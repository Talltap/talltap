(() => {
  // node_modules/orderedmap/dist/index.js
  function OrderedMap(content) {
    this.content = content;
  }
  OrderedMap.prototype = {
    constructor: OrderedMap,
    find: function(key) {
      for (var i = 0; i < this.content.length; i += 2)
        if (this.content[i] === key)
          return i;
      return -1;
    },
    // :: (string) → ?any
    // Retrieve the value stored under `key`, or return undefined when
    // no such key exists.
    get: function(key) {
      var found2 = this.find(key);
      return found2 == -1 ? void 0 : this.content[found2 + 1];
    },
    // :: (string, any, ?string) → OrderedMap
    // Create a new map by replacing the value of `key` with a new
    // value, or adding a binding to the end of the map. If `newKey` is
    // given, the key of the binding will be replaced with that key.
    update: function(key, value, newKey) {
      var self = newKey && newKey != key ? this.remove(newKey) : this;
      var found2 = self.find(key), content = self.content.slice();
      if (found2 == -1) {
        content.push(newKey || key, value);
      } else {
        content[found2 + 1] = value;
        if (newKey)
          content[found2] = newKey;
      }
      return new OrderedMap(content);
    },
    // :: (string) → OrderedMap
    // Return a map with the given key removed, if it existed.
    remove: function(key) {
      var found2 = this.find(key);
      if (found2 == -1)
        return this;
      var content = this.content.slice();
      content.splice(found2, 2);
      return new OrderedMap(content);
    },
    // :: (string, any) → OrderedMap
    // Add a new key to the start of the map.
    addToStart: function(key, value) {
      return new OrderedMap([key, value].concat(this.remove(key).content));
    },
    // :: (string, any) → OrderedMap
    // Add a new key to the end of the map.
    addToEnd: function(key, value) {
      var content = this.remove(key).content.slice();
      content.push(key, value);
      return new OrderedMap(content);
    },
    // :: (string, string, any) → OrderedMap
    // Add a key after the given key. If `place` is not found, the new
    // key is added to the end.
    addBefore: function(place, key, value) {
      var without = this.remove(key), content = without.content.slice();
      var found2 = without.find(place);
      content.splice(found2 == -1 ? content.length : found2, 0, key, value);
      return new OrderedMap(content);
    },
    // :: ((key: string, value: any))
    // Call the given function for each key/value pair in the map, in
    // order.
    forEach: function(f) {
      for (var i = 0; i < this.content.length; i += 2)
        f(this.content[i], this.content[i + 1]);
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a new map by prepending the keys in this map that don't
    // appear in `map` before the keys in `map`.
    prepend: function(map2) {
      map2 = OrderedMap.from(map2);
      if (!map2.size)
        return this;
      return new OrderedMap(map2.content.concat(this.subtract(map2).content));
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a new map by appending the keys in this map that don't
    // appear in `map` after the keys in `map`.
    append: function(map2) {
      map2 = OrderedMap.from(map2);
      if (!map2.size)
        return this;
      return new OrderedMap(this.subtract(map2).content.concat(map2.content));
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a map containing all the keys in this map that don't
    // appear in `map`.
    subtract: function(map2) {
      var result = this;
      map2 = OrderedMap.from(map2);
      for (var i = 0; i < map2.content.length; i += 2)
        result = result.remove(map2.content[i]);
      return result;
    },
    // :: () → Object
    // Turn ordered map into a plain object.
    toObject: function() {
      var result = {};
      this.forEach(function(key, value) {
        result[key] = value;
      });
      return result;
    },
    // :: number
    // The amount of keys in this map.
    get size() {
      return this.content.length >> 1;
    }
  };
  OrderedMap.from = function(value) {
    if (value instanceof OrderedMap)
      return value;
    var content = [];
    if (value)
      for (var prop in value)
        content.push(prop, value[prop]);
    return new OrderedMap(content);
  };
  var dist_default = OrderedMap;

  // node_modules/prosemirror-model/dist/index.js
  function findDiffStart(a, b, pos) {
    for (let i = 0; ; i++) {
      if (i == a.childCount || i == b.childCount)
        return a.childCount == b.childCount ? null : pos;
      let childA = a.child(i), childB = b.child(i);
      if (childA == childB) {
        pos += childA.nodeSize;
        continue;
      }
      if (!childA.sameMarkup(childB))
        return pos;
      if (childA.isText && childA.text != childB.text) {
        for (let j = 0; childA.text[j] == childB.text[j]; j++)
          pos++;
        return pos;
      }
      if (childA.content.size || childB.content.size) {
        let inner = findDiffStart(childA.content, childB.content, pos + 1);
        if (inner != null)
          return inner;
      }
      pos += childA.nodeSize;
    }
  }
  function findDiffEnd(a, b, posA, posB) {
    for (let iA = a.childCount, iB = b.childCount; ; ) {
      if (iA == 0 || iB == 0)
        return iA == iB ? null : { a: posA, b: posB };
      let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
      if (childA == childB) {
        posA -= size;
        posB -= size;
        continue;
      }
      if (!childA.sameMarkup(childB))
        return { a: posA, b: posB };
      if (childA.isText && childA.text != childB.text) {
        let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
        while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
          same++;
          posA--;
          posB--;
        }
        return { a: posA, b: posB };
      }
      if (childA.content.size || childB.content.size) {
        let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
        if (inner)
          return inner;
      }
      posA -= size;
      posB -= size;
    }
  }
  var Fragment = class _Fragment {
    /**
    @internal
    */
    constructor(content, size) {
      this.content = content;
      this.size = size || 0;
      if (size == null)
        for (let i = 0; i < content.length; i++)
          this.size += content[i].nodeSize;
    }
    /**
    Invoke a callback for all descendant nodes between the given two
    positions (relative to start of this fragment). Doesn't descend
    into a node when the callback returns `false`.
    */
    nodesBetween(from2, to, f, nodeStart = 0, parent) {
      for (let i = 0, pos = 0; pos < to; i++) {
        let child = this.content[i], end2 = pos + child.nodeSize;
        if (end2 > from2 && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
          let start2 = pos + 1;
          child.nodesBetween(Math.max(0, from2 - start2), Math.min(child.content.size, to - start2), f, nodeStart + start2);
        }
        pos = end2;
      }
    }
    /**
    Call the given callback for every descendant node. `pos` will be
    relative to the start of the fragment. The callback may return
    `false` to prevent traversal of a given node's children.
    */
    descendants(f) {
      this.nodesBetween(0, this.size, f);
    }
    /**
    Extract the text between `from` and `to`. See the same method on
    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
    */
    textBetween(from2, to, blockSeparator, leafText) {
      let text = "", separated = true;
      this.nodesBetween(from2, to, (node, pos) => {
        if (node.isText) {
          text += node.text.slice(Math.max(from2, pos) - pos, to - pos);
          separated = !blockSeparator;
        } else if (node.isLeaf) {
          if (leafText) {
            text += typeof leafText === "function" ? leafText(node) : leafText;
          } else if (node.type.spec.leafText) {
            text += node.type.spec.leafText(node);
          }
          separated = !blockSeparator;
        } else if (!separated && node.isBlock) {
          text += blockSeparator;
          separated = true;
        }
      }, 0);
      return text;
    }
    /**
    Create a new fragment containing the combined content of this
    fragment and the other.
    */
    append(other) {
      if (!other.size)
        return this;
      if (!this.size)
        return other;
      let last = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i = 0;
      if (last.isText && last.sameMarkup(first2)) {
        content[content.length - 1] = last.withText(last.text + first2.text);
        i = 1;
      }
      for (; i < other.content.length; i++)
        content.push(other.content[i]);
      return new _Fragment(content, this.size + other.size);
    }
    /**
    Cut out the sub-fragment between the two given positions.
    */
    cut(from2, to = this.size) {
      if (from2 == 0 && to == this.size)
        return this;
      let result = [], size = 0;
      if (to > from2)
        for (let i = 0, pos = 0; pos < to; i++) {
          let child = this.content[i], end2 = pos + child.nodeSize;
          if (end2 > from2) {
            if (pos < from2 || end2 > to) {
              if (child.isText)
                child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
              else
                child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
            }
            result.push(child);
            size += child.nodeSize;
          }
          pos = end2;
        }
      return new _Fragment(result, size);
    }
    /**
    @internal
    */
    cutByIndex(from2, to) {
      if (from2 == to)
        return _Fragment.empty;
      if (from2 == 0 && to == this.content.length)
        return this;
      return new _Fragment(this.content.slice(from2, to));
    }
    /**
    Create a new fragment in which the node at the given index is
    replaced by the given node.
    */
    replaceChild(index, node) {
      let current = this.content[index];
      if (current == node)
        return this;
      let copy2 = this.content.slice();
      let size = this.size + node.nodeSize - current.nodeSize;
      copy2[index] = node;
      return new _Fragment(copy2, size);
    }
    /**
    Create a new fragment by prepending the given node to this
    fragment.
    */
    addToStart(node) {
      return new _Fragment([node].concat(this.content), this.size + node.nodeSize);
    }
    /**
    Create a new fragment by appending the given node to this
    fragment.
    */
    addToEnd(node) {
      return new _Fragment(this.content.concat(node), this.size + node.nodeSize);
    }
    /**
    Compare this fragment to another one.
    */
    eq(other) {
      if (this.content.length != other.content.length)
        return false;
      for (let i = 0; i < this.content.length; i++)
        if (!this.content[i].eq(other.content[i]))
          return false;
      return true;
    }
    /**
    The first child of the fragment, or `null` if it is empty.
    */
    get firstChild() {
      return this.content.length ? this.content[0] : null;
    }
    /**
    The last child of the fragment, or `null` if it is empty.
    */
    get lastChild() {
      return this.content.length ? this.content[this.content.length - 1] : null;
    }
    /**
    The number of child nodes in this fragment.
    */
    get childCount() {
      return this.content.length;
    }
    /**
    Get the child node at the given index. Raise an error when the
    index is out of range.
    */
    child(index) {
      let found2 = this.content[index];
      if (!found2)
        throw new RangeError("Index " + index + " out of range for " + this);
      return found2;
    }
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(index) {
      return this.content[index] || null;
    }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(f) {
      for (let i = 0, p = 0; i < this.content.length; i++) {
        let child = this.content[i];
        f(child, p, i);
        p += child.nodeSize;
      }
    }
    /**
    Find the first position at which this fragment and another
    fragment differ, or `null` if they are the same.
    */
    findDiffStart(other, pos = 0) {
      return findDiffStart(this, other, pos);
    }
    /**
    Find the first position, searching from the end, at which this
    fragment and the given fragment differ, or `null` if they are
    the same. Since this position will not be the same in both
    nodes, an object with two separate positions is returned.
    */
    findDiffEnd(other, pos = this.size, otherPos = other.size) {
      return findDiffEnd(this, other, pos, otherPos);
    }
    /**
    Find the index and inner offset corresponding to a given relative
    position in this fragment. The result object will be reused
    (overwritten) the next time the function is called. (Not public.)
    */
    findIndex(pos, round2 = -1) {
      if (pos == 0)
        return retIndex(0, pos);
      if (pos == this.size)
        return retIndex(this.content.length, pos);
      if (pos > this.size || pos < 0)
        throw new RangeError(`Position ${pos} outside of fragment (${this})`);
      for (let i = 0, curPos = 0; ; i++) {
        let cur = this.child(i), end2 = curPos + cur.nodeSize;
        if (end2 >= pos) {
          if (end2 == pos || round2 > 0)
            return retIndex(i + 1, end2);
          return retIndex(i, curPos);
        }
        curPos = end2;
      }
    }
    /**
    Return a debugging string that describes this fragment.
    */
    toString() {
      return "<" + this.toStringInner() + ">";
    }
    /**
    @internal
    */
    toStringInner() {
      return this.content.join(", ");
    }
    /**
    Create a JSON-serializeable representation of this fragment.
    */
    toJSON() {
      return this.content.length ? this.content.map((n) => n.toJSON()) : null;
    }
    /**
    Deserialize a fragment from its JSON representation.
    */
    static fromJSON(schema, value) {
      if (!value)
        return _Fragment.empty;
      if (!Array.isArray(value))
        throw new RangeError("Invalid input for Fragment.fromJSON");
      return new _Fragment(value.map(schema.nodeFromJSON));
    }
    /**
    Build a fragment from an array of nodes. Ensures that adjacent
    text nodes with the same marks are joined together.
    */
    static fromArray(array) {
      if (!array.length)
        return _Fragment.empty;
      let joined, size = 0;
      for (let i = 0; i < array.length; i++) {
        let node = array[i];
        size += node.nodeSize;
        if (i && node.isText && array[i - 1].sameMarkup(node)) {
          if (!joined)
            joined = array.slice(0, i);
          joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
        } else if (joined) {
          joined.push(node);
        }
      }
      return new _Fragment(joined || array, size);
    }
    /**
    Create a fragment from something that can be interpreted as a
    set of nodes. For `null`, it returns the empty fragment. For a
    fragment, the fragment itself. For a node or array of nodes, a
    fragment containing those nodes.
    */
    static from(nodes) {
      if (!nodes)
        return _Fragment.empty;
      if (nodes instanceof _Fragment)
        return nodes;
      if (Array.isArray(nodes))
        return this.fromArray(nodes);
      if (nodes.attrs)
        return new _Fragment([nodes], nodes.nodeSize);
      throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
    }
  };
  Fragment.empty = new Fragment([], 0);
  var found = { index: 0, offset: 0 };
  function retIndex(index, offset2) {
    found.index = index;
    found.offset = offset2;
    return found;
  }
  function compareDeep(a, b) {
    if (a === b)
      return true;
    if (!(a && typeof a == "object") || !(b && typeof b == "object"))
      return false;
    let array = Array.isArray(a);
    if (Array.isArray(b) != array)
      return false;
    if (array) {
      if (a.length != b.length)
        return false;
      for (let i = 0; i < a.length; i++)
        if (!compareDeep(a[i], b[i]))
          return false;
    } else {
      for (let p in a)
        if (!(p in b) || !compareDeep(a[p], b[p]))
          return false;
      for (let p in b)
        if (!(p in a))
          return false;
    }
    return true;
  }
  var Mark = class _Mark {
    /**
    @internal
    */
    constructor(type, attrs) {
      this.type = type;
      this.attrs = attrs;
    }
    /**
    Given a set of marks, create a new set which contains this one as
    well, in the right position. If this mark is already in the set,
    the set itself is returned. If any marks that are set to be
    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
    those are replaced by this one.
    */
    addToSet(set) {
      let copy2, placed = false;
      for (let i = 0; i < set.length; i++) {
        let other = set[i];
        if (this.eq(other))
          return set;
        if (this.type.excludes(other.type)) {
          if (!copy2)
            copy2 = set.slice(0, i);
        } else if (other.type.excludes(this.type)) {
          return set;
        } else {
          if (!placed && other.type.rank > this.type.rank) {
            if (!copy2)
              copy2 = set.slice(0, i);
            copy2.push(this);
            placed = true;
          }
          if (copy2)
            copy2.push(other);
        }
      }
      if (!copy2)
        copy2 = set.slice();
      if (!placed)
        copy2.push(this);
      return copy2;
    }
    /**
    Remove this mark from the given set, returning a new set. If this
    mark is not in the set, the set itself is returned.
    */
    removeFromSet(set) {
      for (let i = 0; i < set.length; i++)
        if (this.eq(set[i]))
          return set.slice(0, i).concat(set.slice(i + 1));
      return set;
    }
    /**
    Test whether this mark is in the given set of marks.
    */
    isInSet(set) {
      for (let i = 0; i < set.length; i++)
        if (this.eq(set[i]))
          return true;
      return false;
    }
    /**
    Test whether this mark has the same type and attributes as
    another mark.
    */
    eq(other) {
      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
    }
    /**
    Convert this mark to a JSON-serializeable representation.
    */
    toJSON() {
      let obj = { type: this.type.name };
      for (let _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      return obj;
    }
    /**
    Deserialize a mark from JSON.
    */
    static fromJSON(schema, json) {
      if (!json)
        throw new RangeError("Invalid input for Mark.fromJSON");
      let type = schema.marks[json.type];
      if (!type)
        throw new RangeError(`There is no mark type ${json.type} in this schema`);
      return type.create(json.attrs);
    }
    /**
    Test whether two sets of marks are identical.
    */
    static sameSet(a, b) {
      if (a == b)
        return true;
      if (a.length != b.length)
        return false;
      for (let i = 0; i < a.length; i++)
        if (!a[i].eq(b[i]))
          return false;
      return true;
    }
    /**
    Create a properly sorted mark set from null, a single mark, or an
    unsorted array of marks.
    */
    static setFrom(marks) {
      if (!marks || Array.isArray(marks) && marks.length == 0)
        return _Mark.none;
      if (marks instanceof _Mark)
        return [marks];
      let copy2 = marks.slice();
      copy2.sort((a, b) => a.type.rank - b.type.rank);
      return copy2;
    }
  };
  Mark.none = [];
  var ReplaceError = class extends Error {
  };
  var Slice = class _Slice {
    /**
    Create a slice. When specifying a non-zero open depth, you must
    make sure that there are nodes of at least that depth at the
    appropriate side of the fragment—i.e. if the fragment is an
    empty paragraph node, `openStart` and `openEnd` can't be greater
    than 1.
    
    It is not necessary for the content of open nodes to conform to
    the schema's content constraints, though it should be a valid
    start/end/middle for such a node, depending on which sides are
    open.
    */
    constructor(content, openStart, openEnd) {
      this.content = content;
      this.openStart = openStart;
      this.openEnd = openEnd;
    }
    /**
    The size this slice would add when inserted into a document.
    */
    get size() {
      return this.content.size - this.openStart - this.openEnd;
    }
    /**
    @internal
    */
    insertAt(pos, fragment) {
      let content = insertInto(this.content, pos + this.openStart, fragment);
      return content && new _Slice(content, this.openStart, this.openEnd);
    }
    /**
    @internal
    */
    removeBetween(from2, to) {
      return new _Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
    }
    /**
    Tests whether this slice is equal to another slice.
    */
    eq(other) {
      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
    }
    /**
    @internal
    */
    toString() {
      return this.content + "(" + this.openStart + "," + this.openEnd + ")";
    }
    /**
    Convert a slice to a JSON-serializable representation.
    */
    toJSON() {
      if (!this.content.size)
        return null;
      let json = { content: this.content.toJSON() };
      if (this.openStart > 0)
        json.openStart = this.openStart;
      if (this.openEnd > 0)
        json.openEnd = this.openEnd;
      return json;
    }
    /**
    Deserialize a slice from its JSON representation.
    */
    static fromJSON(schema, json) {
      if (!json)
        return _Slice.empty;
      let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
      if (typeof openStart != "number" || typeof openEnd != "number")
        throw new RangeError("Invalid input for Slice.fromJSON");
      return new _Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
    }
    /**
    Create a slice from a fragment by taking the maximum possible
    open value on both side of the fragment.
    */
    static maxOpen(fragment, openIsolating = true) {
      let openStart = 0, openEnd = 0;
      for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
        openStart++;
      for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
        openEnd++;
      return new _Slice(fragment, openStart, openEnd);
    }
  };
  Slice.empty = new Slice(Fragment.empty, 0, 0);
  function removeRange(content, from2, to) {
    let { index, offset: offset2 } = content.findIndex(from2), child = content.maybeChild(index);
    let { index: indexTo, offset: offsetTo } = content.findIndex(to);
    if (offset2 == from2 || child.isText) {
      if (offsetTo != to && !content.child(indexTo).isText)
        throw new RangeError("Removing non-flat range");
      return content.cut(0, from2).append(content.cut(to));
    }
    if (index != indexTo)
      throw new RangeError("Removing non-flat range");
    return content.replaceChild(index, child.copy(removeRange(child.content, from2 - offset2 - 1, to - offset2 - 1)));
  }
  function insertInto(content, dist, insert, parent) {
    let { index, offset: offset2 } = content.findIndex(dist), child = content.maybeChild(index);
    if (offset2 == dist || child.isText) {
      if (parent && !parent.canReplace(index, index, insert))
        return null;
      return content.cut(0, dist).append(insert).append(content.cut(dist));
    }
    let inner = insertInto(child.content, dist - offset2 - 1, insert);
    return inner && content.replaceChild(index, child.copy(inner));
  }
  function replace($from, $to, slice2) {
    if (slice2.openStart > $from.depth)
      throw new ReplaceError("Inserted content deeper than insertion position");
    if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
      throw new ReplaceError("Inconsistent open depths");
    return replaceOuter($from, $to, slice2, 0);
  }
  function replaceOuter($from, $to, slice2, depth) {
    let index = $from.index(depth), node = $from.node(depth);
    if (index == $to.index(depth) && depth < $from.depth - slice2.openStart) {
      let inner = replaceOuter($from, $to, slice2, depth + 1);
      return node.copy(node.content.replaceChild(index, inner));
    } else if (!slice2.content.size) {
      return close(node, replaceTwoWay($from, $to, depth));
    } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
      let parent = $from.parent, content = parent.content;
      return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
    } else {
      let { start: start2, end: end2 } = prepareSliceForReplace(slice2, $from);
      return close(node, replaceThreeWay($from, start2, end2, $to, depth));
    }
  }
  function checkJoin(main2, sub) {
    if (!sub.type.compatibleContent(main2.type))
      throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main2.type.name);
  }
  function joinable($before, $after, depth) {
    let node = $before.node(depth);
    checkJoin(node, $after.node(depth));
    return node;
  }
  function addNode(child, target) {
    let last = target.length - 1;
    if (last >= 0 && child.isText && child.sameMarkup(target[last]))
      target[last] = child.withText(target[last].text + child.text);
    else
      target.push(child);
  }
  function addRange($start, $end, depth, target) {
    let node = ($end || $start).node(depth);
    let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
    if ($start) {
      startIndex = $start.index(depth);
      if ($start.depth > depth) {
        startIndex++;
      } else if ($start.textOffset) {
        addNode($start.nodeAfter, target);
        startIndex++;
      }
    }
    for (let i = startIndex; i < endIndex; i++)
      addNode(node.child(i), target);
    if ($end && $end.depth == depth && $end.textOffset)
      addNode($end.nodeBefore, target);
  }
  function close(node, content) {
    node.type.checkContent(content);
    return node.copy(content);
  }
  function replaceThreeWay($from, $start, $end, $to, depth) {
    let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
    let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
    let content = [];
    addRange(null, $from, depth, content);
    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
      checkJoin(openStart, openEnd);
      addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
    } else {
      if (openStart)
        addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
      addRange($start, $end, depth, content);
      if (openEnd)
        addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
    }
    addRange($to, null, depth, content);
    return new Fragment(content);
  }
  function replaceTwoWay($from, $to, depth) {
    let content = [];
    addRange(null, $from, depth, content);
    if ($from.depth > depth) {
      let type = joinable($from, $to, depth + 1);
      addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
    }
    addRange($to, null, depth, content);
    return new Fragment(content);
  }
  function prepareSliceForReplace(slice2, $along) {
    let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
    let node = parent.copy(slice2.content);
    for (let i = extra - 1; i >= 0; i--)
      node = $along.node(i).copy(Fragment.from(node));
    return {
      start: node.resolveNoCache(slice2.openStart + extra),
      end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)
    };
  }
  var ResolvedPos = class _ResolvedPos {
    /**
    @internal
    */
    constructor(pos, path, parentOffset) {
      this.pos = pos;
      this.path = path;
      this.parentOffset = parentOffset;
      this.depth = path.length / 3 - 1;
    }
    /**
    @internal
    */
    resolveDepth(val) {
      if (val == null)
        return this.depth;
      if (val < 0)
        return this.depth + val;
      return val;
    }
    /**
    The parent node that the position points into. Note that even if
    a position points into a text node, that node is not considered
    the parent—text nodes are ‘flat’ in this model, and have no content.
    */
    get parent() {
      return this.node(this.depth);
    }
    /**
    The root node in which the position was resolved.
    */
    get doc() {
      return this.node(0);
    }
    /**
    The ancestor node at the given level. `p.node(p.depth)` is the
    same as `p.parent`.
    */
    node(depth) {
      return this.path[this.resolveDepth(depth) * 3];
    }
    /**
    The index into the ancestor at the given level. If this points
    at the 3rd node in the 2nd paragraph on the top level, for
    example, `p.index(0)` is 1 and `p.index(1)` is 2.
    */
    index(depth) {
      return this.path[this.resolveDepth(depth) * 3 + 1];
    }
    /**
    The index pointing after this position into the ancestor at the
    given level.
    */
    indexAfter(depth) {
      depth = this.resolveDepth(depth);
      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
    }
    /**
    The (absolute) position at the start of the node at the given
    level.
    */
    start(depth) {
      depth = this.resolveDepth(depth);
      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    }
    /**
    The (absolute) position at the end of the node at the given
    level.
    */
    end(depth) {
      depth = this.resolveDepth(depth);
      return this.start(depth) + this.node(depth).content.size;
    }
    /**
    The (absolute) position directly before the wrapping node at the
    given level, or, when `depth` is `this.depth + 1`, the original
    position.
    */
    before(depth) {
      depth = this.resolveDepth(depth);
      if (!depth)
        throw new RangeError("There is no position before the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
    }
    /**
    The (absolute) position directly after the wrapping node at the
    given level, or the original position when `depth` is `this.depth + 1`.
    */
    after(depth) {
      depth = this.resolveDepth(depth);
      if (!depth)
        throw new RangeError("There is no position after the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
    }
    /**
    When this position points into a text node, this returns the
    distance between the position and the start of the text node.
    Will be zero for positions that point between nodes.
    */
    get textOffset() {
      return this.pos - this.path[this.path.length - 1];
    }
    /**
    Get the node directly after the position, if any. If the position
    points into a text node, only the part of that node after the
    position is returned.
    */
    get nodeAfter() {
      let parent = this.parent, index = this.index(this.depth);
      if (index == parent.childCount)
        return null;
      let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
      return dOff ? parent.child(index).cut(dOff) : child;
    }
    /**
    Get the node directly before the position, if any. If the
    position points into a text node, only the part of that node
    before the position is returned.
    */
    get nodeBefore() {
      let index = this.index(this.depth);
      let dOff = this.pos - this.path[this.path.length - 1];
      if (dOff)
        return this.parent.child(index).cut(0, dOff);
      return index == 0 ? null : this.parent.child(index - 1);
    }
    /**
    Get the position at the given index in the parent node at the
    given depth (which defaults to `this.depth`).
    */
    posAtIndex(index, depth) {
      depth = this.resolveDepth(depth);
      let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
      for (let i = 0; i < index; i++)
        pos += node.child(i).nodeSize;
      return pos;
    }
    /**
    Get the marks at this position, factoring in the surrounding
    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
    position is at the start of a non-empty node, the marks of the
    node after it (if any) are returned.
    */
    marks() {
      let parent = this.parent, index = this.index();
      if (parent.content.size == 0)
        return Mark.none;
      if (this.textOffset)
        return parent.child(index).marks;
      let main2 = parent.maybeChild(index - 1), other = parent.maybeChild(index);
      if (!main2) {
        let tmp = main2;
        main2 = other;
        other = tmp;
      }
      let marks = main2.marks;
      for (var i = 0; i < marks.length; i++)
        if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
          marks = marks[i--].removeFromSet(marks);
      return marks;
    }
    /**
    Get the marks after the current position, if any, except those
    that are non-inclusive and not present at position `$end`. This
    is mostly useful for getting the set of marks to preserve after a
    deletion. Will return `null` if this position is at the end of
    its parent node or its parent node isn't a textblock (in which
    case no marks should be preserved).
    */
    marksAcross($end) {
      let after = this.parent.maybeChild(this.index());
      if (!after || !after.isInline)
        return null;
      let marks = after.marks, next = $end.parent.maybeChild($end.index());
      for (var i = 0; i < marks.length; i++)
        if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
          marks = marks[i--].removeFromSet(marks);
      return marks;
    }
    /**
    The depth up to which this position and the given (non-resolved)
    position share the same parent nodes.
    */
    sharedDepth(pos) {
      for (let depth = this.depth; depth > 0; depth--)
        if (this.start(depth) <= pos && this.end(depth) >= pos)
          return depth;
      return 0;
    }
    /**
    Returns a range based on the place where this position and the
    given position diverge around block content. If both point into
    the same textblock, for example, a range around that textblock
    will be returned. If they point into different blocks, the range
    around those blocks in their shared ancestor is returned. You can
    pass in an optional predicate that will be called with a parent
    node to see if a range into that parent is acceptable.
    */
    blockRange(other = this, pred) {
      if (other.pos < this.pos)
        return other.blockRange(this);
      for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
        if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
          return new NodeRange(this, other, d);
      return null;
    }
    /**
    Query whether the given position shares the same parent node.
    */
    sameParent(other) {
      return this.pos - this.parentOffset == other.pos - other.parentOffset;
    }
    /**
    Return the greater of this and the given position.
    */
    max(other) {
      return other.pos > this.pos ? other : this;
    }
    /**
    Return the smaller of this and the given position.
    */
    min(other) {
      return other.pos < this.pos ? other : this;
    }
    /**
    @internal
    */
    toString() {
      let str = "";
      for (let i = 1; i <= this.depth; i++)
        str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
      return str + ":" + this.parentOffset;
    }
    /**
    @internal
    */
    static resolve(doc3, pos) {
      if (!(pos >= 0 && pos <= doc3.content.size))
        throw new RangeError("Position " + pos + " out of range");
      let path = [];
      let start2 = 0, parentOffset = pos;
      for (let node = doc3; ; ) {
        let { index, offset: offset2 } = node.content.findIndex(parentOffset);
        let rem = parentOffset - offset2;
        path.push(node, index, start2 + offset2);
        if (!rem)
          break;
        node = node.child(index);
        if (node.isText)
          break;
        parentOffset = rem - 1;
        start2 += offset2 + 1;
      }
      return new _ResolvedPos(pos, path, parentOffset);
    }
    /**
    @internal
    */
    static resolveCached(doc3, pos) {
      for (let i = 0; i < resolveCache.length; i++) {
        let cached = resolveCache[i];
        if (cached.pos == pos && cached.doc == doc3)
          return cached;
      }
      let result = resolveCache[resolveCachePos] = _ResolvedPos.resolve(doc3, pos);
      resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
      return result;
    }
  };
  var resolveCache = [];
  var resolveCachePos = 0;
  var resolveCacheSize = 12;
  var NodeRange = class {
    /**
    Construct a node range. `$from` and `$to` should point into the
    same node until at least the given `depth`, since a node range
    denotes an adjacent set of nodes in a single parent node.
    */
    constructor($from, $to, depth) {
      this.$from = $from;
      this.$to = $to;
      this.depth = depth;
    }
    /**
    The position at the start of the range.
    */
    get start() {
      return this.$from.before(this.depth + 1);
    }
    /**
    The position at the end of the range.
    */
    get end() {
      return this.$to.after(this.depth + 1);
    }
    /**
    The parent node that the range points into.
    */
    get parent() {
      return this.$from.node(this.depth);
    }
    /**
    The start index of the range in the parent node.
    */
    get startIndex() {
      return this.$from.index(this.depth);
    }
    /**
    The end index of the range in the parent node.
    */
    get endIndex() {
      return this.$to.indexAfter(this.depth);
    }
  };
  var emptyAttrs = /* @__PURE__ */ Object.create(null);
  var Node = class _Node {
    /**
    @internal
    */
    constructor(type, attrs, content, marks = Mark.none) {
      this.type = type;
      this.attrs = attrs;
      this.marks = marks;
      this.content = content || Fragment.empty;
    }
    /**
    The size of this node, as defined by the integer-based [indexing
    scheme](/docs/guide/#doc.indexing). For text nodes, this is the
    amount of characters. For other leaf nodes, it is one. For
    non-leaf nodes, it is the size of the content plus two (the
    start and end token).
    */
    get nodeSize() {
      return this.isLeaf ? 1 : 2 + this.content.size;
    }
    /**
    The number of children that the node has.
    */
    get childCount() {
      return this.content.childCount;
    }
    /**
    Get the child node at the given index. Raises an error when the
    index is out of range.
    */
    child(index) {
      return this.content.child(index);
    }
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(index) {
      return this.content.maybeChild(index);
    }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(f) {
      this.content.forEach(f);
    }
    /**
    Invoke a callback for all descendant nodes recursively between
    the given two positions that are relative to start of this
    node's content. The callback is invoked with the node, its
    position relative to the original node (method receiver),
    its parent node, and its child index. When the callback returns
    false for a given node, that node's children will not be
    recursed over. The last parameter can be used to specify a
    starting position to count from.
    */
    nodesBetween(from2, to, f, startPos = 0) {
      this.content.nodesBetween(from2, to, f, startPos, this);
    }
    /**
    Call the given callback for every descendant node. Doesn't
    descend into a node when the callback returns `false`.
    */
    descendants(f) {
      this.nodesBetween(0, this.content.size, f);
    }
    /**
    Concatenates all the text nodes found in this fragment and its
    children.
    */
    get textContent() {
      return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
    }
    /**
    Get all text between positions `from` and `to`. When
    `blockSeparator` is given, it will be inserted to separate text
    from different block nodes. If `leafText` is given, it'll be
    inserted for every non-text leaf node encountered, otherwise
    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
    */
    textBetween(from2, to, blockSeparator, leafText) {
      return this.content.textBetween(from2, to, blockSeparator, leafText);
    }
    /**
    Returns this node's first child, or `null` if there are no
    children.
    */
    get firstChild() {
      return this.content.firstChild;
    }
    /**
    Returns this node's last child, or `null` if there are no
    children.
    */
    get lastChild() {
      return this.content.lastChild;
    }
    /**
    Test whether two nodes represent the same piece of document.
    */
    eq(other) {
      return this == other || this.sameMarkup(other) && this.content.eq(other.content);
    }
    /**
    Compare the markup (type, attributes, and marks) of this node to
    those of another. Returns `true` if both have the same markup.
    */
    sameMarkup(other) {
      return this.hasMarkup(other.type, other.attrs, other.marks);
    }
    /**
    Check whether this node's markup correspond to the given type,
    attributes, and marks.
    */
    hasMarkup(type, attrs, marks) {
      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
    }
    /**
    Create a new node with the same markup as this node, containing
    the given content (or empty, if no content is given).
    */
    copy(content = null) {
      if (content == this.content)
        return this;
      return new _Node(this.type, this.attrs, content, this.marks);
    }
    /**
    Create a copy of this node, with the given set of marks instead
    of the node's own marks.
    */
    mark(marks) {
      return marks == this.marks ? this : new _Node(this.type, this.attrs, this.content, marks);
    }
    /**
    Create a copy of this node with only the content between the
    given positions. If `to` is not given, it defaults to the end of
    the node.
    */
    cut(from2, to = this.content.size) {
      if (from2 == 0 && to == this.content.size)
        return this;
      return this.copy(this.content.cut(from2, to));
    }
    /**
    Cut out the part of the document between the given positions, and
    return it as a `Slice` object.
    */
    slice(from2, to = this.content.size, includeParents = false) {
      if (from2 == to)
        return Slice.empty;
      let $from = this.resolve(from2), $to = this.resolve(to);
      let depth = includeParents ? 0 : $from.sharedDepth(to);
      let start2 = $from.start(depth), node = $from.node(depth);
      let content = node.content.cut($from.pos - start2, $to.pos - start2);
      return new Slice(content, $from.depth - depth, $to.depth - depth);
    }
    /**
    Replace the part of the document between the given positions with
    the given slice. The slice must 'fit', meaning its open sides
    must be able to connect to the surrounding content, and its
    content nodes must be valid children for the node they are placed
    into. If any of this is violated, an error of type
    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
    */
    replace(from2, to, slice2) {
      return replace(this.resolve(from2), this.resolve(to), slice2);
    }
    /**
    Find the node directly after the given position.
    */
    nodeAt(pos) {
      for (let node = this; ; ) {
        let { index, offset: offset2 } = node.content.findIndex(pos);
        node = node.maybeChild(index);
        if (!node)
          return null;
        if (offset2 == pos || node.isText)
          return node;
        pos -= offset2 + 1;
      }
    }
    /**
    Find the (direct) child node after the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childAfter(pos) {
      let { index, offset: offset2 } = this.content.findIndex(pos);
      return { node: this.content.maybeChild(index), index, offset: offset2 };
    }
    /**
    Find the (direct) child node before the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childBefore(pos) {
      if (pos == 0)
        return { node: null, index: 0, offset: 0 };
      let { index, offset: offset2 } = this.content.findIndex(pos);
      if (offset2 < pos)
        return { node: this.content.child(index), index, offset: offset2 };
      let node = this.content.child(index - 1);
      return { node, index: index - 1, offset: offset2 - node.nodeSize };
    }
    /**
    Resolve the given position in the document, returning an
    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
    */
    resolve(pos) {
      return ResolvedPos.resolveCached(this, pos);
    }
    /**
    @internal
    */
    resolveNoCache(pos) {
      return ResolvedPos.resolve(this, pos);
    }
    /**
    Test whether a given mark or mark type occurs in this document
    between the two given positions.
    */
    rangeHasMark(from2, to, type) {
      let found2 = false;
      if (to > from2)
        this.nodesBetween(from2, to, (node) => {
          if (type.isInSet(node.marks))
            found2 = true;
          return !found2;
        });
      return found2;
    }
    /**
    True when this is a block (non-inline node)
    */
    get isBlock() {
      return this.type.isBlock;
    }
    /**
    True when this is a textblock node, a block node with inline
    content.
    */
    get isTextblock() {
      return this.type.isTextblock;
    }
    /**
    True when this node allows inline content.
    */
    get inlineContent() {
      return this.type.inlineContent;
    }
    /**
    True when this is an inline node (a text node or a node that can
    appear among text).
    */
    get isInline() {
      return this.type.isInline;
    }
    /**
    True when this is a text node.
    */
    get isText() {
      return this.type.isText;
    }
    /**
    True when this is a leaf node.
    */
    get isLeaf() {
      return this.type.isLeaf;
    }
    /**
    True when this is an atom, i.e. when it does not have directly
    editable content. This is usually the same as `isLeaf`, but can
    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
    on a node's spec (typically used when the node is displayed as
    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
    */
    get isAtom() {
      return this.type.isAtom;
    }
    /**
    Return a string representation of this node for debugging
    purposes.
    */
    toString() {
      if (this.type.spec.toDebugString)
        return this.type.spec.toDebugString(this);
      let name = this.type.name;
      if (this.content.size)
        name += "(" + this.content.toStringInner() + ")";
      return wrapMarks(this.marks, name);
    }
    /**
    Get the content match in this node at the given index.
    */
    contentMatchAt(index) {
      let match = this.type.contentMatch.matchFragment(this.content, 0, index);
      if (!match)
        throw new Error("Called contentMatchAt on a node with invalid content");
      return match;
    }
    /**
    Test whether replacing the range between `from` and `to` (by
    child index) with the given replacement fragment (which defaults
    to the empty fragment) would leave the node's content valid. You
    can optionally pass `start` and `end` indices into the
    replacement fragment.
    */
    canReplace(from2, to, replacement = Fragment.empty, start2 = 0, end2 = replacement.childCount) {
      let one = this.contentMatchAt(from2).matchFragment(replacement, start2, end2);
      let two = one && one.matchFragment(this.content, to);
      if (!two || !two.validEnd)
        return false;
      for (let i = start2; i < end2; i++)
        if (!this.type.allowsMarks(replacement.child(i).marks))
          return false;
      return true;
    }
    /**
    Test whether replacing the range `from` to `to` (by index) with
    a node of the given type would leave the node's content valid.
    */
    canReplaceWith(from2, to, type, marks) {
      if (marks && !this.type.allowsMarks(marks))
        return false;
      let start2 = this.contentMatchAt(from2).matchType(type);
      let end2 = start2 && start2.matchFragment(this.content, to);
      return end2 ? end2.validEnd : false;
    }
    /**
    Test whether the given node's content could be appended to this
    node. If that node is empty, this will only return true if there
    is at least one node type that can appear in both nodes (to avoid
    merging completely incompatible nodes).
    */
    canAppend(other) {
      if (other.content.size)
        return this.canReplace(this.childCount, this.childCount, other.content);
      else
        return this.type.compatibleContent(other.type);
    }
    /**
    Check whether this node and its descendants conform to the
    schema, and raise error when they do not.
    */
    check() {
      this.type.checkContent(this.content);
      let copy2 = Mark.none;
      for (let i = 0; i < this.marks.length; i++)
        copy2 = this.marks[i].addToSet(copy2);
      if (!Mark.sameSet(copy2, this.marks))
        throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
      this.content.forEach((node) => node.check());
    }
    /**
    Return a JSON-serializeable representation of this node.
    */
    toJSON() {
      let obj = { type: this.type.name };
      for (let _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      if (this.content.size)
        obj.content = this.content.toJSON();
      if (this.marks.length)
        obj.marks = this.marks.map((n) => n.toJSON());
      return obj;
    }
    /**
    Deserialize a node from its JSON representation.
    */
    static fromJSON(schema, json) {
      if (!json)
        throw new RangeError("Invalid input for Node.fromJSON");
      let marks = null;
      if (json.marks) {
        if (!Array.isArray(json.marks))
          throw new RangeError("Invalid mark data for Node.fromJSON");
        marks = json.marks.map(schema.markFromJSON);
      }
      if (json.type == "text") {
        if (typeof json.text != "string")
          throw new RangeError("Invalid text node in JSON");
        return schema.text(json.text, marks);
      }
      let content = Fragment.fromJSON(schema, json.content);
      return schema.nodeType(json.type).create(json.attrs, content, marks);
    }
  };
  Node.prototype.text = void 0;
  var TextNode = class _TextNode extends Node {
    /**
    @internal
    */
    constructor(type, attrs, content, marks) {
      super(type, attrs, null, marks);
      if (!content)
        throw new RangeError("Empty text nodes are not allowed");
      this.text = content;
    }
    toString() {
      if (this.type.spec.toDebugString)
        return this.type.spec.toDebugString(this);
      return wrapMarks(this.marks, JSON.stringify(this.text));
    }
    get textContent() {
      return this.text;
    }
    textBetween(from2, to) {
      return this.text.slice(from2, to);
    }
    get nodeSize() {
      return this.text.length;
    }
    mark(marks) {
      return marks == this.marks ? this : new _TextNode(this.type, this.attrs, this.text, marks);
    }
    withText(text) {
      if (text == this.text)
        return this;
      return new _TextNode(this.type, this.attrs, text, this.marks);
    }
    cut(from2 = 0, to = this.text.length) {
      if (from2 == 0 && to == this.text.length)
        return this;
      return this.withText(this.text.slice(from2, to));
    }
    eq(other) {
      return this.sameMarkup(other) && this.text == other.text;
    }
    toJSON() {
      let base2 = super.toJSON();
      base2.text = this.text;
      return base2;
    }
  };
  function wrapMarks(marks, str) {
    for (let i = marks.length - 1; i >= 0; i--)
      str = marks[i].type.name + "(" + str + ")";
    return str;
  }
  var ContentMatch = class _ContentMatch {
    /**
    @internal
    */
    constructor(validEnd) {
      this.validEnd = validEnd;
      this.next = [];
      this.wrapCache = [];
    }
    /**
    @internal
    */
    static parse(string, nodeTypes) {
      let stream = new TokenStream(string, nodeTypes);
      if (stream.next == null)
        return _ContentMatch.empty;
      let expr = parseExpr(stream);
      if (stream.next)
        stream.err("Unexpected trailing text");
      let match = dfa(nfa(expr));
      checkForDeadEnds(match, stream);
      return match;
    }
    /**
    Match a node type, returning a match after that node if
    successful.
    */
    matchType(type) {
      for (let i = 0; i < this.next.length; i++)
        if (this.next[i].type == type)
          return this.next[i].next;
      return null;
    }
    /**
    Try to match a fragment. Returns the resulting match when
    successful.
    */
    matchFragment(frag, start2 = 0, end2 = frag.childCount) {
      let cur = this;
      for (let i = start2; cur && i < end2; i++)
        cur = cur.matchType(frag.child(i).type);
      return cur;
    }
    /**
    @internal
    */
    get inlineContent() {
      return this.next.length != 0 && this.next[0].type.isInline;
    }
    /**
    Get the first matching node type at this match position that can
    be generated.
    */
    get defaultType() {
      for (let i = 0; i < this.next.length; i++) {
        let { type } = this.next[i];
        if (!(type.isText || type.hasRequiredAttrs()))
          return type;
      }
      return null;
    }
    /**
    @internal
    */
    compatible(other) {
      for (let i = 0; i < this.next.length; i++)
        for (let j = 0; j < other.next.length; j++)
          if (this.next[i].type == other.next[j].type)
            return true;
      return false;
    }
    /**
    Try to match the given fragment, and if that fails, see if it can
    be made to match by inserting nodes in front of it. When
    successful, return a fragment of inserted nodes (which may be
    empty if nothing had to be inserted). When `toEnd` is true, only
    return a fragment if the resulting match goes to the end of the
    content expression.
    */
    fillBefore(after, toEnd = false, startIndex = 0) {
      let seen = [this];
      function search(match, types) {
        let finished = match.matchFragment(after, startIndex);
        if (finished && (!toEnd || finished.validEnd))
          return Fragment.from(types.map((tp) => tp.createAndFill()));
        for (let i = 0; i < match.next.length; i++) {
          let { type, next } = match.next[i];
          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
            seen.push(next);
            let found2 = search(next, types.concat(type));
            if (found2)
              return found2;
          }
        }
        return null;
      }
      return search(this, []);
    }
    /**
    Find a set of wrapping node types that would allow a node of the
    given type to appear at this position. The result may be empty
    (when it fits directly) and will be null when no such wrapping
    exists.
    */
    findWrapping(target) {
      for (let i = 0; i < this.wrapCache.length; i += 2)
        if (this.wrapCache[i] == target)
          return this.wrapCache[i + 1];
      let computed = this.computeWrapping(target);
      this.wrapCache.push(target, computed);
      return computed;
    }
    /**
    @internal
    */
    computeWrapping(target) {
      let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
      while (active.length) {
        let current = active.shift(), match = current.match;
        if (match.matchType(target)) {
          let result = [];
          for (let obj = current; obj.type; obj = obj.via)
            result.push(obj.type);
          return result.reverse();
        }
        for (let i = 0; i < match.next.length; i++) {
          let { type, next } = match.next[i];
          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
            active.push({ match: type.contentMatch, type, via: current });
            seen[type.name] = true;
          }
        }
      }
      return null;
    }
    /**
    The number of outgoing edges this node has in the finite
    automaton that describes the content expression.
    */
    get edgeCount() {
      return this.next.length;
    }
    /**
    Get the _n_​th outgoing edge from this node in the finite
    automaton that describes the content expression.
    */
    edge(n) {
      if (n >= this.next.length)
        throw new RangeError(`There's no ${n}th edge in this content match`);
      return this.next[n];
    }
    /**
    @internal
    */
    toString() {
      let seen = [];
      function scan(m) {
        seen.push(m);
        for (let i = 0; i < m.next.length; i++)
          if (seen.indexOf(m.next[i].next) == -1)
            scan(m.next[i].next);
      }
      scan(this);
      return seen.map((m, i) => {
        let out = i + (m.validEnd ? "*" : " ") + " ";
        for (let i2 = 0; i2 < m.next.length; i2++)
          out += (i2 ? ", " : "") + m.next[i2].type.name + "->" + seen.indexOf(m.next[i2].next);
        return out;
      }).join("\n");
    }
  };
  ContentMatch.empty = new ContentMatch(true);
  var TokenStream = class {
    constructor(string, nodeTypes) {
      this.string = string;
      this.nodeTypes = nodeTypes;
      this.inline = null;
      this.pos = 0;
      this.tokens = string.split(/\s*(?=\b|\W|$)/);
      if (this.tokens[this.tokens.length - 1] == "")
        this.tokens.pop();
      if (this.tokens[0] == "")
        this.tokens.shift();
    }
    get next() {
      return this.tokens[this.pos];
    }
    eat(tok) {
      return this.next == tok && (this.pos++ || true);
    }
    err(str) {
      throw new SyntaxError(str + " (in content expression '" + this.string + "')");
    }
  };
  function parseExpr(stream) {
    let exprs = [];
    do {
      exprs.push(parseExprSeq(stream));
    } while (stream.eat("|"));
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  }
  function parseExprSeq(stream) {
    let exprs = [];
    do {
      exprs.push(parseExprSubscript(stream));
    } while (stream.next && stream.next != ")" && stream.next != "|");
    return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
  }
  function parseExprSubscript(stream) {
    let expr = parseExprAtom(stream);
    for (; ; ) {
      if (stream.eat("+"))
        expr = { type: "plus", expr };
      else if (stream.eat("*"))
        expr = { type: "star", expr };
      else if (stream.eat("?"))
        expr = { type: "opt", expr };
      else if (stream.eat("{"))
        expr = parseExprRange(stream, expr);
      else
        break;
    }
    return expr;
  }
  function parseNum(stream) {
    if (/\D/.test(stream.next))
      stream.err("Expected number, got '" + stream.next + "'");
    let result = Number(stream.next);
    stream.pos++;
    return result;
  }
  function parseExprRange(stream, expr) {
    let min2 = parseNum(stream), max2 = min2;
    if (stream.eat(",")) {
      if (stream.next != "}")
        max2 = parseNum(stream);
      else
        max2 = -1;
    }
    if (!stream.eat("}"))
      stream.err("Unclosed braced range");
    return { type: "range", min: min2, max: max2, expr };
  }
  function resolveName(stream, name) {
    let types = stream.nodeTypes, type = types[name];
    if (type)
      return [type];
    let result = [];
    for (let typeName in types) {
      let type2 = types[typeName];
      if (type2.groups.indexOf(name) > -1)
        result.push(type2);
    }
    if (result.length == 0)
      stream.err("No node type or group '" + name + "' found");
    return result;
  }
  function parseExprAtom(stream) {
    if (stream.eat("(")) {
      let expr = parseExpr(stream);
      if (!stream.eat(")"))
        stream.err("Missing closing paren");
      return expr;
    } else if (!/\W/.test(stream.next)) {
      let exprs = resolveName(stream, stream.next).map((type) => {
        if (stream.inline == null)
          stream.inline = type.isInline;
        else if (stream.inline != type.isInline)
          stream.err("Mixing inline and block content");
        return { type: "name", value: type };
      });
      stream.pos++;
      return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
    } else {
      stream.err("Unexpected token '" + stream.next + "'");
    }
  }
  function nfa(expr) {
    let nfa2 = [[]];
    connect(compile(expr, 0), node());
    return nfa2;
    function node() {
      return nfa2.push([]) - 1;
    }
    function edge(from2, to, term) {
      let edge2 = { term, to };
      nfa2[from2].push(edge2);
      return edge2;
    }
    function connect(edges, to) {
      edges.forEach((edge2) => edge2.to = to);
    }
    function compile(expr2, from2) {
      if (expr2.type == "choice") {
        return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from2)), []);
      } else if (expr2.type == "seq") {
        for (let i = 0; ; i++) {
          let next = compile(expr2.exprs[i], from2);
          if (i == expr2.exprs.length - 1)
            return next;
          connect(next, from2 = node());
        }
      } else if (expr2.type == "star") {
        let loop = node();
        edge(from2, loop);
        connect(compile(expr2.expr, loop), loop);
        return [edge(loop)];
      } else if (expr2.type == "plus") {
        let loop = node();
        connect(compile(expr2.expr, from2), loop);
        connect(compile(expr2.expr, loop), loop);
        return [edge(loop)];
      } else if (expr2.type == "opt") {
        return [edge(from2)].concat(compile(expr2.expr, from2));
      } else if (expr2.type == "range") {
        let cur = from2;
        for (let i = 0; i < expr2.min; i++) {
          let next = node();
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
        if (expr2.max == -1) {
          connect(compile(expr2.expr, cur), cur);
        } else {
          for (let i = expr2.min; i < expr2.max; i++) {
            let next = node();
            edge(cur, next);
            connect(compile(expr2.expr, cur), next);
            cur = next;
          }
        }
        return [edge(cur)];
      } else if (expr2.type == "name") {
        return [edge(from2, void 0, expr2.value)];
      } else {
        throw new Error("Unknown expr type");
      }
    }
  }
  function cmp(a, b) {
    return b - a;
  }
  function nullFrom(nfa2, node) {
    let result = [];
    scan(node);
    return result.sort(cmp);
    function scan(node2) {
      let edges = nfa2[node2];
      if (edges.length == 1 && !edges[0].term)
        return scan(edges[0].to);
      result.push(node2);
      for (let i = 0; i < edges.length; i++) {
        let { term, to } = edges[i];
        if (!term && result.indexOf(to) == -1)
          scan(to);
      }
    }
  }
  function dfa(nfa2) {
    let labeled = /* @__PURE__ */ Object.create(null);
    return explore(nullFrom(nfa2, 0));
    function explore(states) {
      let out = [];
      states.forEach((node) => {
        nfa2[node].forEach(({ term, to }) => {
          if (!term)
            return;
          let set;
          for (let i = 0; i < out.length; i++)
            if (out[i][0] == term)
              set = out[i][1];
          nullFrom(nfa2, to).forEach((node2) => {
            if (!set)
              out.push([term, set = []]);
            if (set.indexOf(node2) == -1)
              set.push(node2);
          });
        });
      });
      let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
      for (let i = 0; i < out.length; i++) {
        let states2 = out[i][1].sort(cmp);
        state.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
      }
      return state;
    }
  }
  function checkForDeadEnds(match, stream) {
    for (let i = 0, work = [match]; i < work.length; i++) {
      let state = work[i], dead = !state.validEnd, nodes = [];
      for (let j = 0; j < state.next.length; j++) {
        let { type, next } = state.next[j];
        nodes.push(type.name);
        if (dead && !(type.isText || type.hasRequiredAttrs()))
          dead = false;
        if (work.indexOf(next) == -1)
          work.push(next);
      }
      if (dead)
        stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
  function defaultAttrs(attrs) {
    let defaults = /* @__PURE__ */ Object.create(null);
    for (let attrName in attrs) {
      let attr = attrs[attrName];
      if (!attr.hasDefault)
        return null;
      defaults[attrName] = attr.default;
    }
    return defaults;
  }
  function computeAttrs(attrs, value) {
    let built = /* @__PURE__ */ Object.create(null);
    for (let name in attrs) {
      let given = value && value[name];
      if (given === void 0) {
        let attr = attrs[name];
        if (attr.hasDefault)
          given = attr.default;
        else
          throw new RangeError("No value supplied for attribute " + name);
      }
      built[name] = given;
    }
    return built;
  }
  function initAttrs(attrs) {
    let result = /* @__PURE__ */ Object.create(null);
    if (attrs)
      for (let name in attrs)
        result[name] = new Attribute(attrs[name]);
    return result;
  }
  var NodeType = class _NodeType {
    /**
    @internal
    */
    constructor(name, schema, spec) {
      this.name = name;
      this.schema = schema;
      this.spec = spec;
      this.markSet = null;
      this.groups = spec.group ? spec.group.split(" ") : [];
      this.attrs = initAttrs(spec.attrs);
      this.defaultAttrs = defaultAttrs(this.attrs);
      this.contentMatch = null;
      this.inlineContent = null;
      this.isBlock = !(spec.inline || name == "text");
      this.isText = name == "text";
    }
    /**
    True if this is an inline type.
    */
    get isInline() {
      return !this.isBlock;
    }
    /**
    True if this is a textblock type, a block that contains inline
    content.
    */
    get isTextblock() {
      return this.isBlock && this.inlineContent;
    }
    /**
    True for node types that allow no content.
    */
    get isLeaf() {
      return this.contentMatch == ContentMatch.empty;
    }
    /**
    True when this node is an atom, i.e. when it does not have
    directly editable content.
    */
    get isAtom() {
      return this.isLeaf || !!this.spec.atom;
    }
    /**
    The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
    */
    get whitespace() {
      return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
    }
    /**
    Tells you whether this node type has any required attributes.
    */
    hasRequiredAttrs() {
      for (let n in this.attrs)
        if (this.attrs[n].isRequired)
          return true;
      return false;
    }
    /**
    Indicates whether this node allows some of the same content as
    the given node type.
    */
    compatibleContent(other) {
      return this == other || this.contentMatch.compatible(other.contentMatch);
    }
    /**
    @internal
    */
    computeAttrs(attrs) {
      if (!attrs && this.defaultAttrs)
        return this.defaultAttrs;
      else
        return computeAttrs(this.attrs, attrs);
    }
    /**
    Create a `Node` of this type. The given attributes are
    checked and defaulted (you can pass `null` to use the type's
    defaults entirely, if no required attributes exist). `content`
    may be a `Fragment`, a node, an array of nodes, or
    `null`. Similarly `marks` may be `null` to default to the empty
    set of marks.
    */
    create(attrs = null, content, marks) {
      if (this.isText)
        throw new Error("NodeType.create can't construct text nodes");
      return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
    }
    /**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
    against the node type's content restrictions, and throw an error
    if it doesn't match.
    */
    createChecked(attrs = null, content, marks) {
      content = Fragment.from(content);
      this.checkContent(content);
      return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
    }
    /**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
    necessary to add nodes to the start or end of the given fragment
    to make it fit the node. If no fitting wrapping can be found,
    return null. Note that, due to the fact that required nodes can
    always be created, this will always succeed if you pass null or
    `Fragment.empty` as content.
    */
    createAndFill(attrs = null, content, marks) {
      attrs = this.computeAttrs(attrs);
      content = Fragment.from(content);
      if (content.size) {
        let before = this.contentMatch.fillBefore(content);
        if (!before)
          return null;
        content = before.append(content);
      }
      let matched = this.contentMatch.matchFragment(content);
      let after = matched && matched.fillBefore(Fragment.empty, true);
      if (!after)
        return null;
      return new Node(this, attrs, content.append(after), Mark.setFrom(marks));
    }
    /**
    Returns true if the given fragment is valid content for this node
    type with the given attributes.
    */
    validContent(content) {
      let result = this.contentMatch.matchFragment(content);
      if (!result || !result.validEnd)
        return false;
      for (let i = 0; i < content.childCount; i++)
        if (!this.allowsMarks(content.child(i).marks))
          return false;
      return true;
    }
    /**
    Throws a RangeError if the given fragment is not valid content for this
    node type.
    @internal
    */
    checkContent(content) {
      if (!this.validContent(content))
        throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
    }
    /**
    Check whether the given mark type is allowed in this node.
    */
    allowsMarkType(markType) {
      return this.markSet == null || this.markSet.indexOf(markType) > -1;
    }
    /**
    Test whether the given set of marks are allowed in this node.
    */
    allowsMarks(marks) {
      if (this.markSet == null)
        return true;
      for (let i = 0; i < marks.length; i++)
        if (!this.allowsMarkType(marks[i].type))
          return false;
      return true;
    }
    /**
    Removes the marks that are not allowed in this node from the given set.
    */
    allowedMarks(marks) {
      if (this.markSet == null)
        return marks;
      let copy2;
      for (let i = 0; i < marks.length; i++) {
        if (!this.allowsMarkType(marks[i].type)) {
          if (!copy2)
            copy2 = marks.slice(0, i);
        } else if (copy2) {
          copy2.push(marks[i]);
        }
      }
      return !copy2 ? marks : copy2.length ? copy2 : Mark.none;
    }
    /**
    @internal
    */
    static compile(nodes, schema) {
      let result = /* @__PURE__ */ Object.create(null);
      nodes.forEach((name, spec) => result[name] = new _NodeType(name, schema, spec));
      let topType = schema.spec.topNode || "doc";
      if (!result[topType])
        throw new RangeError("Schema is missing its top node type ('" + topType + "')");
      if (!result.text)
        throw new RangeError("Every schema needs a 'text' type");
      for (let _ in result.text.attrs)
        throw new RangeError("The text node type should not have attributes");
      return result;
    }
  };
  var Attribute = class {
    constructor(options) {
      this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
      this.default = options.default;
    }
    get isRequired() {
      return !this.hasDefault;
    }
  };
  var MarkType = class _MarkType {
    /**
    @internal
    */
    constructor(name, rank, schema, spec) {
      this.name = name;
      this.rank = rank;
      this.schema = schema;
      this.spec = spec;
      this.attrs = initAttrs(spec.attrs);
      this.excluded = null;
      let defaults = defaultAttrs(this.attrs);
      this.instance = defaults ? new Mark(this, defaults) : null;
    }
    /**
    Create a mark of this type. `attrs` may be `null` or an object
    containing only some of the mark's attributes. The others, if
    they have defaults, will be added.
    */
    create(attrs = null) {
      if (!attrs && this.instance)
        return this.instance;
      return new Mark(this, computeAttrs(this.attrs, attrs));
    }
    /**
    @internal
    */
    static compile(marks, schema) {
      let result = /* @__PURE__ */ Object.create(null), rank = 0;
      marks.forEach((name, spec) => result[name] = new _MarkType(name, rank++, schema, spec));
      return result;
    }
    /**
    When there is a mark of this type in the given set, a new set
    without it is returned. Otherwise, the input set is returned.
    */
    removeFromSet(set) {
      for (var i = 0; i < set.length; i++)
        if (set[i].type == this) {
          set = set.slice(0, i).concat(set.slice(i + 1));
          i--;
        }
      return set;
    }
    /**
    Tests whether there is a mark of this type in the given set.
    */
    isInSet(set) {
      for (let i = 0; i < set.length; i++)
        if (set[i].type == this)
          return set[i];
    }
    /**
    Queries whether a given mark type is
    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
    */
    excludes(other) {
      return this.excluded.indexOf(other) > -1;
    }
  };
  var Schema = class {
    /**
    Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
    */
    constructor(spec) {
      this.cached = /* @__PURE__ */ Object.create(null);
      let instanceSpec = this.spec = {};
      for (let prop in spec)
        instanceSpec[prop] = spec[prop];
      instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
      this.marks = MarkType.compile(this.spec.marks, this);
      let contentExprCache = /* @__PURE__ */ Object.create(null);
      for (let prop in this.nodes) {
        if (prop in this.marks)
          throw new RangeError(prop + " can not be both a node and a mark");
        let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
        type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
        type.inlineContent = type.contentMatch.inlineContent;
        type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
      }
      for (let prop in this.marks) {
        let type = this.marks[prop], excl = type.spec.excludes;
        type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
      }
      this.nodeFromJSON = this.nodeFromJSON.bind(this);
      this.markFromJSON = this.markFromJSON.bind(this);
      this.topNodeType = this.nodes[this.spec.topNode || "doc"];
      this.cached.wrappings = /* @__PURE__ */ Object.create(null);
    }
    /**
    Create a node in this schema. The `type` may be a string or a
    `NodeType` instance. Attributes will be extended with defaults,
    `content` may be a `Fragment`, `null`, a `Node`, or an array of
    nodes.
    */
    node(type, attrs = null, content, marks) {
      if (typeof type == "string")
        type = this.nodeType(type);
      else if (!(type instanceof NodeType))
        throw new RangeError("Invalid node type: " + type);
      else if (type.schema != this)
        throw new RangeError("Node type from different schema used (" + type.name + ")");
      return type.createChecked(attrs, content, marks);
    }
    /**
    Create a text node in the schema. Empty text nodes are not
    allowed.
    */
    text(text, marks) {
      let type = this.nodes.text;
      return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks));
    }
    /**
    Create a mark with the given type and attributes.
    */
    mark(type, attrs) {
      if (typeof type == "string")
        type = this.marks[type];
      return type.create(attrs);
    }
    /**
    Deserialize a node from its JSON representation. This method is
    bound.
    */
    nodeFromJSON(json) {
      return Node.fromJSON(this, json);
    }
    /**
    Deserialize a mark from its JSON representation. This method is
    bound.
    */
    markFromJSON(json) {
      return Mark.fromJSON(this, json);
    }
    /**
    @internal
    */
    nodeType(name) {
      let found2 = this.nodes[name];
      if (!found2)
        throw new RangeError("Unknown node type: " + name);
      return found2;
    }
  };
  function gatherMarks(schema, marks) {
    let found2 = [];
    for (let i = 0; i < marks.length; i++) {
      let name = marks[i], mark = schema.marks[name], ok = mark;
      if (mark) {
        found2.push(mark);
      } else {
        for (let prop in schema.marks) {
          let mark2 = schema.marks[prop];
          if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
            found2.push(ok = mark2);
        }
      }
      if (!ok)
        throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
    }
    return found2;
  }
  var DOMParser = class _DOMParser {
    /**
    Create a parser that targets the given schema, using the given
    parsing rules.
    */
    constructor(schema, rules) {
      this.schema = schema;
      this.rules = rules;
      this.tags = [];
      this.styles = [];
      rules.forEach((rule) => {
        if (rule.tag)
          this.tags.push(rule);
        else if (rule.style)
          this.styles.push(rule);
      });
      this.normalizeLists = !this.tags.some((r) => {
        if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
          return false;
        let node = schema.nodes[r.node];
        return node.contentMatch.matchType(node);
      });
    }
    /**
    Parse a document from the content of a DOM node.
    */
    parse(dom, options = {}) {
      let context = new ParseContext(this, options, false);
      context.addAll(dom, options.from, options.to);
      return context.finish();
    }
    /**
    Parses the content of the given DOM node, like
    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
    options. But unlike that method, which produces a whole node,
    this one returns a slice that is open at the sides, meaning that
    the schema constraints aren't applied to the start of nodes to
    the left of the input and the end of nodes at the end.
    */
    parseSlice(dom, options = {}) {
      let context = new ParseContext(this, options, true);
      context.addAll(dom, options.from, options.to);
      return Slice.maxOpen(context.finish());
    }
    /**
    @internal
    */
    matchTag(dom, context, after) {
      for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
        let rule = this.tags[i];
        if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
          if (rule.getAttrs) {
            let result = rule.getAttrs(dom);
            if (result === false)
              continue;
            rule.attrs = result || void 0;
          }
          return rule;
        }
      }
    }
    /**
    @internal
    */
    matchStyle(prop, value, context, after) {
      for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
        let rule = this.styles[i], style2 = rule.style;
        if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
        // or has an '=' sign after the prop, followed by the given
        // value.
        style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
          continue;
        if (rule.getAttrs) {
          let result = rule.getAttrs(value);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
    /**
    @internal
    */
    static schemaRules(schema) {
      let result = [];
      function insert(rule) {
        let priority = rule.priority == null ? 50 : rule.priority, i = 0;
        for (; i < result.length; i++) {
          let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
          if (nextPriority < priority)
            break;
        }
        result.splice(i, 0, rule);
      }
      for (let name in schema.marks) {
        let rules = schema.marks[name].spec.parseDOM;
        if (rules)
          rules.forEach((rule) => {
            insert(rule = copy(rule));
            if (!(rule.mark || rule.ignore || rule.clearMark))
              rule.mark = name;
          });
      }
      for (let name in schema.nodes) {
        let rules = schema.nodes[name].spec.parseDOM;
        if (rules)
          rules.forEach((rule) => {
            insert(rule = copy(rule));
            if (!(rule.node || rule.ignore || rule.mark))
              rule.node = name;
          });
      }
      return result;
    }
    /**
    Construct a DOM parser using the parsing rules listed in a
    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
    [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
    */
    static fromSchema(schema) {
      return schema.cached.domParser || (schema.cached.domParser = new _DOMParser(schema, _DOMParser.schemaRules(schema)));
    }
  };
  var blockTags = {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    canvas: true,
    dd: true,
    div: true,
    dl: true,
    fieldset: true,
    figcaption: true,
    figure: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    li: true,
    noscript: true,
    ol: true,
    output: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    tfoot: true,
    ul: true
  };
  var ignoreTags = {
    head: true,
    noscript: true,
    object: true,
    script: true,
    style: true,
    title: true
  };
  var listTags = { ol: true, ul: true };
  var OPT_PRESERVE_WS = 1;
  var OPT_PRESERVE_WS_FULL = 2;
  var OPT_OPEN_LEFT = 4;
  function wsOptionsFor(type, preserveWhitespace, base2) {
    if (preserveWhitespace != null)
      return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
    return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
  }
  var NodeContext = class {
    constructor(type, attrs, marks, pendingMarks, solid, match, options) {
      this.type = type;
      this.attrs = attrs;
      this.marks = marks;
      this.pendingMarks = pendingMarks;
      this.solid = solid;
      this.options = options;
      this.content = [];
      this.activeMarks = Mark.none;
      this.stashMarks = [];
      this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
    }
    findWrapping(node) {
      if (!this.match) {
        if (!this.type)
          return [];
        let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
        if (fill) {
          this.match = this.type.contentMatch.matchFragment(fill);
        } else {
          let start2 = this.type.contentMatch, wrap2;
          if (wrap2 = start2.findWrapping(node.type)) {
            this.match = start2;
            return wrap2;
          } else {
            return null;
          }
        }
      }
      return this.match.findWrapping(node.type);
    }
    finish(openEnd) {
      if (!(this.options & OPT_PRESERVE_WS)) {
        let last = this.content[this.content.length - 1], m;
        if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
          let text = last;
          if (last.text.length == m[0].length)
            this.content.pop();
          else
            this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
        }
      }
      let content = Fragment.from(this.content);
      if (!openEnd && this.match)
        content = content.append(this.match.fillBefore(Fragment.empty, true));
      return this.type ? this.type.create(this.attrs, content, this.marks) : content;
    }
    popFromStashMark(mark) {
      for (let i = this.stashMarks.length - 1; i >= 0; i--)
        if (mark.eq(this.stashMarks[i]))
          return this.stashMarks.splice(i, 1)[0];
    }
    applyPending(nextType) {
      for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {
        let mark = pending[i];
        if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {
          this.activeMarks = mark.addToSet(this.activeMarks);
          this.pendingMarks = mark.removeFromSet(this.pendingMarks);
        }
      }
    }
    inlineContext(node) {
      if (this.type)
        return this.type.inlineContent;
      if (this.content.length)
        return this.content[0].isInline;
      return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
    }
  };
  var ParseContext = class {
    constructor(parser, options, isOpen) {
      this.parser = parser;
      this.options = options;
      this.isOpen = isOpen;
      this.open = 0;
      let topNode = options.topNode, topContext;
      let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
      if (topNode)
        topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
      else if (isOpen)
        topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);
      else
        topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
      this.nodes = [topContext];
      this.find = options.findPositions;
      this.needsBlock = false;
    }
    get top() {
      return this.nodes[this.open];
    }
    // Add a DOM node to the content. Text is inserted as text node,
    // otherwise, the node is passed to `addElement` or, if it has a
    // `style` attribute, `addElementWithStyles`.
    addDOM(dom) {
      if (dom.nodeType == 3)
        this.addTextNode(dom);
      else if (dom.nodeType == 1)
        this.addElement(dom);
    }
    withStyleRules(dom, f) {
      let style2 = dom.getAttribute("style");
      if (!style2)
        return f();
      let marks = this.readStyles(parseStyles(style2));
      if (!marks)
        return;
      let [addMarks, removeMarks] = marks, top2 = this.top;
      for (let i = 0; i < removeMarks.length; i++)
        this.removePendingMark(removeMarks[i], top2);
      for (let i = 0; i < addMarks.length; i++)
        this.addPendingMark(addMarks[i]);
      f();
      for (let i = 0; i < addMarks.length; i++)
        this.removePendingMark(addMarks[i], top2);
      for (let i = 0; i < removeMarks.length; i++)
        this.addPendingMark(removeMarks[i]);
    }
    addTextNode(dom) {
      let value = dom.nodeValue;
      let top2 = this.top;
      if (top2.options & OPT_PRESERVE_WS_FULL || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
        if (!(top2.options & OPT_PRESERVE_WS)) {
          value = value.replace(/[ \t\r\n\u000c]+/g, " ");
          if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
            let nodeBefore = top2.content[top2.content.length - 1];
            let domNodeBefore = dom.previousSibling;
            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
              value = value.slice(1);
          }
        } else if (!(top2.options & OPT_PRESERVE_WS_FULL)) {
          value = value.replace(/\r?\n|\r/g, " ");
        } else {
          value = value.replace(/\r\n?/g, "\n");
        }
        if (value)
          this.insertNode(this.parser.schema.text(value));
        this.findInText(dom);
      } else {
        this.findInside(dom);
      }
    }
    // Try to find a handler for the given tag and use that to parse. If
    // none is found, the element's content nodes are added directly.
    addElement(dom, matchAfter) {
      let name = dom.nodeName.toLowerCase(), ruleID;
      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
        normalizeList(dom);
      let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
      if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
        this.findInside(dom);
        this.ignoreFallback(dom);
      } else if (!rule || rule.skip || rule.closeParent) {
        if (rule && rule.closeParent)
          this.open = Math.max(0, this.open - 1);
        else if (rule && rule.skip.nodeType)
          dom = rule.skip;
        let sync, top2 = this.top, oldNeedsBlock = this.needsBlock;
        if (blockTags.hasOwnProperty(name)) {
          if (top2.content.length && top2.content[0].isInline && this.open) {
            this.open--;
            top2 = this.top;
          }
          sync = true;
          if (!top2.type)
            this.needsBlock = true;
        } else if (!dom.firstChild) {
          this.leafFallback(dom);
          return;
        }
        if (rule && rule.skip)
          this.addAll(dom);
        else
          this.withStyleRules(dom, () => this.addAll(dom));
        if (sync)
          this.sync(top2);
        this.needsBlock = oldNeedsBlock;
      } else {
        this.withStyleRules(dom, () => {
          this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : void 0);
        });
      }
    }
    // Called for leaf DOM nodes that would otherwise be ignored
    leafFallback(dom) {
      if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
        this.addTextNode(dom.ownerDocument.createTextNode("\n"));
    }
    // Called for ignored nodes
    ignoreFallback(dom) {
      if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
        this.findPlace(this.parser.schema.text("-"));
    }
    // Run any style parser associated with the node's styles. Either
    // return an array of marks, or null to indicate some of the styles
    // had a rule with `ignore` set.
    readStyles(styles) {
      let add = Mark.none, remove = Mark.none;
      for (let i = 0; i < styles.length; i += 2) {
        for (let after = void 0; ; ) {
          let rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);
          if (!rule)
            break;
          if (rule.ignore)
            return null;
          if (rule.clearMark) {
            this.top.pendingMarks.concat(this.top.activeMarks).forEach((m) => {
              if (rule.clearMark(m))
                remove = m.addToSet(remove);
            });
          } else {
            add = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(add);
          }
          if (rule.consuming === false)
            after = rule;
          else
            break;
        }
      }
      return [add, remove];
    }
    // Look up a handler for the given node. If none are found, return
    // false. Otherwise, apply it, use its return value to drive the way
    // the node's content is wrapped, and return true.
    addElementByRule(dom, rule, continueAfter) {
      let sync, nodeType, mark;
      if (rule.node) {
        nodeType = this.parser.schema.nodes[rule.node];
        if (!nodeType.isLeaf) {
          sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);
        } else if (!this.insertNode(nodeType.create(rule.attrs))) {
          this.leafFallback(dom);
        }
      } else {
        let markType = this.parser.schema.marks[rule.mark];
        mark = markType.create(rule.attrs);
        this.addPendingMark(mark);
      }
      let startIn = this.top;
      if (nodeType && nodeType.isLeaf) {
        this.findInside(dom);
      } else if (continueAfter) {
        this.addElement(dom, continueAfter);
      } else if (rule.getContent) {
        this.findInside(dom);
        rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node));
      } else {
        let contentDOM = dom;
        if (typeof rule.contentElement == "string")
          contentDOM = dom.querySelector(rule.contentElement);
        else if (typeof rule.contentElement == "function")
          contentDOM = rule.contentElement(dom);
        else if (rule.contentElement)
          contentDOM = rule.contentElement;
        this.findAround(dom, contentDOM, true);
        this.addAll(contentDOM);
      }
      if (sync && this.sync(startIn))
        this.open--;
      if (mark)
        this.removePendingMark(mark, startIn);
    }
    // Add all child nodes between `startIndex` and `endIndex` (or the
    // whole node, if not given). If `sync` is passed, use it to
    // synchronize after every block element.
    addAll(parent, startIndex, endIndex) {
      let index = startIndex || 0;
      for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end2 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end2; dom = dom.nextSibling, ++index) {
        this.findAtPoint(parent, index);
        this.addDOM(dom);
      }
      this.findAtPoint(parent, index);
    }
    // Try to find a way to fit the given node type into the current
    // context. May add intermediate wrappers and/or leave non-solid
    // nodes that we're in.
    findPlace(node) {
      let route, sync;
      for (let depth = this.open; depth >= 0; depth--) {
        let cx = this.nodes[depth];
        let found2 = cx.findWrapping(node);
        if (found2 && (!route || route.length > found2.length)) {
          route = found2;
          sync = cx;
          if (!found2.length)
            break;
        }
        if (cx.solid)
          break;
      }
      if (!route)
        return false;
      this.sync(sync);
      for (let i = 0; i < route.length; i++)
        this.enterInner(route[i], null, false);
      return true;
    }
    // Try to insert the given node, adjusting the context when needed.
    insertNode(node) {
      if (node.isInline && this.needsBlock && !this.top.type) {
        let block = this.textblockFromContext();
        if (block)
          this.enterInner(block);
      }
      if (this.findPlace(node)) {
        this.closeExtra();
        let top2 = this.top;
        top2.applyPending(node.type);
        if (top2.match)
          top2.match = top2.match.matchType(node.type);
        let marks = top2.activeMarks;
        for (let i = 0; i < node.marks.length; i++)
          if (!top2.type || top2.type.allowsMarkType(node.marks[i].type))
            marks = node.marks[i].addToSet(marks);
        top2.content.push(node.mark(marks));
        return true;
      }
      return false;
    }
    // Try to start a node of the given type, adjusting the context when
    // necessary.
    enter(type, attrs, preserveWS) {
      let ok = this.findPlace(type.create(attrs));
      if (ok)
        this.enterInner(type, attrs, true, preserveWS);
      return ok;
    }
    // Open a node of the given type
    enterInner(type, attrs = null, solid = false, preserveWS) {
      this.closeExtra();
      let top2 = this.top;
      top2.applyPending(type);
      top2.match = top2.match && top2.match.matchType(type);
      let options = wsOptionsFor(type, preserveWS, top2.options);
      if (top2.options & OPT_OPEN_LEFT && top2.content.length == 0)
        options |= OPT_OPEN_LEFT;
      this.nodes.push(new NodeContext(type, attrs, top2.activeMarks, top2.pendingMarks, solid, null, options));
      this.open++;
    }
    // Make sure all nodes above this.open are finished and added to
    // their parents
    closeExtra(openEnd = false) {
      let i = this.nodes.length - 1;
      if (i > this.open) {
        for (; i > this.open; i--)
          this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
        this.nodes.length = this.open + 1;
      }
    }
    finish() {
      this.open = 0;
      this.closeExtra(this.isOpen);
      return this.nodes[0].finish(this.isOpen || this.options.topOpen);
    }
    sync(to) {
      for (let i = this.open; i >= 0; i--)
        if (this.nodes[i] == to) {
          this.open = i;
          return true;
        }
      return false;
    }
    get currentPos() {
      this.closeExtra();
      let pos = 0;
      for (let i = this.open; i >= 0; i--) {
        let content = this.nodes[i].content;
        for (let j = content.length - 1; j >= 0; j--)
          pos += content[j].nodeSize;
        if (i)
          pos++;
      }
      return pos;
    }
    findAtPoint(parent, offset2) {
      if (this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (this.find[i].node == parent && this.find[i].offset == offset2)
            this.find[i].pos = this.currentPos;
        }
    }
    findInside(parent) {
      if (this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
            this.find[i].pos = this.currentPos;
        }
    }
    findAround(parent, content, before) {
      if (parent != content && this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
            let pos = content.compareDocumentPosition(this.find[i].node);
            if (pos & (before ? 2 : 4))
              this.find[i].pos = this.currentPos;
          }
        }
    }
    findInText(textNode) {
      if (this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (this.find[i].node == textNode)
            this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
        }
    }
    // Determines whether the given context string matches this context.
    matchesContext(context) {
      if (context.indexOf("|") > -1)
        return context.split(/\s*\|\s*/).some(this.matchesContext, this);
      let parts = context.split("/");
      let option = this.options.context;
      let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
      let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
      let match = (i, depth) => {
        for (; i >= 0; i--) {
          let part = parts[i];
          if (part == "") {
            if (i == parts.length - 1 || i == 0)
              continue;
            for (; depth >= minDepth; depth--)
              if (match(i - 1, depth))
                return true;
            return false;
          } else {
            let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
            if (!next || next.name != part && next.groups.indexOf(part) == -1)
              return false;
            depth--;
          }
        }
        return true;
      };
      return match(parts.length - 1, this.open);
    }
    textblockFromContext() {
      let $context = this.options.context;
      if ($context)
        for (let d = $context.depth; d >= 0; d--) {
          let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
          if (deflt && deflt.isTextblock && deflt.defaultAttrs)
            return deflt;
        }
      for (let name in this.parser.schema.nodes) {
        let type = this.parser.schema.nodes[name];
        if (type.isTextblock && type.defaultAttrs)
          return type;
      }
    }
    addPendingMark(mark) {
      let found2 = findSameMarkInSet(mark, this.top.pendingMarks);
      if (found2)
        this.top.stashMarks.push(found2);
      this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
    }
    removePendingMark(mark, upto) {
      for (let depth = this.open; depth >= 0; depth--) {
        let level = this.nodes[depth];
        let found2 = level.pendingMarks.lastIndexOf(mark);
        if (found2 > -1) {
          level.pendingMarks = mark.removeFromSet(level.pendingMarks);
        } else {
          level.activeMarks = mark.removeFromSet(level.activeMarks);
          let stashMark = level.popFromStashMark(mark);
          if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
            level.activeMarks = stashMark.addToSet(level.activeMarks);
        }
        if (level == upto)
          break;
      }
    }
  };
  function normalizeList(dom) {
    for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
      let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
      if (name && listTags.hasOwnProperty(name) && prevItem) {
        prevItem.appendChild(child);
        child = prevItem;
      } else if (name == "li") {
        prevItem = child;
      } else if (name) {
        prevItem = null;
      }
    }
  }
  function matches(dom, selector) {
    return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
  }
  function parseStyles(style2) {
    let re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
    while (m = re.exec(style2))
      result.push(m[1], m[2].trim());
    return result;
  }
  function copy(obj) {
    let copy2 = {};
    for (let prop in obj)
      copy2[prop] = obj[prop];
    return copy2;
  }
  function markMayApply(markType, nodeType) {
    let nodes = nodeType.schema.nodes;
    for (let name in nodes) {
      let parent = nodes[name];
      if (!parent.allowsMarkType(markType))
        continue;
      let seen = [], scan = (match) => {
        seen.push(match);
        for (let i = 0; i < match.edgeCount; i++) {
          let { type, next } = match.edge(i);
          if (type == nodeType)
            return true;
          if (seen.indexOf(next) < 0 && scan(next))
            return true;
        }
      };
      if (scan(parent.contentMatch))
        return true;
    }
  }
  function findSameMarkInSet(mark, set) {
    for (let i = 0; i < set.length; i++) {
      if (mark.eq(set[i]))
        return set[i];
    }
  }
  var DOMSerializer = class _DOMSerializer {
    /**
    Create a serializer. `nodes` should map node names to functions
    that take a node and return a description of the corresponding
    DOM. `marks` does the same for mark names, but also gets an
    argument that tells it whether the mark's content is block or
    inline content (for typical use, it'll always be inline). A mark
    serializer may be `null` to indicate that marks of that type
    should not be serialized.
    */
    constructor(nodes, marks) {
      this.nodes = nodes;
      this.marks = marks;
    }
    /**
    Serialize the content of this fragment to a DOM fragment. When
    not in the browser, the `document` option, containing a DOM
    document, should be passed so that the serializer can create
    nodes.
    */
    serializeFragment(fragment, options = {}, target) {
      if (!target)
        target = doc(options).createDocumentFragment();
      let top2 = target, active = [];
      fragment.forEach((node) => {
        if (active.length || node.marks.length) {
          let keep = 0, rendered = 0;
          while (keep < active.length && rendered < node.marks.length) {
            let next = node.marks[rendered];
            if (!this.marks[next.type.name]) {
              rendered++;
              continue;
            }
            if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
              break;
            keep++;
            rendered++;
          }
          while (keep < active.length)
            top2 = active.pop()[1];
          while (rendered < node.marks.length) {
            let add = node.marks[rendered++];
            let markDOM = this.serializeMark(add, node.isInline, options);
            if (markDOM) {
              active.push([add, top2]);
              top2.appendChild(markDOM.dom);
              top2 = markDOM.contentDOM || markDOM.dom;
            }
          }
        }
        top2.appendChild(this.serializeNodeInner(node, options));
      });
      return target;
    }
    /**
    @internal
    */
    serializeNodeInner(node, options) {
      let { dom, contentDOM } = _DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));
      if (contentDOM) {
        if (node.isLeaf)
          throw new RangeError("Content hole not allowed in a leaf node spec");
        this.serializeFragment(node.content, options, contentDOM);
      }
      return dom;
    }
    /**
    Serialize this node to a DOM node. This can be useful when you
    need to serialize a part of a document, as opposed to the whole
    document. To serialize a whole document, use
    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
    its [content](https://prosemirror.net/docs/ref/#model.Node.content).
    */
    serializeNode(node, options = {}) {
      let dom = this.serializeNodeInner(node, options);
      for (let i = node.marks.length - 1; i >= 0; i--) {
        let wrap2 = this.serializeMark(node.marks[i], node.isInline, options);
        if (wrap2) {
          (wrap2.contentDOM || wrap2.dom).appendChild(dom);
          dom = wrap2.dom;
        }
      }
      return dom;
    }
    /**
    @internal
    */
    serializeMark(mark, inline, options = {}) {
      let toDOM = this.marks[mark.type.name];
      return toDOM && _DOMSerializer.renderSpec(doc(options), toDOM(mark, inline));
    }
    /**
    Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
    the spec has a hole (zero) in it, `contentDOM` will point at the
    node with the hole.
    */
    static renderSpec(doc3, structure, xmlNS = null) {
      if (typeof structure == "string")
        return { dom: doc3.createTextNode(structure) };
      if (structure.nodeType != null)
        return { dom: structure };
      if (structure.dom && structure.dom.nodeType != null)
        return structure;
      let tagName = structure[0], space = tagName.indexOf(" ");
      if (space > 0) {
        xmlNS = tagName.slice(0, space);
        tagName = tagName.slice(space + 1);
      }
      let contentDOM;
      let dom = xmlNS ? doc3.createElementNS(xmlNS, tagName) : doc3.createElement(tagName);
      let attrs = structure[1], start2 = 1;
      if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
        start2 = 2;
        for (let name in attrs)
          if (attrs[name] != null) {
            let space2 = name.indexOf(" ");
            if (space2 > 0)
              dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
            else
              dom.setAttribute(name, attrs[name]);
          }
      }
      for (let i = start2; i < structure.length; i++) {
        let child = structure[i];
        if (child === 0) {
          if (i < structure.length - 1 || i > start2)
            throw new RangeError("Content hole must be the only child of its parent node");
          return { dom, contentDOM: dom };
        } else {
          let { dom: inner, contentDOM: innerContent } = _DOMSerializer.renderSpec(doc3, child, xmlNS);
          dom.appendChild(inner);
          if (innerContent) {
            if (contentDOM)
              throw new RangeError("Multiple content holes");
            contentDOM = innerContent;
          }
        }
      }
      return { dom, contentDOM };
    }
    /**
    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
    properties in a schema's node and mark specs.
    */
    static fromSchema(schema) {
      return schema.cached.domSerializer || (schema.cached.domSerializer = new _DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
    }
    /**
    Gather the serializers in a schema's node specs into an object.
    This can be useful as a base to build a custom serializer from.
    */
    static nodesFromSchema(schema) {
      let result = gatherToDOM(schema.nodes);
      if (!result.text)
        result.text = (node) => node.text;
      return result;
    }
    /**
    Gather the serializers in a schema's mark specs into an object.
    */
    static marksFromSchema(schema) {
      return gatherToDOM(schema.marks);
    }
  };
  function gatherToDOM(obj) {
    let result = {};
    for (let name in obj) {
      let toDOM = obj[name].spec.toDOM;
      if (toDOM)
        result[name] = toDOM;
    }
    return result;
  }
  function doc(options) {
    return options.document || window.document;
  }

  // node_modules/prosemirror-transform/dist/index.js
  var lower16 = 65535;
  var factor16 = Math.pow(2, 16);
  function makeRecover(index, offset2) {
    return index + offset2 * factor16;
  }
  function recoverIndex(value) {
    return value & lower16;
  }
  function recoverOffset(value) {
    return (value - (value & lower16)) / factor16;
  }
  var DEL_BEFORE = 1;
  var DEL_AFTER = 2;
  var DEL_ACROSS = 4;
  var DEL_SIDE = 8;
  var MapResult = class {
    /**
    @internal
    */
    constructor(pos, delInfo, recover) {
      this.pos = pos;
      this.delInfo = delInfo;
      this.recover = recover;
    }
    /**
    Tells you whether the position was deleted, that is, whether the
    step removed the token on the side queried (via the `assoc`)
    argument from the document.
    */
    get deleted() {
      return (this.delInfo & DEL_SIDE) > 0;
    }
    /**
    Tells you whether the token before the mapped position was deleted.
    */
    get deletedBefore() {
      return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
    }
    /**
    True when the token after the mapped position was deleted.
    */
    get deletedAfter() {
      return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
    }
    /**
    Tells whether any of the steps mapped through deletes across the
    position (including both the token before and after the
    position).
    */
    get deletedAcross() {
      return (this.delInfo & DEL_ACROSS) > 0;
    }
  };
  var StepMap = class _StepMap {
    /**
    Create a position map. The modifications to the document are
    represented as an array of numbers, in which each group of three
    represents a modified chunk as `[start, oldSize, newSize]`.
    */
    constructor(ranges, inverted = false) {
      this.ranges = ranges;
      this.inverted = inverted;
      if (!ranges.length && _StepMap.empty)
        return _StepMap.empty;
    }
    /**
    @internal
    */
    recover(value) {
      let diff = 0, index = recoverIndex(value);
      if (!this.inverted)
        for (let i = 0; i < index; i++)
          diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
      return this.ranges[index * 3] + diff + recoverOffset(value);
    }
    mapResult(pos, assoc = 1) {
      return this._map(pos, assoc, false);
    }
    map(pos, assoc = 1) {
      return this._map(pos, assoc, true);
    }
    /**
    @internal
    */
    _map(pos, assoc, simple) {
      let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (let i = 0; i < this.ranges.length; i += 3) {
        let start2 = this.ranges[i] - (this.inverted ? diff : 0);
        if (start2 > pos)
          break;
        let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end2 = start2 + oldSize;
        if (pos <= end2) {
          let side = !oldSize ? assoc : pos == start2 ? -1 : pos == end2 ? 1 : assoc;
          let result = start2 + diff + (side < 0 ? 0 : newSize);
          if (simple)
            return result;
          let recover = pos == (assoc < 0 ? start2 : end2) ? null : makeRecover(i / 3, pos - start2);
          let del2 = pos == start2 ? DEL_AFTER : pos == end2 ? DEL_BEFORE : DEL_ACROSS;
          if (assoc < 0 ? pos != start2 : pos != end2)
            del2 |= DEL_SIDE;
          return new MapResult(result, del2, recover);
        }
        diff += newSize - oldSize;
      }
      return simple ? pos + diff : new MapResult(pos + diff, 0, null);
    }
    /**
    @internal
    */
    touches(pos, recover) {
      let diff = 0, index = recoverIndex(recover);
      let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (let i = 0; i < this.ranges.length; i += 3) {
        let start2 = this.ranges[i] - (this.inverted ? diff : 0);
        if (start2 > pos)
          break;
        let oldSize = this.ranges[i + oldIndex], end2 = start2 + oldSize;
        if (pos <= end2 && i == index * 3)
          return true;
        diff += this.ranges[i + newIndex] - oldSize;
      }
      return false;
    }
    /**
    Calls the given function on each of the changed ranges included in
    this map.
    */
    forEach(f) {
      let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
        let start2 = this.ranges[i], oldStart = start2 - (this.inverted ? diff : 0), newStart = start2 + (this.inverted ? 0 : diff);
        let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
        diff += newSize - oldSize;
      }
    }
    /**
    Create an inverted version of this map. The result can be used to
    map positions in the post-step document to the pre-step document.
    */
    invert() {
      return new _StepMap(this.ranges, !this.inverted);
    }
    /**
    @internal
    */
    toString() {
      return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
    }
    /**
    Create a map that moves all positions by offset `n` (which may be
    negative). This can be useful when applying steps meant for a
    sub-document to a larger document, or vice-versa.
    */
    static offset(n) {
      return n == 0 ? _StepMap.empty : new _StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
    }
  };
  StepMap.empty = new StepMap([]);
  var Mapping = class _Mapping {
    /**
    Create a new mapping with the given position maps.
    */
    constructor(maps = [], mirror, from2 = 0, to = maps.length) {
      this.maps = maps;
      this.mirror = mirror;
      this.from = from2;
      this.to = to;
    }
    /**
    Create a mapping that maps only through a part of this one.
    */
    slice(from2 = 0, to = this.maps.length) {
      return new _Mapping(this.maps, this.mirror, from2, to);
    }
    /**
    @internal
    */
    copy() {
      return new _Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
    }
    /**
    Add a step map to the end of this mapping. If `mirrors` is
    given, it should be the index of the step map that is the mirror
    image of this one.
    */
    appendMap(map2, mirrors) {
      this.to = this.maps.push(map2);
      if (mirrors != null)
        this.setMirror(this.maps.length - 1, mirrors);
    }
    /**
    Add all the step maps in a given mapping to this one (preserving
    mirroring information).
    */
    appendMapping(mapping) {
      for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
        let mirr = mapping.getMirror(i);
        this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
      }
    }
    /**
    Finds the offset of the step map that mirrors the map at the
    given offset, in this mapping (as per the second argument to
    `appendMap`).
    */
    getMirror(n) {
      if (this.mirror) {
        for (let i = 0; i < this.mirror.length; i++)
          if (this.mirror[i] == n)
            return this.mirror[i + (i % 2 ? -1 : 1)];
      }
    }
    /**
    @internal
    */
    setMirror(n, m) {
      if (!this.mirror)
        this.mirror = [];
      this.mirror.push(n, m);
    }
    /**
    Append the inverse of the given mapping to this one.
    */
    appendMappingInverted(mapping) {
      for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
        let mirr = mapping.getMirror(i);
        this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
      }
    }
    /**
    Create an inverted version of this mapping.
    */
    invert() {
      let inverse = new _Mapping();
      inverse.appendMappingInverted(this);
      return inverse;
    }
    /**
    Map a position through this mapping.
    */
    map(pos, assoc = 1) {
      if (this.mirror)
        return this._map(pos, assoc, true);
      for (let i = this.from; i < this.to; i++)
        pos = this.maps[i].map(pos, assoc);
      return pos;
    }
    /**
    Map a position through this mapping, returning a mapping
    result.
    */
    mapResult(pos, assoc = 1) {
      return this._map(pos, assoc, false);
    }
    /**
    @internal
    */
    _map(pos, assoc, simple) {
      let delInfo = 0;
      for (let i = this.from; i < this.to; i++) {
        let map2 = this.maps[i], result = map2.mapResult(pos, assoc);
        if (result.recover != null) {
          let corr = this.getMirror(i);
          if (corr != null && corr > i && corr < this.to) {
            i = corr;
            pos = this.maps[corr].recover(result.recover);
            continue;
          }
        }
        delInfo |= result.delInfo;
        pos = result.pos;
      }
      return simple ? pos : new MapResult(pos, delInfo, null);
    }
  };
  var stepsByID = /* @__PURE__ */ Object.create(null);
  var Step = class {
    /**
    Get the step map that represents the changes made by this step,
    and which can be used to transform between positions in the old
    and the new document.
    */
    getMap() {
      return StepMap.empty;
    }
    /**
    Try to merge this step with another one, to be applied directly
    after it. Returns the merged step when possible, null if the
    steps can't be merged.
    */
    merge(other) {
      return null;
    }
    /**
    Deserialize a step from its JSON representation. Will call
    through to the step class' own implementation of this method.
    */
    static fromJSON(schema, json) {
      if (!json || !json.stepType)
        throw new RangeError("Invalid input for Step.fromJSON");
      let type = stepsByID[json.stepType];
      if (!type)
        throw new RangeError(`No step type ${json.stepType} defined`);
      return type.fromJSON(schema, json);
    }
    /**
    To be able to serialize steps to JSON, each step needs a string
    ID to attach to its JSON representation. Use this method to
    register an ID for your step classes. Try to pick something
    that's unlikely to clash with steps from other modules.
    */
    static jsonID(id, stepClass) {
      if (id in stepsByID)
        throw new RangeError("Duplicate use of step JSON ID " + id);
      stepsByID[id] = stepClass;
      stepClass.prototype.jsonID = id;
      return stepClass;
    }
  };
  var StepResult = class _StepResult {
    /**
    @internal
    */
    constructor(doc3, failed) {
      this.doc = doc3;
      this.failed = failed;
    }
    /**
    Create a successful step result.
    */
    static ok(doc3) {
      return new _StepResult(doc3, null);
    }
    /**
    Create a failed step result.
    */
    static fail(message) {
      return new _StepResult(null, message);
    }
    /**
    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
    arguments. Create a successful result if it succeeds, and a
    failed one if it throws a `ReplaceError`.
    */
    static fromReplace(doc3, from2, to, slice2) {
      try {
        return _StepResult.ok(doc3.replace(from2, to, slice2));
      } catch (e) {
        if (e instanceof ReplaceError)
          return _StepResult.fail(e.message);
        throw e;
      }
    }
  };
  function mapFragment(fragment, f, parent) {
    let mapped = [];
    for (let i = 0; i < fragment.childCount; i++) {
      let child = fragment.child(i);
      if (child.content.size)
        child = child.copy(mapFragment(child.content, f, child));
      if (child.isInline)
        child = f(child, parent, i);
      mapped.push(child);
    }
    return Fragment.fromArray(mapped);
  }
  var AddMarkStep = class _AddMarkStep extends Step {
    /**
    Create a mark step.
    */
    constructor(from2, to, mark) {
      super();
      this.from = from2;
      this.to = to;
      this.mark = mark;
    }
    apply(doc3) {
      let oldSlice = doc3.slice(this.from, this.to), $from = doc3.resolve(this.from);
      let parent = $from.node($from.sharedDepth(this.to));
      let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
        if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
          return node;
        return node.mark(this.mark.addToSet(node.marks));
      }, parent), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc3, this.from, this.to, slice2);
    }
    invert() {
      return new RemoveMarkStep(this.from, this.to, this.mark);
    }
    map(mapping) {
      let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from2.deleted && to.deleted || from2.pos >= to.pos)
        return null;
      return new _AddMarkStep(from2.pos, to.pos, this.mark);
    }
    merge(other) {
      if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
        return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
    toJSON() {
      return {
        stepType: "addMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for AddMarkStep.fromJSON");
      return new _AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
  };
  Step.jsonID("addMark", AddMarkStep);
  var RemoveMarkStep = class _RemoveMarkStep extends Step {
    /**
    Create a mark-removing step.
    */
    constructor(from2, to, mark) {
      super();
      this.from = from2;
      this.to = to;
      this.mark = mark;
    }
    apply(doc3) {
      let oldSlice = doc3.slice(this.from, this.to);
      let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {
        return node.mark(this.mark.removeFromSet(node.marks));
      }, doc3), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc3, this.from, this.to, slice2);
    }
    invert() {
      return new AddMarkStep(this.from, this.to, this.mark);
    }
    map(mapping) {
      let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from2.deleted && to.deleted || from2.pos >= to.pos)
        return null;
      return new _RemoveMarkStep(from2.pos, to.pos, this.mark);
    }
    merge(other) {
      if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
        return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
    toJSON() {
      return {
        stepType: "removeMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
      return new _RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
  };
  Step.jsonID("removeMark", RemoveMarkStep);
  var AddNodeMarkStep = class _AddNodeMarkStep extends Step {
    /**
    Create a node mark step.
    */
    constructor(pos, mark) {
      super();
      this.pos = pos;
      this.mark = mark;
    }
    apply(doc3) {
      let node = doc3.nodeAt(this.pos);
      if (!node)
        return StepResult.fail("No node at mark step's position");
      let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
      return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
    }
    invert(doc3) {
      let node = doc3.nodeAt(this.pos);
      if (node) {
        let newSet = this.mark.addToSet(node.marks);
        if (newSet.length == node.marks.length) {
          for (let i = 0; i < node.marks.length; i++)
            if (!node.marks[i].isInSet(newSet))
              return new _AddNodeMarkStep(this.pos, node.marks[i]);
          return new _AddNodeMarkStep(this.pos, this.mark);
        }
      }
      return new RemoveNodeMarkStep(this.pos, this.mark);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);
    }
    toJSON() {
      return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.pos != "number")
        throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
      return new _AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
    }
  };
  Step.jsonID("addNodeMark", AddNodeMarkStep);
  var RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {
    /**
    Create a mark-removing step.
    */
    constructor(pos, mark) {
      super();
      this.pos = pos;
      this.mark = mark;
    }
    apply(doc3) {
      let node = doc3.nodeAt(this.pos);
      if (!node)
        return StepResult.fail("No node at mark step's position");
      let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
      return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
    }
    invert(doc3) {
      let node = doc3.nodeAt(this.pos);
      if (!node || !this.mark.isInSet(node.marks))
        return this;
      return new AddNodeMarkStep(this.pos, this.mark);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);
    }
    toJSON() {
      return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.pos != "number")
        throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
      return new _RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
    }
  };
  Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
  var ReplaceStep = class _ReplaceStep extends Step {
    /**
    The given `slice` should fit the 'gap' between `from` and
    `to`—the depths must line up, and the surrounding nodes must be
    able to be joined with the open sides of the slice. When
    `structure` is true, the step will fail if the content between
    from and to is not just a sequence of closing and then opening
    tokens (this is to guard against rebased replace steps
    overwriting something they weren't supposed to).
    */
    constructor(from2, to, slice2, structure = false) {
      super();
      this.from = from2;
      this.to = to;
      this.slice = slice2;
      this.structure = structure;
    }
    apply(doc3) {
      if (this.structure && contentBetween(doc3, this.from, this.to))
        return StepResult.fail("Structure replace would overwrite content");
      return StepResult.fromReplace(doc3, this.from, this.to, this.slice);
    }
    getMap() {
      return new StepMap([this.from, this.to - this.from, this.slice.size]);
    }
    invert(doc3) {
      return new _ReplaceStep(this.from, this.from + this.slice.size, doc3.slice(this.from, this.to));
    }
    map(mapping) {
      let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from2.deletedAcross && to.deletedAcross)
        return null;
      return new _ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice);
    }
    merge(other) {
      if (!(other instanceof _ReplaceStep) || other.structure || this.structure)
        return null;
      if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
        let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
        return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
      } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
        let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
        return new _ReplaceStep(other.from, this.to, slice2, this.structure);
      } else {
        return null;
      }
    }
    toJSON() {
      let json = { stepType: "replace", from: this.from, to: this.to };
      if (this.slice.size)
        json.slice = this.slice.toJSON();
      if (this.structure)
        json.structure = true;
      return json;
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for ReplaceStep.fromJSON");
      return new _ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
    }
  };
  Step.jsonID("replace", ReplaceStep);
  var ReplaceAroundStep = class _ReplaceAroundStep extends Step {
    /**
    Create a replace-around step with the given range and gap.
    `insert` should be the point in the slice into which the content
    of the gap should be moved. `structure` has the same meaning as
    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
    */
    constructor(from2, to, gapFrom, gapTo, slice2, insert, structure = false) {
      super();
      this.from = from2;
      this.to = to;
      this.gapFrom = gapFrom;
      this.gapTo = gapTo;
      this.slice = slice2;
      this.insert = insert;
      this.structure = structure;
    }
    apply(doc3) {
      if (this.structure && (contentBetween(doc3, this.from, this.gapFrom) || contentBetween(doc3, this.gapTo, this.to)))
        return StepResult.fail("Structure gap-replace would overwrite content");
      let gap = doc3.slice(this.gapFrom, this.gapTo);
      if (gap.openStart || gap.openEnd)
        return StepResult.fail("Gap is not a flat range");
      let inserted = this.slice.insertAt(this.insert, gap.content);
      if (!inserted)
        return StepResult.fail("Content does not fit in gap");
      return StepResult.fromReplace(doc3, this.from, this.to, inserted);
    }
    getMap() {
      return new StepMap([
        this.from,
        this.gapFrom - this.from,
        this.insert,
        this.gapTo,
        this.to - this.gapTo,
        this.slice.size - this.insert
      ]);
    }
    invert(doc3) {
      let gap = this.gapTo - this.gapFrom;
      return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc3.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
    }
    map(mapping) {
      let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
      if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
        return null;
      return new _ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
    }
    toJSON() {
      let json = {
        stepType: "replaceAround",
        from: this.from,
        to: this.to,
        gapFrom: this.gapFrom,
        gapTo: this.gapTo,
        insert: this.insert
      };
      if (this.slice.size)
        json.slice = this.slice.toJSON();
      if (this.structure)
        json.structure = true;
      return json;
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
        throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
      return new _ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
    }
  };
  Step.jsonID("replaceAround", ReplaceAroundStep);
  function contentBetween(doc3, from2, to) {
    let $from = doc3.resolve(from2), dist = to - from2, depth = $from.depth;
    while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
      depth--;
      dist--;
    }
    if (dist > 0) {
      let next = $from.node(depth).maybeChild($from.indexAfter(depth));
      while (dist > 0) {
        if (!next || next.isLeaf)
          return true;
        next = next.firstChild;
        dist--;
      }
    }
    return false;
  }
  function addMark(tr, from2, to, mark) {
    let removed = [], added = [];
    let removing, adding;
    tr.doc.nodesBetween(from2, to, (node, pos, parent) => {
      if (!node.isInline)
        return;
      let marks = node.marks;
      if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
        let start2 = Math.max(pos, from2), end2 = Math.min(pos + node.nodeSize, to);
        let newSet = mark.addToSet(marks);
        for (let i = 0; i < marks.length; i++) {
          if (!marks[i].isInSet(newSet)) {
            if (removing && removing.to == start2 && removing.mark.eq(marks[i]))
              removing.to = end2;
            else
              removed.push(removing = new RemoveMarkStep(start2, end2, marks[i]));
          }
        }
        if (adding && adding.to == start2)
          adding.to = end2;
        else
          added.push(adding = new AddMarkStep(start2, end2, mark));
      }
    });
    removed.forEach((s) => tr.step(s));
    added.forEach((s) => tr.step(s));
  }
  function removeMark(tr, from2, to, mark) {
    let matched = [], step = 0;
    tr.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isInline)
        return;
      step++;
      let toRemove = null;
      if (mark instanceof MarkType) {
        let set = node.marks, found2;
        while (found2 = mark.isInSet(set)) {
          (toRemove || (toRemove = [])).push(found2);
          set = found2.removeFromSet(set);
        }
      } else if (mark) {
        if (mark.isInSet(node.marks))
          toRemove = [mark];
      } else {
        toRemove = node.marks;
      }
      if (toRemove && toRemove.length) {
        let end2 = Math.min(pos + node.nodeSize, to);
        for (let i = 0; i < toRemove.length; i++) {
          let style2 = toRemove[i], found2;
          for (let j = 0; j < matched.length; j++) {
            let m = matched[j];
            if (m.step == step - 1 && style2.eq(matched[j].style))
              found2 = m;
          }
          if (found2) {
            found2.to = end2;
            found2.step = step;
          } else {
            matched.push({ style: style2, from: Math.max(pos, from2), to: end2, step });
          }
        }
      }
    });
    matched.forEach((m) => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));
  }
  function clearIncompatible(tr, pos, parentType, match = parentType.contentMatch) {
    let node = tr.doc.nodeAt(pos);
    let replSteps = [], cur = pos + 1;
    for (let i = 0; i < node.childCount; i++) {
      let child = node.child(i), end2 = cur + child.nodeSize;
      let allowed = match.matchType(child.type);
      if (!allowed) {
        replSteps.push(new ReplaceStep(cur, end2, Slice.empty));
      } else {
        match = allowed;
        for (let j = 0; j < child.marks.length; j++)
          if (!parentType.allowsMarkType(child.marks[j].type))
            tr.step(new RemoveMarkStep(cur, end2, child.marks[j]));
        if (child.isText && !parentType.spec.code) {
          let m, newline = /\r?\n|\r/g, slice2;
          while (m = newline.exec(child.text)) {
            if (!slice2)
              slice2 = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
            replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));
          }
        }
      }
      cur = end2;
    }
    if (!match.validEnd) {
      let fill = match.fillBefore(Fragment.empty, true);
      tr.replace(cur, cur, new Slice(fill, 0, 0));
    }
    for (let i = replSteps.length - 1; i >= 0; i--)
      tr.step(replSteps[i]);
  }
  function canCut(node, start2, end2) {
    return (start2 == 0 || node.canReplace(start2, node.childCount)) && (end2 == node.childCount || node.canReplace(0, end2));
  }
  function liftTarget(range) {
    let parent = range.parent;
    let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
    for (let depth = range.depth; ; --depth) {
      let node = range.$from.node(depth);
      let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
      if (depth < range.depth && node.canReplace(index, endIndex, content))
        return depth;
      if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))
        break;
    }
    return null;
  }
  function lift(tr, range, target) {
    let { $from, $to, depth } = range;
    let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
    let start2 = gapStart, end2 = gapEnd;
    let before = Fragment.empty, openStart = 0;
    for (let d = depth, splitting = false; d > target; d--)
      if (splitting || $from.index(d) > 0) {
        splitting = true;
        before = Fragment.from($from.node(d).copy(before));
        openStart++;
      } else {
        start2--;
      }
    let after = Fragment.empty, openEnd = 0;
    for (let d = depth, splitting = false; d > target; d--)
      if (splitting || $to.after(d + 1) < $to.end(d)) {
        splitting = true;
        after = Fragment.from($to.node(d).copy(after));
        openEnd++;
      } else {
        end2++;
      }
    tr.step(new ReplaceAroundStep(start2, end2, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
  }
  function findWrapping(range, nodeType, attrs = null, innerRange = range) {
    let around = findWrappingOutside(range, nodeType);
    let inner = around && findWrappingInside(innerRange, nodeType);
    if (!inner)
      return null;
    return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
  }
  function withAttrs(type) {
    return { type, attrs: null };
  }
  function findWrappingOutside(range, type) {
    let { parent, startIndex, endIndex } = range;
    let around = parent.contentMatchAt(startIndex).findWrapping(type);
    if (!around)
      return null;
    let outer = around.length ? around[0] : type;
    return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
  }
  function findWrappingInside(range, type) {
    let { parent, startIndex, endIndex } = range;
    let inner = parent.child(startIndex);
    let inside = type.contentMatch.findWrapping(inner.type);
    if (!inside)
      return null;
    let lastType = inside.length ? inside[inside.length - 1] : type;
    let innerMatch = lastType.contentMatch;
    for (let i = startIndex; innerMatch && i < endIndex; i++)
      innerMatch = innerMatch.matchType(parent.child(i).type);
    if (!innerMatch || !innerMatch.validEnd)
      return null;
    return inside;
  }
  function wrap(tr, range, wrappers) {
    let content = Fragment.empty;
    for (let i = wrappers.length - 1; i >= 0; i--) {
      if (content.size) {
        let match = wrappers[i].type.contentMatch.matchFragment(content);
        if (!match || !match.validEnd)
          throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
      }
      content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
    }
    let start2 = range.start, end2 = range.end;
    tr.step(new ReplaceAroundStep(start2, end2, start2, end2, new Slice(content, 0, 0), wrappers.length, true));
  }
  function setBlockType(tr, from2, to, type, attrs) {
    if (!type.isTextblock)
      throw new RangeError("Type given to setBlockType should be a textblock");
    let mapFrom = tr.steps.length;
    tr.doc.nodesBetween(from2, to, (node, pos) => {
      if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {
        tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos, 1), type);
        let mapping = tr.mapping.slice(mapFrom);
        let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
        tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
        return false;
      }
    });
  }
  function canChangeType(doc3, pos, type) {
    let $pos = doc3.resolve(pos), index = $pos.index();
    return $pos.parent.canReplaceWith(index, index + 1, type);
  }
  function setNodeMarkup(tr, pos, type, attrs, marks) {
    let node = tr.doc.nodeAt(pos);
    if (!node)
      throw new RangeError("No node at given position");
    if (!type)
      type = node.type;
    let newNode = type.create(attrs, null, marks || node.marks);
    if (node.isLeaf)
      return tr.replaceWith(pos, pos + node.nodeSize, newNode);
    if (!type.validContent(node.content))
      throw new RangeError("Invalid content for node type " + type.name);
    tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
  }
  function canSplit(doc3, pos, depth = 1, typesAfter) {
    let $pos = doc3.resolve(pos), base2 = $pos.depth - depth;
    let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
    if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
      return false;
    for (let d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {
      let node = $pos.node(d), index2 = $pos.index(d);
      if (node.type.spec.isolating)
        return false;
      let rest = node.content.cutByIndex(index2, node.childCount);
      let overrideChild = typesAfter && typesAfter[i + 1];
      if (overrideChild)
        rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
      let after = typesAfter && typesAfter[i] || node;
      if (!node.canReplace(index2 + 1, node.childCount) || !after.type.validContent(rest))
        return false;
    }
    let index = $pos.indexAfter(base2);
    let baseType = typesAfter && typesAfter[0];
    return $pos.node(base2).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base2 + 1).type);
  }
  function split(tr, pos, depth = 1, typesAfter) {
    let $pos = tr.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
    for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
      before = Fragment.from($pos.node(d).copy(before));
      let typeAfter = typesAfter && typesAfter[i];
      after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
    }
    tr.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
  }
  function canJoin(doc3, pos) {
    let $pos = doc3.resolve(pos), index = $pos.index();
    return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
  }
  function joinable2(a, b) {
    return !!(a && b && !a.isLeaf && a.canAppend(b));
  }
  function joinPoint(doc3, pos, dir = -1) {
    let $pos = doc3.resolve(pos);
    for (let d = $pos.depth; ; d--) {
      let before, after, index = $pos.index(d);
      if (d == $pos.depth) {
        before = $pos.nodeBefore;
        after = $pos.nodeAfter;
      } else if (dir > 0) {
        before = $pos.node(d + 1);
        index++;
        after = $pos.node(d).maybeChild(index);
      } else {
        before = $pos.node(d).maybeChild(index - 1);
        after = $pos.node(d + 1);
      }
      if (before && !before.isTextblock && joinable2(before, after) && $pos.node(d).canReplace(index, index + 1))
        return pos;
      if (d == 0)
        break;
      pos = dir < 0 ? $pos.before(d) : $pos.after(d);
    }
  }
  function join(tr, pos, depth) {
    let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
    tr.step(step);
  }
  function insertPoint(doc3, pos, nodeType) {
    let $pos = doc3.resolve(pos);
    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
      return pos;
    if ($pos.parentOffset == 0)
      for (let d = $pos.depth - 1; d >= 0; d--) {
        let index = $pos.index(d);
        if ($pos.node(d).canReplaceWith(index, index, nodeType))
          return $pos.before(d + 1);
        if (index > 0)
          return null;
      }
    if ($pos.parentOffset == $pos.parent.content.size)
      for (let d = $pos.depth - 1; d >= 0; d--) {
        let index = $pos.indexAfter(d);
        if ($pos.node(d).canReplaceWith(index, index, nodeType))
          return $pos.after(d + 1);
        if (index < $pos.node(d).childCount)
          return null;
      }
    return null;
  }
  function dropPoint(doc3, pos, slice2) {
    let $pos = doc3.resolve(pos);
    if (!slice2.content.size)
      return pos;
    let content = slice2.content;
    for (let i = 0; i < slice2.openStart; i++)
      content = content.firstChild.content;
    for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
      for (let d = $pos.depth; d >= 0; d--) {
        let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
        let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
        let parent = $pos.node(d), fits = false;
        if (pass == 1) {
          fits = parent.canReplace(insertPos, insertPos, content);
        } else {
          let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
          fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
        }
        if (fits)
          return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
      }
    }
    return null;
  }
  function replaceStep(doc3, from2, to = from2, slice2 = Slice.empty) {
    if (from2 == to && !slice2.size)
      return null;
    let $from = doc3.resolve(from2), $to = doc3.resolve(to);
    if (fitsTrivially($from, $to, slice2))
      return new ReplaceStep(from2, to, slice2);
    return new Fitter($from, $to, slice2).fit();
  }
  function fitsTrivially($from, $to, slice2) {
    return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
  }
  var Fitter = class {
    constructor($from, $to, unplaced) {
      this.$from = $from;
      this.$to = $to;
      this.unplaced = unplaced;
      this.frontier = [];
      this.placed = Fragment.empty;
      for (let i = 0; i <= $from.depth; i++) {
        let node = $from.node(i);
        this.frontier.push({
          type: node.type,
          match: node.contentMatchAt($from.indexAfter(i))
        });
      }
      for (let i = $from.depth; i > 0; i--)
        this.placed = Fragment.from($from.node(i).copy(this.placed));
    }
    get depth() {
      return this.frontier.length - 1;
    }
    fit() {
      while (this.unplaced.size) {
        let fit = this.findFittable();
        if (fit)
          this.placeNodes(fit);
        else
          this.openMore() || this.dropNode();
      }
      let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
      let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
      if (!$to)
        return null;
      let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
      while (openStart && openEnd && content.childCount == 1) {
        content = content.firstChild.content;
        openStart--;
        openEnd--;
      }
      let slice2 = new Slice(content, openStart, openEnd);
      if (moveInline > -1)
        return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
      if (slice2.size || $from.pos != this.$to.pos)
        return new ReplaceStep($from.pos, $to.pos, slice2);
      return null;
    }
    // Find a position on the start spine of `this.unplaced` that has
    // content that can be moved somewhere on the frontier. Returns two
    // depths, one for the slice and one for the frontier.
    findFittable() {
      let startDepth = this.unplaced.openStart;
      for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
        let node = cur.firstChild;
        if (cur.childCount > 1)
          openEnd = 0;
        if (node.type.spec.isolating && openEnd <= d) {
          startDepth = d;
          break;
        }
        cur = node.content;
      }
      for (let pass = 1; pass <= 2; pass++) {
        for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
          let fragment, parent = null;
          if (sliceDepth) {
            parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
            fragment = parent.content;
          } else {
            fragment = this.unplaced.content;
          }
          let first2 = fragment.firstChild;
          for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
            let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;
            if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type)))
              return { sliceDepth, frontierDepth, parent, inject };
            else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type)))
              return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
            if (parent && match.matchType(parent.type))
              break;
          }
        }
      }
    }
    openMore() {
      let { content, openStart, openEnd } = this.unplaced;
      let inner = contentAt(content, openStart);
      if (!inner.childCount || inner.firstChild.isLeaf)
        return false;
      this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
      return true;
    }
    dropNode() {
      let { content, openStart, openEnd } = this.unplaced;
      let inner = contentAt(content, openStart);
      if (inner.childCount <= 1 && openStart > 0) {
        let openAtEnd = content.size - openStart <= openStart + inner.size;
        this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
      } else {
        this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
      }
    }
    // Move content from the unplaced slice at `sliceDepth` to the
    // frontier node at `frontierDepth`. Close that frontier node when
    // applicable.
    placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
      while (this.depth > frontierDepth)
        this.closeFrontierNode();
      if (wrap2)
        for (let i = 0; i < wrap2.length; i++)
          this.openFrontierNode(wrap2[i]);
      let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
      let openStart = slice2.openStart - sliceDepth;
      let taken = 0, add = [];
      let { match, type } = this.frontier[frontierDepth];
      if (inject) {
        for (let i = 0; i < inject.childCount; i++)
          add.push(inject.child(i));
        match = match.matchFragment(inject);
      }
      let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
      while (taken < fragment.childCount) {
        let next = fragment.child(taken), matches2 = match.matchType(next.type);
        if (!matches2)
          break;
        taken++;
        if (taken > 1 || openStart == 0 || next.content.size) {
          match = matches2;
          add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
        }
      }
      let toEnd = taken == fragment.childCount;
      if (!toEnd)
        openEndCount = -1;
      this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
      this.frontier[frontierDepth].match = match;
      if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
        this.closeFrontierNode();
      for (let i = 0, cur = fragment; i < openEndCount; i++) {
        let node = cur.lastChild;
        this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
        cur = node.content;
      }
      this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
    }
    mustMoveInline() {
      if (!this.$to.parent.isTextblock)
        return -1;
      let top2 = this.frontier[this.depth], level;
      if (!top2.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
        return -1;
      let { depth } = this.$to, after = this.$to.after(depth);
      while (depth > 1 && after == this.$to.end(--depth))
        ++after;
      return after;
    }
    findCloseLevel($to) {
      scan:
        for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
          let { match, type } = this.frontier[i];
          let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
          let fit = contentAfterFits($to, i, type, match, dropInner);
          if (!fit)
            continue;
          for (let d = i - 1; d >= 0; d--) {
            let { match: match2, type: type2 } = this.frontier[d];
            let matches2 = contentAfterFits($to, d, type2, match2, true);
            if (!matches2 || matches2.childCount)
              continue scan;
          }
          return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
        }
    }
    close($to) {
      let close2 = this.findCloseLevel($to);
      if (!close2)
        return null;
      while (this.depth > close2.depth)
        this.closeFrontierNode();
      if (close2.fit.childCount)
        this.placed = addToFragment(this.placed, close2.depth, close2.fit);
      $to = close2.move;
      for (let d = close2.depth + 1; d <= $to.depth; d++) {
        let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
        this.openFrontierNode(node.type, node.attrs, add);
      }
      return $to;
    }
    openFrontierNode(type, attrs = null, content) {
      let top2 = this.frontier[this.depth];
      top2.match = top2.match.matchType(type);
      this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
      this.frontier.push({ type, match: type.contentMatch });
    }
    closeFrontierNode() {
      let open = this.frontier.pop();
      let add = open.match.fillBefore(Fragment.empty, true);
      if (add.childCount)
        this.placed = addToFragment(this.placed, this.frontier.length, add);
    }
  };
  function dropFromFragment(fragment, depth, count) {
    if (depth == 0)
      return fragment.cutByIndex(count, fragment.childCount);
    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
  }
  function addToFragment(fragment, depth, content) {
    if (depth == 0)
      return fragment.append(content);
    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
  }
  function contentAt(fragment, depth) {
    for (let i = 0; i < depth; i++)
      fragment = fragment.firstChild.content;
    return fragment;
  }
  function closeNodeStart(node, openStart, openEnd) {
    if (openStart <= 0)
      return node;
    let frag = node.content;
    if (openStart > 1)
      frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
    if (openStart > 0) {
      frag = node.type.contentMatch.fillBefore(frag).append(frag);
      if (openEnd <= 0)
        frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
    }
    return node.copy(frag);
  }
  function contentAfterFits($to, depth, type, match, open) {
    let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
    if (index == node.childCount && !type.compatibleContent(node.type))
      return null;
    let fit = match.fillBefore(node.content, true, index);
    return fit && !invalidMarks(type, node.content, index) ? fit : null;
  }
  function invalidMarks(type, fragment, start2) {
    for (let i = start2; i < fragment.childCount; i++)
      if (!type.allowsMarks(fragment.child(i).marks))
        return true;
    return false;
  }
  function definesContent(type) {
    return type.spec.defining || type.spec.definingForContent;
  }
  function replaceRange(tr, from2, to, slice2) {
    if (!slice2.size)
      return tr.deleteRange(from2, to);
    let $from = tr.doc.resolve(from2), $to = tr.doc.resolve(to);
    if (fitsTrivially($from, $to, slice2))
      return tr.step(new ReplaceStep(from2, to, slice2));
    let targetDepths = coveredDepths($from, tr.doc.resolve(to));
    if (targetDepths[targetDepths.length - 1] == 0)
      targetDepths.pop();
    let preferredTarget = -($from.depth + 1);
    targetDepths.unshift(preferredTarget);
    for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
      let spec = $from.node(d).type.spec;
      if (spec.defining || spec.definingAsContext || spec.isolating)
        break;
      if (targetDepths.indexOf(d) > -1)
        preferredTarget = d;
      else if ($from.before(d) == pos)
        targetDepths.splice(1, 0, -d);
    }
    let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
    let leftNodes = [], preferredDepth = slice2.openStart;
    for (let content = slice2.content, i = 0; ; i++) {
      let node = content.firstChild;
      leftNodes.push(node);
      if (i == slice2.openStart)
        break;
      content = node.content;
    }
    for (let d = preferredDepth - 1; d >= 0; d--) {
      let leftNode = leftNodes[d], def = definesContent(leftNode.type);
      if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
        preferredDepth = d;
      else if (def || !leftNode.type.isTextblock)
        break;
    }
    for (let j = slice2.openStart; j >= 0; j--) {
      let openDepth = (j + preferredDepth + 1) % (slice2.openStart + 1);
      let insert = leftNodes[openDepth];
      if (!insert)
        continue;
      for (let i = 0; i < targetDepths.length; i++) {
        let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
        if (targetDepth < 0) {
          expand = false;
          targetDepth = -targetDepth;
        }
        let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
        if (parent.canReplaceWith(index, index, insert.type, insert.marks))
          return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
      }
    }
    let startSteps = tr.steps.length;
    for (let i = targetDepths.length - 1; i >= 0; i--) {
      tr.replace(from2, to, slice2);
      if (tr.steps.length > startSteps)
        break;
      let depth = targetDepths[i];
      if (depth < 0)
        continue;
      from2 = $from.before(depth);
      to = $to.after(depth);
    }
  }
  function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
    if (depth < oldOpen) {
      let first2 = fragment.firstChild;
      fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
    }
    if (depth > newOpen) {
      let match = parent.contentMatchAt(0);
      let start2 = match.fillBefore(fragment).append(fragment);
      fragment = start2.append(match.matchFragment(start2).fillBefore(Fragment.empty, true));
    }
    return fragment;
  }
  function replaceRangeWith(tr, from2, to, node) {
    if (!node.isInline && from2 == to && tr.doc.resolve(from2).parent.content.size) {
      let point = insertPoint(tr.doc, from2, node.type);
      if (point != null)
        from2 = to = point;
    }
    tr.replaceRange(from2, to, new Slice(Fragment.from(node), 0, 0));
  }
  function deleteRange(tr, from2, to) {
    let $from = tr.doc.resolve(from2), $to = tr.doc.resolve(to);
    let covered = coveredDepths($from, $to);
    for (let i = 0; i < covered.length; i++) {
      let depth = covered[i], last = i == covered.length - 1;
      if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
        return tr.delete($from.start(depth), $to.end(depth));
      if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
        return tr.delete($from.before(depth), $to.after(depth));
    }
    for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
      if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)
        return tr.delete($from.before(d), to);
    }
    tr.delete(from2, to);
  }
  function coveredDepths($from, $to) {
    let result = [], minDepth = Math.min($from.depth, $to.depth);
    for (let d = minDepth; d >= 0; d--) {
      let start2 = $from.start(d);
      if (start2 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
        break;
      if (start2 == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start2 - 1)
        result.push(d);
    }
    return result;
  }
  var AttrStep = class _AttrStep extends Step {
    /**
    Construct an attribute step.
    */
    constructor(pos, attr, value) {
      super();
      this.pos = pos;
      this.attr = attr;
      this.value = value;
    }
    apply(doc3) {
      let node = doc3.nodeAt(this.pos);
      if (!node)
        return StepResult.fail("No node at attribute step's position");
      let attrs = /* @__PURE__ */ Object.create(null);
      for (let name in node.attrs)
        attrs[name] = node.attrs[name];
      attrs[this.attr] = this.value;
      let updated = node.type.create(attrs, null, node.marks);
      return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
    }
    getMap() {
      return StepMap.empty;
    }
    invert(doc3) {
      return new _AttrStep(this.pos, this.attr, doc3.nodeAt(this.pos).attrs[this.attr]);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);
    }
    toJSON() {
      return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
    }
    static fromJSON(schema, json) {
      if (typeof json.pos != "number" || typeof json.attr != "string")
        throw new RangeError("Invalid input for AttrStep.fromJSON");
      return new _AttrStep(json.pos, json.attr, json.value);
    }
  };
  Step.jsonID("attr", AttrStep);
  var DocAttrStep = class _DocAttrStep extends Step {
    /**
    Construct an attribute step.
    */
    constructor(attr, value) {
      super();
      this.attr = attr;
      this.value = value;
    }
    apply(doc3) {
      let attrs = /* @__PURE__ */ Object.create(null);
      for (let name in doc3.attrs)
        attrs[name] = doc3.attrs[name];
      attrs[this.attr] = this.value;
      let updated = doc3.type.create(attrs, doc3.content, doc3.marks);
      return StepResult.ok(updated);
    }
    getMap() {
      return StepMap.empty;
    }
    invert(doc3) {
      return new _DocAttrStep(this.attr, doc3.attrs[this.attr]);
    }
    map(mapping) {
      return this;
    }
    toJSON() {
      return { stepType: "docAttr", attr: this.attr, value: this.value };
    }
    static fromJSON(schema, json) {
      if (typeof json.attr != "string")
        throw new RangeError("Invalid input for DocAttrStep.fromJSON");
      return new _DocAttrStep(json.attr, json.value);
    }
  };
  Step.jsonID("docAttr", DocAttrStep);
  var TransformError = class extends Error {
  };
  TransformError = function TransformError2(message) {
    let err = Error.call(this, message);
    err.__proto__ = TransformError2.prototype;
    return err;
  };
  TransformError.prototype = Object.create(Error.prototype);
  TransformError.prototype.constructor = TransformError;
  TransformError.prototype.name = "TransformError";
  var Transform = class {
    /**
    Create a transform that starts with the given document.
    */
    constructor(doc3) {
      this.doc = doc3;
      this.steps = [];
      this.docs = [];
      this.mapping = new Mapping();
    }
    /**
    The starting document.
    */
    get before() {
      return this.docs.length ? this.docs[0] : this.doc;
    }
    /**
    Apply a new step in this transform, saving the result. Throws an
    error when the step fails.
    */
    step(step) {
      let result = this.maybeStep(step);
      if (result.failed)
        throw new TransformError(result.failed);
      return this;
    }
    /**
    Try to apply a step in this transformation, ignoring it if it
    fails. Returns the step result.
    */
    maybeStep(step) {
      let result = step.apply(this.doc);
      if (!result.failed)
        this.addStep(step, result.doc);
      return result;
    }
    /**
    True when the document has been changed (when there are any
    steps).
    */
    get docChanged() {
      return this.steps.length > 0;
    }
    /**
    @internal
    */
    addStep(step, doc3) {
      this.docs.push(this.doc);
      this.steps.push(step);
      this.mapping.appendMap(step.getMap());
      this.doc = doc3;
    }
    /**
    Replace the part of the document between `from` and `to` with the
    given `slice`.
    */
    replace(from2, to = from2, slice2 = Slice.empty) {
      let step = replaceStep(this.doc, from2, to, slice2);
      if (step)
        this.step(step);
      return this;
    }
    /**
    Replace the given range with the given content, which may be a
    fragment, node, or array of nodes.
    */
    replaceWith(from2, to, content) {
      return this.replace(from2, to, new Slice(Fragment.from(content), 0, 0));
    }
    /**
    Delete the content between the given positions.
    */
    delete(from2, to) {
      return this.replace(from2, to, Slice.empty);
    }
    /**
    Insert the given content at the given position.
    */
    insert(pos, content) {
      return this.replaceWith(pos, pos, content);
    }
    /**
    Replace a range of the document with a given slice, using
    `from`, `to`, and the slice's
    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
    than fixed start and end points. This method may grow the
    replaced area or close open nodes in the slice in order to get a
    fit that is more in line with WYSIWYG expectations, by dropping
    fully covered parent nodes of the replaced region when they are
    marked [non-defining as
    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
    open parent node from the slice that _is_ marked as [defining
    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
    
    This is the method, for example, to handle paste. The similar
    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
    primitive tool which will _not_ move the start and end of its given
    range, and is useful in situations where you need more precise
    control over what happens.
    */
    replaceRange(from2, to, slice2) {
      replaceRange(this, from2, to, slice2);
      return this;
    }
    /**
    Replace the given range with a node, but use `from` and `to` as
    hints, rather than precise positions. When from and to are the same
    and are at the start or end of a parent node in which the given
    node doesn't fit, this method may _move_ them out towards a parent
    that does allow the given node to be placed. When the given range
    completely covers a parent node, this method may completely replace
    that parent node.
    */
    replaceRangeWith(from2, to, node) {
      replaceRangeWith(this, from2, to, node);
      return this;
    }
    /**
    Delete the given range, expanding it to cover fully covered
    parent nodes until a valid replace is found.
    */
    deleteRange(from2, to) {
      deleteRange(this, from2, to);
      return this;
    }
    /**
    Split the content in the given range off from its parent, if there
    is sibling content before or after it, and move it up the tree to
    the depth specified by `target`. You'll probably want to use
    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
    sure the lift is valid.
    */
    lift(range, target) {
      lift(this, range, target);
      return this;
    }
    /**
    Join the blocks around the given position. If depth is 2, their
    last and first siblings are also joined, and so on.
    */
    join(pos, depth = 1) {
      join(this, pos, depth);
      return this;
    }
    /**
    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
    The wrappers are assumed to be valid in this position, and should
    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
    */
    wrap(range, wrappers) {
      wrap(this, range, wrappers);
      return this;
    }
    /**
    Set the type of all textblocks (partly) between `from` and `to` to
    the given node type with the given attributes.
    */
    setBlockType(from2, to = from2, type, attrs = null) {
      setBlockType(this, from2, to, type, attrs);
      return this;
    }
    /**
    Change the type, attributes, and/or marks of the node at `pos`.
    When `type` isn't given, the existing node type is preserved,
    */
    setNodeMarkup(pos, type, attrs = null, marks) {
      setNodeMarkup(this, pos, type, attrs, marks);
      return this;
    }
    /**
    Set a single attribute on a given node to a new value.
    The `pos` addresses the document content. Use `setDocAttribute`
    to set attributes on the document itself.
    */
    setNodeAttribute(pos, attr, value) {
      this.step(new AttrStep(pos, attr, value));
      return this;
    }
    /**
    Set a single attribute on the document to a new value.
    */
    setDocAttribute(attr, value) {
      this.step(new DocAttrStep(attr, value));
      return this;
    }
    /**
    Add a mark to the node at position `pos`.
    */
    addNodeMark(pos, mark) {
      this.step(new AddNodeMarkStep(pos, mark));
      return this;
    }
    /**
    Remove a mark (or a mark of the given type) from the node at
    position `pos`.
    */
    removeNodeMark(pos, mark) {
      if (!(mark instanceof Mark)) {
        let node = this.doc.nodeAt(pos);
        if (!node)
          throw new RangeError("No node at position " + pos);
        mark = mark.isInSet(node.marks);
        if (!mark)
          return this;
      }
      this.step(new RemoveNodeMarkStep(pos, mark));
      return this;
    }
    /**
    Split the node at the given position, and optionally, if `depth` is
    greater than one, any number of nodes above that. By default, the
    parts split off will inherit the node type of the original node.
    This can be changed by passing an array of types and attributes to
    use after the split.
    */
    split(pos, depth = 1, typesAfter) {
      split(this, pos, depth, typesAfter);
      return this;
    }
    /**
    Add the given mark to the inline content between `from` and `to`.
    */
    addMark(from2, to, mark) {
      addMark(this, from2, to, mark);
      return this;
    }
    /**
    Remove marks from inline nodes between `from` and `to`. When
    `mark` is a single mark, remove precisely that mark. When it is
    a mark type, remove all marks of that type. When it is null,
    remove all marks of any type.
    */
    removeMark(from2, to, mark) {
      removeMark(this, from2, to, mark);
      return this;
    }
    /**
    Removes all marks and nodes from the content of the node at
    `pos` that don't match the given new parent node type. Accepts
    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
    third argument.
    */
    clearIncompatible(pos, parentType, match) {
      clearIncompatible(this, pos, parentType, match);
      return this;
    }
  };

  // node_modules/prosemirror-state/dist/index.js
  var classesById = /* @__PURE__ */ Object.create(null);
  var Selection = class {
    /**
    Initialize a selection with the head and anchor and ranges. If no
    ranges are given, constructs a single range across `$anchor` and
    `$head`.
    */
    constructor($anchor, $head, ranges) {
      this.$anchor = $anchor;
      this.$head = $head;
      this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
    }
    /**
    The selection's anchor, as an unresolved position.
    */
    get anchor() {
      return this.$anchor.pos;
    }
    /**
    The selection's head.
    */
    get head() {
      return this.$head.pos;
    }
    /**
    The lower bound of the selection's main range.
    */
    get from() {
      return this.$from.pos;
    }
    /**
    The upper bound of the selection's main range.
    */
    get to() {
      return this.$to.pos;
    }
    /**
    The resolved lower  bound of the selection's main range.
    */
    get $from() {
      return this.ranges[0].$from;
    }
    /**
    The resolved upper bound of the selection's main range.
    */
    get $to() {
      return this.ranges[0].$to;
    }
    /**
    Indicates whether the selection contains any content.
    */
    get empty() {
      let ranges = this.ranges;
      for (let i = 0; i < ranges.length; i++)
        if (ranges[i].$from.pos != ranges[i].$to.pos)
          return false;
      return true;
    }
    /**
    Get the content of this selection as a slice.
    */
    content() {
      return this.$from.doc.slice(this.from, this.to, true);
    }
    /**
    Replace the selection with a slice or, if no slice is given,
    delete the selection. Will append to the given transaction.
    */
    replace(tr, content = Slice.empty) {
      let lastNode = content.content.lastChild, lastParent = null;
      for (let i = 0; i < content.openEnd; i++) {
        lastParent = lastNode;
        lastNode = lastNode.lastChild;
      }
      let mapFrom = tr.steps.length, ranges = this.ranges;
      for (let i = 0; i < ranges.length; i++) {
        let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
        tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
        if (i == 0)
          selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
      }
    }
    /**
    Replace the selection with the given node, appending the changes
    to the given transaction.
    */
    replaceWith(tr, node) {
      let mapFrom = tr.steps.length, ranges = this.ranges;
      for (let i = 0; i < ranges.length; i++) {
        let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
        let from2 = mapping.map($from.pos), to = mapping.map($to.pos);
        if (i) {
          tr.deleteRange(from2, to);
        } else {
          tr.replaceRangeWith(from2, to, node);
          selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
        }
      }
    }
    /**
    Find a valid cursor or leaf node selection starting at the given
    position and searching back if `dir` is negative, and forward if
    positive. When `textOnly` is true, only consider cursor
    selections. Will return null when no valid selection position is
    found.
    */
    static findFrom($pos, dir, textOnly = false) {
      let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
      if (inner)
        return inner;
      for (let depth = $pos.depth - 1; depth >= 0; depth--) {
        let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
        if (found2)
          return found2;
      }
      return null;
    }
    /**
    Find a valid cursor or leaf node selection near the given
    position. Searches forward first by default, but if `bias` is
    negative, it will search backwards first.
    */
    static near($pos, bias = 1) {
      return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
    }
    /**
    Find the cursor or leaf node selection closest to the start of
    the given document. Will return an
    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
    exists.
    */
    static atStart(doc3) {
      return findSelectionIn(doc3, doc3, 0, 0, 1) || new AllSelection(doc3);
    }
    /**
    Find the cursor or leaf node selection closest to the end of the
    given document.
    */
    static atEnd(doc3) {
      return findSelectionIn(doc3, doc3, doc3.content.size, doc3.childCount, -1) || new AllSelection(doc3);
    }
    /**
    Deserialize the JSON representation of a selection. Must be
    implemented for custom classes (as a static class method).
    */
    static fromJSON(doc3, json) {
      if (!json || !json.type)
        throw new RangeError("Invalid input for Selection.fromJSON");
      let cls = classesById[json.type];
      if (!cls)
        throw new RangeError(`No selection type ${json.type} defined`);
      return cls.fromJSON(doc3, json);
    }
    /**
    To be able to deserialize selections from JSON, custom selection
    classes must register themselves with an ID string, so that they
    can be disambiguated. Try to pick something that's unlikely to
    clash with classes from other modules.
    */
    static jsonID(id, selectionClass) {
      if (id in classesById)
        throw new RangeError("Duplicate use of selection JSON ID " + id);
      classesById[id] = selectionClass;
      selectionClass.prototype.jsonID = id;
      return selectionClass;
    }
    /**
    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
    which is a value that can be mapped without having access to a
    current document, and later resolved to a real selection for a
    given document again. (This is used mostly by the history to
    track and restore old selections.) The default implementation of
    this method just converts the selection to a text selection and
    returns the bookmark for that.
    */
    getBookmark() {
      return TextSelection.between(this.$anchor, this.$head).getBookmark();
    }
  };
  Selection.prototype.visible = true;
  var SelectionRange = class {
    /**
    Create a range.
    */
    constructor($from, $to) {
      this.$from = $from;
      this.$to = $to;
    }
  };
  var warnedAboutTextSelection = false;
  function checkTextSelection($pos) {
    if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
      warnedAboutTextSelection = true;
      console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
    }
  }
  var TextSelection = class _TextSelection extends Selection {
    /**
    Construct a text selection between the given points.
    */
    constructor($anchor, $head = $anchor) {
      checkTextSelection($anchor);
      checkTextSelection($head);
      super($anchor, $head);
    }
    /**
    Returns a resolved position if this is a cursor selection (an
    empty text selection), and null otherwise.
    */
    get $cursor() {
      return this.$anchor.pos == this.$head.pos ? this.$head : null;
    }
    map(doc3, mapping) {
      let $head = doc3.resolve(mapping.map(this.head));
      if (!$head.parent.inlineContent)
        return Selection.near($head);
      let $anchor = doc3.resolve(mapping.map(this.anchor));
      return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
    }
    replace(tr, content = Slice.empty) {
      super.replace(tr, content);
      if (content == Slice.empty) {
        let marks = this.$from.marksAcross(this.$to);
        if (marks)
          tr.ensureMarks(marks);
      }
    }
    eq(other) {
      return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;
    }
    getBookmark() {
      return new TextBookmark(this.anchor, this.head);
    }
    toJSON() {
      return { type: "text", anchor: this.anchor, head: this.head };
    }
    /**
    @internal
    */
    static fromJSON(doc3, json) {
      if (typeof json.anchor != "number" || typeof json.head != "number")
        throw new RangeError("Invalid input for TextSelection.fromJSON");
      return new _TextSelection(doc3.resolve(json.anchor), doc3.resolve(json.head));
    }
    /**
    Create a text selection from non-resolved positions.
    */
    static create(doc3, anchor, head = anchor) {
      let $anchor = doc3.resolve(anchor);
      return new this($anchor, head == anchor ? $anchor : doc3.resolve(head));
    }
    /**
    Return a text selection that spans the given positions or, if
    they aren't text positions, find a text selection near them.
    `bias` determines whether the method searches forward (default)
    or backwards (negative number) first. Will fall back to calling
    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
    doesn't contain a valid text position.
    */
    static between($anchor, $head, bias) {
      let dPos = $anchor.pos - $head.pos;
      if (!bias || dPos)
        bias = dPos >= 0 ? 1 : -1;
      if (!$head.parent.inlineContent) {
        let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
        if (found2)
          $head = found2.$head;
        else
          return Selection.near($head, bias);
      }
      if (!$anchor.parent.inlineContent) {
        if (dPos == 0) {
          $anchor = $head;
        } else {
          $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
          if ($anchor.pos < $head.pos != dPos < 0)
            $anchor = $head;
        }
      }
      return new _TextSelection($anchor, $head);
    }
  };
  Selection.jsonID("text", TextSelection);
  var TextBookmark = class _TextBookmark {
    constructor(anchor, head) {
      this.anchor = anchor;
      this.head = head;
    }
    map(mapping) {
      return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
    }
    resolve(doc3) {
      return TextSelection.between(doc3.resolve(this.anchor), doc3.resolve(this.head));
    }
  };
  var NodeSelection = class _NodeSelection extends Selection {
    /**
    Create a node selection. Does not verify the validity of its
    argument.
    */
    constructor($pos) {
      let node = $pos.nodeAfter;
      let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
      super($pos, $end);
      this.node = node;
    }
    map(doc3, mapping) {
      let { deleted, pos } = mapping.mapResult(this.anchor);
      let $pos = doc3.resolve(pos);
      if (deleted)
        return Selection.near($pos);
      return new _NodeSelection($pos);
    }
    content() {
      return new Slice(Fragment.from(this.node), 0, 0);
    }
    eq(other) {
      return other instanceof _NodeSelection && other.anchor == this.anchor;
    }
    toJSON() {
      return { type: "node", anchor: this.anchor };
    }
    getBookmark() {
      return new NodeBookmark(this.anchor);
    }
    /**
    @internal
    */
    static fromJSON(doc3, json) {
      if (typeof json.anchor != "number")
        throw new RangeError("Invalid input for NodeSelection.fromJSON");
      return new _NodeSelection(doc3.resolve(json.anchor));
    }
    /**
    Create a node selection from non-resolved positions.
    */
    static create(doc3, from2) {
      return new _NodeSelection(doc3.resolve(from2));
    }
    /**
    Determines whether the given node may be selected as a node
    selection.
    */
    static isSelectable(node) {
      return !node.isText && node.type.spec.selectable !== false;
    }
  };
  NodeSelection.prototype.visible = false;
  Selection.jsonID("node", NodeSelection);
  var NodeBookmark = class _NodeBookmark {
    constructor(anchor) {
      this.anchor = anchor;
    }
    map(mapping) {
      let { deleted, pos } = mapping.mapResult(this.anchor);
      return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);
    }
    resolve(doc3) {
      let $pos = doc3.resolve(this.anchor), node = $pos.nodeAfter;
      if (node && NodeSelection.isSelectable(node))
        return new NodeSelection($pos);
      return Selection.near($pos);
    }
  };
  var AllSelection = class _AllSelection extends Selection {
    /**
    Create an all-selection over the given document.
    */
    constructor(doc3) {
      super(doc3.resolve(0), doc3.resolve(doc3.content.size));
    }
    replace(tr, content = Slice.empty) {
      if (content == Slice.empty) {
        tr.delete(0, tr.doc.content.size);
        let sel = Selection.atStart(tr.doc);
        if (!sel.eq(tr.selection))
          tr.setSelection(sel);
      } else {
        super.replace(tr, content);
      }
    }
    toJSON() {
      return { type: "all" };
    }
    /**
    @internal
    */
    static fromJSON(doc3) {
      return new _AllSelection(doc3);
    }
    map(doc3) {
      return new _AllSelection(doc3);
    }
    eq(other) {
      return other instanceof _AllSelection;
    }
    getBookmark() {
      return AllBookmark;
    }
  };
  Selection.jsonID("all", AllSelection);
  var AllBookmark = {
    map() {
      return this;
    },
    resolve(doc3) {
      return new AllSelection(doc3);
    }
  };
  function findSelectionIn(doc3, node, pos, index, dir, text = false) {
    if (node.inlineContent)
      return TextSelection.create(doc3, pos);
    for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
      let child = node.child(i);
      if (!child.isAtom) {
        let inner = findSelectionIn(doc3, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
        if (inner)
          return inner;
      } else if (!text && NodeSelection.isSelectable(child)) {
        return NodeSelection.create(doc3, pos - (dir < 0 ? child.nodeSize : 0));
      }
      pos += child.nodeSize * dir;
    }
    return null;
  }
  function selectionToInsertionEnd(tr, startLen, bias) {
    let last = tr.steps.length - 1;
    if (last < startLen)
      return;
    let step = tr.steps[last];
    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
      return;
    let map2 = tr.mapping.maps[last], end2;
    map2.forEach((_from, _to, _newFrom, newTo) => {
      if (end2 == null)
        end2 = newTo;
    });
    tr.setSelection(Selection.near(tr.doc.resolve(end2), bias));
  }
  var UPDATED_SEL = 1;
  var UPDATED_MARKS = 2;
  var UPDATED_SCROLL = 4;
  var Transaction = class extends Transform {
    /**
    @internal
    */
    constructor(state) {
      super(state.doc);
      this.curSelectionFor = 0;
      this.updated = 0;
      this.meta = /* @__PURE__ */ Object.create(null);
      this.time = Date.now();
      this.curSelection = state.selection;
      this.storedMarks = state.storedMarks;
    }
    /**
    The transaction's current selection. This defaults to the editor
    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
    transaction, but can be overwritten with
    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
    */
    get selection() {
      if (this.curSelectionFor < this.steps.length) {
        this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
        this.curSelectionFor = this.steps.length;
      }
      return this.curSelection;
    }
    /**
    Update the transaction's current selection. Will determine the
    selection that the editor gets when the transaction is applied.
    */
    setSelection(selection) {
      if (selection.$from.doc != this.doc)
        throw new RangeError("Selection passed to setSelection must point at the current document");
      this.curSelection = selection;
      this.curSelectionFor = this.steps.length;
      this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
      this.storedMarks = null;
      return this;
    }
    /**
    Whether the selection was explicitly updated by this transaction.
    */
    get selectionSet() {
      return (this.updated & UPDATED_SEL) > 0;
    }
    /**
    Set the current stored marks.
    */
    setStoredMarks(marks) {
      this.storedMarks = marks;
      this.updated |= UPDATED_MARKS;
      return this;
    }
    /**
    Make sure the current stored marks or, if that is null, the marks
    at the selection, match the given set of marks. Does nothing if
    this is already the case.
    */
    ensureMarks(marks) {
      if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
        this.setStoredMarks(marks);
      return this;
    }
    /**
    Add a mark to the set of stored marks.
    */
    addStoredMark(mark) {
      return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
    }
    /**
    Remove a mark or mark type from the set of stored marks.
    */
    removeStoredMark(mark) {
      return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
    }
    /**
    Whether the stored marks were explicitly set for this transaction.
    */
    get storedMarksSet() {
      return (this.updated & UPDATED_MARKS) > 0;
    }
    /**
    @internal
    */
    addStep(step, doc3) {
      super.addStep(step, doc3);
      this.updated = this.updated & ~UPDATED_MARKS;
      this.storedMarks = null;
    }
    /**
    Update the timestamp for the transaction.
    */
    setTime(time) {
      this.time = time;
      return this;
    }
    /**
    Replace the current selection with the given slice.
    */
    replaceSelection(slice2) {
      this.selection.replace(this, slice2);
      return this;
    }
    /**
    Replace the selection with the given node. When `inheritMarks` is
    true and the content is inline, it inherits the marks from the
    place where it is inserted.
    */
    replaceSelectionWith(node, inheritMarks = true) {
      let selection = this.selection;
      if (inheritMarks)
        node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
      selection.replaceWith(this, node);
      return this;
    }
    /**
    Delete the selection.
    */
    deleteSelection() {
      this.selection.replace(this);
      return this;
    }
    /**
    Replace the given range, or the selection if no range is given,
    with a text node containing the given string.
    */
    insertText(text, from2, to) {
      let schema = this.doc.type.schema;
      if (from2 == null) {
        if (!text)
          return this.deleteSelection();
        return this.replaceSelectionWith(schema.text(text), true);
      } else {
        if (to == null)
          to = from2;
        to = to == null ? from2 : to;
        if (!text)
          return this.deleteRange(from2, to);
        let marks = this.storedMarks;
        if (!marks) {
          let $from = this.doc.resolve(from2);
          marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
        }
        this.replaceRangeWith(from2, to, schema.text(text, marks));
        if (!this.selection.empty)
          this.setSelection(Selection.near(this.selection.$to));
        return this;
      }
    }
    /**
    Store a metadata property in this transaction, keyed either by
    name or by plugin.
    */
    setMeta(key, value) {
      this.meta[typeof key == "string" ? key : key.key] = value;
      return this;
    }
    /**
    Retrieve a metadata property for a given name or plugin.
    */
    getMeta(key) {
      return this.meta[typeof key == "string" ? key : key.key];
    }
    /**
    Returns true if this transaction doesn't contain any metadata,
    and can thus safely be extended.
    */
    get isGeneric() {
      for (let _ in this.meta)
        return false;
      return true;
    }
    /**
    Indicate that the editor should scroll the selection into view
    when updated to the state produced by this transaction.
    */
    scrollIntoView() {
      this.updated |= UPDATED_SCROLL;
      return this;
    }
    /**
    True when this transaction has had `scrollIntoView` called on it.
    */
    get scrolledIntoView() {
      return (this.updated & UPDATED_SCROLL) > 0;
    }
  };
  function bind(f, self) {
    return !self || !f ? f : f.bind(self);
  }
  var FieldDesc = class {
    constructor(name, desc, self) {
      this.name = name;
      this.init = bind(desc.init, self);
      this.apply = bind(desc.apply, self);
    }
  };
  var baseFields = [
    new FieldDesc("doc", {
      init(config2) {
        return config2.doc || config2.schema.topNodeType.createAndFill();
      },
      apply(tr) {
        return tr.doc;
      }
    }),
    new FieldDesc("selection", {
      init(config2, instance) {
        return config2.selection || Selection.atStart(instance.doc);
      },
      apply(tr) {
        return tr.selection;
      }
    }),
    new FieldDesc("storedMarks", {
      init(config2) {
        return config2.storedMarks || null;
      },
      apply(tr, _marks, _old, state) {
        return state.selection.$cursor ? tr.storedMarks : null;
      }
    }),
    new FieldDesc("scrollToSelection", {
      init() {
        return 0;
      },
      apply(tr, prev) {
        return tr.scrolledIntoView ? prev + 1 : prev;
      }
    })
  ];
  var Configuration = class {
    constructor(schema, plugins) {
      this.schema = schema;
      this.plugins = [];
      this.pluginsByKey = /* @__PURE__ */ Object.create(null);
      this.fields = baseFields.slice();
      if (plugins)
        plugins.forEach((plugin) => {
          if (this.pluginsByKey[plugin.key])
            throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
          this.plugins.push(plugin);
          this.pluginsByKey[plugin.key] = plugin;
          if (plugin.spec.state)
            this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
        });
    }
  };
  var EditorState = class _EditorState {
    /**
    @internal
    */
    constructor(config2) {
      this.config = config2;
    }
    /**
    The schema of the state's document.
    */
    get schema() {
      return this.config.schema;
    }
    /**
    The plugins that are active in this state.
    */
    get plugins() {
      return this.config.plugins;
    }
    /**
    Apply the given transaction to produce a new state.
    */
    apply(tr) {
      return this.applyTransaction(tr).state;
    }
    /**
    @internal
    */
    filterTransaction(tr, ignore = -1) {
      for (let i = 0; i < this.config.plugins.length; i++)
        if (i != ignore) {
          let plugin = this.config.plugins[i];
          if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))
            return false;
        }
      return true;
    }
    /**
    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
    returns the precise transactions that were applied (which might
    be influenced by the [transaction
    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
    plugins) along with the new state.
    */
    applyTransaction(rootTr) {
      if (!this.filterTransaction(rootTr))
        return { state: this, transactions: [] };
      let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
      for (; ; ) {
        let haveNew = false;
        for (let i = 0; i < this.config.plugins.length; i++) {
          let plugin = this.config.plugins[i];
          if (plugin.spec.appendTransaction) {
            let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
            let tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
            if (tr && newState.filterTransaction(tr, i)) {
              tr.setMeta("appendedTransaction", rootTr);
              if (!seen) {
                seen = [];
                for (let j = 0; j < this.config.plugins.length; j++)
                  seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
              }
              trs.push(tr);
              newState = newState.applyInner(tr);
              haveNew = true;
            }
            if (seen)
              seen[i] = { state: newState, n: trs.length };
          }
        }
        if (!haveNew)
          return { state: newState, transactions: trs };
      }
    }
    /**
    @internal
    */
    applyInner(tr) {
      if (!tr.before.eq(this.doc))
        throw new RangeError("Applying a mismatched transaction");
      let newInstance = new _EditorState(this.config), fields = this.config.fields;
      for (let i = 0; i < fields.length; i++) {
        let field = fields[i];
        newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
      }
      return newInstance;
    }
    /**
    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
    */
    get tr() {
      return new Transaction(this);
    }
    /**
    Create a new state.
    */
    static create(config2) {
      let $config = new Configuration(config2.doc ? config2.doc.type.schema : config2.schema, config2.plugins);
      let instance = new _EditorState($config);
      for (let i = 0; i < $config.fields.length; i++)
        instance[$config.fields[i].name] = $config.fields[i].init(config2, instance);
      return instance;
    }
    /**
    Create a new state based on this one, but with an adjusted set
    of active plugins. State fields that exist in both sets of
    plugins are kept unchanged. Those that no longer exist are
    dropped, and those that are new are initialized using their
    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
    configuration object..
    */
    reconfigure(config2) {
      let $config = new Configuration(this.schema, config2.plugins);
      let fields = $config.fields, instance = new _EditorState($config);
      for (let i = 0; i < fields.length; i++) {
        let name = fields[i].name;
        instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config2, instance);
      }
      return instance;
    }
    /**
    Serialize this state to JSON. If you want to serialize the state
    of plugins, pass an object mapping property names to use in the
    resulting JSON object to plugin objects. The argument may also be
    a string or number, in which case it is ignored, to support the
    way `JSON.stringify` calls `toString` methods.
    */
    toJSON(pluginFields) {
      let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
      if (this.storedMarks)
        result.storedMarks = this.storedMarks.map((m) => m.toJSON());
      if (pluginFields && typeof pluginFields == "object")
        for (let prop in pluginFields) {
          if (prop == "doc" || prop == "selection")
            throw new RangeError("The JSON fields `doc` and `selection` are reserved");
          let plugin = pluginFields[prop], state = plugin.spec.state;
          if (state && state.toJSON)
            result[prop] = state.toJSON.call(plugin, this[plugin.key]);
        }
      return result;
    }
    /**
    Deserialize a JSON representation of a state. `config` should
    have at least a `schema` field, and should contain array of
    plugins to initialize the state with. `pluginFields` can be used
    to deserialize the state of plugins, by associating plugin
    instances with the property names they use in the JSON object.
    */
    static fromJSON(config2, json, pluginFields) {
      if (!json)
        throw new RangeError("Invalid input for EditorState.fromJSON");
      if (!config2.schema)
        throw new RangeError("Required config field 'schema' missing");
      let $config = new Configuration(config2.schema, config2.plugins);
      let instance = new _EditorState($config);
      $config.fields.forEach((field) => {
        if (field.name == "doc") {
          instance.doc = Node.fromJSON(config2.schema, json.doc);
        } else if (field.name == "selection") {
          instance.selection = Selection.fromJSON(instance.doc, json.selection);
        } else if (field.name == "storedMarks") {
          if (json.storedMarks)
            instance.storedMarks = json.storedMarks.map(config2.schema.markFromJSON);
        } else {
          if (pluginFields)
            for (let prop in pluginFields) {
              let plugin = pluginFields[prop], state = plugin.spec.state;
              if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
                instance[field.name] = state.fromJSON.call(plugin, config2, json[prop], instance);
                return;
              }
            }
          instance[field.name] = field.init(config2, instance);
        }
      });
      return instance;
    }
  };
  function bindProps(obj, self, target) {
    for (let prop in obj) {
      let val = obj[prop];
      if (val instanceof Function)
        val = val.bind(self);
      else if (prop == "handleDOMEvents")
        val = bindProps(val, self, {});
      target[prop] = val;
    }
    return target;
  }
  var Plugin = class {
    /**
    Create a plugin.
    */
    constructor(spec) {
      this.spec = spec;
      this.props = {};
      if (spec.props)
        bindProps(spec.props, this, this.props);
      this.key = spec.key ? spec.key.key : createKey("plugin");
    }
    /**
    Extract the plugin's state field from an editor state.
    */
    getState(state) {
      return state[this.key];
    }
  };
  var keys = /* @__PURE__ */ Object.create(null);
  function createKey(name) {
    if (name in keys)
      return name + "$" + ++keys[name];
    keys[name] = 0;
    return name + "$";
  }
  var PluginKey = class {
    /**
    Create a plugin key.
    */
    constructor(name = "key") {
      this.key = createKey(name);
    }
    /**
    Get the active plugin with this key, if any, from an editor
    state.
    */
    get(state) {
      return state.config.pluginsByKey[this.key];
    }
    /**
    Get the plugin's state from an editor state.
    */
    getState(state) {
      return state[this.key];
    }
  };

  // node_modules/prosemirror-view/dist/index.js
  var domIndex = function(node) {
    for (var index = 0; ; index++) {
      node = node.previousSibling;
      if (!node)
        return index;
    }
  };
  var parentNode = function(node) {
    let parent = node.assignedSlot || node.parentNode;
    return parent && parent.nodeType == 11 ? parent.host : parent;
  };
  var reusedRange = null;
  var textRange = function(node, from2, to) {
    let range = reusedRange || (reusedRange = document.createRange());
    range.setEnd(node, to == null ? node.nodeValue.length : to);
    range.setStart(node, from2 || 0);
    return range;
  };
  var isEquivalentPosition = function(node, off, targetNode, targetOff) {
    return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
  };
  var atomElements = /^(img|br|input|textarea|hr)$/i;
  function scanFor(node, off, targetNode, targetOff, dir) {
    for (; ; ) {
      if (node == targetNode && off == targetOff)
        return true;
      if (off == (dir < 0 ? 0 : nodeSize(node))) {
        let parent = node.parentNode;
        if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
          return false;
        off = domIndex(node) + (dir < 0 ? 0 : 1);
        node = parent;
      } else if (node.nodeType == 1) {
        node = node.childNodes[off + (dir < 0 ? -1 : 0)];
        if (node.contentEditable == "false")
          return false;
        off = dir < 0 ? nodeSize(node) : 0;
      } else {
        return false;
      }
    }
  }
  function nodeSize(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  function isOnEdge(node, offset2, parent) {
    for (let atStart = offset2 == 0, atEnd = offset2 == nodeSize(node); atStart || atEnd; ) {
      if (node == parent)
        return true;
      let index = domIndex(node);
      node = node.parentNode;
      if (!node)
        return false;
      atStart = atStart && index == 0;
      atEnd = atEnd && index == nodeSize(node);
    }
  }
  function hasBlockDesc(dom) {
    let desc;
    for (let cur = dom; cur; cur = cur.parentNode)
      if (desc = cur.pmViewDesc)
        break;
    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
  }
  var selectionCollapsed = function(domSel) {
    return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
  };
  function keyEvent(keyCode, key) {
    let event = document.createEvent("Event");
    event.initEvent("keydown", true, true);
    event.keyCode = keyCode;
    event.key = event.code = key;
    return event;
  }
  function deepActiveElement(doc3) {
    let elt = doc3.activeElement;
    while (elt && elt.shadowRoot)
      elt = elt.shadowRoot.activeElement;
    return elt;
  }
  function caretFromPoint(doc3, x, y) {
    if (doc3.caretPositionFromPoint) {
      try {
        let pos = doc3.caretPositionFromPoint(x, y);
        if (pos)
          return { node: pos.offsetNode, offset: pos.offset };
      } catch (_) {
      }
    }
    if (doc3.caretRangeFromPoint) {
      let range = doc3.caretRangeFromPoint(x, y);
      if (range)
        return { node: range.startContainer, offset: range.startOffset };
    }
  }
  var nav = typeof navigator != "undefined" ? navigator : null;
  var doc2 = typeof document != "undefined" ? document : null;
  var agent = nav && nav.userAgent || "";
  var ie_edge = /Edge\/(\d+)/.exec(agent);
  var ie_upto10 = /MSIE \d/.exec(agent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
  var ie = !!(ie_upto10 || ie_11up || ie_edge);
  var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
  var gecko = !ie && /gecko\/(\d+)/i.test(agent);
  gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
  var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
  var chrome = !!_chrome;
  var chrome_version = _chrome ? +_chrome[1] : 0;
  var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
  var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
  var mac = ios || (nav ? /Mac/.test(nav.platform) : false);
  var windows = nav ? /Win/.test(nav.platform) : false;
  var android = /Android \d/.test(agent);
  var webkit = !!doc2 && "webkitFontSmoothing" in doc2.documentElement.style;
  var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
  function windowRect(doc3) {
    return {
      left: 0,
      right: doc3.documentElement.clientWidth,
      top: 0,
      bottom: doc3.documentElement.clientHeight
    };
  }
  function getSide(value, side) {
    return typeof value == "number" ? value : value[side];
  }
  function clientRect(node) {
    let rect = node.getBoundingClientRect();
    let scaleX = rect.width / node.offsetWidth || 1;
    let scaleY = rect.height / node.offsetHeight || 1;
    return {
      left: rect.left,
      right: rect.left + node.clientWidth * scaleX,
      top: rect.top,
      bottom: rect.top + node.clientHeight * scaleY
    };
  }
  function scrollRectIntoView(view, rect, startDOM) {
    let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
    let doc3 = view.dom.ownerDocument;
    for (let parent = startDOM || view.dom; ; parent = parentNode(parent)) {
      if (!parent)
        break;
      if (parent.nodeType != 1)
        continue;
      let elt = parent;
      let atTop = elt == doc3.body;
      let bounding = atTop ? windowRect(doc3) : clientRect(elt);
      let moveX = 0, moveY = 0;
      if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
        moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
      else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
        moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
      if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
        moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
      else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
        moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
      if (moveX || moveY) {
        if (atTop) {
          doc3.defaultView.scrollBy(moveX, moveY);
        } else {
          let startX = elt.scrollLeft, startY = elt.scrollTop;
          if (moveY)
            elt.scrollTop += moveY;
          if (moveX)
            elt.scrollLeft += moveX;
          let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
          rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
        }
      }
      if (atTop || /^(fixed|sticky)$/.test(getComputedStyle(parent).position))
        break;
    }
  }
  function storeScrollPos(view) {
    let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
    let refDOM, refTop;
    for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
      let dom = view.root.elementFromPoint(x, y);
      if (!dom || dom == view.dom || !view.dom.contains(dom))
        continue;
      let localRect = dom.getBoundingClientRect();
      if (localRect.top >= startY - 20) {
        refDOM = dom;
        refTop = localRect.top;
        break;
      }
    }
    return { refDOM, refTop, stack: scrollStack(view.dom) };
  }
  function scrollStack(dom) {
    let stack = [], doc3 = dom.ownerDocument;
    for (let cur = dom; cur; cur = parentNode(cur)) {
      stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
      if (dom == doc3)
        break;
    }
    return stack;
  }
  function resetScrollPos({ refDOM, refTop, stack }) {
    let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
    restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
  }
  function restoreScrollStack(stack, dTop) {
    for (let i = 0; i < stack.length; i++) {
      let { dom, top: top2, left: left2 } = stack[i];
      if (dom.scrollTop != top2 + dTop)
        dom.scrollTop = top2 + dTop;
      if (dom.scrollLeft != left2)
        dom.scrollLeft = left2;
    }
  }
  var preventScrollSupported = null;
  function focusPreventScroll(dom) {
    if (dom.setActive)
      return dom.setActive();
    if (preventScrollSupported)
      return dom.focus(preventScrollSupported);
    let stored = scrollStack(dom);
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = { preventScroll: true };
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      restoreScrollStack(stored, 0);
    }
  }
  function findOffsetInNode(node, coords) {
    let closest, dxClosest = 2e8, coordsClosest, offset2 = 0;
    let rowBot = coords.top, rowTop = coords.top;
    let firstBelow, coordsBelow;
    for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
      let rects;
      if (child.nodeType == 1)
        rects = child.getClientRects();
      else if (child.nodeType == 3)
        rects = textRange(child).getClientRects();
      else
        continue;
      for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        if (rect.top <= rowBot && rect.bottom >= rowTop) {
          rowBot = Math.max(rect.bottom, rowBot);
          rowTop = Math.min(rect.top, rowTop);
          let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
          if (dx < dxClosest) {
            closest = child;
            dxClosest = dx;
            coordsClosest = dx && closest.nodeType == 3 ? {
              left: rect.right < coords.left ? rect.right : rect.left,
              top: coords.top
            } : coords;
            if (child.nodeType == 1 && dx)
              offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
            continue;
          }
        } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
          firstBelow = child;
          coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
        }
        if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
          offset2 = childIndex + 1;
      }
    }
    if (!closest && firstBelow) {
      closest = firstBelow;
      coordsClosest = coordsBelow;
      dxClosest = 0;
    }
    if (closest && closest.nodeType == 3)
      return findOffsetInText(closest, coordsClosest);
    if (!closest || dxClosest && closest.nodeType == 1)
      return { node, offset: offset2 };
    return findOffsetInNode(closest, coordsClosest);
  }
  function findOffsetInText(node, coords) {
    let len = node.nodeValue.length;
    let range = document.createRange();
    for (let i = 0; i < len; i++) {
      range.setEnd(node, i + 1);
      range.setStart(node, i);
      let rect = singleRect(range, 1);
      if (rect.top == rect.bottom)
        continue;
      if (inRect(coords, rect))
        return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
    }
    return { node, offset: 0 };
  }
  function inRect(coords, rect) {
    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
  }
  function targetKludge(dom, coords) {
    let parent = dom.parentNode;
    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
      return parent;
    return dom;
  }
  function posFromElement(view, elt, coords) {
    let { node, offset: offset2 } = findOffsetInNode(elt, coords), bias = -1;
    if (node.nodeType == 1 && !node.firstChild) {
      let rect = node.getBoundingClientRect();
      bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
    }
    return view.docView.posFromDOM(node, offset2, bias);
  }
  function posFromCaret(view, node, offset2, coords) {
    let outsideBlock = -1;
    for (let cur = node, sawBlock = false; ; ) {
      if (cur == view.dom)
        break;
      let desc = view.docView.nearestDesc(cur, true);
      if (!desc)
        return null;
      if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent && !sawBlock || !desc.contentDOM)) {
        let rect = desc.dom.getBoundingClientRect();
        if (desc.node.isBlock && desc.parent && !sawBlock) {
          sawBlock = true;
          if (rect.left > coords.left || rect.top > coords.top)
            outsideBlock = desc.posBefore;
          else if (rect.right < coords.left || rect.bottom < coords.top)
            outsideBlock = desc.posAfter;
        }
        if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
          let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
          return before ? desc.posBefore : desc.posAfter;
        }
      }
      cur = desc.dom.parentNode;
    }
    return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset2, -1);
  }
  function elementFromPoint(element, coords, box) {
    let len = element.childNodes.length;
    if (len && box.top < box.bottom) {
      for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
        let child = element.childNodes[i];
        if (child.nodeType == 1) {
          let rects = child.getClientRects();
          for (let j = 0; j < rects.length; j++) {
            let rect = rects[j];
            if (inRect(coords, rect))
              return elementFromPoint(child, coords, rect);
          }
        }
        if ((i = (i + 1) % len) == startI)
          break;
      }
    }
    return element;
  }
  function posAtCoords(view, coords) {
    let doc3 = view.dom.ownerDocument, node, offset2 = 0;
    let caret = caretFromPoint(doc3, coords.left, coords.top);
    if (caret)
      ({ node, offset: offset2 } = caret);
    let elt = (view.root.elementFromPoint ? view.root : doc3).elementFromPoint(coords.left, coords.top);
    let pos;
    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
      let box = view.dom.getBoundingClientRect();
      if (!inRect(coords, box))
        return null;
      elt = elementFromPoint(view.dom, coords, box);
      if (!elt)
        return null;
    }
    if (safari) {
      for (let p = elt; node && p; p = parentNode(p))
        if (p.draggable)
          node = void 0;
    }
    elt = targetKludge(elt, coords);
    if (node) {
      if (gecko && node.nodeType == 1) {
        offset2 = Math.min(offset2, node.childNodes.length);
        if (offset2 < node.childNodes.length) {
          let next = node.childNodes[offset2], box;
          if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
            offset2++;
        }
      }
      let prev;
      if (webkit && offset2 && node.nodeType == 1 && (prev = node.childNodes[offset2 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
        offset2--;
      if (node == view.dom && offset2 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
        pos = view.state.doc.content.size;
      else if (offset2 == 0 || node.nodeType != 1 || node.childNodes[offset2 - 1].nodeName != "BR")
        pos = posFromCaret(view, node, offset2, coords);
    }
    if (pos == null)
      pos = posFromElement(view, elt, coords);
    let desc = view.docView.nearestDesc(elt, true);
    return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
  }
  function nonZero(rect) {
    return rect.top < rect.bottom || rect.left < rect.right;
  }
  function singleRect(target, bias) {
    let rects = target.getClientRects();
    if (rects.length) {
      let first2 = rects[bias < 0 ? 0 : rects.length - 1];
      if (nonZero(first2))
        return first2;
    }
    return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
  }
  var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  function coordsAtPos(view, pos, side) {
    let { node, offset: offset2, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
    let supportEmptyRange = webkit || gecko;
    if (node.nodeType == 3) {
      if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset2 : offset2 == node.nodeValue.length))) {
        let rect = singleRect(textRange(node, offset2, offset2), side);
        if (gecko && offset2 && /\s/.test(node.nodeValue[offset2 - 1]) && offset2 < node.nodeValue.length) {
          let rectBefore = singleRect(textRange(node, offset2 - 1, offset2 - 1), -1);
          if (rectBefore.top == rect.top) {
            let rectAfter = singleRect(textRange(node, offset2, offset2 + 1), -1);
            if (rectAfter.top != rect.top)
              return flattenV(rectAfter, rectAfter.left < rectBefore.left);
          }
        }
        return rect;
      } else {
        let from2 = offset2, to = offset2, takeSide = side < 0 ? 1 : -1;
        if (side < 0 && !offset2) {
          to++;
          takeSide = -1;
        } else if (side >= 0 && offset2 == node.nodeValue.length) {
          from2--;
          takeSide = 1;
        } else if (side < 0) {
          from2--;
        } else {
          to++;
        }
        return flattenV(singleRect(textRange(node, from2, to), takeSide), takeSide < 0);
      }
    }
    let $dom = view.state.doc.resolve(pos - (atom || 0));
    if (!$dom.parent.inlineContent) {
      if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
        let before = node.childNodes[offset2 - 1];
        if (before.nodeType == 1)
          return flattenH(before.getBoundingClientRect(), false);
      }
      if (atom == null && offset2 < nodeSize(node)) {
        let after = node.childNodes[offset2];
        if (after.nodeType == 1)
          return flattenH(after.getBoundingClientRect(), true);
      }
      return flattenH(node.getBoundingClientRect(), side >= 0);
    }
    if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
      let before = node.childNodes[offset2 - 1];
      let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
      if (target)
        return flattenV(singleRect(target, 1), false);
    }
    if (atom == null && offset2 < nodeSize(node)) {
      let after = node.childNodes[offset2];
      while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
        after = after.nextSibling;
      let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
      if (target)
        return flattenV(singleRect(target, -1), true);
    }
    return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
  }
  function flattenV(rect, left2) {
    if (rect.width == 0)
      return rect;
    let x = left2 ? rect.left : rect.right;
    return { top: rect.top, bottom: rect.bottom, left: x, right: x };
  }
  function flattenH(rect, top2) {
    if (rect.height == 0)
      return rect;
    let y = top2 ? rect.top : rect.bottom;
    return { top: y, bottom: y, left: rect.left, right: rect.right };
  }
  function withFlushedState(view, state, f) {
    let viewState = view.state, active = view.root.activeElement;
    if (viewState != state)
      view.updateState(state);
    if (active != view.dom)
      view.focus();
    try {
      return f();
    } finally {
      if (viewState != state)
        view.updateState(viewState);
      if (active != view.dom && active)
        active.focus();
    }
  }
  function endOfTextblockVertical(view, state, dir) {
    let sel = state.selection;
    let $pos = dir == "up" ? sel.$from : sel.$to;
    return withFlushedState(view, state, () => {
      let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
      for (; ; ) {
        let nearest = view.docView.nearestDesc(dom, true);
        if (!nearest)
          break;
        if (nearest.node.isBlock) {
          dom = nearest.contentDOM || nearest.dom;
          break;
        }
        dom = nearest.dom.parentNode;
      }
      let coords = coordsAtPos(view, $pos.pos, 1);
      for (let child = dom.firstChild; child; child = child.nextSibling) {
        let boxes;
        if (child.nodeType == 1)
          boxes = child.getClientRects();
        else if (child.nodeType == 3)
          boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
        else
          continue;
        for (let i = 0; i < boxes.length; i++) {
          let box = boxes[i];
          if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
            return false;
        }
      }
      return true;
    });
  }
  var maybeRTL = /[\u0590-\u08ac]/;
  function endOfTextblockHorizontal(view, state, dir) {
    let { $head } = state.selection;
    if (!$head.parent.isTextblock)
      return false;
    let offset2 = $head.parentOffset, atStart = !offset2, atEnd = offset2 == $head.parent.content.size;
    let sel = view.domSelection();
    if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
      return dir == "left" || dir == "backward" ? atStart : atEnd;
    return withFlushedState(view, state, () => {
      let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
      let oldBidiLevel = sel.caretBidiLevel;
      sel.modify("move", dir, "character");
      let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
      let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
      let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
      try {
        sel.collapse(anchorNode, anchorOffset);
        if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
          sel.extend(oldNode, oldOff);
      } catch (_) {
      }
      if (oldBidiLevel != null)
        sel.caretBidiLevel = oldBidiLevel;
      return result;
    });
  }
  var cachedState = null;
  var cachedDir = null;
  var cachedResult = false;
  function endOfTextblock(view, state, dir) {
    if (cachedState == state && cachedDir == dir)
      return cachedResult;
    cachedState = state;
    cachedDir = dir;
    return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
  }
  var NOT_DIRTY = 0;
  var CHILD_DIRTY = 1;
  var CONTENT_DIRTY = 2;
  var NODE_DIRTY = 3;
  var ViewDesc = class {
    constructor(parent, children, dom, contentDOM) {
      this.parent = parent;
      this.children = children;
      this.dom = dom;
      this.contentDOM = contentDOM;
      this.dirty = NOT_DIRTY;
      dom.pmViewDesc = this;
    }
    // Used to check whether a given description corresponds to a
    // widget/mark/node.
    matchesWidget(widget) {
      return false;
    }
    matchesMark(mark) {
      return false;
    }
    matchesNode(node, outerDeco, innerDeco) {
      return false;
    }
    matchesHack(nodeName) {
      return false;
    }
    // When parsing in-editor content (in domchange.js), we allow
    // descriptions to determine the parse rules that should be used to
    // parse them.
    parseRule() {
      return null;
    }
    // Used by the editor's event handler to ignore events that come
    // from certain descs.
    stopEvent(event) {
      return false;
    }
    // The size of the content represented by this desc.
    get size() {
      let size = 0;
      for (let i = 0; i < this.children.length; i++)
        size += this.children[i].size;
      return size;
    }
    // For block nodes, this represents the space taken up by their
    // start/end tokens.
    get border() {
      return 0;
    }
    destroy() {
      this.parent = void 0;
      if (this.dom.pmViewDesc == this)
        this.dom.pmViewDesc = void 0;
      for (let i = 0; i < this.children.length; i++)
        this.children[i].destroy();
    }
    posBeforeChild(child) {
      for (let i = 0, pos = this.posAtStart; ; i++) {
        let cur = this.children[i];
        if (cur == child)
          return pos;
        pos += cur.size;
      }
    }
    get posBefore() {
      return this.parent.posBeforeChild(this);
    }
    get posAtStart() {
      return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
    }
    get posAfter() {
      return this.posBefore + this.size;
    }
    get posAtEnd() {
      return this.posAtStart + this.size - 2 * this.border;
    }
    localPosFromDOM(dom, offset2, bias) {
      if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
        if (bias < 0) {
          let domBefore, desc;
          if (dom == this.contentDOM) {
            domBefore = dom.childNodes[offset2 - 1];
          } else {
            while (dom.parentNode != this.contentDOM)
              dom = dom.parentNode;
            domBefore = dom.previousSibling;
          }
          while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
            domBefore = domBefore.previousSibling;
          return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
        } else {
          let domAfter, desc;
          if (dom == this.contentDOM) {
            domAfter = dom.childNodes[offset2];
          } else {
            while (dom.parentNode != this.contentDOM)
              dom = dom.parentNode;
            domAfter = dom.nextSibling;
          }
          while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
            domAfter = domAfter.nextSibling;
          return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
        }
      }
      let atEnd;
      if (dom == this.dom && this.contentDOM) {
        atEnd = offset2 > domIndex(this.contentDOM);
      } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
        atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
      } else if (this.dom.firstChild) {
        if (offset2 == 0)
          for (let search = dom; ; search = search.parentNode) {
            if (search == this.dom) {
              atEnd = false;
              break;
            }
            if (search.previousSibling)
              break;
          }
        if (atEnd == null && offset2 == dom.childNodes.length)
          for (let search = dom; ; search = search.parentNode) {
            if (search == this.dom) {
              atEnd = true;
              break;
            }
            if (search.nextSibling)
              break;
          }
      }
      return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
    }
    nearestDesc(dom, onlyNodes = false) {
      for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
        let desc = this.getDesc(cur), nodeDOM;
        if (desc && (!onlyNodes || desc.node)) {
          if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
            first2 = false;
          else
            return desc;
        }
      }
    }
    getDesc(dom) {
      let desc = dom.pmViewDesc;
      for (let cur = desc; cur; cur = cur.parent)
        if (cur == this)
          return desc;
    }
    posFromDOM(dom, offset2, bias) {
      for (let scan = dom; scan; scan = scan.parentNode) {
        let desc = this.getDesc(scan);
        if (desc)
          return desc.localPosFromDOM(dom, offset2, bias);
      }
      return -1;
    }
    // Find the desc for the node after the given pos, if any. (When a
    // parent node overrode rendering, there might not be one.)
    descAt(pos) {
      for (let i = 0, offset2 = 0; i < this.children.length; i++) {
        let child = this.children[i], end2 = offset2 + child.size;
        if (offset2 == pos && end2 != offset2) {
          while (!child.border && child.children.length)
            child = child.children[0];
          return child;
        }
        if (pos < end2)
          return child.descAt(pos - offset2 - child.border);
        offset2 = end2;
      }
    }
    domFromPos(pos, side) {
      if (!this.contentDOM)
        return { node: this.dom, offset: 0, atom: pos + 1 };
      let i = 0, offset2 = 0;
      for (let curPos = 0; i < this.children.length; i++) {
        let child = this.children[i], end2 = curPos + child.size;
        if (end2 > pos || child instanceof TrailingHackViewDesc) {
          offset2 = pos - curPos;
          break;
        }
        curPos = end2;
      }
      if (offset2)
        return this.children[i].domFromPos(offset2 - this.children[i].border, side);
      for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
      }
      if (side <= 0) {
        let prev, enter2 = true;
        for (; ; i--, enter2 = false) {
          prev = i ? this.children[i - 1] : null;
          if (!prev || prev.dom.parentNode == this.contentDOM)
            break;
        }
        if (prev && side && enter2 && !prev.border && !prev.domAtom)
          return prev.domFromPos(prev.size, side);
        return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
      } else {
        let next, enter2 = true;
        for (; ; i++, enter2 = false) {
          next = i < this.children.length ? this.children[i] : null;
          if (!next || next.dom.parentNode == this.contentDOM)
            break;
        }
        if (next && enter2 && !next.border && !next.domAtom)
          return next.domFromPos(0, side);
        return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
      }
    }
    // Used to find a DOM range in a single parent for a given changed
    // range.
    parseRange(from2, to, base2 = 0) {
      if (this.children.length == 0)
        return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
      let fromOffset = -1, toOffset = -1;
      for (let offset2 = base2, i = 0; ; i++) {
        let child = this.children[i], end2 = offset2 + child.size;
        if (fromOffset == -1 && from2 <= end2) {
          let childBase = offset2 + child.border;
          if (from2 >= childBase && to <= end2 - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
            return child.parseRange(from2, to, childBase);
          from2 = offset2;
          for (let j = i; j > 0; j--) {
            let prev = this.children[j - 1];
            if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
              fromOffset = domIndex(prev.dom) + 1;
              break;
            }
            from2 -= prev.size;
          }
          if (fromOffset == -1)
            fromOffset = 0;
        }
        if (fromOffset > -1 && (end2 > to || i == this.children.length - 1)) {
          to = end2;
          for (let j = i + 1; j < this.children.length; j++) {
            let next = this.children[j];
            if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
              toOffset = domIndex(next.dom);
              break;
            }
            to += next.size;
          }
          if (toOffset == -1)
            toOffset = this.contentDOM.childNodes.length;
          break;
        }
        offset2 = end2;
      }
      return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
    }
    emptyChildAt(side) {
      if (this.border || !this.contentDOM || !this.children.length)
        return false;
      let child = this.children[side < 0 ? 0 : this.children.length - 1];
      return child.size == 0 || child.emptyChildAt(side);
    }
    domAfterPos(pos) {
      let { node, offset: offset2 } = this.domFromPos(pos, 0);
      if (node.nodeType != 1 || offset2 == node.childNodes.length)
        throw new RangeError("No node after pos " + pos);
      return node.childNodes[offset2];
    }
    // View descs are responsible for setting any selection that falls
    // entirely inside of them, so that custom implementations can do
    // custom things with the selection. Note that this falls apart when
    // a selection starts in such a node and ends in another, in which
    // case we just use whatever domFromPos produces as a best effort.
    setSelection(anchor, head, root, force = false) {
      let from2 = Math.min(anchor, head), to = Math.max(anchor, head);
      for (let i = 0, offset2 = 0; i < this.children.length; i++) {
        let child = this.children[i], end2 = offset2 + child.size;
        if (from2 > offset2 && to < end2)
          return child.setSelection(anchor - offset2 - child.border, head - offset2 - child.border, root, force);
        offset2 = end2;
      }
      let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
      let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
      let domSel = root.getSelection();
      let brKludge = false;
      if ((gecko || safari) && anchor == head) {
        let { node, offset: offset2 } = anchorDOM;
        if (node.nodeType == 3) {
          brKludge = !!(offset2 && node.nodeValue[offset2 - 1] == "\n");
          if (brKludge && offset2 == node.nodeValue.length) {
            for (let scan = node, after; scan; scan = scan.parentNode) {
              if (after = scan.nextSibling) {
                if (after.nodeName == "BR")
                  anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
                break;
              }
              let desc = scan.pmViewDesc;
              if (desc && desc.node && desc.node.isBlock)
                break;
            }
          }
        } else {
          let prev = node.childNodes[offset2 - 1];
          brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
        }
      }
      if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
        let after = domSel.focusNode.childNodes[domSel.focusOffset];
        if (after && after.contentEditable == "false")
          force = true;
      }
      if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))
        return;
      let domSelExtended = false;
      if ((domSel.extend || anchor == head) && !brKludge) {
        domSel.collapse(anchorDOM.node, anchorDOM.offset);
        try {
          if (anchor != head)
            domSel.extend(headDOM.node, headDOM.offset);
          domSelExtended = true;
        } catch (_) {
        }
      }
      if (!domSelExtended) {
        if (anchor > head) {
          let tmp = anchorDOM;
          anchorDOM = headDOM;
          headDOM = tmp;
        }
        let range = document.createRange();
        range.setEnd(headDOM.node, headDOM.offset);
        range.setStart(anchorDOM.node, anchorDOM.offset);
        domSel.removeAllRanges();
        domSel.addRange(range);
      }
    }
    ignoreMutation(mutation) {
      return !this.contentDOM && mutation.type != "selection";
    }
    get contentLost() {
      return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
    }
    // Remove a subtree of the element tree that has been touched
    // by a DOM change, so that the next update will redraw it.
    markDirty(from2, to) {
      for (let offset2 = 0, i = 0; i < this.children.length; i++) {
        let child = this.children[i], end2 = offset2 + child.size;
        if (offset2 == end2 ? from2 <= end2 && to >= offset2 : from2 < end2 && to > offset2) {
          let startInside = offset2 + child.border, endInside = end2 - child.border;
          if (from2 >= startInside && to <= endInside) {
            this.dirty = from2 == offset2 || to == end2 ? CONTENT_DIRTY : CHILD_DIRTY;
            if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
              child.dirty = NODE_DIRTY;
            else
              child.markDirty(from2 - startInside, to - startInside);
            return;
          } else {
            child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
          }
        }
        offset2 = end2;
      }
      this.dirty = CONTENT_DIRTY;
    }
    markParentsDirty() {
      let level = 1;
      for (let node = this.parent; node; node = node.parent, level++) {
        let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
        if (node.dirty < dirty)
          node.dirty = dirty;
      }
    }
    get domAtom() {
      return false;
    }
    get ignoreForCoords() {
      return false;
    }
  };
  var WidgetViewDesc = class extends ViewDesc {
    constructor(parent, widget, view, pos) {
      let self, dom = widget.type.toDOM;
      if (typeof dom == "function")
        dom = dom(view, () => {
          if (!self)
            return pos;
          if (self.parent)
            return self.parent.posBeforeChild(self);
        });
      if (!widget.type.spec.raw) {
        if (dom.nodeType != 1) {
          let wrap2 = document.createElement("span");
          wrap2.appendChild(dom);
          dom = wrap2;
        }
        dom.contentEditable = "false";
        dom.classList.add("ProseMirror-widget");
      }
      super(parent, [], dom, null);
      this.widget = widget;
      this.widget = widget;
      self = this;
    }
    matchesWidget(widget) {
      return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
    }
    parseRule() {
      return { ignore: true };
    }
    stopEvent(event) {
      let stop = this.widget.spec.stopEvent;
      return stop ? stop(event) : false;
    }
    ignoreMutation(mutation) {
      return mutation.type != "selection" || this.widget.spec.ignoreSelection;
    }
    destroy() {
      this.widget.type.destroy(this.dom);
      super.destroy();
    }
    get domAtom() {
      return true;
    }
    get side() {
      return this.widget.type.side;
    }
  };
  var CompositionViewDesc = class extends ViewDesc {
    constructor(parent, dom, textDOM, text) {
      super(parent, [], dom, null);
      this.textDOM = textDOM;
      this.text = text;
    }
    get size() {
      return this.text.length;
    }
    localPosFromDOM(dom, offset2) {
      if (dom != this.textDOM)
        return this.posAtStart + (offset2 ? this.size : 0);
      return this.posAtStart + offset2;
    }
    domFromPos(pos) {
      return { node: this.textDOM, offset: pos };
    }
    ignoreMutation(mut) {
      return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
    }
  };
  var MarkViewDesc = class _MarkViewDesc extends ViewDesc {
    constructor(parent, mark, dom, contentDOM) {
      super(parent, [], dom, contentDOM);
      this.mark = mark;
    }
    static create(parent, mark, inline, view) {
      let custom = view.nodeViews[mark.type.name];
      let spec = custom && custom(mark, view, inline);
      if (!spec || !spec.dom)
        spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));
      return new _MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);
    }
    parseRule() {
      if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
        return null;
      return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
    }
    matchesMark(mark) {
      return this.dirty != NODE_DIRTY && this.mark.eq(mark);
    }
    markDirty(from2, to) {
      super.markDirty(from2, to);
      if (this.dirty != NOT_DIRTY) {
        let parent = this.parent;
        while (!parent.node)
          parent = parent.parent;
        if (parent.dirty < this.dirty)
          parent.dirty = this.dirty;
        this.dirty = NOT_DIRTY;
      }
    }
    slice(from2, to, view) {
      let copy2 = _MarkViewDesc.create(this.parent, this.mark, true, view);
      let nodes = this.children, size = this.size;
      if (to < size)
        nodes = replaceNodes(nodes, to, size, view);
      if (from2 > 0)
        nodes = replaceNodes(nodes, 0, from2, view);
      for (let i = 0; i < nodes.length; i++)
        nodes[i].parent = copy2;
      copy2.children = nodes;
      return copy2;
    }
  };
  var NodeViewDesc = class _NodeViewDesc extends ViewDesc {
    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
      super(parent, [], dom, contentDOM);
      this.node = node;
      this.outerDeco = outerDeco;
      this.innerDeco = innerDeco;
      this.nodeDOM = nodeDOM;
    }
    // By default, a node is rendered using the `toDOM` method from the
    // node type spec. But client code can use the `nodeViews` spec to
    // supply a custom node view, which can influence various aspects of
    // the way the node works.
    //
    // (Using subclassing for this was intentionally decided against,
    // since it'd require exposing a whole slew of finicky
    // implementation details to the user code that they probably will
    // never need.)
    static create(parent, node, outerDeco, innerDeco, view, pos) {
      let custom = view.nodeViews[node.type.name], descObj;
      let spec = custom && custom(node, view, () => {
        if (!descObj)
          return pos;
        if (descObj.parent)
          return descObj.parent.posBeforeChild(descObj);
      }, outerDeco, innerDeco);
      let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
      if (node.isText) {
        if (!dom)
          dom = document.createTextNode(node.text);
        else if (dom.nodeType != 3)
          throw new RangeError("Text must be rendered as a DOM text node");
      } else if (!dom) {
        ({ dom, contentDOM } = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)));
      }
      if (!contentDOM && !node.isText && dom.nodeName != "BR") {
        if (!dom.hasAttribute("contenteditable"))
          dom.contentEditable = "false";
        if (node.type.spec.draggable)
          dom.draggable = true;
      }
      let nodeDOM = dom;
      dom = applyOuterDeco(dom, outerDeco, node);
      if (spec)
        return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
      else if (node.isText)
        return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
      else
        return new _NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
    }
    parseRule() {
      if (this.node.type.spec.reparseInView)
        return null;
      let rule = { node: this.node.type.name, attrs: this.node.attrs };
      if (this.node.type.whitespace == "pre")
        rule.preserveWhitespace = "full";
      if (!this.contentDOM) {
        rule.getContent = () => this.node.content;
      } else if (!this.contentLost) {
        rule.contentElement = this.contentDOM;
      } else {
        for (let i = this.children.length - 1; i >= 0; i--) {
          let child = this.children[i];
          if (this.dom.contains(child.dom.parentNode)) {
            rule.contentElement = child.dom.parentNode;
            break;
          }
        }
        if (!rule.contentElement)
          rule.getContent = () => Fragment.empty;
      }
      return rule;
    }
    matchesNode(node, outerDeco, innerDeco) {
      return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
    }
    get size() {
      return this.node.nodeSize;
    }
    get border() {
      return this.node.isLeaf ? 0 : 1;
    }
    // Syncs `this.children` to match `this.node.content` and the local
    // decorations, possibly introducing nesting for marks. Then, in a
    // separate step, syncs the DOM inside `this.contentDOM` to
    // `this.children`.
    updateChildren(view, pos) {
      let inline = this.node.inlineContent, off = pos;
      let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
      let localComposition = composition && composition.pos > -1 ? composition : null;
      let compositionInChild = composition && composition.pos < 0;
      let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
      iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
        if (widget.spec.marks)
          updater.syncToMarks(widget.spec.marks, inline, view);
        else if (widget.type.side >= 0 && !insideNode)
          updater.syncToMarks(i == this.node.childCount ? Mark.none : this.node.child(i).marks, inline, view);
        updater.placeWidget(widget, view, off);
      }, (child, outerDeco, innerDeco, i) => {
        updater.syncToMarks(child.marks, inline, view);
        let compIndex;
        if (updater.findNodeMatch(child, outerDeco, innerDeco, i))
          ;
        else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view))
          ;
        else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off))
          ;
        else {
          updater.addNode(child, outerDeco, innerDeco, view, off);
        }
        off += child.nodeSize;
      });
      updater.syncToMarks([], inline, view);
      if (this.node.isTextblock)
        updater.addTextblockHacks();
      updater.destroyRest();
      if (updater.changed || this.dirty == CONTENT_DIRTY) {
        if (localComposition)
          this.protectLocalComposition(view, localComposition);
        renderDescs(this.contentDOM, this.children, view);
        if (ios)
          iosHacks(this.dom);
      }
    }
    localCompositionInfo(view, pos) {
      let { from: from2, to } = view.state.selection;
      if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)
        return null;
      let sel = view.domSelectionRange();
      let textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
      if (!textNode || !this.dom.contains(textNode.parentNode))
        return null;
      if (this.node.inlineContent) {
        let text = textNode.nodeValue;
        let textPos = findTextInFragment(this.node.content, text, from2 - pos, to - pos);
        return textPos < 0 ? null : { node: textNode, pos: textPos, text };
      } else {
        return { node: textNode, pos: -1, text: "" };
      }
    }
    protectLocalComposition(view, { node, pos, text }) {
      if (this.getDesc(node))
        return;
      let topNode = node;
      for (; ; topNode = topNode.parentNode) {
        if (topNode.parentNode == this.contentDOM)
          break;
        while (topNode.previousSibling)
          topNode.parentNode.removeChild(topNode.previousSibling);
        while (topNode.nextSibling)
          topNode.parentNode.removeChild(topNode.nextSibling);
        if (topNode.pmViewDesc)
          topNode.pmViewDesc = void 0;
      }
      let desc = new CompositionViewDesc(this, topNode, node, text);
      view.input.compositionNodes.push(desc);
      this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
    }
    // If this desc must be updated to match the given node decoration,
    // do so and return true.
    update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
        return false;
      this.updateInner(node, outerDeco, innerDeco, view);
      return true;
    }
    updateInner(node, outerDeco, innerDeco, view) {
      this.updateOuterDeco(outerDeco);
      this.node = node;
      this.innerDeco = innerDeco;
      if (this.contentDOM)
        this.updateChildren(view, this.posAtStart);
      this.dirty = NOT_DIRTY;
    }
    updateOuterDeco(outerDeco) {
      if (sameOuterDeco(outerDeco, this.outerDeco))
        return;
      let needsWrap = this.nodeDOM.nodeType != 1;
      let oldDOM = this.dom;
      this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
      if (this.dom != oldDOM) {
        oldDOM.pmViewDesc = void 0;
        this.dom.pmViewDesc = this;
      }
      this.outerDeco = outerDeco;
    }
    // Mark this node as being the selected node.
    selectNode() {
      if (this.nodeDOM.nodeType == 1)
        this.nodeDOM.classList.add("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.dom.draggable = true;
    }
    // Remove selected node marking from this node.
    deselectNode() {
      if (this.nodeDOM.nodeType == 1)
        this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.dom.removeAttribute("draggable");
    }
    get domAtom() {
      return this.node.isAtom;
    }
  };
  function docViewDesc(doc3, outerDeco, innerDeco, dom, view) {
    applyOuterDeco(dom, outerDeco, doc3);
    let docView = new NodeViewDesc(void 0, doc3, outerDeco, innerDeco, dom, dom, dom, view, 0);
    if (docView.contentDOM)
      docView.updateChildren(view, 0);
    return docView;
  }
  var TextViewDesc = class _TextViewDesc extends NodeViewDesc {
    constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
      super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
    }
    parseRule() {
      let skip = this.nodeDOM.parentNode;
      while (skip && skip != this.dom && !skip.pmIsDeco)
        skip = skip.parentNode;
      return { skip: skip || true };
    }
    update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
        return false;
      this.updateOuterDeco(outerDeco);
      if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
        this.nodeDOM.nodeValue = node.text;
        if (view.trackWrites == this.nodeDOM)
          view.trackWrites = null;
      }
      this.node = node;
      this.dirty = NOT_DIRTY;
      return true;
    }
    inParent() {
      let parentDOM = this.parent.contentDOM;
      for (let n = this.nodeDOM; n; n = n.parentNode)
        if (n == parentDOM)
          return true;
      return false;
    }
    domFromPos(pos) {
      return { node: this.nodeDOM, offset: pos };
    }
    localPosFromDOM(dom, offset2, bias) {
      if (dom == this.nodeDOM)
        return this.posAtStart + Math.min(offset2, this.node.text.length);
      return super.localPosFromDOM(dom, offset2, bias);
    }
    ignoreMutation(mutation) {
      return mutation.type != "characterData" && mutation.type != "selection";
    }
    slice(from2, to, view) {
      let node = this.node.cut(from2, to), dom = document.createTextNode(node.text);
      return new _TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
    }
    markDirty(from2, to) {
      super.markDirty(from2, to);
      if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
        this.dirty = NODE_DIRTY;
    }
    get domAtom() {
      return false;
    }
  };
  var TrailingHackViewDesc = class extends ViewDesc {
    parseRule() {
      return { ignore: true };
    }
    matchesHack(nodeName) {
      return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
    }
    get domAtom() {
      return true;
    }
    get ignoreForCoords() {
      return this.dom.nodeName == "IMG";
    }
  };
  var CustomNodeViewDesc = class extends NodeViewDesc {
    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
      super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
      this.spec = spec;
    }
    // A custom `update` method gets to decide whether the update goes
    // through. If it does, and there's a `contentDOM` node, our logic
    // updates the children.
    update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY)
        return false;
      if (this.spec.update) {
        let result = this.spec.update(node, outerDeco, innerDeco);
        if (result)
          this.updateInner(node, outerDeco, innerDeco, view);
        return result;
      } else if (!this.contentDOM && !node.isLeaf) {
        return false;
      } else {
        return super.update(node, outerDeco, innerDeco, view);
      }
    }
    selectNode() {
      this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
    }
    deselectNode() {
      this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
    }
    setSelection(anchor, head, root, force) {
      this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : super.setSelection(anchor, head, root, force);
    }
    destroy() {
      if (this.spec.destroy)
        this.spec.destroy();
      super.destroy();
    }
    stopEvent(event) {
      return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
    }
    ignoreMutation(mutation) {
      return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
    }
  };
  function renderDescs(parentDOM, descs, view) {
    let dom = parentDOM.firstChild, written = false;
    for (let i = 0; i < descs.length; i++) {
      let desc = descs[i], childDOM = desc.dom;
      if (childDOM.parentNode == parentDOM) {
        while (childDOM != dom) {
          dom = rm(dom);
          written = true;
        }
        dom = dom.nextSibling;
      } else {
        written = true;
        parentDOM.insertBefore(childDOM, dom);
      }
      if (desc instanceof MarkViewDesc) {
        let pos = dom ? dom.previousSibling : parentDOM.lastChild;
        renderDescs(desc.contentDOM, desc.children, view);
        dom = pos ? pos.nextSibling : parentDOM.firstChild;
      }
    }
    while (dom) {
      dom = rm(dom);
      written = true;
    }
    if (written && view.trackWrites == parentDOM)
      view.trackWrites = null;
  }
  var OuterDecoLevel = function(nodeName) {
    if (nodeName)
      this.nodeName = nodeName;
  };
  OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
  var noDeco = [new OuterDecoLevel()];
  function computeOuterDeco(outerDeco, node, needsWrap) {
    if (outerDeco.length == 0)
      return noDeco;
    let top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top2];
    for (let i = 0; i < outerDeco.length; i++) {
      let attrs = outerDeco[i].type.attrs;
      if (!attrs)
        continue;
      if (attrs.nodeName)
        result.push(top2 = new OuterDecoLevel(attrs.nodeName));
      for (let name in attrs) {
        let val = attrs[name];
        if (val == null)
          continue;
        if (needsWrap && result.length == 1)
          result.push(top2 = new OuterDecoLevel(node.isInline ? "span" : "div"));
        if (name == "class")
          top2.class = (top2.class ? top2.class + " " : "") + val;
        else if (name == "style")
          top2.style = (top2.style ? top2.style + ";" : "") + val;
        else if (name != "nodeName")
          top2[name] = val;
      }
    }
    return result;
  }
  function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
    if (prevComputed == noDeco && curComputed == noDeco)
      return nodeDOM;
    let curDOM = nodeDOM;
    for (let i = 0; i < curComputed.length; i++) {
      let deco = curComputed[i], prev = prevComputed[i];
      if (i) {
        let parent;
        if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
          curDOM = parent;
        } else {
          parent = document.createElement(deco.nodeName);
          parent.pmIsDeco = true;
          parent.appendChild(curDOM);
          prev = noDeco[0];
          curDOM = parent;
        }
      }
      patchAttributes(curDOM, prev || noDeco[0], deco);
    }
    return curDOM;
  }
  function patchAttributes(dom, prev, cur) {
    for (let name in prev)
      if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
        dom.removeAttribute(name);
    for (let name in cur)
      if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
        dom.setAttribute(name, cur[name]);
    if (prev.class != cur.class) {
      let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
      let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
      for (let i = 0; i < prevList.length; i++)
        if (curList.indexOf(prevList[i]) == -1)
          dom.classList.remove(prevList[i]);
      for (let i = 0; i < curList.length; i++)
        if (prevList.indexOf(curList[i]) == -1)
          dom.classList.add(curList[i]);
      if (dom.classList.length == 0)
        dom.removeAttribute("class");
    }
    if (prev.style != cur.style) {
      if (prev.style) {
        let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
        while (m = prop.exec(prev.style))
          dom.style.removeProperty(m[1]);
      }
      if (cur.style)
        dom.style.cssText += cur.style;
    }
  }
  function applyOuterDeco(dom, deco, node) {
    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
  }
  function sameOuterDeco(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].type.eq(b[i].type))
        return false;
    return true;
  }
  function rm(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  var ViewTreeUpdater = class {
    constructor(top2, lock, view) {
      this.lock = lock;
      this.view = view;
      this.index = 0;
      this.stack = [];
      this.changed = false;
      this.top = top2;
      this.preMatch = preMatch(top2.node.content, top2);
    }
    // Destroy and remove the children between the given indices in
    // `this.top`.
    destroyBetween(start2, end2) {
      if (start2 == end2)
        return;
      for (let i = start2; i < end2; i++)
        this.top.children[i].destroy();
      this.top.children.splice(start2, end2 - start2);
      this.changed = true;
    }
    // Destroy all remaining children in `this.top`.
    destroyRest() {
      this.destroyBetween(this.index, this.top.children.length);
    }
    // Sync the current stack of mark descs with the given array of
    // marks, reusing existing mark descs when possible.
    syncToMarks(marks, inline, view) {
      let keep = 0, depth = this.stack.length >> 1;
      let maxKeep = Math.min(depth, marks.length);
      while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
        keep++;
      while (keep < depth) {
        this.destroyRest();
        this.top.dirty = NOT_DIRTY;
        this.index = this.stack.pop();
        this.top = this.stack.pop();
        depth--;
      }
      while (depth < marks.length) {
        this.stack.push(this.top, this.index + 1);
        let found2 = -1;
        for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
          let next = this.top.children[i];
          if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
            found2 = i;
            break;
          }
        }
        if (found2 > -1) {
          if (found2 > this.index) {
            this.changed = true;
            this.destroyBetween(this.index, found2);
          }
          this.top = this.top.children[this.index];
        } else {
          let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
          this.top.children.splice(this.index, 0, markDesc);
          this.top = markDesc;
          this.changed = true;
        }
        this.index = 0;
        depth++;
      }
    }
    // Try to find a node desc matching the given data. Skip over it and
    // return true when successful.
    findNodeMatch(node, outerDeco, innerDeco, index) {
      let found2 = -1, targetDesc;
      if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
        found2 = this.top.children.indexOf(targetDesc, this.index);
      } else {
        for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
          let child = this.top.children[i];
          if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
            found2 = i;
            break;
          }
        }
      }
      if (found2 < 0)
        return false;
      this.destroyBetween(this.index, found2);
      this.index++;
      return true;
    }
    updateNodeAt(node, outerDeco, innerDeco, index, view) {
      let child = this.top.children[index];
      if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
        child.dirty = CONTENT_DIRTY;
      if (!child.update(node, outerDeco, innerDeco, view))
        return false;
      this.destroyBetween(this.index, index);
      this.index++;
      return true;
    }
    findIndexWithChild(domNode) {
      for (; ; ) {
        let parent = domNode.parentNode;
        if (!parent)
          return -1;
        if (parent == this.top.contentDOM) {
          let desc = domNode.pmViewDesc;
          if (desc)
            for (let i = this.index; i < this.top.children.length; i++) {
              if (this.top.children[i] == desc)
                return i;
            }
          return -1;
        }
        domNode = parent;
      }
    }
    // Try to update the next node, if any, to the given data. Checks
    // pre-matches to avoid overwriting nodes that could still be used.
    updateNextNode(node, outerDeco, innerDeco, view, index, pos) {
      for (let i = this.index; i < this.top.children.length; i++) {
        let next = this.top.children[i];
        if (next instanceof NodeViewDesc) {
          let preMatch2 = this.preMatch.matched.get(next);
          if (preMatch2 != null && preMatch2 != index)
            return false;
          let nextDOM = next.dom, updated;
          let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
          if (!locked && next.update(node, outerDeco, innerDeco, view)) {
            this.destroyBetween(this.index, i);
            if (next.dom != nextDOM)
              this.changed = true;
            this.index++;
            return true;
          } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
            this.top.children[this.index] = updated;
            if (updated.contentDOM) {
              updated.dirty = CONTENT_DIRTY;
              updated.updateChildren(view, pos + 1);
              updated.dirty = NOT_DIRTY;
            }
            this.changed = true;
            this.index++;
            return true;
          }
          break;
        }
      }
      return false;
    }
    // When a node with content is replaced by a different node with
    // identical content, move over its children.
    recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
      if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content))
        return null;
      let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
      if (wrapper.contentDOM) {
        wrapper.children = next.children;
        next.children = [];
        for (let ch of wrapper.children)
          ch.parent = wrapper;
      }
      next.destroy();
      return wrapper;
    }
    // Insert the node as a newly created node desc.
    addNode(node, outerDeco, innerDeco, view, pos) {
      let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
      if (desc.contentDOM)
        desc.updateChildren(view, pos + 1);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
    placeWidget(widget, view, pos) {
      let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
      if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
        this.index++;
      } else {
        let desc = new WidgetViewDesc(this.top, widget, view, pos);
        this.top.children.splice(this.index++, 0, desc);
        this.changed = true;
      }
    }
    // Make sure a textblock looks and behaves correctly in
    // contentEditable.
    addTextblockHacks() {
      let lastChild = this.top.children[this.index - 1], parent = this.top;
      while (lastChild instanceof MarkViewDesc) {
        parent = lastChild;
        lastChild = parent.children[parent.children.length - 1];
      }
      if (!lastChild || // Empty textblock
      !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
        if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
          this.addHackNode("IMG", parent);
        this.addHackNode("BR", this.top);
      }
    }
    addHackNode(nodeName, parent) {
      if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
        this.index++;
      } else {
        let dom = document.createElement(nodeName);
        if (nodeName == "IMG") {
          dom.className = "ProseMirror-separator";
          dom.alt = "";
        }
        if (nodeName == "BR")
          dom.className = "ProseMirror-trailingBreak";
        let hack = new TrailingHackViewDesc(this.top, [], dom, null);
        if (parent != this.top)
          parent.children.push(hack);
        else
          parent.children.splice(this.index++, 0, hack);
        this.changed = true;
      }
    }
    isLocked(node) {
      return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
    }
  };
  function preMatch(frag, parentDesc) {
    let curDesc = parentDesc, descI = curDesc.children.length;
    let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
    outer:
      while (fI > 0) {
        let desc;
        for (; ; ) {
          if (descI) {
            let next = curDesc.children[descI - 1];
            if (next instanceof MarkViewDesc) {
              curDesc = next;
              descI = next.children.length;
            } else {
              desc = next;
              descI--;
              break;
            }
          } else if (curDesc == parentDesc) {
            break outer;
          } else {
            descI = curDesc.parent.children.indexOf(curDesc);
            curDesc = curDesc.parent;
          }
        }
        let node = desc.node;
        if (!node)
          continue;
        if (node != frag.child(fI - 1))
          break;
        --fI;
        matched.set(desc, fI);
        matches2.push(desc);
      }
    return { index: fI, matched, matches: matches2.reverse() };
  }
  function compareSide(a, b) {
    return a.type.side - b.type.side;
  }
  function iterDeco(parent, deco, onWidget, onNode) {
    let locals = deco.locals(parent), offset2 = 0;
    if (locals.length == 0) {
      for (let i = 0; i < parent.childCount; i++) {
        let child = parent.child(i);
        onNode(child, locals, deco.forChild(offset2, child), i);
        offset2 += child.nodeSize;
      }
      return;
    }
    let decoIndex = 0, active = [], restNode = null;
    for (let parentIndex = 0; ; ) {
      let widget, widgets;
      while (decoIndex < locals.length && locals[decoIndex].to == offset2) {
        let next = locals[decoIndex++];
        if (next.widget) {
          if (!widget)
            widget = next;
          else
            (widgets || (widgets = [widget])).push(next);
        }
      }
      if (widget) {
        if (widgets) {
          widgets.sort(compareSide);
          for (let i = 0; i < widgets.length; i++)
            onWidget(widgets[i], parentIndex, !!restNode);
        } else {
          onWidget(widget, parentIndex, !!restNode);
        }
      }
      let child, index;
      if (restNode) {
        index = -1;
        child = restNode;
        restNode = null;
      } else if (parentIndex < parent.childCount) {
        index = parentIndex;
        child = parent.child(parentIndex++);
      } else {
        break;
      }
      for (let i = 0; i < active.length; i++)
        if (active[i].to <= offset2)
          active.splice(i--, 1);
      while (decoIndex < locals.length && locals[decoIndex].from <= offset2 && locals[decoIndex].to > offset2)
        active.push(locals[decoIndex++]);
      let end2 = offset2 + child.nodeSize;
      if (child.isText) {
        let cutAt = end2;
        if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
          cutAt = locals[decoIndex].from;
        for (let i = 0; i < active.length; i++)
          if (active[i].to < cutAt)
            cutAt = active[i].to;
        if (cutAt < end2) {
          restNode = child.cut(cutAt - offset2);
          child = child.cut(0, cutAt - offset2);
          end2 = cutAt;
          index = -1;
        }
      }
      let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
      onNode(child, outerDeco, deco.forChild(offset2, child), index);
      offset2 = end2;
    }
  }
  function iosHacks(dom) {
    if (dom.nodeName == "UL" || dom.nodeName == "OL") {
      let oldCSS = dom.style.cssText;
      dom.style.cssText = oldCSS + "; list-style: square !important";
      window.getComputedStyle(dom).listStyle;
      dom.style.cssText = oldCSS;
    }
  }
  function nearbyTextNode(node, offset2) {
    for (; ; ) {
      if (node.nodeType == 3)
        return node;
      if (node.nodeType == 1 && offset2 > 0) {
        if (node.childNodes.length > offset2 && node.childNodes[offset2].nodeType == 3)
          return node.childNodes[offset2];
        node = node.childNodes[offset2 - 1];
        offset2 = nodeSize(node);
      } else if (node.nodeType == 1 && offset2 < node.childNodes.length) {
        node = node.childNodes[offset2];
        offset2 = 0;
      } else {
        return null;
      }
    }
  }
  function findTextInFragment(frag, text, from2, to) {
    for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
      let child = frag.child(i++), childStart = pos;
      pos += child.nodeSize;
      if (!child.isText)
        continue;
      let str = child.text;
      while (i < frag.childCount) {
        let next = frag.child(i++);
        pos += next.nodeSize;
        if (!next.isText)
          break;
        str += next.text;
      }
      if (pos >= from2) {
        if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)
          return to - text.length;
        let found2 = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
        if (found2 >= 0 && found2 + text.length + childStart >= from2)
          return childStart + found2;
        if (from2 == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)
          return to;
      }
    }
    return -1;
  }
  function replaceNodes(nodes, from2, to, view, replacement) {
    let result = [];
    for (let i = 0, off = 0; i < nodes.length; i++) {
      let child = nodes[i], start2 = off, end2 = off += child.size;
      if (start2 >= to || end2 <= from2) {
        result.push(child);
      } else {
        if (start2 < from2)
          result.push(child.slice(0, from2 - start2, view));
        if (replacement) {
          result.push(replacement);
          replacement = void 0;
        }
        if (end2 > to)
          result.push(child.slice(to - start2, child.size, view));
      }
    }
    return result;
  }
  function selectionFromDOM(view, origin = null) {
    let domSel = view.domSelectionRange(), doc3 = view.state.doc;
    if (!domSel.focusNode)
      return null;
    let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
    let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
    if (head < 0)
      return null;
    let $head = doc3.resolve(head), $anchor, selection;
    if (selectionCollapsed(domSel)) {
      $anchor = $head;
      while (nearestDesc && !nearestDesc.node)
        nearestDesc = nearestDesc.parent;
      let nearestDescNode = nearestDesc.node;
      if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
        let pos = nearestDesc.posBefore;
        selection = new NodeSelection(head == pos ? $head : doc3.resolve(pos));
      }
    } else {
      let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
      if (anchor < 0)
        return null;
      $anchor = doc3.resolve(anchor);
    }
    if (!selection) {
      let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
      selection = selectionBetween(view, $anchor, $head, bias);
    }
    return selection;
  }
  function editorOwnsSelection(view) {
    return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
  }
  function selectionToDOM(view, force = false) {
    let sel = view.state.selection;
    syncNodeSelection(view, sel);
    if (!editorOwnsSelection(view))
      return;
    if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
      let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
      if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
        view.input.mouseDown.delayedSelectionSync = true;
        view.domObserver.setCurSelection();
        return;
      }
    }
    view.domObserver.disconnectSelection();
    if (view.cursorWrapper) {
      selectCursorWrapper(view);
    } else {
      let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
      if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
        if (!sel.$from.parent.inlineContent)
          resetEditableFrom = temporarilyEditableNear(view, sel.from);
        if (!sel.empty && !sel.$from.parent.inlineContent)
          resetEditableTo = temporarilyEditableNear(view, sel.to);
      }
      view.docView.setSelection(anchor, head, view.root, force);
      if (brokenSelectBetweenUneditable) {
        if (resetEditableFrom)
          resetEditable(resetEditableFrom);
        if (resetEditableTo)
          resetEditable(resetEditableTo);
      }
      if (sel.visible) {
        view.dom.classList.remove("ProseMirror-hideselection");
      } else {
        view.dom.classList.add("ProseMirror-hideselection");
        if ("onselectionchange" in document)
          removeClassOnSelectionChange(view);
      }
    }
    view.domObserver.setCurSelection();
    view.domObserver.connectSelection();
  }
  var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
  function temporarilyEditableNear(view, pos) {
    let { node, offset: offset2 } = view.docView.domFromPos(pos, 0);
    let after = offset2 < node.childNodes.length ? node.childNodes[offset2] : null;
    let before = offset2 ? node.childNodes[offset2 - 1] : null;
    if (safari && after && after.contentEditable == "false")
      return setEditable(after);
    if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
      if (after)
        return setEditable(after);
      else if (before)
        return setEditable(before);
    }
  }
  function setEditable(element) {
    element.contentEditable = "true";
    if (safari && element.draggable) {
      element.draggable = false;
      element.wasDraggable = true;
    }
    return element;
  }
  function resetEditable(element) {
    element.contentEditable = "false";
    if (element.wasDraggable) {
      element.draggable = true;
      element.wasDraggable = null;
    }
  }
  function removeClassOnSelectionChange(view) {
    let doc3 = view.dom.ownerDocument;
    doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
    let domSel = view.domSelectionRange();
    let node = domSel.anchorNode, offset2 = domSel.anchorOffset;
    doc3.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
      if (domSel.anchorNode != node || domSel.anchorOffset != offset2) {
        doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
        setTimeout(() => {
          if (!editorOwnsSelection(view) || view.state.selection.visible)
            view.dom.classList.remove("ProseMirror-hideselection");
        }, 20);
      }
    });
  }
  function selectCursorWrapper(view) {
    let domSel = view.domSelection(), range = document.createRange();
    let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
    if (img)
      range.setEnd(node.parentNode, domIndex(node) + 1);
    else
      range.setEnd(node, 0);
    range.collapse(false);
    domSel.removeAllRanges();
    domSel.addRange(range);
    if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
      node.disabled = true;
      node.disabled = false;
    }
  }
  function syncNodeSelection(view, sel) {
    if (sel instanceof NodeSelection) {
      let desc = view.docView.descAt(sel.from);
      if (desc != view.lastSelectedViewDesc) {
        clearNodeSelection(view);
        if (desc)
          desc.selectNode();
        view.lastSelectedViewDesc = desc;
      }
    } else {
      clearNodeSelection(view);
    }
  }
  function clearNodeSelection(view) {
    if (view.lastSelectedViewDesc) {
      if (view.lastSelectedViewDesc.parent)
        view.lastSelectedViewDesc.deselectNode();
      view.lastSelectedViewDesc = void 0;
    }
  }
  function selectionBetween(view, $anchor, $head, bias) {
    return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
  }
  function hasFocusAndSelection(view) {
    if (view.editable && !view.hasFocus())
      return false;
    return hasSelection(view);
  }
  function hasSelection(view) {
    let sel = view.domSelectionRange();
    if (!sel.anchorNode)
      return false;
    try {
      return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
    } catch (_) {
      return false;
    }
  }
  function anchorInRightPlace(view) {
    let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
    let domSel = view.domSelectionRange();
    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
  }
  function moveSelectionBlock(state, dir) {
    let { $anchor, $head } = state.selection;
    let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
    let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
    return $start && Selection.findFrom($start, dir);
  }
  function apply(view, sel) {
    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
    return true;
  }
  function selectHorizontally(view, dir, mods) {
    let sel = view.state.selection;
    if (sel instanceof TextSelection) {
      if (!sel.empty || mods.indexOf("s") > -1) {
        return false;
      } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
        let next = moveSelectionBlock(view.state, dir);
        if (next && next instanceof NodeSelection)
          return apply(view, next);
        return false;
      } else if (!(mac && mods.indexOf("m") > -1)) {
        let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
        if (!node || node.isText)
          return false;
        let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
        if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
          return false;
        if (NodeSelection.isSelectable(node)) {
          return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
        } else if (webkit) {
          return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
        } else {
          return false;
        }
      }
    } else if (sel instanceof NodeSelection && sel.node.isInline) {
      return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
    } else {
      let next = moveSelectionBlock(view.state, dir);
      if (next)
        return apply(view, next);
      return false;
    }
  }
  function nodeLen(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  function isIgnorable(dom, dir) {
    if (dom.contentEditable == "false")
      return true;
    let desc = dom.pmViewDesc;
    return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
  }
  function skipIgnoredNodes(view, dir) {
    return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
  }
  function skipIgnoredNodesBefore(view) {
    let sel = view.domSelectionRange();
    let node = sel.focusNode, offset2 = sel.focusOffset;
    if (!node)
      return;
    let moveNode, moveOffset, force = false;
    if (gecko && node.nodeType == 1 && offset2 < nodeLen(node) && isIgnorable(node.childNodes[offset2], -1))
      force = true;
    for (; ; ) {
      if (offset2 > 0) {
        if (node.nodeType != 1) {
          break;
        } else {
          let before = node.childNodes[offset2 - 1];
          if (isIgnorable(before, -1)) {
            moveNode = node;
            moveOffset = --offset2;
          } else if (before.nodeType == 3) {
            node = before;
            offset2 = node.nodeValue.length;
          } else
            break;
        }
      } else if (isBlockNode(node)) {
        break;
      } else {
        let prev = node.previousSibling;
        while (prev && isIgnorable(prev, -1)) {
          moveNode = node.parentNode;
          moveOffset = domIndex(prev);
          prev = prev.previousSibling;
        }
        if (!prev) {
          node = node.parentNode;
          if (node == view.dom)
            break;
          offset2 = 0;
        } else {
          node = prev;
          offset2 = nodeLen(node);
        }
      }
    }
    if (force)
      setSelFocus(view, node, offset2);
    else if (moveNode)
      setSelFocus(view, moveNode, moveOffset);
  }
  function skipIgnoredNodesAfter(view) {
    let sel = view.domSelectionRange();
    let node = sel.focusNode, offset2 = sel.focusOffset;
    if (!node)
      return;
    let len = nodeLen(node);
    let moveNode, moveOffset;
    for (; ; ) {
      if (offset2 < len) {
        if (node.nodeType != 1)
          break;
        let after = node.childNodes[offset2];
        if (isIgnorable(after, 1)) {
          moveNode = node;
          moveOffset = ++offset2;
        } else
          break;
      } else if (isBlockNode(node)) {
        break;
      } else {
        let next = node.nextSibling;
        while (next && isIgnorable(next, 1)) {
          moveNode = next.parentNode;
          moveOffset = domIndex(next) + 1;
          next = next.nextSibling;
        }
        if (!next) {
          node = node.parentNode;
          if (node == view.dom)
            break;
          offset2 = len = 0;
        } else {
          node = next;
          offset2 = 0;
          len = nodeLen(node);
        }
      }
    }
    if (moveNode)
      setSelFocus(view, moveNode, moveOffset);
  }
  function isBlockNode(dom) {
    let desc = dom.pmViewDesc;
    return desc && desc.node && desc.node.isBlock;
  }
  function textNodeAfter(node, offset2) {
    while (node && offset2 == node.childNodes.length && !hasBlockDesc(node)) {
      offset2 = domIndex(node) + 1;
      node = node.parentNode;
    }
    while (node && offset2 < node.childNodes.length) {
      let next = node.childNodes[offset2];
      if (next.nodeType == 3)
        return next;
      if (next.nodeType == 1 && next.contentEditable == "false")
        break;
      node = next;
      offset2 = 0;
    }
  }
  function textNodeBefore(node, offset2) {
    while (node && !offset2 && !hasBlockDesc(node)) {
      offset2 = domIndex(node);
      node = node.parentNode;
    }
    while (node && offset2) {
      let next = node.childNodes[offset2 - 1];
      if (next.nodeType == 3)
        return next;
      if (next.nodeType == 1 && next.contentEditable == "false")
        break;
      node = next;
      offset2 = node.childNodes.length;
    }
  }
  function setSelFocus(view, node, offset2) {
    if (node.nodeType != 3) {
      let before, after;
      if (after = textNodeAfter(node, offset2)) {
        node = after;
        offset2 = 0;
      } else if (before = textNodeBefore(node, offset2)) {
        node = before;
        offset2 = before.nodeValue.length;
      }
    }
    let sel = view.domSelection();
    if (selectionCollapsed(sel)) {
      let range = document.createRange();
      range.setEnd(node, offset2);
      range.setStart(node, offset2);
      sel.removeAllRanges();
      sel.addRange(range);
    } else if (sel.extend) {
      sel.extend(node, offset2);
    }
    view.domObserver.setCurSelection();
    let { state } = view;
    setTimeout(() => {
      if (view.state == state)
        selectionToDOM(view);
    }, 50);
  }
  function findDirection(view, pos) {
    let $pos = view.state.doc.resolve(pos);
    if (!(chrome || windows) && $pos.parent.inlineContent) {
      let coords = view.coordsAtPos(pos);
      if (pos > $pos.start()) {
        let before = view.coordsAtPos(pos - 1);
        let mid = (before.top + before.bottom) / 2;
        if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
          return before.left < coords.left ? "ltr" : "rtl";
      }
      if (pos < $pos.end()) {
        let after = view.coordsAtPos(pos + 1);
        let mid = (after.top + after.bottom) / 2;
        if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
          return after.left > coords.left ? "ltr" : "rtl";
      }
    }
    let computed = getComputedStyle(view.dom).direction;
    return computed == "rtl" ? "rtl" : "ltr";
  }
  function selectVertically(view, dir, mods) {
    let sel = view.state.selection;
    if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
      return false;
    if (mac && mods.indexOf("m") > -1)
      return false;
    let { $from, $to } = sel;
    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
    }
    if (!$from.parent.inlineContent) {
      let side = dir < 0 ? $from : $to;
      let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
      return beyond ? apply(view, beyond) : false;
    }
    return false;
  }
  function stopNativeHorizontalDelete(view, dir) {
    if (!(view.state.selection instanceof TextSelection))
      return true;
    let { $head, $anchor, empty: empty2 } = view.state.selection;
    if (!$head.sameParent($anchor))
      return true;
    if (!empty2)
      return false;
    if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
      return true;
    let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
    if (nextNode && !nextNode.isText) {
      let tr = view.state.tr;
      if (dir < 0)
        tr.delete($head.pos - nextNode.nodeSize, $head.pos);
      else
        tr.delete($head.pos, $head.pos + nextNode.nodeSize);
      view.dispatch(tr);
      return true;
    }
    return false;
  }
  function switchEditable(view, node, state) {
    view.domObserver.stop();
    node.contentEditable = state;
    view.domObserver.start();
  }
  function safariDownArrowBug(view) {
    if (!safari || view.state.selection.$head.parentOffset > 0)
      return false;
    let { focusNode, focusOffset } = view.domSelectionRange();
    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
      let child = focusNode.firstChild;
      switchEditable(view, child, "true");
      setTimeout(() => switchEditable(view, child, "false"), 20);
    }
    return false;
  }
  function getMods(event) {
    let result = "";
    if (event.ctrlKey)
      result += "c";
    if (event.metaKey)
      result += "m";
    if (event.altKey)
      result += "a";
    if (event.shiftKey)
      result += "s";
    return result;
  }
  function captureKeyDown(view, event) {
    let code = event.keyCode, mods = getMods(event);
    if (code == 8 || mac && code == 72 && mods == "c") {
      return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
    } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == "c") {
      return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
    } else if (code == 13 || code == 27) {
      return true;
    } else if (code == 37 || mac && code == 66 && mods == "c") {
      let dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
      return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
    } else if (code == 39 || mac && code == 70 && mods == "c") {
      let dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
      return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
    } else if (code == 38 || mac && code == 80 && mods == "c") {
      return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
    } else if (code == 40 || mac && code == 78 && mods == "c") {
      return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
    } else if (mods == (mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
      return true;
    }
    return false;
  }
  function serializeForClipboard(view, slice2) {
    view.someProp("transformCopied", (f) => {
      slice2 = f(slice2, view);
    });
    let context = [], { content, openStart, openEnd } = slice2;
    while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
      openStart--;
      openEnd--;
      let node = content.firstChild;
      context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
      content = node.content;
    }
    let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
    let doc3 = detachedDoc(), wrap2 = doc3.createElement("div");
    wrap2.appendChild(serializer.serializeFragment(content, { document: doc3 }));
    let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
    while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
      for (let i = needsWrap.length - 1; i >= 0; i--) {
        let wrapper = doc3.createElement(needsWrap[i]);
        while (wrap2.firstChild)
          wrapper.appendChild(wrap2.firstChild);
        wrap2.appendChild(wrapper);
        wrappers++;
      }
      firstChild = wrap2.firstChild;
    }
    if (firstChild && firstChild.nodeType == 1)
      firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
    let text = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
    return { dom: wrap2, text };
  }
  function parseFromClipboard(view, text, html, plainText, $context) {
    let inCode = $context.parent.type.spec.code;
    let dom, slice2;
    if (!html && !text)
      return null;
    let asText = text && (plainText || inCode || !html);
    if (asText) {
      view.someProp("transformPastedText", (f) => {
        text = f(text, inCode || plainText, view);
      });
      if (inCode)
        return text ? new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
      let parsed = view.someProp("clipboardTextParser", (f) => f(text, $context, plainText, view));
      if (parsed) {
        slice2 = parsed;
      } else {
        let marks = $context.marks();
        let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
        dom = document.createElement("div");
        text.split(/(?:\r\n?|\n)+/).forEach((block) => {
          let p = dom.appendChild(document.createElement("p"));
          if (block)
            p.appendChild(serializer.serializeNode(schema.text(block, marks)));
        });
      }
    } else {
      view.someProp("transformPastedHTML", (f) => {
        html = f(html, view);
      });
      dom = readHTML(html);
      if (webkit)
        restoreReplacedSpaces(dom);
    }
    let contextNode = dom && dom.querySelector("[data-pm-slice]");
    let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
    if (sliceData && sliceData[3])
      for (let i = +sliceData[3]; i > 0; i--) {
        let child = dom.firstChild;
        while (child && child.nodeType != 1)
          child = child.nextSibling;
        if (!child)
          break;
        dom = child;
      }
    if (!slice2) {
      let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
      slice2 = parser.parseSlice(dom, {
        preserveWhitespace: !!(asText || sliceData),
        context: $context,
        ruleFromNode(dom2) {
          if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
            return { ignore: true };
          return null;
        }
      });
    }
    if (sliceData) {
      slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
    } else {
      slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
      if (slice2.openStart || slice2.openEnd) {
        let openStart = 0, openEnd = 0;
        for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
        }
        for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
        }
        slice2 = closeSlice(slice2, openStart, openEnd);
      }
    }
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2, view);
    });
    return slice2;
  }
  var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
  function normalizeSiblings(fragment, $context) {
    if (fragment.childCount < 2)
      return fragment;
    for (let d = $context.depth; d >= 0; d--) {
      let parent = $context.node(d);
      let match = parent.contentMatchAt($context.index(d));
      let lastWrap, result = [];
      fragment.forEach((node) => {
        if (!result)
          return;
        let wrap2 = match.findWrapping(node.type), inLast;
        if (!wrap2)
          return result = null;
        if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
          result[result.length - 1] = inLast;
        } else {
          if (result.length)
            result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
          let wrapped = withWrappers(node, wrap2);
          result.push(wrapped);
          match = match.matchType(wrapped.type);
          lastWrap = wrap2;
        }
      });
      if (result)
        return Fragment.from(result);
    }
    return fragment;
  }
  function withWrappers(node, wrap2, from2 = 0) {
    for (let i = wrap2.length - 1; i >= from2; i--)
      node = wrap2[i].create(null, Fragment.from(node));
    return node;
  }
  function addToSibling(wrap2, lastWrap, node, sibling, depth) {
    if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
      let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
      if (inner)
        return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
      let match = sibling.contentMatchAt(sibling.childCount);
      if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
        return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
    }
  }
  function closeRight(node, depth) {
    if (depth == 0)
      return node;
    let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
    let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
    return node.copy(fragment.append(fill));
  }
  function closeRange(fragment, side, from2, to, depth, openEnd) {
    let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
    if (fragment.childCount > 1)
      openEnd = 0;
    if (depth < to - 1)
      inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
    if (depth >= from2)
      inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
    return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
  }
  function closeSlice(slice2, openStart, openEnd) {
    if (openStart < slice2.openStart)
      slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
    if (openEnd < slice2.openEnd)
      slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
    return slice2;
  }
  var wrapMap = {
    thead: ["table"],
    tbody: ["table"],
    tfoot: ["table"],
    caption: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"]
  };
  var _detachedDoc = null;
  function detachedDoc() {
    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
  }
  function readHTML(html) {
    let metas = /^(\s*<meta [^>]*>)*/.exec(html);
    if (metas)
      html = html.slice(metas[0].length);
    let elt = detachedDoc().createElement("div");
    let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
    if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
      html = wrap2.map((n) => "<" + n + ">").join("") + html + wrap2.map((n) => "</" + n + ">").reverse().join("");
    elt.innerHTML = html;
    if (wrap2)
      for (let i = 0; i < wrap2.length; i++)
        elt = elt.querySelector(wrap2[i]) || elt;
    return elt;
  }
  function restoreReplacedSpaces(dom) {
    let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
    for (let i = 0; i < nodes.length; i++) {
      let node = nodes[i];
      if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode)
        node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
    }
  }
  function addContext(slice2, context) {
    if (!slice2.size)
      return slice2;
    let schema = slice2.content.firstChild.type.schema, array;
    try {
      array = JSON.parse(context);
    } catch (e) {
      return slice2;
    }
    let { content, openStart, openEnd } = slice2;
    for (let i = array.length - 2; i >= 0; i -= 2) {
      let type = schema.nodes[array[i]];
      if (!type || type.hasRequiredAttrs())
        break;
      content = Fragment.from(type.create(array[i + 1], content));
      openStart++;
      openEnd++;
    }
    return new Slice(content, openStart, openEnd);
  }
  var handlers = {};
  var editHandlers = {};
  var passiveHandlers = { touchstart: true, touchmove: true };
  var InputState = class {
    constructor() {
      this.shiftKey = false;
      this.mouseDown = null;
      this.lastKeyCode = null;
      this.lastKeyCodeTime = 0;
      this.lastClick = { time: 0, x: 0, y: 0, type: "" };
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastIOSEnter = 0;
      this.lastIOSEnterFallbackTimeout = -1;
      this.lastFocus = 0;
      this.lastTouch = 0;
      this.lastAndroidDelete = 0;
      this.composing = false;
      this.composingTimeout = -1;
      this.compositionNodes = [];
      this.compositionEndedAt = -2e8;
      this.compositionID = 1;
      this.compositionPendingChanges = 0;
      this.domChangeCount = 0;
      this.eventHandlers = /* @__PURE__ */ Object.create(null);
      this.hideSelectionGuard = null;
    }
  };
  function initInput(view) {
    for (let event in handlers) {
      let handler = handlers[event];
      view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
        if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
          handler(view, event2);
      }, passiveHandlers[event] ? { passive: true } : void 0);
    }
    if (safari)
      view.dom.addEventListener("input", () => null);
    ensureListeners(view);
  }
  function setSelectionOrigin(view, origin) {
    view.input.lastSelectionOrigin = origin;
    view.input.lastSelectionTime = Date.now();
  }
  function destroyInput(view) {
    view.domObserver.stop();
    for (let type in view.input.eventHandlers)
      view.dom.removeEventListener(type, view.input.eventHandlers[type]);
    clearTimeout(view.input.composingTimeout);
    clearTimeout(view.input.lastIOSEnterFallbackTimeout);
  }
  function ensureListeners(view) {
    view.someProp("handleDOMEvents", (currentHandlers) => {
      for (let type in currentHandlers)
        if (!view.input.eventHandlers[type])
          view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
    });
  }
  function runCustomHandler(view, event) {
    return view.someProp("handleDOMEvents", (handlers2) => {
      let handler = handlers2[event.type];
      return handler ? handler(view, event) || event.defaultPrevented : false;
    });
  }
  function eventBelongsToView(view, event) {
    if (!event.bubbles)
      return true;
    if (event.defaultPrevented)
      return false;
    for (let node = event.target; node != view.dom; node = node.parentNode)
      if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
        return false;
    return true;
  }
  function dispatchEvent(view, event) {
    if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
      handlers[event.type](view, event);
  }
  editHandlers.keydown = (view, _event) => {
    let event = _event;
    view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
    if (inOrNearComposition(view, event))
      return;
    view.input.lastKeyCode = event.keyCode;
    view.input.lastKeyCodeTime = Date.now();
    if (android && chrome && event.keyCode == 13)
      return;
    if (event.keyCode != 229)
      view.domObserver.forceFlush();
    if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
      let now = Date.now();
      view.input.lastIOSEnter = now;
      view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        if (view.input.lastIOSEnter == now) {
          view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
          view.input.lastIOSEnter = 0;
        }
      }, 200);
    } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
      event.preventDefault();
    } else {
      setSelectionOrigin(view, "key");
    }
  };
  editHandlers.keyup = (view, event) => {
    if (event.keyCode == 16)
      view.input.shiftKey = false;
  };
  editHandlers.keypress = (view, _event) => {
    let event = _event;
    if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)
      return;
    if (view.someProp("handleKeyPress", (f) => f(view, event))) {
      event.preventDefault();
      return;
    }
    let sel = view.state.selection;
    if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
      let text = String.fromCharCode(event.charCode);
      if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text)))
        view.dispatch(view.state.tr.insertText(text).scrollIntoView());
      event.preventDefault();
    }
  };
  function eventCoords(event) {
    return { left: event.clientX, top: event.clientY };
  }
  function isNear(event, click) {
    let dx = click.x - event.clientX, dy = click.y - event.clientY;
    return dx * dx + dy * dy < 100;
  }
  function runHandlerOnContext(view, propName, pos, inside, event) {
    if (inside == -1)
      return false;
    let $pos = view.state.doc.resolve(inside);
    for (let i = $pos.depth + 1; i > 0; i--) {
      if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
        return true;
    }
    return false;
  }
  function updateSelection(view, selection, origin) {
    if (!view.focused)
      view.focus();
    let tr = view.state.tr.setSelection(selection);
    if (origin == "pointer")
      tr.setMeta("pointer", true);
    view.dispatch(tr);
  }
  function selectClickedLeaf(view, inside) {
    if (inside == -1)
      return false;
    let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
    if (node && node.isAtom && NodeSelection.isSelectable(node)) {
      updateSelection(view, new NodeSelection($pos), "pointer");
      return true;
    }
    return false;
  }
  function selectClickedNode(view, inside) {
    if (inside == -1)
      return false;
    let sel = view.state.selection, selectedNode, selectAt;
    if (sel instanceof NodeSelection)
      selectedNode = sel.node;
    let $pos = view.state.doc.resolve(inside);
    for (let i = $pos.depth + 1; i > 0; i--) {
      let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
      if (NodeSelection.isSelectable(node)) {
        if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
          selectAt = $pos.before(sel.$from.depth);
        else
          selectAt = $pos.before(i);
        break;
      }
    }
    if (selectAt != null) {
      updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
      return true;
    } else {
      return false;
    }
  }
  function handleSingleClick(view, pos, inside, event, selectNode) {
    return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
  }
  function handleDoubleClick(view, pos, inside, event) {
    return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
  }
  function handleTripleClick(view, pos, inside, event) {
    return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
  }
  function defaultTripleClick(view, inside, event) {
    if (event.button != 0)
      return false;
    let doc3 = view.state.doc;
    if (inside == -1) {
      if (doc3.inlineContent) {
        updateSelection(view, TextSelection.create(doc3, 0, doc3.content.size), "pointer");
        return true;
      }
      return false;
    }
    let $pos = doc3.resolve(inside);
    for (let i = $pos.depth + 1; i > 0; i--) {
      let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
      let nodePos = $pos.before(i);
      if (node.inlineContent)
        updateSelection(view, TextSelection.create(doc3, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
      else if (NodeSelection.isSelectable(node))
        updateSelection(view, NodeSelection.create(doc3, nodePos), "pointer");
      else
        continue;
      return true;
    }
  }
  function forceDOMFlush(view) {
    return endComposition(view);
  }
  var selectNodeModifier = mac ? "metaKey" : "ctrlKey";
  handlers.mousedown = (view, _event) => {
    let event = _event;
    view.input.shiftKey = event.shiftKey;
    let flushed = forceDOMFlush(view);
    let now = Date.now(), type = "singleClick";
    if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
      if (view.input.lastClick.type == "singleClick")
        type = "doubleClick";
      else if (view.input.lastClick.type == "doubleClick")
        type = "tripleClick";
    }
    view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type };
    let pos = view.posAtCoords(eventCoords(event));
    if (!pos)
      return;
    if (type == "singleClick") {
      if (view.input.mouseDown)
        view.input.mouseDown.done();
      view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
    } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
      event.preventDefault();
    } else {
      setSelectionOrigin(view, "pointer");
    }
  };
  var MouseDown = class {
    constructor(view, pos, event, flushed) {
      this.view = view;
      this.pos = pos;
      this.event = event;
      this.flushed = flushed;
      this.delayedSelectionSync = false;
      this.mightDrag = null;
      this.startDoc = view.state.doc;
      this.selectNode = !!event[selectNodeModifier];
      this.allowDefault = event.shiftKey;
      let targetNode, targetPos;
      if (pos.inside > -1) {
        targetNode = view.state.doc.nodeAt(pos.inside);
        targetPos = pos.inside;
      } else {
        let $pos = view.state.doc.resolve(pos.pos);
        targetNode = $pos.parent;
        targetPos = $pos.depth ? $pos.before() : 0;
      }
      const target = flushed ? null : event.target;
      const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
      this.target = targetDesc ? targetDesc.dom : null;
      let { selection } = view.state;
      if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
        this.mightDrag = {
          node: targetNode,
          pos: targetPos,
          addAttr: !!(this.target && !this.target.draggable),
          setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
        };
      if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr)
          this.target.draggable = true;
        if (this.mightDrag.setUneditable)
          setTimeout(() => {
            if (this.view.input.mouseDown == this)
              this.target.setAttribute("contentEditable", "false");
          }, 20);
        this.view.domObserver.start();
      }
      view.root.addEventListener("mouseup", this.up = this.up.bind(this));
      view.root.addEventListener("mousemove", this.move = this.move.bind(this));
      setSelectionOrigin(view, "pointer");
    }
    done() {
      this.view.root.removeEventListener("mouseup", this.up);
      this.view.root.removeEventListener("mousemove", this.move);
      if (this.mightDrag && this.target) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr)
          this.target.removeAttribute("draggable");
        if (this.mightDrag.setUneditable)
          this.target.removeAttribute("contentEditable");
        this.view.domObserver.start();
      }
      if (this.delayedSelectionSync)
        setTimeout(() => selectionToDOM(this.view));
      this.view.input.mouseDown = null;
    }
    up(event) {
      this.done();
      if (!this.view.dom.contains(event.target))
        return;
      let pos = this.pos;
      if (this.view.state.doc != this.startDoc)
        pos = this.view.posAtCoords(eventCoords(event));
      this.updateAllowDefault(event);
      if (this.allowDefault || !pos) {
        setSelectionOrigin(this.view, "pointer");
      } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
        event.preventDefault();
      } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
      safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
      // cursor, but still report that the node is selected
      // when asked through getSelection. You'll then get a
      // situation where clicking at the point where that
      // (hidden) cursor is doesn't change the selection, and
      // thus doesn't get a reaction from ProseMirror. This
      // works around that.
      chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
        updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
        event.preventDefault();
      } else {
        setSelectionOrigin(this.view, "pointer");
      }
    }
    move(event) {
      this.updateAllowDefault(event);
      setSelectionOrigin(this.view, "pointer");
      if (event.buttons == 0)
        this.done();
    }
    updateAllowDefault(event) {
      if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
        this.allowDefault = true;
    }
  };
  handlers.touchstart = (view) => {
    view.input.lastTouch = Date.now();
    forceDOMFlush(view);
    setSelectionOrigin(view, "pointer");
  };
  handlers.touchmove = (view) => {
    view.input.lastTouch = Date.now();
    setSelectionOrigin(view, "pointer");
  };
  handlers.contextmenu = (view) => forceDOMFlush(view);
  function inOrNearComposition(view, event) {
    if (view.composing)
      return true;
    if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
      view.input.compositionEndedAt = -2e8;
      return true;
    }
    return false;
  }
  var timeoutComposition = android ? 5e3 : -1;
  editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
    if (!view.composing) {
      view.domObserver.flush();
      let { state } = view, $pos = state.selection.$from;
      if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
        view.markCursor = view.state.storedMarks || $pos.marks();
        endComposition(view, true);
        view.markCursor = null;
      } else {
        endComposition(view);
        if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
          let sel = view.domSelectionRange();
          for (let node = sel.focusNode, offset2 = sel.focusOffset; node && node.nodeType == 1 && offset2 != 0; ) {
            let before = offset2 < 0 ? node.lastChild : node.childNodes[offset2 - 1];
            if (!before)
              break;
            if (before.nodeType == 3) {
              view.domSelection().collapse(before, before.nodeValue.length);
              break;
            } else {
              node = before;
              offset2 = -1;
            }
          }
        }
      }
      view.input.composing = true;
    }
    scheduleComposeEnd(view, timeoutComposition);
  };
  editHandlers.compositionend = (view, event) => {
    if (view.composing) {
      view.input.composing = false;
      view.input.compositionEndedAt = event.timeStamp;
      view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
      if (view.input.compositionPendingChanges)
        Promise.resolve().then(() => view.domObserver.flush());
      view.input.compositionID++;
      scheduleComposeEnd(view, 20);
    }
  };
  function scheduleComposeEnd(view, delay) {
    clearTimeout(view.input.composingTimeout);
    if (delay > -1)
      view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
  }
  function clearComposition(view) {
    if (view.composing) {
      view.input.composing = false;
      view.input.compositionEndedAt = timestampFromCustomEvent();
    }
    while (view.input.compositionNodes.length > 0)
      view.input.compositionNodes.pop().markParentsDirty();
  }
  function timestampFromCustomEvent() {
    let event = document.createEvent("Event");
    event.initEvent("event", true, true);
    return event.timeStamp;
  }
  function endComposition(view, forceUpdate = false) {
    if (android && view.domObserver.flushingSoon >= 0)
      return;
    view.domObserver.forceFlush();
    clearComposition(view);
    if (forceUpdate || view.docView && view.docView.dirty) {
      let sel = selectionFromDOM(view);
      if (sel && !sel.eq(view.state.selection))
        view.dispatch(view.state.tr.setSelection(sel));
      else
        view.updateState(view.state);
      return true;
    }
    return false;
  }
  function captureCopy(view, dom) {
    if (!view.dom.parentNode)
      return;
    let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
    wrap2.appendChild(dom);
    wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
    let sel = getSelection(), range = document.createRange();
    range.selectNodeContents(dom);
    view.dom.blur();
    sel.removeAllRanges();
    sel.addRange(range);
    setTimeout(() => {
      if (wrap2.parentNode)
        wrap2.parentNode.removeChild(wrap2);
      view.focus();
    }, 50);
  }
  var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
  handlers.copy = editHandlers.cut = (view, _event) => {
    let event = _event;
    let sel = view.state.selection, cut2 = event.type == "cut";
    if (sel.empty)
      return;
    let data = brokenClipboardAPI ? null : event.clipboardData;
    let slice2 = sel.content(), { dom, text } = serializeForClipboard(view, slice2);
    if (data) {
      event.preventDefault();
      data.clearData();
      data.setData("text/html", dom.innerHTML);
      data.setData("text/plain", text);
    } else {
      captureCopy(view, dom);
    }
    if (cut2)
      view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
  };
  function sliceSingleNode(slice2) {
    return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
  }
  function capturePaste(view, event) {
    if (!view.dom.parentNode)
      return;
    let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
    let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
    if (!plainText)
      target.contentEditable = "true";
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
    setTimeout(() => {
      view.focus();
      if (target.parentNode)
        target.parentNode.removeChild(target);
      if (plainText)
        doPaste(view, target.value, null, plain, event);
      else
        doPaste(view, target.textContent, target.innerHTML, plain, event);
    }, 50);
  }
  function doPaste(view, text, html, preferPlain, event) {
    let slice2 = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
    if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
      return true;
    if (!slice2)
      return false;
    let singleNode = sliceSingleNode(slice2);
    let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
    view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
    return true;
  }
  editHandlers.paste = (view, _event) => {
    let event = _event;
    if (view.composing && !android)
      return;
    let data = brokenClipboardAPI ? null : event.clipboardData;
    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
    if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), plain, event))
      event.preventDefault();
    else
      capturePaste(view, event);
  };
  var Dragging = class {
    constructor(slice2, move) {
      this.slice = slice2;
      this.move = move;
    }
  };
  var dragCopyModifier = mac ? "altKey" : "ctrlKey";
  handlers.dragstart = (view, _event) => {
    let event = _event;
    let mouseDown = view.input.mouseDown;
    if (mouseDown)
      mouseDown.done();
    if (!event.dataTransfer)
      return;
    let sel = view.state.selection;
    let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
    if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
      ;
    else if (mouseDown && mouseDown.mightDrag) {
      view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
    } else if (event.target && event.target.nodeType == 1) {
      let desc = view.docView.nearestDesc(event.target, true);
      if (desc && desc.node.type.spec.draggable && desc != view.docView)
        view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc.posBefore)));
    }
    let slice2 = view.state.selection.content(), { dom, text } = serializeForClipboard(view, slice2);
    event.dataTransfer.clearData();
    event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
    event.dataTransfer.effectAllowed = "copyMove";
    if (!brokenClipboardAPI)
      event.dataTransfer.setData("text/plain", text);
    view.dragging = new Dragging(slice2, !event[dragCopyModifier]);
  };
  handlers.dragend = (view) => {
    let dragging = view.dragging;
    window.setTimeout(() => {
      if (view.dragging == dragging)
        view.dragging = null;
    }, 50);
  };
  editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
  editHandlers.drop = (view, _event) => {
    let event = _event;
    let dragging = view.dragging;
    view.dragging = null;
    if (!event.dataTransfer)
      return;
    let eventPos = view.posAtCoords(eventCoords(event));
    if (!eventPos)
      return;
    let $mouse = view.state.doc.resolve(eventPos.pos);
    let slice2 = dragging && dragging.slice;
    if (slice2) {
      view.someProp("transformPasted", (f) => {
        slice2 = f(slice2, view);
      });
    } else {
      slice2 = parseFromClipboard(view, event.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
    }
    let move = !!(dragging && !event[dragCopyModifier]);
    if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move))) {
      event.preventDefault();
      return;
    }
    if (!slice2)
      return;
    event.preventDefault();
    let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
    if (insertPos == null)
      insertPos = $mouse.pos;
    let tr = view.state.tr;
    if (move)
      tr.deleteSelection();
    let pos = tr.mapping.map(insertPos);
    let isNode = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
    let beforeInsert = tr.doc;
    if (isNode)
      tr.replaceRangeWith(pos, pos, slice2.content.firstChild);
    else
      tr.replaceRange(pos, pos, slice2);
    if (tr.doc.eq(beforeInsert))
      return;
    let $pos = tr.doc.resolve(pos);
    if (isNode && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
      tr.setSelection(new NodeSelection($pos));
    } else {
      let end2 = tr.mapping.map(insertPos);
      tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end2 = newTo);
      tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end2)));
    }
    view.focus();
    view.dispatch(tr.setMeta("uiEvent", "drop"));
  };
  handlers.focus = (view) => {
    view.input.lastFocus = Date.now();
    if (!view.focused) {
      view.domObserver.stop();
      view.dom.classList.add("ProseMirror-focused");
      view.domObserver.start();
      view.focused = true;
      setTimeout(() => {
        if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
          selectionToDOM(view);
      }, 20);
    }
  };
  handlers.blur = (view, _event) => {
    let event = _event;
    if (view.focused) {
      view.domObserver.stop();
      view.dom.classList.remove("ProseMirror-focused");
      view.domObserver.start();
      if (event.relatedTarget && view.dom.contains(event.relatedTarget))
        view.domObserver.currentSelection.clear();
      view.focused = false;
    }
  };
  handlers.beforeinput = (view, _event) => {
    let event = _event;
    if (chrome && android && event.inputType == "deleteContentBackward") {
      view.domObserver.flushSoon();
      let { domChangeCount } = view.input;
      setTimeout(() => {
        if (view.input.domChangeCount != domChangeCount)
          return;
        view.dom.blur();
        view.focus();
        if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
          return;
        let { $cursor } = view.state.selection;
        if ($cursor && $cursor.pos > 0)
          view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
      }, 50);
    }
  };
  for (let prop in editHandlers)
    handlers[prop] = editHandlers[prop];
  function compareObjs(a, b) {
    if (a == b)
      return true;
    for (let p in a)
      if (a[p] !== b[p])
        return false;
    for (let p in b)
      if (!(p in a))
        return false;
    return true;
  }
  var WidgetType = class _WidgetType {
    constructor(toDOM, spec) {
      this.toDOM = toDOM;
      this.spec = spec || noSpec;
      this.side = this.spec.side || 0;
    }
    map(mapping, span, offset2, oldOffset) {
      let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
      return deleted ? null : new Decoration(pos - offset2, pos - offset2, this);
    }
    valid() {
      return true;
    }
    eq(other) {
      return this == other || other instanceof _WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
    }
    destroy(node) {
      if (this.spec.destroy)
        this.spec.destroy(node);
    }
  };
  var InlineType = class _InlineType {
    constructor(attrs, spec) {
      this.attrs = attrs;
      this.spec = spec || noSpec;
    }
    map(mapping, span, offset2, oldOffset) {
      let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
      let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
      return from2 >= to ? null : new Decoration(from2, to, this);
    }
    valid(_, span) {
      return span.from < span.to;
    }
    eq(other) {
      return this == other || other instanceof _InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    }
    static is(span) {
      return span.type instanceof _InlineType;
    }
    destroy() {
    }
  };
  var NodeType2 = class _NodeType {
    constructor(attrs, spec) {
      this.attrs = attrs;
      this.spec = spec || noSpec;
    }
    map(mapping, span, offset2, oldOffset) {
      let from2 = mapping.mapResult(span.from + oldOffset, 1);
      if (from2.deleted)
        return null;
      let to = mapping.mapResult(span.to + oldOffset, -1);
      if (to.deleted || to.pos <= from2.pos)
        return null;
      return new Decoration(from2.pos - offset2, to.pos - offset2, this);
    }
    valid(node, span) {
      let { index, offset: offset2 } = node.content.findIndex(span.from), child;
      return offset2 == span.from && !(child = node.child(index)).isText && offset2 + child.nodeSize == span.to;
    }
    eq(other) {
      return this == other || other instanceof _NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    }
    destroy() {
    }
  };
  var Decoration = class _Decoration {
    /**
    @internal
    */
    constructor(from2, to, type) {
      this.from = from2;
      this.to = to;
      this.type = type;
    }
    /**
    @internal
    */
    copy(from2, to) {
      return new _Decoration(from2, to, this.type);
    }
    /**
    @internal
    */
    eq(other, offset2 = 0) {
      return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
    }
    /**
    @internal
    */
    map(mapping, offset2, oldOffset) {
      return this.type.map(mapping, this, offset2, oldOffset);
    }
    /**
    Creates a widget decoration, which is a DOM node that's shown in
    the document at the given position. It is recommended that you
    delay rendering the widget by passing a function that will be
    called when the widget is actually drawn in a view, but you can
    also directly pass a DOM node. `getPos` can be used to find the
    widget's current document position.
    */
    static widget(pos, toDOM, spec) {
      return new _Decoration(pos, pos, new WidgetType(toDOM, spec));
    }
    /**
    Creates an inline decoration, which adds the given attributes to
    each inline node between `from` and `to`.
    */
    static inline(from2, to, attrs, spec) {
      return new _Decoration(from2, to, new InlineType(attrs, spec));
    }
    /**
    Creates a node decoration. `from` and `to` should point precisely
    before and after a node in the document. That node, and only that
    node, will receive the given attributes.
    */
    static node(from2, to, attrs, spec) {
      return new _Decoration(from2, to, new NodeType2(attrs, spec));
    }
    /**
    The spec provided when creating this decoration. Can be useful
    if you've stored extra information in that object.
    */
    get spec() {
      return this.type.spec;
    }
    /**
    @internal
    */
    get inline() {
      return this.type instanceof InlineType;
    }
    /**
    @internal
    */
    get widget() {
      return this.type instanceof WidgetType;
    }
  };
  var none = [];
  var noSpec = {};
  var DecorationSet = class _DecorationSet {
    /**
    @internal
    */
    constructor(local, children) {
      this.local = local.length ? local : none;
      this.children = children.length ? children : none;
    }
    /**
    Create a set of decorations, using the structure of the given
    document. This will consume (modify) the `decorations` array, so
    you must make a copy if you want need to preserve that.
    */
    static create(doc3, decorations) {
      return decorations.length ? buildTree(decorations, doc3, 0, noSpec) : empty;
    }
    /**
    Find all decorations in this set which touch the given range
    (including decorations that start or end directly at the
    boundaries) and match the given predicate on their spec. When
    `start` and `end` are omitted, all decorations in the set are
    considered. When `predicate` isn't given, all decorations are
    assumed to match.
    */
    find(start2, end2, predicate) {
      let result = [];
      this.findInner(start2 == null ? 0 : start2, end2 == null ? 1e9 : end2, result, 0, predicate);
      return result;
    }
    findInner(start2, end2, result, offset2, predicate) {
      for (let i = 0; i < this.local.length; i++) {
        let span = this.local[i];
        if (span.from <= end2 && span.to >= start2 && (!predicate || predicate(span.spec)))
          result.push(span.copy(span.from + offset2, span.to + offset2));
      }
      for (let i = 0; i < this.children.length; i += 3) {
        if (this.children[i] < end2 && this.children[i + 1] > start2) {
          let childOff = this.children[i] + 1;
          this.children[i + 2].findInner(start2 - childOff, end2 - childOff, result, offset2 + childOff, predicate);
        }
      }
    }
    /**
    Map the set of decorations in response to a change in the
    document.
    */
    map(mapping, doc3, options) {
      if (this == empty || mapping.maps.length == 0)
        return this;
      return this.mapInner(mapping, doc3, 0, 0, options || noSpec);
    }
    /**
    @internal
    */
    mapInner(mapping, node, offset2, oldOffset, options) {
      let newLocal;
      for (let i = 0; i < this.local.length; i++) {
        let mapped = this.local[i].map(mapping, offset2, oldOffset);
        if (mapped && mapped.type.valid(node, mapped))
          (newLocal || (newLocal = [])).push(mapped);
        else if (options.onRemove)
          options.onRemove(this.local[i].spec);
      }
      if (this.children.length)
        return mapChildren(this.children, newLocal || [], mapping, node, offset2, oldOffset, options);
      else
        return newLocal ? new _DecorationSet(newLocal.sort(byPos), none) : empty;
    }
    /**
    Add the given array of decorations to the ones in the set,
    producing a new set. Consumes the `decorations` array. Needs
    access to the current document to create the appropriate tree
    structure.
    */
    add(doc3, decorations) {
      if (!decorations.length)
        return this;
      if (this == empty)
        return _DecorationSet.create(doc3, decorations);
      return this.addInner(doc3, decorations, 0);
    }
    addInner(doc3, decorations, offset2) {
      let children, childIndex = 0;
      doc3.forEach((childNode, childOffset) => {
        let baseOffset = childOffset + offset2, found2;
        if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
          return;
        if (!children)
          children = this.children.slice();
        while (childIndex < children.length && children[childIndex] < childOffset)
          childIndex += 3;
        if (children[childIndex] == childOffset)
          children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
        else
          children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
        childIndex += 3;
      });
      let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
      for (let i = 0; i < local.length; i++)
        if (!local[i].type.valid(doc3, local[i]))
          local.splice(i--, 1);
      return new _DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
    }
    /**
    Create a new set that contains the decorations in this set, minus
    the ones in the given array.
    */
    remove(decorations) {
      if (decorations.length == 0 || this == empty)
        return this;
      return this.removeInner(decorations, 0);
    }
    removeInner(decorations, offset2) {
      let children = this.children, local = this.local;
      for (let i = 0; i < children.length; i += 3) {
        let found2;
        let from2 = children[i] + offset2, to = children[i + 1] + offset2;
        for (let j = 0, span; j < decorations.length; j++)
          if (span = decorations[j]) {
            if (span.from > from2 && span.to < to) {
              decorations[j] = null;
              (found2 || (found2 = [])).push(span);
            }
          }
        if (!found2)
          continue;
        if (children == this.children)
          children = this.children.slice();
        let removed = children[i + 2].removeInner(found2, from2 + 1);
        if (removed != empty) {
          children[i + 2] = removed;
        } else {
          children.splice(i, 3);
          i -= 3;
        }
      }
      if (local.length) {
        for (let i = 0, span; i < decorations.length; i++)
          if (span = decorations[i]) {
            for (let j = 0; j < local.length; j++)
              if (local[j].eq(span, offset2)) {
                if (local == this.local)
                  local = this.local.slice();
                local.splice(j--, 1);
              }
          }
      }
      if (children == this.children && local == this.local)
        return this;
      return local.length || children.length ? new _DecorationSet(local, children) : empty;
    }
    /**
    @internal
    */
    forChild(offset2, node) {
      if (this == empty)
        return this;
      if (node.isLeaf)
        return _DecorationSet.empty;
      let child, local;
      for (let i = 0; i < this.children.length; i += 3)
        if (this.children[i] >= offset2) {
          if (this.children[i] == offset2)
            child = this.children[i + 2];
          break;
        }
      let start2 = offset2 + 1, end2 = start2 + node.content.size;
      for (let i = 0; i < this.local.length; i++) {
        let dec = this.local[i];
        if (dec.from < end2 && dec.to > start2 && dec.type instanceof InlineType) {
          let from2 = Math.max(start2, dec.from) - start2, to = Math.min(end2, dec.to) - start2;
          if (from2 < to)
            (local || (local = [])).push(dec.copy(from2, to));
        }
      }
      if (local) {
        let localSet = new _DecorationSet(local.sort(byPos), none);
        return child ? new DecorationGroup([localSet, child]) : localSet;
      }
      return child || empty;
    }
    /**
    @internal
    */
    eq(other) {
      if (this == other)
        return true;
      if (!(other instanceof _DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
        return false;
      for (let i = 0; i < this.local.length; i++)
        if (!this.local[i].eq(other.local[i]))
          return false;
      for (let i = 0; i < this.children.length; i += 3)
        if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
          return false;
      return true;
    }
    /**
    @internal
    */
    locals(node) {
      return removeOverlap(this.localsInner(node));
    }
    /**
    @internal
    */
    localsInner(node) {
      if (this == empty)
        return none;
      if (node.inlineContent || !this.local.some(InlineType.is))
        return this.local;
      let result = [];
      for (let i = 0; i < this.local.length; i++) {
        if (!(this.local[i].type instanceof InlineType))
          result.push(this.local[i]);
      }
      return result;
    }
  };
  DecorationSet.empty = new DecorationSet([], []);
  DecorationSet.removeOverlap = removeOverlap;
  var empty = DecorationSet.empty;
  var DecorationGroup = class _DecorationGroup {
    constructor(members) {
      this.members = members;
    }
    map(mapping, doc3) {
      const mappedDecos = this.members.map((member) => member.map(mapping, doc3, noSpec));
      return _DecorationGroup.from(mappedDecos);
    }
    forChild(offset2, child) {
      if (child.isLeaf)
        return DecorationSet.empty;
      let found2 = [];
      for (let i = 0; i < this.members.length; i++) {
        let result = this.members[i].forChild(offset2, child);
        if (result == empty)
          continue;
        if (result instanceof _DecorationGroup)
          found2 = found2.concat(result.members);
        else
          found2.push(result);
      }
      return _DecorationGroup.from(found2);
    }
    eq(other) {
      if (!(other instanceof _DecorationGroup) || other.members.length != this.members.length)
        return false;
      for (let i = 0; i < this.members.length; i++)
        if (!this.members[i].eq(other.members[i]))
          return false;
      return true;
    }
    locals(node) {
      let result, sorted = true;
      for (let i = 0; i < this.members.length; i++) {
        let locals = this.members[i].localsInner(node);
        if (!locals.length)
          continue;
        if (!result) {
          result = locals;
        } else {
          if (sorted) {
            result = result.slice();
            sorted = false;
          }
          for (let j = 0; j < locals.length; j++)
            result.push(locals[j]);
        }
      }
      return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
    }
    // Create a group for the given array of decoration sets, or return
    // a single set when possible.
    static from(members) {
      switch (members.length) {
        case 0:
          return empty;
        case 1:
          return members[0];
        default:
          return new _DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));
      }
    }
  };
  function mapChildren(oldChildren, newLocal, mapping, node, offset2, oldOffset, options) {
    let children = oldChildren.slice();
    for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
      let moved = 0;
      mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
        let dSize = newEnd - newStart - (oldEnd - oldStart);
        for (let i2 = 0; i2 < children.length; i2 += 3) {
          let end2 = children[i2 + 1];
          if (end2 < 0 || oldStart > end2 + baseOffset - moved)
            continue;
          let start2 = children[i2] + baseOffset - moved;
          if (oldEnd >= start2) {
            children[i2 + 1] = oldStart <= start2 ? -2 : -1;
          } else if (newStart >= offset2 && dSize) {
            children[i2] += dSize;
            children[i2 + 1] += dSize;
          }
        }
        moved += dSize;
      });
      baseOffset = mapping.maps[i].map(baseOffset, -1);
    }
    let mustRebuild = false;
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] < 0) {
        if (children[i + 1] == -2) {
          mustRebuild = true;
          children[i + 1] = -1;
          continue;
        }
        let from2 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from2 - offset2;
        if (fromLocal < 0 || fromLocal >= node.content.size) {
          mustRebuild = true;
          continue;
        }
        let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset2;
        let { index, offset: childOffset } = node.content.findIndex(fromLocal);
        let childNode = node.maybeChild(index);
        if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
          let mapped = children[i + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i] + oldOffset + 1, options);
          if (mapped != empty) {
            children[i] = fromLocal;
            children[i + 1] = toLocal;
            children[i + 2] = mapped;
          } else {
            children[i + 1] = -2;
            mustRebuild = true;
          }
        } else {
          mustRebuild = true;
        }
      }
    if (mustRebuild) {
      let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset2, oldOffset, options);
      let built = buildTree(decorations, node, 0, options);
      newLocal = built.local;
      for (let i = 0; i < children.length; i += 3)
        if (children[i + 1] < 0) {
          children.splice(i, 3);
          i -= 3;
        }
      for (let i = 0, j = 0; i < built.children.length; i += 3) {
        let from2 = built.children[i];
        while (j < children.length && children[j] < from2)
          j += 3;
        children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
      }
    }
    return new DecorationSet(newLocal.sort(byPos), children);
  }
  function moveSpans(spans, offset2) {
    if (!offset2 || !spans.length)
      return spans;
    let result = [];
    for (let i = 0; i < spans.length; i++) {
      let span = spans[i];
      result.push(new Decoration(span.from + offset2, span.to + offset2, span.type));
    }
    return result;
  }
  function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset2, oldOffset, options) {
    function gather(set, oldOffset2) {
      for (let i = 0; i < set.local.length; i++) {
        let mapped = set.local[i].map(mapping, offset2, oldOffset2);
        if (mapped)
          decorations.push(mapped);
        else if (options.onRemove)
          options.onRemove(set.local[i].spec);
      }
      for (let i = 0; i < set.children.length; i += 3)
        gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);
    }
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] == -1)
        gather(children[i + 2], oldChildren[i] + oldOffset + 1);
    return decorations;
  }
  function takeSpansForNode(spans, node, offset2) {
    if (node.isLeaf)
      return null;
    let end2 = offset2 + node.nodeSize, found2 = null;
    for (let i = 0, span; i < spans.length; i++) {
      if ((span = spans[i]) && span.from > offset2 && span.to < end2) {
        (found2 || (found2 = [])).push(span);
        spans[i] = null;
      }
    }
    return found2;
  }
  function withoutNulls(array) {
    let result = [];
    for (let i = 0; i < array.length; i++)
      if (array[i] != null)
        result.push(array[i]);
    return result;
  }
  function buildTree(spans, node, offset2, options) {
    let children = [], hasNulls = false;
    node.forEach((childNode, localStart) => {
      let found2 = takeSpansForNode(spans, childNode, localStart + offset2);
      if (found2) {
        hasNulls = true;
        let subtree = buildTree(found2, childNode, offset2 + localStart + 1, options);
        if (subtree != empty)
          children.push(localStart, localStart + childNode.nodeSize, subtree);
      }
    });
    let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
    for (let i = 0; i < locals.length; i++)
      if (!locals[i].type.valid(node, locals[i])) {
        if (options.onRemove)
          options.onRemove(locals[i].spec);
        locals.splice(i--, 1);
      }
    return locals.length || children.length ? new DecorationSet(locals, children) : empty;
  }
  function byPos(a, b) {
    return a.from - b.from || a.to - b.to;
  }
  function removeOverlap(spans) {
    let working = spans;
    for (let i = 0; i < working.length - 1; i++) {
      let span = working[i];
      if (span.from != span.to)
        for (let j = i + 1; j < working.length; j++) {
          let next = working[j];
          if (next.from == span.from) {
            if (next.to != span.to) {
              if (working == spans)
                working = spans.slice();
              working[j] = next.copy(next.from, span.to);
              insertAhead(working, j + 1, next.copy(span.to, next.to));
            }
            continue;
          } else {
            if (next.from < span.to) {
              if (working == spans)
                working = spans.slice();
              working[i] = span.copy(span.from, next.from);
              insertAhead(working, j, span.copy(next.from, span.to));
            }
            break;
          }
        }
    }
    return working;
  }
  function insertAhead(array, i, deco) {
    while (i < array.length && byPos(deco, array[i]) > 0)
      i++;
    array.splice(i, 0, deco);
  }
  function viewDecorations(view) {
    let found2 = [];
    view.someProp("decorations", (f) => {
      let result = f(view.state);
      if (result && result != empty)
        found2.push(result);
    });
    if (view.cursorWrapper)
      found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
    return DecorationGroup.from(found2);
  }
  var observeOptions = {
    childList: true,
    characterData: true,
    characterDataOldValue: true,
    attributes: true,
    attributeOldValue: true,
    subtree: true
  };
  var useCharData = ie && ie_version <= 11;
  var SelectionState = class {
    constructor() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    set(sel) {
      this.anchorNode = sel.anchorNode;
      this.anchorOffset = sel.anchorOffset;
      this.focusNode = sel.focusNode;
      this.focusOffset = sel.focusOffset;
    }
    clear() {
      this.anchorNode = this.focusNode = null;
    }
    eq(sel) {
      return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
    }
  };
  var DOMObserver = class {
    constructor(view, handleDOMChange) {
      this.view = view;
      this.handleDOMChange = handleDOMChange;
      this.queue = [];
      this.flushingSoon = -1;
      this.observer = null;
      this.currentSelection = new SelectionState();
      this.onCharData = null;
      this.suppressingSelectionUpdates = false;
      this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
        for (let i = 0; i < mutations.length; i++)
          this.queue.push(mutations[i]);
        if (ie && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
          this.flushSoon();
        else
          this.flush();
      });
      if (useCharData) {
        this.onCharData = (e) => {
          this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
          this.flushSoon();
        };
      }
      this.onSelectionChange = this.onSelectionChange.bind(this);
    }
    flushSoon() {
      if (this.flushingSoon < 0)
        this.flushingSoon = window.setTimeout(() => {
          this.flushingSoon = -1;
          this.flush();
        }, 20);
    }
    forceFlush() {
      if (this.flushingSoon > -1) {
        window.clearTimeout(this.flushingSoon);
        this.flushingSoon = -1;
        this.flush();
      }
    }
    start() {
      if (this.observer) {
        this.observer.takeRecords();
        this.observer.observe(this.view.dom, observeOptions);
      }
      if (this.onCharData)
        this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.connectSelection();
    }
    stop() {
      if (this.observer) {
        let take = this.observer.takeRecords();
        if (take.length) {
          for (let i = 0; i < take.length; i++)
            this.queue.push(take[i]);
          window.setTimeout(() => this.flush(), 20);
        }
        this.observer.disconnect();
      }
      if (this.onCharData)
        this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
      this.disconnectSelection();
    }
    connectSelection() {
      this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    }
    disconnectSelection() {
      this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    }
    suppressSelectionUpdates() {
      this.suppressingSelectionUpdates = true;
      setTimeout(() => this.suppressingSelectionUpdates = false, 50);
    }
    onSelectionChange() {
      if (!hasFocusAndSelection(this.view))
        return;
      if (this.suppressingSelectionUpdates)
        return selectionToDOM(this.view);
      if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
        let sel = this.view.domSelectionRange();
        if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
    setCurSelection() {
      this.currentSelection.set(this.view.domSelectionRange());
    }
    ignoreSelectionChange(sel) {
      if (!sel.focusNode)
        return true;
      let ancestors = /* @__PURE__ */ new Set(), container;
      for (let scan = sel.focusNode; scan; scan = parentNode(scan))
        ancestors.add(scan);
      for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
        if (ancestors.has(scan)) {
          container = scan;
          break;
        }
      let desc = container && this.view.docView.nearestDesc(container);
      if (desc && desc.ignoreMutation({
        type: "selection",
        target: container.nodeType == 3 ? container.parentNode : container
      })) {
        this.setCurSelection();
        return true;
      }
    }
    pendingRecords() {
      if (this.observer)
        for (let mut of this.observer.takeRecords())
          this.queue.push(mut);
      return this.queue;
    }
    flush() {
      let { view } = this;
      if (!view.docView || this.flushingSoon > -1)
        return;
      let mutations = this.pendingRecords();
      if (mutations.length)
        this.queue = [];
      let sel = view.domSelectionRange();
      let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
      let from2 = -1, to = -1, typeOver = false, added = [];
      if (view.editable) {
        for (let i = 0; i < mutations.length; i++) {
          let result = this.registerMutation(mutations[i], added);
          if (result) {
            from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
            to = to < 0 ? result.to : Math.max(result.to, to);
            if (result.typeOver)
              typeOver = true;
          }
        }
      }
      if (gecko && added.length > 1) {
        let brs = added.filter((n) => n.nodeName == "BR");
        if (brs.length == 2) {
          let a = brs[0], b = brs[1];
          if (a.parentNode && a.parentNode.parentNode == b.parentNode)
            b.remove();
          else
            a.remove();
        }
      }
      let readSel = null;
      if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
        view.input.lastFocus = 0;
        selectionToDOM(view);
        this.currentSelection.set(sel);
        view.scrollToSelection();
      } else if (from2 > -1 || newSel) {
        if (from2 > -1) {
          view.docView.markDirty(from2, to);
          checkCSS(view);
        }
        this.handleDOMChange(from2, to, typeOver, added);
        if (view.docView && view.docView.dirty)
          view.updateState(view.state);
        else if (!this.currentSelection.eq(sel))
          selectionToDOM(view);
        this.currentSelection.set(sel);
      }
    }
    registerMutation(mut, added) {
      if (added.indexOf(mut.target) > -1)
        return null;
      let desc = this.view.docView.nearestDesc(mut.target);
      if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
      mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
        return null;
      if (!desc || desc.ignoreMutation(mut))
        return null;
      if (mut.type == "childList") {
        for (let i = 0; i < mut.addedNodes.length; i++)
          added.push(mut.addedNodes[i]);
        if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
          return { from: desc.posBefore, to: desc.posAfter };
        let prev = mut.previousSibling, next = mut.nextSibling;
        if (ie && ie_version <= 11 && mut.addedNodes.length) {
          for (let i = 0; i < mut.addedNodes.length; i++) {
            let { previousSibling, nextSibling } = mut.addedNodes[i];
            if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
              prev = previousSibling;
            if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
              next = nextSibling;
          }
        }
        let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
        let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
        let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
        let to = desc.localPosFromDOM(mut.target, toOffset, 1);
        return { from: from2, to };
      } else if (mut.type == "attributes") {
        return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
      } else {
        return {
          from: desc.posAtStart,
          to: desc.posAtEnd,
          // An event was generated for a text change that didn't change
          // any text. Mark the dom change to fall back to assuming the
          // selection was typed over with an identical value if it can't
          // find another change.
          typeOver: mut.target.nodeValue == mut.oldValue
        };
      }
    }
  };
  var cssChecked = /* @__PURE__ */ new WeakMap();
  var cssCheckWarned = false;
  function checkCSS(view) {
    if (cssChecked.has(view))
      return;
    cssChecked.set(view, null);
    if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
      view.requiresGeckoHackNode = gecko;
      if (cssCheckWarned)
        return;
      console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
      cssCheckWarned = true;
    }
  }
  function safariShadowSelectionRange(view) {
    let found2;
    function read2(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      found2 = event.getTargetRanges()[0];
    }
    view.dom.addEventListener("beforeinput", read2, true);
    document.execCommand("indent");
    view.dom.removeEventListener("beforeinput", read2, true);
    let anchorNode = found2.startContainer, anchorOffset = found2.startOffset;
    let focusNode = found2.endContainer, focusOffset = found2.endOffset;
    let currentAnchor = view.domAtPos(view.state.selection.anchor);
    if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
  }
  function parseBetween(view, from_, to_) {
    let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);
    let domSel = view.domSelectionRange();
    let find;
    let anchor = domSel.anchorNode;
    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
      find = [{ node: anchor, offset: domSel.anchorOffset }];
      if (!selectionCollapsed(domSel))
        find.push({ node: domSel.focusNode, offset: domSel.focusOffset });
    }
    if (chrome && view.input.lastKeyCode === 8) {
      for (let off = toOffset; off > fromOffset; off--) {
        let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
        if (node.nodeName == "BR" && !desc) {
          toOffset = off;
          break;
        }
        if (!desc || desc.size)
          break;
      }
    }
    let startDoc = view.state.doc;
    let parser = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
    let $from = startDoc.resolve(from2);
    let sel = null, doc3 = parser.parse(parent, {
      topNode: $from.parent,
      topMatch: $from.parent.contentMatchAt($from.index()),
      topOpen: true,
      from: fromOffset,
      to: toOffset,
      preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
      findPositions: find,
      ruleFromNode,
      context: $from
    });
    if (find && find[0].pos != null) {
      let anchor2 = find[0].pos, head = find[1] && find[1].pos;
      if (head == null)
        head = anchor2;
      sel = { anchor: anchor2 + from2, head: head + from2 };
    }
    return { doc: doc3, sel, from: from2, to };
  }
  function ruleFromNode(dom) {
    let desc = dom.pmViewDesc;
    if (desc) {
      return desc.parseRule();
    } else if (dom.nodeName == "BR" && dom.parentNode) {
      if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
        let skip = document.createElement("div");
        skip.appendChild(document.createElement("li"));
        return { skip };
      } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
        return { ignore: true };
      }
    } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
      return { ignore: true };
    }
    return null;
  }
  var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
  function readDOMChange(view, from2, to, typeOver, addedNodes) {
    let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
    view.input.compositionPendingChanges = 0;
    if (from2 < 0) {
      let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
      let newSel = selectionFromDOM(view, origin);
      if (newSel && !view.state.selection.eq(newSel)) {
        if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
          return;
        let tr2 = view.state.tr.setSelection(newSel);
        if (origin == "pointer")
          tr2.setMeta("pointer", true);
        else if (origin == "key")
          tr2.scrollIntoView();
        if (compositionID)
          tr2.setMeta("composition", compositionID);
        view.dispatch(tr2);
      }
      return;
    }
    let $before = view.state.doc.resolve(from2);
    let shared = $before.sharedDepth(to);
    from2 = $before.before(shared + 1);
    to = view.state.doc.resolve(to).after(shared + 1);
    let sel = view.state.selection;
    let parse = parseBetween(view, from2, to);
    let doc3 = view.state.doc, compare = doc3.slice(parse.from, parse.to);
    let preferredPos, preferredSide;
    if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
      preferredPos = view.state.selection.to;
      preferredSide = "end";
    } else {
      preferredPos = view.state.selection.from;
      preferredSide = "start";
    }
    view.input.lastKeyCode = null;
    let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
    if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
      view.input.lastIOSEnter = 0;
      return;
    }
    if (!change) {
      if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
        change = { start: sel.from, endA: sel.to, endB: sel.to };
      } else {
        if (parse.sel) {
          let sel2 = resolveSelection(view, view.state.doc, parse.sel);
          if (sel2 && !sel2.eq(view.state.selection)) {
            let tr2 = view.state.tr.setSelection(sel2);
            if (compositionID)
              tr2.setMeta("composition", compositionID);
            view.dispatch(tr2);
          }
        }
        return;
      }
    }
    if (chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from && parse.sel.head == parse.sel.anchor) {
      let size = change.endB - change.start;
      parse.sel = { anchor: parse.sel.anchor + size, head: parse.sel.anchor + size };
    }
    view.input.domChangeCount++;
    if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
      if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
        change.start = view.state.selection.from;
      } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
        change.endB += view.state.selection.to - change.endA;
        change.endA = view.state.selection.to;
      }
    }
    if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \xA0") {
      change.start--;
      change.endA--;
      change.endB--;
    }
    let $from = parse.doc.resolveNoCache(change.start - parse.from);
    let $to = parse.doc.resolveNoCache(change.endB - parse.from);
    let $fromA = doc3.resolve(change.start);
    let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
    let nextSel;
    if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse.doc.content.size && !$from.sameParent($to) && (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
      view.input.lastIOSEnter = 0;
      return;
    }
    if (view.state.selection.anchor > change.start && looksLikeJoin(doc3, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
      if (android && chrome)
        view.domObserver.suppressSelectionUpdates();
      return;
    }
    if (chrome && android && change.endB == change.start)
      view.input.lastAndroidDelete = Date.now();
    if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
      change.endB -= 2;
      $to = parse.doc.resolveNoCache(change.endB - parse.from);
      setTimeout(() => {
        view.someProp("handleKeyDown", function(f) {
          return f(view, keyEvent(13, "Enter"));
        });
      }, 20);
    }
    let chFrom = change.start, chTo = change.endA;
    let tr, storedMarks, markChange;
    if (inlineChange) {
      if ($from.pos == $to.pos) {
        if (ie && ie_version <= 11 && $from.parentOffset == 0) {
          view.domObserver.suppressSelectionUpdates();
          setTimeout(() => selectionToDOM(view), 20);
        }
        tr = view.state.tr.delete(chFrom, chTo);
        storedMarks = doc3.resolve(change.start).marksAcross(doc3.resolve(change.endA));
      } else if (
        // Adding or removing a mark
        change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
      ) {
        tr = view.state.tr;
        if (markChange.type == "add")
          tr.addMark(chFrom, chTo, markChange.mark);
        else
          tr.removeMark(chFrom, chTo, markChange.mark);
      } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
        let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
        if (view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text)))
          return;
        tr = view.state.tr.insertText(text, chFrom, chTo);
      }
    }
    if (!tr)
      tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
    if (parse.sel) {
      let sel2 = resolveSelection(view, tr.doc, parse.sel);
      if (sel2 && !(chrome && android && view.composing && sel2.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))
        tr.setSelection(sel2);
    }
    if (storedMarks)
      tr.ensureMarks(storedMarks);
    if (compositionID)
      tr.setMeta("composition", compositionID);
    view.dispatch(tr.scrollIntoView());
  }
  function resolveSelection(view, doc3, parsedSel) {
    if (Math.max(parsedSel.anchor, parsedSel.head) > doc3.content.size)
      return null;
    return selectionBetween(view, doc3.resolve(parsedSel.anchor), doc3.resolve(parsedSel.head));
  }
  function isMarkChange(cur, prev) {
    let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
    let added = curMarks, removed = prevMarks, type, mark, update;
    for (let i = 0; i < prevMarks.length; i++)
      added = prevMarks[i].removeFromSet(added);
    for (let i = 0; i < curMarks.length; i++)
      removed = curMarks[i].removeFromSet(removed);
    if (added.length == 1 && removed.length == 0) {
      mark = added[0];
      type = "add";
      update = (node) => node.mark(mark.addToSet(node.marks));
    } else if (added.length == 0 && removed.length == 1) {
      mark = removed[0];
      type = "remove";
      update = (node) => node.mark(mark.removeFromSet(node.marks));
    } else {
      return null;
    }
    let updated = [];
    for (let i = 0; i < prev.childCount; i++)
      updated.push(update(prev.child(i)));
    if (Fragment.from(updated).eq(cur))
      return { mark, type };
  }
  function looksLikeJoin(old, start2, end2, $newStart, $newEnd) {
    if (!$newStart.parent.isTextblock || // The content must have shrunk
    end2 - start2 <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
    skipClosingAndOpening($newStart, true, false) < $newEnd.pos)
      return false;
    let $start = old.resolve(start2);
    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
      return false;
    let $next = old.resolve(skipClosingAndOpening($start, true, true));
    if (!$next.parent.isTextblock || $next.pos > end2 || skipClosingAndOpening($next, true, false) < end2)
      return false;
    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
  }
  function skipClosingAndOpening($pos, fromEnd, mayOpen) {
    let depth = $pos.depth, end2 = fromEnd ? $pos.end() : $pos.pos;
    while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
      depth--;
      end2++;
      fromEnd = false;
    }
    if (mayOpen) {
      let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
      while (next && !next.isLeaf) {
        next = next.firstChild;
        end2++;
      }
    }
    return end2;
  }
  function findDiff(a, b, pos, preferredPos, preferredSide) {
    let start2 = a.findDiffStart(b, pos);
    if (start2 == null)
      return null;
    let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
    if (preferredSide == "end") {
      let adjust = Math.max(0, start2 - Math.min(endA, endB));
      preferredPos -= endA + adjust - start2;
    }
    if (endA < start2 && a.size < b.size) {
      let move = preferredPos <= start2 && preferredPos >= endA ? start2 - preferredPos : 0;
      start2 -= move;
      endB = start2 + (endB - endA);
      endA = start2;
    } else if (endB < start2) {
      let move = preferredPos <= start2 && preferredPos >= endB ? start2 - preferredPos : 0;
      start2 -= move;
      endA = start2 + (endA - endB);
      endB = start2;
    }
    return { start: start2, endA, endB };
  }
  var EditorView = class {
    /**
    Create a view. `place` may be a DOM node that the editor should
    be appended to, a function that will place it into the document,
    or an object whose `mount` property holds the node to use as the
    document container. If it is `null`, the editor will not be
    added to the document.
    */
    constructor(place, props) {
      this._root = null;
      this.focused = false;
      this.trackWrites = null;
      this.mounted = false;
      this.markCursor = null;
      this.cursorWrapper = null;
      this.lastSelectedViewDesc = void 0;
      this.input = new InputState();
      this.prevDirectPlugins = [];
      this.pluginViews = [];
      this.requiresGeckoHackNode = false;
      this.dragging = null;
      this._props = props;
      this.state = props.state;
      this.directPlugins = props.plugins || [];
      this.directPlugins.forEach(checkStateComponent);
      this.dispatch = this.dispatch.bind(this);
      this.dom = place && place.mount || document.createElement("div");
      if (place) {
        if (place.appendChild)
          place.appendChild(this.dom);
        else if (typeof place == "function")
          place(this.dom);
        else if (place.mount)
          this.mounted = true;
      }
      this.editable = getEditable(this);
      updateCursorWrapper(this);
      this.nodeViews = buildNodeViews(this);
      this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
      this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));
      this.domObserver.start();
      initInput(this);
      this.updatePluginViews();
    }
    /**
    Holds `true` when a
    [composition](https://w3c.github.io/uievents/#events-compositionevents)
    is active.
    */
    get composing() {
      return this.input.composing;
    }
    /**
    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
    */
    get props() {
      if (this._props.state != this.state) {
        let prev = this._props;
        this._props = {};
        for (let name in prev)
          this._props[name] = prev[name];
        this._props.state = this.state;
      }
      return this._props;
    }
    /**
    Update the view's props. Will immediately cause an update to
    the DOM.
    */
    update(props) {
      if (props.handleDOMEvents != this._props.handleDOMEvents)
        ensureListeners(this);
      let prevProps = this._props;
      this._props = props;
      if (props.plugins) {
        props.plugins.forEach(checkStateComponent);
        this.directPlugins = props.plugins;
      }
      this.updateStateInner(props.state, prevProps);
    }
    /**
    Update the view by updating existing props object with the object
    given as argument. Equivalent to `view.update(Object.assign({},
    view.props, props))`.
    */
    setProps(props) {
      let updated = {};
      for (let name in this._props)
        updated[name] = this._props[name];
      updated.state = this.state;
      for (let name in props)
        updated[name] = props[name];
      this.update(updated);
    }
    /**
    Update the editor's `state` prop, without touching any of the
    other props.
    */
    updateState(state) {
      this.updateStateInner(state, this._props);
    }
    updateStateInner(state, prevProps) {
      let prev = this.state, redraw = false, updateSel = false;
      if (state.storedMarks && this.composing) {
        clearComposition(this);
        updateSel = true;
      }
      this.state = state;
      let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
      if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
        let nodeViews = buildNodeViews(this);
        if (changedNodeViews(nodeViews, this.nodeViews)) {
          this.nodeViews = nodeViews;
          redraw = true;
        }
      }
      if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
        ensureListeners(this);
      }
      this.editable = getEditable(this);
      updateCursorWrapper(this);
      let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
      let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
      let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
      if (updateDoc || !state.selection.eq(prev.selection))
        updateSel = true;
      let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
      if (updateSel) {
        this.domObserver.stop();
        let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
        if (updateDoc) {
          let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
          if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
            this.docView.updateOuterDeco([]);
            this.docView.destroy();
            this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
          }
          if (chromeKludge && !this.trackWrites)
            forceSelUpdate = true;
        }
        if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
          selectionToDOM(this, forceSelUpdate);
        } else {
          syncNodeSelection(this, state.selection);
          this.domObserver.setCurSelection();
        }
        this.domObserver.start();
      }
      this.updatePluginViews(prev);
      if (scroll == "reset") {
        this.dom.scrollTop = 0;
      } else if (scroll == "to selection") {
        this.scrollToSelection();
      } else if (oldScrollPos) {
        resetScrollPos(oldScrollPos);
      }
    }
    /**
    @internal
    */
    scrollToSelection() {
      let startDOM = this.domSelectionRange().focusNode;
      if (this.someProp("handleScrollToSelection", (f) => f(this)))
        ;
      else if (this.state.selection instanceof NodeSelection) {
        let target = this.docView.domAfterPos(this.state.selection.from);
        if (target.nodeType == 1)
          scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
      } else {
        scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
      }
    }
    destroyPluginViews() {
      let view;
      while (view = this.pluginViews.pop())
        if (view.destroy)
          view.destroy();
    }
    updatePluginViews(prevState) {
      if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
        this.prevDirectPlugins = this.directPlugins;
        this.destroyPluginViews();
        for (let i = 0; i < this.directPlugins.length; i++) {
          let plugin = this.directPlugins[i];
          if (plugin.spec.view)
            this.pluginViews.push(plugin.spec.view(this));
        }
        for (let i = 0; i < this.state.plugins.length; i++) {
          let plugin = this.state.plugins[i];
          if (plugin.spec.view)
            this.pluginViews.push(plugin.spec.view(this));
        }
      } else {
        for (let i = 0; i < this.pluginViews.length; i++) {
          let pluginView = this.pluginViews[i];
          if (pluginView.update)
            pluginView.update(this, prevState);
        }
      }
    }
    someProp(propName, f) {
      let prop = this._props && this._props[propName], value;
      if (prop != null && (value = f ? f(prop) : prop))
        return value;
      for (let i = 0; i < this.directPlugins.length; i++) {
        let prop2 = this.directPlugins[i].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
      let plugins = this.state.plugins;
      if (plugins)
        for (let i = 0; i < plugins.length; i++) {
          let prop2 = plugins[i].props[propName];
          if (prop2 != null && (value = f ? f(prop2) : prop2))
            return value;
        }
    }
    /**
    Query whether the view has focus.
    */
    hasFocus() {
      if (ie) {
        let node = this.root.activeElement;
        if (node == this.dom)
          return true;
        if (!node || !this.dom.contains(node))
          return false;
        while (node && this.dom != node && this.dom.contains(node)) {
          if (node.contentEditable == "false")
            return false;
          node = node.parentElement;
        }
        return true;
      }
      return this.root.activeElement == this.dom;
    }
    /**
    Focus the editor.
    */
    focus() {
      this.domObserver.stop();
      if (this.editable)
        focusPreventScroll(this.dom);
      selectionToDOM(this);
      this.domObserver.start();
    }
    /**
    Get the document root in which the editor exists. This will
    usually be the top-level `document`, but might be a [shadow
    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
    root if the editor is inside one.
    */
    get root() {
      let cached = this._root;
      if (cached == null)
        for (let search = this.dom.parentNode; search; search = search.parentNode) {
          if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
            if (!search.getSelection)
              Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
            return this._root = search;
          }
        }
      return cached || document;
    }
    /**
    When an existing editor view is moved to a new document or
    shadow tree, call this to make it recompute its root.
    */
    updateRoot() {
      this._root = null;
    }
    /**
    Given a pair of viewport coordinates, return the document
    position that corresponds to them. May return null if the given
    coordinates aren't inside of the editor. When an object is
    returned, its `pos` property is the position nearest to the
    coordinates, and its `inside` property holds the position of the
    inner node that the position falls inside of, or -1 if it is at
    the top level, not in any node.
    */
    posAtCoords(coords) {
      return posAtCoords(this, coords);
    }
    /**
    Returns the viewport rectangle at a given document position.
    `left` and `right` will be the same number, as this returns a
    flat cursor-ish rectangle. If the position is between two things
    that aren't directly adjacent, `side` determines which element
    is used. When < 0, the element before the position is used,
    otherwise the element after.
    */
    coordsAtPos(pos, side = 1) {
      return coordsAtPos(this, pos, side);
    }
    /**
    Find the DOM position that corresponds to the given document
    position. When `side` is negative, find the position as close as
    possible to the content before the position. When positive,
    prefer positions close to the content after the position. When
    zero, prefer as shallow a position as possible.
    
    Note that you should **not** mutate the editor's internal DOM,
    only inspect it (and even that is usually not necessary).
    */
    domAtPos(pos, side = 0) {
      return this.docView.domFromPos(pos, side);
    }
    /**
    Find the DOM node that represents the document node after the
    given position. May return `null` when the position doesn't point
    in front of a node or if the node is inside an opaque node view.
    
    This is intended to be able to call things like
    `getBoundingClientRect` on that DOM node. Do **not** mutate the
    editor DOM directly, or add styling this way, since that will be
    immediately overriden by the editor as it redraws the node.
    */
    nodeDOM(pos) {
      let desc = this.docView.descAt(pos);
      return desc ? desc.nodeDOM : null;
    }
    /**
    Find the document position that corresponds to a given DOM
    position. (Whenever possible, it is preferable to inspect the
    document structure directly, rather than poking around in the
    DOM, but sometimes—for example when interpreting an event
    target—you don't have a choice.)
    
    The `bias` parameter can be used to influence which side of a DOM
    node to use when the position is inside a leaf node.
    */
    posAtDOM(node, offset2, bias = -1) {
      let pos = this.docView.posFromDOM(node, offset2, bias);
      if (pos == null)
        throw new RangeError("DOM position not inside the editor");
      return pos;
    }
    /**
    Find out whether the selection is at the end of a textblock when
    moving in a given direction. When, for example, given `"left"`,
    it will return true if moving left from the current cursor
    position would leave that position's parent textblock. Will apply
    to the view's current state by default, but it is possible to
    pass a different state.
    */
    endOfTextblock(dir, state) {
      return endOfTextblock(this, state || this.state, dir);
    }
    /**
    Run the editor's paste logic with the given HTML string. The
    `event`, if given, will be passed to the
    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
    */
    pasteHTML(html, event) {
      return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
    }
    /**
    Run the editor's paste logic with the given plain-text input.
    */
    pasteText(text, event) {
      return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
    }
    /**
    Removes the editor from the DOM and destroys all [node
    views](https://prosemirror.net/docs/ref/#view.NodeView).
    */
    destroy() {
      if (!this.docView)
        return;
      destroyInput(this);
      this.destroyPluginViews();
      if (this.mounted) {
        this.docView.update(this.state.doc, [], viewDecorations(this), this);
        this.dom.textContent = "";
      } else if (this.dom.parentNode) {
        this.dom.parentNode.removeChild(this.dom);
      }
      this.docView.destroy();
      this.docView = null;
    }
    /**
    This is true when the view has been
    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
    used anymore).
    */
    get isDestroyed() {
      return this.docView == null;
    }
    /**
    Used for testing.
    */
    dispatchEvent(event) {
      return dispatchEvent(this, event);
    }
    /**
    Dispatch a transaction. Will call
    [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
    when given, and otherwise defaults to applying the transaction to
    the current state and calling
    [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
    This method is bound to the view instance, so that it can be
    easily passed around.
    */
    dispatch(tr) {
      let dispatchTransaction = this._props.dispatchTransaction;
      if (dispatchTransaction)
        dispatchTransaction.call(this, tr);
      else
        this.updateState(this.state.apply(tr));
    }
    /**
    @internal
    */
    domSelectionRange() {
      return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom ? safariShadowSelectionRange(this) : this.domSelection();
    }
    /**
    @internal
    */
    domSelection() {
      return this.root.getSelection();
    }
  };
  function computeDocDeco(view) {
    let attrs = /* @__PURE__ */ Object.create(null);
    attrs.class = "ProseMirror";
    attrs.contenteditable = String(view.editable);
    view.someProp("attributes", (value) => {
      if (typeof value == "function")
        value = value(view.state);
      if (value)
        for (let attr in value) {
          if (attr == "class")
            attrs.class += " " + value[attr];
          else if (attr == "style")
            attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
          else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
            attrs[attr] = String(value[attr]);
        }
    });
    if (!attrs.translate)
      attrs.translate = "no";
    return [Decoration.node(0, view.state.doc.content.size, attrs)];
  }
  function updateCursorWrapper(view) {
    if (view.markCursor) {
      let dom = document.createElement("img");
      dom.className = "ProseMirror-separator";
      dom.setAttribute("mark-placeholder", "true");
      dom.setAttribute("alt", "");
      view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
    } else {
      view.cursorWrapper = null;
    }
  }
  function getEditable(view) {
    return !view.someProp("editable", (value) => value(view.state) === false);
  }
  function selectionContextChanged(sel1, sel2) {
    let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
  }
  function buildNodeViews(view) {
    let result = /* @__PURE__ */ Object.create(null);
    function add(obj) {
      for (let prop in obj)
        if (!Object.prototype.hasOwnProperty.call(result, prop))
          result[prop] = obj[prop];
    }
    view.someProp("nodeViews", add);
    view.someProp("markViews", add);
    return result;
  }
  function changedNodeViews(a, b) {
    let nA = 0, nB = 0;
    for (let prop in a) {
      if (a[prop] != b[prop])
        return true;
      nA++;
    }
    for (let _ in b)
      nB++;
    return nA != nB;
  }
  function checkStateComponent(plugin) {
    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
      throw new RangeError("Plugins passed directly to the view must not have a state component");
  }

  // node_modules/w3c-keyname/index.js
  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  };
  var mac2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  for (i = 0; i < 10; i++)
    base[48 + i] = base[96 + i] = String(i);
  var i;
  for (i = 1; i <= 24; i++)
    base[i + 111] = "F" + i;
  var i;
  for (i = 65; i <= 90; i++) {
    base[i] = String.fromCharCode(i + 32);
    shift[i] = String.fromCharCode(i);
  }
  var i;
  for (code in base)
    if (!shift.hasOwnProperty(code))
      shift[code] = base[code];
  var code;
  function keyName(event) {
    var ignoreKey = mac2 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
    var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
    if (name == "Esc")
      name = "Escape";
    if (name == "Del")
      name = "Delete";
    if (name == "Left")
      name = "ArrowLeft";
    if (name == "Up")
      name = "ArrowUp";
    if (name == "Right")
      name = "ArrowRight";
    if (name == "Down")
      name = "ArrowDown";
    return name;
  }

  // node_modules/prosemirror-keymap/dist/index.js
  var mac3 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
  function normalizeKeyName(name) {
    let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
    if (result == "Space")
      result = " ";
    let alt, ctrl, shift2, meta;
    for (let i = 0; i < parts.length - 1; i++) {
      let mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod))
        meta = true;
      else if (/^a(lt)?$/i.test(mod))
        alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod))
        ctrl = true;
      else if (/^s(hift)?$/i.test(mod))
        shift2 = true;
      else if (/^mod$/i.test(mod)) {
        if (mac3)
          meta = true;
        else
          ctrl = true;
      } else
        throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
      result = "Alt-" + result;
    if (ctrl)
      result = "Ctrl-" + result;
    if (meta)
      result = "Meta-" + result;
    if (shift2)
      result = "Shift-" + result;
    return result;
  }
  function normalize(map2) {
    let copy2 = /* @__PURE__ */ Object.create(null);
    for (let prop in map2)
      copy2[normalizeKeyName(prop)] = map2[prop];
    return copy2;
  }
  function modifiers(name, event, shift2 = true) {
    if (event.altKey)
      name = "Alt-" + name;
    if (event.ctrlKey)
      name = "Ctrl-" + name;
    if (event.metaKey)
      name = "Meta-" + name;
    if (shift2 && event.shiftKey)
      name = "Shift-" + name;
    return name;
  }
  function keymap(bindings) {
    return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
  }
  function keydownHandler(bindings) {
    let map2 = normalize(bindings);
    return function(view, event) {
      let name = keyName(event), baseName, direct = map2[modifiers(name, event)];
      if (direct && direct(view.state, view.dispatch, view))
        return true;
      if (name.length == 1 && name != " ") {
        if (event.shiftKey) {
          let noShift = map2[modifiers(name, event, false)];
          if (noShift && noShift(view.state, view.dispatch, view))
            return true;
        }
        if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
          let fromCode = map2[modifiers(baseName, event)];
          if (fromCode && fromCode(view.state, view.dispatch, view))
            return true;
        }
      }
      return false;
    };
  }

  // node_modules/prosemirror-commands/dist/index.js
  var deleteSelection = (state, dispatch) => {
    if (state.selection.empty)
      return false;
    if (dispatch)
      dispatch(state.tr.deleteSelection().scrollIntoView());
    return true;
  };
  function atBlockStart(state, view) {
    let { $cursor } = state.selection;
    if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
      return null;
    return $cursor;
  }
  var joinBackward = (state, dispatch, view) => {
    let $cursor = atBlockStart(state, view);
    if (!$cursor)
      return false;
    let $cut = findCutBefore($cursor);
    if (!$cut) {
      let range = $cursor.blockRange(), target = range && liftTarget(range);
      if (target == null)
        return false;
      if (dispatch)
        dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    }
    let before = $cut.nodeBefore;
    if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))
      return true;
    if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
      let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          let tr = state.tr.step(delStep);
          tr.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
    }
    if (before.isAtom && $cut.depth == $cursor.depth - 1) {
      if (dispatch)
        dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
      return true;
    }
    return false;
  };
  function textblockAt(node, side, only = false) {
    for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
      if (scan.isTextblock)
        return true;
      if (only && scan.childCount != 1)
        return false;
    }
    return false;
  }
  var selectNodeBackward = (state, dispatch, view) => {
    let { $head, empty: empty2 } = state.selection, $cut = $head;
    if (!empty2)
      return false;
    if ($head.parent.isTextblock) {
      if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
        return false;
      $cut = findCutBefore($head);
    }
    let node = $cut && $cut.nodeBefore;
    if (!node || !NodeSelection.isSelectable(node))
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
    return true;
  };
  function findCutBefore($pos) {
    if (!$pos.parent.type.spec.isolating)
      for (let i = $pos.depth - 1; i >= 0; i--) {
        if ($pos.index(i) > 0)
          return $pos.doc.resolve($pos.before(i + 1));
        if ($pos.node(i).type.spec.isolating)
          break;
      }
    return null;
  }
  function atBlockEnd(state, view) {
    let { $cursor } = state.selection;
    if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
      return null;
    return $cursor;
  }
  var joinForward = (state, dispatch, view) => {
    let $cursor = atBlockEnd(state, view);
    if (!$cursor)
      return false;
    let $cut = findCutAfter($cursor);
    if (!$cut)
      return false;
    let after = $cut.nodeAfter;
    if (deleteBarrier(state, $cut, dispatch))
      return true;
    if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
      let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          let tr = state.tr.step(delStep);
          tr.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
    }
    if (after.isAtom && $cut.depth == $cursor.depth - 1) {
      if (dispatch)
        dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
      return true;
    }
    return false;
  };
  var selectNodeForward = (state, dispatch, view) => {
    let { $head, empty: empty2 } = state.selection, $cut = $head;
    if (!empty2)
      return false;
    if ($head.parent.isTextblock) {
      if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
        return false;
      $cut = findCutAfter($head);
    }
    let node = $cut && $cut.nodeAfter;
    if (!node || !NodeSelection.isSelectable(node))
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
    return true;
  };
  function findCutAfter($pos) {
    if (!$pos.parent.type.spec.isolating)
      for (let i = $pos.depth - 1; i >= 0; i--) {
        let parent = $pos.node(i);
        if ($pos.index(i) + 1 < parent.childCount)
          return $pos.doc.resolve($pos.after(i + 1));
        if (parent.type.spec.isolating)
          break;
      }
    return null;
  }
  var joinUp = (state, dispatch) => {
    let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
    if (nodeSel) {
      if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
        return false;
      point = sel.from;
    } else {
      point = joinPoint(state.doc, sel.from, -1);
      if (point == null)
        return false;
    }
    if (dispatch) {
      let tr = state.tr.join(point);
      if (nodeSel)
        tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
  var joinDown = (state, dispatch) => {
    let sel = state.selection, point;
    if (sel instanceof NodeSelection) {
      if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
        return false;
      point = sel.to;
    } else {
      point = joinPoint(state.doc, sel.to, 1);
      if (point == null)
        return false;
    }
    if (dispatch)
      dispatch(state.tr.join(point).scrollIntoView());
    return true;
  };
  var lift2 = (state, dispatch) => {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  };
  var newlineInCode = (state, dispatch) => {
    let { $head, $anchor } = state.selection;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
      return false;
    if (dispatch)
      dispatch(state.tr.insertText("\n").scrollIntoView());
    return true;
  };
  function defaultBlockAt(match) {
    for (let i = 0; i < match.edgeCount; i++) {
      let { type } = match.edge(i);
      if (type.isTextblock && !type.hasRequiredAttrs())
        return type;
    }
    return null;
  }
  var exitCode = (state, dispatch) => {
    let { $head, $anchor } = state.selection;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
      return false;
    let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
    if (!type || !above.canReplaceWith(after, after, type))
      return false;
    if (dispatch) {
      let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
      tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
  var createParagraphNear = (state, dispatch) => {
    let sel = state.selection, { $from, $to } = sel;
    if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
      return false;
    let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
    if (!type || !type.isTextblock)
      return false;
    if (dispatch) {
      let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
      let tr = state.tr.insert(side, type.createAndFill());
      tr.setSelection(TextSelection.create(tr.doc, side + 1));
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
  var liftEmptyBlock = (state, dispatch) => {
    let { $cursor } = state.selection;
    if (!$cursor || $cursor.parent.content.size)
      return false;
    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
      let before = $cursor.before();
      if (canSplit(state.doc, before)) {
        if (dispatch)
          dispatch(state.tr.split(before).scrollIntoView());
        return true;
      }
    }
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  };
  function splitBlockAs(splitNode) {
    return (state, dispatch) => {
      let { $from, $to } = state.selection;
      if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
        if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
          return false;
        if (dispatch)
          dispatch(state.tr.split($from.pos).scrollIntoView());
        return true;
      }
      if (!$from.parent.isBlock)
        return false;
      if (dispatch) {
        let atEnd = $to.parentOffset == $to.parent.content.size;
        let tr = state.tr;
        if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
          tr.deleteSelection();
        let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
        let splitType = splitNode && splitNode($to.parent, atEnd);
        let types = splitType ? [splitType] : atEnd && deflt ? [{ type: deflt }] : void 0;
        let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
        if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
          if (deflt)
            types = [{ type: deflt }];
          can = true;
        }
        if (can) {
          tr.split(tr.mapping.map($from.pos), 1, types);
          if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {
            let first2 = tr.mapping.map($from.before()), $first = tr.doc.resolve(first2);
            if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))
              tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
          }
        }
        dispatch(tr.scrollIntoView());
      }
      return true;
    };
  }
  var splitBlock = splitBlockAs();
  var selectParentNode = (state, dispatch) => {
    let { $from, to } = state.selection, pos;
    let same = $from.sharedDepth(to);
    if (same == 0)
      return false;
    pos = $from.before(same);
    if (dispatch)
      dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
    return true;
  };
  var selectAll = (state, dispatch) => {
    if (dispatch)
      dispatch(state.tr.setSelection(new AllSelection(state.doc)));
    return true;
  };
  function joinMaybeClear(state, $pos, dispatch) {
    let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
    if (!before || !after || !before.type.compatibleContent(after.type))
      return false;
    if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
      if (dispatch)
        dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
      return true;
    }
    if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
      return false;
    if (dispatch)
      dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());
    return true;
  }
  function deleteBarrier(state, $cut, dispatch) {
    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
    if (before.type.spec.isolating || after.type.spec.isolating)
      return false;
    if (joinMaybeClear(state, $cut, dispatch))
      return true;
    let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
    if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
      if (dispatch) {
        let end2 = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
        for (let i = conn.length - 1; i >= 0; i--)
          wrap2 = Fragment.from(conn[i].create(null, wrap2));
        wrap2 = Fragment.from(before.copy(wrap2));
        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end2, $cut.pos, end2, new Slice(wrap2, 1, 0), conn.length, true));
        let joinAt = end2 + 2 * conn.length;
        if (canJoin(tr.doc, joinAt))
          tr.join(joinAt);
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
    let selAfter = Selection.findFrom($cut, 1);
    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
    if (target != null && target >= $cut.depth) {
      if (dispatch)
        dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    }
    if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
      let at = before, wrap2 = [];
      for (; ; ) {
        wrap2.push(at);
        if (at.isTextblock)
          break;
        at = at.lastChild;
      }
      let afterText = after, afterDepth = 1;
      for (; !afterText.isTextblock; afterText = afterText.firstChild)
        afterDepth++;
      if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
        if (dispatch) {
          let end2 = Fragment.empty;
          for (let i = wrap2.length - 1; i >= 0; i--)
            end2 = Fragment.from(wrap2[i].copy(end2));
          let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end2, wrap2.length, 0), 0, true));
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
    }
    return false;
  }
  function selectTextblockSide(side) {
    return function(state, dispatch) {
      let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
      let depth = $pos.depth;
      while ($pos.node(depth).isInline) {
        if (!depth)
          return false;
        depth--;
      }
      if (!$pos.node(depth).isTextblock)
        return false;
      if (dispatch)
        dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
      return true;
    };
  }
  var selectTextblockStart = selectTextblockSide(-1);
  var selectTextblockEnd = selectTextblockSide(1);
  function wrapIn(nodeType, attrs = null) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
      if (!wrapping)
        return false;
      if (dispatch)
        dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
      return true;
    };
  }
  function setBlockType2(nodeType, attrs = null) {
    return function(state, dispatch) {
      let applicable = false;
      for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {
        let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (applicable)
            return false;
          if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
            return;
          if (node.type == nodeType) {
            applicable = true;
          } else {
            let $pos = state.doc.resolve(pos), index = $pos.index();
            applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
          }
        });
      }
      if (!applicable)
        return false;
      if (dispatch) {
        let tr = state.tr;
        for (let i = 0; i < state.selection.ranges.length; i++) {
          let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
          tr.setBlockType(from2, to, nodeType, attrs);
        }
        dispatch(tr.scrollIntoView());
      }
      return true;
    };
  }
  function chainCommands(...commands2) {
    return function(state, dispatch, view) {
      for (let i = 0; i < commands2.length; i++)
        if (commands2[i](state, dispatch, view))
          return true;
      return false;
    };
  }
  var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
  var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
  var pcBaseKeymap = {
    "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
    "Mod-Enter": exitCode,
    "Backspace": backspace,
    "Mod-Backspace": backspace,
    "Shift-Backspace": backspace,
    "Delete": del,
    "Mod-Delete": del,
    "Mod-a": selectAll
  };
  var macBaseKeymap = {
    "Ctrl-h": pcBaseKeymap["Backspace"],
    "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
    "Ctrl-d": pcBaseKeymap["Delete"],
    "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
    "Alt-Delete": pcBaseKeymap["Mod-Delete"],
    "Alt-d": pcBaseKeymap["Mod-Delete"],
    "Ctrl-a": selectTextblockStart,
    "Ctrl-e": selectTextblockEnd
  };
  for (let key in pcBaseKeymap)
    macBaseKeymap[key] = pcBaseKeymap[key];
  var mac4 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;

  // node_modules/prosemirror-schema-list/dist/index.js
  function wrapInList(listType, attrs = null) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to), doJoin = false, outerRange = range;
      if (!range)
        return false;
      if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
        if ($from.index(range.depth - 1) == 0)
          return false;
        let $insert = state.doc.resolve(range.start - 2);
        outerRange = new NodeRange($insert, $insert, range.depth);
        if (range.endIndex < range.parent.childCount)
          range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);
        doJoin = true;
      }
      let wrap2 = findWrapping(outerRange, listType, attrs, range);
      if (!wrap2)
        return false;
      if (dispatch)
        dispatch(doWrapInList(state.tr, range, wrap2, doJoin, listType).scrollIntoView());
      return true;
    };
  }
  function doWrapInList(tr, range, wrappers, joinBefore, listType) {
    let content = Fragment.empty;
    for (let i = wrappers.length - 1; i >= 0; i--)
      content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
    tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
    let found2 = 0;
    for (let i = 0; i < wrappers.length; i++)
      if (wrappers[i].type == listType)
        found2 = i + 1;
    let splitDepth = wrappers.length - found2;
    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
    for (let i = range.startIndex, e = range.endIndex, first2 = true; i < e; i++, first2 = false) {
      if (!first2 && canSplit(tr.doc, splitPos, splitDepth)) {
        tr.split(splitPos, splitDepth);
        splitPos += 2 * splitDepth;
      }
      splitPos += parent.child(i).nodeSize;
    }
    return tr;
  }
  function liftListItem(itemType) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
      if (!range)
        return false;
      if (!dispatch)
        return true;
      if ($from.node(range.depth - 1).type == itemType)
        return liftToOuterList(state, dispatch, itemType, range);
      else
        return liftOutOfList(state, dispatch, range);
    };
  }
  function liftToOuterList(state, dispatch, itemType, range) {
    let tr = state.tr, end2 = range.end, endOfList = range.$to.end(range.depth);
    if (end2 < endOfList) {
      tr.step(new ReplaceAroundStep(end2 - 1, endOfList, end2, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
      range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
    }
    const target = liftTarget(range);
    if (target == null)
      return false;
    tr.lift(range, target);
    let after = tr.mapping.map(end2, -1) - 1;
    if (canJoin(tr.doc, after))
      tr.join(after);
    dispatch(tr.scrollIntoView());
    return true;
  }
  function liftOutOfList(state, dispatch, range) {
    let tr = state.tr, list = range.parent;
    for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
      pos -= list.child(i).nodeSize;
      tr.delete(pos - 1, pos + 1);
    }
    let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
      return false;
    let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
    let parent = $start.node(-1), indexBefore = $start.index(-1);
    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
      return false;
    let start2 = $start.pos, end2 = start2 + item.nodeSize;
    tr.step(new ReplaceAroundStep(start2 - (atStart ? 1 : 0), end2 + (atEnd ? 1 : 0), start2 + 1, end2 - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
    dispatch(tr.scrollIntoView());
    return true;
  }
  function sinkListItem(itemType) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
      if (!range)
        return false;
      let startIndex = range.startIndex;
      if (startIndex == 0)
        return false;
      let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
      if (nodeBefore.type != itemType)
        return false;
      if (dispatch) {
        let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
        let inner = Fragment.from(nestedBefore ? itemType.create() : null);
        let slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
        let before = range.start, after = range.end;
        dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
      }
      return true;
    };
  }

  // node_modules/@tiptap/core/dist/index.js
  function createChainableState(config2) {
    const { state, transaction } = config2;
    let { selection } = transaction;
    let { doc: doc3 } = transaction;
    let { storedMarks } = transaction;
    return {
      ...state,
      apply: state.apply.bind(state),
      applyTransaction: state.applyTransaction.bind(state),
      filterTransaction: state.filterTransaction,
      plugins: state.plugins,
      schema: state.schema,
      reconfigure: state.reconfigure.bind(state),
      toJSON: state.toJSON.bind(state),
      get storedMarks() {
        return storedMarks;
      },
      get selection() {
        return selection;
      },
      get doc() {
        return doc3;
      },
      get tr() {
        selection = transaction.selection;
        doc3 = transaction.doc;
        storedMarks = transaction.storedMarks;
        return transaction;
      }
    };
  }
  var CommandManager = class {
    constructor(props) {
      this.editor = props.editor;
      this.rawCommands = this.editor.extensionManager.commands;
      this.customState = props.state;
    }
    get hasCustomState() {
      return !!this.customState;
    }
    get state() {
      return this.customState || this.editor.state;
    }
    get commands() {
      const { rawCommands, editor, state } = this;
      const { view } = editor;
      const { tr } = state;
      const props = this.buildProps(tr);
      return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        const method = (...args) => {
          const callback = command2(...args)(props);
          if (!tr.getMeta("preventDispatch") && !this.hasCustomState) {
            view.dispatch(tr);
          }
          return callback;
        };
        return [name, method];
      }));
    }
    get chain() {
      return () => this.createChain();
    }
    get can() {
      return () => this.createCan();
    }
    createChain(startTr, shouldDispatch = true) {
      const { rawCommands, editor, state } = this;
      const { view } = editor;
      const callbacks = [];
      const hasStartTransaction = !!startTr;
      const tr = startTr || state.tr;
      const run2 = () => {
        if (!hasStartTransaction && shouldDispatch && !tr.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr);
        }
        return callbacks.every((callback) => callback === true);
      };
      const chain = {
        ...Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          const chainedCommand = (...args) => {
            const props = this.buildProps(tr, shouldDispatch);
            const callback = command2(...args)(props);
            callbacks.push(callback);
            return chain;
          };
          return [name, chainedCommand];
        })),
        run: run2
      };
      return chain;
    }
    createCan(startTr) {
      const { rawCommands, state } = this;
      const dispatch = false;
      const tr = startTr || state.tr;
      const props = this.buildProps(tr, dispatch);
      const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
      }));
      return {
        ...formattedCommands,
        chain: () => this.createChain(tr, dispatch)
      };
    }
    buildProps(tr, shouldDispatch = true) {
      const { rawCommands, editor, state } = this;
      const { view } = editor;
      const props = {
        tr,
        editor,
        view,
        state: createChainableState({
          state,
          transaction: tr
        }),
        dispatch: shouldDispatch ? () => void 0 : void 0,
        chain: () => this.createChain(tr, shouldDispatch),
        can: () => this.createCan(tr),
        get commands() {
          return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
            return [name, (...args) => command2(...args)(props)];
          }));
        }
      };
      return props;
    }
  };
  var EventEmitter = class {
    constructor() {
      this.callbacks = {};
    }
    on(event, fn2) {
      if (!this.callbacks[event]) {
        this.callbacks[event] = [];
      }
      this.callbacks[event].push(fn2);
      return this;
    }
    emit(event, ...args) {
      const callbacks = this.callbacks[event];
      if (callbacks) {
        callbacks.forEach((callback) => callback.apply(this, args));
      }
      return this;
    }
    off(event, fn2) {
      const callbacks = this.callbacks[event];
      if (callbacks) {
        if (fn2) {
          this.callbacks[event] = callbacks.filter((callback) => callback !== fn2);
        } else {
          delete this.callbacks[event];
        }
      }
      return this;
    }
    removeAllListeners() {
      this.callbacks = {};
    }
  };
  function getExtensionField(extension, field, context) {
    if (extension.config[field] === void 0 && extension.parent) {
      return getExtensionField(extension.parent, field, context);
    }
    if (typeof extension.config[field] === "function") {
      const value = extension.config[field].bind({
        ...context,
        parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
      });
      return value;
    }
    return extension.config[field];
  }
  function splitExtensions(extensions2) {
    const baseExtensions = extensions2.filter((extension) => extension.type === "extension");
    const nodeExtensions = extensions2.filter((extension) => extension.type === "node");
    const markExtensions = extensions2.filter((extension) => extension.type === "mark");
    return {
      baseExtensions,
      nodeExtensions,
      markExtensions
    };
  }
  function getAttributesFromExtensions(extensions2) {
    const extensionAttributes = [];
    const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
    const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
    const defaultAttribute = {
      default: null,
      rendered: true,
      renderHTML: null,
      parseHTML: null,
      keepOnSplit: true,
      isRequired: false
    };
    extensions2.forEach((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
      if (!addGlobalAttributes) {
        return;
      }
      const globalAttributes = addGlobalAttributes();
      globalAttributes.forEach((globalAttribute) => {
        globalAttribute.types.forEach((type) => {
          Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
            extensionAttributes.push({
              type,
              name,
              attribute: {
                ...defaultAttribute,
                ...attribute
              }
            });
          });
        });
      });
    });
    nodeAndMarkExtensions.forEach((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addAttributes = getExtensionField(extension, "addAttributes", context);
      if (!addAttributes) {
        return;
      }
      const attributes = addAttributes();
      Object.entries(attributes).forEach(([name, attribute]) => {
        const mergedAttr = {
          ...defaultAttribute,
          ...attribute
        };
        if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === "function") {
          mergedAttr.default = mergedAttr.default();
        }
        if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === void 0) {
          delete mergedAttr.default;
        }
        extensionAttributes.push({
          type: extension.name,
          name,
          attribute: mergedAttr
        });
      });
    });
    return extensionAttributes;
  }
  function getNodeType(nameOrType, schema) {
    if (typeof nameOrType === "string") {
      if (!schema.nodes[nameOrType]) {
        throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
      }
      return schema.nodes[nameOrType];
    }
    return nameOrType;
  }
  function mergeAttributes(...objects) {
    return objects.filter((item) => !!item).reduce((items, item) => {
      const mergedAttributes = { ...items };
      Object.entries(item).forEach(([key, value]) => {
        const exists = mergedAttributes[key];
        if (!exists) {
          mergedAttributes[key] = value;
          return;
        }
        if (key === "class") {
          const valueClasses = value ? value.split(" ") : [];
          const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
          const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
          mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
        } else if (key === "style") {
          mergedAttributes[key] = [mergedAttributes[key], value].join("; ");
        } else {
          mergedAttributes[key] = value;
        }
      });
      return mergedAttributes;
    }, {});
  }
  function getRenderedAttributes(nodeOrMark, extensionAttributes) {
    return extensionAttributes.filter((item) => item.attribute.rendered).map((item) => {
      if (!item.attribute.renderHTML) {
        return {
          [item.name]: nodeOrMark.attrs[item.name]
        };
      }
      return item.attribute.renderHTML(nodeOrMark.attrs) || {};
    }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function callOrReturn(value, context = void 0, ...props) {
    if (isFunction(value)) {
      if (context) {
        return value.bind(context)(...props);
      }
      return value(...props);
    }
    return value;
  }
  function isEmptyObject(value = {}) {
    return Object.keys(value).length === 0 && value.constructor === Object;
  }
  function fromString(value) {
    if (typeof value !== "string") {
      return value;
    }
    if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
      return Number(value);
    }
    if (value === "true") {
      return true;
    }
    if (value === "false") {
      return false;
    }
    return value;
  }
  function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
    if (parseRule.style) {
      return parseRule;
    }
    return {
      ...parseRule,
      getAttrs: (node) => {
        const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
        if (oldAttributes === false) {
          return false;
        }
        const newAttributes = extensionAttributes.reduce((items, item) => {
          const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
          if (value === null || value === void 0) {
            return items;
          }
          return {
            ...items,
            [item.name]: value
          };
        }, {});
        return { ...oldAttributes, ...newAttributes };
      }
    };
  }
  function cleanUpSchemaItem(data) {
    return Object.fromEntries(
      // @ts-ignore
      Object.entries(data).filter(([key, value]) => {
        if (key === "attrs" && isEmptyObject(value)) {
          return false;
        }
        return value !== null && value !== void 0;
      })
    );
  }
  function getSchemaByResolvedExtensions(extensions2, editor) {
    var _a;
    const allAttributes = getAttributesFromExtensions(extensions2);
    const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
    const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a === void 0 ? void 0 : _a.name;
    const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const extraNodeFields = extensions2.reduce((fields, e) => {
        const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
        return {
          ...fields,
          ...extendNodeSchema ? extendNodeSchema(extension) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraNodeFields,
        content: callOrReturn(getExtensionField(extension, "content", context)),
        marks: callOrReturn(getExtensionField(extension, "marks", context)),
        group: callOrReturn(getExtensionField(extension, "group", context)),
        inline: callOrReturn(getExtensionField(extension, "inline", context)),
        atom: callOrReturn(getExtensionField(extension, "atom", context)),
        selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
        draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
        code: callOrReturn(getExtensionField(extension, "code", context)),
        defining: callOrReturn(getExtensionField(extension, "defining", context)),
        isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
        attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
          var _a2;
          return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
        }))
      });
      const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
      }
      const renderHTML = getExtensionField(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (node) => renderHTML({
          node,
          HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
        });
      }
      const renderText = getExtensionField(extension, "renderText", context);
      if (renderText) {
        schema.toText = renderText;
      }
      return [extension.name, schema];
    }));
    const marks = Object.fromEntries(markExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const extraMarkFields = extensions2.reduce((fields, e) => {
        const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
        return {
          ...fields,
          ...extendMarkSchema ? extendMarkSchema(extension) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraMarkFields,
        inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
        excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
        group: callOrReturn(getExtensionField(extension, "group", context)),
        spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
        code: callOrReturn(getExtensionField(extension, "code", context)),
        attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
          var _a2;
          return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
        }))
      });
      const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
      }
      const renderHTML = getExtensionField(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (mark) => renderHTML({
          mark,
          HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
        });
      }
      return [extension.name, schema];
    }));
    return new Schema({
      topNode,
      nodes,
      marks
    });
  }
  function getSchemaTypeByName(name, schema) {
    return schema.nodes[name] || schema.marks[name] || null;
  }
  function isExtensionRulesEnabled(extension, enabled) {
    if (Array.isArray(enabled)) {
      return enabled.some((enabledExtension) => {
        const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
        return name === extension.name;
      });
    }
    return enabled;
  }
  var getTextContentFromNodes = ($from, maxMatch = 500) => {
    let textBefore = "";
    const sliceEndPos = $from.parentOffset;
    $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {
      var _a, _b;
      const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {
        node,
        pos,
        parent,
        index
      })) || node.textContent || "%leaf%";
      textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos));
    });
    return textBefore;
  };
  function isRegExp(value) {
    return Object.prototype.toString.call(value) === "[object RegExp]";
  }
  var InputRule = class {
    constructor(config2) {
      this.find = config2.find;
      this.handler = config2.handler;
    }
  };
  var inputRuleMatcherHandler = (text, find) => {
    if (isRegExp(find)) {
      return find.exec(text);
    }
    const inputRuleMatch = find(text);
    if (!inputRuleMatch) {
      return null;
    }
    const result = [inputRuleMatch.text];
    result.index = inputRuleMatch.index;
    result.input = text;
    result.data = inputRuleMatch.data;
    if (inputRuleMatch.replaceWith) {
      if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
      }
      result.push(inputRuleMatch.replaceWith);
    }
    return result;
  };
  function run$1(config2) {
    var _a;
    const { editor, from: from2, to, text, rules, plugin } = config2;
    const { view } = editor;
    if (view.composing) {
      return false;
    }
    const $from = view.state.doc.resolve(from2);
    if (
      // check for code node
      $from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find((mark) => mark.type.spec.code))
    ) {
      return false;
    }
    let matched = false;
    const textBefore = getTextContentFromNodes($from) + text;
    rules.forEach((rule) => {
      if (matched) {
        return;
      }
      const match = inputRuleMatcherHandler(textBefore, rule.find);
      if (!match) {
        return;
      }
      const tr = view.state.tr;
      const state = createChainableState({
        state: view.state,
        transaction: tr
      });
      const range = {
        from: from2 - (match[0].length - text.length),
        to
      };
      const { commands: commands2, chain, can } = new CommandManager({
        editor,
        state
      });
      const handler = rule.handler({
        state,
        range,
        match,
        commands: commands2,
        chain,
        can
      });
      if (handler === null || !tr.steps.length) {
        return;
      }
      tr.setMeta(plugin, {
        transform: tr,
        from: from2,
        to,
        text
      });
      view.dispatch(tr);
      matched = true;
    });
    return matched;
  }
  function inputRulesPlugin(props) {
    const { editor, rules } = props;
    const plugin = new Plugin({
      state: {
        init() {
          return null;
        },
        apply(tr, prev) {
          const stored = tr.getMeta(plugin);
          if (stored) {
            return stored;
          }
          return tr.selectionSet || tr.docChanged ? null : prev;
        }
      },
      props: {
        handleTextInput(view, from2, to, text) {
          return run$1({
            editor,
            from: from2,
            to,
            text,
            rules,
            plugin
          });
        },
        handleDOMEvents: {
          compositionend: (view) => {
            setTimeout(() => {
              const { $cursor } = view.state.selection;
              if ($cursor) {
                run$1({
                  editor,
                  from: $cursor.pos,
                  to: $cursor.pos,
                  text: "",
                  rules,
                  plugin
                });
              }
            });
            return false;
          }
        },
        // add support for input rules to trigger on enter
        // this is useful for example for code blocks
        handleKeyDown(view, event) {
          if (event.key !== "Enter") {
            return false;
          }
          const { $cursor } = view.state.selection;
          if ($cursor) {
            return run$1({
              editor,
              from: $cursor.pos,
              to: $cursor.pos,
              text: "\n",
              rules,
              plugin
            });
          }
          return false;
        }
      },
      // @ts-ignore
      isInputRules: true
    });
    return plugin;
  }
  function isNumber(value) {
    return typeof value === "number";
  }
  var PasteRule = class {
    constructor(config2) {
      this.find = config2.find;
      this.handler = config2.handler;
    }
  };
  var pasteRuleMatcherHandler = (text, find) => {
    if (isRegExp(find)) {
      return [...text.matchAll(find)];
    }
    const matches2 = find(text);
    if (!matches2) {
      return [];
    }
    return matches2.map((pasteRuleMatch) => {
      const result = [pasteRuleMatch.text];
      result.index = pasteRuleMatch.index;
      result.input = text;
      result.data = pasteRuleMatch.data;
      if (pasteRuleMatch.replaceWith) {
        if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
          console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
        }
        result.push(pasteRuleMatch.replaceWith);
      }
      return result;
    });
  };
  function run(config2) {
    const { editor, state, from: from2, to, rule } = config2;
    const { commands: commands2, chain, can } = new CommandManager({
      editor,
      state
    });
    const handlers2 = [];
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isTextblock || node.type.spec.code) {
        return;
      }
      const resolvedFrom = Math.max(from2, pos);
      const resolvedTo = Math.min(to, pos + node.content.size);
      const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "\uFFFC");
      const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find);
      matches2.forEach((match) => {
        if (match.index === void 0) {
          return;
        }
        const start2 = resolvedFrom + match.index + 1;
        const end2 = start2 + match[0].length;
        const range = {
          from: state.tr.mapping.map(start2),
          to: state.tr.mapping.map(end2)
        };
        const handler = rule.handler({
          state,
          range,
          match,
          commands: commands2,
          chain,
          can
        });
        handlers2.push(handler);
      });
    });
    const success = handlers2.every((handler) => handler !== null);
    return success;
  }
  function pasteRulesPlugin(props) {
    const { editor, rules } = props;
    let dragSourceElement = null;
    let isPastedFromProseMirror = false;
    let isDroppedFromProseMirror = false;
    const plugins = rules.map((rule) => {
      return new Plugin({
        // we register a global drag handler to track the current drag source element
        view(view) {
          const handleDragstart = (event) => {
            var _a;
            dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;
          };
          window.addEventListener("dragstart", handleDragstart);
          return {
            destroy() {
              window.removeEventListener("dragstart", handleDragstart);
            }
          };
        },
        props: {
          handleDOMEvents: {
            drop: (view) => {
              isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
              return false;
            },
            paste: (view, event) => {
              var _a;
              const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
              isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
              return false;
            }
          }
        },
        appendTransaction: (transactions, oldState, state) => {
          const transaction = transactions[0];
          const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
          const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
          if (!isPaste && !isDrop) {
            return;
          }
          const from2 = oldState.doc.content.findDiffStart(state.doc.content);
          const to = oldState.doc.content.findDiffEnd(state.doc.content);
          if (!isNumber(from2) || !to || from2 === to.b) {
            return;
          }
          const tr = state.tr;
          const chainableState = createChainableState({
            state,
            transaction: tr
          });
          const handler = run({
            editor,
            state: chainableState,
            from: Math.max(from2 - 1, 0),
            to: to.b - 1,
            rule
          });
          if (!handler || !tr.steps.length) {
            return;
          }
          return tr;
        }
      });
    });
    return plugins;
  }
  function findDuplicates(items) {
    const filtered = items.filter((el, index) => items.indexOf(el) !== index);
    return [...new Set(filtered)];
  }
  var ExtensionManager = class _ExtensionManager {
    constructor(extensions2, editor) {
      this.splittableMarks = [];
      this.editor = editor;
      this.extensions = _ExtensionManager.resolve(extensions2);
      this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
      this.extensions.forEach((extension) => {
        var _a;
        this.editor.extensionStorage[extension.name] = extension.storage;
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor: this.editor,
          type: getSchemaTypeByName(extension.name, this.schema)
        };
        if (extension.type === "mark") {
          const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a !== void 0 ? _a : true;
          if (keepOnSplit) {
            this.splittableMarks.push(extension.name);
          }
        }
        const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
        if (onBeforeCreate) {
          this.editor.on("beforeCreate", onBeforeCreate);
        }
        const onCreate2 = getExtensionField(extension, "onCreate", context);
        if (onCreate2) {
          this.editor.on("create", onCreate2);
        }
        const onUpdate = getExtensionField(extension, "onUpdate", context);
        if (onUpdate) {
          this.editor.on("update", onUpdate);
        }
        const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
        if (onSelectionUpdate) {
          this.editor.on("selectionUpdate", onSelectionUpdate);
        }
        const onTransaction = getExtensionField(extension, "onTransaction", context);
        if (onTransaction) {
          this.editor.on("transaction", onTransaction);
        }
        const onFocus = getExtensionField(extension, "onFocus", context);
        if (onFocus) {
          this.editor.on("focus", onFocus);
        }
        const onBlur = getExtensionField(extension, "onBlur", context);
        if (onBlur) {
          this.editor.on("blur", onBlur);
        }
        const onDestroy2 = getExtensionField(extension, "onDestroy", context);
        if (onDestroy2) {
          this.editor.on("destroy", onDestroy2);
        }
      });
    }
    static resolve(extensions2) {
      const resolvedExtensions = _ExtensionManager.sort(_ExtensionManager.flatten(extensions2));
      const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
      if (duplicatedNames.length) {
        console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
      }
      return resolvedExtensions;
    }
    static flatten(extensions2) {
      return extensions2.map((extension) => {
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage
        };
        const addExtensions = getExtensionField(extension, "addExtensions", context);
        if (addExtensions) {
          return [extension, ...this.flatten(addExtensions())];
        }
        return extension;
      }).flat(10);
    }
    static sort(extensions2) {
      const defaultPriority = 100;
      return extensions2.sort((a, b) => {
        const priorityA = getExtensionField(a, "priority") || defaultPriority;
        const priorityB = getExtensionField(b, "priority") || defaultPriority;
        if (priorityA > priorityB) {
          return -1;
        }
        if (priorityA < priorityB) {
          return 1;
        }
        return 0;
      });
    }
    get commands() {
      return this.extensions.reduce((commands2, extension) => {
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor: this.editor,
          type: getSchemaTypeByName(extension.name, this.schema)
        };
        const addCommands = getExtensionField(extension, "addCommands", context);
        if (!addCommands) {
          return commands2;
        }
        return {
          ...commands2,
          ...addCommands()
        };
      }, {});
    }
    get plugins() {
      const { editor } = this;
      const extensions2 = _ExtensionManager.sort([...this.extensions].reverse());
      const inputRules = [];
      const pasteRules = [];
      const allPlugins = extensions2.map((extension) => {
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor,
          type: getSchemaTypeByName(extension.name, this.schema)
        };
        const plugins = [];
        const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
        let defaultBindings = {};
        if (extension.type === "mark" && extension.config.exitable) {
          defaultBindings.ArrowRight = () => Mark2.handleExit({ editor, mark: extension });
        }
        if (addKeyboardShortcuts) {
          const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
            return [shortcut, () => method({ editor })];
          }));
          defaultBindings = { ...defaultBindings, ...bindings };
        }
        const keyMapPlugin = keymap(defaultBindings);
        plugins.push(keyMapPlugin);
        const addInputRules = getExtensionField(extension, "addInputRules", context);
        if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
          inputRules.push(...addInputRules());
        }
        const addPasteRules = getExtensionField(extension, "addPasteRules", context);
        if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
          pasteRules.push(...addPasteRules());
        }
        const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
        if (addProseMirrorPlugins) {
          const proseMirrorPlugins = addProseMirrorPlugins();
          plugins.push(...proseMirrorPlugins);
        }
        return plugins;
      }).flat();
      return [
        inputRulesPlugin({
          editor,
          rules: inputRules
        }),
        ...pasteRulesPlugin({
          editor,
          rules: pasteRules
        }),
        ...allPlugins
      ];
    }
    get attributes() {
      return getAttributesFromExtensions(this.extensions);
    }
    get nodeViews() {
      const { editor } = this;
      const { nodeExtensions } = splitExtensions(this.extensions);
      return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor,
          type: getNodeType(extension.name, this.schema)
        };
        const addNodeView = getExtensionField(extension, "addNodeView", context);
        if (!addNodeView) {
          return [];
        }
        const nodeview = (node, view, getPos, decorations) => {
          const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
          return addNodeView()({
            editor,
            node,
            getPos,
            decorations,
            HTMLAttributes,
            extension
          });
        };
        return [extension.name, nodeview];
      }));
    }
  };
  function getType(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
  }
  function isPlainObject(value) {
    if (getType(value) !== "Object") {
      return false;
    }
    return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
  }
  function mergeDeep(target, source) {
    const output = { ...target };
    if (isPlainObject(target) && isPlainObject(source)) {
      Object.keys(source).forEach((key) => {
        if (isPlainObject(source[key])) {
          if (!(key in target)) {
            Object.assign(output, { [key]: source[key] });
          } else {
            output[key] = mergeDeep(target[key], source[key]);
          }
        } else {
          Object.assign(output, { [key]: source[key] });
        }
      });
    }
    return output;
  }
  var Extension = class _Extension {
    constructor(config2 = {}) {
      this.type = "extension";
      this.name = "extension";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = {
        ...this.config,
        ...config2
      };
      this.name = this.config.name;
      if (config2.defaultOptions) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(config2 = {}) {
      return new _Extension(config2);
    }
    configure(options = {}) {
      const extension = this.extend();
      extension.options = mergeDeep(this.options, options);
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
    extend(extendedConfig = {}) {
      const extension = new _Extension(extendedConfig);
      extension.parent = this;
      this.child = extension;
      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
      if (extendedConfig.defaultOptions) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
      }
      extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
        name: extension.name
      }));
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
  };
  function getTextBetween(startNode, range, options) {
    const { from: from2, to } = range;
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    let text = "";
    let separated = true;
    startNode.nodesBetween(from2, to, (node, pos, parent, index) => {
      var _a;
      const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
      if (textSerializer) {
        if (node.isBlock && !separated) {
          text += blockSeparator;
          separated = true;
        }
        if (parent) {
          text += textSerializer({
            node,
            pos,
            parent,
            index,
            range
          });
        }
      } else if (node.isText) {
        text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from2, pos) - pos, to - pos);
        separated = false;
      } else if (node.isBlock && !separated) {
        text += blockSeparator;
        separated = true;
      }
    });
    return text;
  }
  function getTextSerializersFromSchema(schema) {
    return Object.fromEntries(Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));
  }
  var ClipboardTextSerializer = Extension.create({
    name: "clipboardTextSerializer",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("clipboardTextSerializer"),
          props: {
            clipboardTextSerializer: () => {
              const { editor } = this;
              const { state, schema } = editor;
              const { doc: doc3, selection } = state;
              const { ranges } = selection;
              const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
              const to = Math.max(...ranges.map((range2) => range2.$to.pos));
              const textSerializers = getTextSerializersFromSchema(schema);
              const range = { from: from2, to };
              return getTextBetween(doc3, range, {
                textSerializers
              });
            }
          }
        })
      ];
    }
  });
  var blur = () => ({ editor, view }) => {
    requestAnimationFrame(() => {
      var _a;
      if (!editor.isDestroyed) {
        view.dom.blur();
        (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
      }
    });
    return true;
  };
  var clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
    return commands2.setContent("", emitUpdate);
  };
  var clearNodes = () => ({ state, tr, dispatch }) => {
    const { selection } = tr;
    const { ranges } = selection;
    if (!dispatch) {
      return true;
    }
    ranges.forEach(({ $from, $to }) => {
      state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
        if (node.type.isText) {
          return;
        }
        const { doc: doc3, mapping } = tr;
        const $mappedFrom = doc3.resolve(mapping.map(pos));
        const $mappedTo = doc3.resolve(mapping.map(pos + node.nodeSize));
        const nodeRange = $mappedFrom.blockRange($mappedTo);
        if (!nodeRange) {
          return;
        }
        const targetLiftDepth = liftTarget(nodeRange);
        if (node.type.isTextblock) {
          const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
          tr.setNodeMarkup(nodeRange.start, defaultType);
        }
        if (targetLiftDepth || targetLiftDepth === 0) {
          tr.lift(nodeRange, targetLiftDepth);
        }
      });
    });
    return true;
  };
  var command = (fn2) => (props) => {
    return fn2(props);
  };
  var createParagraphNear2 = () => ({ state, dispatch }) => {
    return createParagraphNear(state, dispatch);
  };
  var cut = (originRange, targetPos) => ({ editor, tr }) => {
    const { state } = editor;
    const contentSlice = state.doc.slice(originRange.from, originRange.to);
    tr.deleteRange(originRange.from, originRange.to);
    const newPos = tr.mapping.map(targetPos);
    tr.insert(newPos, contentSlice.content);
    tr.setSelection(new TextSelection(tr.doc.resolve(newPos - 1)));
    return true;
  };
  var deleteCurrentNode = () => ({ tr, dispatch }) => {
    const { selection } = tr;
    const currentNode = selection.$anchor.node();
    if (currentNode.content.size > 0) {
      return false;
    }
    const $pos = tr.selection.$anchor;
    for (let depth = $pos.depth; depth > 0; depth -= 1) {
      const node = $pos.node(depth);
      if (node.type === currentNode.type) {
        if (dispatch) {
          const from2 = $pos.before(depth);
          const to = $pos.after(depth);
          tr.delete(from2, to).scrollIntoView();
        }
        return true;
      }
    }
    return false;
  };
  var deleteNode = (typeOrName) => ({ tr, state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    const $pos = tr.selection.$anchor;
    for (let depth = $pos.depth; depth > 0; depth -= 1) {
      const node = $pos.node(depth);
      if (node.type === type) {
        if (dispatch) {
          const from2 = $pos.before(depth);
          const to = $pos.after(depth);
          tr.delete(from2, to).scrollIntoView();
        }
        return true;
      }
    }
    return false;
  };
  var deleteRange2 = (range) => ({ tr, dispatch }) => {
    const { from: from2, to } = range;
    if (dispatch) {
      tr.delete(from2, to);
    }
    return true;
  };
  var deleteSelection2 = () => ({ state, dispatch }) => {
    return deleteSelection(state, dispatch);
  };
  var enter = () => ({ commands: commands2 }) => {
    return commands2.keyboardShortcut("Enter");
  };
  var exitCode2 = () => ({ state, dispatch }) => {
    return exitCode(state, dispatch);
  };
  function objectIncludes(object1, object2, options = { strict: true }) {
    const keys2 = Object.keys(object2);
    if (!keys2.length) {
      return true;
    }
    return keys2.every((key) => {
      if (options.strict) {
        return object2[key] === object1[key];
      }
      if (isRegExp(object2[key])) {
        return object2[key].test(object1[key]);
      }
      return object2[key] === object1[key];
    });
  }
  function findMarkInSet(marks, type, attributes = {}) {
    return marks.find((item) => {
      return item.type === type && objectIncludes(item.attrs, attributes);
    });
  }
  function isMarkInSet(marks, type, attributes = {}) {
    return !!findMarkInSet(marks, type, attributes);
  }
  function getMarkRange($pos, type, attributes = {}) {
    if (!$pos || !type) {
      return;
    }
    let start2 = $pos.parent.childAfter($pos.parentOffset);
    if ($pos.parentOffset === start2.offset && start2.offset !== 0) {
      start2 = $pos.parent.childBefore($pos.parentOffset);
    }
    if (!start2.node) {
      return;
    }
    const mark = findMarkInSet([...start2.node.marks], type, attributes);
    if (!mark) {
      return;
    }
    let startIndex = start2.index;
    let startPos = $pos.start() + start2.offset;
    let endIndex = startIndex + 1;
    let endPos = startPos + start2.node.nodeSize;
    findMarkInSet([...start2.node.marks], type, attributes);
    while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
      startIndex -= 1;
      startPos -= $pos.parent.child(startIndex).nodeSize;
    }
    while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
      endPos += $pos.parent.child(endIndex).nodeSize;
      endIndex += 1;
    }
    return {
      from: startPos,
      to: endPos
    };
  }
  function getMarkType(nameOrType, schema) {
    if (typeof nameOrType === "string") {
      if (!schema.marks[nameOrType]) {
        throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
      }
      return schema.marks[nameOrType];
    }
    return nameOrType;
  }
  var extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
    const type = getMarkType(typeOrName, state.schema);
    const { doc: doc3, selection } = tr;
    const { $from, from: from2, to } = selection;
    if (dispatch) {
      const range = getMarkRange($from, type, attributes);
      if (range && range.from <= from2 && range.to >= to) {
        const newSelection = TextSelection.create(doc3, range.from, range.to);
        tr.setSelection(newSelection);
      }
    }
    return true;
  };
  var first = (commands2) => (props) => {
    const items = typeof commands2 === "function" ? commands2(props) : commands2;
    for (let i = 0; i < items.length; i += 1) {
      if (items[i](props)) {
        return true;
      }
    }
    return false;
  };
  function isTextSelection(value) {
    return value instanceof TextSelection;
  }
  function minMax(value = 0, min2 = 0, max2 = 0) {
    return Math.min(Math.max(value, min2), max2);
  }
  function resolveFocusPosition(doc3, position = null) {
    if (!position) {
      return null;
    }
    const selectionAtStart = Selection.atStart(doc3);
    const selectionAtEnd = Selection.atEnd(doc3);
    if (position === "start" || position === true) {
      return selectionAtStart;
    }
    if (position === "end") {
      return selectionAtEnd;
    }
    const minPos = selectionAtStart.from;
    const maxPos = selectionAtEnd.to;
    if (position === "all") {
      return TextSelection.create(doc3, minMax(0, minPos, maxPos), minMax(doc3.content.size, minPos, maxPos));
    }
    return TextSelection.create(doc3, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
  }
  function isiOS() {
    return [
      "iPad Simulator",
      "iPhone Simulator",
      "iPod Simulator",
      "iPad",
      "iPhone",
      "iPod"
    ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
  }
  var focus = (position = null, options = {}) => ({ editor, view, tr, dispatch }) => {
    options = {
      scrollIntoView: true,
      ...options
    };
    const delayedFocus = () => {
      if (isiOS()) {
        view.dom.focus();
      }
      requestAnimationFrame(() => {
        if (!editor.isDestroyed) {
          view.focus();
          if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
            editor.commands.scrollIntoView();
          }
        }
      });
    };
    if (view.hasFocus() && position === null || position === false) {
      return true;
    }
    if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
      delayedFocus();
      return true;
    }
    const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;
    const isSameSelection = editor.state.selection.eq(selection);
    if (dispatch) {
      if (!isSameSelection) {
        tr.setSelection(selection);
      }
      if (isSameSelection && tr.storedMarks) {
        tr.setStoredMarks(tr.storedMarks);
      }
      delayedFocus();
    }
    return true;
  };
  var forEach = (items, fn2) => (props) => {
    return items.every((item, index) => fn2(item, { ...props, index }));
  };
  var insertContent = (value, options) => ({ tr, commands: commands2 }) => {
    return commands2.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);
  };
  function elementFromString(value) {
    const wrappedValue = `<body>${value}</body>`;
    return new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  }
  function createNodeFromContent(content, schema, options) {
    options = {
      slice: true,
      parseOptions: {},
      ...options
    };
    if (typeof content === "object" && content !== null) {
      try {
        if (Array.isArray(content) && content.length > 0) {
          return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
        }
        return schema.nodeFromJSON(content);
      } catch (error) {
        console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
        return createNodeFromContent("", schema, options);
      }
    }
    if (typeof content === "string") {
      const parser = DOMParser.fromSchema(schema);
      return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);
    }
    return createNodeFromContent("", schema, options);
  }
  function selectionToInsertionEnd2(tr, startLen, bias) {
    const last = tr.steps.length - 1;
    if (last < startLen) {
      return;
    }
    const step = tr.steps[last];
    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
      return;
    }
    const map2 = tr.mapping.maps[last];
    let end2 = 0;
    map2.forEach((_from, _to, _newFrom, newTo) => {
      if (end2 === 0) {
        end2 = newTo;
      }
    });
    tr.setSelection(Selection.near(tr.doc.resolve(end2), bias));
  }
  var isFragment = (nodeOrFragment) => {
    return nodeOrFragment.toString().startsWith("<");
  };
  var insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {
    if (dispatch) {
      options = {
        parseOptions: {},
        updateSelection: true,
        ...options
      };
      const content = createNodeFromContent(value, editor.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...options.parseOptions
        }
      });
      if (content.toString() === "<>") {
        return true;
      }
      let { from: from2, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
      let isOnlyTextContent = true;
      let isOnlyBlockContent = true;
      const nodes = isFragment(content) ? content : [content];
      nodes.forEach((node) => {
        node.check();
        isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
        isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
      });
      if (from2 === to && isOnlyBlockContent) {
        const { parent } = tr.doc.resolve(from2);
        const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
        if (isEmptyTextBlock) {
          from2 -= 1;
          to += 1;
        }
      }
      if (isOnlyTextContent) {
        if (Array.isArray(value)) {
          tr.insertText(value.map((v) => v.text || "").join(""), from2, to);
        } else if (typeof value === "object" && !!value && !!value.text) {
          tr.insertText(value.text, from2, to);
        } else {
          tr.insertText(value, from2, to);
        }
      } else {
        tr.replaceWith(from2, to, content);
      }
      if (options.updateSelection) {
        selectionToInsertionEnd2(tr, tr.steps.length - 1, -1);
      }
    }
    return true;
  };
  var joinUp2 = () => ({ state, dispatch }) => {
    return joinUp(state, dispatch);
  };
  var joinDown2 = () => ({ state, dispatch }) => {
    return joinDown(state, dispatch);
  };
  var joinBackward2 = () => ({ state, dispatch }) => {
    return joinBackward(state, dispatch);
  };
  var joinForward2 = () => ({ state, dispatch }) => {
    return joinForward(state, dispatch);
  };
  var joinItemBackward = () => ({ tr, state, dispatch }) => {
    try {
      const point = joinPoint(state.doc, state.selection.$from.pos, -1);
      if (point === null || point === void 0) {
        return false;
      }
      tr.join(point, 2);
      if (dispatch) {
        dispatch(tr);
      }
      return true;
    } catch {
      return false;
    }
  };
  var joinItemForward = () => ({ state, dispatch, tr }) => {
    try {
      const point = joinPoint(state.doc, state.selection.$from.pos, 1);
      if (point === null || point === void 0) {
        return false;
      }
      tr.join(point, 2);
      if (dispatch) {
        dispatch(tr);
      }
      return true;
    } catch (e) {
      return false;
    }
  };
  function isMacOS() {
    return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
  }
  function normalizeKeyName2(name) {
    const parts = name.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result === "Space") {
      result = " ";
    }
    let alt;
    let ctrl;
    let shift2;
    let meta;
    for (let i = 0; i < parts.length - 1; i += 1) {
      const mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) {
        meta = true;
      } else if (/^a(lt)?$/i.test(mod)) {
        alt = true;
      } else if (/^(c|ctrl|control)$/i.test(mod)) {
        ctrl = true;
      } else if (/^s(hift)?$/i.test(mod)) {
        shift2 = true;
      } else if (/^mod$/i.test(mod)) {
        if (isiOS() || isMacOS()) {
          meta = true;
        } else {
          ctrl = true;
        }
      } else {
        throw new Error(`Unrecognized modifier name: ${mod}`);
      }
    }
    if (alt) {
      result = `Alt-${result}`;
    }
    if (ctrl) {
      result = `Ctrl-${result}`;
    }
    if (meta) {
      result = `Meta-${result}`;
    }
    if (shift2) {
      result = `Shift-${result}`;
    }
    return result;
  }
  var keyboardShortcut = (name) => ({ editor, view, tr, dispatch }) => {
    const keys2 = normalizeKeyName2(name).split(/-(?!$)/);
    const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
    const event = new KeyboardEvent("keydown", {
      key: key === "Space" ? " " : key,
      altKey: keys2.includes("Alt"),
      ctrlKey: keys2.includes("Ctrl"),
      metaKey: keys2.includes("Meta"),
      shiftKey: keys2.includes("Shift"),
      bubbles: true,
      cancelable: true
    });
    const capturedTransaction = editor.captureTransaction(() => {
      view.someProp("handleKeyDown", (f) => f(view, event));
    });
    capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
      const newStep = step.map(tr.mapping);
      if (newStep && dispatch) {
        tr.maybeStep(newStep);
      }
    });
    return true;
  };
  function isNodeActive(state, typeOrName, attributes = {}) {
    const { from: from2, to, empty: empty2 } = state.selection;
    const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
    const nodeRanges = [];
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (node.isText) {
        return;
      }
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      nodeRanges.push({
        node,
        from: relativeFrom,
        to: relativeTo
      });
    });
    const selectionRange = to - from2;
    const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
      if (!type) {
        return true;
      }
      return type.name === nodeRange.node.type.name;
    }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
    if (empty2) {
      return !!matchedNodeRanges.length;
    }
    const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
    return range >= selectionRange;
  }
  var lift3 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    const isActive2 = isNodeActive(state, type, attributes);
    if (!isActive2) {
      return false;
    }
    return lift2(state, dispatch);
  };
  var liftEmptyBlock2 = () => ({ state, dispatch }) => {
    return liftEmptyBlock(state, dispatch);
  };
  var liftListItem2 = (typeOrName) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return liftListItem(type)(state, dispatch);
  };
  var newlineInCode2 = () => ({ state, dispatch }) => {
    return newlineInCode(state, dispatch);
  };
  function getSchemaTypeNameByName(name, schema) {
    if (schema.nodes[name]) {
      return "node";
    }
    if (schema.marks[name]) {
      return "mark";
    }
    return null;
  }
  function deleteProps(obj, propOrProps) {
    const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
    return Object.keys(obj).reduce((newObj, prop) => {
      if (!props.includes(prop)) {
        newObj[prop] = obj[prop];
      }
      return newObj;
    }, {});
  }
  var resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {
    let nodeType = null;
    let markType = null;
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (!schemaType) {
      return false;
    }
    if (schemaType === "node") {
      nodeType = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === "mark") {
      markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch) {
      tr.selection.ranges.forEach((range) => {
        state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
          if (nodeType && nodeType === node.type) {
            tr.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
          }
          if (markType && node.marks.length) {
            node.marks.forEach((mark) => {
              if (markType === mark.type) {
                tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
              }
            });
          }
        });
      });
    }
    return true;
  };
  var scrollIntoView = () => ({ tr, dispatch }) => {
    if (dispatch) {
      tr.scrollIntoView();
    }
    return true;
  };
  var selectAll2 = () => ({ tr, commands: commands2 }) => {
    return commands2.setTextSelection({
      from: 0,
      to: tr.doc.content.size
    });
  };
  var selectNodeBackward2 = () => ({ state, dispatch }) => {
    return selectNodeBackward(state, dispatch);
  };
  var selectNodeForward2 = () => ({ state, dispatch }) => {
    return selectNodeForward(state, dispatch);
  };
  var selectParentNode2 = () => ({ state, dispatch }) => {
    return selectParentNode(state, dispatch);
  };
  var selectTextblockEnd2 = () => ({ state, dispatch }) => {
    return selectTextblockEnd(state, dispatch);
  };
  var selectTextblockStart2 = () => ({ state, dispatch }) => {
    return selectTextblockStart(state, dispatch);
  };
  function createDocument(content, schema, parseOptions = {}) {
    return createNodeFromContent(content, schema, { slice: false, parseOptions });
  }
  var setContent = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch }) => {
    const { doc: doc3 } = tr;
    const document2 = createDocument(content, editor.schema, parseOptions);
    if (dispatch) {
      tr.replaceWith(0, doc3.content.size, document2).setMeta("preventUpdate", !emitUpdate);
    }
    return true;
  };
  function getMarkAttributes(state, typeOrName) {
    const type = getMarkType(typeOrName, state.schema);
    const { from: from2, to, empty: empty2 } = state.selection;
    const marks = [];
    if (empty2) {
      if (state.storedMarks) {
        marks.push(...state.storedMarks);
      }
      marks.push(...state.selection.$head.marks());
    } else {
      state.doc.nodesBetween(from2, to, (node) => {
        marks.push(...node.marks);
      });
    }
    const mark = marks.find((markItem) => markItem.type.name === type.name);
    if (!mark) {
      return {};
    }
    return { ...mark.attrs };
  }
  function defaultBlockAt2(match) {
    for (let i = 0; i < match.edgeCount; i += 1) {
      const { type } = match.edge(i);
      if (type.isTextblock && !type.hasRequiredAttrs()) {
        return type;
      }
    }
    return null;
  }
  function findParentNodeClosestToPos($pos, predicate) {
    for (let i = $pos.depth; i > 0; i -= 1) {
      const node = $pos.node(i);
      if (predicate(node)) {
        return {
          pos: i > 0 ? $pos.before(i) : 0,
          start: $pos.start(i),
          depth: i,
          node
        };
      }
    }
  }
  function findParentNode(predicate) {
    return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
  }
  function getHTMLFromFragment(fragment, schema) {
    const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
    const temporaryDocument = document.implementation.createHTMLDocument();
    const container = temporaryDocument.createElement("div");
    container.appendChild(documentFragment);
    return container.innerHTML;
  }
  function getText(node, options) {
    const range = {
      from: 0,
      to: node.content.size
    };
    return getTextBetween(node, range, options);
  }
  function getNodeAttributes(state, typeOrName) {
    const type = getNodeType(typeOrName, state.schema);
    const { from: from2, to } = state.selection;
    const nodes = [];
    state.doc.nodesBetween(from2, to, (node2) => {
      nodes.push(node2);
    });
    const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
    if (!node) {
      return {};
    }
    return { ...node.attrs };
  }
  function getAttributes(state, typeOrName) {
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (schemaType === "node") {
      return getNodeAttributes(state, typeOrName);
    }
    if (schemaType === "mark") {
      return getMarkAttributes(state, typeOrName);
    }
    return {};
  }
  function getMarksBetween(from2, to, doc3) {
    const marks = [];
    if (from2 === to) {
      doc3.resolve(from2).marks().forEach((mark) => {
        const $pos = doc3.resolve(from2 - 1);
        const range = getMarkRange($pos, mark.type);
        if (!range) {
          return;
        }
        marks.push({
          mark,
          ...range
        });
      });
    } else {
      doc3.nodesBetween(from2, to, (node, pos) => {
        marks.push(...node.marks.map((mark) => ({
          from: pos,
          to: pos + node.nodeSize,
          mark
        })));
      });
    }
    return marks;
  }
  function getSplittedAttributes(extensionAttributes, typeName, attributes) {
    return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
      const extensionAttribute = extensionAttributes.find((item) => {
        return item.type === typeName && item.name === name;
      });
      if (!extensionAttribute) {
        return false;
      }
      return extensionAttribute.attribute.keepOnSplit;
    }));
  }
  function isMarkActive(state, typeOrName, attributes = {}) {
    const { empty: empty2, ranges } = state.selection;
    const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
    if (empty2) {
      return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
        if (!type) {
          return true;
        }
        return type.name === mark.type.name;
      }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
    }
    let selectionRange = 0;
    const markRanges = [];
    ranges.forEach(({ $from, $to }) => {
      const from2 = $from.pos;
      const to = $to.pos;
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (!node.isText && !node.marks.length) {
          return;
        }
        const relativeFrom = Math.max(from2, pos);
        const relativeTo = Math.min(to, pos + node.nodeSize);
        const range2 = relativeTo - relativeFrom;
        selectionRange += range2;
        markRanges.push(...node.marks.map((mark) => ({
          mark,
          from: relativeFrom,
          to: relativeTo
        })));
      });
    });
    if (selectionRange === 0) {
      return false;
    }
    const matchedRange = markRanges.filter((markRange) => {
      if (!type) {
        return true;
      }
      return type.name === markRange.mark.type.name;
    }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
    const excludedRange = markRanges.filter((markRange) => {
      if (!type) {
        return true;
      }
      return markRange.mark.type !== type && markRange.mark.type.excludes(type);
    }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
    const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
    return range >= selectionRange;
  }
  function isActive(state, name, attributes = {}) {
    if (!name) {
      return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
    }
    const schemaType = getSchemaTypeNameByName(name, state.schema);
    if (schemaType === "node") {
      return isNodeActive(state, name, attributes);
    }
    if (schemaType === "mark") {
      return isMarkActive(state, name, attributes);
    }
    return false;
  }
  function isList(name, extensions2) {
    const { nodeExtensions } = splitExtensions(extensions2);
    const extension = nodeExtensions.find((item) => item.name === name);
    if (!extension) {
      return false;
    }
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const group = callOrReturn(getExtensionField(extension, "group", context));
    if (typeof group !== "string") {
      return false;
    }
    return group.split(" ").includes("list");
  }
  function isNodeEmpty(node) {
    var _a;
    const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();
    const content = node.toJSON();
    return JSON.stringify(defaultContent) === JSON.stringify(content);
  }
  function isNodeSelection(value) {
    return value instanceof NodeSelection;
  }
  function posToDOMRect(view, from2, to) {
    const minPos = 0;
    const maxPos = view.state.doc.content.size;
    const resolvedFrom = minMax(from2, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const start2 = view.coordsAtPos(resolvedFrom);
    const end2 = view.coordsAtPos(resolvedEnd, -1);
    const top2 = Math.min(start2.top, end2.top);
    const bottom2 = Math.max(start2.bottom, end2.bottom);
    const left2 = Math.min(start2.left, end2.left);
    const right2 = Math.max(start2.right, end2.right);
    const width = right2 - left2;
    const height = bottom2 - top2;
    const x = left2;
    const y = top2;
    const data = {
      top: top2,
      bottom: bottom2,
      left: left2,
      right: right2,
      width,
      height,
      x,
      y
    };
    return {
      ...data,
      toJSON: () => data
    };
  }
  function canSetMark(state, tr, newMarkType) {
    var _a;
    const { selection } = tr;
    let cursor = null;
    if (isTextSelection(selection)) {
      cursor = selection.$cursor;
    }
    if (cursor) {
      const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();
      return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
    }
    const { ranges } = selection;
    return ranges.some(({ $from, $to }) => {
      let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
      state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
        if (someNodeSupportsMark) {
          return false;
        }
        if (node.isInline) {
          const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
          const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
          someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
        }
        return !someNodeSupportsMark;
      });
      return someNodeSupportsMark;
    });
  }
  var setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
    const { selection } = tr;
    const { empty: empty2, ranges } = selection;
    const type = getMarkType(typeOrName, state.schema);
    if (dispatch) {
      if (empty2) {
        const oldAttributes = getMarkAttributes(state, type);
        tr.addStoredMark(type.create({
          ...oldAttributes,
          ...attributes
        }));
      } else {
        ranges.forEach((range) => {
          const from2 = range.$from.pos;
          const to = range.$to.pos;
          state.doc.nodesBetween(from2, to, (node, pos) => {
            const trimmedFrom = Math.max(pos, from2);
            const trimmedTo = Math.min(pos + node.nodeSize, to);
            const someHasMark = node.marks.find((mark) => mark.type === type);
            if (someHasMark) {
              node.marks.forEach((mark) => {
                if (type === mark.type) {
                  tr.addMark(trimmedFrom, trimmedTo, type.create({
                    ...mark.attrs,
                    ...attributes
                  }));
                }
              });
            } else {
              tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
            }
          });
        });
      }
    }
    return canSetMark(state, tr, type);
  };
  var setMeta = (key, value) => ({ tr }) => {
    tr.setMeta(key, value);
    return true;
  };
  var setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
    const type = getNodeType(typeOrName, state.schema);
    if (!type.isTextblock) {
      console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
      return false;
    }
    return chain().command(({ commands: commands2 }) => {
      const canSetBlock = setBlockType2(type, attributes)(state);
      if (canSetBlock) {
        return true;
      }
      return commands2.clearNodes();
    }).command(({ state: updatedState }) => {
      return setBlockType2(type, attributes)(updatedState, dispatch);
    }).run();
  };
  var setNodeSelection = (position) => ({ tr, dispatch }) => {
    if (dispatch) {
      const { doc: doc3 } = tr;
      const from2 = minMax(position, 0, doc3.content.size);
      const selection = NodeSelection.create(doc3, from2);
      tr.setSelection(selection);
    }
    return true;
  };
  var setTextSelection = (position) => ({ tr, dispatch }) => {
    if (dispatch) {
      const { doc: doc3 } = tr;
      const { from: from2, to } = typeof position === "number" ? { from: position, to: position } : position;
      const minPos = TextSelection.atStart(doc3).from;
      const maxPos = TextSelection.atEnd(doc3).to;
      const resolvedFrom = minMax(from2, minPos, maxPos);
      const resolvedEnd = minMax(to, minPos, maxPos);
      const selection = TextSelection.create(doc3, resolvedFrom, resolvedEnd);
      tr.setSelection(selection);
    }
    return true;
  };
  var sinkListItem2 = (typeOrName) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return sinkListItem(type)(state, dispatch);
  };
  function ensureMarks(state, splittableMarks) {
    const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
    if (marks) {
      const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
      state.tr.ensureMarks(filteredMarks);
    }
  }
  var splitBlock2 = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor }) => {
    const { selection, doc: doc3 } = tr;
    const { $from, $to } = selection;
    const extensionAttributes = editor.extensionManager.attributes;
    const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
    if (selection instanceof NodeSelection && selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(doc3, $from.pos)) {
        return false;
      }
      if (dispatch) {
        if (keepMarks) {
          ensureMarks(state, editor.extensionManager.splittableMarks);
        }
        tr.split($from.pos).scrollIntoView();
      }
      return true;
    }
    if (!$from.parent.isBlock) {
      return false;
    }
    if (dispatch) {
      const atEnd = $to.parentOffset === $to.parent.content.size;
      if (selection instanceof TextSelection) {
        tr.deleteSelection();
      }
      const deflt = $from.depth === 0 ? void 0 : defaultBlockAt2($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      let types = atEnd && deflt ? [
        {
          type: deflt,
          attrs: newAttributes
        }
      ] : void 0;
      let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
      if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
        can = true;
        types = deflt ? [
          {
            type: deflt,
            attrs: newAttributes
          }
        ] : void 0;
      }
      if (can) {
        tr.split(tr.mapping.map($from.pos), 1, types);
        if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
          const first2 = tr.mapping.map($from.before());
          const $first = tr.doc.resolve(first2);
          if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
            tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
          }
        }
      }
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr.scrollIntoView();
    }
    return true;
  };
  var splitListItem = (typeOrName) => ({ tr, state, dispatch, editor }) => {
    var _a;
    const type = getNodeType(typeOrName, state.schema);
    const { $from, $to } = state.selection;
    const node = state.selection.node;
    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
      return false;
    }
    const grandParent = $from.node(-1);
    if (grandParent.type !== type) {
      return false;
    }
    const extensionAttributes = editor.extensionManager.attributes;
    if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
      if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
        return false;
      }
      if (dispatch) {
        let wrap2 = Fragment.empty;
        const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
        for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
          wrap2 = Fragment.from($from.node(d).copy(wrap2));
        }
        const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
        const newNextTypeAttributes2 = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
        const nextType2 = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
        wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
        const start2 = $from.before($from.depth - (depthBefore - 1));
        tr.replace(start2, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
        let sel = -1;
        tr.doc.nodesBetween(start2, tr.doc.content.size, (n, pos) => {
          if (sel > -1) {
            return false;
          }
          if (n.isTextblock && n.content.size === 0) {
            sel = pos + 1;
          }
        });
        if (sel > -1) {
          tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));
        }
        tr.scrollIntoView();
      }
      return true;
    }
    const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);
    const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
    tr.delete($from.pos, $to.pos);
    const types = nextType ? [
      { type, attrs: newTypeAttributes },
      { type: nextType, attrs: newNextTypeAttributes }
    ] : [{ type, attrs: newTypeAttributes }];
    if (!canSplit(tr.doc, $from.pos, 2)) {
      return false;
    }
    if (dispatch) {
      const { selection, storedMarks } = state;
      const { splittableMarks } = editor.extensionManager;
      const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
      tr.split($from.pos, 2, types).scrollIntoView();
      if (!marks || !dispatch) {
        return true;
      }
      const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
      tr.ensureMarks(filteredMarks);
    }
    return true;
  };
  var joinListBackwards = (tr, listType) => {
    const list = findParentNode((node) => node.type === listType)(tr.selection);
    if (!list) {
      return true;
    }
    const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
    if (before === void 0) {
      return true;
    }
    const nodeBefore = tr.doc.nodeAt(before);
    const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr.doc, list.pos);
    if (!canJoinBackwards) {
      return true;
    }
    tr.join(list.pos);
    return true;
  };
  var joinListForwards = (tr, listType) => {
    const list = findParentNode((node) => node.type === listType)(tr.selection);
    if (!list) {
      return true;
    }
    const after = tr.doc.resolve(list.start).after(list.depth);
    if (after === void 0) {
      return true;
    }
    const nodeAfter = tr.doc.nodeAt(after);
    const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr.doc, after);
    if (!canJoinForwards) {
      return true;
    }
    tr.join(after);
    return true;
  };
  var toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr, state, dispatch, chain, commands: commands2, can }) => {
    const { extensions: extensions2, splittableMarks } = editor.extensionManager;
    const listType = getNodeType(listTypeOrName, state.schema);
    const itemType = getNodeType(itemTypeOrName, state.schema);
    const { selection, storedMarks } = state;
    const { $from, $to } = selection;
    const range = $from.blockRange($to);
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    if (!range) {
      return false;
    }
    const parentList = findParentNode((node) => isList(node.type.name, extensions2))(selection);
    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
      if (parentList.node.type === listType) {
        return commands2.liftListItem(itemType);
      }
      if (isList(parentList.node.type.name, extensions2) && listType.validContent(parentList.node.content) && dispatch) {
        return chain().command(() => {
          tr.setNodeMarkup(parentList.pos, listType);
          return true;
        }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
      }
    }
    if (!keepMarks || !marks || !dispatch) {
      return chain().command(() => {
        const canWrapInList = can().wrapInList(listType, attributes);
        if (canWrapInList) {
          return true;
        }
        return commands2.clearNodes();
      }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
    }
    return chain().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
      tr.ensureMarks(filteredMarks);
      if (canWrapInList) {
        return true;
      }
      return commands2.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
  };
  var toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands: commands2 }) => {
    const { extendEmptyMarkRange = false } = options;
    const type = getMarkType(typeOrName, state.schema);
    const isActive2 = isMarkActive(state, type, attributes);
    if (isActive2) {
      return commands2.unsetMark(type, { extendEmptyMarkRange });
    }
    return commands2.setMark(type, attributes);
  };
  var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
    const type = getNodeType(typeOrName, state.schema);
    const toggleType = getNodeType(toggleTypeOrName, state.schema);
    const isActive2 = isNodeActive(state, type, attributes);
    if (isActive2) {
      return commands2.setNode(toggleType);
    }
    return commands2.setNode(type, attributes);
  };
  var toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
    const type = getNodeType(typeOrName, state.schema);
    const isActive2 = isNodeActive(state, type, attributes);
    if (isActive2) {
      return commands2.lift(type);
    }
    return commands2.wrapIn(type, attributes);
  };
  var undoInputRule = () => ({ state, dispatch }) => {
    const plugins = state.plugins;
    for (let i = 0; i < plugins.length; i += 1) {
      const plugin = plugins[i];
      let undoable;
      if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
        if (dispatch) {
          const tr = state.tr;
          const toUndo = undoable.transform;
          for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
            tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
          }
          if (undoable.text) {
            const marks = tr.doc.resolve(undoable.from).marks();
            tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
          } else {
            tr.delete(undoable.from, undoable.to);
          }
        }
        return true;
      }
    }
    return false;
  };
  var unsetAllMarks = () => ({ tr, dispatch }) => {
    const { selection } = tr;
    const { empty: empty2, ranges } = selection;
    if (empty2) {
      return true;
    }
    if (dispatch) {
      ranges.forEach((range) => {
        tr.removeMark(range.$from.pos, range.$to.pos);
      });
    }
    return true;
  };
  var unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {
    var _a;
    const { extendEmptyMarkRange = false } = options;
    const { selection } = tr;
    const type = getMarkType(typeOrName, state.schema);
    const { $from, empty: empty2, ranges } = selection;
    if (!dispatch) {
      return true;
    }
    if (empty2 && extendEmptyMarkRange) {
      let { from: from2, to } = selection;
      const attrs = (_a = $from.marks().find((mark) => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;
      const range = getMarkRange($from, type, attrs);
      if (range) {
        from2 = range.from;
        to = range.to;
      }
      tr.removeMark(from2, to, type);
    } else {
      ranges.forEach((range) => {
        tr.removeMark(range.$from.pos, range.$to.pos, type);
      });
    }
    tr.removeStoredMark(type);
    return true;
  };
  var updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
    let nodeType = null;
    let markType = null;
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (!schemaType) {
      return false;
    }
    if (schemaType === "node") {
      nodeType = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === "mark") {
      markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch) {
      tr.selection.ranges.forEach((range) => {
        const from2 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (nodeType && nodeType === node.type) {
            tr.setNodeMarkup(pos, void 0, {
              ...node.attrs,
              ...attributes
            });
          }
          if (markType && node.marks.length) {
            node.marks.forEach((mark) => {
              if (markType === mark.type) {
                const trimmedFrom = Math.max(pos, from2);
                const trimmedTo = Math.min(pos + node.nodeSize, to);
                tr.addMark(trimmedFrom, trimmedTo, markType.create({
                  ...mark.attrs,
                  ...attributes
                }));
              }
            });
          }
        });
      });
    }
    return true;
  };
  var wrapIn2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return wrapIn(type, attributes)(state, dispatch);
  };
  var wrapInList2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return wrapInList(type, attributes)(state, dispatch);
  };
  var commands = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    blur,
    clearContent,
    clearNodes,
    command,
    createParagraphNear: createParagraphNear2,
    cut,
    deleteCurrentNode,
    deleteNode,
    deleteRange: deleteRange2,
    deleteSelection: deleteSelection2,
    enter,
    exitCode: exitCode2,
    extendMarkRange,
    first,
    focus,
    forEach,
    insertContent,
    insertContentAt,
    joinUp: joinUp2,
    joinDown: joinDown2,
    joinBackward: joinBackward2,
    joinForward: joinForward2,
    joinItemBackward,
    joinItemForward,
    keyboardShortcut,
    lift: lift3,
    liftEmptyBlock: liftEmptyBlock2,
    liftListItem: liftListItem2,
    newlineInCode: newlineInCode2,
    resetAttributes,
    scrollIntoView,
    selectAll: selectAll2,
    selectNodeBackward: selectNodeBackward2,
    selectNodeForward: selectNodeForward2,
    selectParentNode: selectParentNode2,
    selectTextblockEnd: selectTextblockEnd2,
    selectTextblockStart: selectTextblockStart2,
    setContent,
    setMark,
    setMeta,
    setNode,
    setNodeSelection,
    setTextSelection,
    sinkListItem: sinkListItem2,
    splitBlock: splitBlock2,
    splitListItem,
    toggleList,
    toggleMark,
    toggleNode,
    toggleWrap,
    undoInputRule,
    unsetAllMarks,
    unsetMark,
    updateAttributes,
    wrapIn: wrapIn2,
    wrapInList: wrapInList2
  });
  var Commands = Extension.create({
    name: "commands",
    addCommands() {
      return {
        ...commands
      };
    }
  });
  var Editable = Extension.create({
    name: "editable",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("editable"),
          props: {
            editable: () => this.editor.options.editable
          }
        })
      ];
    }
  });
  var FocusEvents = Extension.create({
    name: "focusEvents",
    addProseMirrorPlugins() {
      const { editor } = this;
      return [
        new Plugin({
          key: new PluginKey("focusEvents"),
          props: {
            handleDOMEvents: {
              focus: (view, event) => {
                editor.isFocused = true;
                const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
                view.dispatch(transaction);
                return false;
              },
              blur: (view, event) => {
                editor.isFocused = false;
                const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
                view.dispatch(transaction);
                return false;
              }
            }
          }
        })
      ];
    }
  });
  var Keymap = Extension.create({
    name: "keymap",
    addKeyboardShortcuts() {
      const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
        () => commands2.undoInputRule(),
        // maybe convert first text block node to default node
        () => commands2.command(({ tr }) => {
          const { selection, doc: doc3 } = tr;
          const { empty: empty2, $anchor } = selection;
          const { pos, parent } = $anchor;
          const $parentPos = $anchor.parent.isTextblock ? tr.doc.resolve(pos - 1) : $anchor;
          const parentIsIsolating = $parentPos.parent.type.spec.isolating;
          const parentPos = $anchor.pos - $anchor.parentOffset;
          const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc3).from === pos;
          if (!empty2 || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {
            return false;
          }
          return commands2.clearNodes();
        }),
        () => commands2.deleteSelection(),
        () => commands2.joinBackward(),
        () => commands2.selectNodeBackward()
      ]);
      const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
        () => commands2.deleteSelection(),
        () => commands2.deleteCurrentNode(),
        () => commands2.joinForward(),
        () => commands2.selectNodeForward()
      ]);
      const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
        () => commands2.newlineInCode(),
        () => commands2.createParagraphNear(),
        () => commands2.liftEmptyBlock(),
        () => commands2.splitBlock()
      ]);
      const baseKeymap = {
        Enter: handleEnter,
        "Mod-Enter": () => this.editor.commands.exitCode(),
        Backspace: handleBackspace,
        "Mod-Backspace": handleBackspace,
        "Shift-Backspace": handleBackspace,
        Delete: handleDelete,
        "Mod-Delete": handleDelete,
        "Mod-a": () => this.editor.commands.selectAll()
      };
      const pcKeymap = {
        ...baseKeymap
      };
      const macKeymap = {
        ...baseKeymap,
        "Ctrl-h": handleBackspace,
        "Alt-Backspace": handleBackspace,
        "Ctrl-d": handleDelete,
        "Ctrl-Alt-Backspace": handleDelete,
        "Alt-Delete": handleDelete,
        "Alt-d": handleDelete,
        "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
        "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
      };
      if (isiOS() || isMacOS()) {
        return macKeymap;
      }
      return pcKeymap;
    },
    addProseMirrorPlugins() {
      return [
        // With this plugin we check if the whole document was selected and deleted.
        // In this case we will additionally call `clearNodes()` to convert e.g. a heading
        // to a paragraph if necessary.
        // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
        // with many other commands.
        new Plugin({
          key: new PluginKey("clearDocument"),
          appendTransaction: (transactions, oldState, newState) => {
            const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
            if (!docChanges) {
              return;
            }
            const { empty: empty2, from: from2, to } = oldState.selection;
            const allFrom = Selection.atStart(oldState.doc).from;
            const allEnd = Selection.atEnd(oldState.doc).to;
            const allWasSelected = from2 === allFrom && to === allEnd;
            if (empty2 || !allWasSelected) {
              return;
            }
            const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, " ", " ").length === 0;
            if (!isEmpty) {
              return;
            }
            const tr = newState.tr;
            const state = createChainableState({
              state: newState,
              transaction: tr
            });
            const { commands: commands2 } = new CommandManager({
              editor: this.editor,
              state
            });
            commands2.clearNodes();
            if (!tr.steps.length) {
              return;
            }
            return tr;
          }
        })
      ];
    }
  });
  var Tabindex = Extension.create({
    name: "tabindex",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("tabindex"),
          props: {
            attributes: this.editor.isEditable ? { tabindex: "0" } : {}
          }
        })
      ];
    }
  });
  var extensions = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ClipboardTextSerializer,
    Commands,
    Editable,
    FocusEvents,
    Keymap,
    Tabindex
  });
  var style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
  function createStyleTag(style2, nonce, suffix) {
    const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ""}]`);
    if (tiptapStyleTag !== null) {
      return tiptapStyleTag;
    }
    const styleNode = document.createElement("style");
    if (nonce) {
      styleNode.setAttribute("nonce", nonce);
    }
    styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ""}`, "");
    styleNode.innerHTML = style2;
    document.getElementsByTagName("head")[0].appendChild(styleNode);
    return styleNode;
  }
  var Editor = class extends EventEmitter {
    constructor(options = {}) {
      super();
      this.isFocused = false;
      this.extensionStorage = {};
      this.options = {
        element: document.createElement("div"),
        content: "",
        injectCSS: true,
        injectNonce: void 0,
        extensions: [],
        autofocus: false,
        editable: true,
        editorProps: {},
        parseOptions: {},
        enableInputRules: true,
        enablePasteRules: true,
        enableCoreExtensions: true,
        onBeforeCreate: () => null,
        onCreate: () => null,
        onUpdate: () => null,
        onSelectionUpdate: () => null,
        onTransaction: () => null,
        onFocus: () => null,
        onBlur: () => null,
        onDestroy: () => null
      };
      this.isCapturingTransaction = false;
      this.capturedTransaction = null;
      this.setOptions(options);
      this.createExtensionManager();
      this.createCommandManager();
      this.createSchema();
      this.on("beforeCreate", this.options.onBeforeCreate);
      this.emit("beforeCreate", { editor: this });
      this.createView();
      this.injectCSS();
      this.on("create", this.options.onCreate);
      this.on("update", this.options.onUpdate);
      this.on("selectionUpdate", this.options.onSelectionUpdate);
      this.on("transaction", this.options.onTransaction);
      this.on("focus", this.options.onFocus);
      this.on("blur", this.options.onBlur);
      this.on("destroy", this.options.onDestroy);
      window.setTimeout(() => {
        if (this.isDestroyed) {
          return;
        }
        this.commands.focus(this.options.autofocus);
        this.emit("create", { editor: this });
      }, 0);
    }
    /**
     * Returns the editor storage.
     */
    get storage() {
      return this.extensionStorage;
    }
    /**
     * An object of all registered commands.
     */
    get commands() {
      return this.commandManager.commands;
    }
    /**
     * Create a command chain to call multiple commands at once.
     */
    chain() {
      return this.commandManager.chain();
    }
    /**
     * Check if a command or a command chain can be executed. Without executing it.
     */
    can() {
      return this.commandManager.can();
    }
    /**
     * Inject CSS styles.
     */
    injectCSS() {
      if (this.options.injectCSS && document) {
        this.css = createStyleTag(style, this.options.injectNonce);
      }
    }
    /**
     * Update editor options.
     *
     * @param options A list of options
     */
    setOptions(options = {}) {
      this.options = {
        ...this.options,
        ...options
      };
      if (!this.view || !this.state || this.isDestroyed) {
        return;
      }
      if (this.options.editorProps) {
        this.view.setProps(this.options.editorProps);
      }
      this.view.updateState(this.state);
    }
    /**
     * Update editable state of the editor.
     */
    setEditable(editable, emitUpdate = true) {
      this.setOptions({ editable });
      if (emitUpdate) {
        this.emit("update", { editor: this, transaction: this.state.tr });
      }
    }
    /**
     * Returns whether the editor is editable.
     */
    get isEditable() {
      return this.options.editable && this.view && this.view.editable;
    }
    /**
     * Returns the editor state.
     */
    get state() {
      return this.view.state;
    }
    /**
     * Register a ProseMirror plugin.
     *
     * @param plugin A ProseMirror plugin
     * @param handlePlugins Control how to merge the plugin into the existing plugins.
     */
    registerPlugin(plugin, handlePlugins) {
      const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
      const state = this.state.reconfigure({ plugins });
      this.view.updateState(state);
    }
    /**
     * Unregister a ProseMirror plugin.
     *
     * @param nameOrPluginKey The plugins name
     */
    unregisterPlugin(nameOrPluginKey) {
      if (this.isDestroyed) {
        return;
      }
      const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
      const state = this.state.reconfigure({
        // @ts-ignore
        plugins: this.state.plugins.filter((plugin) => !plugin.key.startsWith(name))
      });
      this.view.updateState(state);
    }
    /**
     * Creates an extension manager.
     */
    createExtensionManager() {
      const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];
      const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
        return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
      });
      this.extensionManager = new ExtensionManager(allExtensions, this);
    }
    /**
     * Creates an command manager.
     */
    createCommandManager() {
      this.commandManager = new CommandManager({
        editor: this
      });
    }
    /**
     * Creates a ProseMirror schema.
     */
    createSchema() {
      this.schema = this.extensionManager.schema;
    }
    /**
     * Creates a ProseMirror view.
     */
    createView() {
      const doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions);
      const selection = resolveFocusPosition(doc3, this.options.autofocus);
      this.view = new EditorView(this.options.element, {
        ...this.options.editorProps,
        dispatchTransaction: this.dispatchTransaction.bind(this),
        state: EditorState.create({
          doc: doc3,
          selection: selection || void 0
        })
      });
      const newState = this.state.reconfigure({
        plugins: this.extensionManager.plugins
      });
      this.view.updateState(newState);
      this.createNodeViews();
      this.prependClass();
      const dom = this.view.dom;
      dom.editor = this;
    }
    /**
     * Creates all node views.
     */
    createNodeViews() {
      this.view.setProps({
        nodeViews: this.extensionManager.nodeViews
      });
    }
    /**
     * Prepend class name to element.
     */
    prependClass() {
      this.view.dom.className = `tiptap ${this.view.dom.className}`;
    }
    captureTransaction(fn2) {
      this.isCapturingTransaction = true;
      fn2();
      this.isCapturingTransaction = false;
      const tr = this.capturedTransaction;
      this.capturedTransaction = null;
      return tr;
    }
    /**
     * The callback over which to send transactions (state updates) produced by the view.
     *
     * @param transaction An editor state transaction
     */
    dispatchTransaction(transaction) {
      if (this.view.isDestroyed) {
        return;
      }
      if (this.isCapturingTransaction) {
        if (!this.capturedTransaction) {
          this.capturedTransaction = transaction;
          return;
        }
        transaction.steps.forEach((step) => {
          var _a;
          return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);
        });
        return;
      }
      const state = this.state.apply(transaction);
      const selectionHasChanged = !this.state.selection.eq(state.selection);
      this.view.updateState(state);
      this.emit("transaction", {
        editor: this,
        transaction
      });
      if (selectionHasChanged) {
        this.emit("selectionUpdate", {
          editor: this,
          transaction
        });
      }
      const focus2 = transaction.getMeta("focus");
      const blur2 = transaction.getMeta("blur");
      if (focus2) {
        this.emit("focus", {
          editor: this,
          event: focus2.event,
          transaction
        });
      }
      if (blur2) {
        this.emit("blur", {
          editor: this,
          event: blur2.event,
          transaction
        });
      }
      if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
        return;
      }
      this.emit("update", {
        editor: this,
        transaction
      });
    }
    /**
     * Get attributes of the currently selected node or mark.
     */
    getAttributes(nameOrType) {
      return getAttributes(this.state, nameOrType);
    }
    isActive(nameOrAttributes, attributesOrUndefined) {
      const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
      const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
      return isActive(this.state, name, attributes);
    }
    /**
     * Get the document as JSON.
     */
    getJSON() {
      return this.state.doc.toJSON();
    }
    /**
     * Get the document as HTML.
     */
    getHTML() {
      return getHTMLFromFragment(this.state.doc.content, this.schema);
    }
    /**
     * Get the document as text.
     */
    getText(options) {
      const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
      return getText(this.state.doc, {
        blockSeparator,
        textSerializers: {
          ...getTextSerializersFromSchema(this.schema),
          ...textSerializers
        }
      });
    }
    /**
     * Check if there is no content.
     */
    get isEmpty() {
      return isNodeEmpty(this.state.doc);
    }
    /**
     * Get the number of characters for the current document.
     *
     * @deprecated
     */
    getCharacterCount() {
      console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
      return this.state.doc.content.size - 2;
    }
    /**
     * Destroy the editor.
     */
    destroy() {
      this.emit("destroy");
      if (this.view) {
        this.view.destroy();
      }
      this.removeAllListeners();
    }
    /**
     * Check if the editor is already destroyed.
     */
    get isDestroyed() {
      var _a;
      return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);
    }
  };
  function markInputRule(config2) {
    return new InputRule({
      find: config2.find,
      handler: ({ state, range, match }) => {
        const attributes = callOrReturn(config2.getAttributes, void 0, match);
        if (attributes === false || attributes === null) {
          return null;
        }
        const { tr } = state;
        const captureGroup = match[match.length - 1];
        const fullMatch = match[0];
        if (captureGroup) {
          const startSpaces = fullMatch.search(/\S/);
          const textStart = range.from + fullMatch.indexOf(captureGroup);
          const textEnd = textStart + captureGroup.length;
          const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
            const excluded = item.mark.type.excluded;
            return excluded.find((type) => type === config2.type && type !== item.mark.type);
          }).filter((item) => item.to > textStart);
          if (excludedMarks.length) {
            return null;
          }
          if (textEnd < range.to) {
            tr.delete(textEnd, range.to);
          }
          if (textStart > range.from) {
            tr.delete(range.from + startSpaces, textStart);
          }
          const markEnd = range.from + startSpaces + captureGroup.length;
          tr.addMark(range.from + startSpaces, markEnd, config2.type.create(attributes || {}));
          tr.removeStoredMark(config2.type);
        }
      }
    });
  }
  function nodeInputRule(config2) {
    return new InputRule({
      find: config2.find,
      handler: ({ state, range, match }) => {
        const attributes = callOrReturn(config2.getAttributes, void 0, match) || {};
        const { tr } = state;
        const start2 = range.from;
        let end2 = range.to;
        const newNode = config2.type.create(attributes);
        if (match[1]) {
          const offset2 = match[0].lastIndexOf(match[1]);
          let matchStart = start2 + offset2;
          if (matchStart > end2) {
            matchStart = end2;
          } else {
            end2 = matchStart + match[1].length;
          }
          const lastChar = match[0][match[0].length - 1];
          tr.insertText(lastChar, start2 + match[0].length - 1);
          tr.replaceWith(matchStart, end2, newNode);
        } else if (match[0]) {
          tr.insert(start2 - 1, config2.type.create(attributes)).delete(tr.mapping.map(start2), tr.mapping.map(end2));
        }
        tr.scrollIntoView();
      }
    });
  }
  function textblockTypeInputRule(config2) {
    return new InputRule({
      find: config2.find,
      handler: ({ state, range, match }) => {
        const $start = state.doc.resolve(range.from);
        const attributes = callOrReturn(config2.getAttributes, void 0, match) || {};
        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config2.type)) {
          return null;
        }
        state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config2.type, attributes);
      }
    });
  }
  function wrappingInputRule(config2) {
    return new InputRule({
      find: config2.find,
      handler: ({ state, range, match, chain }) => {
        const attributes = callOrReturn(config2.getAttributes, void 0, match) || {};
        const tr = state.tr.delete(range.from, range.to);
        const $start = tr.doc.resolve(range.from);
        const blockRange = $start.blockRange();
        const wrapping = blockRange && findWrapping(blockRange, config2.type, attributes);
        if (!wrapping) {
          return null;
        }
        tr.wrap(blockRange, wrapping);
        if (config2.keepMarks && config2.editor) {
          const { selection, storedMarks } = state;
          const { splittableMarks } = config2.editor.extensionManager;
          const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
          if (marks) {
            const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
            tr.ensureMarks(filteredMarks);
          }
        }
        if (config2.keepAttributes) {
          const nodeType = config2.type.name === "bulletList" || config2.type.name === "orderedList" ? "listItem" : "taskList";
          chain().updateAttributes(nodeType, attributes).run();
        }
        const before = tr.doc.resolve(range.from - 1).nodeBefore;
        if (before && before.type === config2.type && canJoin(tr.doc, range.from - 1) && (!config2.joinPredicate || config2.joinPredicate(match, before))) {
          tr.join(range.from - 1);
        }
      }
    });
  }
  var Mark2 = class _Mark {
    constructor(config2 = {}) {
      this.type = "mark";
      this.name = "mark";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = {
        ...this.config,
        ...config2
      };
      this.name = this.config.name;
      if (config2.defaultOptions) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(config2 = {}) {
      return new _Mark(config2);
    }
    configure(options = {}) {
      const extension = this.extend();
      extension.options = mergeDeep(this.options, options);
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
    extend(extendedConfig = {}) {
      const extension = new _Mark(extendedConfig);
      extension.parent = this;
      this.child = extension;
      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
      if (extendedConfig.defaultOptions) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
      }
      extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
        name: extension.name
      }));
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
    static handleExit({ editor, mark }) {
      const { tr } = editor.state;
      const currentPos = editor.state.selection.$from;
      const isAtEnd = currentPos.pos === currentPos.end();
      if (isAtEnd) {
        const currentMarks = currentPos.marks();
        const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
        if (!isInMark) {
          return false;
        }
        const removeMark2 = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
        if (removeMark2) {
          tr.removeStoredMark(removeMark2);
        }
        tr.insertText(" ", currentPos.pos);
        editor.view.dispatch(tr);
        return true;
      }
      return false;
    }
  };
  var Node2 = class _Node {
    constructor(config2 = {}) {
      this.type = "node";
      this.name = "node";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = {
        ...this.config,
        ...config2
      };
      this.name = this.config.name;
      if (config2.defaultOptions) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(config2 = {}) {
      return new _Node(config2);
    }
    configure(options = {}) {
      const extension = this.extend();
      extension.options = mergeDeep(this.options, options);
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
    extend(extendedConfig = {}) {
      const extension = new _Node(extendedConfig);
      extension.parent = this;
      this.child = extension;
      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
      if (extendedConfig.defaultOptions) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
      }
      extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
        name: extension.name
      }));
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
  };
  function markPasteRule(config2) {
    return new PasteRule({
      find: config2.find,
      handler: ({ state, range, match }) => {
        const attributes = callOrReturn(config2.getAttributes, void 0, match);
        if (attributes === false || attributes === null) {
          return null;
        }
        const { tr } = state;
        const captureGroup = match[match.length - 1];
        const fullMatch = match[0];
        let markEnd = range.to;
        if (captureGroup) {
          const startSpaces = fullMatch.search(/\S/);
          const textStart = range.from + fullMatch.indexOf(captureGroup);
          const textEnd = textStart + captureGroup.length;
          const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
            const excluded = item.mark.type.excluded;
            return excluded.find((type) => type === config2.type && type !== item.mark.type);
          }).filter((item) => item.to > textStart);
          if (excludedMarks.length) {
            return null;
          }
          if (textEnd < range.to) {
            tr.delete(textEnd, range.to);
          }
          if (textStart > range.from) {
            tr.delete(range.from + startSpaces, textStart);
          }
          markEnd = range.from + startSpaces + captureGroup.length;
          tr.addMark(range.from + startSpaces, markEnd, config2.type.create(attributes || {}));
          tr.removeStoredMark(config2.type);
        }
      }
    });
  }

  // node_modules/@tiptap/extension-document/dist/index.js
  var Document = Node2.create({
    name: "doc",
    topNode: true,
    content: "block+"
  });

  // node_modules/@tiptap/extension-character-count/dist/index.js
  var CharacterCount = Extension.create({
    name: "characterCount",
    addOptions() {
      return {
        limit: null,
        mode: "textSize"
      };
    },
    addStorage() {
      return {
        characters: () => 0,
        words: () => 0
      };
    },
    onBeforeCreate() {
      this.storage.characters = (options) => {
        const node = (options === null || options === void 0 ? void 0 : options.node) || this.editor.state.doc;
        const mode = (options === null || options === void 0 ? void 0 : options.mode) || this.options.mode;
        if (mode === "textSize") {
          const text = node.textBetween(0, node.content.size, void 0, " ");
          return text.length;
        }
        return node.nodeSize;
      };
      this.storage.words = (options) => {
        const node = (options === null || options === void 0 ? void 0 : options.node) || this.editor.state.doc;
        const text = node.textBetween(0, node.content.size, " ", " ");
        const words = text.split(" ").filter((word) => word !== "");
        return words.length;
      };
    },
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("characterCount"),
          filterTransaction: (transaction, state) => {
            const limit = this.options.limit;
            if (!transaction.docChanged || limit === 0 || limit === null || limit === void 0) {
              return true;
            }
            const oldSize = this.storage.characters({ node: state.doc });
            const newSize = this.storage.characters({ node: transaction.doc });
            if (newSize <= limit) {
              return true;
            }
            if (oldSize > limit && newSize > limit && newSize <= oldSize) {
              return true;
            }
            if (oldSize > limit && newSize > limit && newSize > oldSize) {
              return false;
            }
            const isPaste = transaction.getMeta("paste");
            if (!isPaste) {
              return false;
            }
            const pos = transaction.selection.$head.pos;
            const over = newSize - limit;
            const from2 = pos - over;
            const to = pos;
            transaction.deleteRange(from2, to);
            const updatedSize = this.storage.characters({ node: transaction.doc });
            if (updatedSize > limit) {
              return false;
            }
            return true;
          }
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-blockquote/dist/index.js
  var inputRegex = /^\s*>\s$/;
  var Blockquote = Node2.create({
    name: "blockquote",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    content: "block+",
    group: "block",
    defining: true,
    parseHTML() {
      return [
        { tag: "blockquote" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setBlockquote: () => ({ commands: commands2 }) => {
          return commands2.wrapIn(this.name);
        },
        toggleBlockquote: () => ({ commands: commands2 }) => {
          return commands2.toggleWrap(this.name);
        },
        unsetBlockquote: () => ({ commands: commands2 }) => {
          return commands2.lift(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
      };
    },
    addInputRules() {
      return [
        wrappingInputRule({
          find: inputRegex,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-bold/dist/index.js
  var starInputRegex = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/;
  var starPasteRegex = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g;
  var underscoreInputRegex = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/;
  var underscorePasteRegex = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g;
  var Bold = Mark2.create({
    name: "bold",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "strong"
        },
        {
          tag: "b",
          getAttrs: (node) => node.style.fontWeight !== "normal" && null
        },
        {
          style: "font-weight",
          getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setBold: () => ({ commands: commands2 }) => {
          return commands2.setMark(this.name);
        },
        toggleBold: () => ({ commands: commands2 }) => {
          return commands2.toggleMark(this.name);
        },
        unsetBold: () => ({ commands: commands2 }) => {
          return commands2.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-b": () => this.editor.commands.toggleBold(),
        "Mod-B": () => this.editor.commands.toggleBold()
      };
    },
    addInputRules() {
      return [
        markInputRule({
          find: starInputRegex,
          type: this.type
        }),
        markInputRule({
          find: underscoreInputRegex,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: starPasteRegex,
          type: this.type
        }),
        markPasteRule({
          find: underscorePasteRegex,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-bullet-list/dist/index.js
  var ListItem = Node2.create({
    name: "listItem",
    addOptions() {
      return {
        HTMLAttributes: {},
        bulletListTypeName: "bulletList",
        orderedListTypeName: "orderedList"
      };
    },
    content: "paragraph block*",
    defining: true,
    parseHTML() {
      return [
        {
          tag: "li"
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addKeyboardShortcuts() {
      return {
        Enter: () => this.editor.commands.splitListItem(this.name),
        Tab: () => this.editor.commands.sinkListItem(this.name),
        "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
      };
    }
  });
  var TextStyle = Mark2.create({
    name: "textStyle",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "span",
          getAttrs: (element) => {
            const hasStyles = element.hasAttribute("style");
            if (!hasStyles) {
              return false;
            }
            return {};
          }
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
          const attributes = getMarkAttributes(state, this.type);
          const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
          if (hasStyles) {
            return true;
          }
          return commands2.unsetMark(this.name);
        }
      };
    }
  });
  var inputRegex2 = /^\s*([-+*])\s$/;
  var BulletList = Node2.create({
    name: "bulletList",
    addOptions() {
      return {
        itemTypeName: "listItem",
        HTMLAttributes: {},
        keepMarks: false,
        keepAttributes: false
      };
    },
    group: "block list",
    content() {
      return `${this.options.itemTypeName}+`;
    },
    parseHTML() {
      return [
        { tag: "ul" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        toggleBulletList: () => ({ commands: commands2, chain }) => {
          if (this.options.keepAttributes) {
            return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItem.name, this.editor.getAttributes(TextStyle.name)).run();
          }
          return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
      };
    },
    addInputRules() {
      let inputRule = wrappingInputRule({
        find: inputRegex2,
        type: this.type
      });
      if (this.options.keepMarks || this.options.keepAttributes) {
        inputRule = wrappingInputRule({
          find: inputRegex2,
          type: this.type,
          keepMarks: this.options.keepMarks,
          keepAttributes: this.options.keepAttributes,
          getAttributes: () => {
            return this.editor.getAttributes(TextStyle.name);
          },
          editor: this.editor
        });
      }
      return [
        inputRule
      ];
    }
  });

  // node_modules/@tiptap/extension-code/dist/index.js
  var inputRegex3 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/;
  var pasteRegex = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g;
  var Code = Mark2.create({
    name: "code",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    excludes: "_",
    code: true,
    exitable: true,
    parseHTML() {
      return [
        { tag: "code" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setCode: () => ({ commands: commands2 }) => {
          return commands2.setMark(this.name);
        },
        toggleCode: () => ({ commands: commands2 }) => {
          return commands2.toggleMark(this.name);
        },
        unsetCode: () => ({ commands: commands2 }) => {
          return commands2.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-e": () => this.editor.commands.toggleCode()
      };
    },
    addInputRules() {
      return [
        markInputRule({
          find: inputRegex3,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: pasteRegex,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-code-block/dist/index.js
  var backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
  var tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
  var CodeBlock = Node2.create({
    name: "codeBlock",
    addOptions() {
      return {
        languageClassPrefix: "language-",
        exitOnTripleEnter: true,
        exitOnArrowDown: true,
        HTMLAttributes: {}
      };
    },
    content: "text*",
    marks: "",
    group: "block",
    code: true,
    defining: true,
    addAttributes() {
      return {
        language: {
          default: null,
          parseHTML: (element) => {
            var _a;
            const { languageClassPrefix } = this.options;
            const classNames = [...((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || []];
            const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
            const language = languages[0];
            if (!language) {
              return null;
            }
            return language;
          },
          rendered: false
        }
      };
    },
    parseHTML() {
      return [
        {
          tag: "pre",
          preserveWhitespace: "full"
        }
      ];
    },
    renderHTML({ node, HTMLAttributes }) {
      return [
        "pre",
        mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
        [
          "code",
          {
            class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
          },
          0
        ]
      ];
    },
    addCommands() {
      return {
        setCodeBlock: (attributes) => ({ commands: commands2 }) => {
          return commands2.setNode(this.name, attributes);
        },
        toggleCodeBlock: (attributes) => ({ commands: commands2 }) => {
          return commands2.toggleNode(this.name, "paragraph", attributes);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
        // remove code block when at start of document or code block is empty
        Backspace: () => {
          const { empty: empty2, $anchor } = this.editor.state.selection;
          const isAtStart = $anchor.pos === 1;
          if (!empty2 || $anchor.parent.type.name !== this.name) {
            return false;
          }
          if (isAtStart || !$anchor.parent.textContent.length) {
            return this.editor.commands.clearNodes();
          }
          return false;
        },
        // exit node on triple enter
        Enter: ({ editor }) => {
          if (!this.options.exitOnTripleEnter) {
            return false;
          }
          const { state } = editor;
          const { selection } = state;
          const { $from, empty: empty2 } = selection;
          if (!empty2 || $from.parent.type !== this.type) {
            return false;
          }
          const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
          const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
          if (!isAtEnd || !endsWithDoubleNewline) {
            return false;
          }
          return editor.chain().command(({ tr }) => {
            tr.delete($from.pos - 2, $from.pos);
            return true;
          }).exitCode().run();
        },
        // exit node on arrow down
        ArrowDown: ({ editor }) => {
          if (!this.options.exitOnArrowDown) {
            return false;
          }
          const { state } = editor;
          const { selection, doc: doc3 } = state;
          const { $from, empty: empty2 } = selection;
          if (!empty2 || $from.parent.type !== this.type) {
            return false;
          }
          const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
          if (!isAtEnd) {
            return false;
          }
          const after = $from.after();
          if (after === void 0) {
            return false;
          }
          const nodeAfter = doc3.nodeAt(after);
          if (nodeAfter) {
            return false;
          }
          return editor.commands.exitCode();
        }
      };
    },
    addInputRules() {
      return [
        textblockTypeInputRule({
          find: backtickInputRegex,
          type: this.type,
          getAttributes: (match) => ({
            language: match[1]
          })
        }),
        textblockTypeInputRule({
          find: tildeInputRegex,
          type: this.type,
          getAttributes: (match) => ({
            language: match[1]
          })
        })
      ];
    },
    addProseMirrorPlugins() {
      return [
        // this plugin creates a code block for pasted content from VS Code
        // we can also detect the copied code language
        new Plugin({
          key: new PluginKey("codeBlockVSCodeHandler"),
          props: {
            handlePaste: (view, event) => {
              if (!event.clipboardData) {
                return false;
              }
              if (this.editor.isActive(this.type.name)) {
                return false;
              }
              const text = event.clipboardData.getData("text/plain");
              const vscode = event.clipboardData.getData("vscode-editor-data");
              const vscodeData = vscode ? JSON.parse(vscode) : void 0;
              const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
              if (!text || !language) {
                return false;
              }
              const { tr } = view.state;
              tr.replaceSelectionWith(this.type.create({ language }));
              tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));
              tr.insertText(text.replace(/\r\n?/g, "\n"));
              tr.setMeta("paste", true);
              view.dispatch(tr);
              return true;
            }
          }
        })
      ];
    }
  });

  // node_modules/prosemirror-dropcursor/dist/index.js
  function dropCursor(options = {}) {
    return new Plugin({
      view(editorView) {
        return new DropCursorView(editorView, options);
      }
    });
  }
  var DropCursorView = class {
    constructor(editorView, options) {
      var _a;
      this.editorView = editorView;
      this.cursorPos = null;
      this.element = null;
      this.timeout = -1;
      this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;
      this.color = options.color === false ? void 0 : options.color || "black";
      this.class = options.class;
      this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
        let handler = (e) => {
          this[name](e);
        };
        editorView.dom.addEventListener(name, handler);
        return { name, handler };
      });
    }
    destroy() {
      this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
    }
    update(editorView, prevState) {
      if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
        if (this.cursorPos > editorView.state.doc.content.size)
          this.setCursor(null);
        else
          this.updateOverlay();
      }
    }
    setCursor(pos) {
      if (pos == this.cursorPos)
        return;
      this.cursorPos = pos;
      if (pos == null) {
        this.element.parentNode.removeChild(this.element);
        this.element = null;
      } else {
        this.updateOverlay();
      }
    }
    updateOverlay() {
      let $pos = this.editorView.state.doc.resolve(this.cursorPos);
      let isBlock = !$pos.parent.inlineContent, rect;
      if (isBlock) {
        let before = $pos.nodeBefore, after = $pos.nodeAfter;
        if (before || after) {
          let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
          if (node) {
            let nodeRect = node.getBoundingClientRect();
            let top2 = before ? nodeRect.bottom : nodeRect.top;
            if (before && after)
              top2 = (top2 + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
            rect = { left: nodeRect.left, right: nodeRect.right, top: top2 - this.width / 2, bottom: top2 + this.width / 2 };
          }
        }
      }
      if (!rect) {
        let coords = this.editorView.coordsAtPos(this.cursorPos);
        rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };
      }
      let parent = this.editorView.dom.offsetParent;
      if (!this.element) {
        this.element = parent.appendChild(document.createElement("div"));
        if (this.class)
          this.element.className = this.class;
        this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
        if (this.color) {
          this.element.style.backgroundColor = this.color;
        }
      }
      this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
      this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
      let parentLeft, parentTop;
      if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
        parentLeft = -pageXOffset;
        parentTop = -pageYOffset;
      } else {
        let rect2 = parent.getBoundingClientRect();
        parentLeft = rect2.left - parent.scrollLeft;
        parentTop = rect2.top - parent.scrollTop;
      }
      this.element.style.left = rect.left - parentLeft + "px";
      this.element.style.top = rect.top - parentTop + "px";
      this.element.style.width = rect.right - rect.left + "px";
      this.element.style.height = rect.bottom - rect.top + "px";
    }
    scheduleRemoval(timeout) {
      clearTimeout(this.timeout);
      this.timeout = setTimeout(() => this.setCursor(null), timeout);
    }
    dragover(event) {
      if (!this.editorView.editable)
        return;
      let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
      let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
      let disableDropCursor = node && node.type.spec.disableDropCursor;
      let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
      if (pos && !disabled) {
        let target = pos.pos;
        if (this.editorView.dragging && this.editorView.dragging.slice) {
          let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
          if (point != null)
            target = point;
        }
        this.setCursor(target);
        this.scheduleRemoval(5e3);
      }
    }
    dragend() {
      this.scheduleRemoval(20);
    }
    drop() {
      this.scheduleRemoval(20);
    }
    dragleave(event) {
      if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))
        this.setCursor(null);
    }
  };

  // node_modules/@tiptap/extension-dropcursor/dist/index.js
  var Dropcursor = Extension.create({
    name: "dropCursor",
    addOptions() {
      return {
        color: "currentColor",
        width: 1,
        class: void 0
      };
    },
    addProseMirrorPlugins() {
      return [
        dropCursor(this.options)
      ];
    }
  });

  // node_modules/prosemirror-gapcursor/dist/index.js
  var GapCursor = class _GapCursor extends Selection {
    /**
    Create a gap cursor.
    */
    constructor($pos) {
      super($pos, $pos);
    }
    map(doc3, mapping) {
      let $pos = doc3.resolve(mapping.map(this.head));
      return _GapCursor.valid($pos) ? new _GapCursor($pos) : Selection.near($pos);
    }
    content() {
      return Slice.empty;
    }
    eq(other) {
      return other instanceof _GapCursor && other.head == this.head;
    }
    toJSON() {
      return { type: "gapcursor", pos: this.head };
    }
    /**
    @internal
    */
    static fromJSON(doc3, json) {
      if (typeof json.pos != "number")
        throw new RangeError("Invalid input for GapCursor.fromJSON");
      return new _GapCursor(doc3.resolve(json.pos));
    }
    /**
    @internal
    */
    getBookmark() {
      return new GapBookmark(this.anchor);
    }
    /**
    @internal
    */
    static valid($pos) {
      let parent = $pos.parent;
      if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
        return false;
      let override = parent.type.spec.allowGapCursor;
      if (override != null)
        return override;
      let deflt = parent.contentMatchAt($pos.index()).defaultType;
      return deflt && deflt.isTextblock;
    }
    /**
    @internal
    */
    static findGapCursorFrom($pos, dir, mustMove = false) {
      search:
        for (; ; ) {
          if (!mustMove && _GapCursor.valid($pos))
            return $pos;
          let pos = $pos.pos, next = null;
          for (let d = $pos.depth; ; d--) {
            let parent = $pos.node(d);
            if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
              next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
              break;
            } else if (d == 0) {
              return null;
            }
            pos += dir;
            let $cur = $pos.doc.resolve(pos);
            if (_GapCursor.valid($cur))
              return $cur;
          }
          for (; ; ) {
            let inside = dir > 0 ? next.firstChild : next.lastChild;
            if (!inside) {
              if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
                $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
                mustMove = false;
                continue search;
              }
              break;
            }
            next = inside;
            pos += dir;
            let $cur = $pos.doc.resolve(pos);
            if (_GapCursor.valid($cur))
              return $cur;
          }
          return null;
        }
    }
  };
  GapCursor.prototype.visible = false;
  GapCursor.findFrom = GapCursor.findGapCursorFrom;
  Selection.jsonID("gapcursor", GapCursor);
  var GapBookmark = class _GapBookmark {
    constructor(pos) {
      this.pos = pos;
    }
    map(mapping) {
      return new _GapBookmark(mapping.map(this.pos));
    }
    resolve(doc3) {
      let $pos = doc3.resolve(this.pos);
      return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
    }
  };
  function closedBefore($pos) {
    for (let d = $pos.depth; d >= 0; d--) {
      let index = $pos.index(d), parent = $pos.node(d);
      if (index == 0) {
        if (parent.type.spec.isolating)
          return true;
        continue;
      }
      for (let before = parent.child(index - 1); ; before = before.lastChild) {
        if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
          return true;
        if (before.inlineContent)
          return false;
      }
    }
    return true;
  }
  function closedAfter($pos) {
    for (let d = $pos.depth; d >= 0; d--) {
      let index = $pos.indexAfter(d), parent = $pos.node(d);
      if (index == parent.childCount) {
        if (parent.type.spec.isolating)
          return true;
        continue;
      }
      for (let after = parent.child(index); ; after = after.firstChild) {
        if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
          return true;
        if (after.inlineContent)
          return false;
      }
    }
    return true;
  }
  function gapCursor() {
    return new Plugin({
      props: {
        decorations: drawGapCursor,
        createSelectionBetween(_view, $anchor, $head) {
          return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
        },
        handleClick,
        handleKeyDown,
        handleDOMEvents: { beforeinput }
      }
    });
  }
  var handleKeyDown = keydownHandler({
    "ArrowLeft": arrow("horiz", -1),
    "ArrowRight": arrow("horiz", 1),
    "ArrowUp": arrow("vert", -1),
    "ArrowDown": arrow("vert", 1)
  });
  function arrow(axis, dir) {
    const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
    return function(state, dispatch, view) {
      let sel = state.selection;
      let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
      if (sel instanceof TextSelection) {
        if (!view.endOfTextblock(dirStr) || $start.depth == 0)
          return false;
        mustMove = false;
        $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
      }
      let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
      if (!$found)
        return false;
      if (dispatch)
        dispatch(state.tr.setSelection(new GapCursor($found)));
      return true;
    };
  }
  function handleClick(view, pos, event) {
    if (!view || !view.editable)
      return false;
    let $pos = view.state.doc.resolve(pos);
    if (!GapCursor.valid($pos))
      return false;
    let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
    if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
      return false;
    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
    return true;
  }
  function beforeinput(view, event) {
    if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
      return false;
    let { $from } = view.state.selection;
    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
    if (!insert)
      return false;
    let frag = Fragment.empty;
    for (let i = insert.length - 1; i >= 0; i--)
      frag = Fragment.from(insert[i].createAndFill(null, frag));
    let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
    tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));
    view.dispatch(tr);
    return false;
  }
  function drawGapCursor(state) {
    if (!(state.selection instanceof GapCursor))
      return null;
    let node = document.createElement("div");
    node.className = "ProseMirror-gapcursor";
    return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
  }

  // node_modules/@tiptap/extension-gapcursor/dist/index.js
  var Gapcursor = Extension.create({
    name: "gapCursor",
    addProseMirrorPlugins() {
      return [
        gapCursor()
      ];
    },
    extendNodeSchema(extension) {
      var _a;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      return {
        allowGapCursor: (_a = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) !== null && _a !== void 0 ? _a : null
      };
    }
  });

  // node_modules/@tiptap/extension-hard-break/dist/index.js
  var HardBreak = Node2.create({
    name: "hardBreak",
    addOptions() {
      return {
        keepMarks: true,
        HTMLAttributes: {}
      };
    },
    inline: true,
    group: "inline",
    selectable: false,
    parseHTML() {
      return [
        { tag: "br" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
    },
    renderText() {
      return "\n";
    },
    addCommands() {
      return {
        setHardBreak: () => ({ commands: commands2, chain, state, editor }) => {
          return commands2.first([
            () => commands2.exitCode(),
            () => commands2.command(() => {
              const { selection, storedMarks } = state;
              if (selection.$from.parent.type.spec.isolating) {
                return false;
              }
              const { keepMarks } = this.options;
              const { splittableMarks } = editor.extensionManager;
              const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
              return chain().insertContent({ type: this.name }).command(({ tr, dispatch }) => {
                if (dispatch && marks && keepMarks) {
                  const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                  tr.ensureMarks(filteredMarks);
                }
                return true;
              }).run();
            })
          ]);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Enter": () => this.editor.commands.setHardBreak(),
        "Shift-Enter": () => this.editor.commands.setHardBreak()
      };
    }
  });

  // node_modules/@tiptap/extension-heading/dist/index.js
  var Heading = Node2.create({
    name: "heading",
    addOptions() {
      return {
        levels: [1, 2, 3, 4, 5, 6],
        HTMLAttributes: {}
      };
    },
    content: "inline*",
    group: "block",
    defining: true,
    addAttributes() {
      return {
        level: {
          default: 1,
          rendered: false
        }
      };
    },
    parseHTML() {
      return this.options.levels.map((level) => ({
        tag: `h${level}`,
        attrs: { level }
      }));
    },
    renderHTML({ node, HTMLAttributes }) {
      const hasLevel = this.options.levels.includes(node.attrs.level);
      const level = hasLevel ? node.attrs.level : this.options.levels[0];
      return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setHeading: (attributes) => ({ commands: commands2 }) => {
          if (!this.options.levels.includes(attributes.level)) {
            return false;
          }
          return commands2.setNode(this.name, attributes);
        },
        toggleHeading: (attributes) => ({ commands: commands2 }) => {
          if (!this.options.levels.includes(attributes.level)) {
            return false;
          }
          return commands2.toggleNode(this.name, "paragraph", attributes);
        }
      };
    },
    addKeyboardShortcuts() {
      return this.options.levels.reduce((items, level) => ({
        ...items,
        ...{
          [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
        }
      }), {});
    },
    addInputRules() {
      return this.options.levels.map((level) => {
        return textblockTypeInputRule({
          find: new RegExp(`^(#{1,${level}})\\s$`),
          type: this.type,
          getAttributes: {
            level
          }
        });
      });
    }
  });

  // node_modules/rope-sequence/dist/index.js
  var GOOD_LEAF_SIZE = 200;
  var RopeSequence = function RopeSequence2() {
  };
  RopeSequence.prototype.append = function append(other) {
    if (!other.length) {
      return this;
    }
    other = RopeSequence.from(other);
    return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
  };
  RopeSequence.prototype.prepend = function prepend(other) {
    if (!other.length) {
      return this;
    }
    return RopeSequence.from(other).append(this);
  };
  RopeSequence.prototype.appendInner = function appendInner(other) {
    return new Append(this, other);
  };
  RopeSequence.prototype.slice = function slice(from2, to) {
    if (from2 === void 0)
      from2 = 0;
    if (to === void 0)
      to = this.length;
    if (from2 >= to) {
      return RopeSequence.empty;
    }
    return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
  };
  RopeSequence.prototype.get = function get(i) {
    if (i < 0 || i >= this.length) {
      return void 0;
    }
    return this.getInner(i);
  };
  RopeSequence.prototype.forEach = function forEach2(f, from2, to) {
    if (from2 === void 0)
      from2 = 0;
    if (to === void 0)
      to = this.length;
    if (from2 <= to) {
      this.forEachInner(f, from2, to, 0);
    } else {
      this.forEachInvertedInner(f, from2, to, 0);
    }
  };
  RopeSequence.prototype.map = function map(f, from2, to) {
    if (from2 === void 0)
      from2 = 0;
    if (to === void 0)
      to = this.length;
    var result = [];
    this.forEach(function(elt, i) {
      return result.push(f(elt, i));
    }, from2, to);
    return result;
  };
  RopeSequence.from = function from(values) {
    if (values instanceof RopeSequence) {
      return values;
    }
    return values && values.length ? new Leaf(values) : RopeSequence.empty;
  };
  var Leaf = /* @__PURE__ */ function(RopeSequence3) {
    function Leaf2(values) {
      RopeSequence3.call(this);
      this.values = values;
    }
    if (RopeSequence3)
      Leaf2.__proto__ = RopeSequence3;
    Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
    Leaf2.prototype.constructor = Leaf2;
    var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
    Leaf2.prototype.flatten = function flatten() {
      return this.values;
    };
    Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
      if (from2 == 0 && to == this.length) {
        return this;
      }
      return new Leaf2(this.values.slice(from2, to));
    };
    Leaf2.prototype.getInner = function getInner(i) {
      return this.values[i];
    };
    Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
      for (var i = from2; i < to; i++) {
        if (f(this.values[i], start2 + i) === false) {
          return false;
        }
      }
    };
    Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
      for (var i = from2 - 1; i >= to; i--) {
        if (f(this.values[i], start2 + i) === false) {
          return false;
        }
      }
    };
    Leaf2.prototype.leafAppend = function leafAppend(other) {
      if (this.length + other.length <= GOOD_LEAF_SIZE) {
        return new Leaf2(this.values.concat(other.flatten()));
      }
    };
    Leaf2.prototype.leafPrepend = function leafPrepend(other) {
      if (this.length + other.length <= GOOD_LEAF_SIZE) {
        return new Leaf2(other.flatten().concat(this.values));
      }
    };
    prototypeAccessors.length.get = function() {
      return this.values.length;
    };
    prototypeAccessors.depth.get = function() {
      return 0;
    };
    Object.defineProperties(Leaf2.prototype, prototypeAccessors);
    return Leaf2;
  }(RopeSequence);
  RopeSequence.empty = new Leaf([]);
  var Append = /* @__PURE__ */ function(RopeSequence3) {
    function Append2(left2, right2) {
      RopeSequence3.call(this);
      this.left = left2;
      this.right = right2;
      this.length = left2.length + right2.length;
      this.depth = Math.max(left2.depth, right2.depth) + 1;
    }
    if (RopeSequence3)
      Append2.__proto__ = RopeSequence3;
    Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
    Append2.prototype.constructor = Append2;
    Append2.prototype.flatten = function flatten() {
      return this.left.flatten().concat(this.right.flatten());
    };
    Append2.prototype.getInner = function getInner(i) {
      return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
    };
    Append2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
      var leftLen = this.left.length;
      if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start2) === false) {
        return false;
      }
      if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start2 + leftLen) === false) {
        return false;
      }
    };
    Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
      var leftLen = this.left.length;
      if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start2 + leftLen) === false) {
        return false;
      }
      if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start2) === false) {
        return false;
      }
    };
    Append2.prototype.sliceInner = function sliceInner(from2, to) {
      if (from2 == 0 && to == this.length) {
        return this;
      }
      var leftLen = this.left.length;
      if (to <= leftLen) {
        return this.left.slice(from2, to);
      }
      if (from2 >= leftLen) {
        return this.right.slice(from2 - leftLen, to - leftLen);
      }
      return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
    };
    Append2.prototype.leafAppend = function leafAppend(other) {
      var inner = this.right.leafAppend(other);
      if (inner) {
        return new Append2(this.left, inner);
      }
    };
    Append2.prototype.leafPrepend = function leafPrepend(other) {
      var inner = this.left.leafPrepend(other);
      if (inner) {
        return new Append2(inner, this.right);
      }
    };
    Append2.prototype.appendInner = function appendInner2(other) {
      if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
        return new Append2(this.left, new Append2(this.right, other));
      }
      return new Append2(this, other);
    };
    return Append2;
  }(RopeSequence);
  var dist_default2 = RopeSequence;

  // node_modules/prosemirror-history/dist/index.js
  var max_empty_items = 500;
  var Branch = class _Branch {
    constructor(items, eventCount) {
      this.items = items;
      this.eventCount = eventCount;
    }
    // Pop the latest event off the branch's history and apply it
    // to a document transform.
    popEvent(state, preserveItems) {
      if (this.eventCount == 0)
        return null;
      let end2 = this.items.length;
      for (; ; end2--) {
        let next = this.items.get(end2 - 1);
        if (next.selection) {
          --end2;
          break;
        }
      }
      let remap, mapFrom;
      if (preserveItems) {
        remap = this.remapping(end2, this.items.length);
        mapFrom = remap.maps.length;
      }
      let transform = state.tr;
      let selection, remaining;
      let addAfter = [], addBefore = [];
      this.items.forEach((item, i) => {
        if (!item.step) {
          if (!remap) {
            remap = this.remapping(end2, i + 1);
            mapFrom = remap.maps.length;
          }
          mapFrom--;
          addBefore.push(item);
          return;
        }
        if (remap) {
          addBefore.push(new Item(item.map));
          let step = item.step.map(remap.slice(mapFrom)), map2;
          if (step && transform.maybeStep(step).doc) {
            map2 = transform.mapping.maps[transform.mapping.maps.length - 1];
            addAfter.push(new Item(map2, void 0, void 0, addAfter.length + addBefore.length));
          }
          mapFrom--;
          if (map2)
            remap.appendMap(map2, mapFrom);
        } else {
          transform.maybeStep(item.step);
        }
        if (item.selection) {
          selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
          remaining = new _Branch(this.items.slice(0, end2).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
          return false;
        }
      }, this.items.length, 0);
      return { remaining, transform, selection };
    }
    // Create a new branch with the given transform added.
    addTransform(transform, selection, histOptions, preserveItems) {
      let newItems = [], eventCount = this.eventCount;
      let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
      for (let i = 0; i < transform.steps.length; i++) {
        let step = transform.steps[i].invert(transform.docs[i]);
        let item = new Item(transform.mapping.maps[i], step, selection), merged;
        if (merged = lastItem && lastItem.merge(item)) {
          item = merged;
          if (i)
            newItems.pop();
          else
            oldItems = oldItems.slice(0, oldItems.length - 1);
        }
        newItems.push(item);
        if (selection) {
          eventCount++;
          selection = void 0;
        }
        if (!preserveItems)
          lastItem = item;
      }
      let overflow = eventCount - histOptions.depth;
      if (overflow > DEPTH_OVERFLOW) {
        oldItems = cutOffEvents(oldItems, overflow);
        eventCount -= overflow;
      }
      return new _Branch(oldItems.append(newItems), eventCount);
    }
    remapping(from2, to) {
      let maps = new Mapping();
      this.items.forEach((item, i) => {
        let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
        maps.appendMap(item.map, mirrorPos);
      }, from2, to);
      return maps;
    }
    addMaps(array) {
      if (this.eventCount == 0)
        return this;
      return new _Branch(this.items.append(array.map((map2) => new Item(map2))), this.eventCount);
    }
    // When the collab module receives remote changes, the history has
    // to know about those, so that it can adjust the steps that were
    // rebased on top of the remote changes, and include the position
    // maps for the remote changes in its array of items.
    rebased(rebasedTransform, rebasedCount) {
      if (!this.eventCount)
        return this;
      let rebasedItems = [], start2 = Math.max(0, this.items.length - rebasedCount);
      let mapping = rebasedTransform.mapping;
      let newUntil = rebasedTransform.steps.length;
      let eventCount = this.eventCount;
      this.items.forEach((item) => {
        if (item.selection)
          eventCount--;
      }, start2);
      let iRebased = rebasedCount;
      this.items.forEach((item) => {
        let pos = mapping.getMirror(--iRebased);
        if (pos == null)
          return;
        newUntil = Math.min(newUntil, pos);
        let map2 = mapping.maps[pos];
        if (item.step) {
          let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
          let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
          if (selection)
            eventCount++;
          rebasedItems.push(new Item(map2, step, selection));
        } else {
          rebasedItems.push(new Item(map2));
        }
      }, start2);
      let newMaps = [];
      for (let i = rebasedCount; i < newUntil; i++)
        newMaps.push(new Item(mapping.maps[i]));
      let items = this.items.slice(0, start2).append(newMaps).append(rebasedItems);
      let branch = new _Branch(items, eventCount);
      if (branch.emptyItemCount() > max_empty_items)
        branch = branch.compress(this.items.length - rebasedItems.length);
      return branch;
    }
    emptyItemCount() {
      let count = 0;
      this.items.forEach((item) => {
        if (!item.step)
          count++;
      });
      return count;
    }
    // Compressing a branch means rewriting it to push the air (map-only
    // items) out. During collaboration, these naturally accumulate
    // because each remote change adds one. The `upto` argument is used
    // to ensure that only the items below a given level are compressed,
    // because `rebased` relies on a clean, untouched set of items in
    // order to associate old items with rebased steps.
    compress(upto = this.items.length) {
      let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
      let items = [], events = 0;
      this.items.forEach((item, i) => {
        if (i >= upto) {
          items.push(item);
          if (item.selection)
            events++;
        } else if (item.step) {
          let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
          mapFrom--;
          if (map2)
            remap.appendMap(map2, mapFrom);
          if (step) {
            let selection = item.selection && item.selection.map(remap.slice(mapFrom));
            if (selection)
              events++;
            let newItem = new Item(map2.invert(), step, selection), merged, last = items.length - 1;
            if (merged = items.length && items[last].merge(newItem))
              items[last] = merged;
            else
              items.push(newItem);
          }
        } else if (item.map) {
          mapFrom--;
        }
      }, this.items.length, 0);
      return new _Branch(dist_default2.from(items.reverse()), events);
    }
  };
  Branch.empty = new Branch(dist_default2.empty, 0);
  function cutOffEvents(items, n) {
    let cutPoint;
    items.forEach((item, i) => {
      if (item.selection && n-- == 0) {
        cutPoint = i;
        return false;
      }
    });
    return items.slice(cutPoint);
  }
  var Item = class _Item {
    constructor(map2, step, selection, mirrorOffset) {
      this.map = map2;
      this.step = step;
      this.selection = selection;
      this.mirrorOffset = mirrorOffset;
    }
    merge(other) {
      if (this.step && other.step && !other.selection) {
        let step = other.step.merge(this.step);
        if (step)
          return new _Item(step.getMap().invert(), step, this.selection);
      }
    }
  };
  var HistoryState = class {
    constructor(done, undone, prevRanges, prevTime, prevComposition) {
      this.done = done;
      this.undone = undone;
      this.prevRanges = prevRanges;
      this.prevTime = prevTime;
      this.prevComposition = prevComposition;
    }
  };
  var DEPTH_OVERFLOW = 20;
  function applyTransaction(history2, state, tr, options) {
    let historyTr = tr.getMeta(historyKey), rebased;
    if (historyTr)
      return historyTr.historyState;
    if (tr.getMeta(closeHistoryKey))
      history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
    let appended = tr.getMeta("appendedTransaction");
    if (tr.steps.length == 0) {
      return history2;
    } else if (appended && appended.getMeta(historyKey)) {
      if (appended.getMeta(historyKey).redo)
        return new HistoryState(history2.done.addTransform(tr, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history2.prevTime, history2.prevComposition);
      else
        return new HistoryState(history2.done, history2.undone.addTransform(tr, void 0, options, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
    } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
      let composition = tr.getMeta("composition");
      let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));
      let prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
      return new HistoryState(history2.done.addTransform(tr, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history2.prevComposition : composition);
    } else if (rebased = tr.getMeta("rebased")) {
      return new HistoryState(history2.done.rebased(tr, rebased), history2.undone.rebased(tr, rebased), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
    } else {
      return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
    }
  }
  function isAdjacentTo(transform, prevRanges) {
    if (!prevRanges)
      return false;
    if (!transform.docChanged)
      return true;
    let adjacent = false;
    transform.mapping.maps[0].forEach((start2, end2) => {
      for (let i = 0; i < prevRanges.length; i += 2)
        if (start2 <= prevRanges[i + 1] && end2 >= prevRanges[i])
          adjacent = true;
    });
    return adjacent;
  }
  function rangesFor(map2) {
    let result = [];
    map2.forEach((_from, _to, from2, to) => result.push(from2, to));
    return result;
  }
  function mapRanges(ranges, mapping) {
    if (!ranges)
      return null;
    let result = [];
    for (let i = 0; i < ranges.length; i += 2) {
      let from2 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
      if (from2 <= to)
        result.push(from2, to);
    }
    return result;
  }
  function histTransaction(history2, state, dispatch, redo2) {
    let preserveItems = mustPreserveItems(state);
    let histOptions = historyKey.get(state).spec.config;
    let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
    if (!pop)
      return;
    let selection = pop.selection.resolve(pop.transform.doc);
    let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
    let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
    dispatch(pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist }).scrollIntoView());
  }
  var cachedPreserveItems = false;
  var cachedPreserveItemsPlugins = null;
  function mustPreserveItems(state) {
    let plugins = state.plugins;
    if (cachedPreserveItemsPlugins != plugins) {
      cachedPreserveItems = false;
      cachedPreserveItemsPlugins = plugins;
      for (let i = 0; i < plugins.length; i++)
        if (plugins[i].spec.historyPreserveItems) {
          cachedPreserveItems = true;
          break;
        }
    }
    return cachedPreserveItems;
  }
  var historyKey = new PluginKey("history");
  var closeHistoryKey = new PluginKey("closeHistory");
  function history(config2 = {}) {
    config2 = {
      depth: config2.depth || 100,
      newGroupDelay: config2.newGroupDelay || 500
    };
    return new Plugin({
      key: historyKey,
      state: {
        init() {
          return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
        },
        apply(tr, hist, state) {
          return applyTransaction(hist, state, tr, config2);
        }
      },
      config: config2,
      props: {
        handleDOMEvents: {
          beforeinput(view, e) {
            let inputType = e.inputType;
            let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
            if (!command2)
              return false;
            e.preventDefault();
            return command2(view.state, view.dispatch);
          }
        }
      }
    });
  }
  var undo = (state, dispatch) => {
    let hist = historyKey.getState(state);
    if (!hist || hist.done.eventCount == 0)
      return false;
    if (dispatch)
      histTransaction(hist, state, dispatch, false);
    return true;
  };
  var redo = (state, dispatch) => {
    let hist = historyKey.getState(state);
    if (!hist || hist.undone.eventCount == 0)
      return false;
    if (dispatch)
      histTransaction(hist, state, dispatch, true);
    return true;
  };

  // node_modules/@tiptap/extension-history/dist/index.js
  var History = Extension.create({
    name: "history",
    addOptions() {
      return {
        depth: 100,
        newGroupDelay: 500
      };
    },
    addCommands() {
      return {
        undo: () => ({ state, dispatch }) => {
          return undo(state, dispatch);
        },
        redo: () => ({ state, dispatch }) => {
          return redo(state, dispatch);
        }
      };
    },
    addProseMirrorPlugins() {
      return [
        history(this.options)
      ];
    },
    addKeyboardShortcuts() {
      return {
        "Mod-z": () => this.editor.commands.undo(),
        "Mod-Z": () => this.editor.commands.undo(),
        "Mod-y": () => this.editor.commands.redo(),
        "Mod-Y": () => this.editor.commands.redo(),
        "Shift-Mod-z": () => this.editor.commands.redo(),
        "Shift-Mod-Z": () => this.editor.commands.redo(),
        // Russian keyboard layouts
        "Mod-\u044F": () => this.editor.commands.undo(),
        "Shift-Mod-\u044F": () => this.editor.commands.redo()
      };
    }
  });

  // node_modules/@tiptap/extension-horizontal-rule/dist/index.js
  var HorizontalRule = Node2.create({
    name: "horizontalRule",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    group: "block",
    parseHTML() {
      return [{ tag: "hr" }];
    },
    renderHTML({ HTMLAttributes }) {
      return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
    },
    addCommands() {
      return {
        setHorizontalRule: () => ({ chain, state }) => {
          const { $to: $originTo } = state.selection;
          const currentChain = chain();
          if ($originTo.parentOffset === 0) {
            currentChain.insertContentAt(Math.max($originTo.pos - 2, 0), { type: this.name });
          } else {
            currentChain.insertContent({ type: this.name });
          }
          return currentChain.command(({ tr, dispatch }) => {
            var _a;
            if (dispatch) {
              const { $to } = tr.selection;
              const posAfter = $to.end();
              if ($to.nodeAfter) {
                if ($to.nodeAfter.isTextblock) {
                  tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1));
                } else if ($to.nodeAfter.isBlock) {
                  tr.setSelection(NodeSelection.create(tr.doc, $to.pos));
                } else {
                  tr.setSelection(TextSelection.create(tr.doc, $to.pos));
                }
              } else {
                const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();
                if (node) {
                  tr.insert(posAfter, node);
                  tr.setSelection(TextSelection.create(tr.doc, posAfter + 1));
                }
              }
              tr.scrollIntoView();
            }
            return true;
          }).run();
        }
      };
    },
    addInputRules() {
      return [
        nodeInputRule({
          find: /^(?:---|—-|___\s|\*\*\*\s)$/,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-italic/dist/index.js
  var starInputRegex2 = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/;
  var starPasteRegex2 = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g;
  var underscoreInputRegex2 = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/;
  var underscorePasteRegex2 = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g;
  var Italic = Mark2.create({
    name: "italic",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "em"
        },
        {
          tag: "i",
          getAttrs: (node) => node.style.fontStyle !== "normal" && null
        },
        {
          style: "font-style=italic"
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setItalic: () => ({ commands: commands2 }) => {
          return commands2.setMark(this.name);
        },
        toggleItalic: () => ({ commands: commands2 }) => {
          return commands2.toggleMark(this.name);
        },
        unsetItalic: () => ({ commands: commands2 }) => {
          return commands2.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-i": () => this.editor.commands.toggleItalic(),
        "Mod-I": () => this.editor.commands.toggleItalic()
      };
    },
    addInputRules() {
      return [
        markInputRule({
          find: starInputRegex2,
          type: this.type
        }),
        markInputRule({
          find: underscoreInputRegex2,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: starPasteRegex2,
          type: this.type
        }),
        markPasteRule({
          find: underscorePasteRegex2,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-list-item/dist/index.js
  var ListItem2 = Node2.create({
    name: "listItem",
    addOptions() {
      return {
        HTMLAttributes: {},
        bulletListTypeName: "bulletList",
        orderedListTypeName: "orderedList"
      };
    },
    content: "paragraph block*",
    defining: true,
    parseHTML() {
      return [
        {
          tag: "li"
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addKeyboardShortcuts() {
      return {
        Enter: () => this.editor.commands.splitListItem(this.name),
        Tab: () => this.editor.commands.sinkListItem(this.name),
        "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
      };
    }
  });

  // node_modules/@tiptap/extension-ordered-list/dist/index.js
  var ListItem3 = Node2.create({
    name: "listItem",
    addOptions() {
      return {
        HTMLAttributes: {},
        bulletListTypeName: "bulletList",
        orderedListTypeName: "orderedList"
      };
    },
    content: "paragraph block*",
    defining: true,
    parseHTML() {
      return [
        {
          tag: "li"
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addKeyboardShortcuts() {
      return {
        Enter: () => this.editor.commands.splitListItem(this.name),
        Tab: () => this.editor.commands.sinkListItem(this.name),
        "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
      };
    }
  });
  var TextStyle2 = Mark2.create({
    name: "textStyle",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "span",
          getAttrs: (element) => {
            const hasStyles = element.hasAttribute("style");
            if (!hasStyles) {
              return false;
            }
            return {};
          }
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
          const attributes = getMarkAttributes(state, this.type);
          const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
          if (hasStyles) {
            return true;
          }
          return commands2.unsetMark(this.name);
        }
      };
    }
  });
  var inputRegex4 = /^(\d+)\.\s$/;
  var OrderedList = Node2.create({
    name: "orderedList",
    addOptions() {
      return {
        itemTypeName: "listItem",
        HTMLAttributes: {},
        keepMarks: false,
        keepAttributes: false
      };
    },
    group: "block list",
    content() {
      return `${this.options.itemTypeName}+`;
    },
    addAttributes() {
      return {
        start: {
          default: 1,
          parseHTML: (element) => {
            return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
          }
        }
      };
    },
    parseHTML() {
      return [
        {
          tag: "ol"
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      const { start: start2, ...attributesWithoutStart } = HTMLAttributes;
      return start2 === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        toggleOrderedList: () => ({ commands: commands2, chain }) => {
          if (this.options.keepAttributes) {
            return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItem3.name, this.editor.getAttributes(TextStyle2.name)).run();
          }
          return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
      };
    },
    addInputRules() {
      let inputRule = wrappingInputRule({
        find: inputRegex4,
        type: this.type,
        getAttributes: (match) => ({ start: +match[1] }),
        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]
      });
      if (this.options.keepMarks || this.options.keepAttributes) {
        inputRule = wrappingInputRule({
          find: inputRegex4,
          type: this.type,
          keepMarks: this.options.keepMarks,
          keepAttributes: this.options.keepAttributes,
          getAttributes: (match) => ({ start: +match[1], ...this.editor.getAttributes(TextStyle2.name) }),
          joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],
          editor: this.editor
        });
      }
      return [
        inputRule
      ];
    }
  });

  // node_modules/@tiptap/extension-paragraph/dist/index.js
  var Paragraph = Node2.create({
    name: "paragraph",
    priority: 1e3,
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    group: "block",
    content: "inline*",
    parseHTML() {
      return [
        { tag: "p" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setParagraph: () => ({ commands: commands2 }) => {
          return commands2.setNode(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Alt-0": () => this.editor.commands.setParagraph()
      };
    }
  });

  // node_modules/@tiptap/extension-strike/dist/index.js
  var inputRegex5 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/;
  var pasteRegex2 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g;
  var Strike = Mark2.create({
    name: "strike",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "s"
        },
        {
          tag: "del"
        },
        {
          tag: "strike"
        },
        {
          style: "text-decoration",
          consuming: false,
          getAttrs: (style2) => style2.includes("line-through") ? {} : false
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setStrike: () => ({ commands: commands2 }) => {
          return commands2.setMark(this.name);
        },
        toggleStrike: () => ({ commands: commands2 }) => {
          return commands2.toggleMark(this.name);
        },
        unsetStrike: () => ({ commands: commands2 }) => {
          return commands2.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      const shortcuts = {};
      if (isMacOS()) {
        shortcuts["Mod-Shift-s"] = () => this.editor.commands.toggleStrike();
      } else {
        shortcuts["Ctrl-Shift-s"] = () => this.editor.commands.toggleStrike();
      }
      return shortcuts;
    },
    addInputRules() {
      return [
        markInputRule({
          find: inputRegex5,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: pasteRegex2,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-text/dist/index.js
  var Text = Node2.create({
    name: "text",
    group: "inline"
  });

  // node_modules/@tiptap/starter-kit/dist/index.js
  var StarterKit = Extension.create({
    name: "starterKit",
    addExtensions() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
      const extensions2 = [];
      if (this.options.blockquote !== false) {
        extensions2.push(Blockquote.configure((_a = this.options) === null || _a === void 0 ? void 0 : _a.blockquote));
      }
      if (this.options.bold !== false) {
        extensions2.push(Bold.configure((_b = this.options) === null || _b === void 0 ? void 0 : _b.bold));
      }
      if (this.options.bulletList !== false) {
        extensions2.push(BulletList.configure((_c = this.options) === null || _c === void 0 ? void 0 : _c.bulletList));
      }
      if (this.options.code !== false) {
        extensions2.push(Code.configure((_d = this.options) === null || _d === void 0 ? void 0 : _d.code));
      }
      if (this.options.codeBlock !== false) {
        extensions2.push(CodeBlock.configure((_e = this.options) === null || _e === void 0 ? void 0 : _e.codeBlock));
      }
      if (this.options.document !== false) {
        extensions2.push(Document.configure((_f = this.options) === null || _f === void 0 ? void 0 : _f.document));
      }
      if (this.options.dropcursor !== false) {
        extensions2.push(Dropcursor.configure((_g = this.options) === null || _g === void 0 ? void 0 : _g.dropcursor));
      }
      if (this.options.gapcursor !== false) {
        extensions2.push(Gapcursor.configure((_h = this.options) === null || _h === void 0 ? void 0 : _h.gapcursor));
      }
      if (this.options.hardBreak !== false) {
        extensions2.push(HardBreak.configure((_j = this.options) === null || _j === void 0 ? void 0 : _j.hardBreak));
      }
      if (this.options.heading !== false) {
        extensions2.push(Heading.configure((_k = this.options) === null || _k === void 0 ? void 0 : _k.heading));
      }
      if (this.options.history !== false) {
        extensions2.push(History.configure((_l = this.options) === null || _l === void 0 ? void 0 : _l.history));
      }
      if (this.options.horizontalRule !== false) {
        extensions2.push(HorizontalRule.configure((_m = this.options) === null || _m === void 0 ? void 0 : _m.horizontalRule));
      }
      if (this.options.italic !== false) {
        extensions2.push(Italic.configure((_o = this.options) === null || _o === void 0 ? void 0 : _o.italic));
      }
      if (this.options.listItem !== false) {
        extensions2.push(ListItem2.configure((_p = this.options) === null || _p === void 0 ? void 0 : _p.listItem));
      }
      if (this.options.orderedList !== false) {
        extensions2.push(OrderedList.configure((_q = this.options) === null || _q === void 0 ? void 0 : _q.orderedList));
      }
      if (this.options.paragraph !== false) {
        extensions2.push(Paragraph.configure((_r = this.options) === null || _r === void 0 ? void 0 : _r.paragraph));
      }
      if (this.options.strike !== false) {
        extensions2.push(Strike.configure((_s = this.options) === null || _s === void 0 ? void 0 : _s.strike));
      }
      if (this.options.text !== false) {
        extensions2.push(Text.configure((_t = this.options) === null || _t === void 0 ? void 0 : _t.text));
      }
      return extensions2;
    }
  });

  // node_modules/@popperjs/core/lib/enums.js
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  // node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindow.js
  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }

  // node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  // node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style2 = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style2 = styleProperties.reduce(function(style3, property) {
          style3[property] = "";
          return style3;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style2);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect,
    requires: ["computeStyles"]
  };

  // node_modules/@popperjs/core/lib/utils/getBasePlacement.js
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }

  // node_modules/@popperjs/core/lib/utils/math.js
  var max = Math.max;
  var min = Math.min;
  var round = Math.round;

  // node_modules/@popperjs/core/lib/utils/userAgent.js
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }

  // node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }

  // node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect2 = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round(clientRect2.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round(clientRect2.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect2.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect2.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect2.width / scaleX;
    var height = clientRect2.height / scaleY;
    return {
      width,
      height,
      top: y,
      right: x + width,
      bottom: y + height,
      left: x,
      x,
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  function getLayoutRect(element) {
    var clientRect2 = getBoundingClientRect(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect2.width - width) <= 1) {
      width = clientRect2.width;
    }
    if (Math.abs(clientRect2.height - height) <= 1) {
      height = clientRect2.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/contains.js
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;
      do {
        if (next && parent.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
    return false;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
  function getComputedStyle2(element) {
    return getWindow(element).getComputedStyle(element);
  }

  // node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element.document
    )) || window.document).documentElement;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element)
    );
  }

  // node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle2(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle2(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle2(currentNode);
      if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }

  // node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }

  // node_modules/@popperjs/core/lib/utils/within.js
  function within(min2, value, max2) {
    return max(min2, min(value, max2));
  }
  function withinMaxClamp(min2, value, max2) {
    var v = within(min2, value, max2);
    return v > max2 ? max2 : v;
  }

  // node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  // node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  // node_modules/@popperjs/core/lib/utils/expandToHashMap.js
  function expandToHashMap(value, keys2) {
    return keys2.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  // node_modules/@popperjs/core/lib/modifiers/arrow.js
  var toPaddingObject = function toPaddingObject2(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  };
  function arrow2(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
  function effect2(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      return;
    }
    state.elements.arrow = arrowElement;
  }
  var arrow_default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow2,
    effect: effect2,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  // node_modules/@popperjs/core/lib/utils/getVariation.js
  function getVariation(placement) {
    return placement.split("-")[1];
  }

  // node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref, win) {
    var x = _ref.x, y = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x * dpr) / dpr || 0,
      y: round(y * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp]
        );
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp]
        );
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x,
      y
    }, getWindow(popper2)) : {
      x,
      y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };

  // node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  var passive = {
    passive: true
  };
  function effect3(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect: effect3,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
  var hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash[matched];
    });
  }

  // node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
  var hash2 = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash2[matched];
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === "fixed") {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x + getWindowScrollBarX(element),
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;
    if (getComputedStyle2(body || html).direction === "rtl") {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  // node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }

  // node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)))
    );
  }

  // node_modules/@popperjs/core/lib/utils/rectToClientRect.js
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  // node_modules/@popperjs/core/lib/utils/computeOffsets.js
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }

  // node_modules/@popperjs/core/lib/utils/detectOverflow.js
  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset2 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset2[axis] * multiply;
      });
    }
    return overflowOffsets;
  }

  // node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements2.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements2;
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b) {
      return overflows[a] - overflows[b];
    });
  }

  // node_modules/@popperjs/core/lib/modifiers/flip.js
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i = 0; i < placements2.length; i++) {
      var placement = placements2[i];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break")
          break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  var flip_default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };

  // node_modules/@popperjs/core/lib/modifiers/hide.js
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide_default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };

  // node_modules/@popperjs/core/lib/modifiers/offset.js
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data;
  }
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };

  // node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getAltAxis.js
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }

  // node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset2 = popperOffsets2[mainAxis];
      var min2 = offset2 + overflow[mainSide];
      var max2 = offset2 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset2 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  }
  var preventOverflow_default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };

  // node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  // node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  // node_modules/@popperjs/core/lib/utils/orderModifiers.js
  function order(modifiers2) {
    var map2 = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers2.forEach(function(modifier) {
      map2.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map2.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers2.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers2) {
    var orderedModifiers = order(modifiers2);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  // node_modules/@popperjs/core/lib/utils/debounce.js
  function debounce(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn2());
          });
        });
      }
      return pending;
    };
  }

  // node_modules/@popperjs/core/lib/utils/mergeByName.js
  function mergeByName(modifiers2) {
    var merged = modifiers2.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }

  // node_modules/@popperjs/core/lib/createPopper.js
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference2, popper2, options) {
      if (options === void 0) {
        options = defaultOptions;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m) {
            return m.enabled;
          });
          runModifierEffects();
          return instance.update();
        },
        // Sync update – it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name,
                instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update – it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function() {
          return new Promise(function(resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        return instance;
      }
      instance.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref) {
          var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect5 = _ref.effect;
          if (typeof effect5 === "function") {
            var cleanupFn = effect5({
              state,
              name,
              instance,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }

  // node_modules/@popperjs/core/lib/popper.js
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });

  // node_modules/tippy.js/dist/tippy.esm.js
  var BOX_CLASS = "tippy-box";
  var CONTENT_CLASS = "tippy-content";
  var BACKDROP_CLASS = "tippy-backdrop";
  var ARROW_CLASS = "tippy-arrow";
  var SVG_ARROW_CLASS = "tippy-svg-arrow";
  var TOUCH_OPTIONS = {
    passive: true,
    capture: true
  };
  var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
    return document.body;
  };
  function hasOwnProperty(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  }
  function getValueAtIndexOrReturn(value, index, defaultValue) {
    if (Array.isArray(value)) {
      var v = value[index];
      return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
    }
    return value;
  }
  function isType(value, type) {
    var str = {}.toString.call(value);
    return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
  }
  function invokeWithArgsOrReturn(value, args) {
    return typeof value === "function" ? value.apply(void 0, args) : value;
  }
  function debounce2(fn2, ms) {
    if (ms === 0) {
      return fn2;
    }
    var timeout;
    return function(arg) {
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        fn2(arg);
      }, ms);
    };
  }
  function removeProperties(obj, keys2) {
    var clone = Object.assign({}, obj);
    keys2.forEach(function(key) {
      delete clone[key];
    });
    return clone;
  }
  function splitBySpaces(value) {
    return value.split(/\s+/).filter(Boolean);
  }
  function normalizeToArray(value) {
    return [].concat(value);
  }
  function pushIfUnique(arr, value) {
    if (arr.indexOf(value) === -1) {
      arr.push(value);
    }
  }
  function unique(arr) {
    return arr.filter(function(item, index) {
      return arr.indexOf(item) === index;
    });
  }
  function getBasePlacement2(placement) {
    return placement.split("-")[0];
  }
  function arrayFrom(value) {
    return [].slice.call(value);
  }
  function removeUndefinedProps(obj) {
    return Object.keys(obj).reduce(function(acc, key) {
      if (obj[key] !== void 0) {
        acc[key] = obj[key];
      }
      return acc;
    }, {});
  }
  function div() {
    return document.createElement("div");
  }
  function isElement2(value) {
    return ["Element", "Fragment"].some(function(type) {
      return isType(value, type);
    });
  }
  function isNodeList(value) {
    return isType(value, "NodeList");
  }
  function isMouseEvent(value) {
    return isType(value, "MouseEvent");
  }
  function isReferenceElement(value) {
    return !!(value && value._tippy && value._tippy.reference === value);
  }
  function getArrayOfElements(value) {
    if (isElement2(value)) {
      return [value];
    }
    if (isNodeList(value)) {
      return arrayFrom(value);
    }
    if (Array.isArray(value)) {
      return value;
    }
    return arrayFrom(document.querySelectorAll(value));
  }
  function setTransitionDuration(els, value) {
    els.forEach(function(el) {
      if (el) {
        el.style.transitionDuration = value + "ms";
      }
    });
  }
  function setVisibilityState(els, state) {
    els.forEach(function(el) {
      if (el) {
        el.setAttribute("data-state", state);
      }
    });
  }
  function getOwnerDocument(elementOrElements) {
    var _element$ownerDocumen;
    var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
    return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
  }
  function isCursorOutsideInteractiveBorder(popperTreeData, event) {
    var clientX = event.clientX, clientY = event.clientY;
    return popperTreeData.every(function(_ref) {
      var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
      var interactiveBorder = props.interactiveBorder;
      var basePlacement = getBasePlacement2(popperState.placement);
      var offsetData = popperState.modifiersData.offset;
      if (!offsetData) {
        return true;
      }
      var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
      var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
      var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
      var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
      var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
      var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
      var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
      var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
      return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
    });
  }
  function updateTransitionEndListener(box, action, listener) {
    var method = action + "EventListener";
    ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
      box[method](event, listener);
    });
  }
  function actualContains(parent, child) {
    var target = child;
    while (target) {
      var _target$getRootNode;
      if (parent.contains(target)) {
        return true;
      }
      target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
    }
    return false;
  }
  var currentInput = {
    isTouch: false
  };
  var lastMouseMoveTime = 0;
  function onDocumentTouchStart() {
    if (currentInput.isTouch) {
      return;
    }
    currentInput.isTouch = true;
    if (window.performance) {
      document.addEventListener("mousemove", onDocumentMouseMove);
    }
  }
  function onDocumentMouseMove() {
    var now = performance.now();
    if (now - lastMouseMoveTime < 20) {
      currentInput.isTouch = false;
      document.removeEventListener("mousemove", onDocumentMouseMove);
    }
    lastMouseMoveTime = now;
  }
  function onWindowBlur() {
    var activeElement = document.activeElement;
    if (isReferenceElement(activeElement)) {
      var instance = activeElement._tippy;
      if (activeElement.blur && !instance.state.isVisible) {
        activeElement.blur();
      }
    }
  }
  function bindGlobalEventListeners() {
    document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
    window.addEventListener("blur", onWindowBlur);
  }
  var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
  var isIE11 = isBrowser ? (
    // @ts-ignore
    !!window.msCrypto
  ) : false;
  function createMemoryLeakWarning(method) {
    var txt = method === "destroy" ? "n already-" : " ";
    return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
  }
  function clean(value) {
    var spacesAndTabs = /[ \t]{2,}/g;
    var lineStartWithSpaces = /^[ \t]*/gm;
    return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
  }
  function getDevMessage(message) {
    return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\u{1F477}\u200D This is a development-only message. It will be removed in production.\n  ");
  }
  function getFormattedMessage(message) {
    return [
      getDevMessage(message),
      // title
      "color: #00C584; font-size: 1.3em; font-weight: bold;",
      // message
      "line-height: 1.5",
      // footer
      "color: #a6a095;"
    ];
  }
  var visitedMessages;
  if (true) {
    resetVisitedMessages();
  }
  function resetVisitedMessages() {
    visitedMessages = /* @__PURE__ */ new Set();
  }
  function warnWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
      var _console;
      visitedMessages.add(message);
      (_console = console).warn.apply(_console, getFormattedMessage(message));
    }
  }
  function errorWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
      var _console2;
      visitedMessages.add(message);
      (_console2 = console).error.apply(_console2, getFormattedMessage(message));
    }
  }
  function validateTargets(targets) {
    var didPassFalsyValue = !targets;
    var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
    errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
    errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
  }
  var pluginProps = {
    animateFill: false,
    followCursor: false,
    inlinePositioning: false,
    sticky: false
  };
  var renderProps = {
    allowHTML: false,
    animation: "fade",
    arrow: true,
    content: "",
    inertia: false,
    maxWidth: 350,
    role: "tooltip",
    theme: "",
    zIndex: 9999
  };
  var defaultProps = Object.assign({
    appendTo: TIPPY_DEFAULT_APPEND_TO,
    aria: {
      content: "auto",
      expanded: "auto"
    },
    delay: 0,
    duration: [300, 250],
    getReferenceClientRect: null,
    hideOnClick: true,
    ignoreAttributes: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: "",
    offset: [0, 10],
    onAfterUpdate: function onAfterUpdate() {
    },
    onBeforeUpdate: function onBeforeUpdate() {
    },
    onCreate: function onCreate() {
    },
    onDestroy: function onDestroy() {
    },
    onHidden: function onHidden() {
    },
    onHide: function onHide() {
    },
    onMount: function onMount() {
    },
    onShow: function onShow() {
    },
    onShown: function onShown() {
    },
    onTrigger: function onTrigger() {
    },
    onUntrigger: function onUntrigger() {
    },
    onClickOutside: function onClickOutside() {
    },
    placement: "top",
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: false,
    touch: true,
    trigger: "mouseenter focus",
    triggerTarget: null
  }, pluginProps, renderProps);
  var defaultKeys = Object.keys(defaultProps);
  var setDefaultProps = function setDefaultProps2(partialProps) {
    if (true) {
      validateProps(partialProps, []);
    }
    var keys2 = Object.keys(partialProps);
    keys2.forEach(function(key) {
      defaultProps[key] = partialProps[key];
    });
  };
  function getExtendedPassedProps(passedProps) {
    var plugins = passedProps.plugins || [];
    var pluginProps2 = plugins.reduce(function(acc, plugin) {
      var name = plugin.name, defaultValue = plugin.defaultValue;
      if (name) {
        var _name;
        acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
      }
      return acc;
    }, {});
    return Object.assign({}, passedProps, pluginProps2);
  }
  function getDataAttributeProps(reference2, plugins) {
    var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
      plugins
    }))) : defaultKeys;
    var props = propKeys.reduce(function(acc, key) {
      var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
      if (!valueAsString) {
        return acc;
      }
      if (key === "content") {
        acc[key] = valueAsString;
      } else {
        try {
          acc[key] = JSON.parse(valueAsString);
        } catch (e) {
          acc[key] = valueAsString;
        }
      }
      return acc;
    }, {});
    return props;
  }
  function evaluateProps(reference2, props) {
    var out = Object.assign({}, props, {
      content: invokeWithArgsOrReturn(props.content, [reference2])
    }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
    out.aria = Object.assign({}, defaultProps.aria, out.aria);
    out.aria = {
      expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
      content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
    };
    return out;
  }
  function validateProps(partialProps, plugins) {
    if (partialProps === void 0) {
      partialProps = {};
    }
    if (plugins === void 0) {
      plugins = [];
    }
    var keys2 = Object.keys(partialProps);
    keys2.forEach(function(prop) {
      var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
      var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop);
      if (didPassUnknownProp) {
        didPassUnknownProp = plugins.filter(function(plugin) {
          return plugin.name === prop;
        }).length === 0;
      }
      warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
    });
  }
  var innerHTML = function innerHTML2() {
    return "innerHTML";
  };
  function dangerouslySetInnerHTML(element, html) {
    element[innerHTML()] = html;
  }
  function createArrowElement(value) {
    var arrow3 = div();
    if (value === true) {
      arrow3.className = ARROW_CLASS;
    } else {
      arrow3.className = SVG_ARROW_CLASS;
      if (isElement2(value)) {
        arrow3.appendChild(value);
      } else {
        dangerouslySetInnerHTML(arrow3, value);
      }
    }
    return arrow3;
  }
  function setContent2(content, props) {
    if (isElement2(props.content)) {
      dangerouslySetInnerHTML(content, "");
      content.appendChild(props.content);
    } else if (typeof props.content !== "function") {
      if (props.allowHTML) {
        dangerouslySetInnerHTML(content, props.content);
      } else {
        content.textContent = props.content;
      }
    }
  }
  function getChildren(popper2) {
    var box = popper2.firstElementChild;
    var boxChildren = arrayFrom(box.children);
    return {
      box,
      content: boxChildren.find(function(node) {
        return node.classList.contains(CONTENT_CLASS);
      }),
      arrow: boxChildren.find(function(node) {
        return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
      }),
      backdrop: boxChildren.find(function(node) {
        return node.classList.contains(BACKDROP_CLASS);
      })
    };
  }
  function render(instance) {
    var popper2 = div();
    var box = div();
    box.className = BOX_CLASS;
    box.setAttribute("data-state", "hidden");
    box.setAttribute("tabindex", "-1");
    var content = div();
    content.className = CONTENT_CLASS;
    content.setAttribute("data-state", "hidden");
    setContent2(content, instance.props);
    popper2.appendChild(box);
    box.appendChild(content);
    onUpdate(instance.props, instance.props);
    function onUpdate(prevProps, nextProps) {
      var _getChildren = getChildren(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow3 = _getChildren.arrow;
      if (nextProps.theme) {
        box2.setAttribute("data-theme", nextProps.theme);
      } else {
        box2.removeAttribute("data-theme");
      }
      if (typeof nextProps.animation === "string") {
        box2.setAttribute("data-animation", nextProps.animation);
      } else {
        box2.removeAttribute("data-animation");
      }
      if (nextProps.inertia) {
        box2.setAttribute("data-inertia", "");
      } else {
        box2.removeAttribute("data-inertia");
      }
      box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
      if (nextProps.role) {
        box2.setAttribute("role", nextProps.role);
      } else {
        box2.removeAttribute("role");
      }
      if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
        setContent2(content2, instance.props);
      }
      if (nextProps.arrow) {
        if (!arrow3) {
          box2.appendChild(createArrowElement(nextProps.arrow));
        } else if (prevProps.arrow !== nextProps.arrow) {
          box2.removeChild(arrow3);
          box2.appendChild(createArrowElement(nextProps.arrow));
        }
      } else if (arrow3) {
        box2.removeChild(arrow3);
      }
    }
    return {
      popper: popper2,
      onUpdate
    };
  }
  render.$$tippy = true;
  var idCounter = 1;
  var mouseMoveListeners = [];
  var mountedInstances = [];
  function createTippy(reference2, passedProps) {
    var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
    var showTimeout;
    var hideTimeout;
    var scheduleHideAnimationFrame;
    var isVisibleFromClick = false;
    var didHideDueToDocumentMouseDown = false;
    var didTouchMove = false;
    var ignoreOnFirstUpdate = false;
    var lastTriggerEvent;
    var currentTransitionEndListener;
    var onFirstUpdate;
    var listeners = [];
    var debouncedOnMouseMove = debounce2(onMouseMove, props.interactiveDebounce);
    var currentTarget;
    var id = idCounter++;
    var popperInstance = null;
    var plugins = unique(props.plugins);
    var state = {
      // Is the instance currently enabled?
      isEnabled: true,
      // Is the tippy currently showing and not transitioning out?
      isVisible: false,
      // Has the instance been destroyed?
      isDestroyed: false,
      // Is the tippy currently mounted to the DOM?
      isMounted: false,
      // Has the tippy finished transitioning in?
      isShown: false
    };
    var instance = {
      // properties
      id,
      reference: reference2,
      popper: div(),
      popperInstance,
      props,
      state,
      plugins,
      // methods
      clearDelayTimeouts,
      setProps,
      setContent: setContent3,
      show,
      hide: hide2,
      hideWithInteractivity,
      enable,
      disable,
      unmount,
      destroy
    };
    if (!props.render) {
      if (true) {
        errorWhen(true, "render() function has not been supplied.");
      }
      return instance;
    }
    var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
    popper2.setAttribute("data-tippy-root", "");
    popper2.id = "tippy-" + instance.id;
    instance.popper = popper2;
    reference2._tippy = instance;
    popper2._tippy = instance;
    var pluginsHooks = plugins.map(function(plugin) {
      return plugin.fn(instance);
    });
    var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
    addListeners();
    handleAriaExpandedAttribute();
    handleStyles();
    invokeHook("onCreate", [instance]);
    if (props.showOnCreate) {
      scheduleShow();
    }
    popper2.addEventListener("mouseenter", function() {
      if (instance.props.interactive && instance.state.isVisible) {
        instance.clearDelayTimeouts();
      }
    });
    popper2.addEventListener("mouseleave", function() {
      if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
        getDocument().addEventListener("mousemove", debouncedOnMouseMove);
      }
    });
    return instance;
    function getNormalizedTouchSettings() {
      var touch = instance.props.touch;
      return Array.isArray(touch) ? touch : [touch, 0];
    }
    function getIsCustomTouchBehavior() {
      return getNormalizedTouchSettings()[0] === "hold";
    }
    function getIsDefaultRenderFn() {
      var _instance$props$rende;
      return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
    }
    function getCurrentTarget() {
      return currentTarget || reference2;
    }
    function getDocument() {
      var parent = getCurrentTarget().parentNode;
      return parent ? getOwnerDocument(parent) : document;
    }
    function getDefaultTemplateChildren() {
      return getChildren(popper2);
    }
    function getDelay(isShow) {
      if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
        return 0;
      }
      return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
    }
    function handleStyles(fromHide) {
      if (fromHide === void 0) {
        fromHide = false;
      }
      popper2.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
      popper2.style.zIndex = "" + instance.props.zIndex;
    }
    function invokeHook(hook, args, shouldInvokePropsHook) {
      if (shouldInvokePropsHook === void 0) {
        shouldInvokePropsHook = true;
      }
      pluginsHooks.forEach(function(pluginHooks) {
        if (pluginHooks[hook]) {
          pluginHooks[hook].apply(pluginHooks, args);
        }
      });
      if (shouldInvokePropsHook) {
        var _instance$props;
        (_instance$props = instance.props)[hook].apply(_instance$props, args);
      }
    }
    function handleAriaContentAttribute() {
      var aria = instance.props.aria;
      if (!aria.content) {
        return;
      }
      var attr = "aria-" + aria.content;
      var id2 = popper2.id;
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node) {
        var currentValue = node.getAttribute(attr);
        if (instance.state.isVisible) {
          node.setAttribute(attr, currentValue ? currentValue + " " + id2 : id2);
        } else {
          var nextValue = currentValue && currentValue.replace(id2, "").trim();
          if (nextValue) {
            node.setAttribute(attr, nextValue);
          } else {
            node.removeAttribute(attr);
          }
        }
      });
    }
    function handleAriaExpandedAttribute() {
      if (hasAriaExpanded || !instance.props.aria.expanded) {
        return;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node) {
        if (instance.props.interactive) {
          node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false");
        } else {
          node.removeAttribute("aria-expanded");
        }
      });
    }
    function cleanupInteractiveMouseListeners() {
      getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
      mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
        return listener !== debouncedOnMouseMove;
      });
    }
    function onDocumentPress(event) {
      if (currentInput.isTouch) {
        if (didTouchMove || event.type === "mousedown") {
          return;
        }
      }
      var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
      if (instance.props.interactive && actualContains(popper2, actualTarget)) {
        return;
      }
      if (normalizeToArray(instance.props.triggerTarget || reference2).some(function(el) {
        return actualContains(el, actualTarget);
      })) {
        if (currentInput.isTouch) {
          return;
        }
        if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
          return;
        }
      } else {
        invokeHook("onClickOutside", [instance, event]);
      }
      if (instance.props.hideOnClick === true) {
        instance.clearDelayTimeouts();
        instance.hide();
        didHideDueToDocumentMouseDown = true;
        setTimeout(function() {
          didHideDueToDocumentMouseDown = false;
        });
        if (!instance.state.isMounted) {
          removeDocumentPress();
        }
      }
    }
    function onTouchMove() {
      didTouchMove = true;
    }
    function onTouchStart() {
      didTouchMove = false;
    }
    function addDocumentPress() {
      var doc3 = getDocument();
      doc3.addEventListener("mousedown", onDocumentPress, true);
      doc3.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
      doc3.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
      doc3.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function removeDocumentPress() {
      var doc3 = getDocument();
      doc3.removeEventListener("mousedown", onDocumentPress, true);
      doc3.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
      doc3.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
      doc3.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function onTransitionedOut(duration, callback) {
      onTransitionEnd(duration, function() {
        if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
          callback();
        }
      });
    }
    function onTransitionedIn(duration, callback) {
      onTransitionEnd(duration, callback);
    }
    function onTransitionEnd(duration, callback) {
      var box = getDefaultTemplateChildren().box;
      function listener(event) {
        if (event.target === box) {
          updateTransitionEndListener(box, "remove", listener);
          callback();
        }
      }
      if (duration === 0) {
        return callback();
      }
      updateTransitionEndListener(box, "remove", currentTransitionEndListener);
      updateTransitionEndListener(box, "add", listener);
      currentTransitionEndListener = listener;
    }
    function on(eventType, handler, options) {
      if (options === void 0) {
        options = false;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node) {
        node.addEventListener(eventType, handler, options);
        listeners.push({
          node,
          eventType,
          handler,
          options
        });
      });
    }
    function addListeners() {
      if (getIsCustomTouchBehavior()) {
        on("touchstart", onTrigger2, {
          passive: true
        });
        on("touchend", onMouseLeave, {
          passive: true
        });
      }
      splitBySpaces(instance.props.trigger).forEach(function(eventType) {
        if (eventType === "manual") {
          return;
        }
        on(eventType, onTrigger2);
        switch (eventType) {
          case "mouseenter":
            on("mouseleave", onMouseLeave);
            break;
          case "focus":
            on(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
            break;
          case "focusin":
            on("focusout", onBlurOrFocusOut);
            break;
        }
      });
    }
    function removeListeners() {
      listeners.forEach(function(_ref) {
        var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
        node.removeEventListener(eventType, handler, options);
      });
      listeners = [];
    }
    function onTrigger2(event) {
      var _lastTriggerEvent;
      var shouldScheduleClickHide = false;
      if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
        return;
      }
      var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
      lastTriggerEvent = event;
      currentTarget = event.currentTarget;
      handleAriaExpandedAttribute();
      if (!instance.state.isVisible && isMouseEvent(event)) {
        mouseMoveListeners.forEach(function(listener) {
          return listener(event);
        });
      }
      if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
        shouldScheduleClickHide = true;
      } else {
        scheduleShow(event);
      }
      if (event.type === "click") {
        isVisibleFromClick = !shouldScheduleClickHide;
      }
      if (shouldScheduleClickHide && !wasFocused) {
        scheduleHide(event);
      }
    }
    function onMouseMove(event) {
      var target = event.target;
      var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
      if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
        return;
      }
      var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
        var _instance$popperInsta;
        var instance2 = popper3._tippy;
        var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
        if (state2) {
          return {
            popperRect: popper3.getBoundingClientRect(),
            popperState: state2,
            props
          };
        }
        return null;
      }).filter(Boolean);
      if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
        cleanupInteractiveMouseListeners();
        scheduleHide(event);
      }
    }
    function onMouseLeave(event) {
      var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
      if (shouldBail) {
        return;
      }
      if (instance.props.interactive) {
        instance.hideWithInteractivity(event);
        return;
      }
      scheduleHide(event);
    }
    function onBlurOrFocusOut(event) {
      if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
        return;
      }
      if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
        return;
      }
      scheduleHide(event);
    }
    function isEventListenerStopped(event) {
      return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
    }
    function createPopperInstance() {
      destroyPopperInstance();
      var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset2 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
      var arrow3 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
      var computedReference = getReferenceClientRect ? {
        getBoundingClientRect: getReferenceClientRect,
        contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
      } : reference2;
      var tippyModifier = {
        name: "$$tippy",
        enabled: true,
        phase: "beforeWrite",
        requires: ["computeStyles"],
        fn: function fn2(_ref2) {
          var state2 = _ref2.state;
          if (getIsDefaultRenderFn()) {
            var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
            ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
              if (attr === "placement") {
                box.setAttribute("data-placement", state2.placement);
              } else {
                if (state2.attributes.popper["data-popper-" + attr]) {
                  box.setAttribute("data-" + attr, "");
                } else {
                  box.removeAttribute("data-" + attr);
                }
              }
            });
            state2.attributes.popper = {};
          }
        }
      };
      var modifiers2 = [{
        name: "offset",
        options: {
          offset: offset2
        }
      }, {
        name: "preventOverflow",
        options: {
          padding: {
            top: 2,
            bottom: 2,
            left: 5,
            right: 5
          }
        }
      }, {
        name: "flip",
        options: {
          padding: 5
        }
      }, {
        name: "computeStyles",
        options: {
          adaptive: !moveTransition
        }
      }, tippyModifier];
      if (getIsDefaultRenderFn() && arrow3) {
        modifiers2.push({
          name: "arrow",
          options: {
            element: arrow3,
            padding: 3
          }
        });
      }
      modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
      instance.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
        placement,
        onFirstUpdate,
        modifiers: modifiers2
      }));
    }
    function destroyPopperInstance() {
      if (instance.popperInstance) {
        instance.popperInstance.destroy();
        instance.popperInstance = null;
      }
    }
    function mount() {
      var appendTo = instance.props.appendTo;
      var parentNode2;
      var node = getCurrentTarget();
      if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
        parentNode2 = node.parentNode;
      } else {
        parentNode2 = invokeWithArgsOrReturn(appendTo, [node]);
      }
      if (!parentNode2.contains(popper2)) {
        parentNode2.appendChild(popper2);
      }
      instance.state.isMounted = true;
      createPopperInstance();
      if (true) {
        warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper2, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
      }
    }
    function getNestedPopperTree() {
      return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
    }
    function scheduleShow(event) {
      instance.clearDelayTimeouts();
      if (event) {
        invokeHook("onTrigger", [instance, event]);
      }
      addDocumentPress();
      var delay = getDelay(true);
      var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
      if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
        delay = touchDelay;
      }
      if (delay) {
        showTimeout = setTimeout(function() {
          instance.show();
        }, delay);
      } else {
        instance.show();
      }
    }
    function scheduleHide(event) {
      instance.clearDelayTimeouts();
      invokeHook("onUntrigger", [instance, event]);
      if (!instance.state.isVisible) {
        removeDocumentPress();
        return;
      }
      if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
        return;
      }
      var delay = getDelay(false);
      if (delay) {
        hideTimeout = setTimeout(function() {
          if (instance.state.isVisible) {
            instance.hide();
          }
        }, delay);
      } else {
        scheduleHideAnimationFrame = requestAnimationFrame(function() {
          instance.hide();
        });
      }
    }
    function enable() {
      instance.state.isEnabled = true;
    }
    function disable() {
      instance.hide();
      instance.state.isEnabled = false;
    }
    function clearDelayTimeouts() {
      clearTimeout(showTimeout);
      clearTimeout(hideTimeout);
      cancelAnimationFrame(scheduleHideAnimationFrame);
    }
    function setProps(partialProps) {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("setProps"));
      }
      if (instance.state.isDestroyed) {
        return;
      }
      invokeHook("onBeforeUpdate", [instance, partialProps]);
      removeListeners();
      var prevProps = instance.props;
      var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
        ignoreAttributes: true
      }));
      instance.props = nextProps;
      addListeners();
      if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
        cleanupInteractiveMouseListeners();
        debouncedOnMouseMove = debounce2(onMouseMove, nextProps.interactiveDebounce);
      }
      if (prevProps.triggerTarget && !nextProps.triggerTarget) {
        normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
          node.removeAttribute("aria-expanded");
        });
      } else if (nextProps.triggerTarget) {
        reference2.removeAttribute("aria-expanded");
      }
      handleAriaExpandedAttribute();
      handleStyles();
      if (onUpdate) {
        onUpdate(prevProps, nextProps);
      }
      if (instance.popperInstance) {
        createPopperInstance();
        getNestedPopperTree().forEach(function(nestedPopper) {
          requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
        });
      }
      invokeHook("onAfterUpdate", [instance, partialProps]);
    }
    function setContent3(content) {
      instance.setProps({
        content
      });
    }
    function show() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("show"));
      }
      var isAlreadyVisible = instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
      if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
        return;
      }
      if (getCurrentTarget().hasAttribute("disabled")) {
        return;
      }
      invokeHook("onShow", [instance], false);
      if (instance.props.onShow(instance) === false) {
        return;
      }
      instance.state.isVisible = true;
      if (getIsDefaultRenderFn()) {
        popper2.style.visibility = "visible";
      }
      handleStyles();
      addDocumentPress();
      if (!instance.state.isMounted) {
        popper2.style.transition = "none";
      }
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
        setTransitionDuration([box, content], 0);
      }
      onFirstUpdate = function onFirstUpdate2() {
        var _instance$popperInsta2;
        if (!instance.state.isVisible || ignoreOnFirstUpdate) {
          return;
        }
        ignoreOnFirstUpdate = true;
        void popper2.offsetHeight;
        popper2.style.transition = instance.props.moveTransition;
        if (getIsDefaultRenderFn() && instance.props.animation) {
          var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
          setTransitionDuration([_box, _content], duration);
          setVisibilityState([_box, _content], "visible");
        }
        handleAriaContentAttribute();
        handleAriaExpandedAttribute();
        pushIfUnique(mountedInstances, instance);
        (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
        invokeHook("onMount", [instance]);
        if (instance.props.animation && getIsDefaultRenderFn()) {
          onTransitionedIn(duration, function() {
            instance.state.isShown = true;
            invokeHook("onShown", [instance]);
          });
        }
      };
      mount();
    }
    function hide2() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hide"));
      }
      var isAlreadyHidden = !instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
      if (isAlreadyHidden || isDestroyed || isDisabled) {
        return;
      }
      invokeHook("onHide", [instance], false);
      if (instance.props.onHide(instance) === false) {
        return;
      }
      instance.state.isVisible = false;
      instance.state.isShown = false;
      ignoreOnFirstUpdate = false;
      isVisibleFromClick = false;
      if (getIsDefaultRenderFn()) {
        popper2.style.visibility = "hidden";
      }
      cleanupInteractiveMouseListeners();
      removeDocumentPress();
      handleStyles(true);
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
        if (instance.props.animation) {
          setTransitionDuration([box, content], duration);
          setVisibilityState([box, content], "hidden");
        }
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      if (instance.props.animation) {
        if (getIsDefaultRenderFn()) {
          onTransitionedOut(duration, instance.unmount);
        }
      } else {
        instance.unmount();
      }
    }
    function hideWithInteractivity(event) {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
      }
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
      pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
      debouncedOnMouseMove(event);
    }
    function unmount() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("unmount"));
      }
      if (instance.state.isVisible) {
        instance.hide();
      }
      if (!instance.state.isMounted) {
        return;
      }
      destroyPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        nestedPopper._tippy.unmount();
      });
      if (popper2.parentNode) {
        popper2.parentNode.removeChild(popper2);
      }
      mountedInstances = mountedInstances.filter(function(i) {
        return i !== instance;
      });
      instance.state.isMounted = false;
      invokeHook("onHidden", [instance]);
    }
    function destroy() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("destroy"));
      }
      if (instance.state.isDestroyed) {
        return;
      }
      instance.clearDelayTimeouts();
      instance.unmount();
      removeListeners();
      delete reference2._tippy;
      instance.state.isDestroyed = true;
      invokeHook("onDestroy", [instance]);
    }
  }
  function tippy(targets, optionalProps) {
    if (optionalProps === void 0) {
      optionalProps = {};
    }
    var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
    if (true) {
      validateTargets(targets);
      validateProps(optionalProps, plugins);
    }
    bindGlobalEventListeners();
    var passedProps = Object.assign({}, optionalProps, {
      plugins
    });
    var elements = getArrayOfElements(targets);
    if (true) {
      var isSingleContentElement = isElement2(passedProps.content);
      var isMoreThanOneReferenceElement = elements.length > 1;
      warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
    }
    var instances = elements.reduce(function(acc, reference2) {
      var instance = reference2 && createTippy(reference2, passedProps);
      if (instance) {
        acc.push(instance);
      }
      return acc;
    }, []);
    return isElement2(targets) ? instances[0] : instances;
  }
  tippy.defaultProps = defaultProps;
  tippy.setDefaultProps = setDefaultProps;
  tippy.currentInput = currentInput;
  var applyStylesModifier = Object.assign({}, applyStyles_default, {
    effect: function effect4(_ref) {
      var state = _ref.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }
    }
  });
  tippy.setDefaultProps({
    render
  });
  var tippy_esm_default = tippy;

  // node_modules/@tiptap/extension-bubble-menu/dist/index.js
  var BubbleMenuView = class {
    constructor({ editor, element, view, tippyOptions = {}, updateDelay = 250, shouldShow }) {
      this.preventHide = false;
      this.shouldShow = ({ view: view2, state, from: from2, to }) => {
        const { doc: doc3, selection } = state;
        const { empty: empty2 } = selection;
        const isEmptyTextBlock = !doc3.textBetween(from2, to).length && isTextSelection(state.selection);
        const isChildOfMenu = this.element.contains(document.activeElement);
        const hasEditorFocus = view2.hasFocus() || isChildOfMenu;
        if (!hasEditorFocus || empty2 || isEmptyTextBlock || !this.editor.isEditable) {
          return false;
        }
        return true;
      };
      this.mousedownHandler = () => {
        this.preventHide = true;
      };
      this.dragstartHandler = () => {
        this.hide();
      };
      this.focusHandler = () => {
        setTimeout(() => this.update(this.editor.view));
      };
      this.blurHandler = ({ event }) => {
        var _a;
        if (this.preventHide) {
          this.preventHide = false;
          return;
        }
        if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
          return;
        }
        this.hide();
      };
      this.tippyBlurHandler = (event) => {
        this.blurHandler({ event });
      };
      this.handleDebouncedUpdate = (view2, oldState) => {
        const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view2.state.selection));
        const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view2.state.doc));
        if (!selectionChanged && !docChanged) {
          return;
        }
        if (this.updateDebounceTimer) {
          clearTimeout(this.updateDebounceTimer);
        }
        this.updateDebounceTimer = window.setTimeout(() => {
          this.updateHandler(view2, selectionChanged, docChanged, oldState);
        }, this.updateDelay);
      };
      this.updateHandler = (view2, selectionChanged, docChanged, oldState) => {
        var _a, _b, _c;
        const { state, composing } = view2;
        const { selection } = state;
        const isSame = !selectionChanged && !docChanged;
        if (composing || isSame) {
          return;
        }
        this.createTooltip();
        const { ranges } = selection;
        const from2 = Math.min(...ranges.map((range) => range.$from.pos));
        const to = Math.max(...ranges.map((range) => range.$to.pos));
        const shouldShow2 = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {
          editor: this.editor,
          view: view2,
          state,
          oldState,
          from: from2,
          to
        });
        if (!shouldShow2) {
          this.hide();
          return;
        }
        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
          getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => {
            if (isNodeSelection(state.selection)) {
              let node = view2.nodeDOM(from2);
              const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector("[data-node-view-wrapper]");
              if (nodeViewWrapper) {
                node = nodeViewWrapper.firstChild;
              }
              if (node) {
                return node.getBoundingClientRect();
              }
            }
            return posToDOMRect(view2, from2, to);
          })
        });
        this.show();
      };
      this.editor = editor;
      this.element = element;
      this.view = view;
      this.updateDelay = updateDelay;
      if (shouldShow) {
        this.shouldShow = shouldShow;
      }
      this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
      this.view.dom.addEventListener("dragstart", this.dragstartHandler);
      this.editor.on("focus", this.focusHandler);
      this.editor.on("blur", this.blurHandler);
      this.tippyOptions = tippyOptions;
      this.element.remove();
      this.element.style.visibility = "visible";
    }
    createTooltip() {
      const { element: editorElement } = this.editor.options;
      const editorIsAttached = !!editorElement.parentElement;
      if (this.tippy || !editorIsAttached) {
        return;
      }
      this.tippy = tippy_esm_default(editorElement, {
        duration: 0,
        getReferenceClientRect: null,
        content: this.element,
        interactive: true,
        trigger: "manual",
        placement: "top",
        hideOnClick: "toggle",
        ...this.tippyOptions
      });
      if (this.tippy.popper.firstChild) {
        this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler);
      }
    }
    update(view, oldState) {
      const { state } = view;
      const hasValidSelection = state.selection.$from.pos !== state.selection.$to.pos;
      if (this.updateDelay > 0 && hasValidSelection) {
        this.handleDebouncedUpdate(view, oldState);
        return;
      }
      const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));
      const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));
      this.updateHandler(view, selectionChanged, docChanged, oldState);
    }
    show() {
      var _a;
      (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
    }
    hide() {
      var _a;
      (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
    }
    destroy() {
      var _a, _b;
      if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {
        this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler);
      }
      (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();
      this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
      this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
      this.editor.off("focus", this.focusHandler);
      this.editor.off("blur", this.blurHandler);
    }
  };
  var BubbleMenuPlugin = (options) => {
    return new Plugin({
      key: typeof options.pluginKey === "string" ? new PluginKey(options.pluginKey) : options.pluginKey,
      view: (view) => new BubbleMenuView({ view, ...options })
    });
  };
  var BubbleMenu = Extension.create({
    name: "bubbleMenu",
    addOptions() {
      return {
        element: null,
        tippyOptions: {},
        pluginKey: "bubbleMenu",
        updateDelay: void 0,
        shouldShow: null
      };
    },
    addProseMirrorPlugins() {
      if (!this.options.element) {
        return [];
      }
      return [
        BubbleMenuPlugin({
          pluginKey: this.options.pluginKey,
          editor: this.editor,
          element: this.options.element,
          tippyOptions: this.options.tippyOptions,
          updateDelay: this.options.updateDelay,
          shouldShow: this.options.shouldShow
        })
      ];
    }
  });

  // packages/talltap/resources/js/index.js
  var config = {
    document: Document.extend({
      content: "heading block*"
    }),
    editorProps: {
      attributes: {
        class: "prose prose-sm sm:prose lg:prose-lg xl:prose-lg focus:outline-none"
      }
    }
  };
  document.addEventListener("alpine:init", () => {
    Alpine.data("talltap", (content, bubbleMenuActiveTrigger) => {
      const ref = "tallEditor";
      if (!window.talltap) {
        window.talltap = {};
      }
      let editor = window.talltap[ref];
      return {
        updatedAt: Date.now(),
        // force Alpine to rerender on selection change
        content,
        output: void 0,
        data: {},
        init() {
          const _this = this;
          if (editor !== void 0) {
            return;
          }
          editor = new Editor({
            element: this.$refs.tiptap,
            editorProps: config.editorProps,
            extensions: [
              config.document,
              ...window.talltapRegistry.getExtensions(),
              StarterKit.configure({
                codeBlock: false,
                document: false,
                dropcursor: {
                  color: "skyblue",
                  width: 2
                }
              }),
              BubbleMenu.configure({
                pluginKey: "talltap-bubble-menu",
                // @ts-ignore
                element: document.getElementById("bubbleMenu"),
                //this.$refs.bubbleMenu,
                shouldShow: ({ editor: editor2 }) => bubbleMenuActiveTrigger.some((trigger) => editor2.isActive(trigger) || trigger === "*" && !editor2.view.state.selection.empty)
              }),
              CharacterCount
            ],
            content,
            onCreate({ editor: editor2 }) {
              _this.updatedAt = Date.now();
              _this.createExternalData(editor2);
              _this.$dispatch("update");
            },
            onUpdate({ editor: editor2 }) {
              _this.updatedAt = Date.now();
              _this.updateExternalData(editor2);
              _this.$dispatch("update");
            },
            onSelectionUpdate({ editor: editor2 }) {
              _this.updatedAt = Date.now();
              _this.$dispatch("update");
            }
          });
          window.talltap[ref] = editor;
        },
        editor() {
          return editor;
        },
        createExternalData(editor2) {
          this.data.characterCount = editor2.storage.characterCount.characters();
        },
        updateExternalData(editor2) {
          this.data.characterCount = editor2.storage.characterCount.characters();
          this.content = editor2.getHTML();
          this.debounceOutput();
        },
        debounceOutput() {
          if (!this.output) {
            this.output = Alpine.debounce(
              () => {
                this.$wire.set("value", this.content);
                this.$dispatch("content-updated");
              },
              500
            );
            return;
          }
          this.output();
        },
        isActive(type, opts = {}) {
          return editor.isActive(type, opts);
        }
      };
    });
  });
})();
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29yZGVyZWRtYXAvZGlzdC9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItbW9kZWwvZGlzdC9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItdHJhbnNmb3JtL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXN0YXRlL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXZpZXcvZGlzdC9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvdzNjLWtleW5hbWUvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWtleW1hcC9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1jb21tYW5kcy9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1zY2hlbWEtbGlzdC9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY3JlYXRlQ2hhaW5hYmxlU3RhdGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvQ29tbWFuZE1hbmFnZXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvRXZlbnRFbWl0dGVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9zcGxpdEV4dGVuc2lvbnMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXROb2RlVHlwZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvbWVyZ2VBdHRyaWJ1dGVzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc0Z1bmN0aW9uLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzRW1wdHlPYmplY3QudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2Zyb21TdHJpbmcudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFNjaGVtYVR5cGVCeU5hbWUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0V4dGVuc2lvblJ1bGVzRW5hYmxlZC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFRleHRDb250ZW50RnJvbU5vZGVzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc1JlZ0V4cC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9JbnB1dFJ1bGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzTnVtYmVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL1Bhc3RlUnVsZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvZmluZER1cGxpY2F0ZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvRXh0ZW5zaW9uTWFuYWdlci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvaXNQbGFpbk9iamVjdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvbWVyZ2VEZWVwLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL0V4dGVuc2lvbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFRleHRCZXR3ZWVuLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2NsaXBib2FyZFRleHRTZXJpYWxpemVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2JsdXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvY2xlYXJDb250ZW50LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2NsZWFyTm9kZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvY29tbWFuZC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9jcmVhdGVQYXJhZ3JhcGhOZWFyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2N1dC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9kZWxldGVDdXJyZW50Tm9kZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9kZWxldGVOb2RlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2RlbGV0ZVJhbmdlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2RlbGV0ZVNlbGVjdGlvbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9lbnRlci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9leGl0Q29kZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvb2JqZWN0SW5jbHVkZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRNYXJrUmFuZ2UudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRNYXJrVHlwZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9leHRlbmRNYXJrUmFuZ2UudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvZmlyc3QudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc1RleHRTZWxlY3Rpb24udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL21pbk1heC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL3Jlc29sdmVGb2N1c1Bvc2l0aW9uLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc2lPUy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9mb2N1cy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9mb3JFYWNoLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2luc2VydENvbnRlbnQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2VsZW1lbnRGcm9tU3RyaW5nLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY3JlYXRlTm9kZUZyb21Db250ZW50LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvaW5zZXJ0Q29udGVudEF0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2pvaW4udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvam9pbkl0ZW1CYWNrd2FyZC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9qb2luSXRlbUZvcndhcmQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzTWFjT1MudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMva2V5Ym9hcmRTaG9ydGN1dC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzTm9kZUFjdGl2ZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9saWZ0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2xpZnRFbXB0eUJsb2NrLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2xpZnRMaXN0SXRlbS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9uZXdsaW5lSW5Db2RlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2RlbGV0ZVByb3BzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3Jlc2V0QXR0cmlidXRlcy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zY3JvbGxJbnRvVmlldy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZWxlY3RBbGwudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2VsZWN0Tm9kZUJhY2t3YXJkLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdE5vZGVGb3J3YXJkLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdFBhcmVudE5vZGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2VsZWN0VGV4dGJsb2NrRW5kLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdFRleHRibG9ja1N0YXJ0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY3JlYXRlRG9jdW1lbnQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2V0Q29udGVudC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldE1hcmtBdHRyaWJ1dGVzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY29tYmluZVRyYW5zYWN0aW9uU3RlcHMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9kZWZhdWx0QmxvY2tBdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2ZpbmRDaGlsZHJlbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2ZpbmRDaGlsZHJlbkluUmFuZ2UudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9maW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1Bvcy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2ZpbmRQYXJlbnROb2RlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0SFRNTEZyb21GcmFnbWVudC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFNjaGVtYS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dlbmVyYXRlSFRNTC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dlbmVyYXRlSlNPTi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFRleHQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZW5lcmF0ZVRleHQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXROb2RlQXR0cmlidXRlcy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldEF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL3JlbW92ZUR1cGxpY2F0ZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRDaGFuZ2VkUmFuZ2VzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0RGVidWdKU09OLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0TWFya3NCZXR3ZWVuLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0Tm9kZUF0UG9zaXRpb24udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRTcGxpdHRlZEF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc01hcmtBY3RpdmUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0FjdGl2ZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzQXRFbmRPZk5vZGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0F0U3RhcnRPZk5vZGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0xpc3QudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc05vZGVFbXB0eS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzTm9kZVNlbGVjdGlvbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL3Bvc1RvRE9NUmVjdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZXRNYXJrLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NldE1ldGEudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2V0Tm9kZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZXROb2RlU2VsZWN0aW9uLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NldFRleHRTZWxlY3Rpb24udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2lua0xpc3RJdGVtLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NwbGl0QmxvY2sudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc3BsaXRMaXN0SXRlbS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy90b2dnbGVMaXN0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3RvZ2dsZU1hcmsudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdG9nZ2xlTm9kZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy90b2dnbGVXcmFwLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3VuZG9JbnB1dFJ1bGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdW5zZXRBbGxNYXJrcy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy91bnNldE1hcmsudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdXBkYXRlQXR0cmlidXRlcy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy93cmFwSW4udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvd3JhcEluTGlzdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2NvbW1hbmRzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2V4dGVuc2lvbnMvZWRpdGFibGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvZXh0ZW5zaW9ucy9mb2N1c0V2ZW50cy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2tleW1hcC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL3RhYmluZGV4LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3N0eWxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9jcmVhdGVTdHlsZVRhZy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9FZGl0b3IudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaW5wdXRSdWxlcy9tYXJrSW5wdXRSdWxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2lucHV0UnVsZXMvbm9kZUlucHV0UnVsZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9pbnB1dFJ1bGVzL3RleHRibG9ja1R5cGVJbnB1dFJ1bGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaW5wdXRSdWxlcy90ZXh0SW5wdXRSdWxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2lucHV0UnVsZXMvd3JhcHBpbmdJbnB1dFJ1bGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvTWFyay50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9Ob2RlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc0FuZHJvaWQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvTm9kZVZpZXcudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvcGFzdGVSdWxlcy9tYXJrUGFzdGVSdWxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9lc2NhcGVGb3JSZWdFeC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvaXNTdHJpbmcudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvcGFzdGVSdWxlcy9ub2RlUGFzdGVSdWxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3Bhc3RlUnVsZXMvdGV4dFBhc3RlUnVsZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9UcmFja2VyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1kb2N1bWVudC9zcmMvZG9jdW1lbnQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWNoYXJhY3Rlci1jb3VudC9zcmMvY2hhcmFjdGVyLWNvdW50LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ibG9ja3F1b3RlL3NyYy9ibG9ja3F1b3RlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ib2xkL3NyYy9ib2xkLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saXN0LWl0ZW0vc3JjL2xpc3QtaXRlbS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC1zdHlsZS9zcmMvdGV4dC1zdHlsZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYnVsbGV0LWxpc3Qvc3JjL2J1bGxldC1saXN0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1jb2RlL3NyYy9jb2RlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1jb2RlLWJsb2NrL3NyYy9jb2RlLWJsb2NrLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1kcm9wY3Vyc29yL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWRyb3BjdXJzb3Ivc3JjL2Ryb3BjdXJzb3IudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWdhcGN1cnNvci9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1nYXBjdXJzb3Ivc3JjL2dhcGN1cnNvci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGFyZC1icmVhay9zcmMvaGFyZC1icmVhay50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGVhZGluZy9zcmMvaGVhZGluZy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcm9wZS1zZXF1ZW5jZS9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1oaXN0b3J5L2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhpc3Rvcnkvc3JjL2hpc3RvcnkudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhvcml6b250YWwtcnVsZS9zcmMvaG9yaXpvbnRhbC1ydWxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1pdGFsaWMvc3JjL2l0YWxpYy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC1pdGVtL3NyYy9saXN0LWl0ZW0udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3QtaXRlbS9zcmMvbGlzdC1pdGVtLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10ZXh0LXN0eWxlL3NyYy90ZXh0LXN0eWxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1vcmRlcmVkLWxpc3Qvc3JjL29yZGVyZWQtbGlzdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoL3NyYy9wYXJhZ3JhcGgudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXN0cmlrZS9zcmMvc3RyaWtlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10ZXh0L3NyYy90ZXh0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3N0YXJ0ZXIta2l0L3NyYy9zdGFydGVyLWtpdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21hdGguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy91c2VyQWdlbnQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNMYXlvdXRWaWV3cG9ydC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzVGFibGVFbGVtZW50LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2ZsaXAuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVTY3JvbGwuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGVib3VuY2UuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZUJ5TmFtZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL2NvbnN0YW50cy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL3V0aWxzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvZG9tLXV0aWxzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvYmluZEdsb2JhbEV2ZW50TGlzdGVuZXJzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvYnJvd3Nlci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL3ZhbGlkYXRpb24udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy9wcm9wcy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL3RlbXBsYXRlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvY3JlYXRlVGlwcHkudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy9pbmRleC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL2FkZG9ucy9jcmVhdGVTaW5nbGV0b24udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy9hZGRvbnMvZGVsZWdhdGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy9wbHVnaW5zL2FuaW1hdGVGaWxsLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvcGx1Z2lucy9mb2xsb3dDdXJzb3IudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy9wbHVnaW5zL2lubGluZVBvc2l0aW9uaW5nLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvcGx1Z2lucy9zdGlja3kudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL2J1aWxkL2Jhc2UuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJ1YmJsZS1tZW51L3NyYy9idWJibGUtbWVudS1wbHVnaW4udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJ1YmJsZS1tZW51L3NyYy9idWJibGUtbWVudS50cyIsICIuLi9yZXNvdXJjZXMvanMvaW5kZXguanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8vIDo6LSBQZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhbiBvcmRlcmVkIG1hcHBpbmcgZnJvbVxuLy8gc3RyaW5ncyB0byB2YWx1ZXMsIHdpdGggc29tZSBjb252ZW5pZW50IHVwZGF0ZSBtZXRob2RzLlxuZnVuY3Rpb24gT3JkZXJlZE1hcChjb250ZW50KSB7XG4gIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG59XG5cbk9yZGVyZWRNYXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogT3JkZXJlZE1hcCxcblxuICBmaW5kOiBmdW5jdGlvbihrZXkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkgKz0gMilcbiAgICAgIGlmICh0aGlzLmNvbnRlbnRbaV0gPT09IGtleSkgcmV0dXJuIGlcbiAgICByZXR1cm4gLTFcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nKSBcdTIxOTIgP2FueVxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWUgc3RvcmVkIHVuZGVyIGBrZXlgLCBvciByZXR1cm4gdW5kZWZpbmVkIHdoZW5cbiAgLy8gbm8gc3VjaCBrZXkgZXhpc3RzLlxuICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMuZmluZChrZXkpO1xuICAgIHJldHVybiBmb3VuZCA9PSAtMSA/IHVuZGVmaW5lZCA6IHRoaXMuY29udGVudFtmb3VuZCArIDFdXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZywgYW55LCA/c3RyaW5nKSBcdTIxOTIgT3JkZXJlZE1hcFxuICAvLyBDcmVhdGUgYSBuZXcgbWFwIGJ5IHJlcGxhY2luZyB0aGUgdmFsdWUgb2YgYGtleWAgd2l0aCBhIG5ld1xuICAvLyB2YWx1ZSwgb3IgYWRkaW5nIGEgYmluZGluZyB0byB0aGUgZW5kIG9mIHRoZSBtYXAuIElmIGBuZXdLZXlgIGlzXG4gIC8vIGdpdmVuLCB0aGUga2V5IG9mIHRoZSBiaW5kaW5nIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGF0IGtleS5cbiAgdXBkYXRlOiBmdW5jdGlvbihrZXksIHZhbHVlLCBuZXdLZXkpIHtcbiAgICB2YXIgc2VsZiA9IG5ld0tleSAmJiBuZXdLZXkgIT0ga2V5ID8gdGhpcy5yZW1vdmUobmV3S2V5KSA6IHRoaXM7XG4gICAgdmFyIGZvdW5kID0gc2VsZi5maW5kKGtleSksIGNvbnRlbnQgPSBzZWxmLmNvbnRlbnQuc2xpY2UoKTtcbiAgICBpZiAoZm91bmQgPT0gLTEpIHtcbiAgICAgIGNvbnRlbnQucHVzaChuZXdLZXkgfHwga2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnRbZm91bmQgKyAxXSA9IHZhbHVlO1xuICAgICAgaWYgKG5ld0tleSkgY29udGVudFtmb3VuZF0gPSBuZXdLZXk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcpIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIFJldHVybiBhIG1hcCB3aXRoIHRoZSBnaXZlbiBrZXkgcmVtb3ZlZCwgaWYgaXQgZXhpc3RlZC5cbiAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmZpbmQoa2V5KTtcbiAgICBpZiAoZm91bmQgPT0gLTEpIHJldHVybiB0aGlzXG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKTtcbiAgICBjb250ZW50LnNwbGljZShmb3VuZCwgMik7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZywgYW55KSBcdTIxOTIgT3JkZXJlZE1hcFxuICAvLyBBZGQgYSBuZXcga2V5IHRvIHRoZSBzdGFydCBvZiB0aGUgbWFwLlxuICBhZGRUb1N0YXJ0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKFtrZXksIHZhbHVlXS5jb25jYXQodGhpcy5yZW1vdmUoa2V5KS5jb250ZW50KSlcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nLCBhbnkpIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIEFkZCBhIG5ldyBrZXkgdG8gdGhlIGVuZCBvZiB0aGUgbWFwLlxuICBhZGRUb0VuZDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhciBjb250ZW50ID0gdGhpcy5yZW1vdmUoa2V5KS5jb250ZW50LnNsaWNlKCk7XG4gICAgY29udGVudC5wdXNoKGtleSwgdmFsdWUpO1xuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcsIHN0cmluZywgYW55KSBcdTIxOTIgT3JkZXJlZE1hcFxuICAvLyBBZGQgYSBrZXkgYWZ0ZXIgdGhlIGdpdmVuIGtleS4gSWYgYHBsYWNlYCBpcyBub3QgZm91bmQsIHRoZSBuZXdcbiAgLy8ga2V5IGlzIGFkZGVkIHRvIHRoZSBlbmQuXG4gIGFkZEJlZm9yZTogZnVuY3Rpb24ocGxhY2UsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgd2l0aG91dCA9IHRoaXMucmVtb3ZlKGtleSksIGNvbnRlbnQgPSB3aXRob3V0LmNvbnRlbnQuc2xpY2UoKTtcbiAgICB2YXIgZm91bmQgPSB3aXRob3V0LmZpbmQocGxhY2UpO1xuICAgIGNvbnRlbnQuc3BsaWNlKGZvdW5kID09IC0xID8gY29udGVudC5sZW5ndGggOiBmb3VuZCwgMCwga2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkpXG4gIC8vIENhbGwgdGhlIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyIGluIHRoZSBtYXAsIGluXG4gIC8vIG9yZGVyLlxuICBmb3JFYWNoOiBmdW5jdGlvbihmKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpICs9IDIpXG4gICAgICBmKHRoaXMuY29udGVudFtpXSwgdGhpcy5jb250ZW50W2kgKyAxXSk7XG4gIH0sXG5cbiAgLy8gOjogKHVuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG5ldyBtYXAgYnkgcHJlcGVuZGluZyB0aGUga2V5cyBpbiB0aGlzIG1hcCB0aGF0IGRvbid0XG4gIC8vIGFwcGVhciBpbiBgbWFwYCBiZWZvcmUgdGhlIGtleXMgaW4gYG1hcGAuXG4gIHByZXBlbmQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgIG1hcCA9IE9yZGVyZWRNYXAuZnJvbShtYXApO1xuICAgIGlmICghbWFwLnNpemUpIHJldHVybiB0aGlzXG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKG1hcC5jb250ZW50LmNvbmNhdCh0aGlzLnN1YnRyYWN0KG1hcCkuY29udGVudCkpXG4gIH0sXG5cbiAgLy8gOjogKHVuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG5ldyBtYXAgYnkgYXBwZW5kaW5nIHRoZSBrZXlzIGluIHRoaXMgbWFwIHRoYXQgZG9uJ3RcbiAgLy8gYXBwZWFyIGluIGBtYXBgIGFmdGVyIHRoZSBrZXlzIGluIGBtYXBgLlxuICBhcHBlbmQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgIG1hcCA9IE9yZGVyZWRNYXAuZnJvbShtYXApO1xuICAgIGlmICghbWFwLnNpemUpIHJldHVybiB0aGlzXG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKHRoaXMuc3VidHJhY3QobWFwKS5jb250ZW50LmNvbmNhdChtYXAuY29udGVudCkpXG4gIH0sXG5cbiAgLy8gOjogKHVuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG1hcCBjb250YWluaW5nIGFsbCB0aGUga2V5cyBpbiB0aGlzIG1hcCB0aGF0IGRvbid0XG4gIC8vIGFwcGVhciBpbiBgbWFwYC5cbiAgc3VidHJhY3Q6IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzO1xuICAgIG1hcCA9IE9yZGVyZWRNYXAuZnJvbShtYXApO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmNvbnRlbnQubGVuZ3RoOyBpICs9IDIpXG4gICAgICByZXN1bHQgPSByZXN1bHQucmVtb3ZlKG1hcC5jb250ZW50W2ldKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0sXG5cbiAgLy8gOjogKCkgXHUyMTkyIE9iamVjdFxuICAvLyBUdXJuIG9yZGVyZWQgbWFwIGludG8gYSBwbGFpbiBvYmplY3QuXG4gIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGtleSwgdmFsdWUpIHsgcmVzdWx0W2tleV0gPSB2YWx1ZTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9LFxuXG4gIC8vIDo6IG51bWJlclxuICAvLyBUaGUgYW1vdW50IG9mIGtleXMgaW4gdGhpcyBtYXAuXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID4+IDFcbiAgfVxufTtcblxuLy8gOjogKD91bmlvbjxPYmplY3QsIE9yZGVyZWRNYXA+KSBcdTIxOTIgT3JkZXJlZE1hcFxuLy8gUmV0dXJuIGEgbWFwIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQuIElmIG51bGwsIGNyZWF0ZSBhbiBlbXB0eVxuLy8gbWFwLiBJZiBnaXZlbiBhbiBvcmRlcmVkIG1hcCwgcmV0dXJuIHRoYXQgbWFwIGl0c2VsZi4gSWYgZ2l2ZW4gYW5cbi8vIG9iamVjdCwgY3JlYXRlIGEgbWFwIGZyb20gdGhlIG9iamVjdCdzIHByb3BlcnRpZXMuXG5PcmRlcmVkTWFwLmZyb20gPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPcmRlcmVkTWFwKSByZXR1cm4gdmFsdWVcbiAgdmFyIGNvbnRlbnQgPSBbXTtcbiAgaWYgKHZhbHVlKSBmb3IgKHZhciBwcm9wIGluIHZhbHVlKSBjb250ZW50LnB1c2gocHJvcCwgdmFsdWVbcHJvcF0pO1xuICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoY29udGVudClcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE9yZGVyZWRNYXA7XG4iLCAiaW1wb3J0IE9yZGVyZWRNYXAgZnJvbSAnb3JkZXJlZG1hcCc7XG5cbmZ1bmN0aW9uIGZpbmREaWZmU3RhcnQoYSwgYiwgcG9zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgaWYgKGkgPT0gYS5jaGlsZENvdW50IHx8IGkgPT0gYi5jaGlsZENvdW50KVxuICAgICAgICAgICAgcmV0dXJuIGEuY2hpbGRDb3VudCA9PSBiLmNoaWxkQ291bnQgPyBudWxsIDogcG9zO1xuICAgICAgICBsZXQgY2hpbGRBID0gYS5jaGlsZChpKSwgY2hpbGRCID0gYi5jaGlsZChpKTtcbiAgICAgICAgaWYgKGNoaWxkQSA9PSBjaGlsZEIpIHtcbiAgICAgICAgICAgIHBvcyArPSBjaGlsZEEubm9kZVNpemU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoaWxkQS5zYW1lTWFya3VwKGNoaWxkQikpXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICBpZiAoY2hpbGRBLmlzVGV4dCAmJiBjaGlsZEEudGV4dCAhPSBjaGlsZEIudGV4dCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGNoaWxkQS50ZXh0W2pdID09IGNoaWxkQi50ZXh0W2pdOyBqKyspXG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEEuY29udGVudC5zaXplIHx8IGNoaWxkQi5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGZpbmREaWZmU3RhcnQoY2hpbGRBLmNvbnRlbnQsIGNoaWxkQi5jb250ZW50LCBwb3MgKyAxKTtcbiAgICAgICAgICAgIGlmIChpbm5lciAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gY2hpbGRBLm5vZGVTaXplO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmREaWZmRW5kKGEsIGIsIHBvc0EsIHBvc0IpIHtcbiAgICBmb3IgKGxldCBpQSA9IGEuY2hpbGRDb3VudCwgaUIgPSBiLmNoaWxkQ291bnQ7Oykge1xuICAgICAgICBpZiAoaUEgPT0gMCB8fCBpQiA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGlBID09IGlCID8gbnVsbCA6IHsgYTogcG9zQSwgYjogcG9zQiB9O1xuICAgICAgICBsZXQgY2hpbGRBID0gYS5jaGlsZCgtLWlBKSwgY2hpbGRCID0gYi5jaGlsZCgtLWlCKSwgc2l6ZSA9IGNoaWxkQS5ub2RlU2l6ZTtcbiAgICAgICAgaWYgKGNoaWxkQSA9PSBjaGlsZEIpIHtcbiAgICAgICAgICAgIHBvc0EgLT0gc2l6ZTtcbiAgICAgICAgICAgIHBvc0IgLT0gc2l6ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hpbGRBLnNhbWVNYXJrdXAoY2hpbGRCKSlcbiAgICAgICAgICAgIHJldHVybiB7IGE6IHBvc0EsIGI6IHBvc0IgfTtcbiAgICAgICAgaWYgKGNoaWxkQS5pc1RleHQgJiYgY2hpbGRBLnRleHQgIT0gY2hpbGRCLnRleHQpIHtcbiAgICAgICAgICAgIGxldCBzYW1lID0gMCwgbWluU2l6ZSA9IE1hdGgubWluKGNoaWxkQS50ZXh0Lmxlbmd0aCwgY2hpbGRCLnRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIHdoaWxlIChzYW1lIDwgbWluU2l6ZSAmJiBjaGlsZEEudGV4dFtjaGlsZEEudGV4dC5sZW5ndGggLSBzYW1lIC0gMV0gPT0gY2hpbGRCLnRleHRbY2hpbGRCLnRleHQubGVuZ3RoIC0gc2FtZSAtIDFdKSB7XG4gICAgICAgICAgICAgICAgc2FtZSsrO1xuICAgICAgICAgICAgICAgIHBvc0EtLTtcbiAgICAgICAgICAgICAgICBwb3NCLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBhOiBwb3NBLCBiOiBwb3NCIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkQS5jb250ZW50LnNpemUgfHwgY2hpbGRCLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gZmluZERpZmZFbmQoY2hpbGRBLmNvbnRlbnQsIGNoaWxkQi5jb250ZW50LCBwb3NBIC0gMSwgcG9zQiAtIDEpO1xuICAgICAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgfVxuICAgICAgICBwb3NBIC09IHNpemU7XG4gICAgICAgIHBvc0IgLT0gc2l6ZTtcbiAgICB9XG59XG5cbi8qKlxuQSBmcmFnbWVudCByZXByZXNlbnRzIGEgbm9kZSdzIGNvbGxlY3Rpb24gb2YgY2hpbGQgbm9kZXMuXG5cbkxpa2Ugbm9kZXMsIGZyYWdtZW50cyBhcmUgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZXMsIGFuZCB5b3VcbnNob3VsZCBub3QgbXV0YXRlIHRoZW0gb3IgdGhlaXIgY29udGVudC4gUmF0aGVyLCB5b3UgY3JlYXRlIG5ld1xuaW5zdGFuY2VzIHdoZW5ldmVyIG5lZWRlZC4gVGhlIEFQSSB0cmllcyB0byBtYWtlIHRoaXMgZWFzeS5cbiovXG5jbGFzcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnRlbnQsIHNpemUpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZSB8fCAwO1xuICAgICAgICBpZiAoc2l6ZSA9PSBudWxsKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSArPSBjb250ZW50W2ldLm5vZGVTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBJbnZva2UgYSBjYWxsYmFjayBmb3IgYWxsIGRlc2NlbmRhbnQgbm9kZXMgYmV0d2VlbiB0aGUgZ2l2ZW4gdHdvXG4gICAgcG9zaXRpb25zIChyZWxhdGl2ZSB0byBzdGFydCBvZiB0aGlzIGZyYWdtZW50KS4gRG9lc24ndCBkZXNjZW5kXG4gICAgaW50byBhIG5vZGUgd2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLlxuICAgICovXG4gICAgbm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmLCBub2RlU3RhcnQgPSAwLCBwYXJlbnQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IHBvcyA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY29udGVudFtpXSwgZW5kID0gcG9zICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoZW5kID4gZnJvbSAmJiBmKGNoaWxkLCBub2RlU3RhcnQgKyBwb3MsIHBhcmVudCB8fCBudWxsLCBpKSAhPT0gZmFsc2UgJiYgY2hpbGQuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgICBjaGlsZC5ub2Rlc0JldHdlZW4oTWF0aC5tYXgoMCwgZnJvbSAtIHN0YXJ0KSwgTWF0aC5taW4oY2hpbGQuY29udGVudC5zaXplLCB0byAtIHN0YXJ0KSwgZiwgbm9kZVN0YXJ0ICsgc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBldmVyeSBkZXNjZW5kYW50IG5vZGUuIGBwb3NgIHdpbGwgYmVcbiAgICByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50LiBUaGUgY2FsbGJhY2sgbWF5IHJldHVyblxuICAgIGBmYWxzZWAgdG8gcHJldmVudCB0cmF2ZXJzYWwgb2YgYSBnaXZlbiBub2RlJ3MgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBkZXNjZW5kYW50cyhmKSB7XG4gICAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKDAsIHRoaXMuc2l6ZSwgZik7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4dHJhY3QgdGhlIHRleHQgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AuIFNlZSB0aGUgc2FtZSBtZXRob2Qgb25cbiAgICBbYE5vZGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS50ZXh0QmV0d2VlbikuXG4gICAgKi9cbiAgICB0ZXh0QmV0d2Vlbihmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KSB7XG4gICAgICAgIGxldCB0ZXh0ID0gXCJcIiwgc2VwYXJhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gbm9kZS50ZXh0LnNsaWNlKE1hdGgubWF4KGZyb20sIHBvcykgLSBwb3MsIHRvIC0gcG9zKTtcbiAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgPSAhYmxvY2tTZXBhcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLmlzTGVhZikge1xuICAgICAgICAgICAgICAgIGlmIChsZWFmVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IHR5cGVvZiBsZWFmVGV4dCA9PT0gXCJmdW5jdGlvblwiID8gbGVhZlRleHQobm9kZSkgOiBsZWFmVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlLnNwZWMubGVhZlRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBub2RlLnR5cGUuc3BlYy5sZWFmVGV4dChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VwYXJhdGVkID0gIWJsb2NrU2VwYXJhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXNlcGFyYXRlZCAmJiBub2RlLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IGJsb2NrU2VwYXJhdG9yO1xuICAgICAgICAgICAgICAgIHNlcGFyYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGNvbnRhaW5pbmcgdGhlIGNvbWJpbmVkIGNvbnRlbnQgb2YgdGhpc1xuICAgIGZyYWdtZW50IGFuZCB0aGUgb3RoZXIuXG4gICAgKi9cbiAgICBhcHBlbmQob3RoZXIpIHtcbiAgICAgICAgaWYgKCFvdGhlci5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubGFzdENoaWxkLCBmaXJzdCA9IG90aGVyLmZpcnN0Q2hpbGQsIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKSwgaSA9IDA7XG4gICAgICAgIGlmIChsYXN0LmlzVGV4dCAmJiBsYXN0LnNhbWVNYXJrdXAoZmlyc3QpKSB7XG4gICAgICAgICAgICBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gPSBsYXN0LndpdGhUZXh0KGxhc3QudGV4dCArIGZpcnN0LnRleHQpO1xuICAgICAgICAgICAgaSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCBvdGhlci5jb250ZW50Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgY29udGVudC5wdXNoKG90aGVyLmNvbnRlbnRbaV0pO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvbnRlbnQsIHRoaXMuc2l6ZSArIG90aGVyLnNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDdXQgb3V0IHRoZSBzdWItZnJhZ21lbnQgYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIGN1dChmcm9tLCB0byA9IHRoaXMuc2l6ZSkge1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIHNpemUgPSAwO1xuICAgICAgICBpZiAodG8gPiBmcm9tKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IHBvcyA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV0sIGVuZCA9IHBvcyArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tIHx8IGVuZCA+IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaXNUZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY3V0KE1hdGgubWF4KDAsIGZyb20gLSBwb3MpLCBNYXRoLm1pbihjaGlsZC50ZXh0Lmxlbmd0aCwgdG8gLSBwb3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmN1dChNYXRoLm1heCgwLCBmcm9tIC0gcG9zIC0gMSksIE1hdGgubWluKGNoaWxkLmNvbnRlbnQuc2l6ZSwgdG8gLSBwb3MgLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBzaXplICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQocmVzdWx0LCBzaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjdXRCeUluZGV4KGZyb20sIHRvKSB7XG4gICAgICAgIGlmIChmcm9tID09IHRvKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmNvbnRlbnQuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGluIHdoaWNoIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBpbmRleCBpc1xuICAgIHJlcGxhY2VkIGJ5IHRoZSBnaXZlbiBub2RlLlxuICAgICovXG4gICAgcmVwbGFjZUNoaWxkKGluZGV4LCBub2RlKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5jb250ZW50W2luZGV4XTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT0gbm9kZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgY29weSA9IHRoaXMuY29udGVudC5zbGljZSgpO1xuICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUgLSBjdXJyZW50Lm5vZGVTaXplO1xuICAgICAgICBjb3B5W2luZGV4XSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29weSwgc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBieSBwcmVwZW5kaW5nIHRoZSBnaXZlbiBub2RlIHRvIHRoaXNcbiAgICBmcmFnbWVudC5cbiAgICAqL1xuICAgIGFkZFRvU3RhcnQobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KFtub2RlXS5jb25jYXQodGhpcy5jb250ZW50KSwgdGhpcy5zaXplICsgbm9kZS5ub2RlU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBieSBhcHBlbmRpbmcgdGhlIGdpdmVuIG5vZGUgdG8gdGhpc1xuICAgIGZyYWdtZW50LlxuICAgICovXG4gICAgYWRkVG9FbmQobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHRoaXMuY29udGVudC5jb25jYXQobm9kZSksIHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgZnJhZ21lbnQgdG8gYW5vdGhlciBvbmUuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCAhPSBvdGhlci5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udGVudFtpXS5lcShvdGhlci5jb250ZW50W2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZmlyc3QgY2hpbGQgb2YgdGhlIGZyYWdtZW50LCBvciBgbnVsbGAgaWYgaXQgaXMgZW1wdHkuXG4gICAgKi9cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnRbMF0gOiBudWxsOyB9XG4gICAgLyoqXG4gICAgVGhlIGxhc3QgY2hpbGQgb2YgdGhlIGZyYWdtZW50LCBvciBgbnVsbGAgaWYgaXQgaXMgZW1wdHkuXG4gICAgKi9cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gOiBudWxsOyB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiBjaGlsZCBub2RlcyBpbiB0aGlzIGZyYWdtZW50LlxuICAgICovXG4gICAgZ2V0IGNoaWxkQ291bnQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC4gUmFpc2UgYW4gZXJyb3Igd2hlbiB0aGVcbiAgICBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgKi9cbiAgICBjaGlsZChpbmRleCkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLmNvbnRlbnRbaW5kZXhdO1xuICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBcIiArIGluZGV4ICsgXCIgb3V0IG9mIHJhbmdlIGZvciBcIiArIHRoaXMpO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIGl0IGV4aXN0cy5cbiAgICAqL1xuICAgIG1heWJlQ2hpbGQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFtpbmRleF0gfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbCBgZmAgZm9yIGV2ZXJ5IGNoaWxkIG5vZGUsIHBhc3NpbmcgdGhlIG5vZGUsIGl0cyBvZmZzZXRcbiAgICBpbnRvIHRoaXMgcGFyZW50IG5vZGUsIGFuZCBpdHMgaW5kZXguXG4gICAgKi9cbiAgICBmb3JFYWNoKGYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHAgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV07XG4gICAgICAgICAgICBmKGNoaWxkLCBwLCBpKTtcbiAgICAgICAgICAgIHAgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZmlyc3QgcG9zaXRpb24gYXQgd2hpY2ggdGhpcyBmcmFnbWVudCBhbmQgYW5vdGhlclxuICAgIGZyYWdtZW50IGRpZmZlciwgb3IgYG51bGxgIGlmIHRoZXkgYXJlIHRoZSBzYW1lLlxuICAgICovXG4gICAgZmluZERpZmZTdGFydChvdGhlciwgcG9zID0gMCkge1xuICAgICAgICByZXR1cm4gZmluZERpZmZTdGFydCh0aGlzLCBvdGhlciwgcG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZmlyc3QgcG9zaXRpb24sIHNlYXJjaGluZyBmcm9tIHRoZSBlbmQsIGF0IHdoaWNoIHRoaXNcbiAgICBmcmFnbWVudCBhbmQgdGhlIGdpdmVuIGZyYWdtZW50IGRpZmZlciwgb3IgYG51bGxgIGlmIHRoZXkgYXJlXG4gICAgdGhlIHNhbWUuIFNpbmNlIHRoaXMgcG9zaXRpb24gd2lsbCBub3QgYmUgdGhlIHNhbWUgaW4gYm90aFxuICAgIG5vZGVzLCBhbiBvYmplY3Qgd2l0aCB0d28gc2VwYXJhdGUgcG9zaXRpb25zIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgZmluZERpZmZFbmQob3RoZXIsIHBvcyA9IHRoaXMuc2l6ZSwgb3RoZXJQb3MgPSBvdGhlci5zaXplKSB7XG4gICAgICAgIHJldHVybiBmaW5kRGlmZkVuZCh0aGlzLCBvdGhlciwgcG9zLCBvdGhlclBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGluZGV4IGFuZCBpbm5lciBvZmZzZXQgY29ycmVzcG9uZGluZyB0byBhIGdpdmVuIHJlbGF0aXZlXG4gICAgcG9zaXRpb24gaW4gdGhpcyBmcmFnbWVudC4gVGhlIHJlc3VsdCBvYmplY3Qgd2lsbCBiZSByZXVzZWRcbiAgICAob3ZlcndyaXR0ZW4pIHRoZSBuZXh0IHRpbWUgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZC4gKE5vdCBwdWJsaWMuKVxuICAgICovXG4gICAgZmluZEluZGV4KHBvcywgcm91bmQgPSAtMSkge1xuICAgICAgICBpZiAocG9zID09IDApXG4gICAgICAgICAgICByZXR1cm4gcmV0SW5kZXgoMCwgcG9zKTtcbiAgICAgICAgaWYgKHBvcyA9PSB0aGlzLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gcmV0SW5kZXgodGhpcy5jb250ZW50Lmxlbmd0aCwgcG9zKTtcbiAgICAgICAgaWYgKHBvcyA+IHRoaXMuc2l6ZSB8fCBwb3MgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBvc2l0aW9uICR7cG9zfSBvdXRzaWRlIG9mIGZyYWdtZW50ICgke3RoaXN9KWApO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgY3VyUG9zID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHRoaXMuY2hpbGQoaSksIGVuZCA9IGN1clBvcyArIGN1ci5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA9PSBwb3MgfHwgcm91bmQgPiAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0SW5kZXgoaSArIDEsIGVuZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KGksIGN1clBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJQb3MgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgZGVidWdnaW5nIHN0cmluZyB0aGF0IGRlc2NyaWJlcyB0aGlzIGZyYWdtZW50LlxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBcIjxcIiArIHRoaXMudG9TdHJpbmdJbm5lcigpICsgXCI+XCI7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nSW5uZXIoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuam9pbihcIiwgXCIpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgSlNPTi1zZXJpYWxpemVhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZnJhZ21lbnQuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50Lm1hcChuID0+IG4udG9KU09OKCkpIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBmcmFnbWVudCBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgRnJhZ21lbnQuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQodmFsdWUubWFwKHNjaGVtYS5ub2RlRnJvbUpTT04pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSBmcmFnbWVudCBmcm9tIGFuIGFycmF5IG9mIG5vZGVzLiBFbnN1cmVzIHRoYXQgYWRqYWNlbnRcbiAgICB0ZXh0IG5vZGVzIHdpdGggdGhlIHNhbWUgbWFya3MgYXJlIGpvaW5lZCB0b2dldGhlci5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgaWYgKCFhcnJheS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGxldCBqb2luZWQsIHNpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGFycmF5W2ldO1xuICAgICAgICAgICAgc2l6ZSArPSBub2RlLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGkgJiYgbm9kZS5pc1RleHQgJiYgYXJyYXlbaSAtIDFdLnNhbWVNYXJrdXAobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWpvaW5lZClcbiAgICAgICAgICAgICAgICAgICAgam9pbmVkID0gYXJyYXkuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgam9pbmVkW2pvaW5lZC5sZW5ndGggLSAxXSA9IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgLndpdGhUZXh0KGpvaW5lZFtqb2luZWQubGVuZ3RoIC0gMV0udGV4dCArIG5vZGUudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChqb2luZWQpIHtcbiAgICAgICAgICAgICAgICBqb2luZWQucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGpvaW5lZCB8fCBhcnJheSwgc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGZyYWdtZW50IGZyb20gc29tZXRoaW5nIHRoYXQgY2FuIGJlIGludGVycHJldGVkIGFzIGFcbiAgICBzZXQgb2Ygbm9kZXMuIEZvciBgbnVsbGAsIGl0IHJldHVybnMgdGhlIGVtcHR5IGZyYWdtZW50LiBGb3IgYVxuICAgIGZyYWdtZW50LCB0aGUgZnJhZ21lbnQgaXRzZWxmLiBGb3IgYSBub2RlIG9yIGFycmF5IG9mIG5vZGVzLCBhXG4gICAgZnJhZ21lbnQgY29udGFpbmluZyB0aG9zZSBub2Rlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG5vZGVzKSB7XG4gICAgICAgIGlmICghbm9kZXMpXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGlmIChub2RlcyBpbnN0YW5jZW9mIEZyYWdtZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tQXJyYXkobm9kZXMpO1xuICAgICAgICBpZiAobm9kZXMuYXR0cnMpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KFtub2Rlc10sIG5vZGVzLm5vZGVTaXplKTtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4gbm90IGNvbnZlcnQgXCIgKyBub2RlcyArIFwiIHRvIGEgRnJhZ21lbnRcIiArXG4gICAgICAgICAgICAobm9kZXMubm9kZXNCZXR3ZWVuID8gXCIgKGxvb2tzIGxpa2UgbXVsdGlwbGUgdmVyc2lvbnMgb2YgcHJvc2VtaXJyb3ItbW9kZWwgd2VyZSBsb2FkZWQpXCIgOiBcIlwiKSk7XG4gICAgfVxufVxuLyoqXG5BbiBlbXB0eSBmcmFnbWVudC4gSW50ZW5kZWQgdG8gYmUgcmV1c2VkIHdoZW5ldmVyIGEgbm9kZSBkb2Vzbid0XG5jb250YWluIGFueXRoaW5nIChyYXRoZXIgdGhhbiBhbGxvY2F0aW5nIGEgbmV3IGVtcHR5IGZyYWdtZW50IGZvclxuZWFjaCBsZWFmIG5vZGUpLlxuKi9cbkZyYWdtZW50LmVtcHR5ID0gbmV3IEZyYWdtZW50KFtdLCAwKTtcbmNvbnN0IGZvdW5kID0geyBpbmRleDogMCwgb2Zmc2V0OiAwIH07XG5mdW5jdGlvbiByZXRJbmRleChpbmRleCwgb2Zmc2V0KSB7XG4gICAgZm91bmQuaW5kZXggPSBpbmRleDtcbiAgICBmb3VuZC5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlRGVlcChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghKGEgJiYgdHlwZW9mIGEgPT0gXCJvYmplY3RcIikgfHxcbiAgICAgICAgIShiICYmIHR5cGVvZiBiID09IFwib2JqZWN0XCIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGFycmF5ID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShiKSAhPSBhcnJheSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChhcnJheSkge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghY29tcGFyZURlZXAoYVtpXSwgYltpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgcCBpbiBhKVxuICAgICAgICAgICAgaWYgKCEocCBpbiBiKSB8fCAhY29tcGFyZURlZXAoYVtwXSwgYltwXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBwIGluIGIpXG4gICAgICAgICAgICBpZiAoIShwIGluIGEpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuQSBtYXJrIGlzIGEgcGllY2Ugb2YgaW5mb3JtYXRpb24gdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSBub2RlLFxuc3VjaCBhcyBpdCBiZWluZyBlbXBoYXNpemVkLCBpbiBjb2RlIGZvbnQsIG9yIGEgbGluay4gSXQgaGFzIGFcbnR5cGUgYW5kIG9wdGlvbmFsbHkgYSBzZXQgb2YgYXR0cmlidXRlcyB0aGF0IHByb3ZpZGUgZnVydGhlclxuaW5mb3JtYXRpb24gKHN1Y2ggYXMgdGhlIHRhcmdldCBvZiB0aGUgbGluaykuIE1hcmtzIGFyZSBjcmVhdGVkXG50aHJvdWdoIGEgYFNjaGVtYWAsIHdoaWNoIGNvbnRyb2xzIHdoaWNoIHR5cGVzIGV4aXN0IGFuZCB3aGljaFxuYXR0cmlidXRlcyB0aGV5IGhhdmUuXG4qL1xuY2xhc3MgTWFyayB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiB0aGlzIG1hcmsuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGUgYXR0cmlidXRlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtYXJrLlxuICAgICovXG4gICAgYXR0cnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgIH1cbiAgICAvKipcbiAgICBHaXZlbiBhIHNldCBvZiBtYXJrcywgY3JlYXRlIGEgbmV3IHNldCB3aGljaCBjb250YWlucyB0aGlzIG9uZSBhc1xuICAgIHdlbGwsIGluIHRoZSByaWdodCBwb3NpdGlvbi4gSWYgdGhpcyBtYXJrIGlzIGFscmVhZHkgaW4gdGhlIHNldCxcbiAgICB0aGUgc2V0IGl0c2VsZiBpcyByZXR1cm5lZC4gSWYgYW55IG1hcmtzIHRoYXQgYXJlIHNldCB0byBiZVxuICAgIFtleGNsdXNpdmVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrU3BlYy5leGNsdWRlcykgd2l0aCB0aGlzIG1hcmsgYXJlIHByZXNlbnQsXG4gICAgdGhvc2UgYXJlIHJlcGxhY2VkIGJ5IHRoaXMgb25lLlxuICAgICovXG4gICAgYWRkVG9TZXQoc2V0KSB7XG4gICAgICAgIGxldCBjb3B5LCBwbGFjZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBvdGhlciA9IHNldFtpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKG90aGVyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZS5leGNsdWRlcyhvdGhlci50eXBlKSkge1xuICAgICAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IHNldC5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG90aGVyLnR5cGUuZXhjbHVkZXModGhpcy50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBsYWNlZCAmJiBvdGhlci50eXBlLnJhbmsgPiB0aGlzLnR5cGUucmFuaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gc2V0LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5LnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb3B5KVxuICAgICAgICAgICAgICAgICAgICBjb3B5LnB1c2gob3RoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgIGNvcHkgPSBzZXQuc2xpY2UoKTtcbiAgICAgICAgaWYgKCFwbGFjZWQpXG4gICAgICAgICAgICBjb3B5LnB1c2godGhpcyk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgdGhpcyBtYXJrIGZyb20gdGhlIGdpdmVuIHNldCwgcmV0dXJuaW5nIGEgbmV3IHNldC4gSWYgdGhpc1xuICAgIG1hcmsgaXMgbm90IGluIHRoZSBzZXQsIHRoZSBzZXQgaXRzZWxmIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgcmVtb3ZlRnJvbVNldChzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5lcShzZXRbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXQuc2xpY2UoMCwgaSkuY29uY2F0KHNldC5zbGljZShpICsgMSkpO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhpcyBtYXJrIGlzIGluIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MuXG4gICAgKi9cbiAgICBpc0luU2V0KHNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKHNldFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoaXMgbWFyayBoYXMgdGhlIHNhbWUgdHlwZSBhbmQgYXR0cmlidXRlcyBhc1xuICAgIGFub3RoZXIgbWFyay5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAodGhpcy50eXBlID09IG90aGVyLnR5cGUgJiYgY29tcGFyZURlZXAodGhpcy5hdHRycywgb3RoZXIuYXR0cnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCB0aGlzIG1hcmsgdG8gYSBKU09OLXNlcmlhbGl6ZWFibGUgcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBvYmogPSB7IHR5cGU6IHRoaXMudHlwZS5uYW1lIH07XG4gICAgICAgIGZvciAobGV0IF8gaW4gdGhpcy5hdHRycykge1xuICAgICAgICAgICAgb2JqLmF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgbWFyayBmcm9tIEpTT04uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgTWFyay5mcm9tSlNPTlwiKTtcbiAgICAgICAgbGV0IHR5cGUgPSBzY2hlbWEubWFya3NbanNvbi50eXBlXTtcbiAgICAgICAgaWYgKCF0eXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFRoZXJlIGlzIG5vIG1hcmsgdHlwZSAke2pzb24udHlwZX0gaW4gdGhpcyBzY2hlbWFgKTtcbiAgICAgICAgcmV0dXJuIHR5cGUuY3JlYXRlKGpzb24uYXR0cnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdHdvIHNldHMgb2YgbWFya3MgYXJlIGlkZW50aWNhbC5cbiAgICAqL1xuICAgIHN0YXRpYyBzYW1lU2V0KGEsIGIpIHtcbiAgICAgICAgaWYgKGEgPT0gYilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghYVtpXS5lcShiW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBwcm9wZXJseSBzb3J0ZWQgbWFyayBzZXQgZnJvbSBudWxsLCBhIHNpbmdsZSBtYXJrLCBvciBhblxuICAgIHVuc29ydGVkIGFycmF5IG9mIG1hcmtzLlxuICAgICovXG4gICAgc3RhdGljIHNldEZyb20obWFya3MpIHtcbiAgICAgICAgaWYgKCFtYXJrcyB8fCBBcnJheS5pc0FycmF5KG1hcmtzKSAmJiBtYXJrcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBNYXJrLm5vbmU7XG4gICAgICAgIGlmIChtYXJrcyBpbnN0YW5jZW9mIE1hcmspXG4gICAgICAgICAgICByZXR1cm4gW21hcmtzXTtcbiAgICAgICAgbGV0IGNvcHkgPSBtYXJrcy5zbGljZSgpO1xuICAgICAgICBjb3B5LnNvcnQoKGEsIGIpID0+IGEudHlwZS5yYW5rIC0gYi50eXBlLnJhbmspO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG59XG4vKipcblRoZSBlbXB0eSBzZXQgb2YgbWFya3MuXG4qL1xuTWFyay5ub25lID0gW107XG5cbi8qKlxuRXJyb3IgdHlwZSByYWlzZWQgYnkgW2BOb2RlLnJlcGxhY2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS5yZXBsYWNlKSB3aGVuXG5naXZlbiBhbiBpbnZhbGlkIHJlcGxhY2VtZW50LlxuKi9cbmNsYXNzIFJlcGxhY2VFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbi8qXG5SZXBsYWNlRXJyb3IgPSBmdW5jdGlvbih0aGlzOiBhbnksIG1lc3NhZ2U6IHN0cmluZykge1xuICBsZXQgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKVxuICA7KGVyciBhcyBhbnkpLl9fcHJvdG9fXyA9IFJlcGxhY2VFcnJvci5wcm90b3R5cGVcbiAgcmV0dXJuIGVyclxufSBhcyBhbnlcblxuUmVwbGFjZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKVxuUmVwbGFjZUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlcGxhY2VFcnJvclxuUmVwbGFjZUVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJSZXBsYWNlRXJyb3JcIlxuKi9cbi8qKlxuQSBzbGljZSByZXByZXNlbnRzIGEgcGllY2UgY3V0IG91dCBvZiBhIGxhcmdlciBkb2N1bWVudC4gSXRcbnN0b3JlcyBub3Qgb25seSBhIGZyYWdtZW50LCBidXQgYWxzbyB0aGUgZGVwdGggdXAgdG8gd2hpY2ggbm9kZXMgb25cbmJvdGggc2lkZSBhcmUgXHUyMDE4b3Blblx1MjAxOSAoY3V0IHRocm91Z2gpLlxuKi9cbmNsYXNzIFNsaWNlIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBzbGljZS4gV2hlbiBzcGVjaWZ5aW5nIGEgbm9uLXplcm8gb3BlbiBkZXB0aCwgeW91IG11c3RcbiAgICBtYWtlIHN1cmUgdGhhdCB0aGVyZSBhcmUgbm9kZXMgb2YgYXQgbGVhc3QgdGhhdCBkZXB0aCBhdCB0aGVcbiAgICBhcHByb3ByaWF0ZSBzaWRlIG9mIHRoZSBmcmFnbWVudFx1MjAxNGkuZS4gaWYgdGhlIGZyYWdtZW50IGlzIGFuXG4gICAgZW1wdHkgcGFyYWdyYXBoIG5vZGUsIGBvcGVuU3RhcnRgIGFuZCBgb3BlbkVuZGAgY2FuJ3QgYmUgZ3JlYXRlclxuICAgIHRoYW4gMS5cbiAgICBcbiAgICBJdCBpcyBub3QgbmVjZXNzYXJ5IGZvciB0aGUgY29udGVudCBvZiBvcGVuIG5vZGVzIHRvIGNvbmZvcm0gdG9cbiAgICB0aGUgc2NoZW1hJ3MgY29udGVudCBjb25zdHJhaW50cywgdGhvdWdoIGl0IHNob3VsZCBiZSBhIHZhbGlkXG4gICAgc3RhcnQvZW5kL21pZGRsZSBmb3Igc3VjaCBhIG5vZGUsIGRlcGVuZGluZyBvbiB3aGljaCBzaWRlcyBhcmVcbiAgICBvcGVuLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHNsaWNlJ3MgY29udGVudC5cbiAgICAqL1xuICAgIGNvbnRlbnQsIFxuICAgIC8qKlxuICAgIFRoZSBvcGVuIGRlcHRoIGF0IHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBvcGVuU3RhcnQsIFxuICAgIC8qKlxuICAgIFRoZSBvcGVuIGRlcHRoIGF0IHRoZSBlbmQuXG4gICAgKi9cbiAgICBvcGVuRW5kKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMub3BlblN0YXJ0ID0gb3BlblN0YXJ0O1xuICAgICAgICB0aGlzLm9wZW5FbmQgPSBvcGVuRW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2l6ZSB0aGlzIHNsaWNlIHdvdWxkIGFkZCB3aGVuIGluc2VydGVkIGludG8gYSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LnNpemUgLSB0aGlzLm9wZW5TdGFydCAtIHRoaXMub3BlbkVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpbnNlcnRBdChwb3MsIGZyYWdtZW50KSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gaW5zZXJ0SW50byh0aGlzLmNvbnRlbnQsIHBvcyArIHRoaXMub3BlblN0YXJ0LCBmcmFnbWVudCk7XG4gICAgICAgIHJldHVybiBjb250ZW50ICYmIG5ldyBTbGljZShjb250ZW50LCB0aGlzLm9wZW5TdGFydCwgdGhpcy5vcGVuRW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZW1vdmVCZXR3ZWVuKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UocmVtb3ZlUmFuZ2UodGhpcy5jb250ZW50LCBmcm9tICsgdGhpcy5vcGVuU3RhcnQsIHRvICsgdGhpcy5vcGVuU3RhcnQpLCB0aGlzLm9wZW5TdGFydCwgdGhpcy5vcGVuRW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdHMgd2hldGhlciB0aGlzIHNsaWNlIGlzIGVxdWFsIHRvIGFub3RoZXIgc2xpY2UuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LmVxKG90aGVyLmNvbnRlbnQpICYmIHRoaXMub3BlblN0YXJ0ID09IG90aGVyLm9wZW5TdGFydCAmJiB0aGlzLm9wZW5FbmQgPT0gb3RoZXIub3BlbkVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudCArIFwiKFwiICsgdGhpcy5vcGVuU3RhcnQgKyBcIixcIiArIHRoaXMub3BlbkVuZCArIFwiKVwiO1xuICAgIH1cbiAgICAvKipcbiAgICBDb252ZXJ0IGEgc2xpY2UgdG8gYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQganNvbiA9IHsgY29udGVudDogdGhpcy5jb250ZW50LnRvSlNPTigpIH07XG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA+IDApXG4gICAgICAgICAgICBqc29uLm9wZW5TdGFydCA9IHRoaXMub3BlblN0YXJ0O1xuICAgICAgICBpZiAodGhpcy5vcGVuRW5kID4gMClcbiAgICAgICAgICAgIGpzb24ub3BlbkVuZCA9IHRoaXMub3BlbkVuZDtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgc2xpY2UgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uKVxuICAgICAgICAgICAgcmV0dXJuIFNsaWNlLmVtcHR5O1xuICAgICAgICBsZXQgb3BlblN0YXJ0ID0ganNvbi5vcGVuU3RhcnQgfHwgMCwgb3BlbkVuZCA9IGpzb24ub3BlbkVuZCB8fCAwO1xuICAgICAgICBpZiAodHlwZW9mIG9wZW5TdGFydCAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBvcGVuRW5kICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFNsaWNlLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKEZyYWdtZW50LmZyb21KU09OKHNjaGVtYSwganNvbi5jb250ZW50KSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2xpY2UgZnJvbSBhIGZyYWdtZW50IGJ5IHRha2luZyB0aGUgbWF4aW11bSBwb3NzaWJsZVxuICAgIG9wZW4gdmFsdWUgb24gYm90aCBzaWRlIG9mIHRoZSBmcmFnbWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXhPcGVuKGZyYWdtZW50LCBvcGVuSXNvbGF0aW5nID0gdHJ1ZSkge1xuICAgICAgICBsZXQgb3BlblN0YXJ0ID0gMCwgb3BlbkVuZCA9IDA7XG4gICAgICAgIGZvciAobGV0IG4gPSBmcmFnbWVudC5maXJzdENoaWxkOyBuICYmICFuLmlzTGVhZiAmJiAob3Blbklzb2xhdGluZyB8fCAhbi50eXBlLnNwZWMuaXNvbGF0aW5nKTsgbiA9IG4uZmlyc3RDaGlsZClcbiAgICAgICAgICAgIG9wZW5TdGFydCsrO1xuICAgICAgICBmb3IgKGxldCBuID0gZnJhZ21lbnQubGFzdENoaWxkOyBuICYmICFuLmlzTGVhZiAmJiAob3Blbklzb2xhdGluZyB8fCAhbi50eXBlLnNwZWMuaXNvbGF0aW5nKTsgbiA9IG4ubGFzdENoaWxkKVxuICAgICAgICAgICAgb3BlbkVuZCsrO1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKGZyYWdtZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgIH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNsaWNlLlxuKi9cblNsaWNlLmVtcHR5ID0gbmV3IFNsaWNlKEZyYWdtZW50LmVtcHR5LCAwLCAwKTtcbmZ1bmN0aW9uIHJlbW92ZVJhbmdlKGNvbnRlbnQsIGZyb20sIHRvKSB7XG4gICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gY29udGVudC5maW5kSW5kZXgoZnJvbSksIGNoaWxkID0gY29udGVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICBsZXQgeyBpbmRleDogaW5kZXhUbywgb2Zmc2V0OiBvZmZzZXRUbyB9ID0gY29udGVudC5maW5kSW5kZXgodG8pO1xuICAgIGlmIChvZmZzZXQgPT0gZnJvbSB8fCBjaGlsZC5pc1RleHQpIHtcbiAgICAgICAgaWYgKG9mZnNldFRvICE9IHRvICYmICFjb250ZW50LmNoaWxkKGluZGV4VG8pLmlzVGV4dClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVtb3Zpbmcgbm9uLWZsYXQgcmFuZ2VcIik7XG4gICAgICAgIHJldHVybiBjb250ZW50LmN1dCgwLCBmcm9tKS5hcHBlbmQoY29udGVudC5jdXQodG8pKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9IGluZGV4VG8pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVtb3Zpbmcgbm9uLWZsYXQgcmFuZ2VcIik7XG4gICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBjaGlsZC5jb3B5KHJlbW92ZVJhbmdlKGNoaWxkLmNvbnRlbnQsIGZyb20gLSBvZmZzZXQgLSAxLCB0byAtIG9mZnNldCAtIDEpKSk7XG59XG5mdW5jdGlvbiBpbnNlcnRJbnRvKGNvbnRlbnQsIGRpc3QsIGluc2VydCwgcGFyZW50KSB7XG4gICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gY29udGVudC5maW5kSW5kZXgoZGlzdCksIGNoaWxkID0gY29udGVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICBpZiAob2Zmc2V0ID09IGRpc3QgfHwgY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCwgaW5zZXJ0KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gY29udGVudC5jdXQoMCwgZGlzdCkuYXBwZW5kKGluc2VydCkuYXBwZW5kKGNvbnRlbnQuY3V0KGRpc3QpKTtcbiAgICB9XG4gICAgbGV0IGlubmVyID0gaW5zZXJ0SW50byhjaGlsZC5jb250ZW50LCBkaXN0IC0gb2Zmc2V0IC0gMSwgaW5zZXJ0KTtcbiAgICByZXR1cm4gaW5uZXIgJiYgY29udGVudC5yZXBsYWNlQ2hpbGQoaW5kZXgsIGNoaWxkLmNvcHkoaW5uZXIpKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2UoJGZyb20sICR0bywgc2xpY2UpIHtcbiAgICBpZiAoc2xpY2Uub3BlblN0YXJ0ID4gJGZyb20uZGVwdGgpXG4gICAgICAgIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbnNlcnRlZCBjb250ZW50IGRlZXBlciB0aGFuIGluc2VydGlvbiBwb3NpdGlvblwiKTtcbiAgICBpZiAoJGZyb20uZGVwdGggLSBzbGljZS5vcGVuU3RhcnQgIT0gJHRvLmRlcHRoIC0gc2xpY2Uub3BlbkVuZClcbiAgICAgICAgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkluY29uc2lzdGVudCBvcGVuIGRlcHRoc1wiKTtcbiAgICByZXR1cm4gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCAwKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VPdXRlcigkZnJvbSwgJHRvLCBzbGljZSwgZGVwdGgpIHtcbiAgICBsZXQgaW5kZXggPSAkZnJvbS5pbmRleChkZXB0aCksIG5vZGUgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICBpZiAoaW5kZXggPT0gJHRvLmluZGV4KGRlcHRoKSAmJiBkZXB0aCA8ICRmcm9tLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0KSB7XG4gICAgICAgIGxldCBpbm5lciA9IHJlcGxhY2VPdXRlcigkZnJvbSwgJHRvLCBzbGljZSwgZGVwdGggKyAxKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuY29weShub2RlLmNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBpbm5lcikpO1xuICAgIH1cbiAgICBlbHNlIGlmICghc2xpY2UuY29udGVudC5zaXplKSB7XG4gICAgICAgIHJldHVybiBjbG9zZShub2RlLCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFzbGljZS5vcGVuU3RhcnQgJiYgIXNsaWNlLm9wZW5FbmQgJiYgJGZyb20uZGVwdGggPT0gZGVwdGggJiYgJHRvLmRlcHRoID09IGRlcHRoKSB7IC8vIFNpbXBsZSwgZmxhdCBjYXNlXG4gICAgICAgIGxldCBwYXJlbnQgPSAkZnJvbS5wYXJlbnQsIGNvbnRlbnQgPSBwYXJlbnQuY29udGVudDtcbiAgICAgICAgcmV0dXJuIGNsb3NlKHBhcmVudCwgY29udGVudC5jdXQoMCwgJGZyb20ucGFyZW50T2Zmc2V0KS5hcHBlbmQoc2xpY2UuY29udGVudCkuYXBwZW5kKGNvbnRlbnQuY3V0KCR0by5wYXJlbnRPZmZzZXQpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBwcmVwYXJlU2xpY2VGb3JSZXBsYWNlKHNsaWNlLCAkZnJvbSk7XG4gICAgICAgIHJldHVybiBjbG9zZShub2RlLCByZXBsYWNlVGhyZWVXYXkoJGZyb20sIHN0YXJ0LCBlbmQsICR0bywgZGVwdGgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0pvaW4obWFpbiwgc3ViKSB7XG4gICAgaWYgKCFzdWIudHlwZS5jb21wYXRpYmxlQ29udGVudChtYWluLnR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiQ2Fubm90IGpvaW4gXCIgKyBzdWIudHlwZS5uYW1lICsgXCIgb250byBcIiArIG1haW4udHlwZS5uYW1lKTtcbn1cbmZ1bmN0aW9uIGpvaW5hYmxlKCRiZWZvcmUsICRhZnRlciwgZGVwdGgpIHtcbiAgICBsZXQgbm9kZSA9ICRiZWZvcmUubm9kZShkZXB0aCk7XG4gICAgY2hlY2tKb2luKG5vZGUsICRhZnRlci5ub2RlKGRlcHRoKSk7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBhZGROb2RlKGNoaWxkLCB0YXJnZXQpIHtcbiAgICBsZXQgbGFzdCA9IHRhcmdldC5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0ID49IDAgJiYgY2hpbGQuaXNUZXh0ICYmIGNoaWxkLnNhbWVNYXJrdXAodGFyZ2V0W2xhc3RdKSlcbiAgICAgICAgdGFyZ2V0W2xhc3RdID0gY2hpbGQud2l0aFRleHQodGFyZ2V0W2xhc3RdLnRleHQgKyBjaGlsZC50ZXh0KTtcbiAgICBlbHNlXG4gICAgICAgIHRhcmdldC5wdXNoKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGFkZFJhbmdlKCRzdGFydCwgJGVuZCwgZGVwdGgsIHRhcmdldCkge1xuICAgIGxldCBub2RlID0gKCRlbmQgfHwgJHN0YXJ0KS5ub2RlKGRlcHRoKTtcbiAgICBsZXQgc3RhcnRJbmRleCA9IDAsIGVuZEluZGV4ID0gJGVuZCA/ICRlbmQuaW5kZXgoZGVwdGgpIDogbm9kZS5jaGlsZENvdW50O1xuICAgIGlmICgkc3RhcnQpIHtcbiAgICAgICAgc3RhcnRJbmRleCA9ICRzdGFydC5pbmRleChkZXB0aCk7XG4gICAgICAgIGlmICgkc3RhcnQuZGVwdGggPiBkZXB0aCkge1xuICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCRzdGFydC50ZXh0T2Zmc2V0KSB7XG4gICAgICAgICAgICBhZGROb2RlKCRzdGFydC5ub2RlQWZ0ZXIsIHRhcmdldCk7XG4gICAgICAgICAgICBzdGFydEluZGV4Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKVxuICAgICAgICBhZGROb2RlKG5vZGUuY2hpbGQoaSksIHRhcmdldCk7XG4gICAgaWYgKCRlbmQgJiYgJGVuZC5kZXB0aCA9PSBkZXB0aCAmJiAkZW5kLnRleHRPZmZzZXQpXG4gICAgICAgIGFkZE5vZGUoJGVuZC5ub2RlQmVmb3JlLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gY2xvc2Uobm9kZSwgY29udGVudCkge1xuICAgIG5vZGUudHlwZS5jaGVja0NvbnRlbnQoY29udGVudCk7XG4gICAgcmV0dXJuIG5vZGUuY29weShjb250ZW50KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VUaHJlZVdheSgkZnJvbSwgJHN0YXJ0LCAkZW5kLCAkdG8sIGRlcHRoKSB7XG4gICAgbGV0IG9wZW5TdGFydCA9ICRmcm9tLmRlcHRoID4gZGVwdGggJiYgam9pbmFibGUoJGZyb20sICRzdGFydCwgZGVwdGggKyAxKTtcbiAgICBsZXQgb3BlbkVuZCA9ICR0by5kZXB0aCA+IGRlcHRoICYmIGpvaW5hYmxlKCRlbmQsICR0bywgZGVwdGggKyAxKTtcbiAgICBsZXQgY29udGVudCA9IFtdO1xuICAgIGFkZFJhbmdlKG51bGwsICRmcm9tLCBkZXB0aCwgY29udGVudCk7XG4gICAgaWYgKG9wZW5TdGFydCAmJiBvcGVuRW5kICYmICRzdGFydC5pbmRleChkZXB0aCkgPT0gJGVuZC5pbmRleChkZXB0aCkpIHtcbiAgICAgICAgY2hlY2tKb2luKG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIGFkZE5vZGUoY2xvc2Uob3BlblN0YXJ0LCByZXBsYWNlVGhyZWVXYXkoJGZyb20sICRzdGFydCwgJGVuZCwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAob3BlblN0YXJ0KVxuICAgICAgICAgICAgYWRkTm9kZShjbG9zZShvcGVuU3RhcnQsIHJlcGxhY2VUd29XYXkoJGZyb20sICRzdGFydCwgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgICAgICBhZGRSYW5nZSgkc3RhcnQsICRlbmQsIGRlcHRoLCBjb250ZW50KTtcbiAgICAgICAgaWYgKG9wZW5FbmQpXG4gICAgICAgICAgICBhZGROb2RlKGNsb3NlKG9wZW5FbmQsIHJlcGxhY2VUd29XYXkoJGVuZCwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgfVxuICAgIGFkZFJhbmdlKCR0bywgbnVsbCwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29udGVudCk7XG59XG5mdW5jdGlvbiByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBbXTtcbiAgICBhZGRSYW5nZShudWxsLCAkZnJvbSwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIGlmICgkZnJvbS5kZXB0aCA+IGRlcHRoKSB7XG4gICAgICAgIGxldCB0eXBlID0gam9pbmFibGUoJGZyb20sICR0bywgZGVwdGggKyAxKTtcbiAgICAgICAgYWRkTm9kZShjbG9zZSh0eXBlLCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgICB9XG4gICAgYWRkUmFuZ2UoJHRvLCBudWxsLCBkZXB0aCwgY29udGVudCk7XG4gICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVTbGljZUZvclJlcGxhY2Uoc2xpY2UsICRhbG9uZykge1xuICAgIGxldCBleHRyYSA9ICRhbG9uZy5kZXB0aCAtIHNsaWNlLm9wZW5TdGFydCwgcGFyZW50ID0gJGFsb25nLm5vZGUoZXh0cmEpO1xuICAgIGxldCBub2RlID0gcGFyZW50LmNvcHkoc2xpY2UuY29udGVudCk7XG4gICAgZm9yIChsZXQgaSA9IGV4dHJhIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIG5vZGUgPSAkYWxvbmcubm9kZShpKS5jb3B5KEZyYWdtZW50LmZyb20obm9kZSkpO1xuICAgIHJldHVybiB7IHN0YXJ0OiBub2RlLnJlc29sdmVOb0NhY2hlKHNsaWNlLm9wZW5TdGFydCArIGV4dHJhKSxcbiAgICAgICAgZW5kOiBub2RlLnJlc29sdmVOb0NhY2hlKG5vZGUuY29udGVudC5zaXplIC0gc2xpY2Uub3BlbkVuZCAtIGV4dHJhKSB9O1xufVxuXG4vKipcbllvdSBjYW4gW19yZXNvbHZlX10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUucmVzb2x2ZSkgYSBwb3NpdGlvbiB0byBnZXQgbW9yZVxuaW5mb3JtYXRpb24gYWJvdXQgaXQuIE9iamVjdHMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgc3VjaCBhXG5yZXNvbHZlZCBwb3NpdGlvbiwgcHJvdmlkaW5nIHZhcmlvdXMgcGllY2VzIG9mIGNvbnRleHRcbmluZm9ybWF0aW9uLCBhbmQgc29tZSBoZWxwZXIgbWV0aG9kcy5cblxuVGhyb3VnaG91dCB0aGlzIGludGVyZmFjZSwgbWV0aG9kcyB0aGF0IHRha2UgYW4gb3B0aW9uYWwgYGRlcHRoYFxucGFyYW1ldGVyIHdpbGwgaW50ZXJwcmV0IHVuZGVmaW5lZCBhcyBgdGhpcy5kZXB0aGAgYW5kIG5lZ2F0aXZlXG5udW1iZXJzIGFzIGB0aGlzLmRlcHRoICsgdmFsdWVgLlxuKi9cbmNsYXNzIFJlc29sdmVkUG9zIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiB0aGF0IHdhcyByZXNvbHZlZC5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwYXRoLCBcbiAgICAvKipcbiAgICBUaGUgb2Zmc2V0IHRoaXMgcG9zaXRpb24gaGFzIGludG8gaXRzIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgcGFyZW50T2Zmc2V0KSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLnBhcmVudE9mZnNldCA9IHBhcmVudE9mZnNldDtcbiAgICAgICAgdGhpcy5kZXB0aCA9IHBhdGgubGVuZ3RoIC8gMyAtIDE7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzb2x2ZURlcHRoKHZhbCkge1xuICAgICAgICBpZiAodmFsID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXB0aDtcbiAgICAgICAgaWYgKHZhbCA8IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXB0aCArIHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHBhcmVudCBub2RlIHRoYXQgdGhlIHBvc2l0aW9uIHBvaW50cyBpbnRvLiBOb3RlIHRoYXQgZXZlbiBpZlxuICAgIGEgcG9zaXRpb24gcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIHRoYXQgbm9kZSBpcyBub3QgY29uc2lkZXJlZFxuICAgIHRoZSBwYXJlbnRcdTIwMTR0ZXh0IG5vZGVzIGFyZSBcdTIwMThmbGF0XHUyMDE5IGluIHRoaXMgbW9kZWwsIGFuZCBoYXZlIG5vIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgcGFyZW50KCkgeyByZXR1cm4gdGhpcy5ub2RlKHRoaXMuZGVwdGgpOyB9XG4gICAgLyoqXG4gICAgVGhlIHJvb3Qgbm9kZSBpbiB3aGljaCB0aGUgcG9zaXRpb24gd2FzIHJlc29sdmVkLlxuICAgICovXG4gICAgZ2V0IGRvYygpIHsgcmV0dXJuIHRoaXMubm9kZSgwKTsgfVxuICAgIC8qKlxuICAgIFRoZSBhbmNlc3RvciBub2RlIGF0IHRoZSBnaXZlbiBsZXZlbC4gYHAubm9kZShwLmRlcHRoKWAgaXMgdGhlXG4gICAgc2FtZSBhcyBgcC5wYXJlbnRgLlxuICAgICovXG4gICAgbm9kZShkZXB0aCkgeyByZXR1cm4gdGhpcy5wYXRoW3RoaXMucmVzb2x2ZURlcHRoKGRlcHRoKSAqIDNdOyB9XG4gICAgLyoqXG4gICAgVGhlIGluZGV4IGludG8gdGhlIGFuY2VzdG9yIGF0IHRoZSBnaXZlbiBsZXZlbC4gSWYgdGhpcyBwb2ludHNcbiAgICBhdCB0aGUgM3JkIG5vZGUgaW4gdGhlIDJuZCBwYXJhZ3JhcGggb24gdGhlIHRvcCBsZXZlbCwgZm9yXG4gICAgZXhhbXBsZSwgYHAuaW5kZXgoMClgIGlzIDEgYW5kIGBwLmluZGV4KDEpYCBpcyAyLlxuICAgICovXG4gICAgaW5kZXgoZGVwdGgpIHsgcmV0dXJuIHRoaXMucGF0aFt0aGlzLnJlc29sdmVEZXB0aChkZXB0aCkgKiAzICsgMV07IH1cbiAgICAvKipcbiAgICBUaGUgaW5kZXggcG9pbnRpbmcgYWZ0ZXIgdGhpcyBwb3NpdGlvbiBpbnRvIHRoZSBhbmNlc3RvciBhdCB0aGVcbiAgICBnaXZlbiBsZXZlbC5cbiAgICAqL1xuICAgIGluZGV4QWZ0ZXIoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4KGRlcHRoKSArIChkZXB0aCA9PSB0aGlzLmRlcHRoICYmICF0aGlzLnRleHRPZmZzZXQgPyAwIDogMSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGF0IHRoZSBzdGFydCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW5cbiAgICBsZXZlbC5cbiAgICAqL1xuICAgIHN0YXJ0KGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICByZXR1cm4gZGVwdGggPT0gMCA/IDAgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV0gKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBub2RlIGF0IHRoZSBnaXZlblxuICAgIGxldmVsLlxuICAgICovXG4gICAgZW5kKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydChkZXB0aCkgKyB0aGlzLm5vZGUoZGVwdGgpLmNvbnRlbnQuc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gZGlyZWN0bHkgYmVmb3JlIHRoZSB3cmFwcGluZyBub2RlIGF0IHRoZVxuICAgIGdpdmVuIGxldmVsLCBvciwgd2hlbiBgZGVwdGhgIGlzIGB0aGlzLmRlcHRoICsgMWAsIHRoZSBvcmlnaW5hbFxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgYmVmb3JlKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGVyZSBpcyBubyBwb3NpdGlvbiBiZWZvcmUgdGhlIHRvcC1sZXZlbCBub2RlXCIpO1xuICAgICAgICByZXR1cm4gZGVwdGggPT0gdGhpcy5kZXB0aCArIDEgPyB0aGlzLnBvcyA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gZGlyZWN0bHkgYWZ0ZXIgdGhlIHdyYXBwaW5nIG5vZGUgYXQgdGhlXG4gICAgZ2l2ZW4gbGV2ZWwsIG9yIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiB3aGVuIGBkZXB0aGAgaXMgYHRoaXMuZGVwdGggKyAxYC5cbiAgICAqL1xuICAgIGFmdGVyKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGVyZSBpcyBubyBwb3NpdGlvbiBhZnRlciB0aGUgdG9wLWxldmVsIG5vZGVcIik7XG4gICAgICAgIHJldHVybiBkZXB0aCA9PSB0aGlzLmRlcHRoICsgMSA/IHRoaXMucG9zIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgdGhpcy5wYXRoW2RlcHRoICogM10ubm9kZVNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZW4gdGhpcyBwb3NpdGlvbiBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgdGhpcyByZXR1cm5zIHRoZVxuICAgIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvc2l0aW9uIGFuZCB0aGUgc3RhcnQgb2YgdGhlIHRleHQgbm9kZS5cbiAgICBXaWxsIGJlIHplcm8gZm9yIHBvc2l0aW9ucyB0aGF0IHBvaW50IGJldHdlZW4gbm9kZXMuXG4gICAgKi9cbiAgICBnZXQgdGV4dE9mZnNldCgpIHsgcmV0dXJuIHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbm9kZSBkaXJlY3RseSBhZnRlciB0aGUgcG9zaXRpb24sIGlmIGFueS4gSWYgdGhlIHBvc2l0aW9uXG4gICAgcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIG9ubHkgdGhlIHBhcnQgb2YgdGhhdCBub2RlIGFmdGVyIHRoZVxuICAgIHBvc2l0aW9uIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgZ2V0IG5vZGVBZnRlcigpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50LCBpbmRleCA9IHRoaXMuaW5kZXgodGhpcy5kZXB0aCk7XG4gICAgICAgIGlmIChpbmRleCA9PSBwYXJlbnQuY2hpbGRDb3VudClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZE9mZiA9IHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXSwgY2hpbGQgPSBwYXJlbnQuY2hpbGQoaW5kZXgpO1xuICAgICAgICByZXR1cm4gZE9mZiA/IHBhcmVudC5jaGlsZChpbmRleCkuY3V0KGRPZmYpIDogY2hpbGQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbm9kZSBkaXJlY3RseSBiZWZvcmUgdGhlIHBvc2l0aW9uLCBpZiBhbnkuIElmIHRoZVxuICAgIHBvc2l0aW9uIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCBvbmx5IHRoZSBwYXJ0IG9mIHRoYXQgbm9kZVxuICAgIGJlZm9yZSB0aGUgcG9zaXRpb24gaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICBnZXQgbm9kZUJlZm9yZSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5pbmRleCh0aGlzLmRlcHRoKTtcbiAgICAgICAgbGV0IGRPZmYgPSB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChkT2ZmKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkKGluZGV4KS5jdXQoMCwgZE9mZik7XG4gICAgICAgIHJldHVybiBpbmRleCA9PSAwID8gbnVsbCA6IHRoaXMucGFyZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcG9zaXRpb24gYXQgdGhlIGdpdmVuIGluZGV4IGluIHRoZSBwYXJlbnQgbm9kZSBhdCB0aGVcbiAgICBnaXZlbiBkZXB0aCAod2hpY2ggZGVmYXVsdHMgdG8gYHRoaXMuZGVwdGhgKS5cbiAgICAqL1xuICAgIHBvc0F0SW5kZXgoaW5kZXgsIGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMucGF0aFtkZXB0aCAqIDNdLCBwb3MgPSBkZXB0aCA9PSAwID8gMCA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcbiAgICAgICAgICAgIHBvcyArPSBub2RlLmNoaWxkKGkpLm5vZGVTaXplO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG1hcmtzIGF0IHRoaXMgcG9zaXRpb24sIGZhY3RvcmluZyBpbiB0aGUgc3Vycm91bmRpbmdcbiAgICBtYXJrcycgW2BpbmNsdXNpdmVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1NwZWMuaW5jbHVzaXZlKSBwcm9wZXJ0eS4gSWYgdGhlXG4gICAgcG9zaXRpb24gaXMgYXQgdGhlIHN0YXJ0IG9mIGEgbm9uLWVtcHR5IG5vZGUsIHRoZSBtYXJrcyBvZiB0aGVcbiAgICBub2RlIGFmdGVyIGl0IChpZiBhbnkpIGFyZSByZXR1cm5lZC5cbiAgICAqL1xuICAgIG1hcmtzKCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQsIGluZGV4ID0gdGhpcy5pbmRleCgpO1xuICAgICAgICAvLyBJbiBhbiBlbXB0eSBwYXJlbnQsIHJldHVybiB0aGUgZW1wdHkgYXJyYXlcbiAgICAgICAgaWYgKHBhcmVudC5jb250ZW50LnNpemUgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBNYXJrLm5vbmU7XG4gICAgICAgIC8vIFdoZW4gaW5zaWRlIGEgdGV4dCBub2RlLCBqdXN0IHJldHVybiB0aGUgdGV4dCBub2RlJ3MgbWFya3NcbiAgICAgICAgaWYgKHRoaXMudGV4dE9mZnNldClcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuY2hpbGQoaW5kZXgpLm1hcmtzO1xuICAgICAgICBsZXQgbWFpbiA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4IC0gMSksIG90aGVyID0gcGFyZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAvLyBJZiB0aGUgYGFmdGVyYCBmbGFnIGlzIHRydWUgb2YgdGhlcmUgaXMgbm8gbm9kZSBiZWZvcmUsIG1ha2VcbiAgICAgICAgLy8gdGhlIG5vZGUgYWZ0ZXIgdGhpcyBwb3NpdGlvbiB0aGUgbWFpbiByZWZlcmVuY2UuXG4gICAgICAgIGlmICghbWFpbikge1xuICAgICAgICAgICAgbGV0IHRtcCA9IG1haW47XG4gICAgICAgICAgICBtYWluID0gb3RoZXI7XG4gICAgICAgICAgICBvdGhlciA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgYWxsIG1hcmtzIGluIHRoZSBtYWluIG5vZGUsIGV4Y2VwdCB0aG9zZSB0aGF0IGhhdmVcbiAgICAgICAgLy8gYGluY2x1c2l2ZWAgc2V0IHRvIGZhbHNlIGFuZCBhcmUgbm90IHByZXNlbnQgaW4gdGhlIG90aGVyIG5vZGUuXG4gICAgICAgIGxldCBtYXJrcyA9IG1haW4ubWFya3M7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobWFya3NbaV0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UgJiYgKCFvdGhlciB8fCAhbWFya3NbaV0uaXNJblNldChvdGhlci5tYXJrcykpKVxuICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3NbaS0tXS5yZW1vdmVGcm9tU2V0KG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG1hcmtzIGFmdGVyIHRoZSBjdXJyZW50IHBvc2l0aW9uLCBpZiBhbnksIGV4Y2VwdCB0aG9zZVxuICAgIHRoYXQgYXJlIG5vbi1pbmNsdXNpdmUgYW5kIG5vdCBwcmVzZW50IGF0IHBvc2l0aW9uIGAkZW5kYC4gVGhpc1xuICAgIGlzIG1vc3RseSB1c2VmdWwgZm9yIGdldHRpbmcgdGhlIHNldCBvZiBtYXJrcyB0byBwcmVzZXJ2ZSBhZnRlciBhXG4gICAgZGVsZXRpb24uIFdpbGwgcmV0dXJuIGBudWxsYCBpZiB0aGlzIHBvc2l0aW9uIGlzIGF0IHRoZSBlbmQgb2ZcbiAgICBpdHMgcGFyZW50IG5vZGUgb3IgaXRzIHBhcmVudCBub2RlIGlzbid0IGEgdGV4dGJsb2NrIChpbiB3aGljaFxuICAgIGNhc2Ugbm8gbWFya3Mgc2hvdWxkIGJlIHByZXNlcnZlZCkuXG4gICAgKi9cbiAgICBtYXJrc0Fjcm9zcygkZW5kKSB7XG4gICAgICAgIGxldCBhZnRlciA9IHRoaXMucGFyZW50Lm1heWJlQ2hpbGQodGhpcy5pbmRleCgpKTtcbiAgICAgICAgaWYgKCFhZnRlciB8fCAhYWZ0ZXIuaXNJbmxpbmUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IG1hcmtzID0gYWZ0ZXIubWFya3MsIG5leHQgPSAkZW5kLnBhcmVudC5tYXliZUNoaWxkKCRlbmQuaW5kZXgoKSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobWFya3NbaV0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UgJiYgKCFuZXh0IHx8ICFtYXJrc1tpXS5pc0luU2V0KG5leHQubWFya3MpKSlcbiAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzW2ktLV0ucmVtb3ZlRnJvbVNldChtYXJrcyk7XG4gICAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGRlcHRoIHVwIHRvIHdoaWNoIHRoaXMgcG9zaXRpb24gYW5kIHRoZSBnaXZlbiAobm9uLXJlc29sdmVkKVxuICAgIHBvc2l0aW9uIHNoYXJlIHRoZSBzYW1lIHBhcmVudCBub2Rlcy5cbiAgICAqL1xuICAgIHNoYXJlZERlcHRoKHBvcykge1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9IHRoaXMuZGVwdGg7IGRlcHRoID4gMDsgZGVwdGgtLSlcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0KGRlcHRoKSA8PSBwb3MgJiYgdGhpcy5lbmQoZGVwdGgpID49IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVwdGg7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGEgcmFuZ2UgYmFzZWQgb24gdGhlIHBsYWNlIHdoZXJlIHRoaXMgcG9zaXRpb24gYW5kIHRoZVxuICAgIGdpdmVuIHBvc2l0aW9uIGRpdmVyZ2UgYXJvdW5kIGJsb2NrIGNvbnRlbnQuIElmIGJvdGggcG9pbnQgaW50b1xuICAgIHRoZSBzYW1lIHRleHRibG9jaywgZm9yIGV4YW1wbGUsIGEgcmFuZ2UgYXJvdW5kIHRoYXQgdGV4dGJsb2NrXG4gICAgd2lsbCBiZSByZXR1cm5lZC4gSWYgdGhleSBwb2ludCBpbnRvIGRpZmZlcmVudCBibG9ja3MsIHRoZSByYW5nZVxuICAgIGFyb3VuZCB0aG9zZSBibG9ja3MgaW4gdGhlaXIgc2hhcmVkIGFuY2VzdG9yIGlzIHJldHVybmVkLiBZb3UgY2FuXG4gICAgcGFzcyBpbiBhbiBvcHRpb25hbCBwcmVkaWNhdGUgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgcGFyZW50XG4gICAgbm9kZSB0byBzZWUgaWYgYSByYW5nZSBpbnRvIHRoYXQgcGFyZW50IGlzIGFjY2VwdGFibGUuXG4gICAgKi9cbiAgICBibG9ja1JhbmdlKG90aGVyID0gdGhpcywgcHJlZCkge1xuICAgICAgICBpZiAob3RoZXIucG9zIDwgdGhpcy5wb3MpXG4gICAgICAgICAgICByZXR1cm4gb3RoZXIuYmxvY2tSYW5nZSh0aGlzKTtcbiAgICAgICAgZm9yIChsZXQgZCA9IHRoaXMuZGVwdGggLSAodGhpcy5wYXJlbnQuaW5saW5lQ29udGVudCB8fCB0aGlzLnBvcyA9PSBvdGhlci5wb3MgPyAxIDogMCk7IGQgPj0gMDsgZC0tKVxuICAgICAgICAgICAgaWYgKG90aGVyLnBvcyA8PSB0aGlzLmVuZChkKSAmJiAoIXByZWQgfHwgcHJlZCh0aGlzLm5vZGUoZCkpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVSYW5nZSh0aGlzLCBvdGhlciwgZCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBRdWVyeSB3aGV0aGVyIHRoZSBnaXZlbiBwb3NpdGlvbiBzaGFyZXMgdGhlIHNhbWUgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBzYW1lUGFyZW50KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyAtIHRoaXMucGFyZW50T2Zmc2V0ID09IG90aGVyLnBvcyAtIG90aGVyLnBhcmVudE9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRoZSBncmVhdGVyIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIG1heChvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIucG9zID4gdGhpcy5wb3MgPyBvdGhlciA6IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgc21hbGxlciBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBtaW4ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLnBvcyA8IHRoaXMucG9zID8gb3RoZXIgOiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgc3RyID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdGhpcy5kZXB0aDsgaSsrKVxuICAgICAgICAgICAgc3RyICs9IChzdHIgPyBcIi9cIiA6IFwiXCIpICsgdGhpcy5ub2RlKGkpLnR5cGUubmFtZSArIFwiX1wiICsgdGhpcy5pbmRleChpIC0gMSk7XG4gICAgICAgIHJldHVybiBzdHIgKyBcIjpcIiArIHRoaXMucGFyZW50T2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyByZXNvbHZlKGRvYywgcG9zKSB7XG4gICAgICAgIGlmICghKHBvcyA+PSAwICYmIHBvcyA8PSBkb2MuY29udGVudC5zaXplKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUG9zaXRpb24gXCIgKyBwb3MgKyBcIiBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgIGxldCBwYXRoID0gW107XG4gICAgICAgIGxldCBzdGFydCA9IDAsIHBhcmVudE9mZnNldCA9IHBvcztcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IGRvYzs7KSB7XG4gICAgICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KHBhcmVudE9mZnNldCk7XG4gICAgICAgICAgICBsZXQgcmVtID0gcGFyZW50T2Zmc2V0IC0gb2Zmc2V0O1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUsIGluZGV4LCBzdGFydCArIG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoIXJlbSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChub2RlLmlzVGV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBhcmVudE9mZnNldCA9IHJlbSAtIDE7XG4gICAgICAgICAgICBzdGFydCArPSBvZmZzZXQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRQb3MocG9zLCBwYXRoLCBwYXJlbnRPZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyByZXNvbHZlQ2FjaGVkKGRvYywgcG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzb2x2ZUNhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2FjaGVkID0gcmVzb2x2ZUNhY2hlW2ldO1xuICAgICAgICAgICAgaWYgKGNhY2hlZC5wb3MgPT0gcG9zICYmIGNhY2hlZC5kb2MgPT0gZG9jKVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IHJlc29sdmVDYWNoZVtyZXNvbHZlQ2FjaGVQb3NdID0gUmVzb2x2ZWRQb3MucmVzb2x2ZShkb2MsIHBvcyk7XG4gICAgICAgIHJlc29sdmVDYWNoZVBvcyA9IChyZXNvbHZlQ2FjaGVQb3MgKyAxKSAlIHJlc29sdmVDYWNoZVNpemU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxubGV0IHJlc29sdmVDYWNoZSA9IFtdLCByZXNvbHZlQ2FjaGVQb3MgPSAwLCByZXNvbHZlQ2FjaGVTaXplID0gMTI7XG4vKipcblJlcHJlc2VudHMgYSBmbGF0IHJhbmdlIG9mIGNvbnRlbnQsIGkuZS4gb25lIHRoYXQgc3RhcnRzIGFuZFxuZW5kcyBpbiB0aGUgc2FtZSBub2RlLlxuKi9cbmNsYXNzIE5vZGVSYW5nZSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbm9kZSByYW5nZS4gYCRmcm9tYCBhbmQgYCR0b2Agc2hvdWxkIHBvaW50IGludG8gdGhlXG4gICAgc2FtZSBub2RlIHVudGlsIGF0IGxlYXN0IHRoZSBnaXZlbiBgZGVwdGhgLCBzaW5jZSBhIG5vZGUgcmFuZ2VcbiAgICBkZW5vdGVzIGFuIGFkamFjZW50IHNldCBvZiBub2RlcyBpbiBhIHNpbmdsZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEEgcmVzb2x2ZWQgcG9zaXRpb24gYWxvbmcgdGhlIHN0YXJ0IG9mIHRoZSBjb250ZW50LiBNYXkgaGF2ZSBhXG4gICAgYGRlcHRoYCBncmVhdGVyIHRoYW4gdGhpcyBvYmplY3QncyBgZGVwdGhgIHByb3BlcnR5LCBzaW5jZVxuICAgIHRoZXNlIGFyZSB0aGUgcG9zaXRpb25zIHRoYXQgd2VyZSB1c2VkIHRvIGNvbXB1dGUgdGhlIHJhbmdlLFxuICAgIG5vdCByZS1yZXNvbHZlZCBwb3NpdGlvbnMgZGlyZWN0bHkgYXQgaXRzIGJvdW5kYXJpZXMuXG4gICAgKi9cbiAgICAkZnJvbSwgXG4gICAgLyoqXG4gICAgQSBwb3NpdGlvbiBhbG9uZyB0aGUgZW5kIG9mIHRoZSBjb250ZW50LiBTZWVcbiAgICBjYXZlYXQgZm9yIFtgJGZyb21gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVJhbmdlLiRmcm9tKS5cbiAgICAqL1xuICAgICR0bywgXG4gICAgLyoqXG4gICAgVGhlIGRlcHRoIG9mIHRoZSBub2RlIHRoYXQgdGhpcyByYW5nZSBwb2ludHMgaW50by5cbiAgICAqL1xuICAgIGRlcHRoKSB7XG4gICAgICAgIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgICAgICAgdGhpcy4kdG8gPSAkdG87XG4gICAgICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLiRmcm9tLmJlZm9yZSh0aGlzLmRlcHRoICsgMSk7IH1cbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy4kdG8uYWZ0ZXIodGhpcy5kZXB0aCArIDEpOyB9XG4gICAgLyoqXG4gICAgVGhlIHBhcmVudCBub2RlIHRoYXQgdGhlIHJhbmdlIHBvaW50cyBpbnRvLlxuICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHsgcmV0dXJuIHRoaXMuJGZyb20ubm9kZSh0aGlzLmRlcHRoKTsgfVxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBpbmRleCBvZiB0aGUgcmFuZ2UgaW4gdGhlIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgZ2V0IHN0YXJ0SW5kZXgoKSB7IHJldHVybiB0aGlzLiRmcm9tLmluZGV4KHRoaXMuZGVwdGgpOyB9XG4gICAgLyoqXG4gICAgVGhlIGVuZCBpbmRleCBvZiB0aGUgcmFuZ2UgaW4gdGhlIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgZ2V0IGVuZEluZGV4KCkgeyByZXR1cm4gdGhpcy4kdG8uaW5kZXhBZnRlcih0aGlzLmRlcHRoKTsgfVxufVxuXG5jb25zdCBlbXB0eUF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgbm9kZSBpbiB0aGUgdHJlZSB0aGF0IG1ha2VzIHVwIGFcblByb3NlTWlycm9yIGRvY3VtZW50LiBTbyBhIGRvY3VtZW50IGlzIGFuIGluc3RhbmNlIG9mIGBOb2RlYCwgd2l0aFxuY2hpbGRyZW4gdGhhdCBhcmUgYWxzbyBpbnN0YW5jZXMgb2YgYE5vZGVgLlxuXG5Ob2RlcyBhcmUgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZXMuIEluc3RlYWQgb2YgY2hhbmdpbmcgdGhlbSwgeW91XG5jcmVhdGUgbmV3IG9uZXMgd2l0aCB0aGUgY29udGVudCB5b3Ugd2FudC4gT2xkIG9uZXMga2VlcCBwb2ludGluZ1xuYXQgdGhlIG9sZCBkb2N1bWVudCBzaGFwZS4gVGhpcyBpcyBtYWRlIGNoZWFwZXIgYnkgc2hhcmluZ1xuc3RydWN0dXJlIGJldHdlZW4gdGhlIG9sZCBhbmQgbmV3IGRhdGEgYXMgbXVjaCBhcyBwb3NzaWJsZSwgd2hpY2ggYVxudHJlZSBzaGFwZSBsaWtlIHRoaXMgKHdpdGhvdXQgYmFjayBwb2ludGVycykgbWFrZXMgZWFzeS5cblxuKipEbyBub3QqKiBkaXJlY3RseSBtdXRhdGUgdGhlIHByb3BlcnRpZXMgb2YgYSBgTm9kZWAgb2JqZWN0LiBTZWVcblt0aGUgZ3VpZGVdKC9kb2NzL2d1aWRlLyNkb2MpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuKi9cbmNsYXNzIE5vZGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2Ygbm9kZSB0aGF0IHRoaXMgaXMuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBBbiBvYmplY3QgbWFwcGluZyBhdHRyaWJ1dGUgbmFtZXMgdG8gdmFsdWVzLiBUaGUga2luZCBvZlxuICAgIGF0dHJpYnV0ZXMgYWxsb3dlZCBhbmQgcmVxdWlyZWQgYXJlXG4gICAgW2RldGVybWluZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5hdHRycykgYnkgdGhlIG5vZGUgdHlwZS5cbiAgICAqL1xuICAgIGF0dHJzLCBcbiAgICAvLyBBIGZyYWdtZW50IGhvbGRpbmcgdGhlIG5vZGUncyBjaGlsZHJlbi5cbiAgICBjb250ZW50LCBcbiAgICAvKipcbiAgICBUaGUgbWFya3MgKHRoaW5ncyBsaWtlIHdoZXRoZXIgaXQgaXMgZW1waGFzaXplZCBvciBwYXJ0IG9mIGFcbiAgICBsaW5rKSBhcHBsaWVkIHRvIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIG1hcmtzID0gTWFyay5ub25lKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50IHx8IEZyYWdtZW50LmVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2l6ZSBvZiB0aGlzIG5vZGUsIGFzIGRlZmluZWQgYnkgdGhlIGludGVnZXItYmFzZWQgW2luZGV4aW5nXG4gICAgc2NoZW1lXSgvZG9jcy9ndWlkZS8jZG9jLmluZGV4aW5nKS4gRm9yIHRleHQgbm9kZXMsIHRoaXMgaXMgdGhlXG4gICAgYW1vdW50IG9mIGNoYXJhY3RlcnMuIEZvciBvdGhlciBsZWFmIG5vZGVzLCBpdCBpcyBvbmUuIEZvclxuICAgIG5vbi1sZWFmIG5vZGVzLCBpdCBpcyB0aGUgc2l6ZSBvZiB0aGUgY29udGVudCBwbHVzIHR3byAodGhlXG4gICAgc3RhcnQgYW5kIGVuZCB0b2tlbikuXG4gICAgKi9cbiAgICBnZXQgbm9kZVNpemUoKSB7IHJldHVybiB0aGlzLmlzTGVhZiA/IDEgOiAyICsgdGhpcy5jb250ZW50LnNpemU7IH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgdGhlIG5vZGUgaGFzLlxuICAgICovXG4gICAgZ2V0IGNoaWxkQ291bnQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuY2hpbGRDb3VudDsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguIFJhaXNlcyBhbiBlcnJvciB3aGVuIHRoZVxuICAgIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAqL1xuICAgIGNoaWxkKGluZGV4KSB7IHJldHVybiB0aGlzLmNvbnRlbnQuY2hpbGQoaW5kZXgpOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleCwgaWYgaXQgZXhpc3RzLlxuICAgICovXG4gICAgbWF5YmVDaGlsZChpbmRleCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpOyB9XG4gICAgLyoqXG4gICAgQ2FsbCBgZmAgZm9yIGV2ZXJ5IGNoaWxkIG5vZGUsIHBhc3NpbmcgdGhlIG5vZGUsIGl0cyBvZmZzZXRcbiAgICBpbnRvIHRoaXMgcGFyZW50IG5vZGUsIGFuZCBpdHMgaW5kZXguXG4gICAgKi9cbiAgICBmb3JFYWNoKGYpIHsgdGhpcy5jb250ZW50LmZvckVhY2goZik7IH1cbiAgICAvKipcbiAgICBJbnZva2UgYSBjYWxsYmFjayBmb3IgYWxsIGRlc2NlbmRhbnQgbm9kZXMgcmVjdXJzaXZlbHkgYmV0d2VlblxuICAgIHRoZSBnaXZlbiB0d28gcG9zaXRpb25zIHRoYXQgYXJlIHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHRoaXNcbiAgICBub2RlJ3MgY29udGVudC4gVGhlIGNhbGxiYWNrIGlzIGludm9rZWQgd2l0aCB0aGUgbm9kZSwgaXRzXG4gICAgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIG9yaWdpbmFsIG5vZGUgKG1ldGhvZCByZWNlaXZlciksXG4gICAgaXRzIHBhcmVudCBub2RlLCBhbmQgaXRzIGNoaWxkIGluZGV4LiBXaGVuIHRoZSBjYWxsYmFjayByZXR1cm5zXG4gICAgZmFsc2UgZm9yIGEgZ2l2ZW4gbm9kZSwgdGhhdCBub2RlJ3MgY2hpbGRyZW4gd2lsbCBub3QgYmVcbiAgICByZWN1cnNlZCBvdmVyLiBUaGUgbGFzdCBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSBhXG4gICAgc3RhcnRpbmcgcG9zaXRpb24gdG8gY291bnQgZnJvbS5cbiAgICAqL1xuICAgIG5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZiwgc3RhcnRQb3MgPSAwKSB7XG4gICAgICAgIHRoaXMuY29udGVudC5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYsIHN0YXJ0UG9zLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbCB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IGRlc2NlbmRhbnQgbm9kZS4gRG9lc24ndFxuICAgIGRlc2NlbmQgaW50byBhIG5vZGUgd2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLlxuICAgICovXG4gICAgZGVzY2VuZGFudHMoZikge1xuICAgICAgICB0aGlzLm5vZGVzQmV0d2VlbigwLCB0aGlzLmNvbnRlbnQuc2l6ZSwgZik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbmNhdGVuYXRlcyBhbGwgdGhlIHRleHQgbm9kZXMgZm91bmQgaW4gdGhpcyBmcmFnbWVudCBhbmQgaXRzXG4gICAgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBnZXQgdGV4dENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pc0xlYWYgJiYgdGhpcy50eXBlLnNwZWMubGVhZlRleHQpXG4gICAgICAgICAgICA/IHRoaXMudHlwZS5zcGVjLmxlYWZUZXh0KHRoaXMpXG4gICAgICAgICAgICA6IHRoaXMudGV4dEJldHdlZW4oMCwgdGhpcy5jb250ZW50LnNpemUsIFwiXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYWxsIHRleHQgYmV0d2VlbiBwb3NpdGlvbnMgYGZyb21gIGFuZCBgdG9gLiBXaGVuXG4gICAgYGJsb2NrU2VwYXJhdG9yYCBpcyBnaXZlbiwgaXQgd2lsbCBiZSBpbnNlcnRlZCB0byBzZXBhcmF0ZSB0ZXh0XG4gICAgZnJvbSBkaWZmZXJlbnQgYmxvY2sgbm9kZXMuIElmIGBsZWFmVGV4dGAgaXMgZ2l2ZW4sIGl0J2xsIGJlXG4gICAgaW5zZXJ0ZWQgZm9yIGV2ZXJ5IG5vbi10ZXh0IGxlYWYgbm9kZSBlbmNvdW50ZXJlZCwgb3RoZXJ3aXNlXG4gICAgW2BsZWFmVGV4dGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlY15sZWFmVGV4dCkgd2lsbCBiZSB1c2VkLlxuICAgICovXG4gICAgdGV4dEJldHdlZW4oZnJvbSwgdG8sIGJsb2NrU2VwYXJhdG9yLCBsZWFmVGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LnRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoaXMgbm9kZSdzIGZpcnN0IGNoaWxkLCBvciBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vXG4gICAgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5maXJzdENoaWxkOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGlzIG5vZGUncyBsYXN0IGNoaWxkLCBvciBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vXG4gICAgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxhc3RDaGlsZDsgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0d28gbm9kZXMgcmVwcmVzZW50IHRoZSBzYW1lIHBpZWNlIG9mIGRvY3VtZW50LlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgKHRoaXMuc2FtZU1hcmt1cChvdGhlcikgJiYgdGhpcy5jb250ZW50LmVxKG90aGVyLmNvbnRlbnQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGUgbWFya3VwICh0eXBlLCBhdHRyaWJ1dGVzLCBhbmQgbWFya3MpIG9mIHRoaXMgbm9kZSB0b1xuICAgIHRob3NlIG9mIGFub3RoZXIuIFJldHVybnMgYHRydWVgIGlmIGJvdGggaGF2ZSB0aGUgc2FtZSBtYXJrdXAuXG4gICAgKi9cbiAgICBzYW1lTWFya3VwKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc01hcmt1cChvdGhlci50eXBlLCBvdGhlci5hdHRycywgb3RoZXIubWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoaXMgbm9kZSdzIG1hcmt1cCBjb3JyZXNwb25kIHRvIHRoZSBnaXZlbiB0eXBlLFxuICAgIGF0dHJpYnV0ZXMsIGFuZCBtYXJrcy5cbiAgICAqL1xuICAgIGhhc01hcmt1cCh0eXBlLCBhdHRycywgbWFya3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSB0eXBlICYmXG4gICAgICAgICAgICBjb21wYXJlRGVlcCh0aGlzLmF0dHJzLCBhdHRycyB8fCB0eXBlLmRlZmF1bHRBdHRycyB8fCBlbXB0eUF0dHJzKSAmJlxuICAgICAgICAgICAgTWFyay5zYW1lU2V0KHRoaXMubWFya3MsIG1hcmtzIHx8IE1hcmsubm9uZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBub2RlIHdpdGggdGhlIHNhbWUgbWFya3VwIGFzIHRoaXMgbm9kZSwgY29udGFpbmluZ1xuICAgIHRoZSBnaXZlbiBjb250ZW50IChvciBlbXB0eSwgaWYgbm8gY29udGVudCBpcyBnaXZlbikuXG4gICAgKi9cbiAgICBjb3B5KGNvbnRlbnQgPSBudWxsKSB7XG4gICAgICAgIGlmIChjb250ZW50ID09IHRoaXMuY29udGVudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCBjb250ZW50LCB0aGlzLm1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIG5vZGUsIHdpdGggdGhlIGdpdmVuIHNldCBvZiBtYXJrcyBpbnN0ZWFkXG4gICAgb2YgdGhlIG5vZGUncyBvd24gbWFya3MuXG4gICAgKi9cbiAgICBtYXJrKG1hcmtzKSB7XG4gICAgICAgIHJldHVybiBtYXJrcyA9PSB0aGlzLm1hcmtzID8gdGhpcyA6IG5ldyBOb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGhpcy5jb250ZW50LCBtYXJrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBub2RlIHdpdGggb25seSB0aGUgY29udGVudCBiZXR3ZWVuIHRoZVxuICAgIGdpdmVuIHBvc2l0aW9ucy4gSWYgYHRvYCBpcyBub3QgZ2l2ZW4sIGl0IGRlZmF1bHRzIHRvIHRoZSBlbmQgb2ZcbiAgICB0aGUgbm9kZS5cbiAgICAqL1xuICAgIGN1dChmcm9tLCB0byA9IHRoaXMuY29udGVudC5zaXplKSB7XG4gICAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSh0aGlzLmNvbnRlbnQuY3V0KGZyb20sIHRvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEN1dCBvdXQgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucywgYW5kXG4gICAgcmV0dXJuIGl0IGFzIGEgYFNsaWNlYCBvYmplY3QuXG4gICAgKi9cbiAgICBzbGljZShmcm9tLCB0byA9IHRoaXMuY29udGVudC5zaXplLCBpbmNsdWRlUGFyZW50cyA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChmcm9tID09IHRvKVxuICAgICAgICAgICAgcmV0dXJuIFNsaWNlLmVtcHR5O1xuICAgICAgICBsZXQgJGZyb20gPSB0aGlzLnJlc29sdmUoZnJvbSksICR0byA9IHRoaXMucmVzb2x2ZSh0byk7XG4gICAgICAgIGxldCBkZXB0aCA9IGluY2x1ZGVQYXJlbnRzID8gMCA6ICRmcm9tLnNoYXJlZERlcHRoKHRvKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gJGZyb20uc3RhcnQoZGVwdGgpLCBub2RlID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgIGxldCBjb250ZW50ID0gbm9kZS5jb250ZW50LmN1dCgkZnJvbS5wb3MgLSBzdGFydCwgJHRvLnBvcyAtIHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShjb250ZW50LCAkZnJvbS5kZXB0aCAtIGRlcHRoLCAkdG8uZGVwdGggLSBkZXB0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucyB3aXRoXG4gICAgdGhlIGdpdmVuIHNsaWNlLiBUaGUgc2xpY2UgbXVzdCAnZml0JywgbWVhbmluZyBpdHMgb3BlbiBzaWRlc1xuICAgIG11c3QgYmUgYWJsZSB0byBjb25uZWN0IHRvIHRoZSBzdXJyb3VuZGluZyBjb250ZW50LCBhbmQgaXRzXG4gICAgY29udGVudCBub2RlcyBtdXN0IGJlIHZhbGlkIGNoaWxkcmVuIGZvciB0aGUgbm9kZSB0aGV5IGFyZSBwbGFjZWRcbiAgICBpbnRvLiBJZiBhbnkgb2YgdGhpcyBpcyB2aW9sYXRlZCwgYW4gZXJyb3Igb2YgdHlwZVxuICAgIFtgUmVwbGFjZUVycm9yYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlJlcGxhY2VFcnJvcikgaXMgdGhyb3duLlxuICAgICovXG4gICAgcmVwbGFjZShmcm9tLCB0bywgc2xpY2UpIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2UodGhpcy5yZXNvbHZlKGZyb20pLCB0aGlzLnJlc29sdmUodG8pLCBzbGljZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIG5vZGUgZGlyZWN0bHkgYWZ0ZXIgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbm9kZUF0KHBvcykge1xuICAgICAgICBmb3IgKGxldCBub2RlID0gdGhpczs7KSB7XG4gICAgICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KHBvcyk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gcG9zIHx8IG5vZGUuaXNUZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgcG9zIC09IG9mZnNldCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgKGRpcmVjdCkgY2hpbGQgbm9kZSBhZnRlciB0aGUgZ2l2ZW4gb2Zmc2V0LCBpZiBhbnksXG4gICAgYW5kIHJldHVybiBpdCBhbG9uZyB3aXRoIGl0cyBpbmRleCBhbmQgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoaXNcbiAgICBub2RlLlxuICAgICovXG4gICAgY2hpbGRBZnRlcihwb3MpIHtcbiAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gdGhpcy5jb250ZW50LmZpbmRJbmRleChwb3MpO1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnQubWF5YmVDaGlsZChpbmRleCksIGluZGV4LCBvZmZzZXQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgKGRpcmVjdCkgY2hpbGQgbm9kZSBiZWZvcmUgdGhlIGdpdmVuIG9mZnNldCwgaWYgYW55LFxuICAgIGFuZCByZXR1cm4gaXQgYWxvbmcgd2l0aCBpdHMgaW5kZXggYW5kIG9mZnNldCByZWxhdGl2ZSB0byB0aGlzXG4gICAgbm9kZS5cbiAgICAqL1xuICAgIGNoaWxkQmVmb3JlKHBvcykge1xuICAgICAgICBpZiAocG9zID09IDApXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiBudWxsLCBpbmRleDogMCwgb2Zmc2V0OiAwIH07XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IHRoaXMuY29udGVudC5maW5kSW5kZXgocG9zKTtcbiAgICAgICAgaWYgKG9mZnNldCA8IHBvcylcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudC5jaGlsZChpbmRleCksIGluZGV4LCBvZmZzZXQgfTtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmNvbnRlbnQuY2hpbGQoaW5kZXggLSAxKTtcbiAgICAgICAgcmV0dXJuIHsgbm9kZSwgaW5kZXg6IGluZGV4IC0gMSwgb2Zmc2V0OiBvZmZzZXQgLSBub2RlLm5vZGVTaXplIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc29sdmUgdGhlIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCwgcmV0dXJuaW5nIGFuXG4gICAgW29iamVjdF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlJlc29sdmVkUG9zKSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IGl0cyBjb250ZXh0LlxuICAgICovXG4gICAgcmVzb2x2ZShwb3MpIHsgcmV0dXJuIFJlc29sdmVkUG9zLnJlc29sdmVDYWNoZWQodGhpcywgcG9zKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzb2x2ZU5vQ2FjaGUocG9zKSB7IHJldHVybiBSZXNvbHZlZFBvcy5yZXNvbHZlKHRoaXMsIHBvcyk7IH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgYSBnaXZlbiBtYXJrIG9yIG1hcmsgdHlwZSBvY2N1cnMgaW4gdGhpcyBkb2N1bWVudFxuICAgIGJldHdlZW4gdGhlIHR3byBnaXZlbiBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICByYW5nZUhhc01hcmsoZnJvbSwgdG8sIHR5cGUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGlmICh0byA+IGZyb20pXG4gICAgICAgICAgICB0aGlzLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuaXNJblNldChub2RlLm1hcmtzKSlcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAhZm91bmQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhIGJsb2NrIChub24taW5saW5lIG5vZGUpXG4gICAgKi9cbiAgICBnZXQgaXNCbG9jaygpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0Jsb2NrOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSB0ZXh0YmxvY2sgbm9kZSwgYSBibG9jayBub2RlIHdpdGggaW5saW5lXG4gICAgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc1RleHRibG9jaygpIHsgcmV0dXJuIHRoaXMudHlwZS5pc1RleHRibG9jazsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG5vZGUgYWxsb3dzIGlubGluZSBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlubGluZUNvbnRlbnQoKSB7IHJldHVybiB0aGlzLnR5cGUuaW5saW5lQ29udGVudDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGFuIGlubGluZSBub2RlIChhIHRleHQgbm9kZSBvciBhIG5vZGUgdGhhdCBjYW5cbiAgICBhcHBlYXIgYW1vbmcgdGV4dCkuXG4gICAgKi9cbiAgICBnZXQgaXNJbmxpbmUoKSB7IHJldHVybiB0aGlzLnR5cGUuaXNJbmxpbmU7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhIHRleHQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBpc1RleHQoKSB7IHJldHVybiB0aGlzLnR5cGUuaXNUZXh0OyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSBsZWFmIG5vZGUuXG4gICAgKi9cbiAgICBnZXQgaXNMZWFmKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzTGVhZjsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGFuIGF0b20sIGkuZS4gd2hlbiBpdCBkb2VzIG5vdCBoYXZlIGRpcmVjdGx5XG4gICAgZWRpdGFibGUgY29udGVudC4gVGhpcyBpcyB1c3VhbGx5IHRoZSBzYW1lIGFzIGBpc0xlYWZgLCBidXQgY2FuXG4gICAgYmUgY29uZmlndXJlZCB3aXRoIHRoZSBbYGF0b21gIHByb3BlcnR5XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuYXRvbSlcbiAgICBvbiBhIG5vZGUncyBzcGVjICh0eXBpY2FsbHkgdXNlZCB3aGVuIHRoZSBub2RlIGlzIGRpc3BsYXllZCBhc1xuICAgIGFuIHVuZWRpdGFibGUgW25vZGUgdmlld10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuTm9kZVZpZXcpKS5cbiAgICAqL1xuICAgIGdldCBpc0F0b20oKSB7IHJldHVybiB0aGlzLnR5cGUuaXNBdG9tOyB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZSBmb3IgZGVidWdnaW5nXG4gICAgcHVycG9zZXMuXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZyh0aGlzKTtcbiAgICAgICAgbGV0IG5hbWUgPSB0aGlzLnR5cGUubmFtZTtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgbmFtZSArPSBcIihcIiArIHRoaXMuY29udGVudC50b1N0cmluZ0lubmVyKCkgKyBcIilcIjtcbiAgICAgICAgcmV0dXJuIHdyYXBNYXJrcyh0aGlzLm1hcmtzLCBuYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjb250ZW50IG1hdGNoIGluIHRoaXMgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgKi9cbiAgICBjb250ZW50TWF0Y2hBdChpbmRleCkge1xuICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCAwLCBpbmRleCk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgY29udGVudE1hdGNoQXQgb24gYSBub2RlIHdpdGggaW52YWxpZCBjb250ZW50XCIpO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciByZXBsYWNpbmcgdGhlIHJhbmdlIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIChieVxuICAgIGNoaWxkIGluZGV4KSB3aXRoIHRoZSBnaXZlbiByZXBsYWNlbWVudCBmcmFnbWVudCAod2hpY2ggZGVmYXVsdHNcbiAgICB0byB0aGUgZW1wdHkgZnJhZ21lbnQpIHdvdWxkIGxlYXZlIHRoZSBub2RlJ3MgY29udGVudCB2YWxpZC4gWW91XG4gICAgY2FuIG9wdGlvbmFsbHkgcGFzcyBgc3RhcnRgIGFuZCBgZW5kYCBpbmRpY2VzIGludG8gdGhlXG4gICAgcmVwbGFjZW1lbnQgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBjYW5SZXBsYWNlKGZyb20sIHRvLCByZXBsYWNlbWVudCA9IEZyYWdtZW50LmVtcHR5LCBzdGFydCA9IDAsIGVuZCA9IHJlcGxhY2VtZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgbGV0IG9uZSA9IHRoaXMuY29udGVudE1hdGNoQXQoZnJvbSkubWF0Y2hGcmFnbWVudChyZXBsYWNlbWVudCwgc3RhcnQsIGVuZCk7XG4gICAgICAgIGxldCB0d28gPSBvbmUgJiYgb25lLm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCB0byk7XG4gICAgICAgIGlmICghdHdvIHx8ICF0d28udmFsaWRFbmQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnR5cGUuYWxsb3dzTWFya3MocmVwbGFjZW1lbnQuY2hpbGQoaSkubWFya3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciByZXBsYWNpbmcgdGhlIHJhbmdlIGBmcm9tYCB0byBgdG9gIChieSBpbmRleCkgd2l0aFxuICAgIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSB3b3VsZCBsZWF2ZSB0aGUgbm9kZSdzIGNvbnRlbnQgdmFsaWQuXG4gICAgKi9cbiAgICBjYW5SZXBsYWNlV2l0aChmcm9tLCB0bywgdHlwZSwgbWFya3MpIHtcbiAgICAgICAgaWYgKG1hcmtzICYmICF0aGlzLnR5cGUuYWxsb3dzTWFya3MobWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmNvbnRlbnRNYXRjaEF0KGZyb20pLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICYmIHN0YXJ0Lm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCB0byk7XG4gICAgICAgIHJldHVybiBlbmQgPyBlbmQudmFsaWRFbmQgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiBub2RlJ3MgY29udGVudCBjb3VsZCBiZSBhcHBlbmRlZCB0byB0aGlzXG4gICAgbm9kZS4gSWYgdGhhdCBub2RlIGlzIGVtcHR5LCB0aGlzIHdpbGwgb25seSByZXR1cm4gdHJ1ZSBpZiB0aGVyZVxuICAgIGlzIGF0IGxlYXN0IG9uZSBub2RlIHR5cGUgdGhhdCBjYW4gYXBwZWFyIGluIGJvdGggbm9kZXMgKHRvIGF2b2lkXG4gICAgbWVyZ2luZyBjb21wbGV0ZWx5IGluY29tcGF0aWJsZSBub2RlcykuXG4gICAgKi9cbiAgICBjYW5BcHBlbmQob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhblJlcGxhY2UodGhpcy5jaGlsZENvdW50LCB0aGlzLmNoaWxkQ291bnQsIG90aGVyLmNvbnRlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLmNvbXBhdGlibGVDb250ZW50KG90aGVyLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoaXMgbm9kZSBhbmQgaXRzIGRlc2NlbmRhbnRzIGNvbmZvcm0gdG8gdGhlXG4gICAgc2NoZW1hLCBhbmQgcmFpc2UgZXJyb3Igd2hlbiB0aGV5IGRvIG5vdC5cbiAgICAqL1xuICAgIGNoZWNrKCkge1xuICAgICAgICB0aGlzLnR5cGUuY2hlY2tDb250ZW50KHRoaXMuY29udGVudCk7XG4gICAgICAgIGxldCBjb3B5ID0gTWFyay5ub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBjb3B5ID0gdGhpcy5tYXJrc1tpXS5hZGRUb1NldChjb3B5KTtcbiAgICAgICAgaWYgKCFNYXJrLnNhbWVTZXQoY29weSwgdGhpcy5tYXJrcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBjb2xsZWN0aW9uIG9mIG1hcmtzIGZvciBub2RlICR7dGhpcy50eXBlLm5hbWV9OiAke3RoaXMubWFya3MubWFwKG0gPT4gbS50eXBlLm5hbWUpfWApO1xuICAgICAgICB0aGlzLmNvbnRlbnQuZm9yRWFjaChub2RlID0+IG5vZGUuY2hlY2soKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIEpTT04tc2VyaWFsaXplYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBvYmogPSB7IHR5cGU6IHRoaXMudHlwZS5uYW1lIH07XG4gICAgICAgIGZvciAobGV0IF8gaW4gdGhpcy5hdHRycykge1xuICAgICAgICAgICAgb2JqLmF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIG9iai5jb250ZW50ID0gdGhpcy5jb250ZW50LnRvSlNPTigpO1xuICAgICAgICBpZiAodGhpcy5tYXJrcy5sZW5ndGgpXG4gICAgICAgICAgICBvYmoubWFya3MgPSB0aGlzLm1hcmtzLm1hcChuID0+IG4udG9KU09OKCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG5vZGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBOb2RlLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgbWFya3MgPSBudWxsO1xuICAgICAgICBpZiAoanNvbi5tYXJrcykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24ubWFya3MpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBtYXJrIGRhdGEgZm9yIE5vZGUuZnJvbUpTT05cIik7XG4gICAgICAgICAgICBtYXJrcyA9IGpzb24ubWFya3MubWFwKHNjaGVtYS5tYXJrRnJvbUpTT04pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc29uLnR5cGUgPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbi50ZXh0ICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHRleHQgbm9kZSBpbiBKU09OXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS50ZXh0KGpzb24udGV4dCwgbWFya3MpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50ID0gRnJhZ21lbnQuZnJvbUpTT04oc2NoZW1hLCBqc29uLmNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gc2NoZW1hLm5vZGVUeXBlKGpzb24udHlwZSkuY3JlYXRlKGpzb24uYXR0cnMsIGNvbnRlbnQsIG1hcmtzKTtcbiAgICB9XG59XG5Ob2RlLnByb3RvdHlwZS50ZXh0ID0gdW5kZWZpbmVkO1xuY2xhc3MgVGV4dE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGF0dHJzLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBzdXBlcih0eXBlLCBhdHRycywgbnVsbCwgbWFya3MpO1xuICAgICAgICBpZiAoIWNvbnRlbnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkVtcHR5IHRleHQgbm9kZXMgYXJlIG5vdCBhbGxvd2VkXCIpO1xuICAgICAgICB0aGlzLnRleHQgPSBjb250ZW50O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHdyYXBNYXJrcyh0aGlzLm1hcmtzLCBKU09OLnN0cmluZ2lmeSh0aGlzLnRleHQpKTtcbiAgICB9XG4gICAgZ2V0IHRleHRDb250ZW50KCkgeyByZXR1cm4gdGhpcy50ZXh0OyB9XG4gICAgdGV4dEJldHdlZW4oZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMudGV4dC5zbGljZShmcm9tLCB0byk7IH1cbiAgICBnZXQgbm9kZVNpemUoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgbWFyayhtYXJrcykge1xuICAgICAgICByZXR1cm4gbWFya3MgPT0gdGhpcy5tYXJrcyA/IHRoaXMgOiBuZXcgVGV4dE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCB0aGlzLnRleHQsIG1hcmtzKTtcbiAgICB9XG4gICAgd2l0aFRleHQodGV4dCkge1xuICAgICAgICBpZiAodGV4dCA9PSB0aGlzLnRleHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Tm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRleHQsIHRoaXMubWFya3MpO1xuICAgIH1cbiAgICBjdXQoZnJvbSA9IDAsIHRvID0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMudGV4dC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aFRleHQodGhpcy50ZXh0LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhbWVNYXJrdXAob3RoZXIpICYmIHRoaXMudGV4dCA9PSBvdGhlci50ZXh0O1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBiYXNlID0gc3VwZXIudG9KU09OKCk7XG4gICAgICAgIGJhc2UudGV4dCA9IHRoaXMudGV4dDtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JhcE1hcmtzKG1hcmtzLCBzdHIpIHtcbiAgICBmb3IgKGxldCBpID0gbWFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHN0ciA9IG1hcmtzW2ldLnR5cGUubmFtZSArIFwiKFwiICsgc3RyICsgXCIpXCI7XG4gICAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG5JbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgYSBtYXRjaCBzdGF0ZSBvZiBhIG5vZGUgdHlwZSdzXG5bY29udGVudCBleHByZXNzaW9uXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuY29udGVudCksIGFuZCBjYW4gYmUgdXNlZCB0b1xuZmluZCBvdXQgd2hldGhlciBmdXJ0aGVyIGNvbnRlbnQgbWF0Y2hlcyBoZXJlLCBhbmQgd2hldGhlciBhIGdpdmVuXG5wb3NpdGlvbiBpcyBhIHZhbGlkIGVuZCBvZiB0aGUgbm9kZS5cbiovXG5jbGFzcyBDb250ZW50TWF0Y2gge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbWF0Y2ggc3RhdGUgcmVwcmVzZW50cyBhIHZhbGlkIGVuZCBvZiB0aGUgbm9kZS5cbiAgICAqL1xuICAgIHZhbGlkRW5kKSB7XG4gICAgICAgIHRoaXMudmFsaWRFbmQgPSB2YWxpZEVuZDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm5leHQgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLndyYXBDYWNoZSA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBwYXJzZShzdHJpbmcsIG5vZGVUeXBlcykge1xuICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFRva2VuU3RyZWFtKHN0cmluZywgbm9kZVR5cGVzKTtcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gQ29udGVudE1hdGNoLmVtcHR5O1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHJlYW0pO1xuICAgICAgICBpZiAoc3RyZWFtLm5leHQpXG4gICAgICAgICAgICBzdHJlYW0uZXJyKFwiVW5leHBlY3RlZCB0cmFpbGluZyB0ZXh0XCIpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBkZmEobmZhKGV4cHIpKTtcbiAgICAgICAgY2hlY2tGb3JEZWFkRW5kcyhtYXRjaCwgc3RyZWFtKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXRjaCBhIG5vZGUgdHlwZSwgcmV0dXJuaW5nIGEgbWF0Y2ggYWZ0ZXIgdGhhdCBub2RlIGlmXG4gICAgc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIG1hdGNoVHlwZSh0eXBlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMubmV4dFtpXS50eXBlID09IHR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dFtpXS5uZXh0O1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIG1hdGNoIGEgZnJhZ21lbnQuIFJldHVybnMgdGhlIHJlc3VsdGluZyBtYXRjaCB3aGVuXG4gICAgc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIG1hdGNoRnJhZ21lbnQoZnJhZywgc3RhcnQgPSAwLCBlbmQgPSBmcmFnLmNoaWxkQ291bnQpIHtcbiAgICAgICAgbGV0IGN1ciA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgY3VyICYmIGkgPCBlbmQ7IGkrKylcbiAgICAgICAgICAgIGN1ciA9IGN1ci5tYXRjaFR5cGUoZnJhZy5jaGlsZChpKS50eXBlKTtcbiAgICAgICAgcmV0dXJuIGN1cjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaW5saW5lQ29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dC5sZW5ndGggIT0gMCAmJiB0aGlzLm5leHRbMF0udHlwZS5pc0lubGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBmaXJzdCBtYXRjaGluZyBub2RlIHR5cGUgYXQgdGhpcyBtYXRjaCBwb3NpdGlvbiB0aGF0IGNhblxuICAgIGJlIGdlbmVyYXRlZC5cbiAgICAqL1xuICAgIGdldCBkZWZhdWx0VHlwZSgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IHR5cGUgfSA9IHRoaXMubmV4dFtpXTtcbiAgICAgICAgICAgIGlmICghKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXRpYmxlKG90aGVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvdGhlci5uZXh0Lmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5leHRbaV0udHlwZSA9PSBvdGhlci5uZXh0W2pdLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBtYXRjaCB0aGUgZ2l2ZW4gZnJhZ21lbnQsIGFuZCBpZiB0aGF0IGZhaWxzLCBzZWUgaWYgaXQgY2FuXG4gICAgYmUgbWFkZSB0byBtYXRjaCBieSBpbnNlcnRpbmcgbm9kZXMgaW4gZnJvbnQgb2YgaXQuIFdoZW5cbiAgICBzdWNjZXNzZnVsLCByZXR1cm4gYSBmcmFnbWVudCBvZiBpbnNlcnRlZCBub2RlcyAod2hpY2ggbWF5IGJlXG4gICAgZW1wdHkgaWYgbm90aGluZyBoYWQgdG8gYmUgaW5zZXJ0ZWQpLiBXaGVuIGB0b0VuZGAgaXMgdHJ1ZSwgb25seVxuICAgIHJldHVybiBhIGZyYWdtZW50IGlmIHRoZSByZXN1bHRpbmcgbWF0Y2ggZ29lcyB0byB0aGUgZW5kIG9mIHRoZVxuICAgIGNvbnRlbnQgZXhwcmVzc2lvbi5cbiAgICAqL1xuICAgIGZpbGxCZWZvcmUoYWZ0ZXIsIHRvRW5kID0gZmFsc2UsIHN0YXJ0SW5kZXggPSAwKSB7XG4gICAgICAgIGxldCBzZWVuID0gW3RoaXNdO1xuICAgICAgICBmdW5jdGlvbiBzZWFyY2gobWF0Y2gsIHR5cGVzKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSBtYXRjaC5tYXRjaEZyYWdtZW50KGFmdGVyLCBzdGFydEluZGV4KTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZCAmJiAoIXRvRW5kIHx8IGZpbmlzaGVkLnZhbGlkRW5kKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbSh0eXBlcy5tYXAodHAgPT4gdHAuY3JlYXRlQW5kRmlsbCgpKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBuZXh0IH0gPSBtYXRjaC5uZXh0W2ldO1xuICAgICAgICAgICAgICAgIGlmICghKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSAmJiBzZWVuLmluZGV4T2YobmV4dCkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vlbi5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBzZWFyY2gobmV4dCwgdHlwZXMuY29uY2F0KHR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWFyY2godGhpcywgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGEgc2V0IG9mIHdyYXBwaW5nIG5vZGUgdHlwZXMgdGhhdCB3b3VsZCBhbGxvdyBhIG5vZGUgb2YgdGhlXG4gICAgZ2l2ZW4gdHlwZSB0byBhcHBlYXIgYXQgdGhpcyBwb3NpdGlvbi4gVGhlIHJlc3VsdCBtYXkgYmUgZW1wdHlcbiAgICAod2hlbiBpdCBmaXRzIGRpcmVjdGx5KSBhbmQgd2lsbCBiZSBudWxsIHdoZW4gbm8gc3VjaCB3cmFwcGluZ1xuICAgIGV4aXN0cy5cbiAgICAqL1xuICAgIGZpbmRXcmFwcGluZyh0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndyYXBDYWNoZS5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIGlmICh0aGlzLndyYXBDYWNoZVtpXSA9PSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcENhY2hlW2kgKyAxXTtcbiAgICAgICAgbGV0IGNvbXB1dGVkID0gdGhpcy5jb21wdXRlV3JhcHBpbmcodGFyZ2V0KTtcbiAgICAgICAgdGhpcy53cmFwQ2FjaGUucHVzaCh0YXJnZXQsIGNvbXB1dGVkKTtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVkO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXB1dGVXcmFwcGluZyh0YXJnZXQpIHtcbiAgICAgICAgbGV0IHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpLCBhY3RpdmUgPSBbeyBtYXRjaDogdGhpcywgdHlwZTogbnVsbCwgdmlhOiBudWxsIH1dO1xuICAgICAgICB3aGlsZSAoYWN0aXZlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSBhY3RpdmUuc2hpZnQoKSwgbWF0Y2ggPSBjdXJyZW50Lm1hdGNoO1xuICAgICAgICAgICAgaWYgKG1hdGNoLm1hdGNoVHlwZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9iaiA9IGN1cnJlbnQ7IG9iai50eXBlOyBvYmogPSBvYmoudmlhKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmoudHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBuZXh0IH0gPSBtYXRjaC5uZXh0W2ldO1xuICAgICAgICAgICAgICAgIGlmICghdHlwZS5pc0xlYWYgJiYgIXR5cGUuaGFzUmVxdWlyZWRBdHRycygpICYmICEodHlwZS5uYW1lIGluIHNlZW4pICYmICghY3VycmVudC50eXBlIHx8IG5leHQudmFsaWRFbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKHsgbWF0Y2g6IHR5cGUuY29udGVudE1hdGNoLCB0eXBlLCB2aWE6IGN1cnJlbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNlZW5bdHlwZS5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIG91dGdvaW5nIGVkZ2VzIHRoaXMgbm9kZSBoYXMgaW4gdGhlIGZpbml0ZVxuICAgIGF1dG9tYXRvbiB0aGF0IGRlc2NyaWJlcyB0aGUgY29udGVudCBleHByZXNzaW9uLlxuICAgICovXG4gICAgZ2V0IGVkZ2VDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dC5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgX25fXHUyMDBCdGggb3V0Z29pbmcgZWRnZSBmcm9tIHRoaXMgbm9kZSBpbiB0aGUgZmluaXRlXG4gICAgYXV0b21hdG9uIHRoYXQgZGVzY3JpYmVzIHRoZSBjb250ZW50IGV4cHJlc3Npb24uXG4gICAgKi9cbiAgICBlZGdlKG4pIHtcbiAgICAgICAgaWYgKG4gPj0gdGhpcy5uZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGVyZSdzIG5vICR7bn10aCBlZGdlIGluIHRoaXMgY29udGVudCBtYXRjaGApO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0W25dO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgc2VlbiA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBzY2FuKG0pIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChtKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbS5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2YobS5uZXh0W2ldLm5leHQpID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzY2FuKG0ubmV4dFtpXS5uZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBzY2FuKHRoaXMpO1xuICAgICAgICByZXR1cm4gc2Vlbi5tYXAoKG0sIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBvdXQgPSBpICsgKG0udmFsaWRFbmQgPyBcIipcIiA6IFwiIFwiKSArIFwiIFwiO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtLm5leHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgb3V0ICs9IChpID8gXCIsIFwiIDogXCJcIikgKyBtLm5leHRbaV0udHlwZS5uYW1lICsgXCItPlwiICsgc2Vlbi5pbmRleE9mKG0ubmV4dFtpXS5uZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgfVxufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5Db250ZW50TWF0Y2guZW1wdHkgPSBuZXcgQ29udGVudE1hdGNoKHRydWUpO1xuY2xhc3MgVG9rZW5TdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZywgbm9kZVR5cGVzKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICB0aGlzLm5vZGVUeXBlcyA9IG5vZGVUeXBlcztcbiAgICAgICAgdGhpcy5pbmxpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMudG9rZW5zID0gc3RyaW5nLnNwbGl0KC9cXHMqKD89XFxifFxcV3wkKS8pO1xuICAgICAgICBpZiAodGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0gPT0gXCJcIilcbiAgICAgICAgICAgIHRoaXMudG9rZW5zLnBvcCgpO1xuICAgICAgICBpZiAodGhpcy50b2tlbnNbMF0gPT0gXCJcIilcbiAgICAgICAgICAgIHRoaXMudG9rZW5zLnNoaWZ0KCk7XG4gICAgfVxuICAgIGdldCBuZXh0KCkgeyByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5wb3NdOyB9XG4gICAgZWF0KHRvaykgeyByZXR1cm4gdGhpcy5uZXh0ID09IHRvayAmJiAodGhpcy5wb3MrKyB8fCB0cnVlKTsgfVxuICAgIGVycihzdHIpIHsgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN0ciArIFwiIChpbiBjb250ZW50IGV4cHJlc3Npb24gJ1wiICsgdGhpcy5zdHJpbmcgKyBcIicpXCIpOyB9XG59XG5mdW5jdGlvbiBwYXJzZUV4cHIoc3RyZWFtKSB7XG4gICAgbGV0IGV4cHJzID0gW107XG4gICAgZG8ge1xuICAgICAgICBleHBycy5wdXNoKHBhcnNlRXhwclNlcShzdHJlYW0pKTtcbiAgICB9IHdoaWxlIChzdHJlYW0uZWF0KFwifFwiKSk7XG4gICAgcmV0dXJuIGV4cHJzLmxlbmd0aCA9PSAxID8gZXhwcnNbMF0gOiB7IHR5cGU6IFwiY2hvaWNlXCIsIGV4cHJzIH07XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJTZXEoc3RyZWFtKSB7XG4gICAgbGV0IGV4cHJzID0gW107XG4gICAgZG8ge1xuICAgICAgICBleHBycy5wdXNoKHBhcnNlRXhwclN1YnNjcmlwdChzdHJlYW0pKTtcbiAgICB9IHdoaWxlIChzdHJlYW0ubmV4dCAmJiBzdHJlYW0ubmV4dCAhPSBcIilcIiAmJiBzdHJlYW0ubmV4dCAhPSBcInxcIik7XG4gICAgcmV0dXJuIGV4cHJzLmxlbmd0aCA9PSAxID8gZXhwcnNbMF0gOiB7IHR5cGU6IFwic2VxXCIsIGV4cHJzIH07XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJTdWJzY3JpcHQoc3RyZWFtKSB7XG4gICAgbGV0IGV4cHIgPSBwYXJzZUV4cHJBdG9tKHN0cmVhbSk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdChcIitcIikpXG4gICAgICAgICAgICBleHByID0geyB0eXBlOiBcInBsdXNcIiwgZXhwciB9O1xuICAgICAgICBlbHNlIGlmIChzdHJlYW0uZWF0KFwiKlwiKSlcbiAgICAgICAgICAgIGV4cHIgPSB7IHR5cGU6IFwic3RhclwiLCBleHByIH07XG4gICAgICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoXCI/XCIpKVxuICAgICAgICAgICAgZXhwciA9IHsgdHlwZTogXCJvcHRcIiwgZXhwciB9O1xuICAgICAgICBlbHNlIGlmIChzdHJlYW0uZWF0KFwie1wiKSlcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZUV4cHJSYW5nZShzdHJlYW0sIGV4cHIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG59XG5mdW5jdGlvbiBwYXJzZU51bShzdHJlYW0pIHtcbiAgICBpZiAoL1xcRC8udGVzdChzdHJlYW0ubmV4dCkpXG4gICAgICAgIHN0cmVhbS5lcnIoXCJFeHBlY3RlZCBudW1iZXIsIGdvdCAnXCIgKyBzdHJlYW0ubmV4dCArIFwiJ1wiKTtcbiAgICBsZXQgcmVzdWx0ID0gTnVtYmVyKHN0cmVhbS5uZXh0KTtcbiAgICBzdHJlYW0ucG9zKys7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwclJhbmdlKHN0cmVhbSwgZXhwcikge1xuICAgIGxldCBtaW4gPSBwYXJzZU51bShzdHJlYW0pLCBtYXggPSBtaW47XG4gICAgaWYgKHN0cmVhbS5lYXQoXCIsXCIpKSB7XG4gICAgICAgIGlmIChzdHJlYW0ubmV4dCAhPSBcIn1cIilcbiAgICAgICAgICAgIG1heCA9IHBhcnNlTnVtKHN0cmVhbSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1heCA9IC0xO1xuICAgIH1cbiAgICBpZiAoIXN0cmVhbS5lYXQoXCJ9XCIpKVxuICAgICAgICBzdHJlYW0uZXJyKFwiVW5jbG9zZWQgYnJhY2VkIHJhbmdlXCIpO1xuICAgIHJldHVybiB7IHR5cGU6IFwicmFuZ2VcIiwgbWluLCBtYXgsIGV4cHIgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVOYW1lKHN0cmVhbSwgbmFtZSkge1xuICAgIGxldCB0eXBlcyA9IHN0cmVhbS5ub2RlVHlwZXMsIHR5cGUgPSB0eXBlc1tuYW1lXTtcbiAgICBpZiAodHlwZSlcbiAgICAgICAgcmV0dXJuIFt0eXBlXTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgdHlwZU5hbWUgaW4gdHlwZXMpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1t0eXBlTmFtZV07XG4gICAgICAgIGlmICh0eXBlLmdyb3Vwcy5pbmRleE9mKG5hbWUpID4gLTEpXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0eXBlKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPT0gMClcbiAgICAgICAgc3RyZWFtLmVycihcIk5vIG5vZGUgdHlwZSBvciBncm91cCAnXCIgKyBuYW1lICsgXCInIGZvdW5kXCIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJBdG9tKHN0cmVhbSkge1xuICAgIGlmIChzdHJlYW0uZWF0KFwiKFwiKSkge1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHJlYW0pO1xuICAgICAgICBpZiAoIXN0cmVhbS5lYXQoXCIpXCIpKVxuICAgICAgICAgICAgc3RyZWFtLmVycihcIk1pc3NpbmcgY2xvc2luZyBwYXJlblwiKTtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICAgIGVsc2UgaWYgKCEvXFxXLy50ZXN0KHN0cmVhbS5uZXh0KSkge1xuICAgICAgICBsZXQgZXhwcnMgPSByZXNvbHZlTmFtZShzdHJlYW0sIHN0cmVhbS5uZXh0KS5tYXAodHlwZSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLmlubGluZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHN0cmVhbS5pbmxpbmUgPSB0eXBlLmlzSW5saW5lO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmlubGluZSAhPSB0eXBlLmlzSW5saW5lKVxuICAgICAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJNaXhpbmcgaW5saW5lIGFuZCBibG9jayBjb250ZW50XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJuYW1lXCIsIHZhbHVlOiB0eXBlIH07XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW0ucG9zKys7XG4gICAgICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogeyB0eXBlOiBcImNob2ljZVwiLCBleHBycyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RyZWFtLmVycihcIlVuZXhwZWN0ZWQgdG9rZW4gJ1wiICsgc3RyZWFtLm5leHQgKyBcIidcIik7XG4gICAgfVxufVxuLyoqXG5Db25zdHJ1Y3QgYW4gTkZBIGZyb20gYW4gZXhwcmVzc2lvbiBhcyByZXR1cm5lZCBieSB0aGUgcGFyc2VyLiBUaGVcbk5GQSBpcyByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBzdGF0ZXMsIHdoaWNoIGFyZSB0aGVtc2VsdmVzXG5hcnJheXMgb2YgZWRnZXMsIHdoaWNoIGFyZSBge3Rlcm0sIHRvfWAgb2JqZWN0cy4gVGhlIGZpcnN0IHN0YXRlIGlzXG50aGUgZW50cnkgc3RhdGUgYW5kIHRoZSBsYXN0IG5vZGUgaXMgdGhlIHN1Y2Nlc3Mgc3RhdGUuXG5cbk5vdGUgdGhhdCB1bmxpa2UgdHlwaWNhbCBORkFzLCB0aGUgZWRnZSBvcmRlcmluZyBpbiB0aGlzIG9uZSBpc1xuc2lnbmlmaWNhbnQsIGluIHRoYXQgaXQgaXMgdXNlZCB0byBjb250cnVjdCBmaWxsZXIgY29udGVudCB3aGVuXG5uZWNlc3NhcnkuXG4qL1xuZnVuY3Rpb24gbmZhKGV4cHIpIHtcbiAgICBsZXQgbmZhID0gW1tdXTtcbiAgICBjb25uZWN0KGNvbXBpbGUoZXhwciwgMCksIG5vZGUoKSk7XG4gICAgcmV0dXJuIG5mYTtcbiAgICBmdW5jdGlvbiBub2RlKCkgeyByZXR1cm4gbmZhLnB1c2goW10pIC0gMTsgfVxuICAgIGZ1bmN0aW9uIGVkZ2UoZnJvbSwgdG8sIHRlcm0pIHtcbiAgICAgICAgbGV0IGVkZ2UgPSB7IHRlcm0sIHRvIH07XG4gICAgICAgIG5mYVtmcm9tXS5wdXNoKGVkZ2UpO1xuICAgICAgICByZXR1cm4gZWRnZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29ubmVjdChlZGdlcywgdG8pIHtcbiAgICAgICAgZWRnZXMuZm9yRWFjaChlZGdlID0+IGVkZ2UudG8gPSB0byk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBpbGUoZXhwciwgZnJvbSkge1xuICAgICAgICBpZiAoZXhwci50eXBlID09IFwiY2hvaWNlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBleHByLmV4cHJzLnJlZHVjZSgob3V0LCBleHByKSA9PiBvdXQuY29uY2F0KGNvbXBpbGUoZXhwciwgZnJvbSkpLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwic2VxXCIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjb21waWxlKGV4cHIuZXhwcnNbaV0sIGZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChpID09IGV4cHIuZXhwcnMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgY29ubmVjdChuZXh0LCBmcm9tID0gbm9kZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJzdGFyXCIpIHtcbiAgICAgICAgICAgIGxldCBsb29wID0gbm9kZSgpO1xuICAgICAgICAgICAgZWRnZShmcm9tLCBsb29wKTtcbiAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGxvb3ApLCBsb29wKTtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShsb29wKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwicGx1c1wiKSB7XG4gICAgICAgICAgICBsZXQgbG9vcCA9IG5vZGUoKTtcbiAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGZyb20pLCBsb29wKTtcbiAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGxvb3ApLCBsb29wKTtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShsb29wKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwib3B0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShmcm9tKV0uY29uY2F0KGNvbXBpbGUoZXhwci5leHByLCBmcm9tKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwicmFuZ2VcIikge1xuICAgICAgICAgICAgbGV0IGN1ciA9IGZyb207XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHIubWluOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUoKTtcbiAgICAgICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBuZXh0KTtcbiAgICAgICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cHIubWF4ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBleHByLm1pbjsgaSA8IGV4cHIubWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2UoY3VyLCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IG5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGN1cildO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcIm5hbWVcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGZyb20sIHVuZGVmaW5lZCwgZXhwci52YWx1ZSldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBleHByIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjbXAoYSwgYikgeyByZXR1cm4gYiAtIGE7IH1cbi8vIEdldCB0aGUgc2V0IG9mIG5vZGVzIHJlYWNoYWJsZSBieSBudWxsIGVkZ2VzIGZyb20gYG5vZGVgLiBPbWl0XG4vLyBub2RlcyB3aXRoIG9ubHkgYSBzaW5nbGUgbnVsbC1vdXQtZWRnZSwgc2luY2UgdGhleSBtYXkgbGVhZCB0b1xuLy8gbmVlZGxlc3MgZHVwbGljYXRlZCBub2Rlcy5cbmZ1bmN0aW9uIG51bGxGcm9tKG5mYSwgbm9kZSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBzY2FuKG5vZGUpO1xuICAgIHJldHVybiByZXN1bHQuc29ydChjbXApO1xuICAgIGZ1bmN0aW9uIHNjYW4obm9kZSkge1xuICAgICAgICBsZXQgZWRnZXMgPSBuZmFbbm9kZV07XG4gICAgICAgIGlmIChlZGdlcy5sZW5ndGggPT0gMSAmJiAhZWRnZXNbMF0udGVybSlcbiAgICAgICAgICAgIHJldHVybiBzY2FuKGVkZ2VzWzBdLnRvKTtcbiAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IHRlcm0sIHRvIH0gPSBlZGdlc1tpXTtcbiAgICAgICAgICAgIGlmICghdGVybSAmJiByZXN1bHQuaW5kZXhPZih0bykgPT0gLTEpXG4gICAgICAgICAgICAgICAgc2Nhbih0byk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBDb21waWxlcyBhbiBORkEgYXMgcHJvZHVjZWQgYnkgYG5mYWAgaW50byBhIERGQSwgbW9kZWxlZCBhcyBhIHNldFxuLy8gb2Ygc3RhdGUgb2JqZWN0cyAoYENvbnRlbnRNYXRjaGAgaW5zdGFuY2VzKSB3aXRoIHRyYW5zaXRpb25zXG4vLyBiZXR3ZWVuIHRoZW0uXG5mdW5jdGlvbiBkZmEobmZhKSB7XG4gICAgbGV0IGxhYmVsZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiBleHBsb3JlKG51bGxGcm9tKG5mYSwgMCkpO1xuICAgIGZ1bmN0aW9uIGV4cGxvcmUoc3RhdGVzKSB7XG4gICAgICAgIGxldCBvdXQgPSBbXTtcbiAgICAgICAgc3RhdGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBuZmFbbm9kZV0uZm9yRWFjaCgoeyB0ZXJtLCB0byB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0ZXJtKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbGV0IHNldDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dFtpXVswXSA9PSB0ZXJtKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0ID0gb3V0W2ldWzFdO1xuICAgICAgICAgICAgICAgIG51bGxGcm9tKG5mYSwgdG8pLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goW3Rlcm0sIHNldCA9IFtdXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXQuaW5kZXhPZihub2RlKSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgc3RhdGUgPSBsYWJlbGVkW3N0YXRlcy5qb2luKFwiLFwiKV0gPSBuZXcgQ29udGVudE1hdGNoKHN0YXRlcy5pbmRleE9mKG5mYS5sZW5ndGggLSAxKSA+IC0xKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZXMgPSBvdXRbaV1bMV0uc29ydChjbXApO1xuICAgICAgICAgICAgc3RhdGUubmV4dC5wdXNoKHsgdHlwZTogb3V0W2ldWzBdLCBuZXh0OiBsYWJlbGVkW3N0YXRlcy5qb2luKFwiLFwiKV0gfHwgZXhwbG9yZShzdGF0ZXMpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0ZvckRlYWRFbmRzKG1hdGNoLCBzdHJlYW0pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgd29yayA9IFttYXRjaF07IGkgPCB3b3JrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHdvcmtbaV0sIGRlYWQgPSAhc3RhdGUudmFsaWRFbmQsIG5vZGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdGUubmV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gc3RhdGUubmV4dFtqXTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2godHlwZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChkZWFkICYmICEodHlwZS5pc1RleHQgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpKVxuICAgICAgICAgICAgICAgIGRlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh3b3JrLmluZGV4T2YobmV4dCkgPT0gLTEpXG4gICAgICAgICAgICAgICAgd29yay5wdXNoKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWFkKVxuICAgICAgICAgICAgc3RyZWFtLmVycihcIk9ubHkgbm9uLWdlbmVyYXRhYmxlIG5vZGVzIChcIiArIG5vZGVzLmpvaW4oXCIsIFwiKSArIFwiKSBpbiBhIHJlcXVpcmVkIHBvc2l0aW9uIChzZWUgaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9ndWlkZS8jZ2VuZXJhdGFibGUpXCIpO1xuICAgIH1cbn1cblxuLy8gRm9yIG5vZGUgdHlwZXMgd2hlcmUgYWxsIGF0dHJzIGhhdmUgYSBkZWZhdWx0IHZhbHVlIChvciB3aGljaCBkb24ndFxuLy8gaGF2ZSBhbnkgYXR0cmlidXRlcyksIGJ1aWxkIHVwIGEgc2luZ2xlIHJldXNhYmxlIGRlZmF1bHQgYXR0cmlidXRlXG4vLyBvYmplY3QsIGFuZCB1c2UgaXQgZm9yIGFsbCBub2RlcyB0aGF0IGRvbid0IHNwZWNpZnkgc3BlY2lmaWNcbi8vIGF0dHJpYnV0ZXMuXG5mdW5jdGlvbiBkZWZhdWx0QXR0cnMoYXR0cnMpIHtcbiAgICBsZXQgZGVmYXVsdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IGF0dHJOYW1lIGluIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyID0gYXR0cnNbYXR0ck5hbWVdO1xuICAgICAgICBpZiAoIWF0dHIuaGFzRGVmYXVsdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBkZWZhdWx0c1thdHRyTmFtZV0gPSBhdHRyLmRlZmF1bHQ7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0cztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVBdHRycyhhdHRycywgdmFsdWUpIHtcbiAgICBsZXQgYnVpbHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgbGV0IGdpdmVuID0gdmFsdWUgJiYgdmFsdWVbbmFtZV07XG4gICAgICAgIGlmIChnaXZlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgYXR0ciA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgaWYgKGF0dHIuaGFzRGVmYXVsdClcbiAgICAgICAgICAgICAgICBnaXZlbiA9IGF0dHIuZGVmYXVsdDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIHZhbHVlIHN1cHBsaWVkIGZvciBhdHRyaWJ1dGUgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsdFtuYW1lXSA9IGdpdmVuO1xuICAgIH1cbiAgICByZXR1cm4gYnVpbHQ7XG59XG5mdW5jdGlvbiBpbml0QXR0cnMoYXR0cnMpIHtcbiAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoYXR0cnMpXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSBuZXcgQXR0cmlidXRlKGF0dHJzW25hbWVdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5Ob2RlIHR5cGVzIGFyZSBvYmplY3RzIGFsbG9jYXRlZCBvbmNlIHBlciBgU2NoZW1hYCBhbmQgdXNlZCB0b1xuW3RhZ10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUudHlwZSkgYE5vZGVgIGluc3RhbmNlcy4gVGhleSBjb250YWluIGluZm9ybWF0aW9uXG5hYm91dCB0aGUgbm9kZSB0eXBlLCBzdWNoIGFzIGl0cyBuYW1lIGFuZCB3aGF0IGtpbmQgb2Ygbm9kZSBpdFxucmVwcmVzZW50cy5cbiovXG5jbGFzcyBOb2RlVHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSB0aGUgbm9kZSB0eXBlIGhhcyBpbiB0aGlzIHNjaGVtYS5cbiAgICAqL1xuICAgIG5hbWUsIFxuICAgIC8qKlxuICAgIEEgbGluayBiYWNrIHRvIHRoZSBgU2NoZW1hYCB0aGUgbm9kZSB0eXBlIGJlbG9uZ3MgdG8uXG4gICAgKi9cbiAgICBzY2hlbWEsIFxuICAgIC8qKlxuICAgIFRoZSBzcGVjIHRoYXQgdGhpcyB0eXBlIGlzIGJhc2VkIG9uXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIHNldCBvZiBtYXJrcyBhbGxvd2VkIGluIHRoaXMgbm9kZS4gYG51bGxgIG1lYW5zIGFsbCBtYXJrc1xuICAgICAgICBhcmUgYWxsb3dlZC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXJrU2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5ncm91cHMgPSBzcGVjLmdyb3VwID8gc3BlYy5ncm91cC5zcGxpdChcIiBcIikgOiBbXTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGluaXRBdHRycyhzcGVjLmF0dHJzKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0QXR0cnMgPSBkZWZhdWx0QXR0cnModGhpcy5hdHRycyk7XG4gICAgICAgIHRoaXMuY29udGVudE1hdGNoID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmxpbmVDb250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0Jsb2NrID0gIShzcGVjLmlubGluZSB8fCBuYW1lID09IFwidGV4dFwiKTtcbiAgICAgICAgdGhpcy5pc1RleHQgPSBuYW1lID09IFwidGV4dFwiO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHRoaXMgaXMgYW4gaW5saW5lIHR5cGUuXG4gICAgKi9cbiAgICBnZXQgaXNJbmxpbmUoKSB7IHJldHVybiAhdGhpcy5pc0Jsb2NrOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB0aGlzIGlzIGEgdGV4dGJsb2NrIHR5cGUsIGEgYmxvY2sgdGhhdCBjb250YWlucyBpbmxpbmVcbiAgICBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlzVGV4dGJsb2NrKCkgeyByZXR1cm4gdGhpcy5pc0Jsb2NrICYmIHRoaXMuaW5saW5lQ29udGVudDsgfVxuICAgIC8qKlxuICAgIFRydWUgZm9yIG5vZGUgdHlwZXMgdGhhdCBhbGxvdyBubyBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlzTGVhZigpIHsgcmV0dXJuIHRoaXMuY29udGVudE1hdGNoID09IENvbnRlbnRNYXRjaC5lbXB0eTsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG5vZGUgaXMgYW4gYXRvbSwgaS5lLiB3aGVuIGl0IGRvZXMgbm90IGhhdmVcbiAgICBkaXJlY3RseSBlZGl0YWJsZSBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlzQXRvbSgpIHsgcmV0dXJuIHRoaXMuaXNMZWFmIHx8ICEhdGhpcy5zcGVjLmF0b207IH1cbiAgICAvKipcbiAgICBUaGUgbm9kZSB0eXBlJ3MgW3doaXRlc3BhY2VdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy53aGl0ZXNwYWNlKSBvcHRpb24uXG4gICAgKi9cbiAgICBnZXQgd2hpdGVzcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy53aGl0ZXNwYWNlIHx8ICh0aGlzLnNwZWMuY29kZSA/IFwicHJlXCIgOiBcIm5vcm1hbFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhpcyBub2RlIHR5cGUgaGFzIGFueSByZXF1aXJlZCBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgaGFzUmVxdWlyZWRBdHRycygpIHtcbiAgICAgICAgZm9yIChsZXQgbiBpbiB0aGlzLmF0dHJzKVxuICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnNbbl0uaXNSZXF1aXJlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIG5vZGUgYWxsb3dzIHNvbWUgb2YgdGhlIHNhbWUgY29udGVudCBhc1xuICAgIHRoZSBnaXZlbiBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBjb21wYXRpYmxlQ29udGVudChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCB0aGlzLmNvbnRlbnRNYXRjaC5jb21wYXRpYmxlKG90aGVyLmNvbnRlbnRNYXRjaCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcHV0ZUF0dHJzKGF0dHJzKSB7XG4gICAgICAgIGlmICghYXR0cnMgJiYgdGhpcy5kZWZhdWx0QXR0cnMpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0QXR0cnM7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlQXR0cnModGhpcy5hdHRycywgYXR0cnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBgTm9kZWAgb2YgdGhpcyB0eXBlLiBUaGUgZ2l2ZW4gYXR0cmlidXRlcyBhcmVcbiAgICBjaGVja2VkIGFuZCBkZWZhdWx0ZWQgKHlvdSBjYW4gcGFzcyBgbnVsbGAgdG8gdXNlIHRoZSB0eXBlJ3NcbiAgICBkZWZhdWx0cyBlbnRpcmVseSwgaWYgbm8gcmVxdWlyZWQgYXR0cmlidXRlcyBleGlzdCkuIGBjb250ZW50YFxuICAgIG1heSBiZSBhIGBGcmFnbWVudGAsIGEgbm9kZSwgYW4gYXJyYXkgb2Ygbm9kZXMsIG9yXG4gICAgYG51bGxgLiBTaW1pbGFybHkgYG1hcmtzYCBtYXkgYmUgYG51bGxgIHRvIGRlZmF1bHQgdG8gdGhlIGVtcHR5XG4gICAgc2V0IG9mIG1hcmtzLlxuICAgICovXG4gICAgY3JlYXRlKGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUZXh0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZVR5cGUuY3JlYXRlIGNhbid0IGNvbnN0cnVjdCB0ZXh0IG5vZGVzXCIpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpLCBGcmFnbWVudC5mcm9tKGNvbnRlbnQpLCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTGlrZSBbYGNyZWF0ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlVHlwZS5jcmVhdGUpLCBidXQgY2hlY2sgdGhlIGdpdmVuIGNvbnRlbnRcbiAgICBhZ2FpbnN0IHRoZSBub2RlIHR5cGUncyBjb250ZW50IHJlc3RyaWN0aW9ucywgYW5kIHRocm93IGFuIGVycm9yXG4gICAgaWYgaXQgZG9lc24ndCBtYXRjaC5cbiAgICAqL1xuICAgIGNyZWF0ZUNoZWNrZWQoYXR0cnMgPSBudWxsLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbShjb250ZW50KTtcbiAgICAgICAgdGhpcy5jaGVja0NvbnRlbnQoY29udGVudCk7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyksIGNvbnRlbnQsIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBMaWtlIFtgY3JlYXRlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVUeXBlLmNyZWF0ZSksIGJ1dCBzZWUgaWYgaXQgaXNcbiAgICBuZWNlc3NhcnkgdG8gYWRkIG5vZGVzIHRvIHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGdpdmVuIGZyYWdtZW50XG4gICAgdG8gbWFrZSBpdCBmaXQgdGhlIG5vZGUuIElmIG5vIGZpdHRpbmcgd3JhcHBpbmcgY2FuIGJlIGZvdW5kLFxuICAgIHJldHVybiBudWxsLiBOb3RlIHRoYXQsIGR1ZSB0byB0aGUgZmFjdCB0aGF0IHJlcXVpcmVkIG5vZGVzIGNhblxuICAgIGFsd2F5cyBiZSBjcmVhdGVkLCB0aGlzIHdpbGwgYWx3YXlzIHN1Y2NlZWQgaWYgeW91IHBhc3MgbnVsbCBvclxuICAgIGBGcmFnbWVudC5lbXB0eWAgYXMgY29udGVudC5cbiAgICAqL1xuICAgIGNyZWF0ZUFuZEZpbGwoYXR0cnMgPSBudWxsLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBhdHRycyA9IHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKTtcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20oY29udGVudCk7XG4gICAgICAgIGlmIChjb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSB0aGlzLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKCFiZWZvcmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb250ZW50ID0gYmVmb3JlLmFwcGVuZChjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWF0Y2hlZCA9IHRoaXMuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoY29udGVudCk7XG4gICAgICAgIGxldCBhZnRlciA9IG1hdGNoZWQgJiYgbWF0Y2hlZC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgICAgaWYgKCFhZnRlcilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgYXR0cnMsIGNvbnRlbnQuYXBwZW5kKGFmdGVyKSwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZnJhZ21lbnQgaXMgdmFsaWQgY29udGVudCBmb3IgdGhpcyBub2RlXG4gICAgdHlwZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgdmFsaWRDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoY29udGVudCk7XG4gICAgICAgIGlmICghcmVzdWx0IHx8ICFyZXN1bHQudmFsaWRFbmQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudC5jaGlsZENvdW50OyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dzTWFya3MoY29udGVudC5jaGlsZChpKS5tYXJrcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhyb3dzIGEgUmFuZ2VFcnJvciBpZiB0aGUgZ2l2ZW4gZnJhZ21lbnQgaXMgbm90IHZhbGlkIGNvbnRlbnQgZm9yIHRoaXNcbiAgICBub2RlIHR5cGUuXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaGVja0NvbnRlbnQoY29udGVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmFsaWRDb250ZW50KGNvbnRlbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgY29udGVudCBmb3Igbm9kZSAke3RoaXMubmFtZX06ICR7Y29udGVudC50b1N0cmluZygpLnNsaWNlKDAsIDUwKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gbWFyayB0eXBlIGlzIGFsbG93ZWQgaW4gdGhpcyBub2RlLlxuICAgICovXG4gICAgYWxsb3dzTWFya1R5cGUobWFya1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFya1NldCA9PSBudWxsIHx8IHRoaXMubWFya1NldC5pbmRleE9mKG1hcmtUeXBlKSA+IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhlIGdpdmVuIHNldCBvZiBtYXJrcyBhcmUgYWxsb3dlZCBpbiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBhbGxvd3NNYXJrcyhtYXJrcykge1xuICAgICAgICBpZiAodGhpcy5tYXJrU2V0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxvd3NNYXJrVHlwZShtYXJrc1tpXS50eXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmVzIHRoZSBtYXJrcyB0aGF0IGFyZSBub3QgYWxsb3dlZCBpbiB0aGlzIG5vZGUgZnJvbSB0aGUgZ2l2ZW4gc2V0LlxuICAgICovXG4gICAgYWxsb3dlZE1hcmtzKG1hcmtzKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcmtTZXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBtYXJrcztcbiAgICAgICAgbGV0IGNvcHk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxvd3NNYXJrVHlwZShtYXJrc1tpXS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IG1hcmtzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29weSkge1xuICAgICAgICAgICAgICAgIGNvcHkucHVzaChtYXJrc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFjb3B5ID8gbWFya3MgOiBjb3B5Lmxlbmd0aCA/IGNvcHkgOiBNYXJrLm5vbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNvbXBpbGUobm9kZXMsIHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaCgobmFtZSwgc3BlYykgPT4gcmVzdWx0W25hbWVdID0gbmV3IE5vZGVUeXBlKG5hbWUsIHNjaGVtYSwgc3BlYykpO1xuICAgICAgICBsZXQgdG9wVHlwZSA9IHNjaGVtYS5zcGVjLnRvcE5vZGUgfHwgXCJkb2NcIjtcbiAgICAgICAgaWYgKCFyZXN1bHRbdG9wVHlwZV0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlNjaGVtYSBpcyBtaXNzaW5nIGl0cyB0b3Agbm9kZSB0eXBlICgnXCIgKyB0b3BUeXBlICsgXCInKVwiKTtcbiAgICAgICAgaWYgKCFyZXN1bHQudGV4dClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRXZlcnkgc2NoZW1hIG5lZWRzIGEgJ3RleHQnIHR5cGVcIik7XG4gICAgICAgIGZvciAobGV0IF8gaW4gcmVzdWx0LnRleHQuYXR0cnMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSB0ZXh0IG5vZGUgdHlwZSBzaG91bGQgbm90IGhhdmUgYXR0cmlidXRlc1wiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyBBdHRyaWJ1dGUgZGVzY3JpcHRvcnNcbmNsYXNzIEF0dHJpYnV0ZSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLmhhc0RlZmF1bHQgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJkZWZhdWx0XCIpO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSBvcHRpb25zLmRlZmF1bHQ7XG4gICAgfVxuICAgIGdldCBpc1JlcXVpcmVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaGFzRGVmYXVsdDtcbiAgICB9XG59XG4vLyBNYXJrc1xuLyoqXG5MaWtlIG5vZGVzLCBtYXJrcyAod2hpY2ggYXJlIGFzc29jaWF0ZWQgd2l0aCBub2RlcyB0byBzaWduaWZ5XG50aGluZ3MgbGlrZSBlbXBoYXNpcyBvciBiZWluZyBwYXJ0IG9mIGEgbGluaykgYXJlXG5bdGFnZ2VkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFyay50eXBlKSB3aXRoIHR5cGUgb2JqZWN0cywgd2hpY2ggYXJlXG5pbnN0YW50aWF0ZWQgb25jZSBwZXIgYFNjaGVtYWAuXG4qL1xuY2xhc3MgTWFya1R5cGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5hbWUgb2YgdGhlIG1hcmsgdHlwZS5cbiAgICAqL1xuICAgIG5hbWUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmFuaywgXG4gICAgLyoqXG4gICAgVGhlIHNjaGVtYSB0aGF0IHRoaXMgbWFyayB0eXBlIGluc3RhbmNlIGlzIHBhcnQgb2YuXG4gICAgKi9cbiAgICBzY2hlbWEsIFxuICAgIC8qKlxuICAgIFRoZSBzcGVjIG9uIHdoaWNoIHRoZSB0eXBlIGlzIGJhc2VkLlxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnJhbmsgPSByYW5rO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgdGhpcy5hdHRycyA9IGluaXRBdHRycyhzcGVjLmF0dHJzKTtcbiAgICAgICAgdGhpcy5leGNsdWRlZCA9IG51bGw7XG4gICAgICAgIGxldCBkZWZhdWx0cyA9IGRlZmF1bHRBdHRycyh0aGlzLmF0dHJzKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGRlZmF1bHRzID8gbmV3IE1hcmsodGhpcywgZGVmYXVsdHMpIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayBvZiB0aGlzIHR5cGUuIGBhdHRyc2AgbWF5IGJlIGBudWxsYCBvciBhbiBvYmplY3RcbiAgICBjb250YWluaW5nIG9ubHkgc29tZSBvZiB0aGUgbWFyaydzIGF0dHJpYnV0ZXMuIFRoZSBvdGhlcnMsIGlmXG4gICAgdGhleSBoYXZlIGRlZmF1bHRzLCB3aWxsIGJlIGFkZGVkLlxuICAgICovXG4gICAgY3JlYXRlKGF0dHJzID0gbnVsbCkge1xuICAgICAgICBpZiAoIWF0dHJzICYmIHRoaXMuaW5zdGFuY2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrKHRoaXMsIGNvbXB1dGVBdHRycyh0aGlzLmF0dHJzLCBhdHRycykpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjb21waWxlKG1hcmtzLCBzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCksIHJhbmsgPSAwO1xuICAgICAgICBtYXJrcy5mb3JFYWNoKChuYW1lLCBzcGVjKSA9PiByZXN1bHRbbmFtZV0gPSBuZXcgTWFya1R5cGUobmFtZSwgcmFuaysrLCBzY2hlbWEsIHNwZWMpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hlbiB0aGVyZSBpcyBhIG1hcmsgb2YgdGhpcyB0eXBlIGluIHRoZSBnaXZlbiBzZXQsIGEgbmV3IHNldFxuICAgIHdpdGhvdXQgaXQgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSwgdGhlIGlucHV0IHNldCBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIHJlbW92ZUZyb21TZXQoc2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHNldFtpXS50eXBlID09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICBzZXQgPSBzZXQuc2xpY2UoMCwgaSkuY29uY2F0KHNldC5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdHMgd2hldGhlciB0aGVyZSBpcyBhIG1hcmsgb2YgdGhpcyB0eXBlIGluIHRoZSBnaXZlbiBzZXQuXG4gICAgKi9cbiAgICBpc0luU2V0KHNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChzZXRbaV0udHlwZSA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRbaV07XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJpZXMgd2hldGhlciBhIGdpdmVuIG1hcmsgdHlwZSBpc1xuICAgIFtleGNsdWRlZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtTcGVjLmV4Y2x1ZGVzKSBieSB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGV4Y2x1ZGVzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4Y2x1ZGVkLmluZGV4T2Yob3RoZXIpID4gLTE7XG4gICAgfVxufVxuLyoqXG5BIGRvY3VtZW50IHNjaGVtYS4gSG9sZHMgW25vZGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlVHlwZSkgYW5kIFttYXJrXG50eXBlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1R5cGUpIG9iamVjdHMgZm9yIHRoZSBub2RlcyBhbmQgbWFya3MgdGhhdCBtYXlcbm9jY3VyIGluIGNvbmZvcm1pbmcgZG9jdW1lbnRzLCBhbmQgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3JcbmNyZWF0aW5nIGFuZCBkZXNlcmlhbGl6aW5nIHN1Y2ggZG9jdW1lbnRzLlxuXG5XaGVuIGdpdmVuLCB0aGUgdHlwZSBwYXJhbWV0ZXJzIHByb3ZpZGUgdGhlIG5hbWVzIG9mIHRoZSBub2RlcyBhbmRcbm1hcmtzIGluIHRoaXMgc2NoZW1hLlxuKi9cbmNsYXNzIFNjaGVtYSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgc2NoZW1hIGZyb20gYSBzY2hlbWEgW3NwZWNpZmljYXRpb25dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5TY2hlbWFTcGVjKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEFuIG9iamVjdCBmb3Igc3RvcmluZyB3aGF0ZXZlciB2YWx1ZXMgbW9kdWxlcyBtYXkgd2FudCB0b1xuICAgICAgICBjb21wdXRlIGFuZCBjYWNoZSBwZXIgc2NoZW1hLiAoSWYgeW91IHdhbnQgdG8gc3RvcmUgc29tZXRoaW5nXG4gICAgICAgIGluIGl0LCB0cnkgdG8gdXNlIHByb3BlcnR5IG5hbWVzIHVubGlrZWx5IHRvIGNsYXNoLilcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWNoZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgaW5zdGFuY2VTcGVjID0gdGhpcy5zcGVjID0ge307XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gc3BlYylcbiAgICAgICAgICAgIGluc3RhbmNlU3BlY1twcm9wXSA9IHNwZWNbcHJvcF07XG4gICAgICAgIGluc3RhbmNlU3BlYy5ub2RlcyA9IE9yZGVyZWRNYXAuZnJvbShzcGVjLm5vZGVzKSxcbiAgICAgICAgICAgIGluc3RhbmNlU3BlYy5tYXJrcyA9IE9yZGVyZWRNYXAuZnJvbShzcGVjLm1hcmtzIHx8IHt9KSxcbiAgICAgICAgICAgIHRoaXMubm9kZXMgPSBOb2RlVHlwZS5jb21waWxlKHRoaXMuc3BlYy5ub2RlcywgdGhpcyk7XG4gICAgICAgIHRoaXMubWFya3MgPSBNYXJrVHlwZS5jb21waWxlKHRoaXMuc3BlYy5tYXJrcywgdGhpcyk7XG4gICAgICAgIGxldCBjb250ZW50RXhwckNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcCBpbiB0aGlzLm1hcmtzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHByb3AgKyBcIiBjYW4gbm90IGJlIGJvdGggYSBub2RlIGFuZCBhIG1hcmtcIik7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMubm9kZXNbcHJvcF0sIGNvbnRlbnRFeHByID0gdHlwZS5zcGVjLmNvbnRlbnQgfHwgXCJcIiwgbWFya0V4cHIgPSB0eXBlLnNwZWMubWFya3M7XG4gICAgICAgICAgICB0eXBlLmNvbnRlbnRNYXRjaCA9IGNvbnRlbnRFeHByQ2FjaGVbY29udGVudEV4cHJdIHx8XG4gICAgICAgICAgICAgICAgKGNvbnRlbnRFeHByQ2FjaGVbY29udGVudEV4cHJdID0gQ29udGVudE1hdGNoLnBhcnNlKGNvbnRlbnRFeHByLCB0aGlzLm5vZGVzKSk7XG4gICAgICAgICAgICB0eXBlLmlubGluZUNvbnRlbnQgPSB0eXBlLmNvbnRlbnRNYXRjaC5pbmxpbmVDb250ZW50O1xuICAgICAgICAgICAgdHlwZS5tYXJrU2V0ID0gbWFya0V4cHIgPT0gXCJfXCIgPyBudWxsIDpcbiAgICAgICAgICAgICAgICBtYXJrRXhwciA/IGdhdGhlck1hcmtzKHRoaXMsIG1hcmtFeHByLnNwbGl0KFwiIFwiKSkgOlxuICAgICAgICAgICAgICAgICAgICBtYXJrRXhwciA9PSBcIlwiIHx8ICF0eXBlLmlubGluZUNvbnRlbnQgPyBbXSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0aGlzLm1hcmtzKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMubWFya3NbcHJvcF0sIGV4Y2wgPSB0eXBlLnNwZWMuZXhjbHVkZXM7XG4gICAgICAgICAgICB0eXBlLmV4Y2x1ZGVkID0gZXhjbCA9PSBudWxsID8gW3R5cGVdIDogZXhjbCA9PSBcIlwiID8gW10gOiBnYXRoZXJNYXJrcyh0aGlzLCBleGNsLnNwbGl0KFwiIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlRnJvbUpTT04gPSB0aGlzLm5vZGVGcm9tSlNPTi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1hcmtGcm9tSlNPTiA9IHRoaXMubWFya0Zyb21KU09OLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudG9wTm9kZVR5cGUgPSB0aGlzLm5vZGVzW3RoaXMuc3BlYy50b3BOb2RlIHx8IFwiZG9jXCJdO1xuICAgICAgICB0aGlzLmNhY2hlZC53cmFwcGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBub2RlIGluIHRoaXMgc2NoZW1hLiBUaGUgYHR5cGVgIG1heSBiZSBhIHN0cmluZyBvciBhXG4gICAgYE5vZGVUeXBlYCBpbnN0YW5jZS4gQXR0cmlidXRlcyB3aWxsIGJlIGV4dGVuZGVkIHdpdGggZGVmYXVsdHMsXG4gICAgYGNvbnRlbnRgIG1heSBiZSBhIGBGcmFnbWVudGAsIGBudWxsYCwgYSBgTm9kZWAsIG9yIGFuIGFycmF5IG9mXG4gICAgbm9kZXMuXG4gICAgKi9cbiAgICBub2RlKHR5cGUsIGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0eXBlID0gdGhpcy5ub2RlVHlwZSh0eXBlKTtcbiAgICAgICAgZWxzZSBpZiAoISh0eXBlIGluc3RhbmNlb2YgTm9kZVR5cGUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG5vZGUgdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgZWxzZSBpZiAodHlwZS5zY2hlbWEgIT0gdGhpcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGZyb20gZGlmZmVyZW50IHNjaGVtYSB1c2VkIChcIiArIHR5cGUubmFtZSArIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIHR5cGUuY3JlYXRlQ2hlY2tlZChhdHRycywgY29udGVudCwgbWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB0ZXh0IG5vZGUgaW4gdGhlIHNjaGVtYS4gRW1wdHkgdGV4dCBub2RlcyBhcmUgbm90XG4gICAgYWxsb3dlZC5cbiAgICAqL1xuICAgIHRleHQodGV4dCwgbWFya3MpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0aGlzLm5vZGVzLnRleHQ7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUodHlwZSwgdHlwZS5kZWZhdWx0QXR0cnMsIHRleHQsIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrIHdpdGggdGhlIGdpdmVuIHR5cGUgYW5kIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBtYXJrKHR5cGUsIGF0dHJzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdHlwZSA9IHRoaXMubWFya3NbdHlwZV07XG4gICAgICAgIHJldHVybiB0eXBlLmNyZWF0ZShhdHRycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgbm9kZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBUaGlzIG1ldGhvZCBpc1xuICAgIGJvdW5kLlxuICAgICovXG4gICAgbm9kZUZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIE5vZGUuZnJvbUpTT04odGhpcywganNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgbWFyayBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBUaGlzIG1ldGhvZCBpc1xuICAgIGJvdW5kLlxuICAgICovXG4gICAgbWFya0Zyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIE1hcmsuZnJvbUpTT04odGhpcywganNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbm9kZVR5cGUobmFtZSkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLm5vZGVzW25hbWVdO1xuICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIgKyBuYW1lKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdhdGhlck1hcmtzKHNjaGVtYSwgbWFya3MpIHtcbiAgICBsZXQgZm91bmQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBuYW1lID0gbWFya3NbaV0sIG1hcmsgPSBzY2hlbWEubWFya3NbbmFtZV0sIG9rID0gbWFyaztcbiAgICAgICAgaWYgKG1hcmspIHtcbiAgICAgICAgICAgIGZvdW5kLnB1c2gobWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHNjaGVtYS5tYXJrcykge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrID0gc2NoZW1hLm1hcmtzW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwiX1wiIHx8IChtYXJrLnNwZWMuZ3JvdXAgJiYgbWFyay5zcGVjLmdyb3VwLnNwbGl0KFwiIFwiKS5pbmRleE9mKG5hbWUpID4gLTEpKVxuICAgICAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKG9rID0gbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvaylcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlVua25vd24gbWFyayB0eXBlOiAnXCIgKyBtYXJrc1tpXSArIFwiJ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuXG4vKipcbkEgRE9NIHBhcnNlciByZXByZXNlbnRzIGEgc3RyYXRlZ3kgZm9yIHBhcnNpbmcgRE9NIGNvbnRlbnQgaW50byBhXG5Qcm9zZU1pcnJvciBkb2N1bWVudCBjb25mb3JtaW5nIHRvIGEgZ2l2ZW4gc2NoZW1hLiBJdHMgYmVoYXZpb3IgaXNcbmRlZmluZWQgYnkgYW4gYXJyYXkgb2YgW3J1bGVzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUGFyc2VSdWxlKS5cbiovXG5jbGFzcyBET01QYXJzZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBhcnNlciB0aGF0IHRhcmdldHMgdGhlIGdpdmVuIHNjaGVtYSwgdXNpbmcgdGhlIGdpdmVuXG4gICAgcGFyc2luZyBydWxlcy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzY2hlbWEgaW50byB3aGljaCB0aGUgcGFyc2VyIHBhcnNlcy5cbiAgICAqL1xuICAgIHNjaGVtYSwgXG4gICAgLyoqXG4gICAgVGhlIHNldCBvZiBbcGFyc2UgcnVsZXNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5QYXJzZVJ1bGUpIHRoYXQgdGhlIHBhcnNlclxuICAgIHVzZXMsIGluIG9yZGVyIG9mIHByZWNlZGVuY2UuXG4gICAgKi9cbiAgICBydWxlcykge1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudGFncyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc3R5bGVzID0gW107XG4gICAgICAgIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICBpZiAocnVsZS50YWcpXG4gICAgICAgICAgICAgICAgdGhpcy50YWdzLnB1c2gocnVsZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlLnN0eWxlKVxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBPbmx5IG5vcm1hbGl6ZSBsaXN0IGVsZW1lbnRzIHdoZW4gbGlzdHMgaW4gdGhlIHNjaGVtYSBjYW4ndCBkaXJlY3RseSBjb250YWluIHRoZW1zZWx2ZXNcbiAgICAgICAgdGhpcy5ub3JtYWxpemVMaXN0cyA9ICF0aGlzLnRhZ3Muc29tZShyID0+IHtcbiAgICAgICAgICAgIGlmICghL14odWx8b2wpXFxiLy50ZXN0KHIudGFnKSB8fCAhci5ub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBub2RlID0gc2NoZW1hLm5vZGVzW3Iubm9kZV07XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jb250ZW50TWF0Y2gubWF0Y2hUeXBlKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUGFyc2UgYSBkb2N1bWVudCBmcm9tIHRoZSBjb250ZW50IG9mIGEgRE9NIG5vZGUuXG4gICAgKi9cbiAgICBwYXJzZShkb20sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgY29udGV4dCA9IG5ldyBQYXJzZUNvbnRleHQodGhpcywgb3B0aW9ucywgZmFsc2UpO1xuICAgICAgICBjb250ZXh0LmFkZEFsbChkb20sIG9wdGlvbnMuZnJvbSwgb3B0aW9ucy50byk7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBQYXJzZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGdpdmVuIERPTSBub2RlLCBsaWtlXG4gICAgW2BwYXJzZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5ET01QYXJzZXIucGFyc2UpLCBhbmQgdGFrZXMgdGhlIHNhbWUgc2V0IG9mXG4gICAgb3B0aW9ucy4gQnV0IHVubGlrZSB0aGF0IG1ldGhvZCwgd2hpY2ggcHJvZHVjZXMgYSB3aG9sZSBub2RlLFxuICAgIHRoaXMgb25lIHJldHVybnMgYSBzbGljZSB0aGF0IGlzIG9wZW4gYXQgdGhlIHNpZGVzLCBtZWFuaW5nIHRoYXRcbiAgICB0aGUgc2NoZW1hIGNvbnN0cmFpbnRzIGFyZW4ndCBhcHBsaWVkIHRvIHRoZSBzdGFydCBvZiBub2RlcyB0b1xuICAgIHRoZSBsZWZ0IG9mIHRoZSBpbnB1dCBhbmQgdGhlIGVuZCBvZiBub2RlcyBhdCB0aGUgZW5kLlxuICAgICovXG4gICAgcGFyc2VTbGljZShkb20sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgY29udGV4dCA9IG5ldyBQYXJzZUNvbnRleHQodGhpcywgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIGNvbnRleHQuYWRkQWxsKGRvbSwgb3B0aW9ucy5mcm9tLCBvcHRpb25zLnRvKTtcbiAgICAgICAgcmV0dXJuIFNsaWNlLm1heE9wZW4oY29udGV4dC5maW5pc2goKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWF0Y2hUYWcoZG9tLCBjb250ZXh0LCBhZnRlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gYWZ0ZXIgPyB0aGlzLnRhZ3MuaW5kZXhPZihhZnRlcikgKyAxIDogMDsgaSA8IHRoaXMudGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnRhZ3NbaV07XG4gICAgICAgICAgICBpZiAobWF0Y2hlcyhkb20sIHJ1bGUudGFnKSAmJlxuICAgICAgICAgICAgICAgIChydWxlLm5hbWVzcGFjZSA9PT0gdW5kZWZpbmVkIHx8IGRvbS5uYW1lc3BhY2VVUkkgPT0gcnVsZS5uYW1lc3BhY2UpICYmXG4gICAgICAgICAgICAgICAgKCFydWxlLmNvbnRleHQgfHwgY29udGV4dC5tYXRjaGVzQ29udGV4dChydWxlLmNvbnRleHQpKSkge1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmdldEF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBydWxlLmdldEF0dHJzKGRvbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuYXR0cnMgPSByZXN1bHQgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hdGNoU3R5bGUocHJvcCwgdmFsdWUsIGNvbnRleHQsIGFmdGVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBhZnRlciA/IHRoaXMuc3R5bGVzLmluZGV4T2YoYWZ0ZXIpICsgMSA6IDA7IGkgPCB0aGlzLnN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnN0eWxlc1tpXSwgc3R5bGUgPSBydWxlLnN0eWxlO1xuICAgICAgICAgICAgaWYgKHN0eWxlLmluZGV4T2YocHJvcCkgIT0gMCB8fFxuICAgICAgICAgICAgICAgIHJ1bGUuY29udGV4dCAmJiAhY29udGV4dC5tYXRjaGVzQ29udGV4dChydWxlLmNvbnRleHQpIHx8XG4gICAgICAgICAgICAgICAgLy8gVGVzdCB0aGF0IHRoZSBzdHlsZSBzdHJpbmcgZWl0aGVyIHByZWNpc2VseSBtYXRjaGVzIHRoZSBwcm9wLFxuICAgICAgICAgICAgICAgIC8vIG9yIGhhcyBhbiAnPScgc2lnbiBhZnRlciB0aGUgcHJvcCwgZm9sbG93ZWQgYnkgdGhlIGdpdmVuXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICAgICAgc3R5bGUubGVuZ3RoID4gcHJvcC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgKHN0eWxlLmNoYXJDb2RlQXQocHJvcC5sZW5ndGgpICE9IDYxIHx8IHN0eWxlLnNsaWNlKHByb3AubGVuZ3RoICsgMSkgIT0gdmFsdWUpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJ1bGUuZ2V0QXR0cnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcnVsZS5nZXRBdHRycyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJ1bGUuYXR0cnMgPSByZXN1bHQgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgc2NoZW1hUnVsZXMoc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0KHJ1bGUpIHtcbiAgICAgICAgICAgIGxldCBwcmlvcml0eSA9IHJ1bGUucHJpb3JpdHkgPT0gbnVsbCA/IDUwIDogcnVsZS5wcmlvcml0eSwgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcmVzdWx0W2ldLCBuZXh0UHJpb3JpdHkgPSBuZXh0LnByaW9yaXR5ID09IG51bGwgPyA1MCA6IG5leHQucHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRQcmlvcml0eSA8IHByaW9yaXR5KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoaSwgMCwgcnVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBzY2hlbWEubWFya3MpIHtcbiAgICAgICAgICAgIGxldCBydWxlcyA9IHNjaGVtYS5tYXJrc1tuYW1lXS5zcGVjLnBhcnNlRE9NO1xuICAgICAgICAgICAgaWYgKHJ1bGVzKVxuICAgICAgICAgICAgICAgIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydChydWxlID0gY29weShydWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJ1bGUubWFyayB8fCBydWxlLmlnbm9yZSB8fCBydWxlLmNsZWFyTWFyaykpXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLm1hcmsgPSBuYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gc2NoZW1hLm5vZGVzKSB7XG4gICAgICAgICAgICBsZXQgcnVsZXMgPSBzY2hlbWEubm9kZXNbbmFtZV0uc3BlYy5wYXJzZURPTTtcbiAgICAgICAgICAgIGlmIChydWxlcylcbiAgICAgICAgICAgICAgICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQocnVsZSA9IGNvcHkocnVsZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShydWxlLm5vZGUgfHwgcnVsZS5pZ25vcmUgfHwgcnVsZS5tYXJrKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUubm9kZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgRE9NIHBhcnNlciB1c2luZyB0aGUgcGFyc2luZyBydWxlcyBsaXN0ZWQgaW4gYVxuICAgIHNjaGVtYSdzIFtub2RlIHNwZWNzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMucGFyc2VET00pLCByZW9yZGVyZWQgYnlcbiAgICBbcHJpb3JpdHldKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5QYXJzZVJ1bGUucHJpb3JpdHkpLlxuICAgICovXG4gICAgc3RhdGljIGZyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuY2FjaGVkLmRvbVBhcnNlciB8fFxuICAgICAgICAgICAgKHNjaGVtYS5jYWNoZWQuZG9tUGFyc2VyID0gbmV3IERPTVBhcnNlcihzY2hlbWEsIERPTVBhcnNlci5zY2hlbWFSdWxlcyhzY2hlbWEpKSk7XG4gICAgfVxufVxuY29uc3QgYmxvY2tUYWdzID0ge1xuICAgIGFkZHJlc3M6IHRydWUsIGFydGljbGU6IHRydWUsIGFzaWRlOiB0cnVlLCBibG9ja3F1b3RlOiB0cnVlLCBjYW52YXM6IHRydWUsXG4gICAgZGQ6IHRydWUsIGRpdjogdHJ1ZSwgZGw6IHRydWUsIGZpZWxkc2V0OiB0cnVlLCBmaWdjYXB0aW9uOiB0cnVlLCBmaWd1cmU6IHRydWUsXG4gICAgZm9vdGVyOiB0cnVlLCBmb3JtOiB0cnVlLCBoMTogdHJ1ZSwgaDI6IHRydWUsIGgzOiB0cnVlLCBoNDogdHJ1ZSwgaDU6IHRydWUsXG4gICAgaDY6IHRydWUsIGhlYWRlcjogdHJ1ZSwgaGdyb3VwOiB0cnVlLCBocjogdHJ1ZSwgbGk6IHRydWUsIG5vc2NyaXB0OiB0cnVlLCBvbDogdHJ1ZSxcbiAgICBvdXRwdXQ6IHRydWUsIHA6IHRydWUsIHByZTogdHJ1ZSwgc2VjdGlvbjogdHJ1ZSwgdGFibGU6IHRydWUsIHRmb290OiB0cnVlLCB1bDogdHJ1ZVxufTtcbmNvbnN0IGlnbm9yZVRhZ3MgPSB7XG4gICAgaGVhZDogdHJ1ZSwgbm9zY3JpcHQ6IHRydWUsIG9iamVjdDogdHJ1ZSwgc2NyaXB0OiB0cnVlLCBzdHlsZTogdHJ1ZSwgdGl0bGU6IHRydWVcbn07XG5jb25zdCBsaXN0VGFncyA9IHsgb2w6IHRydWUsIHVsOiB0cnVlIH07XG4vLyBVc2luZyBhIGJpdGZpZWxkIGZvciBub2RlIGNvbnRleHQgb3B0aW9uc1xuY29uc3QgT1BUX1BSRVNFUlZFX1dTID0gMSwgT1BUX1BSRVNFUlZFX1dTX0ZVTEwgPSAyLCBPUFRfT1BFTl9MRUZUID0gNDtcbmZ1bmN0aW9uIHdzT3B0aW9uc0Zvcih0eXBlLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIGJhc2UpIHtcbiAgICBpZiAocHJlc2VydmVXaGl0ZXNwYWNlICE9IG51bGwpXG4gICAgICAgIHJldHVybiAocHJlc2VydmVXaGl0ZXNwYWNlID8gT1BUX1BSRVNFUlZFX1dTIDogMCkgfFxuICAgICAgICAgICAgKHByZXNlcnZlV2hpdGVzcGFjZSA9PT0gXCJmdWxsXCIgPyBPUFRfUFJFU0VSVkVfV1NfRlVMTCA6IDApO1xuICAgIHJldHVybiB0eXBlICYmIHR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiID8gT1BUX1BSRVNFUlZFX1dTIHwgT1BUX1BSRVNFUlZFX1dTX0ZVTEwgOiBiYXNlICYgfk9QVF9PUEVOX0xFRlQ7XG59XG5jbGFzcyBOb2RlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgYXR0cnMsIFxuICAgIC8vIE1hcmtzIGFwcGxpZWQgdG8gdGhpcyBub2RlIGl0c2VsZlxuICAgIG1hcmtzLCBcbiAgICAvLyBNYXJrcyB0aGF0IGNhbid0IGFwcGx5IGhlcmUsIGJ1dCB3aWxsIGJlIHVzZWQgaW4gY2hpbGRyZW4gaWYgcG9zc2libGVcbiAgICBwZW5kaW5nTWFya3MsIHNvbGlkLCBtYXRjaCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICAgICAgdGhpcy5wZW5kaW5nTWFya3MgPSBwZW5kaW5nTWFya3M7XG4gICAgICAgIHRoaXMuc29saWQgPSBzb2xpZDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb250ZW50ID0gW107XG4gICAgICAgIC8vIE1hcmtzIGFwcGxpZWQgdG8gdGhlIG5vZGUncyBjaGlsZHJlblxuICAgICAgICB0aGlzLmFjdGl2ZU1hcmtzID0gTWFyay5ub25lO1xuICAgICAgICAvLyBOZXN0ZWQgTWFya3Mgd2l0aCBzYW1lIHR5cGVcbiAgICAgICAgdGhpcy5zdGFzaE1hcmtzID0gW107XG4gICAgICAgIHRoaXMubWF0Y2ggPSBtYXRjaCB8fCAob3B0aW9ucyAmIE9QVF9PUEVOX0xFRlQgPyBudWxsIDogdHlwZS5jb250ZW50TWF0Y2gpO1xuICAgIH1cbiAgICBmaW5kV3JhcHBpbmcobm9kZSkge1xuICAgICAgICBpZiAoIXRoaXMubWF0Y2gpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy50eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIGxldCBmaWxsID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmZyb20obm9kZSkpO1xuICAgICAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGZpbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaCwgd3JhcDtcbiAgICAgICAgICAgICAgICBpZiAod3JhcCA9IHN0YXJ0LmZpbmRXcmFwcGluZyhub2RlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2ggPSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2guZmluZFdyYXBwaW5nKG5vZGUudHlwZSk7XG4gICAgfVxuICAgIGZpbmlzaChvcGVuRW5kKSB7XG4gICAgICAgIGlmICghKHRoaXMub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XUykpIHsgLy8gU3RyaXAgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdLCBtO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC5pc1RleHQgJiYgKG0gPSAvWyBcXHRcXHJcXG5cXHUwMDBjXSskLy5leGVjKGxhc3QudGV4dCkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHQgPSBsYXN0O1xuICAgICAgICAgICAgICAgIGlmIChsYXN0LnRleHQubGVuZ3RoID09IG1bMF0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQucG9wKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdID0gdGV4dC53aXRoVGV4dCh0ZXh0LnRleHQuc2xpY2UoMCwgdGV4dC50ZXh0Lmxlbmd0aCAtIG1bMF0ubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHRoaXMuY29udGVudCk7XG4gICAgICAgIGlmICghb3BlbkVuZCAmJiB0aGlzLm1hdGNoKVxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuYXBwZW5kKHRoaXMubWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID8gdGhpcy50eXBlLmNyZWF0ZSh0aGlzLmF0dHJzLCBjb250ZW50LCB0aGlzLm1hcmtzKSA6IGNvbnRlbnQ7XG4gICAgfVxuICAgIHBvcEZyb21TdGFzaE1hcmsobWFyaykge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGFzaE1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgaWYgKG1hcmsuZXEodGhpcy5zdGFzaE1hcmtzW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFzaE1hcmtzLnNwbGljZShpLCAxKVswXTtcbiAgICB9XG4gICAgYXBwbHlQZW5kaW5nKG5leHRUeXBlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nTWFya3M7IGkgPCBwZW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFyayA9IHBlbmRpbmdbaV07XG4gICAgICAgICAgICBpZiAoKHRoaXMudHlwZSA/IHRoaXMudHlwZS5hbGxvd3NNYXJrVHlwZShtYXJrLnR5cGUpIDogbWFya01heUFwcGx5KG1hcmsudHlwZSwgbmV4dFR5cGUpKSAmJlxuICAgICAgICAgICAgICAgICFtYXJrLmlzSW5TZXQodGhpcy5hY3RpdmVNYXJrcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZU1hcmtzID0gbWFyay5hZGRUb1NldCh0aGlzLmFjdGl2ZU1hcmtzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdNYXJrcyA9IG1hcmsucmVtb3ZlRnJvbVNldCh0aGlzLnBlbmRpbmdNYXJrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5saW5lQ29udGV4dChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLmlubGluZUNvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFswXS5pc0lubGluZTtcbiAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZSAmJiAhYmxvY2tUYWdzLmhhc093blByb3BlcnR5KG5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG59XG5jbGFzcyBQYXJzZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIFRoZSBwYXJzZXIgd2UgYXJlIHVzaW5nLlxuICAgIHBhcnNlciwgXG4gICAgLy8gVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoaXMgcGFyc2UuXG4gICAgb3B0aW9ucywgaXNPcGVuKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmlzT3BlbiA9IGlzT3BlbjtcbiAgICAgICAgdGhpcy5vcGVuID0gMDtcbiAgICAgICAgbGV0IHRvcE5vZGUgPSBvcHRpb25zLnRvcE5vZGUsIHRvcENvbnRleHQ7XG4gICAgICAgIGxldCB0b3BPcHRpb25zID0gd3NPcHRpb25zRm9yKG51bGwsIG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlLCAwKSB8IChpc09wZW4gPyBPUFRfT1BFTl9MRUZUIDogMCk7XG4gICAgICAgIGlmICh0b3BOb2RlKVxuICAgICAgICAgICAgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dCh0b3BOb2RlLnR5cGUsIHRvcE5vZGUuYXR0cnMsIE1hcmsubm9uZSwgTWFyay5ub25lLCB0cnVlLCBvcHRpb25zLnRvcE1hdGNoIHx8IHRvcE5vZGUudHlwZS5jb250ZW50TWF0Y2gsIHRvcE9wdGlvbnMpO1xuICAgICAgICBlbHNlIGlmIChpc09wZW4pXG4gICAgICAgICAgICB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KG51bGwsIG51bGwsIE1hcmsubm9uZSwgTWFyay5ub25lLCB0cnVlLCBudWxsLCB0b3BPcHRpb25zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dChwYXJzZXIuc2NoZW1hLnRvcE5vZGVUeXBlLCBudWxsLCBNYXJrLm5vbmUsIE1hcmsubm9uZSwgdHJ1ZSwgbnVsbCwgdG9wT3B0aW9ucyk7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbdG9wQ29udGV4dF07XG4gICAgICAgIHRoaXMuZmluZCA9IG9wdGlvbnMuZmluZFBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5uZWVkc0Jsb2NrID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCB0b3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzW3RoaXMub3Blbl07XG4gICAgfVxuICAgIC8vIEFkZCBhIERPTSBub2RlIHRvIHRoZSBjb250ZW50LiBUZXh0IGlzIGluc2VydGVkIGFzIHRleHQgbm9kZSxcbiAgICAvLyBvdGhlcndpc2UsIHRoZSBub2RlIGlzIHBhc3NlZCB0byBgYWRkRWxlbWVudGAgb3IsIGlmIGl0IGhhcyBhXG4gICAgLy8gYHN0eWxlYCBhdHRyaWJ1dGUsIGBhZGRFbGVtZW50V2l0aFN0eWxlc2AuXG4gICAgYWRkRE9NKGRvbSkge1xuICAgICAgICBpZiAoZG9tLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB0aGlzLmFkZFRleHROb2RlKGRvbSk7XG4gICAgICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50KGRvbSk7XG4gICAgfVxuICAgIHdpdGhTdHlsZVJ1bGVzKGRvbSwgZikge1xuICAgICAgICBsZXQgc3R5bGUgPSBkb20uZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgICAgIGlmICghc3R5bGUpXG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICBsZXQgbWFya3MgPSB0aGlzLnJlYWRTdHlsZXMocGFyc2VTdHlsZXMoc3R5bGUpKTtcbiAgICAgICAgaWYgKCFtYXJrcylcbiAgICAgICAgICAgIHJldHVybjsgLy8gQSBzdHlsZSB3aXRoIGlnbm9yZTogdHJ1ZVxuICAgICAgICBsZXQgW2FkZE1hcmtzLCByZW1vdmVNYXJrc10gPSBtYXJrcywgdG9wID0gdGhpcy50b3A7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlTWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBlbmRpbmdNYXJrKHJlbW92ZU1hcmtzW2ldLCB0b3ApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZE1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5hZGRQZW5kaW5nTWFyayhhZGRNYXJrc1tpXSk7XG4gICAgICAgIGYoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUGVuZGluZ01hcmsoYWRkTWFya3NbaV0sIHRvcCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlTWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLmFkZFBlbmRpbmdNYXJrKHJlbW92ZU1hcmtzW2ldKTtcbiAgICB9XG4gICAgYWRkVGV4dE5vZGUoZG9tKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGRvbS5ub2RlVmFsdWU7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgaWYgKHRvcC5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTX0ZVTEwgfHxcbiAgICAgICAgICAgIHRvcC5pbmxpbmVDb250ZXh0KGRvbSkgfHxcbiAgICAgICAgICAgIC9bXiBcXHRcXHJcXG5cXHUwMDBjXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICghKHRvcC5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvWyBcXHRcXHJcXG5cXHUwMDBjXSsvZywgXCIgXCIpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgc3RhcnRzIHdpdGggd2hpdGVzcGFjZSwgYW5kIHRoZXJlIGlzIG5vIG5vZGUgYmVmb3JlIGl0LCBvclxuICAgICAgICAgICAgICAgIC8vIGEgaGFyZCBicmVhaywgb3IgYSB0ZXh0IG5vZGUgdGhhdCBlbmRzIHdpdGggd2hpdGVzcGFjZSwgc3RyaXAgdGhlXG4gICAgICAgICAgICAgICAgLy8gbGVhZGluZyBzcGFjZS5cbiAgICAgICAgICAgICAgICBpZiAoL15bIFxcdFxcclxcblxcdTAwMGNdLy50ZXN0KHZhbHVlKSAmJiB0aGlzLm9wZW4gPT0gdGhpcy5ub2Rlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub2RlQmVmb3JlID0gdG9wLmNvbnRlbnRbdG9wLmNvbnRlbnQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBkb21Ob2RlQmVmb3JlID0gZG9tLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlQmVmb3JlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoZG9tTm9kZUJlZm9yZSAmJiBkb21Ob2RlQmVmb3JlLm5vZGVOYW1lID09ICdCUicpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAobm9kZUJlZm9yZS5pc1RleHQgJiYgL1sgXFx0XFxyXFxuXFx1MDAwY10kLy50ZXN0KG5vZGVCZWZvcmUudGV4dCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghKHRvcC5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTX0ZVTEwpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHI/XFxufFxcci9nLCBcIiBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnROb2RlKHRoaXMucGFyc2VyLnNjaGVtYS50ZXh0KHZhbHVlKSk7XG4gICAgICAgICAgICB0aGlzLmZpbmRJblRleHQoZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRyeSB0byBmaW5kIGEgaGFuZGxlciBmb3IgdGhlIGdpdmVuIHRhZyBhbmQgdXNlIHRoYXQgdG8gcGFyc2UuIElmXG4gICAgLy8gbm9uZSBpcyBmb3VuZCwgdGhlIGVsZW1lbnQncyBjb250ZW50IG5vZGVzIGFyZSBhZGRlZCBkaXJlY3RseS5cbiAgICBhZGRFbGVtZW50KGRvbSwgbWF0Y2hBZnRlcikge1xuICAgICAgICBsZXQgbmFtZSA9IGRvbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBydWxlSUQ7XG4gICAgICAgIGlmIChsaXN0VGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB0aGlzLnBhcnNlci5ub3JtYWxpemVMaXN0cylcbiAgICAgICAgICAgIG5vcm1hbGl6ZUxpc3QoZG9tKTtcbiAgICAgICAgbGV0IHJ1bGUgPSAodGhpcy5vcHRpb25zLnJ1bGVGcm9tTm9kZSAmJiB0aGlzLm9wdGlvbnMucnVsZUZyb21Ob2RlKGRvbSkpIHx8XG4gICAgICAgICAgICAocnVsZUlEID0gdGhpcy5wYXJzZXIubWF0Y2hUYWcoZG9tLCB0aGlzLCBtYXRjaEFmdGVyKSk7XG4gICAgICAgIGlmIChydWxlID8gcnVsZS5pZ25vcmUgOiBpZ25vcmVUYWdzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlRmFsbGJhY2soZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcnVsZSB8fCBydWxlLnNraXAgfHwgcnVsZS5jbG9zZVBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHJ1bGUgJiYgcnVsZS5jbG9zZVBhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4gPSBNYXRoLm1heCgwLCB0aGlzLm9wZW4gLSAxKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUgJiYgcnVsZS5za2lwLm5vZGVUeXBlKVxuICAgICAgICAgICAgICAgIGRvbSA9IHJ1bGUuc2tpcDtcbiAgICAgICAgICAgIGxldCBzeW5jLCB0b3AgPSB0aGlzLnRvcCwgb2xkTmVlZHNCbG9jayA9IHRoaXMubmVlZHNCbG9jaztcbiAgICAgICAgICAgIGlmIChibG9ja1RhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9wLmNvbnRlbnQubGVuZ3RoICYmIHRvcC5jb250ZW50WzBdLmlzSW5saW5lICYmIHRoaXMub3Blbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW4tLTtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gdGhpcy50b3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghdG9wLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmVlZHNCbG9jayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZG9tLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlYWZGYWxsYmFjayhkb20pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydWxlICYmIHJ1bGUuc2tpcClcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEFsbChkb20pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMud2l0aFN0eWxlUnVsZXMoZG9tLCAoKSA9PiB0aGlzLmFkZEFsbChkb20pKTtcbiAgICAgICAgICAgIGlmIChzeW5jKVxuICAgICAgICAgICAgICAgIHRoaXMuc3luYyh0b3ApO1xuICAgICAgICAgICAgdGhpcy5uZWVkc0Jsb2NrID0gb2xkTmVlZHNCbG9jaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud2l0aFN0eWxlUnVsZXMoZG9tLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50QnlSdWxlKGRvbSwgcnVsZSwgcnVsZS5jb25zdW1pbmcgPT09IGZhbHNlID8gcnVsZUlEIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENhbGxlZCBmb3IgbGVhZiBET00gbm9kZXMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYmUgaWdub3JlZFxuICAgIGxlYWZGYWxsYmFjayhkb20pIHtcbiAgICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgdGhpcy50b3AudHlwZSAmJiB0aGlzLnRvcC50eXBlLmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICB0aGlzLmFkZFRleHROb2RlKGRvbS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXCIpKTtcbiAgICB9XG4gICAgLy8gQ2FsbGVkIGZvciBpZ25vcmVkIG5vZGVzXG4gICAgaWdub3JlRmFsbGJhY2soZG9tKSB7XG4gICAgICAgIC8vIElnbm9yZWQgQlIgbm9kZXMgc2hvdWxkIGF0IGxlYXN0IGNyZWF0ZSBhbiBpbmxpbmUgY29udGV4dFxuICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiAoIXRoaXMudG9wLnR5cGUgfHwgIXRoaXMudG9wLnR5cGUuaW5saW5lQ29udGVudCkpXG4gICAgICAgICAgICB0aGlzLmZpbmRQbGFjZSh0aGlzLnBhcnNlci5zY2hlbWEudGV4dChcIi1cIikpO1xuICAgIH1cbiAgICAvLyBSdW4gYW55IHN0eWxlIHBhcnNlciBhc3NvY2lhdGVkIHdpdGggdGhlIG5vZGUncyBzdHlsZXMuIEVpdGhlclxuICAgIC8vIHJldHVybiBhbiBhcnJheSBvZiBtYXJrcywgb3IgbnVsbCB0byBpbmRpY2F0ZSBzb21lIG9mIHRoZSBzdHlsZXNcbiAgICAvLyBoYWQgYSBydWxlIHdpdGggYGlnbm9yZWAgc2V0LlxuICAgIHJlYWRTdHlsZXMoc3R5bGVzKSB7XG4gICAgICAgIGxldCBhZGQgPSBNYXJrLm5vbmUsIHJlbW92ZSA9IE1hcmsubm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGFmdGVyID0gdW5kZWZpbmVkOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IHRoaXMucGFyc2VyLm1hdGNoU3R5bGUoc3R5bGVzW2ldLCBzdHlsZXNbaSArIDFdLCB0aGlzLCBhZnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKCFydWxlKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5pZ25vcmUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmNsZWFyTWFyaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvcC5wZW5kaW5nTWFya3MuY29uY2F0KHRoaXMudG9wLmFjdGl2ZU1hcmtzKS5mb3JFYWNoKG0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUuY2xlYXJNYXJrKG0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSA9IG0uYWRkVG9TZXQocmVtb3ZlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGQgPSB0aGlzLnBhcnNlci5zY2hlbWEubWFya3NbcnVsZS5tYXJrXS5jcmVhdGUocnVsZS5hdHRycykuYWRkVG9TZXQoYWRkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuY29uc3VtaW5nID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSBydWxlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFthZGQsIHJlbW92ZV07XG4gICAgfVxuICAgIC8vIExvb2sgdXAgYSBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gbm9kZS4gSWYgbm9uZSBhcmUgZm91bmQsIHJldHVyblxuICAgIC8vIGZhbHNlLiBPdGhlcndpc2UsIGFwcGx5IGl0LCB1c2UgaXRzIHJldHVybiB2YWx1ZSB0byBkcml2ZSB0aGUgd2F5XG4gICAgLy8gdGhlIG5vZGUncyBjb250ZW50IGlzIHdyYXBwZWQsIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICBhZGRFbGVtZW50QnlSdWxlKGRvbSwgcnVsZSwgY29udGludWVBZnRlcikge1xuICAgICAgICBsZXQgc3luYywgbm9kZVR5cGUsIG1hcms7XG4gICAgICAgIGlmIChydWxlLm5vZGUpIHtcbiAgICAgICAgICAgIG5vZGVUeXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzW3J1bGUubm9kZV07XG4gICAgICAgICAgICBpZiAoIW5vZGVUeXBlLmlzTGVhZikge1xuICAgICAgICAgICAgICAgIHN5bmMgPSB0aGlzLmVudGVyKG5vZGVUeXBlLCBydWxlLmF0dHJzIHx8IG51bGwsIHJ1bGUucHJlc2VydmVXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmluc2VydE5vZGUobm9kZVR5cGUuY3JlYXRlKHJ1bGUuYXR0cnMpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhZkZhbGxiYWNrKGRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWFya1R5cGUgPSB0aGlzLnBhcnNlci5zY2hlbWEubWFya3NbcnVsZS5tYXJrXTtcbiAgICAgICAgICAgIG1hcmsgPSBtYXJrVHlwZS5jcmVhdGUocnVsZS5hdHRycyk7XG4gICAgICAgICAgICB0aGlzLmFkZFBlbmRpbmdNYXJrKG1hcmspO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydEluID0gdGhpcy50b3A7XG4gICAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZS5pc0xlYWYpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRpbnVlQWZ0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudChkb20sIGNvbnRpbnVlQWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJ1bGUuZ2V0Q29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgICAgICBydWxlLmdldENvbnRlbnQoZG9tLCB0aGlzLnBhcnNlci5zY2hlbWEpLmZvckVhY2gobm9kZSA9PiB0aGlzLmluc2VydE5vZGUobm9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRET00gPSBkb207XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGUuY29udGVudEVsZW1lbnQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NID0gZG9tLnF1ZXJ5U2VsZWN0b3IocnVsZS5jb250ZW50RWxlbWVudCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcnVsZS5jb250ZW50RWxlbWVudCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgY29udGVudERPTSA9IHJ1bGUuY29udGVudEVsZW1lbnQoZG9tKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUuY29udGVudEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgY29udGVudERPTSA9IHJ1bGUuY29udGVudEVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmRBcm91bmQoZG9tLCBjb250ZW50RE9NLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQWxsKGNvbnRlbnRET00pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzeW5jICYmIHRoaXMuc3luYyhzdGFydEluKSlcbiAgICAgICAgICAgIHRoaXMub3Blbi0tO1xuICAgICAgICBpZiAobWFyaylcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUGVuZGluZ01hcmsobWFyaywgc3RhcnRJbik7XG4gICAgfVxuICAgIC8vIEFkZCBhbGwgY2hpbGQgbm9kZXMgYmV0d2VlbiBgc3RhcnRJbmRleGAgYW5kIGBlbmRJbmRleGAgKG9yIHRoZVxuICAgIC8vIHdob2xlIG5vZGUsIGlmIG5vdCBnaXZlbikuIElmIGBzeW5jYCBpcyBwYXNzZWQsIHVzZSBpdCB0b1xuICAgIC8vIHN5bmNocm9uaXplIGFmdGVyIGV2ZXJ5IGJsb2NrIGVsZW1lbnQuXG4gICAgYWRkQWxsKHBhcmVudCwgc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gc3RhcnRJbmRleCB8fCAwO1xuICAgICAgICBmb3IgKGxldCBkb20gPSBzdGFydEluZGV4ID8gcGFyZW50LmNoaWxkTm9kZXNbc3RhcnRJbmRleF0gOiBwYXJlbnQuZmlyc3RDaGlsZCwgZW5kID0gZW5kSW5kZXggPT0gbnVsbCA/IG51bGwgOiBwYXJlbnQuY2hpbGROb2Rlc1tlbmRJbmRleF07IGRvbSAhPSBlbmQ7IGRvbSA9IGRvbS5uZXh0U2libGluZywgKytpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5maW5kQXRQb2ludChwYXJlbnQsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYWRkRE9NKGRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5kQXRQb2ludChwYXJlbnQsIGluZGV4KTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSB3YXkgdG8gZml0IHRoZSBnaXZlbiBub2RlIHR5cGUgaW50byB0aGUgY3VycmVudFxuICAgIC8vIGNvbnRleHQuIE1heSBhZGQgaW50ZXJtZWRpYXRlIHdyYXBwZXJzIGFuZC9vciBsZWF2ZSBub24tc29saWRcbiAgICAvLyBub2RlcyB0aGF0IHdlJ3JlIGluLlxuICAgIGZpbmRQbGFjZShub2RlKSB7XG4gICAgICAgIGxldCByb3V0ZSwgc3luYztcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSB0aGlzLm9wZW47IGRlcHRoID49IDA7IGRlcHRoLS0pIHtcbiAgICAgICAgICAgIGxldCBjeCA9IHRoaXMubm9kZXNbZGVwdGhdO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gY3guZmluZFdyYXBwaW5nKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGZvdW5kICYmICghcm91dGUgfHwgcm91dGUubGVuZ3RoID4gZm91bmQubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHJvdXRlID0gZm91bmQ7XG4gICAgICAgICAgICAgICAgc3luYyA9IGN4O1xuICAgICAgICAgICAgICAgIGlmICghZm91bmQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjeC5zb2xpZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJvdXRlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnN5bmMoc3luYyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLmVudGVySW5uZXIocm91dGVbaV0sIG51bGwsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFRyeSB0byBpbnNlcnQgdGhlIGdpdmVuIG5vZGUsIGFkanVzdGluZyB0aGUgY29udGV4dCB3aGVuIG5lZWRlZC5cbiAgICBpbnNlcnROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuaXNJbmxpbmUgJiYgdGhpcy5uZWVkc0Jsb2NrICYmICF0aGlzLnRvcC50eXBlKSB7XG4gICAgICAgICAgICBsZXQgYmxvY2sgPSB0aGlzLnRleHRibG9ja0Zyb21Db250ZXh0KCk7XG4gICAgICAgICAgICBpZiAoYmxvY2spXG4gICAgICAgICAgICAgICAgdGhpcy5lbnRlcklubmVyKGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maW5kUGxhY2Uobm9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VFeHRyYSgpO1xuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgICAgICAgdG9wLmFwcGx5UGVuZGluZyhub2RlLnR5cGUpO1xuICAgICAgICAgICAgaWYgKHRvcC5tYXRjaClcbiAgICAgICAgICAgICAgICB0b3AubWF0Y2ggPSB0b3AubWF0Y2gubWF0Y2hUeXBlKG5vZGUudHlwZSk7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSB0b3AuYWN0aXZlTWFya3M7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKCF0b3AudHlwZSB8fCB0b3AudHlwZS5hbGxvd3NNYXJrVHlwZShub2RlLm1hcmtzW2ldLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICBtYXJrcyA9IG5vZGUubWFya3NbaV0uYWRkVG9TZXQobWFya3MpO1xuICAgICAgICAgICAgdG9wLmNvbnRlbnQucHVzaChub2RlLm1hcmsobWFya3MpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIHN0YXJ0IGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSwgYWRqdXN0aW5nIHRoZSBjb250ZXh0IHdoZW5cbiAgICAvLyBuZWNlc3NhcnkuXG4gICAgZW50ZXIodHlwZSwgYXR0cnMsIHByZXNlcnZlV1MpIHtcbiAgICAgICAgbGV0IG9rID0gdGhpcy5maW5kUGxhY2UodHlwZS5jcmVhdGUoYXR0cnMpKTtcbiAgICAgICAgaWYgKG9rKVxuICAgICAgICAgICAgdGhpcy5lbnRlcklubmVyKHR5cGUsIGF0dHJzLCB0cnVlLCBwcmVzZXJ2ZVdTKTtcbiAgICAgICAgcmV0dXJuIG9rO1xuICAgIH1cbiAgICAvLyBPcGVuIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZVxuICAgIGVudGVySW5uZXIodHlwZSwgYXR0cnMgPSBudWxsLCBzb2xpZCA9IGZhbHNlLCBwcmVzZXJ2ZVdTKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFeHRyYSgpO1xuICAgICAgICBsZXQgdG9wID0gdGhpcy50b3A7XG4gICAgICAgIHRvcC5hcHBseVBlbmRpbmcodHlwZSk7XG4gICAgICAgIHRvcC5tYXRjaCA9IHRvcC5tYXRjaCAmJiB0b3AubWF0Y2gubWF0Y2hUeXBlKHR5cGUpO1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHdzT3B0aW9uc0Zvcih0eXBlLCBwcmVzZXJ2ZVdTLCB0b3Aub3B0aW9ucyk7XG4gICAgICAgIGlmICgodG9wLm9wdGlvbnMgJiBPUFRfT1BFTl9MRUZUKSAmJiB0b3AuY29udGVudC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIG9wdGlvbnMgfD0gT1BUX09QRU5fTEVGVDtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBOb2RlQ29udGV4dCh0eXBlLCBhdHRycywgdG9wLmFjdGl2ZU1hcmtzLCB0b3AucGVuZGluZ01hcmtzLCBzb2xpZCwgbnVsbCwgb3B0aW9ucykpO1xuICAgICAgICB0aGlzLm9wZW4rKztcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIGFsbCBub2RlcyBhYm92ZSB0aGlzLm9wZW4gYXJlIGZpbmlzaGVkIGFuZCBhZGRlZCB0b1xuICAgIC8vIHRoZWlyIHBhcmVudHNcbiAgICBjbG9zZUV4dHJhKG9wZW5FbmQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgaSA9IHRoaXMubm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGkgPiB0aGlzLm9wZW4pIHtcbiAgICAgICAgICAgIGZvciAoOyBpID4gdGhpcy5vcGVuOyBpLS0pXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlc1tpIC0gMV0uY29udGVudC5wdXNoKHRoaXMubm9kZXNbaV0uZmluaXNoKG9wZW5FbmQpKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMubGVuZ3RoID0gdGhpcy5vcGVuICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHRoaXMub3BlbiA9IDA7XG4gICAgICAgIHRoaXMuY2xvc2VFeHRyYSh0aGlzLmlzT3Blbik7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzWzBdLmZpbmlzaCh0aGlzLmlzT3BlbiB8fCB0aGlzLm9wdGlvbnMudG9wT3Blbik7XG4gICAgfVxuICAgIHN5bmModG8pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMub3BlbjsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1tpXSA9PSB0bykge1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbiA9IGk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRQb3MoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFeHRyYSgpO1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMub3BlbjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5ub2Rlc1tpXS5jb250ZW50O1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGNvbnRlbnQubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG4gICAgICAgICAgICAgICAgcG9zICs9IGNvbnRlbnRbal0ubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBmaW5kQXRQb2ludChwYXJlbnQsIG9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLm5vZGUgPT0gcGFyZW50ICYmIHRoaXMuZmluZFtpXS5vZmZzZXQgPT0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kSW5zaWRlKHBhcmVudCkge1xuICAgICAgICBpZiAodGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLnBvcyA9PSBudWxsICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxICYmIHBhcmVudC5jb250YWlucyh0aGlzLmZpbmRbaV0ubm9kZSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3M7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRBcm91bmQocGFyZW50LCBjb250ZW50LCBiZWZvcmUpIHtcbiAgICAgICAgaWYgKHBhcmVudCAhPSBjb250ZW50ICYmIHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5wb3MgPT0gbnVsbCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMSAmJiBwYXJlbnQuY29udGFpbnModGhpcy5maW5kW2ldLm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3MgPSBjb250ZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuZmluZFtpXS5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyAmIChiZWZvcmUgPyAyIDogNCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZmluZEluVGV4dCh0ZXh0Tm9kZSkge1xuICAgICAgICBpZiAodGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLm5vZGUgPT0gdGV4dE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3MgLSAodGV4dE5vZGUubm9kZVZhbHVlLmxlbmd0aCAtIHRoaXMuZmluZFtpXS5vZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIGNvbnRleHQgc3RyaW5nIG1hdGNoZXMgdGhpcyBjb250ZXh0LlxuICAgIG1hdGNoZXNDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuaW5kZXhPZihcInxcIikgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnNwbGl0KC9cXHMqXFx8XFxzKi8pLnNvbWUodGhpcy5tYXRjaGVzQ29udGV4dCwgdGhpcyk7XG4gICAgICAgIGxldCBwYXJ0cyA9IGNvbnRleHQuc3BsaXQoXCIvXCIpO1xuICAgICAgICBsZXQgb3B0aW9uID0gdGhpcy5vcHRpb25zLmNvbnRleHQ7XG4gICAgICAgIGxldCB1c2VSb290ID0gIXRoaXMuaXNPcGVuICYmICghb3B0aW9uIHx8IG9wdGlvbi5wYXJlbnQudHlwZSA9PSB0aGlzLm5vZGVzWzBdLnR5cGUpO1xuICAgICAgICBsZXQgbWluRGVwdGggPSAtKG9wdGlvbiA/IG9wdGlvbi5kZXB0aCArIDEgOiAwKSArICh1c2VSb290ID8gMCA6IDEpO1xuICAgICAgICBsZXQgbWF0Y2ggPSAoaSwgZGVwdGgpID0+IHtcbiAgICAgICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQgPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSBwYXJ0cy5sZW5ndGggLSAxIHx8IGkgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZGVwdGggPj0gbWluRGVwdGg7IGRlcHRoLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2goaSAtIDEsIGRlcHRoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBkZXB0aCA+IDAgfHwgKGRlcHRoID09IDAgJiYgdXNlUm9vdCkgPyB0aGlzLm5vZGVzW2RlcHRoXS50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9wdGlvbiAmJiBkZXB0aCA+PSBtaW5EZXB0aCA/IG9wdGlvbi5ub2RlKGRlcHRoIC0gbWluRGVwdGgpLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dCB8fCAobmV4dC5uYW1lICE9IHBhcnQgJiYgbmV4dC5ncm91cHMuaW5kZXhPZihwYXJ0KSA9PSAtMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtYXRjaChwYXJ0cy5sZW5ndGggLSAxLCB0aGlzLm9wZW4pO1xuICAgIH1cbiAgICB0ZXh0YmxvY2tGcm9tQ29udGV4dCgpIHtcbiAgICAgICAgbGV0ICRjb250ZXh0ID0gdGhpcy5vcHRpb25zLmNvbnRleHQ7XG4gICAgICAgIGlmICgkY29udGV4dClcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAkY29udGV4dC5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVmbHQgPSAkY29udGV4dC5ub2RlKGQpLmNvbnRlbnRNYXRjaEF0KCRjb250ZXh0LmluZGV4QWZ0ZXIoZCkpLmRlZmF1bHRUeXBlO1xuICAgICAgICAgICAgICAgIGlmIChkZWZsdCAmJiBkZWZsdC5pc1RleHRibG9jayAmJiBkZWZsdC5kZWZhdWx0QXR0cnMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLnBhcnNlci5zY2hlbWEubm9kZXMpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGUuaXNUZXh0YmxvY2sgJiYgdHlwZS5kZWZhdWx0QXR0cnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkUGVuZGluZ01hcmsobWFyaykge1xuICAgICAgICBsZXQgZm91bmQgPSBmaW5kU2FtZU1hcmtJblNldChtYXJrLCB0aGlzLnRvcC5wZW5kaW5nTWFya3MpO1xuICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICB0aGlzLnRvcC5zdGFzaE1hcmtzLnB1c2goZm91bmQpO1xuICAgICAgICB0aGlzLnRvcC5wZW5kaW5nTWFya3MgPSBtYXJrLmFkZFRvU2V0KHRoaXMudG9wLnBlbmRpbmdNYXJrcyk7XG4gICAgfVxuICAgIHJlbW92ZVBlbmRpbmdNYXJrKG1hcmssIHVwdG8pIHtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSB0aGlzLm9wZW47IGRlcHRoID49IDA7IGRlcHRoLS0pIHtcbiAgICAgICAgICAgIGxldCBsZXZlbCA9IHRoaXMubm9kZXNbZGVwdGhdO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gbGV2ZWwucGVuZGluZ01hcmtzLmxhc3RJbmRleE9mKG1hcmspO1xuICAgICAgICAgICAgaWYgKGZvdW5kID4gLTEpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5wZW5kaW5nTWFya3MgPSBtYXJrLnJlbW92ZUZyb21TZXQobGV2ZWwucGVuZGluZ01hcmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldmVsLmFjdGl2ZU1hcmtzID0gbWFyay5yZW1vdmVGcm9tU2V0KGxldmVsLmFjdGl2ZU1hcmtzKTtcbiAgICAgICAgICAgICAgICBsZXQgc3Rhc2hNYXJrID0gbGV2ZWwucG9wRnJvbVN0YXNoTWFyayhtYXJrKTtcbiAgICAgICAgICAgICAgICBpZiAoc3Rhc2hNYXJrICYmIGxldmVsLnR5cGUgJiYgbGV2ZWwudHlwZS5hbGxvd3NNYXJrVHlwZShzdGFzaE1hcmsudHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIGxldmVsLmFjdGl2ZU1hcmtzID0gc3Rhc2hNYXJrLmFkZFRvU2V0KGxldmVsLmFjdGl2ZU1hcmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZXZlbCA9PSB1cHRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gS2x1ZGdlIHRvIHdvcmsgYXJvdW5kIGRpcmVjdGx5IG5lc3RlZCBsaXN0IG5vZGVzIHByb2R1Y2VkIGJ5IHNvbWVcbi8vIHRvb2xzIGFuZCBhbGxvd2VkIGJ5IGJyb3dzZXJzIHRvIG1lYW4gdGhhdCB0aGUgbmVzdGVkIGxpc3QgaXNcbi8vIGFjdHVhbGx5IHBhcnQgb2YgdGhlIGxpc3QgaXRlbSBhYm92ZSBpdC5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpc3QoZG9tKSB7XG4gICAgZm9yIChsZXQgY2hpbGQgPSBkb20uZmlyc3RDaGlsZCwgcHJldkl0ZW0gPSBudWxsOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICBsZXQgbmFtZSA9IGNoaWxkLm5vZGVUeXBlID09IDEgPyBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbiAgICAgICAgaWYgKG5hbWUgJiYgbGlzdFRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgcHJldkl0ZW0pIHtcbiAgICAgICAgICAgIHByZXZJdGVtLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIGNoaWxkID0gcHJldkl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PSBcImxpXCIpIHtcbiAgICAgICAgICAgIHByZXZJdGVtID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSkge1xuICAgICAgICAgICAgcHJldkl0ZW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gQXBwbHkgYSBDU1Mgc2VsZWN0b3IuXG5mdW5jdGlvbiBtYXRjaGVzKGRvbSwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gKGRvbS5tYXRjaGVzIHx8IGRvbS5tc01hdGNoZXNTZWxlY3RvciB8fCBkb20ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGRvbS5tb3pNYXRjaGVzU2VsZWN0b3IpLmNhbGwoZG9tLCBzZWxlY3Rvcik7XG59XG4vLyBUb2tlbml6ZSBhIHN0eWxlIGF0dHJpYnV0ZSBpbnRvIHByb3BlcnR5L3ZhbHVlIHBhaXJzLlxuZnVuY3Rpb24gcGFyc2VTdHlsZXMoc3R5bGUpIHtcbiAgICBsZXQgcmUgPSAvXFxzKihbXFx3LV0rKVxccyo6XFxzKihbXjtdKykvZywgbSwgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKG0gPSByZS5leGVjKHN0eWxlKSlcbiAgICAgICAgcmVzdWx0LnB1c2gobVsxXSwgbVsyXS50cmltKCkpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb3B5KG9iaikge1xuICAgIGxldCBjb3B5ID0ge307XG4gICAgZm9yIChsZXQgcHJvcCBpbiBvYmopXG4gICAgICAgIGNvcHlbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgcmV0dXJuIGNvcHk7XG59XG4vLyBVc2VkIHdoZW4gZmluZGluZyBhIG1hcmsgYXQgdGhlIHRvcCBsZXZlbCBvZiBhIGZyYWdtZW50IHBhcnNlLlxuLy8gQ2hlY2tzIHdoZXRoZXIgaXQgd291bGQgYmUgcmVhc29uYWJsZSB0byBhcHBseSBhIGdpdmVuIG1hcmsgdHlwZSB0b1xuLy8gYSBnaXZlbiBub2RlLCBieSBsb29raW5nIGF0IHRoZSB3YXkgdGhlIG1hcmsgb2NjdXJzIGluIHRoZSBzY2hlbWEuXG5mdW5jdGlvbiBtYXJrTWF5QXBwbHkobWFya1R5cGUsIG5vZGVUeXBlKSB7XG4gICAgbGV0IG5vZGVzID0gbm9kZVR5cGUuc2NoZW1hLm5vZGVzO1xuICAgIGZvciAobGV0IG5hbWUgaW4gbm9kZXMpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IG5vZGVzW25hbWVdO1xuICAgICAgICBpZiAoIXBhcmVudC5hbGxvd3NNYXJrVHlwZShtYXJrVHlwZSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IHNlZW4gPSBbXSwgc2NhbiA9IChtYXRjaCkgPT4ge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKG1hdGNoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2guZWRnZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBuZXh0IH0gPSBtYXRjaC5lZGdlKGkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IG5vZGVUeXBlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG5leHQpIDwgMCAmJiBzY2FuKG5leHQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNjYW4ocGFyZW50LmNvbnRlbnRNYXRjaCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kU2FtZU1hcmtJblNldChtYXJrLCBzZXQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobWFyay5lcShzZXRbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIHNldFtpXTtcbiAgICB9XG59XG5cbi8qKlxuQSBET00gc2VyaWFsaXplciBrbm93cyBob3cgdG8gY29udmVydCBQcm9zZU1pcnJvciBub2RlcyBhbmRcbm1hcmtzIG9mIHZhcmlvdXMgdHlwZXMgdG8gRE9NIG5vZGVzLlxuKi9cbmNsYXNzIERPTVNlcmlhbGl6ZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlcmlhbGl6ZXIuIGBub2Rlc2Agc2hvdWxkIG1hcCBub2RlIG5hbWVzIHRvIGZ1bmN0aW9uc1xuICAgIHRoYXQgdGFrZSBhIG5vZGUgYW5kIHJldHVybiBhIGRlc2NyaXB0aW9uIG9mIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgRE9NLiBgbWFya3NgIGRvZXMgdGhlIHNhbWUgZm9yIG1hcmsgbmFtZXMsIGJ1dCBhbHNvIGdldHMgYW5cbiAgICBhcmd1bWVudCB0aGF0IHRlbGxzIGl0IHdoZXRoZXIgdGhlIG1hcmsncyBjb250ZW50IGlzIGJsb2NrIG9yXG4gICAgaW5saW5lIGNvbnRlbnQgKGZvciB0eXBpY2FsIHVzZSwgaXQnbGwgYWx3YXlzIGJlIGlubGluZSkuIEEgbWFya1xuICAgIHNlcmlhbGl6ZXIgbWF5IGJlIGBudWxsYCB0byBpbmRpY2F0ZSB0aGF0IG1hcmtzIG9mIHRoYXQgdHlwZVxuICAgIHNob3VsZCBub3QgYmUgc2VyaWFsaXplZC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHNlcmlhbGl6YXRpb24gZnVuY3Rpb25zLlxuICAgICovXG4gICAgbm9kZXMsIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHNlcmlhbGl6YXRpb24gZnVuY3Rpb25zLlxuICAgICovXG4gICAgbWFya3MpIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgICAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGUgY29udGVudCBvZiB0aGlzIGZyYWdtZW50IHRvIGEgRE9NIGZyYWdtZW50LiBXaGVuXG4gICAgbm90IGluIHRoZSBicm93c2VyLCB0aGUgYGRvY3VtZW50YCBvcHRpb24sIGNvbnRhaW5pbmcgYSBET01cbiAgICBkb2N1bWVudCwgc2hvdWxkIGJlIHBhc3NlZCBzbyB0aGF0IHRoZSBzZXJpYWxpemVyIGNhbiBjcmVhdGVcbiAgICBub2Rlcy5cbiAgICAqL1xuICAgIHNlcmlhbGl6ZUZyYWdtZW50KGZyYWdtZW50LCBvcHRpb25zID0ge30sIHRhcmdldCkge1xuICAgICAgICBpZiAoIXRhcmdldClcbiAgICAgICAgICAgIHRhcmdldCA9IGRvYyhvcHRpb25zKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIGxldCB0b3AgPSB0YXJnZXQsIGFjdGl2ZSA9IFtdO1xuICAgICAgICBmcmFnbWVudC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGFjdGl2ZS5sZW5ndGggfHwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQga2VlcCA9IDAsIHJlbmRlcmVkID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoa2VlcCA8IGFjdGl2ZS5sZW5ndGggJiYgcmVuZGVyZWQgPCBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUubWFya3NbcmVuZGVyZWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWFya3NbbmV4dC50eXBlLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0LmVxKGFjdGl2ZVtrZWVwXVswXSkgfHwgbmV4dC50eXBlLnNwZWMuc3Bhbm5pbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGtlZXArKztcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGtlZXAgPCBhY3RpdmUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0b3AgPSBhY3RpdmUucG9wKClbMV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlbmRlcmVkIDwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFkZCA9IG5vZGUubWFya3NbcmVuZGVyZWQrK107XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXJrRE9NID0gdGhpcy5zZXJpYWxpemVNYXJrKGFkZCwgbm9kZS5pc0lubGluZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXJrRE9NKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUucHVzaChbYWRkLCB0b3BdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5hcHBlbmRDaGlsZChtYXJrRE9NLmRvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSBtYXJrRE9NLmNvbnRlbnRET00gfHwgbWFya0RPTS5kb207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3AuYXBwZW5kQ2hpbGQodGhpcy5zZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucykge1xuICAgICAgICBsZXQgeyBkb20sIGNvbnRlbnRET00gfSA9IERPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2Mob3B0aW9ucyksIHRoaXMubm9kZXNbbm9kZS50eXBlLm5hbWVdKG5vZGUpKTtcbiAgICAgICAgaWYgKGNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNvbnRlbnQgaG9sZSBub3QgYWxsb3dlZCBpbiBhIGxlYWYgbm9kZSBzcGVjXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVGcmFnbWVudChub2RlLmNvbnRlbnQsIG9wdGlvbnMsIGNvbnRlbnRET00pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGlzIG5vZGUgdG8gYSBET00gbm9kZS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4geW91XG4gICAgbmVlZCB0byBzZXJpYWxpemUgYSBwYXJ0IG9mIGEgZG9jdW1lbnQsIGFzIG9wcG9zZWQgdG8gdGhlIHdob2xlXG4gICAgZG9jdW1lbnQuIFRvIHNlcmlhbGl6ZSBhIHdob2xlIGRvY3VtZW50LCB1c2VcbiAgICBbYHNlcmlhbGl6ZUZyYWdtZW50YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkRPTVNlcmlhbGl6ZXIuc2VyaWFsaXplRnJhZ21lbnQpIG9uXG4gICAgaXRzIFtjb250ZW50XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS5jb250ZW50KS5cbiAgICAqL1xuICAgIHNlcmlhbGl6ZU5vZGUobm9kZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBkb20gPSB0aGlzLnNlcmlhbGl6ZU5vZGVJbm5lcihub2RlLCBvcHRpb25zKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IG5vZGUubWFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB3cmFwID0gdGhpcy5zZXJpYWxpemVNYXJrKG5vZGUubWFya3NbaV0sIG5vZGUuaXNJbmxpbmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHdyYXApIHtcbiAgICAgICAgICAgICAgICAod3JhcC5jb250ZW50RE9NIHx8IHdyYXAuZG9tKS5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgICAgIGRvbSA9IHdyYXAuZG9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2VyaWFsaXplTWFyayhtYXJrLCBpbmxpbmUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgdG9ET00gPSB0aGlzLm1hcmtzW21hcmsudHlwZS5uYW1lXTtcbiAgICAgICAgcmV0dXJuIHRvRE9NICYmIERPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2Mob3B0aW9ucyksIHRvRE9NKG1hcmssIGlubGluZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW5kZXIgYW4gW291dHB1dCBzcGVjXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuRE9NT3V0cHV0U3BlYykgdG8gYSBET00gbm9kZS4gSWZcbiAgICB0aGUgc3BlYyBoYXMgYSBob2xlICh6ZXJvKSBpbiBpdCwgYGNvbnRlbnRET01gIHdpbGwgcG9pbnQgYXQgdGhlXG4gICAgbm9kZSB3aXRoIHRoZSBob2xlLlxuICAgICovXG4gICAgc3RhdGljIHJlbmRlclNwZWMoZG9jLCBzdHJ1Y3R1cmUsIHhtbE5TID0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIHN0cnVjdHVyZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIHsgZG9tOiBkb2MuY3JlYXRlVGV4dE5vZGUoc3RydWN0dXJlKSB9O1xuICAgICAgICBpZiAoc3RydWN0dXJlLm5vZGVUeXBlICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm4geyBkb206IHN0cnVjdHVyZSB9O1xuICAgICAgICBpZiAoc3RydWN0dXJlLmRvbSAmJiBzdHJ1Y3R1cmUuZG9tLm5vZGVUeXBlICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gc3RydWN0dXJlO1xuICAgICAgICBsZXQgdGFnTmFtZSA9IHN0cnVjdHVyZVswXSwgc3BhY2UgPSB0YWdOYW1lLmluZGV4T2YoXCIgXCIpO1xuICAgICAgICBpZiAoc3BhY2UgPiAwKSB7XG4gICAgICAgICAgICB4bWxOUyA9IHRhZ05hbWUuc2xpY2UoMCwgc3BhY2UpO1xuICAgICAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWUuc2xpY2Uoc3BhY2UgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudERPTTtcbiAgICAgICAgbGV0IGRvbSA9ICh4bWxOUyA/IGRvYy5jcmVhdGVFbGVtZW50TlMoeG1sTlMsIHRhZ05hbWUpIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSkpO1xuICAgICAgICBsZXQgYXR0cnMgPSBzdHJ1Y3R1cmVbMV0sIHN0YXJ0ID0gMTtcbiAgICAgICAgaWYgKGF0dHJzICYmIHR5cGVvZiBhdHRycyA9PSBcIm9iamVjdFwiICYmIGF0dHJzLm5vZGVUeXBlID09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoYXR0cnMpKSB7XG4gICAgICAgICAgICBzdGFydCA9IDI7XG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKVxuICAgICAgICAgICAgICAgIGlmIChhdHRyc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZSA9IG5hbWUuaW5kZXhPZihcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGFjZSA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlTlMobmFtZS5zbGljZSgwLCBzcGFjZSksIG5hbWUuc2xpY2Uoc3BhY2UgKyAxKSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RydWN0dXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBzdHJ1Y3R1cmVbaV07XG4gICAgICAgICAgICBpZiAoY2hpbGQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IHN0cnVjdHVyZS5sZW5ndGggLSAxIHx8IGkgPiBzdGFydClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDb250ZW50IGhvbGUgbXVzdCBiZSB0aGUgb25seSBjaGlsZCBvZiBpdHMgcGFyZW50IG5vZGVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9tLCBjb250ZW50RE9NOiBkb20gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB7IGRvbTogaW5uZXIsIGNvbnRlbnRET006IGlubmVyQ29udGVudCB9ID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvYywgY2hpbGQsIHhtbE5TKTtcbiAgICAgICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoaW5uZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lckNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk11bHRpcGxlIGNvbnRlbnQgaG9sZXNcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBpbm5lckNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbSwgY29udGVudERPTSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBCdWlsZCBhIHNlcmlhbGl6ZXIgdXNpbmcgdGhlIFtgdG9ET01gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMudG9ET00pXG4gICAgcHJvcGVydGllcyBpbiBhIHNjaGVtYSdzIG5vZGUgYW5kIG1hcmsgc3BlY3MuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5jYWNoZWQuZG9tU2VyaWFsaXplciB8fFxuICAgICAgICAgICAgKHNjaGVtYS5jYWNoZWQuZG9tU2VyaWFsaXplciA9IG5ldyBET01TZXJpYWxpemVyKHRoaXMubm9kZXNGcm9tU2NoZW1hKHNjaGVtYSksIHRoaXMubWFya3NGcm9tU2NoZW1hKHNjaGVtYSkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2F0aGVyIHRoZSBzZXJpYWxpemVycyBpbiBhIHNjaGVtYSdzIG5vZGUgc3BlY3MgaW50byBhbiBvYmplY3QuXG4gICAgVGhpcyBjYW4gYmUgdXNlZnVsIGFzIGEgYmFzZSB0byBidWlsZCBhIGN1c3RvbSBzZXJpYWxpemVyIGZyb20uXG4gICAgKi9cbiAgICBzdGF0aWMgbm9kZXNGcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gZ2F0aGVyVG9ET00oc2NoZW1hLm5vZGVzKTtcbiAgICAgICAgaWYgKCFyZXN1bHQudGV4dClcbiAgICAgICAgICAgIHJlc3VsdC50ZXh0ID0gbm9kZSA9PiBub2RlLnRleHQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdhdGhlciB0aGUgc2VyaWFsaXplcnMgaW4gYSBzY2hlbWEncyBtYXJrIHNwZWNzIGludG8gYW4gb2JqZWN0LlxuICAgICovXG4gICAgc3RhdGljIG1hcmtzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIGdhdGhlclRvRE9NKHNjaGVtYS5tYXJrcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2F0aGVyVG9ET00ob2JqKSB7XG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IG5hbWUgaW4gb2JqKSB7XG4gICAgICAgIGxldCB0b0RPTSA9IG9ialtuYW1lXS5zcGVjLnRvRE9NO1xuICAgICAgICBpZiAodG9ET00pXG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSB0b0RPTTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGRvYyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZG9jdW1lbnQgfHwgd2luZG93LmRvY3VtZW50O1xufVxuXG5leHBvcnQgeyBDb250ZW50TWF0Y2gsIERPTVBhcnNlciwgRE9NU2VyaWFsaXplciwgRnJhZ21lbnQsIE1hcmssIE1hcmtUeXBlLCBOb2RlLCBOb2RlUmFuZ2UsIE5vZGVUeXBlLCBSZXBsYWNlRXJyb3IsIFJlc29sdmVkUG9zLCBTY2hlbWEsIFNsaWNlIH07XG4iLCAiaW1wb3J0IHsgUmVwbGFjZUVycm9yLCBTbGljZSwgRnJhZ21lbnQsIE1hcmtUeXBlLCBNYXJrIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuXG4vLyBSZWNvdmVyeSB2YWx1ZXMgZW5jb2RlIGEgcmFuZ2UgaW5kZXggYW5kIGFuIG9mZnNldC4gVGhleSBhcmVcbi8vIHJlcHJlc2VudGVkIGFzIG51bWJlcnMsIGJlY2F1c2UgdG9ucyBvZiB0aGVtIHdpbGwgYmUgY3JlYXRlZCB3aGVuXG4vLyBtYXBwaW5nLCBmb3IgZXhhbXBsZSwgYSBsYXJnZSBudW1iZXIgb2YgZGVjb3JhdGlvbnMuIFRoZSBudW1iZXInc1xuLy8gbG93ZXIgMTYgYml0cyBwcm92aWRlIHRoZSBpbmRleCwgdGhlIHJlbWFpbmluZyBiaXRzIHRoZSBvZmZzZXQuXG4vL1xuLy8gTm90ZTogV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYml0IHNoaWZ0IG9wZXJhdG9ycyB0byBlbi0gYW5kXG4vLyBkZWNvZGUgdGhlc2UsIHNpbmNlIHRob3NlIGNsaXAgdG8gMzIgYml0cywgd2hpY2ggd2UgbWlnaHQgaW4gcmFyZVxuLy8gY2FzZXMgd2FudCB0byBvdmVyZmxvdy4gQSA2NC1iaXQgZmxvYXQgY2FuIHJlcHJlc2VudCA0OC1iaXRcbi8vIGludGVnZXJzIHByZWNpc2VseS5cbmNvbnN0IGxvd2VyMTYgPSAweGZmZmY7XG5jb25zdCBmYWN0b3IxNiA9IE1hdGgucG93KDIsIDE2KTtcbmZ1bmN0aW9uIG1ha2VSZWNvdmVyKGluZGV4LCBvZmZzZXQpIHsgcmV0dXJuIGluZGV4ICsgb2Zmc2V0ICogZmFjdG9yMTY7IH1cbmZ1bmN0aW9uIHJlY292ZXJJbmRleCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgJiBsb3dlcjE2OyB9XG5mdW5jdGlvbiByZWNvdmVyT2Zmc2V0KHZhbHVlKSB7IHJldHVybiAodmFsdWUgLSAodmFsdWUgJiBsb3dlcjE2KSkgLyBmYWN0b3IxNjsgfVxuY29uc3QgREVMX0JFRk9SRSA9IDEsIERFTF9BRlRFUiA9IDIsIERFTF9BQ1JPU1MgPSA0LCBERUxfU0lERSA9IDg7XG4vKipcbkFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBtYXBwZWQgcG9zaXRpb24gd2l0aCBleHRyYVxuaW5mb3JtYXRpb24uXG4qL1xuY2xhc3MgTWFwUmVzdWx0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBtYXBwZWQgdmVyc2lvbiBvZiB0aGUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZGVsSW5mbywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWNvdmVyKSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmRlbEluZm8gPSBkZWxJbmZvO1xuICAgICAgICB0aGlzLnJlY292ZXIgPSByZWNvdmVyO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGUgcG9zaXRpb24gd2FzIGRlbGV0ZWQsIHRoYXQgaXMsIHdoZXRoZXIgdGhlXG4gICAgc3RlcCByZW1vdmVkIHRoZSB0b2tlbiBvbiB0aGUgc2lkZSBxdWVyaWVkICh2aWEgdGhlIGBhc3NvY2ApXG4gICAgYXJndW1lbnQgZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZGVsZXRlZCgpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiBERUxfU0lERSkgPiAwOyB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIHRva2VuIGJlZm9yZSB0aGUgbWFwcGVkIHBvc2l0aW9uIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRCZWZvcmUoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgKERFTF9CRUZPUkUgfCBERUxfQUNST1NTKSkgPiAwOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoZSB0b2tlbiBhZnRlciB0aGUgbWFwcGVkIHBvc2l0aW9uIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRBZnRlcigpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiAoREVMX0FGVEVSIHwgREVMX0FDUk9TUykpID4gMDsgfVxuICAgIC8qKlxuICAgIFRlbGxzIHdoZXRoZXIgYW55IG9mIHRoZSBzdGVwcyBtYXBwZWQgdGhyb3VnaCBkZWxldGVzIGFjcm9zcyB0aGVcbiAgICBwb3NpdGlvbiAoaW5jbHVkaW5nIGJvdGggdGhlIHRva2VuIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlXG4gICAgcG9zaXRpb24pLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRBY3Jvc3MoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgREVMX0FDUk9TUykgPiAwOyB9XG59XG4vKipcbkEgbWFwIGRlc2NyaWJpbmcgdGhlIGRlbGV0aW9ucyBhbmQgaW5zZXJ0aW9ucyBtYWRlIGJ5IGEgc3RlcCwgd2hpY2hcbmNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlIGNvcnJlc3BvbmRlbmNlIGJldHdlZW4gcG9zaXRpb25zIGluIHRoZVxucHJlLXN0ZXAgdmVyc2lvbiBvZiBhIGRvY3VtZW50IGFuZCB0aGUgc2FtZSBwb3NpdGlvbiBpbiB0aGVcbnBvc3Qtc3RlcCB2ZXJzaW9uLlxuKi9cbmNsYXNzIFN0ZXBNYXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBvc2l0aW9uIG1hcC4gVGhlIG1vZGlmaWNhdGlvbnMgdG8gdGhlIGRvY3VtZW50IGFyZVxuICAgIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIG51bWJlcnMsIGluIHdoaWNoIGVhY2ggZ3JvdXAgb2YgdGhyZWVcbiAgICByZXByZXNlbnRzIGEgbW9kaWZpZWQgY2h1bmsgYXMgYFtzdGFydCwgb2xkU2l6ZSwgbmV3U2l6ZV1gLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByYW5nZXMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW52ZXJ0ZWQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5pbnZlcnRlZCA9IGludmVydGVkO1xuICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGggJiYgU3RlcE1hcC5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlY292ZXIodmFsdWUpIHtcbiAgICAgICAgbGV0IGRpZmYgPSAwLCBpbmRleCA9IHJlY292ZXJJbmRleCh2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5pbnZlcnRlZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICBkaWZmICs9IHRoaXMucmFuZ2VzW2kgKiAzICsgMl0gLSB0aGlzLnJhbmdlc1tpICogMyArIDFdO1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXNbaW5kZXggKiAzXSArIGRpZmYgKyByZWNvdmVyT2Zmc2V0KHZhbHVlKTtcbiAgICB9XG4gICAgbWFwUmVzdWx0KHBvcywgYXNzb2MgPSAxKSB7IHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgZmFsc2UpOyB9XG4gICAgbWFwKHBvcywgYXNzb2MgPSAxKSB7IHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIF9tYXAocG9zLCBhc3NvYywgc2ltcGxlKSB7XG4gICAgICAgIGxldCBkaWZmID0gMCwgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsIG5ld0luZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDEgOiAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1tpXSAtICh0aGlzLmludmVydGVkID8gZGlmZiA6IDApO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IG9sZFNpemUgPSB0aGlzLnJhbmdlc1tpICsgb2xkSW5kZXhdLCBuZXdTaXplID0gdGhpcy5yYW5nZXNbaSArIG5ld0luZGV4XSwgZW5kID0gc3RhcnQgKyBvbGRTaXplO1xuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2lkZSA9ICFvbGRTaXplID8gYXNzb2MgOiBwb3MgPT0gc3RhcnQgPyAtMSA6IHBvcyA9PSBlbmQgPyAxIDogYXNzb2M7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHN0YXJ0ICsgZGlmZiArIChzaWRlIDwgMCA/IDAgOiBuZXdTaXplKTtcbiAgICAgICAgICAgICAgICBpZiAoc2ltcGxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGxldCByZWNvdmVyID0gcG9zID09IChhc3NvYyA8IDAgPyBzdGFydCA6IGVuZCkgPyBudWxsIDogbWFrZVJlY292ZXIoaSAvIDMsIHBvcyAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBsZXQgZGVsID0gcG9zID09IHN0YXJ0ID8gREVMX0FGVEVSIDogcG9zID09IGVuZCA/IERFTF9CRUZPUkUgOiBERUxfQUNST1NTO1xuICAgICAgICAgICAgICAgIGlmIChhc3NvYyA8IDAgPyBwb3MgIT0gc3RhcnQgOiBwb3MgIT0gZW5kKVxuICAgICAgICAgICAgICAgICAgICBkZWwgfD0gREVMX1NJREU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXBSZXN1bHQocmVzdWx0LCBkZWwsIHJlY292ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlmZiArPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2ltcGxlID8gcG9zICsgZGlmZiA6IG5ldyBNYXBSZXN1bHQocG9zICsgZGlmZiwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG91Y2hlcyhwb3MsIHJlY292ZXIpIHtcbiAgICAgICAgbGV0IGRpZmYgPSAwLCBpbmRleCA9IHJlY292ZXJJbmRleChyZWNvdmVyKTtcbiAgICAgICAgbGV0IG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0gLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgZW5kID0gc3RhcnQgKyBvbGRTaXplO1xuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQgJiYgaSA9PSBpbmRleCAqIDMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkaWZmICs9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF0gLSBvbGRTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbHMgdGhlIGdpdmVuIGZ1bmN0aW9uIG9uIGVhY2ggb2YgdGhlIGNoYW5nZWQgcmFuZ2VzIGluY2x1ZGVkIGluXG4gICAgdGhpcyBtYXAuXG4gICAgKi9cbiAgICBmb3JFYWNoKGYpIHtcbiAgICAgICAgbGV0IG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGRpZmYgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzW2ldLCBvbGRTdGFydCA9IHN0YXJ0IC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCksIG5ld1N0YXJ0ID0gc3RhcnQgKyAodGhpcy5pbnZlcnRlZCA/IDAgOiBkaWZmKTtcbiAgICAgICAgICAgIGxldCBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgbmV3U2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF07XG4gICAgICAgICAgICBmKG9sZFN0YXJ0LCBvbGRTdGFydCArIG9sZFNpemUsIG5ld1N0YXJ0LCBuZXdTdGFydCArIG5ld1NpemUpO1xuICAgICAgICAgICAgZGlmZiArPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW52ZXJ0ZWQgdmVyc2lvbiBvZiB0aGlzIG1hcC4gVGhlIHJlc3VsdCBjYW4gYmUgdXNlZCB0b1xuICAgIG1hcCBwb3NpdGlvbnMgaW4gdGhlIHBvc3Qtc3RlcCBkb2N1bWVudCB0byB0aGUgcHJlLXN0ZXAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RlcE1hcCh0aGlzLnJhbmdlcywgIXRoaXMuaW52ZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW52ZXJ0ZWQgPyBcIi1cIiA6IFwiXCIpICsgSlNPTi5zdHJpbmdpZnkodGhpcy5yYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXAgdGhhdCBtb3ZlcyBhbGwgcG9zaXRpb25zIGJ5IG9mZnNldCBgbmAgKHdoaWNoIG1heSBiZVxuICAgIG5lZ2F0aXZlKS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gYXBwbHlpbmcgc3RlcHMgbWVhbnQgZm9yIGFcbiAgICBzdWItZG9jdW1lbnQgdG8gYSBsYXJnZXIgZG9jdW1lbnQsIG9yIHZpY2UtdmVyc2EuXG4gICAgKi9cbiAgICBzdGF0aWMgb2Zmc2V0KG4pIHtcbiAgICAgICAgcmV0dXJuIG4gPT0gMCA/IFN0ZXBNYXAuZW1wdHkgOiBuZXcgU3RlcE1hcChuIDwgMCA/IFswLCAtbiwgMF0gOiBbMCwgMCwgbl0pO1xuICAgIH1cbn1cbi8qKlxuQSBTdGVwTWFwIHRoYXQgY29udGFpbnMgbm8gY2hhbmdlZCByYW5nZXMuXG4qL1xuU3RlcE1hcC5lbXB0eSA9IG5ldyBTdGVwTWFwKFtdKTtcbi8qKlxuQSBtYXBwaW5nIHJlcHJlc2VudHMgYSBwaXBlbGluZSBvZiB6ZXJvIG9yIG1vcmUgW3N0ZXBcbm1hcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcE1hcCkuIEl0IGhhcyBzcGVjaWFsIHByb3Zpc2lvbnMgZm9yIGxvc3NsZXNzbHlcbmhhbmRsaW5nIG1hcHBpbmcgcG9zaXRpb25zIHRocm91Z2ggYSBzZXJpZXMgb2Ygc3RlcHMgaW4gd2hpY2ggc29tZVxuc3RlcHMgYXJlIGludmVydGVkIHZlcnNpb25zIG9mIGVhcmxpZXIgc3RlcHMuIChUaGlzIGNvbWVzIHVwIHdoZW5cblx1MjAxOFtyZWJhc2luZ10oL2RvY3MvZ3VpZGUvI3RyYW5zZm9ybS5yZWJhc2luZylcdTIwMTkgc3RlcHMgZm9yXG5jb2xsYWJvcmF0aW9uIG9yIGhpc3RvcnkgbWFuYWdlbWVudC4pXG4qL1xuY2xhc3MgTWFwcGluZyB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IG1hcHBpbmcgd2l0aCB0aGUgZ2l2ZW4gcG9zaXRpb24gbWFwcy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGVwIG1hcHMgaW4gdGhpcyBtYXBwaW5nLlxuICAgICovXG4gICAgbWFwcyA9IFtdLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1pcnJvciwgXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGluIHRoZSBgbWFwc2AgYXJyYXksIHVzZWQgd2hlbiBgbWFwYCBvclxuICAgIGBtYXBSZXN1bHRgIGlzIGNhbGxlZC5cbiAgICAqL1xuICAgIGZyb20gPSAwLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uIGluIHRoZSBgbWFwc2AgYXJyYXkuXG4gICAgKi9cbiAgICB0byA9IG1hcHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubWFwcyA9IG1hcHM7XG4gICAgICAgIHRoaXMubWlycm9yID0gbWlycm9yO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcHBpbmcgdGhhdCBtYXBzIG9ubHkgdGhyb3VnaCBhIHBhcnQgb2YgdGhpcyBvbmUuXG4gICAgKi9cbiAgICBzbGljZShmcm9tID0gMCwgdG8gPSB0aGlzLm1hcHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwcGluZyh0aGlzLm1hcHMsIHRoaXMubWlycm9yLCBmcm9tLCB0byk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXBwaW5nKHRoaXMubWFwcy5zbGljZSgpLCB0aGlzLm1pcnJvciAmJiB0aGlzLm1pcnJvci5zbGljZSgpLCB0aGlzLmZyb20sIHRoaXMudG8pO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSBzdGVwIG1hcCB0byB0aGUgZW5kIG9mIHRoaXMgbWFwcGluZy4gSWYgYG1pcnJvcnNgIGlzXG4gICAgZ2l2ZW4sIGl0IHNob3VsZCBiZSB0aGUgaW5kZXggb2YgdGhlIHN0ZXAgbWFwIHRoYXQgaXMgdGhlIG1pcnJvclxuICAgIGltYWdlIG9mIHRoaXMgb25lLlxuICAgICovXG4gICAgYXBwZW5kTWFwKG1hcCwgbWlycm9ycykge1xuICAgICAgICB0aGlzLnRvID0gdGhpcy5tYXBzLnB1c2gobWFwKTtcbiAgICAgICAgaWYgKG1pcnJvcnMgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuc2V0TWlycm9yKHRoaXMubWFwcy5sZW5ndGggLSAxLCBtaXJyb3JzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGFsbCB0aGUgc3RlcCBtYXBzIGluIGEgZ2l2ZW4gbWFwcGluZyB0byB0aGlzIG9uZSAocHJlc2VydmluZ1xuICAgIG1pcnJvcmluZyBpbmZvcm1hdGlvbikuXG4gICAgKi9cbiAgICBhcHBlbmRNYXBwaW5nKG1hcHBpbmcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHN0YXJ0U2l6ZSA9IHRoaXMubWFwcy5sZW5ndGg7IGkgPCBtYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtaXJyID0gbWFwcGluZy5nZXRNaXJyb3IoaSk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZE1hcChtYXBwaW5nLm1hcHNbaV0sIG1pcnIgIT0gbnVsbCAmJiBtaXJyIDwgaSA/IHN0YXJ0U2l6ZSArIG1pcnIgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmRzIHRoZSBvZmZzZXQgb2YgdGhlIHN0ZXAgbWFwIHRoYXQgbWlycm9ycyB0aGUgbWFwIGF0IHRoZVxuICAgIGdpdmVuIG9mZnNldCwgaW4gdGhpcyBtYXBwaW5nIChhcyBwZXIgdGhlIHNlY29uZCBhcmd1bWVudCB0b1xuICAgIGBhcHBlbmRNYXBgKS5cbiAgICAqL1xuICAgIGdldE1pcnJvcihuKSB7XG4gICAgICAgIGlmICh0aGlzLm1pcnJvcilcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5taXJyb3IubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yW2ldID09IG4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1pcnJvcltpICsgKGkgJSAyID8gLTEgOiAxKV07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2V0TWlycm9yKG4sIG0pIHtcbiAgICAgICAgaWYgKCF0aGlzLm1pcnJvcilcbiAgICAgICAgICAgIHRoaXMubWlycm9yID0gW107XG4gICAgICAgIHRoaXMubWlycm9yLnB1c2gobiwgbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGVuZCB0aGUgaW52ZXJzZSBvZiB0aGUgZ2l2ZW4gbWFwcGluZyB0byB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZE1hcHBpbmdJbnZlcnRlZChtYXBwaW5nKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBtYXBwaW5nLm1hcHMubGVuZ3RoIC0gMSwgdG90YWxTaXplID0gdGhpcy5tYXBzLmxlbmd0aCArIG1hcHBpbmcubWFwcy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgbWlyciA9IG1hcHBpbmcuZ2V0TWlycm9yKGkpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRNYXAobWFwcGluZy5tYXBzW2ldLmludmVydCgpLCBtaXJyICE9IG51bGwgJiYgbWlyciA+IGkgPyB0b3RhbFNpemUgLSBtaXJyIC0gMSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGludmVydGVkIHZlcnNpb24gb2YgdGhpcyBtYXBwaW5nLlxuICAgICovXG4gICAgaW52ZXJ0KCkge1xuICAgICAgICBsZXQgaW52ZXJzZSA9IG5ldyBNYXBwaW5nO1xuICAgICAgICBpbnZlcnNlLmFwcGVuZE1hcHBpbmdJbnZlcnRlZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGludmVyc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhIHBvc2l0aW9uIHRocm91Z2ggdGhpcyBtYXBwaW5nLlxuICAgICovXG4gICAgbWFwKHBvcywgYXNzb2MgPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLm1pcnJvcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgdHJ1ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZyb207IGkgPCB0aGlzLnRvOyBpKyspXG4gICAgICAgICAgICBwb3MgPSB0aGlzLm1hcHNbaV0ubWFwKHBvcywgYXNzb2MpO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYSBwb3NpdGlvbiB0aHJvdWdoIHRoaXMgbWFwcGluZywgcmV0dXJuaW5nIGEgbWFwcGluZ1xuICAgIHJlc3VsdC5cbiAgICAqL1xuICAgIG1hcFJlc3VsdChwb3MsIGFzc29jID0gMSkgeyByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIGZhbHNlKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgX21hcChwb3MsIGFzc29jLCBzaW1wbGUpIHtcbiAgICAgICAgbGV0IGRlbEluZm8gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcm9tOyBpIDwgdGhpcy50bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwID0gdGhpcy5tYXBzW2ldLCByZXN1bHQgPSBtYXAubWFwUmVzdWx0KHBvcywgYXNzb2MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29yciA9IHRoaXMuZ2V0TWlycm9yKGkpO1xuICAgICAgICAgICAgICAgIGlmIChjb3JyICE9IG51bGwgJiYgY29yciA+IGkgJiYgY29yciA8IHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGNvcnI7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMubWFwc1tjb3JyXS5yZWNvdmVyKHJlc3VsdC5yZWNvdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsSW5mbyB8PSByZXN1bHQuZGVsSW5mbztcbiAgICAgICAgICAgIHBvcyA9IHJlc3VsdC5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbXBsZSA/IHBvcyA6IG5ldyBNYXBSZXN1bHQocG9zLCBkZWxJbmZvLCBudWxsKTtcbiAgICB9XG59XG5cbmNvbnN0IHN0ZXBzQnlJRCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcbkEgc3RlcCBvYmplY3QgcmVwcmVzZW50cyBhbiBhdG9taWMgY2hhbmdlLiBJdCBnZW5lcmFsbHkgYXBwbGllc1xub25seSB0byB0aGUgZG9jdW1lbnQgaXQgd2FzIGNyZWF0ZWQgZm9yLCBzaW5jZSB0aGUgcG9zaXRpb25zXG5zdG9yZWQgaW4gaXQgd2lsbCBvbmx5IG1ha2Ugc2Vuc2UgZm9yIHRoYXQgZG9jdW1lbnQuXG5cbk5ldyBzdGVwcyBhcmUgZGVmaW5lZCBieSBjcmVhdGluZyBjbGFzc2VzIHRoYXQgZXh0ZW5kIGBTdGVwYCxcbm92ZXJyaWRpbmcgdGhlIGBhcHBseWAsIGBpbnZlcnRgLCBgbWFwYCwgYGdldE1hcGAgYW5kIGBmcm9tSlNPTmBcbm1ldGhvZHMsIGFuZCByZWdpc3RlcmluZyB5b3VyIGNsYXNzIHdpdGggYSB1bmlxdWVcbkpTT04tc2VyaWFsaXphdGlvbiBpZGVudGlmaWVyIHVzaW5nXG5bYFN0ZXAuanNvbklEYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwXmpzb25JRCkuXG4qL1xuY2xhc3MgU3RlcCB7XG4gICAgLyoqXG4gICAgR2V0IHRoZSBzdGVwIG1hcCB0aGF0IHJlcHJlc2VudHMgdGhlIGNoYW5nZXMgbWFkZSBieSB0aGlzIHN0ZXAsXG4gICAgYW5kIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHRyYW5zZm9ybSBiZXR3ZWVuIHBvc2l0aW9ucyBpbiB0aGUgb2xkXG4gICAgYW5kIHRoZSBuZXcgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXRNYXAoKSB7IHJldHVybiBTdGVwTWFwLmVtcHR5OyB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIG1lcmdlIHRoaXMgc3RlcCB3aXRoIGFub3RoZXIgb25lLCB0byBiZSBhcHBsaWVkIGRpcmVjdGx5XG4gICAgYWZ0ZXIgaXQuIFJldHVybnMgdGhlIG1lcmdlZCBzdGVwIHdoZW4gcG9zc2libGUsIG51bGwgaWYgdGhlXG4gICAgc3RlcHMgY2FuJ3QgYmUgbWVyZ2VkLlxuICAgICovXG4gICAgbWVyZ2Uob3RoZXIpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIHN0ZXAgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gV2lsbCBjYWxsXG4gICAgdGhyb3VnaCB0byB0aGUgc3RlcCBjbGFzcycgb3duIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIWpzb24uc3RlcFR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIGxldCB0eXBlID0gc3RlcHNCeUlEW2pzb24uc3RlcFR5cGVdO1xuICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gc3RlcCB0eXBlICR7anNvbi5zdGVwVHlwZX0gZGVmaW5lZGApO1xuICAgICAgICByZXR1cm4gdHlwZS5mcm9tSlNPTihzY2hlbWEsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBUbyBiZSBhYmxlIHRvIHNlcmlhbGl6ZSBzdGVwcyB0byBKU09OLCBlYWNoIHN0ZXAgbmVlZHMgYSBzdHJpbmdcbiAgICBJRCB0byBhdHRhY2ggdG8gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFVzZSB0aGlzIG1ldGhvZCB0b1xuICAgIHJlZ2lzdGVyIGFuIElEIGZvciB5b3VyIHN0ZXAgY2xhc3Nlcy4gVHJ5IHRvIHBpY2sgc29tZXRoaW5nXG4gICAgdGhhdCdzIHVubGlrZWx5IHRvIGNsYXNoIHdpdGggc3RlcHMgZnJvbSBvdGhlciBtb2R1bGVzLlxuICAgICovXG4gICAgc3RhdGljIGpzb25JRChpZCwgc3RlcENsYXNzKSB7XG4gICAgICAgIGlmIChpZCBpbiBzdGVwc0J5SUQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkR1cGxpY2F0ZSB1c2Ugb2Ygc3RlcCBKU09OIElEIFwiICsgaWQpO1xuICAgICAgICBzdGVwc0J5SURbaWRdID0gc3RlcENsYXNzO1xuICAgICAgICBzdGVwQ2xhc3MucHJvdG90eXBlLmpzb25JRCA9IGlkO1xuICAgICAgICByZXR1cm4gc3RlcENsYXNzO1xuICAgIH1cbn1cbi8qKlxuVGhlIHJlc3VsdCBvZiBbYXBwbHlpbmddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcC5hcHBseSkgYSBzdGVwLiBDb250YWlucyBlaXRoZXIgYVxubmV3IGRvY3VtZW50IG9yIGEgZmFpbHVyZSB2YWx1ZS5cbiovXG5jbGFzcyBTdGVwUmVzdWx0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0cmFuc2Zvcm1lZCBkb2N1bWVudCwgaWYgc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIGRvYywgXG4gICAgLyoqXG4gICAgVGhlIGZhaWx1cmUgbWVzc2FnZSwgaWYgdW5zdWNjZXNzZnVsLlxuICAgICovXG4gICAgZmFpbGVkKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLmZhaWxlZCA9IGZhaWxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc3VjY2Vzc2Z1bCBzdGVwIHJlc3VsdC5cbiAgICAqL1xuICAgIHN0YXRpYyBvayhkb2MpIHsgcmV0dXJuIG5ldyBTdGVwUmVzdWx0KGRvYywgbnVsbCk7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmYWlsZWQgc3RlcCByZXN1bHQuXG4gICAgKi9cbiAgICBzdGF0aWMgZmFpbChtZXNzYWdlKSB7IHJldHVybiBuZXcgU3RlcFJlc3VsdChudWxsLCBtZXNzYWdlKTsgfVxuICAgIC8qKlxuICAgIENhbGwgW2BOb2RlLnJlcGxhY2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS5yZXBsYWNlKSB3aXRoIHRoZSBnaXZlblxuICAgIGFyZ3VtZW50cy4gQ3JlYXRlIGEgc3VjY2Vzc2Z1bCByZXN1bHQgaWYgaXQgc3VjY2VlZHMsIGFuZCBhXG4gICAgZmFpbGVkIG9uZSBpZiBpdCB0aHJvd3MgYSBgUmVwbGFjZUVycm9yYC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tUmVwbGFjZShkb2MsIGZyb20sIHRvLCBzbGljZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQub2soZG9jLnJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmVwbGFjZUVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1hcEZyYWdtZW50KGZyYWdtZW50LCBmLCBwYXJlbnQpIHtcbiAgICBsZXQgbWFwcGVkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFnbWVudC5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gZnJhZ21lbnQuY2hpbGQoaSk7XG4gICAgICAgIGlmIChjaGlsZC5jb250ZW50LnNpemUpXG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmNvcHkobWFwRnJhZ21lbnQoY2hpbGQuY29udGVudCwgZiwgY2hpbGQpKTtcbiAgICAgICAgaWYgKGNoaWxkLmlzSW5saW5lKVxuICAgICAgICAgICAgY2hpbGQgPSBmKGNoaWxkLCBwYXJlbnQsIGkpO1xuICAgICAgICBtYXBwZWQucHVzaChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBGcmFnbWVudC5mcm9tQXJyYXkobWFwcGVkKTtcbn1cbi8qKlxuQWRkIGEgbWFyayB0byBhbGwgaW5saW5lIGNvbnRlbnQgYmV0d2VlbiB0d28gcG9zaXRpb25zLlxuKi9cbmNsYXNzIEFkZE1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBtYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSBtYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gYWRkLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgb2xkU2xpY2UgPSBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKSwgJGZyb20gPSBkb2MucmVzb2x2ZSh0aGlzLmZyb20pO1xuICAgICAgICBsZXQgcGFyZW50ID0gJGZyb20ubm9kZSgkZnJvbS5zaGFyZWREZXB0aCh0aGlzLnRvKSk7XG4gICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShtYXBGcmFnbWVudChvbGRTbGljZS5jb250ZW50LCAobm9kZSwgcGFyZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIW5vZGUuaXNBdG9tIHx8ICFwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZSh0aGlzLm1hcmsudHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5tYXJrKHRoaXMubWFyay5hZGRUb1NldChub2RlLm1hcmtzKSk7XG4gICAgICAgIH0sIHBhcmVudCksIG9sZFNsaWNlLm9wZW5TdGFydCwgb2xkU2xpY2Uub3BlbkVuZCk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBzbGljZSk7XG4gICAgfVxuICAgIGludmVydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcCh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQgJiYgdG8uZGVsZXRlZCB8fCBmcm9tLnBvcyA+PSB0by5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChmcm9tLnBvcywgdG8ucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBBZGRNYXJrU3RlcCAmJlxuICAgICAgICAgICAgb3RoZXIubWFyay5lcSh0aGlzLm1hcmspICYmXG4gICAgICAgICAgICB0aGlzLmZyb20gPD0gb3RoZXIudG8gJiYgdGhpcy50byA+PSBvdGhlci5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChNYXRoLm1pbih0aGlzLmZyb20sIG90aGVyLmZyb20pLCBNYXRoLm1heCh0aGlzLnRvLCBvdGhlci50byksIHRoaXMubWFyayk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImFkZE1hcmtcIiwgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpLFxuICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBBZGRNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChqc29uLmZyb20sIGpzb24udG8sIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJhZGRNYXJrXCIsIEFkZE1hcmtTdGVwKTtcbi8qKlxuUmVtb3ZlIGEgbWFyayBmcm9tIGFsbCBpbmxpbmUgY29udGVudCBiZXR3ZWVuIHR3byBwb3NpdGlvbnMuXG4qL1xuY2xhc3MgUmVtb3ZlTWFya1N0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrLXJlbW92aW5nIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgdGhlIHVubWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgdW5tYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gcmVtb3ZlLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgb2xkU2xpY2UgPSBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKG1hcEZyYWdtZW50KG9sZFNsaWNlLmNvbnRlbnQsIG5vZGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubWFyayh0aGlzLm1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSk7XG4gICAgICAgIH0sIGRvYyksIG9sZFNsaWNlLm9wZW5TdGFydCwgb2xkU2xpY2Uub3BlbkVuZCk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBzbGljZSk7XG4gICAgfVxuICAgIGludmVydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcCh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQgJiYgdG8uZGVsZXRlZCB8fCBmcm9tLnBvcyA+PSB0by5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChmcm9tLnBvcywgdG8ucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBSZW1vdmVNYXJrU3RlcCAmJlxuICAgICAgICAgICAgb3RoZXIubWFyay5lcSh0aGlzLm1hcmspICYmXG4gICAgICAgICAgICB0aGlzLmZyb20gPD0gb3RoZXIudG8gJiYgdGhpcy50byA+PSBvdGhlci5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChNYXRoLm1pbih0aGlzLmZyb20sIG90aGVyLmZyb20pLCBNYXRoLm1heCh0aGlzLnRvLCBvdGhlci50byksIHRoaXMubWFyayk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcInJlbW92ZU1hcmtcIiwgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpLFxuICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZW1vdmVNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChqc29uLmZyb20sIGpzb24udG8sIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZW1vdmVNYXJrXCIsIFJlbW92ZU1hcmtTdGVwKTtcbi8qKlxuQWRkIGEgbWFyayB0byBhIHNwZWNpZmljIG5vZGUuXG4qL1xuY2xhc3MgQWRkTm9kZU1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBtYXJrIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBub2RlLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayB0byBhZGQuXG4gICAgKi9cbiAgICBtYXJrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgbWFyayBzdGVwJ3MgcG9zaXRpb25cIik7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbm9kZS50eXBlLmNyZWF0ZShub2RlLmF0dHJzLCBudWxsLCB0aGlzLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMucG9zLCB0aGlzLnBvcyArIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLCAwLCBub2RlLmlzTGVhZiA/IDAgOiAxKSk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIGxldCBuZXdTZXQgPSB0aGlzLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcyk7XG4gICAgICAgICAgICBpZiAobmV3U2V0Lmxlbmd0aCA9PSBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5tYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLm1hcmtzW2ldLmlzSW5TZXQobmV3U2V0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKHRoaXMucG9zLCBub2RlLm1hcmtzW2ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcCh0aGlzLnBvcywgdGhpcy5tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU5vZGVNYXJrU3RlcCh0aGlzLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMucG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIHBvcy5kZWxldGVkQWZ0ZXIgPyBudWxsIDogbmV3IEFkZE5vZGVNYXJrU3RlcChwb3MucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImFkZE5vZGVNYXJrXCIsIHBvczogdGhpcy5wb3MsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBBZGROb2RlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKGpzb24ucG9zLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiYWRkTm9kZU1hcmtcIiwgQWRkTm9kZU1hcmtTdGVwKTtcbi8qKlxuUmVtb3ZlIGEgbWFyayBmcm9tIGEgc3BlY2lmaWMgbm9kZS5cbiovXG5jbGFzcyBSZW1vdmVOb2RlTWFya1N0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrLXJlbW92aW5nIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBub2RlLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayB0byByZW1vdmUuXG4gICAgKi9cbiAgICBtYXJrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgbWFyayBzdGVwJ3MgcG9zaXRpb25cIik7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbm9kZS50eXBlLmNyZWF0ZShub2RlLmF0dHJzLCBudWxsLCB0aGlzLm1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5wb3MsIHRoaXMucG9zICsgMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odXBkYXRlZCksIDAsIG5vZGUuaXNMZWFmID8gMCA6IDEpKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoIW5vZGUgfHwgIXRoaXMubWFyay5pc0luU2V0KG5vZGUubWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKHRoaXMucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgcG9zID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5wb3MsIDEpO1xuICAgICAgICByZXR1cm4gcG9zLmRlbGV0ZWRBZnRlciA/IG51bGwgOiBuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKHBvcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwicmVtb3ZlTm9kZU1hcmtcIiwgcG9zOiB0aGlzLnBvcywgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24ucG9zICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlbW92ZU5vZGVNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAoanNvbi5wb3MsIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZW1vdmVOb2RlTWFya1wiLCBSZW1vdmVOb2RlTWFya1N0ZXApO1xuXG4vKipcblJlcGxhY2UgYSBwYXJ0IG9mIHRoZSBkb2N1bWVudCB3aXRoIGEgc2xpY2Ugb2YgbmV3IGNvbnRlbnQuXG4qL1xuY2xhc3MgUmVwbGFjZVN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBUaGUgZ2l2ZW4gYHNsaWNlYCBzaG91bGQgZml0IHRoZSAnZ2FwJyBiZXR3ZWVuIGBmcm9tYCBhbmRcbiAgICBgdG9gXHUyMDE0dGhlIGRlcHRocyBtdXN0IGxpbmUgdXAsIGFuZCB0aGUgc3Vycm91bmRpbmcgbm9kZXMgbXVzdCBiZVxuICAgIGFibGUgdG8gYmUgam9pbmVkIHdpdGggdGhlIG9wZW4gc2lkZXMgb2YgdGhlIHNsaWNlLiBXaGVuXG4gICAgYHN0cnVjdHVyZWAgaXMgdHJ1ZSwgdGhlIHN0ZXAgd2lsbCBmYWlsIGlmIHRoZSBjb250ZW50IGJldHdlZW5cbiAgICBmcm9tIGFuZCB0byBpcyBub3QganVzdCBhIHNlcXVlbmNlIG9mIGNsb3NpbmcgYW5kIHRoZW4gb3BlbmluZ1xuICAgIHRva2VucyAodGhpcyBpcyB0byBndWFyZCBhZ2FpbnN0IHJlYmFzZWQgcmVwbGFjZSBzdGVwc1xuICAgIG92ZXJ3cml0aW5nIHNvbWV0aGluZyB0aGV5IHdlcmVuJ3Qgc3VwcG9zZWQgdG8pLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBzbGljZSB0byBpbnNlcnQuXG4gICAgKi9cbiAgICBzbGljZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdHJ1Y3R1cmUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuc2xpY2UgPSBzbGljZTtcbiAgICAgICAgdGhpcy5zdHJ1Y3R1cmUgPSBzdHJ1Y3R1cmU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUgJiYgY29udGVudEJldHdlZW4oZG9jLCB0aGlzLmZyb20sIHRoaXMudG8pKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIlN0cnVjdHVyZSByZXBsYWNlIHdvdWxkIG92ZXJ3cml0ZSBjb250ZW50XCIpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5zbGljZSk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGVwTWFwKFt0aGlzLmZyb20sIHRoaXMudG8gLSB0aGlzLmZyb20sIHRoaXMuc2xpY2Uuc2l6ZV0pO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAodGhpcy5mcm9tLCB0aGlzLmZyb20gKyB0aGlzLnNsaWNlLnNpemUsIGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICAgICAgaWYgKGZyb20uZGVsZXRlZEFjcm9zcyAmJiB0by5kZWxldGVkQWNyb3NzKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoZnJvbS5wb3MsIE1hdGgubWF4KGZyb20ucG9zLCB0by5wb3MpLCB0aGlzLnNsaWNlKTtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCkgfHwgb3RoZXIuc3RydWN0dXJlIHx8IHRoaXMuc3RydWN0dXJlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0aGlzLmZyb20gKyB0aGlzLnNsaWNlLnNpemUgPT0gb3RoZXIuZnJvbSAmJiAhdGhpcy5zbGljZS5vcGVuRW5kICYmICFvdGhlci5zbGljZS5vcGVuU3RhcnQpIHtcbiAgICAgICAgICAgIGxldCBzbGljZSA9IHRoaXMuc2xpY2Uuc2l6ZSArIG90aGVyLnNsaWNlLnNpemUgPT0gMCA/IFNsaWNlLmVtcHR5XG4gICAgICAgICAgICAgICAgOiBuZXcgU2xpY2UodGhpcy5zbGljZS5jb250ZW50LmFwcGVuZChvdGhlci5zbGljZS5jb250ZW50KSwgdGhpcy5zbGljZS5vcGVuU3RhcnQsIG90aGVyLnNsaWNlLm9wZW5FbmQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcCh0aGlzLmZyb20sIHRoaXMudG8gKyAob3RoZXIudG8gLSBvdGhlci5mcm9tKSwgc2xpY2UsIHRoaXMuc3RydWN0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlci50byA9PSB0aGlzLmZyb20gJiYgIXRoaXMuc2xpY2Uub3BlblN0YXJ0ICYmICFvdGhlci5zbGljZS5vcGVuRW5kKSB7XG4gICAgICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLnNsaWNlLnNpemUgKyBvdGhlci5zbGljZS5zaXplID09IDAgPyBTbGljZS5lbXB0eVxuICAgICAgICAgICAgICAgIDogbmV3IFNsaWNlKG90aGVyLnNsaWNlLmNvbnRlbnQuYXBwZW5kKHRoaXMuc2xpY2UuY29udGVudCksIG90aGVyLnNsaWNlLm9wZW5TdGFydCwgdGhpcy5zbGljZS5vcGVuRW5kKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAob3RoZXIuZnJvbSwgdGhpcy50bywgc2xpY2UsIHRoaXMuc3RydWN0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGpzb24gPSB7IHN0ZXBUeXBlOiBcInJlcGxhY2VcIiwgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byB9O1xuICAgICAgICBpZiAodGhpcy5zbGljZS5zaXplKVxuICAgICAgICAgICAganNvbi5zbGljZSA9IHRoaXMuc2xpY2UudG9KU09OKCk7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSlcbiAgICAgICAgICAgIGpzb24uc3RydWN0dXJlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlcGxhY2VTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGpzb24uZnJvbSwganNvbi50bywgU2xpY2UuZnJvbUpTT04oc2NoZW1hLCBqc29uLnNsaWNlKSwgISFqc29uLnN0cnVjdHVyZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZXBsYWNlXCIsIFJlcGxhY2VTdGVwKTtcbi8qKlxuUmVwbGFjZSBhIHBhcnQgb2YgdGhlIGRvY3VtZW50IHdpdGggYSBzbGljZSBvZiBjb250ZW50LCBidXRcbnByZXNlcnZlIGEgcmFuZ2Ugb2YgdGhlIHJlcGxhY2VkIGNvbnRlbnQgYnkgbW92aW5nIGl0IGludG8gdGhlXG5zbGljZS5cbiovXG5jbGFzcyBSZXBsYWNlQXJvdW5kU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJlcGxhY2UtYXJvdW5kIHN0ZXAgd2l0aCB0aGUgZ2l2ZW4gcmFuZ2UgYW5kIGdhcC5cbiAgICBgaW5zZXJ0YCBzaG91bGQgYmUgdGhlIHBvaW50IGluIHRoZSBzbGljZSBpbnRvIHdoaWNoIHRoZSBjb250ZW50XG4gICAgb2YgdGhlIGdhcCBzaG91bGQgYmUgbW92ZWQuIGBzdHJ1Y3R1cmVgIGhhcyB0aGUgc2FtZSBtZWFuaW5nIGFzXG4gICAgaXQgaGFzIGluIHRoZSBbYFJlcGxhY2VTdGVwYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5SZXBsYWNlU3RlcCkgY2xhc3MuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHByZXNlcnZlZCByYW5nZS5cbiAgICAqL1xuICAgIGdhcEZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgcHJlc2VydmVkIHJhbmdlLlxuICAgICovXG4gICAgZ2FwVG8sIFxuICAgIC8qKlxuICAgIFRoZSBzbGljZSB0byBpbnNlcnQuXG4gICAgKi9cbiAgICBzbGljZSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGluIHRoZSBzbGljZSB3aGVyZSB0aGUgcHJlc2VydmVkIHJhbmdlIHNob3VsZCBiZVxuICAgIGluc2VydGVkLlxuICAgICovXG4gICAgaW5zZXJ0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0cnVjdHVyZSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5nYXBGcm9tID0gZ2FwRnJvbTtcbiAgICAgICAgdGhpcy5nYXBUbyA9IGdhcFRvO1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgICAgICB0aGlzLnN0cnVjdHVyZSA9IHN0cnVjdHVyZTtcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSAmJiAoY29udGVudEJldHdlZW4oZG9jLCB0aGlzLmZyb20sIHRoaXMuZ2FwRnJvbSkgfHxcbiAgICAgICAgICAgIGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5nYXBUbywgdGhpcy50bykpKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIlN0cnVjdHVyZSBnYXAtcmVwbGFjZSB3b3VsZCBvdmVyd3JpdGUgY29udGVudFwiKTtcbiAgICAgICAgbGV0IGdhcCA9IGRvYy5zbGljZSh0aGlzLmdhcEZyb20sIHRoaXMuZ2FwVG8pO1xuICAgICAgICBpZiAoZ2FwLm9wZW5TdGFydCB8fCBnYXAub3BlbkVuZClcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJHYXAgaXMgbm90IGEgZmxhdCByYW5nZVwiKTtcbiAgICAgICAgbGV0IGluc2VydGVkID0gdGhpcy5zbGljZS5pbnNlcnRBdCh0aGlzLmluc2VydCwgZ2FwLmNvbnRlbnQpO1xuICAgICAgICBpZiAoIWluc2VydGVkKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIkNvbnRlbnQgZG9lcyBub3QgZml0IGluIGdhcFwiKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIGluc2VydGVkKTtcbiAgICB9XG4gICAgZ2V0TWFwKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0ZXBNYXAoW3RoaXMuZnJvbSwgdGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLmluc2VydCxcbiAgICAgICAgICAgIHRoaXMuZ2FwVG8sIHRoaXMudG8gLSB0aGlzLmdhcFRvLCB0aGlzLnNsaWNlLnNpemUgLSB0aGlzLmluc2VydF0pO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBnYXAgPSB0aGlzLmdhcFRvIC0gdGhpcy5nYXBGcm9tO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKHRoaXMuZnJvbSwgdGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplICsgZ2FwLCB0aGlzLmZyb20gKyB0aGlzLmluc2VydCwgdGhpcy5mcm9tICsgdGhpcy5pbnNlcnQgKyBnYXAsIGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pLnJlbW92ZUJldHdlZW4odGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLmdhcFRvIC0gdGhpcy5mcm9tKSwgdGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGxldCBnYXBGcm9tID0gbWFwcGluZy5tYXAodGhpcy5nYXBGcm9tLCAtMSksIGdhcFRvID0gbWFwcGluZy5tYXAodGhpcy5nYXBUbywgMSk7XG4gICAgICAgIGlmICgoZnJvbS5kZWxldGVkQWNyb3NzICYmIHRvLmRlbGV0ZWRBY3Jvc3MpIHx8IGdhcEZyb20gPCBmcm9tLnBvcyB8fCBnYXBUbyA+IHRvLnBvcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKGZyb20ucG9zLCB0by5wb3MsIGdhcEZyb20sIGdhcFRvLCB0aGlzLnNsaWNlLCB0aGlzLmluc2VydCwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBqc29uID0geyBzdGVwVHlwZTogXCJyZXBsYWNlQXJvdW5kXCIsIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8sXG4gICAgICAgICAgICBnYXBGcm9tOiB0aGlzLmdhcEZyb20sIGdhcFRvOiB0aGlzLmdhcFRvLCBpbnNlcnQ6IHRoaXMuaW5zZXJ0IH07XG4gICAgICAgIGlmICh0aGlzLnNsaWNlLnNpemUpXG4gICAgICAgICAgICBqc29uLnNsaWNlID0gdGhpcy5zbGljZS50b0pTT04oKTtcbiAgICAgICAgaWYgKHRoaXMuc3RydWN0dXJlKVxuICAgICAgICAgICAganNvbi5zdHJ1Y3R1cmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAgICAgdHlwZW9mIGpzb24uZ2FwRnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmdhcFRvICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaW5zZXJ0ICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlcGxhY2VBcm91bmRTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKGpzb24uZnJvbSwganNvbi50bywganNvbi5nYXBGcm9tLCBqc29uLmdhcFRvLCBTbGljZS5mcm9tSlNPTihzY2hlbWEsIGpzb24uc2xpY2UpLCBqc29uLmluc2VydCwgISFqc29uLnN0cnVjdHVyZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZXBsYWNlQXJvdW5kXCIsIFJlcGxhY2VBcm91bmRTdGVwKTtcbmZ1bmN0aW9uIGNvbnRlbnRCZXR3ZWVuKGRvYywgZnJvbSwgdG8pIHtcbiAgICBsZXQgJGZyb20gPSBkb2MucmVzb2x2ZShmcm9tKSwgZGlzdCA9IHRvIC0gZnJvbSwgZGVwdGggPSAkZnJvbS5kZXB0aDtcbiAgICB3aGlsZSAoZGlzdCA+IDAgJiYgZGVwdGggPiAwICYmICRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpID09ICRmcm9tLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpIHtcbiAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgZGlzdC0tO1xuICAgIH1cbiAgICBpZiAoZGlzdCA+IDApIHtcbiAgICAgICAgbGV0IG5leHQgPSAkZnJvbS5ub2RlKGRlcHRoKS5tYXliZUNoaWxkKCRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpKTtcbiAgICAgICAgd2hpbGUgKGRpc3QgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dC5pc0xlYWYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dC5maXJzdENoaWxkO1xuICAgICAgICAgICAgZGlzdC0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkTWFyayh0ciwgZnJvbSwgdG8sIG1hcmspIHtcbiAgICBsZXQgcmVtb3ZlZCA9IFtdLCBhZGRlZCA9IFtdO1xuICAgIGxldCByZW1vdmluZywgYWRkaW5nO1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MsIHBhcmVudCkgPT4ge1xuICAgICAgICBpZiAoIW5vZGUuaXNJbmxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBtYXJrcyA9IG5vZGUubWFya3M7XG4gICAgICAgIGlmICghbWFyay5pc0luU2V0KG1hcmtzKSAmJiBwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZShtYXJrLnR5cGUpKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLCBlbmQgPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICBsZXQgbmV3U2V0ID0gbWFyay5hZGRUb1NldChtYXJrcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXJrc1tpXS5pc0luU2V0KG5ld1NldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92aW5nICYmIHJlbW92aW5nLnRvID09IHN0YXJ0ICYmIHJlbW92aW5nLm1hcmsuZXEobWFya3NbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZpbmcudG8gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaChyZW1vdmluZyA9IG5ldyBSZW1vdmVNYXJrU3RlcChzdGFydCwgZW5kLCBtYXJrc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZGRpbmcgJiYgYWRkaW5nLnRvID09IHN0YXJ0KVxuICAgICAgICAgICAgICAgIGFkZGluZy50byA9IGVuZDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhZGRlZC5wdXNoKGFkZGluZyA9IG5ldyBBZGRNYXJrU3RlcChzdGFydCwgZW5kLCBtYXJrKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZW1vdmVkLmZvckVhY2gocyA9PiB0ci5zdGVwKHMpKTtcbiAgICBhZGRlZC5mb3JFYWNoKHMgPT4gdHIuc3RlcChzKSk7XG59XG5mdW5jdGlvbiByZW1vdmVNYXJrKHRyLCBmcm9tLCB0bywgbWFyaykge1xuICAgIGxldCBtYXRjaGVkID0gW10sIHN0ZXAgPSAwO1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKCFub2RlLmlzSW5saW5lKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdGVwKys7XG4gICAgICAgIGxldCB0b1JlbW92ZSA9IG51bGw7XG4gICAgICAgIGlmIChtYXJrIGluc3RhbmNlb2YgTWFya1R5cGUpIHtcbiAgICAgICAgICAgIGxldCBzZXQgPSBub2RlLm1hcmtzLCBmb3VuZDtcbiAgICAgICAgICAgIHdoaWxlIChmb3VuZCA9IG1hcmsuaXNJblNldChzZXQpKSB7XG4gICAgICAgICAgICAgICAgKHRvUmVtb3ZlIHx8ICh0b1JlbW92ZSA9IFtdKSkucHVzaChmb3VuZCk7XG4gICAgICAgICAgICAgICAgc2V0ID0gZm91bmQucmVtb3ZlRnJvbVNldChzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hcmspIHtcbiAgICAgICAgICAgIGlmIChtYXJrLmlzSW5TZXQobm9kZS5tYXJrcykpXG4gICAgICAgICAgICAgICAgdG9SZW1vdmUgPSBbbWFya107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b1JlbW92ZSA9IG5vZGUubWFya3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvUmVtb3ZlICYmIHRvUmVtb3ZlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9SZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSB0b1JlbW92ZVtpXSwgZm91bmQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaGVkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtID0gbWF0Y2hlZFtqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0uc3RlcCA9PSBzdGVwIC0gMSAmJiBzdHlsZS5lcShtYXRjaGVkW2pdLnN0eWxlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kLnRvID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZC5zdGVwID0gc3RlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaCh7IHN0eWxlLCBmcm9tOiBNYXRoLm1heChwb3MsIGZyb20pLCB0bzogZW5kLCBzdGVwIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG1hdGNoZWQuZm9yRWFjaChtID0+IHRyLnN0ZXAobmV3IFJlbW92ZU1hcmtTdGVwKG0uZnJvbSwgbS50bywgbS5zdHlsZSkpKTtcbn1cbmZ1bmN0aW9uIGNsZWFySW5jb21wYXRpYmxlKHRyLCBwb3MsIHBhcmVudFR5cGUsIG1hdGNoID0gcGFyZW50VHlwZS5jb250ZW50TWF0Y2gpIHtcbiAgICBsZXQgbm9kZSA9IHRyLmRvYy5ub2RlQXQocG9zKTtcbiAgICBsZXQgcmVwbFN0ZXBzID0gW10sIGN1ciA9IHBvcyArIDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBub2RlLmNoaWxkKGkpLCBlbmQgPSBjdXIgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgbGV0IGFsbG93ZWQgPSBtYXRjaC5tYXRjaFR5cGUoY2hpbGQudHlwZSk7XG4gICAgICAgIGlmICghYWxsb3dlZCkge1xuICAgICAgICAgICAgcmVwbFN0ZXBzLnB1c2gobmV3IFJlcGxhY2VTdGVwKGN1ciwgZW5kLCBTbGljZS5lbXB0eSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2ggPSBhbGxvd2VkO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZC5tYXJrcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFR5cGUuYWxsb3dzTWFya1R5cGUoY2hpbGQubWFya3Nbal0udHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIHRyLnN0ZXAobmV3IFJlbW92ZU1hcmtTdGVwKGN1ciwgZW5kLCBjaGlsZC5tYXJrc1tqXSkpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmlzVGV4dCAmJiAhcGFyZW50VHlwZS5zcGVjLmNvZGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgbSwgbmV3bGluZSA9IC9cXHI/XFxufFxcci9nLCBzbGljZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobSA9IG5ld2xpbmUuZXhlYyhjaGlsZC50ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNsaWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2UgPSBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShwYXJlbnRUeXBlLnNjaGVtYS50ZXh0KFwiIFwiLCBwYXJlbnRUeXBlLmFsbG93ZWRNYXJrcyhjaGlsZC5tYXJrcykpKSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxTdGVwcy5wdXNoKG5ldyBSZXBsYWNlU3RlcChjdXIgKyBtLmluZGV4LCBjdXIgKyBtLmluZGV4ICsgbVswXS5sZW5ndGgsIHNsaWNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1ciA9IGVuZDtcbiAgICB9XG4gICAgaWYgKCFtYXRjaC52YWxpZEVuZCkge1xuICAgICAgICBsZXQgZmlsbCA9IG1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgICAgICB0ci5yZXBsYWNlKGN1ciwgY3VyLCBuZXcgU2xpY2UoZmlsbCwgMCwgMCkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gcmVwbFN0ZXBzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICB0ci5zdGVwKHJlcGxTdGVwc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNhbkN1dChub2RlLCBzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChzdGFydCA9PSAwIHx8IG5vZGUuY2FuUmVwbGFjZShzdGFydCwgbm9kZS5jaGlsZENvdW50KSkgJiZcbiAgICAgICAgKGVuZCA9PSBub2RlLmNoaWxkQ291bnQgfHwgbm9kZS5jYW5SZXBsYWNlKDAsIGVuZCkpO1xufVxuLyoqXG5UcnkgdG8gZmluZCBhIHRhcmdldCBkZXB0aCB0byB3aGljaCB0aGUgY29udGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2VcbmNhbiBiZSBsaWZ0ZWQuIFdpbGwgbm90IGdvIGFjcm9zc1xuW2lzb2xhdGluZ10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmlzb2xhdGluZykgcGFyZW50IG5vZGVzLlxuKi9cbmZ1bmN0aW9uIGxpZnRUYXJnZXQocmFuZ2UpIHtcbiAgICBsZXQgcGFyZW50ID0gcmFuZ2UucGFyZW50O1xuICAgIGxldCBjb250ZW50ID0gcGFyZW50LmNvbnRlbnQuY3V0QnlJbmRleChyYW5nZS5zdGFydEluZGV4LCByYW5nZS5lbmRJbmRleCk7XG4gICAgZm9yIChsZXQgZGVwdGggPSByYW5nZS5kZXB0aDs7IC0tZGVwdGgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSByYW5nZS4kZnJvbS5ub2RlKGRlcHRoKTtcbiAgICAgICAgbGV0IGluZGV4ID0gcmFuZ2UuJGZyb20uaW5kZXgoZGVwdGgpLCBlbmRJbmRleCA9IHJhbmdlLiR0by5pbmRleEFmdGVyKGRlcHRoKTtcbiAgICAgICAgaWYgKGRlcHRoIDwgcmFuZ2UuZGVwdGggJiYgbm9kZS5jYW5SZXBsYWNlKGluZGV4LCBlbmRJbmRleCwgY29udGVudCkpXG4gICAgICAgICAgICByZXR1cm4gZGVwdGg7XG4gICAgICAgIGlmIChkZXB0aCA9PSAwIHx8IG5vZGUudHlwZS5zcGVjLmlzb2xhdGluZyB8fCAhY2FuQ3V0KG5vZGUsIGluZGV4LCBlbmRJbmRleCkpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBsaWZ0KHRyLCByYW5nZSwgdGFyZ2V0KSB7XG4gICAgbGV0IHsgJGZyb20sICR0bywgZGVwdGggfSA9IHJhbmdlO1xuICAgIGxldCBnYXBTdGFydCA9ICRmcm9tLmJlZm9yZShkZXB0aCArIDEpLCBnYXBFbmQgPSAkdG8uYWZ0ZXIoZGVwdGggKyAxKTtcbiAgICBsZXQgc3RhcnQgPSBnYXBTdGFydCwgZW5kID0gZ2FwRW5kO1xuICAgIGxldCBiZWZvcmUgPSBGcmFnbWVudC5lbXB0eSwgb3BlblN0YXJ0ID0gMDtcbiAgICBmb3IgKGxldCBkID0gZGVwdGgsIHNwbGl0dGluZyA9IGZhbHNlOyBkID4gdGFyZ2V0OyBkLS0pXG4gICAgICAgIGlmIChzcGxpdHRpbmcgfHwgJGZyb20uaW5kZXgoZCkgPiAwKSB7XG4gICAgICAgICAgICBzcGxpdHRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYmVmb3JlID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGQpLmNvcHkoYmVmb3JlKSk7XG4gICAgICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgIH1cbiAgICBsZXQgYWZ0ZXIgPSBGcmFnbWVudC5lbXB0eSwgb3BlbkVuZCA9IDA7XG4gICAgZm9yIChsZXQgZCA9IGRlcHRoLCBzcGxpdHRpbmcgPSBmYWxzZTsgZCA+IHRhcmdldDsgZC0tKVxuICAgICAgICBpZiAoc3BsaXR0aW5nIHx8ICR0by5hZnRlcihkICsgMSkgPCAkdG8uZW5kKGQpKSB7XG4gICAgICAgICAgICBzcGxpdHRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYWZ0ZXIgPSBGcmFnbWVudC5mcm9tKCR0by5ub2RlKGQpLmNvcHkoYWZ0ZXIpKTtcbiAgICAgICAgICAgIG9wZW5FbmQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICB9XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQsIGVuZCwgZ2FwU3RhcnQsIGdhcEVuZCwgbmV3IFNsaWNlKGJlZm9yZS5hcHBlbmQoYWZ0ZXIpLCBvcGVuU3RhcnQsIG9wZW5FbmQpLCBiZWZvcmUuc2l6ZSAtIG9wZW5TdGFydCwgdHJ1ZSkpO1xufVxuLyoqXG5UcnkgdG8gZmluZCBhIHZhbGlkIHdheSB0byB3cmFwIHRoZSBjb250ZW50IGluIHRoZSBnaXZlbiByYW5nZSBpbiBhXG5ub2RlIG9mIHRoZSBnaXZlbiB0eXBlLiBNYXkgaW50cm9kdWNlIGV4dHJhIG5vZGVzIGFyb3VuZCBhbmQgaW5zaWRlXG50aGUgd3JhcHBlciBub2RlLCBpZiBuZWNlc3NhcnkuIFJldHVybnMgbnVsbCBpZiBubyB2YWxpZCB3cmFwcGluZ1xuY291bGQgYmUgZm91bmQuIFdoZW4gYGlubmVyUmFuZ2VgIGlzIGdpdmVuLCB0aGF0IHJhbmdlJ3MgY29udGVudCBpc1xudXNlZCBhcyB0aGUgY29udGVudCB0byBmaXQgaW50byB0aGUgd3JhcHBpbmcsIGluc3RlYWQgb2YgdGhlXG5jb250ZW50IG9mIGByYW5nZWAuXG4qL1xuZnVuY3Rpb24gZmluZFdyYXBwaW5nKHJhbmdlLCBub2RlVHlwZSwgYXR0cnMgPSBudWxsLCBpbm5lclJhbmdlID0gcmFuZ2UpIHtcbiAgICBsZXQgYXJvdW5kID0gZmluZFdyYXBwaW5nT3V0c2lkZShyYW5nZSwgbm9kZVR5cGUpO1xuICAgIGxldCBpbm5lciA9IGFyb3VuZCAmJiBmaW5kV3JhcHBpbmdJbnNpZGUoaW5uZXJSYW5nZSwgbm9kZVR5cGUpO1xuICAgIGlmICghaW5uZXIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBhcm91bmQubWFwKHdpdGhBdHRycylcbiAgICAgICAgLmNvbmNhdCh7IHR5cGU6IG5vZGVUeXBlLCBhdHRycyB9KS5jb25jYXQoaW5uZXIubWFwKHdpdGhBdHRycykpO1xufVxuZnVuY3Rpb24gd2l0aEF0dHJzKHR5cGUpIHsgcmV0dXJuIHsgdHlwZSwgYXR0cnM6IG51bGwgfTsgfVxuZnVuY3Rpb24gZmluZFdyYXBwaW5nT3V0c2lkZShyYW5nZSwgdHlwZSkge1xuICAgIGxldCB7IHBhcmVudCwgc3RhcnRJbmRleCwgZW5kSW5kZXggfSA9IHJhbmdlO1xuICAgIGxldCBhcm91bmQgPSBwYXJlbnQuY29udGVudE1hdGNoQXQoc3RhcnRJbmRleCkuZmluZFdyYXBwaW5nKHR5cGUpO1xuICAgIGlmICghYXJvdW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgb3V0ZXIgPSBhcm91bmQubGVuZ3RoID8gYXJvdW5kWzBdIDogdHlwZTtcbiAgICByZXR1cm4gcGFyZW50LmNhblJlcGxhY2VXaXRoKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBvdXRlcikgPyBhcm91bmQgOiBudWxsO1xufVxuZnVuY3Rpb24gZmluZFdyYXBwaW5nSW5zaWRlKHJhbmdlLCB0eXBlKSB7XG4gICAgbGV0IHsgcGFyZW50LCBzdGFydEluZGV4LCBlbmRJbmRleCB9ID0gcmFuZ2U7XG4gICAgbGV0IGlubmVyID0gcGFyZW50LmNoaWxkKHN0YXJ0SW5kZXgpO1xuICAgIGxldCBpbnNpZGUgPSB0eXBlLmNvbnRlbnRNYXRjaC5maW5kV3JhcHBpbmcoaW5uZXIudHlwZSk7XG4gICAgaWYgKCFpbnNpZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBsYXN0VHlwZSA9IGluc2lkZS5sZW5ndGggPyBpbnNpZGVbaW5zaWRlLmxlbmd0aCAtIDFdIDogdHlwZTtcbiAgICBsZXQgaW5uZXJNYXRjaCA9IGxhc3RUeXBlLmNvbnRlbnRNYXRjaDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaW5uZXJNYXRjaCAmJiBpIDwgZW5kSW5kZXg7IGkrKylcbiAgICAgICAgaW5uZXJNYXRjaCA9IGlubmVyTWF0Y2gubWF0Y2hUeXBlKHBhcmVudC5jaGlsZChpKS50eXBlKTtcbiAgICBpZiAoIWlubmVyTWF0Y2ggfHwgIWlubmVyTWF0Y2gudmFsaWRFbmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBpbnNpZGU7XG59XG5mdW5jdGlvbiB3cmFwKHRyLCByYW5nZSwgd3JhcHBlcnMpIHtcbiAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGZvciAobGV0IGkgPSB3cmFwcGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB3cmFwcGVyc1tpXS50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCB8fCAhbWF0Y2gudmFsaWRFbmQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJXcmFwcGVyIHR5cGUgZ2l2ZW4gdG8gVHJhbnNmb3JtLndyYXAgZG9lcyBub3QgZm9ybSB2YWxpZCBjb250ZW50IG9mIGl0cyBwYXJlbnQgd3JhcHBlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh3cmFwcGVyc1tpXS50eXBlLmNyZWF0ZSh3cmFwcGVyc1tpXS5hdHRycywgY29udGVudCkpO1xuICAgIH1cbiAgICBsZXQgc3RhcnQgPSByYW5nZS5zdGFydCwgZW5kID0gcmFuZ2UuZW5kO1xuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0LCBlbmQsIHN0YXJ0LCBlbmQsIG5ldyBTbGljZShjb250ZW50LCAwLCAwKSwgd3JhcHBlcnMubGVuZ3RoLCB0cnVlKSk7XG59XG5mdW5jdGlvbiBzZXRCbG9ja1R5cGUodHIsIGZyb20sIHRvLCB0eXBlLCBhdHRycykge1xuICAgIGlmICghdHlwZS5pc1RleHRibG9jaylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUeXBlIGdpdmVuIHRvIHNldEJsb2NrVHlwZSBzaG91bGQgYmUgYSB0ZXh0YmxvY2tcIik7XG4gICAgbGV0IG1hcEZyb20gPSB0ci5zdGVwcy5sZW5ndGg7XG4gICAgdHIuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBpZiAobm9kZS5pc1RleHRibG9jayAmJiAhbm9kZS5oYXNNYXJrdXAodHlwZSwgYXR0cnMpICYmIGNhbkNoYW5nZVR5cGUodHIuZG9jLCB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MpLCB0eXBlKSkge1xuICAgICAgICAgICAgLy8gRW5zdXJlIGFsbCBtYXJrdXAgdGhhdCBpc24ndCBhbGxvd2VkIGluIHRoZSBuZXcgbm9kZSB0eXBlIGlzIGNsZWFyZWRcbiAgICAgICAgICAgIHRyLmNsZWFySW5jb21wYXRpYmxlKHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcywgMSksIHR5cGUpO1xuICAgICAgICAgICAgbGV0IG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgICAgICAgICAgbGV0IHN0YXJ0TSA9IG1hcHBpbmcubWFwKHBvcywgMSksIGVuZE0gPSBtYXBwaW5nLm1hcChwb3MgKyBub2RlLm5vZGVTaXplLCAxKTtcbiAgICAgICAgICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0TSwgZW5kTSwgc3RhcnRNICsgMSwgZW5kTSAtIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBub2RlLm1hcmtzKSksIDAsIDApLCAxLCB0cnVlKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNhbkNoYW5nZVR5cGUoZG9jLCBwb3MsIHR5cGUpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyksIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICAgIHJldHVybiAkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXggKyAxLCB0eXBlKTtcbn1cbi8qKlxuQ2hhbmdlIHRoZSB0eXBlLCBhdHRyaWJ1dGVzLCBhbmQvb3IgbWFya3Mgb2YgdGhlIG5vZGUgYXQgYHBvc2AuXG5XaGVuIGB0eXBlYCBpc24ndCBnaXZlbiwgdGhlIGV4aXN0aW5nIG5vZGUgdHlwZSBpcyBwcmVzZXJ2ZWQsXG4qL1xuZnVuY3Rpb24gc2V0Tm9kZU1hcmt1cCh0ciwgcG9zLCB0eXBlLCBhdHRycywgbWFya3MpIHtcbiAgICBsZXQgbm9kZSA9IHRyLmRvYy5ub2RlQXQocG9zKTtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gbm9kZSBhdCBnaXZlbiBwb3NpdGlvblwiKTtcbiAgICBpZiAoIXR5cGUpXG4gICAgICAgIHR5cGUgPSBub2RlLnR5cGU7XG4gICAgbGV0IG5ld05vZGUgPSB0eXBlLmNyZWF0ZShhdHRycywgbnVsbCwgbWFya3MgfHwgbm9kZS5tYXJrcyk7XG4gICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICByZXR1cm4gdHIucmVwbGFjZVdpdGgocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCBuZXdOb2RlKTtcbiAgICBpZiAoIXR5cGUudmFsaWRDb250ZW50KG5vZGUuY29udGVudCkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBjb250ZW50IGZvciBub2RlIHR5cGUgXCIgKyB0eXBlLm5hbWUpO1xuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwgcG9zICsgMSwgcG9zICsgbm9kZS5ub2RlU2l6ZSAtIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5ld05vZGUpLCAwLCAwKSwgMSwgdHJ1ZSkpO1xufVxuLyoqXG5DaGVjayB3aGV0aGVyIHNwbGl0dGluZyBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgYWxsb3dlZC5cbiovXG5mdW5jdGlvbiBjYW5TcGxpdChkb2MsIHBvcywgZGVwdGggPSAxLCB0eXBlc0FmdGVyKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLCBiYXNlID0gJHBvcy5kZXB0aCAtIGRlcHRoO1xuICAgIGxldCBpbm5lclR5cGUgPSAodHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW3R5cGVzQWZ0ZXIubGVuZ3RoIC0gMV0pIHx8ICRwb3MucGFyZW50O1xuICAgIGlmIChiYXNlIDwgMCB8fCAkcG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nIHx8XG4gICAgICAgICEkcG9zLnBhcmVudC5jYW5SZXBsYWNlKCRwb3MuaW5kZXgoKSwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudCkgfHxcbiAgICAgICAgIWlubmVyVHlwZS50eXBlLnZhbGlkQ29udGVudCgkcG9zLnBhcmVudC5jb250ZW50LmN1dEJ5SW5kZXgoJHBvcy5pbmRleCgpLCAkcG9zLnBhcmVudC5jaGlsZENvdW50KSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCAtIDEsIGkgPSBkZXB0aCAtIDI7IGQgPiBiYXNlOyBkLS0sIGktLSkge1xuICAgICAgICBsZXQgbm9kZSA9ICRwb3Mubm9kZShkKSwgaW5kZXggPSAkcG9zLmluZGV4KGQpO1xuICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgcmVzdCA9IG5vZGUuY29udGVudC5jdXRCeUluZGV4KGluZGV4LCBub2RlLmNoaWxkQ291bnQpO1xuICAgICAgICBsZXQgb3ZlcnJpZGVDaGlsZCA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlcltpICsgMV07XG4gICAgICAgIGlmIChvdmVycmlkZUNoaWxkKVxuICAgICAgICAgICAgcmVzdCA9IHJlc3QucmVwbGFjZUNoaWxkKDAsIG92ZXJyaWRlQ2hpbGQudHlwZS5jcmVhdGUob3ZlcnJpZGVDaGlsZC5hdHRycykpO1xuICAgICAgICBsZXQgYWZ0ZXIgPSAodHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW2ldKSB8fCBub2RlO1xuICAgICAgICBpZiAoIW5vZGUuY2FuUmVwbGFjZShpbmRleCArIDEsIG5vZGUuY2hpbGRDb3VudCkgfHwgIWFmdGVyLnR5cGUudmFsaWRDb250ZW50KHJlc3QpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoYmFzZSk7XG4gICAgbGV0IGJhc2VUeXBlID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyWzBdO1xuICAgIHJldHVybiAkcG9zLm5vZGUoYmFzZSkuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBiYXNlVHlwZSA/IGJhc2VUeXBlLnR5cGUgOiAkcG9zLm5vZGUoYmFzZSArIDEpLnR5cGUpO1xufVxuZnVuY3Rpb24gc3BsaXQodHIsIHBvcywgZGVwdGggPSAxLCB0eXBlc0FmdGVyKSB7XG4gICAgbGV0ICRwb3MgPSB0ci5kb2MucmVzb2x2ZShwb3MpLCBiZWZvcmUgPSBGcmFnbWVudC5lbXB0eSwgYWZ0ZXIgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCwgZSA9ICRwb3MuZGVwdGggLSBkZXB0aCwgaSA9IGRlcHRoIC0gMTsgZCA+IGU7IGQtLSwgaS0tKSB7XG4gICAgICAgIGJlZm9yZSA9IEZyYWdtZW50LmZyb20oJHBvcy5ub2RlKGQpLmNvcHkoYmVmb3JlKSk7XG4gICAgICAgIGxldCB0eXBlQWZ0ZXIgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbaV07XG4gICAgICAgIGFmdGVyID0gRnJhZ21lbnQuZnJvbSh0eXBlQWZ0ZXIgPyB0eXBlQWZ0ZXIudHlwZS5jcmVhdGUodHlwZUFmdGVyLmF0dHJzLCBhZnRlcikgOiAkcG9zLm5vZGUoZCkuY29weShhZnRlcikpO1xuICAgIH1cbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlU3RlcChwb3MsIHBvcywgbmV3IFNsaWNlKGJlZm9yZS5hcHBlbmQoYWZ0ZXIpLCBkZXB0aCwgZGVwdGgpLCB0cnVlKSk7XG59XG4vKipcblRlc3Qgd2hldGhlciB0aGUgYmxvY2tzIGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBwb3NpdGlvbiBjYW4gYmVcbmpvaW5lZC5cbiovXG5mdW5jdGlvbiBjYW5Kb2luKGRvYywgcG9zKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICByZXR1cm4gam9pbmFibGUoJHBvcy5ub2RlQmVmb3JlLCAkcG9zLm5vZGVBZnRlcikgJiZcbiAgICAgICAgJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKTtcbn1cbmZ1bmN0aW9uIGpvaW5hYmxlKGEsIGIpIHtcbiAgICByZXR1cm4gISEoYSAmJiBiICYmICFhLmlzTGVhZiAmJiBhLmNhbkFwcGVuZChiKSk7XG59XG4vKipcbkZpbmQgYW4gYW5jZXN0b3Igb2YgdGhlIGdpdmVuIHBvc2l0aW9uIHRoYXQgY2FuIGJlIGpvaW5lZCB0byB0aGVcbmJsb2NrIGJlZm9yZSAob3IgYWZ0ZXIgaWYgYGRpcmAgaXMgcG9zaXRpdmUpLiBSZXR1cm5zIHRoZSBqb2luYWJsZVxucG9pbnQsIGlmIGFueS5cbiovXG5mdW5jdGlvbiBqb2luUG9pbnQoZG9jLCBwb3MsIGRpciA9IC0xKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOzsgZC0tKSB7XG4gICAgICAgIGxldCBiZWZvcmUsIGFmdGVyLCBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgICAgIGlmIChkID09ICRwb3MuZGVwdGgpIHtcbiAgICAgICAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZTtcbiAgICAgICAgICAgIGFmdGVyID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgYmVmb3JlID0gJHBvcy5ub2RlKGQgKyAxKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBhZnRlciA9ICRwb3Mubm9kZShkKS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZShkKS5tYXliZUNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgICAgICBhZnRlciA9ICRwb3Mubm9kZShkICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlZm9yZSAmJiAhYmVmb3JlLmlzVGV4dGJsb2NrICYmIGpvaW5hYmxlKGJlZm9yZSwgYWZ0ZXIpICYmXG4gICAgICAgICAgICAkcG9zLm5vZGUoZCkuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKSlcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIGlmIChkID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgcG9zID0gZGlyIDwgMCA/ICRwb3MuYmVmb3JlKGQpIDogJHBvcy5hZnRlcihkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBqb2luKHRyLCBwb3MsIGRlcHRoKSB7XG4gICAgbGV0IHN0ZXAgPSBuZXcgUmVwbGFjZVN0ZXAocG9zIC0gZGVwdGgsIHBvcyArIGRlcHRoLCBTbGljZS5lbXB0eSwgdHJ1ZSk7XG4gICAgdHIuc3RlcChzdGVwKTtcbn1cbi8qKlxuVHJ5IHRvIGZpbmQgYSBwb2ludCB3aGVyZSBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUgY2FuIGJlIGluc2VydGVkXG5uZWFyIGBwb3NgLCBieSBzZWFyY2hpbmcgdXAgdGhlIG5vZGUgaGllcmFyY2h5IHdoZW4gYHBvc2AgaXRzZWxmXG5pc24ndCBhIHZhbGlkIHBsYWNlIGJ1dCBpcyBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGEgbm9kZS4gUmV0dXJuXG5udWxsIGlmIG5vIHBvc2l0aW9uIHdhcyBmb3VuZC5cbiovXG5mdW5jdGlvbiBpbnNlcnRQb2ludChkb2MsIHBvcywgbm9kZVR5cGUpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKCRwb3MuaW5kZXgoKSwgJHBvcy5pbmRleCgpLCBub2RlVHlwZSkpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgaWYgKCRwb3MucGFyZW50T2Zmc2V0ID09IDApXG4gICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgICAgICAgICBpZiAoJHBvcy5ub2RlKGQpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgbm9kZVR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmJlZm9yZShkICsgMSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgaWYgKCRwb3MucGFyZW50T2Zmc2V0ID09ICRwb3MucGFyZW50LmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleEFmdGVyKGQpO1xuICAgICAgICAgICAgaWYgKCRwb3Mubm9kZShkKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIG5vZGVUeXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5hZnRlcihkICsgMSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAkcG9zLm5vZGUoZCkuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5GaW5kcyBhIHBvc2l0aW9uIGF0IG9yIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24gd2hlcmUgdGhlIGdpdmVuXG5zbGljZSBjYW4gYmUgaW5zZXJ0ZWQuIFdpbGwgbG9vayBhdCBwYXJlbnQgbm9kZXMnIG5lYXJlc3QgYm91bmRhcnlcbmFuZCB0cnkgdGhlcmUsIGV2ZW4gaWYgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIHdhc24ndCBkaXJlY3RseSBhdCB0aGVcbnN0YXJ0IG9yIGVuZCBvZiB0aGF0IG5vZGUuIFJldHVybnMgbnVsbCB3aGVuIG5vIHBvc2l0aW9uIHdhcyBmb3VuZC5cbiovXG5mdW5jdGlvbiBkcm9wUG9pbnQoZG9jLCBwb3MsIHNsaWNlKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmICghc2xpY2UuY29udGVudC5zaXplKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGxldCBjb250ZW50ID0gc2xpY2UuY29udGVudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWNlLm9wZW5TdGFydDsgaSsrKVxuICAgICAgICBjb250ZW50ID0gY29udGVudC5maXJzdENoaWxkLmNvbnRlbnQ7XG4gICAgZm9yIChsZXQgcGFzcyA9IDE7IHBhc3MgPD0gKHNsaWNlLm9wZW5TdGFydCA9PSAwICYmIHNsaWNlLnNpemUgPyAyIDogMSk7IHBhc3MrKykge1xuICAgICAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGxldCBiaWFzID0gZCA9PSAkcG9zLmRlcHRoID8gMCA6ICRwb3MucG9zIDw9ICgkcG9zLnN0YXJ0KGQgKyAxKSArICRwb3MuZW5kKGQgKyAxKSkgLyAyID8gLTEgOiAxO1xuICAgICAgICAgICAgbGV0IGluc2VydFBvcyA9ICRwb3MuaW5kZXgoZCkgKyAoYmlhcyA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gJHBvcy5ub2RlKGQpLCBmaXRzID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocGFzcyA9PSAxKSB7XG4gICAgICAgICAgICAgICAgZml0cyA9IHBhcmVudC5jYW5SZXBsYWNlKGluc2VydFBvcywgaW5zZXJ0UG9zLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB3cmFwcGluZyA9IHBhcmVudC5jb250ZW50TWF0Y2hBdChpbnNlcnRQb3MpLmZpbmRXcmFwcGluZyhjb250ZW50LmZpcnN0Q2hpbGQudHlwZSk7XG4gICAgICAgICAgICAgICAgZml0cyA9IHdyYXBwaW5nICYmIHBhcmVudC5jYW5SZXBsYWNlV2l0aChpbnNlcnRQb3MsIGluc2VydFBvcywgd3JhcHBpbmdbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpdHMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpYXMgPT0gMCA/ICRwb3MucG9zIDogYmlhcyA8IDAgPyAkcG9zLmJlZm9yZShkICsgMSkgOiAkcG9zLmFmdGVyKGQgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG5cdTIwMThGaXRcdTIwMTkgYSBzbGljZSBpbnRvIGEgZ2l2ZW4gcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LCBwcm9kdWNpbmcgYVxuW3N0ZXBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcCkgdGhhdCBpbnNlcnRzIGl0LiBXaWxsIHJldHVybiBudWxsIGlmXG50aGVyZSdzIG5vIG1lYW5pbmdmdWwgd2F5IHRvIGluc2VydCB0aGUgc2xpY2UgaGVyZSwgb3IgaW5zZXJ0aW5nIGl0XG53b3VsZCBiZSBhIG5vLW9wIChhbiBlbXB0eSBzbGljZSBvdmVyIGFuIGVtcHR5IHJhbmdlKS5cbiovXG5mdW5jdGlvbiByZXBsYWNlU3RlcChkb2MsIGZyb20sIHRvID0gZnJvbSwgc2xpY2UgPSBTbGljZS5lbXB0eSkge1xuICAgIGlmIChmcm9tID09IHRvICYmICFzbGljZS5zaXplKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgJGZyb20gPSBkb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gZG9jLnJlc29sdmUodG8pO1xuICAgIC8vIE9wdGltaXphdGlvbiAtLSBhdm9pZCB3b3JrIGlmIGl0J3Mgb2J2aW91cyB0aGF0IGl0J3Mgbm90IG5lZWRlZC5cbiAgICBpZiAoZml0c1RyaXZpYWxseSgkZnJvbSwgJHRvLCBzbGljZSkpXG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoZnJvbSwgdG8sIHNsaWNlKTtcbiAgICByZXR1cm4gbmV3IEZpdHRlcigkZnJvbSwgJHRvLCBzbGljZSkuZml0KCk7XG59XG5mdW5jdGlvbiBmaXRzVHJpdmlhbGx5KCRmcm9tLCAkdG8sIHNsaWNlKSB7XG4gICAgcmV0dXJuICFzbGljZS5vcGVuU3RhcnQgJiYgIXNsaWNlLm9wZW5FbmQgJiYgJGZyb20uc3RhcnQoKSA9PSAkdG8uc3RhcnQoKSAmJlxuICAgICAgICAkZnJvbS5wYXJlbnQuY2FuUmVwbGFjZSgkZnJvbS5pbmRleCgpLCAkdG8uaW5kZXgoKSwgc2xpY2UuY29udGVudCk7XG59XG4vLyBBbGdvcml0aG0gZm9yICdwbGFjaW5nJyB0aGUgZWxlbWVudHMgb2YgYSBzbGljZSBpbnRvIGEgZ2FwOlxuLy9cbi8vIFdlIGNvbnNpZGVyIHRoZSBjb250ZW50IG9mIGVhY2ggbm9kZSB0aGF0IGlzIG9wZW4gdG8gdGhlIGxlZnQgdG8gYmVcbi8vIGluZGVwZW5kZW50bHkgcGxhY2VhYmxlLiBJLmUuIGluIDxwKFwiZm9vXCIpLCBwKFwiYmFyXCIpPiwgd2hlbiB0aGVcbi8vIHBhcmFncmFwaCBvbiB0aGUgbGVmdCBpcyBvcGVuLCBcImZvb1wiIGNhbiBiZSBwbGFjZWQgKHNvbWV3aGVyZSBvblxuLy8gdGhlIGxlZnQgc2lkZSBvZiB0aGUgcmVwbGFjZW1lbnQgZ2FwKSBpbmRlcGVuZGVudGx5IGZyb20gcChcImJhclwiKS5cbi8vXG4vLyBUaGlzIGNsYXNzIHRyYWNrcyB0aGUgc3RhdGUgb2YgdGhlIHBsYWNlbWVudCBwcm9ncmVzcyBpbiB0aGVcbi8vIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuLy9cbi8vICAtIGBmcm9udGllcmAgaG9sZHMgYSBzdGFjayBvZiBge3R5cGUsIG1hdGNofWAgb2JqZWN0cyB0aGF0XG4vLyAgICByZXByZXNlbnQgdGhlIG9wZW4gc2lkZSBvZiB0aGUgcmVwbGFjZW1lbnQuIEl0IHN0YXJ0cyBhdFxuLy8gICAgYCRmcm9tYCwgdGhlbiBtb3ZlcyBmb3J3YXJkIGFzIGNvbnRlbnQgaXMgcGxhY2VkLCBhbmQgaXMgZmluYWxseVxuLy8gICAgcmVjb25jaWxlZCB3aXRoIGAkdG9gLlxuLy9cbi8vICAtIGB1bnBsYWNlZGAgaXMgYSBzbGljZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvbnRlbnQgdGhhdCBoYXNuJ3Rcbi8vICAgIGJlZW4gcGxhY2VkIHlldC5cbi8vXG4vLyAgLSBgcGxhY2VkYCBpcyBhIGZyYWdtZW50IG9mIHBsYWNlZCBjb250ZW50LiBJdHMgb3Blbi1zdGFydCB2YWx1ZVxuLy8gICAgaXMgaW1wbGljaXQgaW4gYCRmcm9tYCwgYW5kIGl0cyBvcGVuLWVuZCB2YWx1ZSBpbiBgZnJvbnRpZXJgLlxuY2xhc3MgRml0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigkZnJvbSwgJHRvLCB1bnBsYWNlZCkge1xuICAgICAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgICAgIHRoaXMuJHRvID0gJHRvO1xuICAgICAgICB0aGlzLnVucGxhY2VkID0gdW5wbGFjZWQ7XG4gICAgICAgIHRoaXMuZnJvbnRpZXIgPSBbXTtcbiAgICAgICAgdGhpcy5wbGFjZWQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gJGZyb20uZGVwdGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSAkZnJvbS5ub2RlKGkpO1xuICAgICAgICAgICAgdGhpcy5mcm9udGllci5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgICAgICAgICAgbWF0Y2g6IG5vZGUuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcihpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAkZnJvbS5kZXB0aDsgaSA+IDA7IGktLSlcbiAgICAgICAgICAgIHRoaXMucGxhY2VkID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGkpLmNvcHkodGhpcy5wbGFjZWQpKTtcbiAgICB9XG4gICAgZ2V0IGRlcHRoKCkgeyByZXR1cm4gdGhpcy5mcm9udGllci5sZW5ndGggLSAxOyB9XG4gICAgZml0KCkge1xuICAgICAgICAvLyBBcyBsb25nIGFzIHRoZXJlJ3MgdW5wbGFjZWQgY29udGVudCwgdHJ5IHRvIHBsYWNlIHNvbWUgb2YgaXQuXG4gICAgICAgIC8vIElmIHRoYXQgZmFpbHMsIGVpdGhlciBpbmNyZWFzZSB0aGUgb3BlbiBzY29yZSBvZiB0aGUgdW5wbGFjZWRcbiAgICAgICAgLy8gc2xpY2UsIG9yIGRyb3Agbm9kZXMgZnJvbSBpdCwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgICAgICB3aGlsZSAodGhpcy51bnBsYWNlZC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgZml0ID0gdGhpcy5maW5kRml0dGFibGUoKTtcbiAgICAgICAgICAgIGlmIChmaXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wbGFjZU5vZGVzKGZpdCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuTW9yZSgpIHx8IHRoaXMuZHJvcE5vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZXJlJ3MgaW5saW5lIGNvbnRlbnQgZGlyZWN0bHkgYWZ0ZXIgdGhlIGZyb250aWVyIF9hbmRfXG4gICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIGB0aGlzLiR0b2AsIHdlIG11c3QgZ2VuZXJhdGUgYSBgUmVwbGFjZUFyb3VuZGBcbiAgICAgICAgLy8gc3RlcCB0aGF0IHB1bGxzIHRoYXQgY29udGVudCBpbnRvIHRoZSBub2RlIGFmdGVyIHRoZSBmcm9udGllci5cbiAgICAgICAgLy8gVGhhdCBtZWFucyB0aGUgZml0dGluZyBtdXN0IGJlIGRvbmUgdG8gdGhlIGVuZCBvZiB0aGUgdGV4dGJsb2NrXG4gICAgICAgIC8vIG5vZGUgYWZ0ZXIgYHRoaXMuJHRvYCwgbm90IGB0aGlzLiR0b2AgaXRzZWxmLlxuICAgICAgICBsZXQgbW92ZUlubGluZSA9IHRoaXMubXVzdE1vdmVJbmxpbmUoKSwgcGxhY2VkU2l6ZSA9IHRoaXMucGxhY2VkLnNpemUgLSB0aGlzLmRlcHRoIC0gdGhpcy4kZnJvbS5kZXB0aDtcbiAgICAgICAgbGV0ICRmcm9tID0gdGhpcy4kZnJvbSwgJHRvID0gdGhpcy5jbG9zZShtb3ZlSW5saW5lIDwgMCA/IHRoaXMuJHRvIDogJGZyb20uZG9jLnJlc29sdmUobW92ZUlubGluZSkpO1xuICAgICAgICBpZiAoISR0bylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvLyBJZiBjbG9zaW5nIHRvIGAkdG9gIHN1Y2NlZWRlZCwgY3JlYXRlIGEgc3RlcFxuICAgICAgICBsZXQgY29udGVudCA9IHRoaXMucGxhY2VkLCBvcGVuU3RhcnQgPSAkZnJvbS5kZXB0aCwgb3BlbkVuZCA9ICR0by5kZXB0aDtcbiAgICAgICAgd2hpbGUgKG9wZW5TdGFydCAmJiBvcGVuRW5kICYmIGNvbnRlbnQuY2hpbGRDb3VudCA9PSAxKSB7IC8vIE5vcm1hbGl6ZSBieSBkcm9wcGluZyBvcGVuIHBhcmVudCBub2Rlc1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgICAgICAgICAgb3BlblN0YXJ0LS07XG4gICAgICAgICAgICBvcGVuRW5kLS07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIGlmIChtb3ZlSW5saW5lID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKCRmcm9tLnBvcywgbW92ZUlubGluZSwgdGhpcy4kdG8ucG9zLCB0aGlzLiR0by5lbmQoKSwgc2xpY2UsIHBsYWNlZFNpemUpO1xuICAgICAgICBpZiAoc2xpY2Uuc2l6ZSB8fCAkZnJvbS5wb3MgIT0gdGhpcy4kdG8ucG9zKSAvLyBEb24ndCBnZW5lcmF0ZSBuby1vcCBzdGVwc1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcCgkZnJvbS5wb3MsICR0by5wb3MsIHNsaWNlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEZpbmQgYSBwb3NpdGlvbiBvbiB0aGUgc3RhcnQgc3BpbmUgb2YgYHRoaXMudW5wbGFjZWRgIHRoYXQgaGFzXG4gICAgLy8gY29udGVudCB0aGF0IGNhbiBiZSBtb3ZlZCBzb21ld2hlcmUgb24gdGhlIGZyb250aWVyLiBSZXR1cm5zIHR3b1xuICAgIC8vIGRlcHRocywgb25lIGZvciB0aGUgc2xpY2UgYW5kIG9uZSBmb3IgdGhlIGZyb250aWVyLlxuICAgIGZpbmRGaXR0YWJsZSgpIHtcbiAgICAgICAgbGV0IHN0YXJ0RGVwdGggPSB0aGlzLnVucGxhY2VkLm9wZW5TdGFydDtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gdGhpcy51bnBsYWNlZC5jb250ZW50LCBkID0gMCwgb3BlbkVuZCA9IHRoaXMudW5wbGFjZWQub3BlbkVuZDsgZCA8IHN0YXJ0RGVwdGg7IGQrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBjdXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChjdXIuY2hpbGRDb3VudCA+IDEpXG4gICAgICAgICAgICAgICAgb3BlbkVuZCA9IDA7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nICYmIG9wZW5FbmQgPD0gZCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RGVwdGggPSBkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gbm9kZS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgdHJ5IHdyYXBwaW5nIG5vZGVzIChwYXNzIDIpIGFmdGVyIGZpbmRpbmcgYSBwbGFjZSB3aXRob3V0XG4gICAgICAgIC8vIHdyYXBwaW5nIGZhaWxlZC5cbiAgICAgICAgZm9yIChsZXQgcGFzcyA9IDE7IHBhc3MgPD0gMjsgcGFzcysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzbGljZURlcHRoID0gcGFzcyA9PSAxID8gc3RhcnREZXB0aCA6IHRoaXMudW5wbGFjZWQub3BlblN0YXJ0OyBzbGljZURlcHRoID49IDA7IHNsaWNlRGVwdGgtLSkge1xuICAgICAgICAgICAgICAgIGxldCBmcmFnbWVudCwgcGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc2xpY2VEZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBjb250ZW50QXQodGhpcy51bnBsYWNlZC5jb250ZW50LCBzbGljZURlcHRoIC0gMSkuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBwYXJlbnQuY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy51bnBsYWNlZC5jb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGZyb250aWVyRGVwdGggPSB0aGlzLmRlcHRoOyBmcm9udGllckRlcHRoID49IDA7IGZyb250aWVyRGVwdGgtLSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBtYXRjaCB9ID0gdGhpcy5mcm9udGllcltmcm9udGllckRlcHRoXSwgd3JhcCwgaW5qZWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gcGFzcyAxLCBpZiB0aGUgbmV4dCBub2RlIG1hdGNoZXMsIG9yIHRoZXJlIGlzIG5vIG5leHRcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9kZSBidXQgdGhlIHBhcmVudHMgbG9vayBjb21wYXRpYmxlLCB3ZSd2ZSBmb3VuZCBhXG4gICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFzcyA9PSAxICYmIChmaXJzdCA/IG1hdGNoLm1hdGNoVHlwZShmaXJzdC50eXBlKSB8fCAoaW5qZWN0ID0gbWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5mcm9tKGZpcnN0KSwgZmFsc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwYXJlbnQgJiYgdHlwZS5jb21wYXRpYmxlQ29udGVudChwYXJlbnQudHlwZSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc2xpY2VEZXB0aCwgZnJvbnRpZXJEZXB0aCwgcGFyZW50LCBpbmplY3QgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gcGFzcyAyLCBsb29rIGZvciBhIHNldCBvZiB3cmFwcGluZyBub2RlcyB0aGF0IG1ha2VcbiAgICAgICAgICAgICAgICAgICAgLy8gYGZpcnN0YCBmaXQgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFzcyA9PSAyICYmIGZpcnN0ICYmICh3cmFwID0gbWF0Y2guZmluZFdyYXBwaW5nKGZpcnN0LnR5cGUpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHNsaWNlRGVwdGgsIGZyb250aWVyRGVwdGgsIHBhcmVudCwgd3JhcCB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjb250aW51ZSBsb29raW5nIGZ1cnRoZXIgdXAgaWYgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdvdWxkIGZpdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIG1hdGNoLm1hdGNoVHlwZShwYXJlbnQudHlwZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3Blbk1vcmUoKSB7XG4gICAgICAgIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gdGhpcy51bnBsYWNlZDtcbiAgICAgICAgbGV0IGlubmVyID0gY29udGVudEF0KGNvbnRlbnQsIG9wZW5TdGFydCk7XG4gICAgICAgIGlmICghaW5uZXIuY2hpbGRDb3VudCB8fCBpbm5lci5maXJzdENoaWxkLmlzTGVhZilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBTbGljZShjb250ZW50LCBvcGVuU3RhcnQgKyAxLCBNYXRoLm1heChvcGVuRW5kLCBpbm5lci5zaXplICsgb3BlblN0YXJ0ID49IGNvbnRlbnQuc2l6ZSAtIG9wZW5FbmQgPyBvcGVuU3RhcnQgKyAxIDogMCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZHJvcE5vZGUoKSB7XG4gICAgICAgIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gdGhpcy51bnBsYWNlZDtcbiAgICAgICAgbGV0IGlubmVyID0gY29udGVudEF0KGNvbnRlbnQsIG9wZW5TdGFydCk7XG4gICAgICAgIGlmIChpbm5lci5jaGlsZENvdW50IDw9IDEgJiYgb3BlblN0YXJ0ID4gMCkge1xuICAgICAgICAgICAgbGV0IG9wZW5BdEVuZCA9IGNvbnRlbnQuc2l6ZSAtIG9wZW5TdGFydCA8PSBvcGVuU3RhcnQgKyBpbm5lci5zaXplO1xuICAgICAgICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KGNvbnRlbnQsIG9wZW5TdGFydCAtIDEsIDEpLCBvcGVuU3RhcnQgLSAxLCBvcGVuQXRFbmQgPyBvcGVuU3RhcnQgLSAxIDogb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVucGxhY2VkID0gbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoY29udGVudCwgb3BlblN0YXJ0LCAxKSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNb3ZlIGNvbnRlbnQgZnJvbSB0aGUgdW5wbGFjZWQgc2xpY2UgYXQgYHNsaWNlRGVwdGhgIHRvIHRoZVxuICAgIC8vIGZyb250aWVyIG5vZGUgYXQgYGZyb250aWVyRGVwdGhgLiBDbG9zZSB0aGF0IGZyb250aWVyIG5vZGUgd2hlblxuICAgIC8vIGFwcGxpY2FibGUuXG4gICAgcGxhY2VOb2Rlcyh7IHNsaWNlRGVwdGgsIGZyb250aWVyRGVwdGgsIHBhcmVudCwgaW5qZWN0LCB3cmFwIH0pIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuZGVwdGggPiBmcm9udGllckRlcHRoKVxuICAgICAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgICBpZiAod3JhcClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JhcC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5Gcm9udGllck5vZGUod3JhcFtpXSk7XG4gICAgICAgIGxldCBzbGljZSA9IHRoaXMudW5wbGFjZWQsIGZyYWdtZW50ID0gcGFyZW50ID8gcGFyZW50LmNvbnRlbnQgOiBzbGljZS5jb250ZW50O1xuICAgICAgICBsZXQgb3BlblN0YXJ0ID0gc2xpY2Uub3BlblN0YXJ0IC0gc2xpY2VEZXB0aDtcbiAgICAgICAgbGV0IHRha2VuID0gMCwgYWRkID0gW107XG4gICAgICAgIGxldCB7IG1hdGNoLCB0eXBlIH0gPSB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdO1xuICAgICAgICBpZiAoaW5qZWN0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluamVjdC5jaGlsZENvdW50OyBpKyspXG4gICAgICAgICAgICAgICAgYWRkLnB1c2goaW5qZWN0LmNoaWxkKGkpKTtcbiAgICAgICAgICAgIG1hdGNoID0gbWF0Y2gubWF0Y2hGcmFnbWVudChpbmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGVzIHRoZSBhbW91bnQgb2YgKGVuZCkgb3BlbiBub2RlcyBhdCB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAvLyBmcmFnbWVudC4gV2hlbiAwLCB0aGUgcGFyZW50IGlzIG9wZW4sIGJ1dCBubyBtb3JlLiBXaGVuXG4gICAgICAgIC8vIG5lZ2F0aXZlLCBub3RoaW5nIGlzIG9wZW4uXG4gICAgICAgIGxldCBvcGVuRW5kQ291bnQgPSAoZnJhZ21lbnQuc2l6ZSArIHNsaWNlRGVwdGgpIC0gKHNsaWNlLmNvbnRlbnQuc2l6ZSAtIHNsaWNlLm9wZW5FbmQpO1xuICAgICAgICAvLyBTY2FuIG92ZXIgdGhlIGZyYWdtZW50LCBmaXR0aW5nIGFzIG1hbnkgY2hpbGQgbm9kZXMgYXNcbiAgICAgICAgLy8gcG9zc2libGUuXG4gICAgICAgIHdoaWxlICh0YWtlbiA8IGZyYWdtZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZnJhZ21lbnQuY2hpbGQodGFrZW4pLCBtYXRjaGVzID0gbWF0Y2gubWF0Y2hUeXBlKG5leHQudHlwZSk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB0YWtlbisrO1xuICAgICAgICAgICAgaWYgKHRha2VuID4gMSB8fCBvcGVuU3RhcnQgPT0gMCB8fCBuZXh0LmNvbnRlbnQuc2l6ZSkgeyAvLyBEcm9wIGVtcHR5IG9wZW4gbm9kZXNcbiAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoZXM7XG4gICAgICAgICAgICAgICAgYWRkLnB1c2goY2xvc2VOb2RlU3RhcnQobmV4dC5tYXJrKHR5cGUuYWxsb3dlZE1hcmtzKG5leHQubWFya3MpKSwgdGFrZW4gPT0gMSA/IG9wZW5TdGFydCA6IDAsIHRha2VuID09IGZyYWdtZW50LmNoaWxkQ291bnQgPyBvcGVuRW5kQ291bnQgOiAtMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0b0VuZCA9IHRha2VuID09IGZyYWdtZW50LmNoaWxkQ291bnQ7XG4gICAgICAgIGlmICghdG9FbmQpXG4gICAgICAgICAgICBvcGVuRW5kQ291bnQgPSAtMTtcbiAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCBmcm9udGllckRlcHRoLCBGcmFnbWVudC5mcm9tKGFkZCkpO1xuICAgICAgICB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdLm1hdGNoID0gbWF0Y2g7XG4gICAgICAgIC8vIElmIHRoZSBwYXJlbnQgdHlwZXMgbWF0Y2gsIGFuZCB0aGUgZW50aXJlIG5vZGUgd2FzIG1vdmVkLCBhbmRcbiAgICAgICAgLy8gaXQncyBub3Qgb3BlbiwgY2xvc2UgdGhpcyBmcm9udGllciBub2RlIHJpZ2h0IGF3YXkuXG4gICAgICAgIGlmICh0b0VuZCAmJiBvcGVuRW5kQ291bnQgPCAwICYmIHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdLnR5cGUgJiYgdGhpcy5mcm9udGllci5sZW5ndGggPiAxKVxuICAgICAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgICAvLyBBZGQgbmV3IGZyb250aWVyIG5vZGVzIGZvciBhbnkgb3BlbiBub2RlcyBhdCB0aGUgZW5kLlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgY3VyID0gZnJhZ21lbnQ7IGkgPCBvcGVuRW5kQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBjdXIubGFzdENoaWxkO1xuICAgICAgICAgICAgdGhpcy5mcm9udGllci5wdXNoKHsgdHlwZTogbm9kZS50eXBlLCBtYXRjaDogbm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpIH0pO1xuICAgICAgICAgICAgY3VyID0gbm9kZS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBgdGhpcy51bnBsYWNlZGAuIERyb3AgdGhlIGVudGlyZSBub2RlIGZyb20gd2hpY2ggd2VcbiAgICAgICAgLy8gcGxhY2VkIGl0IHdlIGdvdCB0byBpdHMgZW5kLCBvdGhlcndpc2UganVzdCBkcm9wIHRoZSBwbGFjZWRcbiAgICAgICAgLy8gbm9kZXMuXG4gICAgICAgIHRoaXMudW5wbGFjZWQgPSAhdG9FbmQgPyBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChzbGljZS5jb250ZW50LCBzbGljZURlcHRoLCB0YWtlbiksIHNsaWNlLm9wZW5TdGFydCwgc2xpY2Uub3BlbkVuZClcbiAgICAgICAgICAgIDogc2xpY2VEZXB0aCA9PSAwID8gU2xpY2UuZW1wdHlcbiAgICAgICAgICAgICAgICA6IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIHNsaWNlRGVwdGggLSAxLCAxKSwgc2xpY2VEZXB0aCAtIDEsIG9wZW5FbmRDb3VudCA8IDAgPyBzbGljZS5vcGVuRW5kIDogc2xpY2VEZXB0aCAtIDEpO1xuICAgIH1cbiAgICBtdXN0TW92ZUlubGluZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiR0by5wYXJlbnQuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdLCBsZXZlbDtcbiAgICAgICAgaWYgKCF0b3AudHlwZS5pc1RleHRibG9jayB8fCAhY29udGVudEFmdGVyRml0cyh0aGlzLiR0bywgdGhpcy4kdG8uZGVwdGgsIHRvcC50eXBlLCB0b3AubWF0Y2gsIGZhbHNlKSB8fFxuICAgICAgICAgICAgKHRoaXMuJHRvLmRlcHRoID09IHRoaXMuZGVwdGggJiYgKGxldmVsID0gdGhpcy5maW5kQ2xvc2VMZXZlbCh0aGlzLiR0bykpICYmIGxldmVsLmRlcHRoID09IHRoaXMuZGVwdGgpKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBsZXQgeyBkZXB0aCB9ID0gdGhpcy4kdG8sIGFmdGVyID0gdGhpcy4kdG8uYWZ0ZXIoZGVwdGgpO1xuICAgICAgICB3aGlsZSAoZGVwdGggPiAxICYmIGFmdGVyID09IHRoaXMuJHRvLmVuZCgtLWRlcHRoKSlcbiAgICAgICAgICAgICsrYWZ0ZXI7XG4gICAgICAgIHJldHVybiBhZnRlcjtcbiAgICB9XG4gICAgZmluZENsb3NlTGV2ZWwoJHRvKSB7XG4gICAgICAgIHNjYW46IGZvciAobGV0IGkgPSBNYXRoLm1pbih0aGlzLmRlcHRoLCAkdG8uZGVwdGgpOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHsgbWF0Y2gsIHR5cGUgfSA9IHRoaXMuZnJvbnRpZXJbaV07XG4gICAgICAgICAgICBsZXQgZHJvcElubmVyID0gaSA8ICR0by5kZXB0aCAmJiAkdG8uZW5kKGkgKyAxKSA9PSAkdG8ucG9zICsgKCR0by5kZXB0aCAtIChpICsgMSkpO1xuICAgICAgICAgICAgbGV0IGZpdCA9IGNvbnRlbnRBZnRlckZpdHMoJHRvLCBpLCB0eXBlLCBtYXRjaCwgZHJvcElubmVyKTtcbiAgICAgICAgICAgIGlmICghZml0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgZCA9IGkgLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgICAgIGxldCB7IG1hdGNoLCB0eXBlIH0gPSB0aGlzLmZyb250aWVyW2RdO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaGVzID0gY29udGVudEFmdGVyRml0cygkdG8sIGQsIHR5cGUsIG1hdGNoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5jaGlsZENvdW50KVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGVwdGg6IGksIGZpdCwgbW92ZTogZHJvcElubmVyID8gJHRvLmRvYy5yZXNvbHZlKCR0by5hZnRlcihpICsgMSkpIDogJHRvIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2UoJHRvKSB7XG4gICAgICAgIGxldCBjbG9zZSA9IHRoaXMuZmluZENsb3NlTGV2ZWwoJHRvKTtcbiAgICAgICAgaWYgKCFjbG9zZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAodGhpcy5kZXB0aCA+IGNsb3NlLmRlcHRoKVxuICAgICAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgICBpZiAoY2xvc2UuZml0LmNoaWxkQ291bnQpXG4gICAgICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIGNsb3NlLmRlcHRoLCBjbG9zZS5maXQpO1xuICAgICAgICAkdG8gPSBjbG9zZS5tb3ZlO1xuICAgICAgICBmb3IgKGxldCBkID0gY2xvc2UuZGVwdGggKyAxOyBkIDw9ICR0by5kZXB0aDsgZCsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9ICR0by5ub2RlKGQpLCBhZGQgPSBub2RlLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUobm9kZS5jb250ZW50LCB0cnVlLCAkdG8uaW5kZXgoZCkpO1xuICAgICAgICAgICAgdGhpcy5vcGVuRnJvbnRpZXJOb2RlKG5vZGUudHlwZSwgbm9kZS5hdHRycywgYWRkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRvO1xuICAgIH1cbiAgICBvcGVuRnJvbnRpZXJOb2RlKHR5cGUsIGF0dHJzID0gbnVsbCwgY29udGVudCkge1xuICAgICAgICBsZXQgdG9wID0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXTtcbiAgICAgICAgdG9wLm1hdGNoID0gdG9wLm1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCB0aGlzLmRlcHRoLCBGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGF0dHJzLCBjb250ZW50KSkpO1xuICAgICAgICB0aGlzLmZyb250aWVyLnB1c2goeyB0eXBlLCBtYXRjaDogdHlwZS5jb250ZW50TWF0Y2ggfSk7XG4gICAgfVxuICAgIGNsb3NlRnJvbnRpZXJOb2RlKCkge1xuICAgICAgICBsZXQgb3BlbiA9IHRoaXMuZnJvbnRpZXIucG9wKCk7XG4gICAgICAgIGxldCBhZGQgPSBvcGVuLm1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgICAgICBpZiAoYWRkLmNoaWxkQ291bnQpXG4gICAgICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIHRoaXMuZnJvbnRpZXIubGVuZ3RoLCBhZGQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRyb3BGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBjb3VudCkge1xuICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQuY3V0QnlJbmRleChjb3VudCwgZnJhZ21lbnQuY2hpbGRDb3VudCk7XG4gICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2VDaGlsZCgwLCBmcmFnbWVudC5maXJzdENoaWxkLmNvcHkoZHJvcEZyb21GcmFnbWVudChmcmFnbWVudC5maXJzdENoaWxkLmNvbnRlbnQsIGRlcHRoIC0gMSwgY291bnQpKSk7XG59XG5mdW5jdGlvbiBhZGRUb0ZyYWdtZW50KGZyYWdtZW50LCBkZXB0aCwgY29udGVudCkge1xuICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQuYXBwZW5kKGNvbnRlbnQpO1xuICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoZnJhZ21lbnQuY2hpbGRDb3VudCAtIDEsIGZyYWdtZW50Lmxhc3RDaGlsZC5jb3B5KGFkZFRvRnJhZ21lbnQoZnJhZ21lbnQubGFzdENoaWxkLmNvbnRlbnQsIGRlcHRoIC0gMSwgY29udGVudCkpKTtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRBdChmcmFnbWVudCwgZGVwdGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHRoOyBpKyspXG4gICAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgIHJldHVybiBmcmFnbWVudDtcbn1cbmZ1bmN0aW9uIGNsb3NlTm9kZVN0YXJ0KG5vZGUsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGlmIChvcGVuU3RhcnQgPD0gMClcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgbGV0IGZyYWcgPSBub2RlLmNvbnRlbnQ7XG4gICAgaWYgKG9wZW5TdGFydCA+IDEpXG4gICAgICAgIGZyYWcgPSBmcmFnLnJlcGxhY2VDaGlsZCgwLCBjbG9zZU5vZGVTdGFydChmcmFnLmZpcnN0Q2hpbGQsIG9wZW5TdGFydCAtIDEsIGZyYWcuY2hpbGRDb3VudCA9PSAxID8gb3BlbkVuZCAtIDEgOiAwKSk7XG4gICAgaWYgKG9wZW5TdGFydCA+IDApIHtcbiAgICAgICAgZnJhZyA9IG5vZGUudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShmcmFnKS5hcHBlbmQoZnJhZyk7XG4gICAgICAgIGlmIChvcGVuRW5kIDw9IDApXG4gICAgICAgICAgICBmcmFnID0gZnJhZy5hcHBlbmQobm9kZS50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGZyYWcpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUuY29weShmcmFnKTtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRBZnRlckZpdHMoJHRvLCBkZXB0aCwgdHlwZSwgbWF0Y2gsIG9wZW4pIHtcbiAgICBsZXQgbm9kZSA9ICR0by5ub2RlKGRlcHRoKSwgaW5kZXggPSBvcGVuID8gJHRvLmluZGV4QWZ0ZXIoZGVwdGgpIDogJHRvLmluZGV4KGRlcHRoKTtcbiAgICBpZiAoaW5kZXggPT0gbm9kZS5jaGlsZENvdW50ICYmICF0eXBlLmNvbXBhdGlibGVDb250ZW50KG5vZGUudHlwZSkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmaXQgPSBtYXRjaC5maWxsQmVmb3JlKG5vZGUuY29udGVudCwgdHJ1ZSwgaW5kZXgpO1xuICAgIHJldHVybiBmaXQgJiYgIWludmFsaWRNYXJrcyh0eXBlLCBub2RlLmNvbnRlbnQsIGluZGV4KSA/IGZpdCA6IG51bGw7XG59XG5mdW5jdGlvbiBpbnZhbGlkTWFya3ModHlwZSwgZnJhZ21lbnQsIHN0YXJ0KSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZnJhZ21lbnQuY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICBpZiAoIXR5cGUuYWxsb3dzTWFya3MoZnJhZ21lbnQuY2hpbGQoaSkubWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZGVmaW5lc0NvbnRlbnQodHlwZSkge1xuICAgIHJldHVybiB0eXBlLnNwZWMuZGVmaW5pbmcgfHwgdHlwZS5zcGVjLmRlZmluaW5nRm9yQ29udGVudDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VSYW5nZSh0ciwgZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgaWYgKCFzbGljZS5zaXplKVxuICAgICAgICByZXR1cm4gdHIuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgIGxldCAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLCAkdG8gPSB0ci5kb2MucmVzb2x2ZSh0byk7XG4gICAgaWYgKGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpKVxuICAgICAgICByZXR1cm4gdHIuc3RlcChuZXcgUmVwbGFjZVN0ZXAoZnJvbSwgdG8sIHNsaWNlKSk7XG4gICAgbGV0IHRhcmdldERlcHRocyA9IGNvdmVyZWREZXB0aHMoJGZyb20sIHRyLmRvYy5yZXNvbHZlKHRvKSk7XG4gICAgLy8gQ2FuJ3QgcmVwbGFjZSB0aGUgd2hvbGUgZG9jdW1lbnQsIHNvIHJlbW92ZSAwIGlmIGl0J3MgcHJlc2VudFxuICAgIGlmICh0YXJnZXREZXB0aHNbdGFyZ2V0RGVwdGhzLmxlbmd0aCAtIDFdID09IDApXG4gICAgICAgIHRhcmdldERlcHRocy5wb3AoKTtcbiAgICAvLyBOZWdhdGl2ZSBudW1iZXJzIHJlcHJlc2VudCBub3QgZXhwYW5zaW9uIG92ZXIgdGhlIHdob2xlIG5vZGUgYXRcbiAgICAvLyB0aGF0IGRlcHRoLCBidXQgcmVwbGFjaW5nIGZyb20gJGZyb20uYmVmb3JlKC1EKSB0byAkdG8ucG9zLlxuICAgIGxldCBwcmVmZXJyZWRUYXJnZXQgPSAtKCRmcm9tLmRlcHRoICsgMSk7XG4gICAgdGFyZ2V0RGVwdGhzLnVuc2hpZnQocHJlZmVycmVkVGFyZ2V0KTtcbiAgICAvLyBUaGlzIGxvb3AgcGlja3MgYSBwcmVmZXJyZWQgdGFyZ2V0IGRlcHRoLCBpZiBvbmUgb2YgdGhlIGNvdmVyaW5nXG4gICAgLy8gZGVwdGhzIGlzIG5vdCBvdXRzaWRlIG9mIGEgZGVmaW5pbmcgbm9kZSwgYW5kIGFkZHMgbmVnYXRpdmVcbiAgICAvLyBkZXB0aHMgZm9yIGFueSBkZXB0aCB0aGF0IGhhcyAkZnJvbSBhdCBpdHMgc3RhcnQgYW5kIGRvZXMgbm90XG4gICAgLy8gY3Jvc3MgYSBkZWZpbmluZyBub2RlLlxuICAgIGZvciAobGV0IGQgPSAkZnJvbS5kZXB0aCwgcG9zID0gJGZyb20ucG9zIC0gMTsgZCA+IDA7IGQtLSwgcG9zLS0pIHtcbiAgICAgICAgbGV0IHNwZWMgPSAkZnJvbS5ub2RlKGQpLnR5cGUuc3BlYztcbiAgICAgICAgaWYgKHNwZWMuZGVmaW5pbmcgfHwgc3BlYy5kZWZpbmluZ0FzQ29udGV4dCB8fCBzcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAodGFyZ2V0RGVwdGhzLmluZGV4T2YoZCkgPiAtMSlcbiAgICAgICAgICAgIHByZWZlcnJlZFRhcmdldCA9IGQ7XG4gICAgICAgIGVsc2UgaWYgKCRmcm9tLmJlZm9yZShkKSA9PSBwb3MpXG4gICAgICAgICAgICB0YXJnZXREZXB0aHMuc3BsaWNlKDEsIDAsIC1kKTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpdCBlYWNoIHBvc3NpYmxlIGRlcHRoIG9mIHRoZSBzbGljZSBpbnRvIGVhY2ggcG9zc2libGVcbiAgICAvLyB0YXJnZXQgZGVwdGgsIHN0YXJ0aW5nIHdpdGggdGhlIHByZWZlcnJlZCBkZXB0aHMuXG4gICAgbGV0IHByZWZlcnJlZFRhcmdldEluZGV4ID0gdGFyZ2V0RGVwdGhzLmluZGV4T2YocHJlZmVycmVkVGFyZ2V0KTtcbiAgICBsZXQgbGVmdE5vZGVzID0gW10sIHByZWZlcnJlZERlcHRoID0gc2xpY2Uub3BlblN0YXJ0O1xuICAgIGZvciAobGV0IGNvbnRlbnQgPSBzbGljZS5jb250ZW50LCBpID0gMDs7IGkrKykge1xuICAgICAgICBsZXQgbm9kZSA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgbGVmdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIGlmIChpID09IHNsaWNlLm9wZW5TdGFydClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb250ZW50ID0gbm9kZS5jb250ZW50O1xuICAgIH1cbiAgICAvLyBCYWNrIHVwIHByZWZlcnJlZERlcHRoIHRvIGNvdmVyIGRlZmluaW5nIHRleHRibG9ja3MgZGlyZWN0bHlcbiAgICAvLyBhYm92ZSBpdCwgcG9zc2libHkgc2tpcHBpbmcgYSBub24tZGVmaW5pbmcgdGV4dGJsb2NrLlxuICAgIGZvciAobGV0IGQgPSBwcmVmZXJyZWREZXB0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBsZWZ0Tm9kZSA9IGxlZnROb2Rlc1tkXSwgZGVmID0gZGVmaW5lc0NvbnRlbnQobGVmdE5vZGUudHlwZSk7XG4gICAgICAgIGlmIChkZWYgJiYgIWxlZnROb2RlLnNhbWVNYXJrdXAoJGZyb20ubm9kZShNYXRoLmFicyhwcmVmZXJyZWRUYXJnZXQpIC0gMSkpKVxuICAgICAgICAgICAgcHJlZmVycmVkRGVwdGggPSBkO1xuICAgICAgICBlbHNlIGlmIChkZWYgfHwgIWxlZnROb2RlLnR5cGUuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IHNsaWNlLm9wZW5TdGFydDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgbGV0IG9wZW5EZXB0aCA9IChqICsgcHJlZmVycmVkRGVwdGggKyAxKSAlIChzbGljZS5vcGVuU3RhcnQgKyAxKTtcbiAgICAgICAgbGV0IGluc2VydCA9IGxlZnROb2Rlc1tvcGVuRGVwdGhdO1xuICAgICAgICBpZiAoIWluc2VydClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldERlcHRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gTG9vcCBvdmVyIHBvc3NpYmxlIGV4cGFuc2lvbiBsZXZlbHMsIHN0YXJ0aW5nIHdpdGggdGhlXG4gICAgICAgICAgICAvLyBwcmVmZXJyZWQgb25lXG4gICAgICAgICAgICBsZXQgdGFyZ2V0RGVwdGggPSB0YXJnZXREZXB0aHNbKGkgKyBwcmVmZXJyZWRUYXJnZXRJbmRleCkgJSB0YXJnZXREZXB0aHMubGVuZ3RoXSwgZXhwYW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0YXJnZXREZXB0aCA8IDApIHtcbiAgICAgICAgICAgICAgICBleHBhbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0YXJnZXREZXB0aCA9IC10YXJnZXREZXB0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkZnJvbS5ub2RlKHRhcmdldERlcHRoIC0gMSksIGluZGV4ID0gJGZyb20uaW5kZXgodGFyZ2V0RGVwdGggLSAxKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBpbnNlcnQudHlwZSwgaW5zZXJ0Lm1hcmtzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHIucmVwbGFjZSgkZnJvbS5iZWZvcmUodGFyZ2V0RGVwdGgpLCBleHBhbmQgPyAkdG8uYWZ0ZXIodGFyZ2V0RGVwdGgpIDogdG8sIG5ldyBTbGljZShjbG9zZUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIDAsIHNsaWNlLm9wZW5TdGFydCwgb3BlbkRlcHRoKSwgb3BlbkRlcHRoLCBzbGljZS5vcGVuRW5kKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0YXJ0U3RlcHMgPSB0ci5zdGVwcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IHRhcmdldERlcHRocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0ci5yZXBsYWNlKGZyb20sIHRvLCBzbGljZSk7XG4gICAgICAgIGlmICh0ci5zdGVwcy5sZW5ndGggPiBzdGFydFN0ZXBzKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBkZXB0aCA9IHRhcmdldERlcHRoc1tpXTtcbiAgICAgICAgaWYgKGRlcHRoIDwgMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmcm9tID0gJGZyb20uYmVmb3JlKGRlcHRoKTtcbiAgICAgICAgdG8gPSAkdG8uYWZ0ZXIoZGVwdGgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb3NlRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBvbGRPcGVuLCBuZXdPcGVuLCBwYXJlbnQpIHtcbiAgICBpZiAoZGVwdGggPCBvbGRPcGVuKSB7XG4gICAgICAgIGxldCBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQucmVwbGFjZUNoaWxkKDAsIGZpcnN0LmNvcHkoY2xvc2VGcmFnbWVudChmaXJzdC5jb250ZW50LCBkZXB0aCArIDEsIG9sZE9wZW4sIG5ld09wZW4sIGZpcnN0KSkpO1xuICAgIH1cbiAgICBpZiAoZGVwdGggPiBuZXdPcGVuKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdCgwKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gbWF0Y2guZmlsbEJlZm9yZShmcmFnbWVudCkuYXBwZW5kKGZyYWdtZW50KTtcbiAgICAgICAgZnJhZ21lbnQgPSBzdGFydC5hcHBlbmQobWF0Y2gubWF0Y2hGcmFnbWVudChzdGFydCkuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG59XG5mdW5jdGlvbiByZXBsYWNlUmFuZ2VXaXRoKHRyLCBmcm9tLCB0bywgbm9kZSkge1xuICAgIGlmICghbm9kZS5pc0lubGluZSAmJiBmcm9tID09IHRvICYmIHRyLmRvYy5yZXNvbHZlKGZyb20pLnBhcmVudC5jb250ZW50LnNpemUpIHtcbiAgICAgICAgbGV0IHBvaW50ID0gaW5zZXJ0UG9pbnQodHIuZG9jLCBmcm9tLCBub2RlLnR5cGUpO1xuICAgICAgICBpZiAocG9pbnQgIT0gbnVsbClcbiAgICAgICAgICAgIGZyb20gPSB0byA9IHBvaW50O1xuICAgIH1cbiAgICB0ci5yZXBsYWNlUmFuZ2UoZnJvbSwgdG8sIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5vZGUpLCAwLCAwKSk7XG59XG5mdW5jdGlvbiBkZWxldGVSYW5nZSh0ciwgZnJvbSwgdG8pIHtcbiAgICBsZXQgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gdHIuZG9jLnJlc29sdmUodG8pO1xuICAgIGxldCBjb3ZlcmVkID0gY292ZXJlZERlcHRocygkZnJvbSwgJHRvKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlcHRoID0gY292ZXJlZFtpXSwgbGFzdCA9IGkgPT0gY292ZXJlZC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoKGxhc3QgJiYgZGVwdGggPT0gMCkgfHwgJGZyb20ubm9kZShkZXB0aCkudHlwZS5jb250ZW50TWF0Y2gudmFsaWRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdHIuZGVsZXRlKCRmcm9tLnN0YXJ0KGRlcHRoKSwgJHRvLmVuZChkZXB0aCkpO1xuICAgICAgICBpZiAoZGVwdGggPiAwICYmIChsYXN0IHx8ICRmcm9tLm5vZGUoZGVwdGggLSAxKS5jYW5SZXBsYWNlKCRmcm9tLmluZGV4KGRlcHRoIC0gMSksICR0by5pbmRleEFmdGVyKGRlcHRoIC0gMSkpKSlcbiAgICAgICAgICAgIHJldHVybiB0ci5kZWxldGUoJGZyb20uYmVmb3JlKGRlcHRoKSwgJHRvLmFmdGVyKGRlcHRoKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGQgPSAxOyBkIDw9ICRmcm9tLmRlcHRoICYmIGQgPD0gJHRvLmRlcHRoOyBkKyspIHtcbiAgICAgICAgaWYgKGZyb20gLSAkZnJvbS5zdGFydChkKSA9PSAkZnJvbS5kZXB0aCAtIGQgJiYgdG8gPiAkZnJvbS5lbmQoZCkgJiYgJHRvLmVuZChkKSAtIHRvICE9ICR0by5kZXB0aCAtIGQpXG4gICAgICAgICAgICByZXR1cm4gdHIuZGVsZXRlKCRmcm9tLmJlZm9yZShkKSwgdG8pO1xuICAgIH1cbiAgICB0ci5kZWxldGUoZnJvbSwgdG8pO1xufVxuLy8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgZGVwdGhzIGZvciB3aGljaCAkZnJvbSAtICR0byBzcGFucyB0aGVcbi8vIHdob2xlIGNvbnRlbnQgb2YgdGhlIG5vZGVzIGF0IHRoYXQgZGVwdGguXG5mdW5jdGlvbiBjb3ZlcmVkRGVwdGhzKCRmcm9tLCAkdG8pIHtcbiAgICBsZXQgcmVzdWx0ID0gW10sIG1pbkRlcHRoID0gTWF0aC5taW4oJGZyb20uZGVwdGgsICR0by5kZXB0aCk7XG4gICAgZm9yIChsZXQgZCA9IG1pbkRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgc3RhcnQgPSAkZnJvbS5zdGFydChkKTtcbiAgICAgICAgaWYgKHN0YXJ0IDwgJGZyb20ucG9zIC0gKCRmcm9tLmRlcHRoIC0gZCkgfHxcbiAgICAgICAgICAgICR0by5lbmQoZCkgPiAkdG8ucG9zICsgKCR0by5kZXB0aCAtIGQpIHx8XG4gICAgICAgICAgICAkZnJvbS5ub2RlKGQpLnR5cGUuc3BlYy5pc29sYXRpbmcgfHxcbiAgICAgICAgICAgICR0by5ub2RlKGQpLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHN0YXJ0ID09ICR0by5zdGFydChkKSB8fFxuICAgICAgICAgICAgKGQgPT0gJGZyb20uZGVwdGggJiYgZCA9PSAkdG8uZGVwdGggJiYgJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgJiYgJHRvLnBhcmVudC5pbmxpbmVDb250ZW50ICYmXG4gICAgICAgICAgICAgICAgZCAmJiAkdG8uc3RhcnQoZCAtIDEpID09IHN0YXJ0IC0gMSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG5VcGRhdGUgYW4gYXR0cmlidXRlIGluIGEgc3BlY2lmaWMgbm9kZS5cbiovXG5jbGFzcyBBdHRyU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhbiBhdHRyaWJ1dGUgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIFRoZSBhdHRyaWJ1dGUgdG8gc2V0LlxuICAgICovXG4gICAgYXR0ciwgXG4gICAgLy8gVGhlIGF0dHJpYnV0ZSdzIG5ldyB2YWx1ZS5cbiAgICB2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5hdHRyID0gYXR0cjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgYXR0cmlidXRlIHN0ZXAncyBwb3NpdGlvblwiKTtcbiAgICAgICAgbGV0IGF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBub2RlLmF0dHJzKVxuICAgICAgICAgICAgYXR0cnNbbmFtZV0gPSBub2RlLmF0dHJzW25hbWVdO1xuICAgICAgICBhdHRyc1t0aGlzLmF0dHJdID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBub2RlLnR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBub2RlLm1hcmtzKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLnBvcywgdGhpcy5wb3MgKyAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh1cGRhdGVkKSwgMCwgbm9kZS5pc0xlYWYgPyAwIDogMSkpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXR0clN0ZXAodGhpcy5wb3MsIHRoaXMuYXR0ciwgZG9jLm5vZGVBdCh0aGlzLnBvcykuYXR0cnNbdGhpcy5hdHRyXSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnBvcywgMSk7XG4gICAgICAgIHJldHVybiBwb3MuZGVsZXRlZEFmdGVyID8gbnVsbCA6IG5ldyBBdHRyU3RlcChwb3MucG9zLCB0aGlzLmF0dHIsIHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImF0dHJcIiwgcG9zOiB0aGlzLnBvcywgYXR0cjogdGhpcy5hdHRyLCB2YWx1ZTogdGhpcy52YWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5hdHRyICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEF0dHJTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJTdGVwKGpzb24ucG9zLCBqc29uLmF0dHIsIGpzb24udmFsdWUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiYXR0clwiLCBBdHRyU3RlcCk7XG4vKipcblVwZGF0ZSBhbiBhdHRyaWJ1dGUgaW4gdGhlIGRvYyBub2RlLlxuKi9cbmNsYXNzIERvY0F0dHJTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGFuIGF0dHJpYnV0ZSBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGF0dHJpYnV0ZSB0byBzZXQuXG4gICAgKi9cbiAgICBhdHRyLCBcbiAgICAvLyBUaGUgYXR0cmlidXRlJ3MgbmV3IHZhbHVlLlxuICAgIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXR0ciA9IGF0dHI7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gZG9jLmF0dHJzKVxuICAgICAgICAgICAgYXR0cnNbbmFtZV0gPSBkb2MuYXR0cnNbbmFtZV07XG4gICAgICAgIGF0dHJzW3RoaXMuYXR0cl0gPSB0aGlzLnZhbHVlO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IGRvYy50eXBlLmNyZWF0ZShhdHRycywgZG9jLmNvbnRlbnQsIGRvYy5tYXJrcyk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0Lm9rKHVwZGF0ZWQpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9jQXR0clN0ZXAodGhpcy5hdHRyLCBkb2MuYXR0cnNbdGhpcy5hdHRyXSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImRvY0F0dHJcIiwgYXR0cjogdGhpcy5hdHRyLCB2YWx1ZTogdGhpcy52YWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5hdHRyICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIERvY0F0dHJTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IERvY0F0dHJTdGVwKGpzb24uYXR0ciwganNvbi52YWx1ZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJkb2NBdHRyXCIsIERvY0F0dHJTdGVwKTtcblxuLyoqXG5AaW50ZXJuYWxcbiovXG5sZXQgVHJhbnNmb3JtRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbn07XG5UcmFuc2Zvcm1FcnJvciA9IGZ1bmN0aW9uIFRyYW5zZm9ybUVycm9yKG1lc3NhZ2UpIHtcbiAgICBsZXQgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICBlcnIuX19wcm90b19fID0gVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlO1xuICAgIHJldHVybiBlcnI7XG59O1xuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJhbnNmb3JtRXJyb3I7XG5UcmFuc2Zvcm1FcnJvci5wcm90b3R5cGUubmFtZSA9IFwiVHJhbnNmb3JtRXJyb3JcIjtcbi8qKlxuQWJzdHJhY3Rpb24gdG8gYnVpbGQgdXAgYW5kIHRyYWNrIGFuIGFycmF5IG9mXG5bc3RlcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcCkgcmVwcmVzZW50aW5nIGEgZG9jdW1lbnQgdHJhbnNmb3JtYXRpb24uXG5cbk1vc3QgdHJhbnNmb3JtaW5nIG1ldGhvZHMgcmV0dXJuIHRoZSBgVHJhbnNmb3JtYCBvYmplY3QgaXRzZWxmLCBzb1xudGhhdCB0aGV5IGNhbiBiZSBjaGFpbmVkLlxuKi9cbmNsYXNzIFRyYW5zZm9ybSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdHJhbnNmb3JtIHRoYXQgc3RhcnRzIHdpdGggdGhlIGdpdmVuIGRvY3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZG9jdW1lbnQgKHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIHN0ZXBzIGluIHRoZVxuICAgIHRyYW5zZm9ybSkuXG4gICAgKi9cbiAgICBkb2MpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgc3RlcHMgaW4gdGhpcyB0cmFuc2Zvcm0uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc3RlcHMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBkb2N1bWVudHMgYmVmb3JlIGVhY2ggb2YgdGhlIHN0ZXBzLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvY3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEEgbWFwcGluZyB3aXRoIHRoZSBtYXBzIGZvciBlYWNoIG9mIHRoZSBzdGVwcyBpbiB0aGlzIHRyYW5zZm9ybS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBwaW5nID0gbmV3IE1hcHBpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzdGFydGluZyBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBiZWZvcmUoKSB7IHJldHVybiB0aGlzLmRvY3MubGVuZ3RoID8gdGhpcy5kb2NzWzBdIDogdGhpcy5kb2M7IH1cbiAgICAvKipcbiAgICBBcHBseSBhIG5ldyBzdGVwIGluIHRoaXMgdHJhbnNmb3JtLCBzYXZpbmcgdGhlIHJlc3VsdC4gVGhyb3dzIGFuXG4gICAgZXJyb3Igd2hlbiB0aGUgc3RlcCBmYWlscy5cbiAgICAqL1xuICAgIHN0ZXAoc3RlcCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5tYXliZVN0ZXAoc3RlcCk7XG4gICAgICAgIGlmIChyZXN1bHQuZmFpbGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zZm9ybUVycm9yKHJlc3VsdC5mYWlsZWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIGFwcGx5IGEgc3RlcCBpbiB0aGlzIHRyYW5zZm9ybWF0aW9uLCBpZ25vcmluZyBpdCBpZiBpdFxuICAgIGZhaWxzLiBSZXR1cm5zIHRoZSBzdGVwIHJlc3VsdC5cbiAgICAqL1xuICAgIG1heWJlU3RlcChzdGVwKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzdGVwLmFwcGx5KHRoaXMuZG9jKTtcbiAgICAgICAgaWYgKCFyZXN1bHQuZmFpbGVkKVxuICAgICAgICAgICAgdGhpcy5hZGRTdGVwKHN0ZXAsIHJlc3VsdC5kb2MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhlIGRvY3VtZW50IGhhcyBiZWVuIGNoYW5nZWQgKHdoZW4gdGhlcmUgYXJlIGFueVxuICAgIHN0ZXBzKS5cbiAgICAqL1xuICAgIGdldCBkb2NDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwcy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFkZFN0ZXAoc3RlcCwgZG9jKSB7XG4gICAgICAgIHRoaXMuZG9jcy5wdXNoKHRoaXMuZG9jKTtcbiAgICAgICAgdGhpcy5zdGVwcy5wdXNoKHN0ZXApO1xuICAgICAgICB0aGlzLm1hcHBpbmcuYXBwZW5kTWFwKHN0ZXAuZ2V0TWFwKCkpO1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgcGFydCBvZiB0aGUgZG9jdW1lbnQgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2Agd2l0aCB0aGVcbiAgICBnaXZlbiBgc2xpY2VgLlxuICAgICovXG4gICAgcmVwbGFjZShmcm9tLCB0byA9IGZyb20sIHNsaWNlID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgbGV0IHN0ZXAgPSByZXBsYWNlU3RlcCh0aGlzLmRvYywgZnJvbSwgdG8sIHNsaWNlKTtcbiAgICAgICAgaWYgKHN0ZXApXG4gICAgICAgICAgICB0aGlzLnN0ZXAoc3RlcCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBnaXZlbiByYW5nZSB3aXRoIHRoZSBnaXZlbiBjb250ZW50LCB3aGljaCBtYXkgYmUgYVxuICAgIGZyYWdtZW50LCBub2RlLCBvciBhcnJheSBvZiBub2Rlcy5cbiAgICAqL1xuICAgIHJlcGxhY2VXaXRoKGZyb20sIHRvLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoZnJvbSwgdG8sIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKGNvbnRlbnQpLCAwLCAwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSB0aGUgY29udGVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBkZWxldGUoZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZShmcm9tLCB0bywgU2xpY2UuZW1wdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICBJbnNlcnQgdGhlIGdpdmVuIGNvbnRlbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgaW5zZXJ0KHBvcywgY29udGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlV2l0aChwb3MsIHBvcywgY29udGVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgYSByYW5nZSBvZiB0aGUgZG9jdW1lbnQgd2l0aCBhIGdpdmVuIHNsaWNlLCB1c2luZ1xuICAgIGBmcm9tYCwgYHRvYCwgYW5kIHRoZSBzbGljZSdzXG4gICAgW2BvcGVuU3RhcnRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuU2xpY2Uub3BlblN0YXJ0KSBwcm9wZXJ0eSBhcyBoaW50cywgcmF0aGVyXG4gICAgdGhhbiBmaXhlZCBzdGFydCBhbmQgZW5kIHBvaW50cy4gVGhpcyBtZXRob2QgbWF5IGdyb3cgdGhlXG4gICAgcmVwbGFjZWQgYXJlYSBvciBjbG9zZSBvcGVuIG5vZGVzIGluIHRoZSBzbGljZSBpbiBvcmRlciB0byBnZXQgYVxuICAgIGZpdCB0aGF0IGlzIG1vcmUgaW4gbGluZSB3aXRoIFdZU0lXWUcgZXhwZWN0YXRpb25zLCBieSBkcm9wcGluZ1xuICAgIGZ1bGx5IGNvdmVyZWQgcGFyZW50IG5vZGVzIG9mIHRoZSByZXBsYWNlZCByZWdpb24gd2hlbiB0aGV5IGFyZVxuICAgIG1hcmtlZCBbbm9uLWRlZmluaW5nIGFzXG4gICAgY29udGV4dF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmRlZmluaW5nQXNDb250ZXh0KSwgb3IgaW5jbHVkaW5nIGFuXG4gICAgb3BlbiBwYXJlbnQgbm9kZSBmcm9tIHRoZSBzbGljZSB0aGF0IF9pc18gbWFya2VkIGFzIFtkZWZpbmluZ1xuICAgIGl0cyBjb250ZW50XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuZGVmaW5pbmdGb3JDb250ZW50KS5cbiAgICBcbiAgICBUaGlzIGlzIHRoZSBtZXRob2QsIGZvciBleGFtcGxlLCB0byBoYW5kbGUgcGFzdGUuIFRoZSBzaW1pbGFyXG4gICAgW2ByZXBsYWNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5UcmFuc2Zvcm0ucmVwbGFjZSkgbWV0aG9kIGlzIGEgbW9yZVxuICAgIHByaW1pdGl2ZSB0b29sIHdoaWNoIHdpbGwgX25vdF8gbW92ZSB0aGUgc3RhcnQgYW5kIGVuZCBvZiBpdHMgZ2l2ZW5cbiAgICByYW5nZSwgYW5kIGlzIHVzZWZ1bCBpbiBzaXR1YXRpb25zIHdoZXJlIHlvdSBuZWVkIG1vcmUgcHJlY2lzZVxuICAgIGNvbnRyb2wgb3ZlciB3aGF0IGhhcHBlbnMuXG4gICAgKi9cbiAgICByZXBsYWNlUmFuZ2UoZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgICAgIHJlcGxhY2VSYW5nZSh0aGlzLCBmcm9tLCB0bywgc2xpY2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aCBhIG5vZGUsIGJ1dCB1c2UgYGZyb21gIGFuZCBgdG9gIGFzXG4gICAgaGludHMsIHJhdGhlciB0aGFuIHByZWNpc2UgcG9zaXRpb25zLiBXaGVuIGZyb20gYW5kIHRvIGFyZSB0aGUgc2FtZVxuICAgIGFuZCBhcmUgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhIHBhcmVudCBub2RlIGluIHdoaWNoIHRoZSBnaXZlblxuICAgIG5vZGUgZG9lc24ndCBmaXQsIHRoaXMgbWV0aG9kIG1heSBfbW92ZV8gdGhlbSBvdXQgdG93YXJkcyBhIHBhcmVudFxuICAgIHRoYXQgZG9lcyBhbGxvdyB0aGUgZ2l2ZW4gbm9kZSB0byBiZSBwbGFjZWQuIFdoZW4gdGhlIGdpdmVuIHJhbmdlXG4gICAgY29tcGxldGVseSBjb3ZlcnMgYSBwYXJlbnQgbm9kZSwgdGhpcyBtZXRob2QgbWF5IGNvbXBsZXRlbHkgcmVwbGFjZVxuICAgIHRoYXQgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICByZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBub2RlKSB7XG4gICAgICAgIHJlcGxhY2VSYW5nZVdpdGgodGhpcywgZnJvbSwgdG8sIG5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIHRoZSBnaXZlbiByYW5nZSwgZXhwYW5kaW5nIGl0IHRvIGNvdmVyIGZ1bGx5IGNvdmVyZWRcbiAgICBwYXJlbnQgbm9kZXMgdW50aWwgYSB2YWxpZCByZXBsYWNlIGlzIGZvdW5kLlxuICAgICovXG4gICAgZGVsZXRlUmFuZ2UoZnJvbSwgdG8pIHtcbiAgICAgICAgZGVsZXRlUmFuZ2UodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU3BsaXQgdGhlIGNvbnRlbnQgaW4gdGhlIGdpdmVuIHJhbmdlIG9mZiBmcm9tIGl0cyBwYXJlbnQsIGlmIHRoZXJlXG4gICAgaXMgc2libGluZyBjb250ZW50IGJlZm9yZSBvciBhZnRlciBpdCwgYW5kIG1vdmUgaXQgdXAgdGhlIHRyZWUgdG9cbiAgICB0aGUgZGVwdGggc3BlY2lmaWVkIGJ5IGB0YXJnZXRgLiBZb3UnbGwgcHJvYmFibHkgd2FudCB0byB1c2VcbiAgICBbYGxpZnRUYXJnZXRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLmxpZnRUYXJnZXQpIHRvIGNvbXB1dGUgYHRhcmdldGAsIHRvIG1ha2VcbiAgICBzdXJlIHRoZSBsaWZ0IGlzIHZhbGlkLlxuICAgICovXG4gICAgbGlmdChyYW5nZSwgdGFyZ2V0KSB7XG4gICAgICAgIGxpZnQodGhpcywgcmFuZ2UsIHRhcmdldCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBKb2luIHRoZSBibG9ja3MgYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvbi4gSWYgZGVwdGggaXMgMiwgdGhlaXJcbiAgICBsYXN0IGFuZCBmaXJzdCBzaWJsaW5ncyBhcmUgYWxzbyBqb2luZWQsIGFuZCBzbyBvbi5cbiAgICAqL1xuICAgIGpvaW4ocG9zLCBkZXB0aCA9IDEpIHtcbiAgICAgICAgam9pbih0aGlzLCBwb3MsIGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFdyYXAgdGhlIGdpdmVuIFtyYW5nZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVSYW5nZSkgaW4gdGhlIGdpdmVuIHNldCBvZiB3cmFwcGVycy5cbiAgICBUaGUgd3JhcHBlcnMgYXJlIGFzc3VtZWQgdG8gYmUgdmFsaWQgaW4gdGhpcyBwb3NpdGlvbiwgYW5kIHNob3VsZFxuICAgIHByb2JhYmx5IGJlIGNvbXB1dGVkIHdpdGggW2BmaW5kV3JhcHBpbmdgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLmZpbmRXcmFwcGluZykuXG4gICAgKi9cbiAgICB3cmFwKHJhbmdlLCB3cmFwcGVycykge1xuICAgICAgICB3cmFwKHRoaXMsIHJhbmdlLCB3cmFwcGVycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIHR5cGUgb2YgYWxsIHRleHRibG9ja3MgKHBhcnRseSkgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AgdG9cbiAgICB0aGUgZ2l2ZW4gbm9kZSB0eXBlIHdpdGggdGhlIGdpdmVuIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBzZXRCbG9ja1R5cGUoZnJvbSwgdG8gPSBmcm9tLCB0eXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICAgICAgc2V0QmxvY2tUeXBlKHRoaXMsIGZyb20sIHRvLCB0eXBlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGFuZ2UgdGhlIHR5cGUsIGF0dHJpYnV0ZXMsIGFuZC9vciBtYXJrcyBvZiB0aGUgbm9kZSBhdCBgcG9zYC5cbiAgICBXaGVuIGB0eXBlYCBpc24ndCBnaXZlbiwgdGhlIGV4aXN0aW5nIG5vZGUgdHlwZSBpcyBwcmVzZXJ2ZWQsXG4gICAgKi9cbiAgICBzZXROb2RlTWFya3VwKHBvcywgdHlwZSwgYXR0cnMgPSBudWxsLCBtYXJrcykge1xuICAgICAgICBzZXROb2RlTWFya3VwKHRoaXMsIHBvcywgdHlwZSwgYXR0cnMsIG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCBhIHNpbmdsZSBhdHRyaWJ1dGUgb24gYSBnaXZlbiBub2RlIHRvIGEgbmV3IHZhbHVlLlxuICAgIFRoZSBgcG9zYCBhZGRyZXNzZXMgdGhlIGRvY3VtZW50IGNvbnRlbnQuIFVzZSBgc2V0RG9jQXR0cmlidXRlYFxuICAgIHRvIHNldCBhdHRyaWJ1dGVzIG9uIHRoZSBkb2N1bWVudCBpdHNlbGYuXG4gICAgKi9cbiAgICBzZXROb2RlQXR0cmlidXRlKHBvcywgYXR0ciwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdGVwKG5ldyBBdHRyU3RlcChwb3MsIGF0dHIsIHZhbHVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgYSBzaW5nbGUgYXR0cmlidXRlIG9uIHRoZSBkb2N1bWVudCB0byBhIG5ldyB2YWx1ZS5cbiAgICAqL1xuICAgIHNldERvY0F0dHJpYnV0ZShhdHRyLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnN0ZXAobmV3IERvY0F0dHJTdGVwKGF0dHIsIHZhbHVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSBtYXJrIHRvIHRoZSBub2RlIGF0IHBvc2l0aW9uIGBwb3NgLlxuICAgICovXG4gICAgYWRkTm9kZU1hcmsocG9zLCBtYXJrKSB7XG4gICAgICAgIHRoaXMuc3RlcChuZXcgQWRkTm9kZU1hcmtTdGVwKHBvcywgbWFyaykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIGEgbWFyayAob3IgYSBtYXJrIG9mIHRoZSBnaXZlbiB0eXBlKSBmcm9tIHRoZSBub2RlIGF0XG4gICAgcG9zaXRpb24gYHBvc2AuXG4gICAgKi9cbiAgICByZW1vdmVOb2RlTWFyayhwb3MsIG1hcmspIHtcbiAgICAgICAgaWYgKCEobWFyayBpbnN0YW5jZW9mIE1hcmspKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZG9jLm5vZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gbm9kZSBhdCBwb3NpdGlvbiBcIiArIHBvcyk7XG4gICAgICAgICAgICBtYXJrID0gbWFyay5pc0luU2V0KG5vZGUubWFya3MpO1xuICAgICAgICAgICAgaWYgKCFtYXJrKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RlcChuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKHBvcywgbWFyaykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU3BsaXQgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBhbmQgb3B0aW9uYWxseSwgaWYgYGRlcHRoYCBpc1xuICAgIGdyZWF0ZXIgdGhhbiBvbmUsIGFueSBudW1iZXIgb2Ygbm9kZXMgYWJvdmUgdGhhdC4gQnkgZGVmYXVsdCwgdGhlXG4gICAgcGFydHMgc3BsaXQgb2ZmIHdpbGwgaW5oZXJpdCB0aGUgbm9kZSB0eXBlIG9mIHRoZSBvcmlnaW5hbCBub2RlLlxuICAgIFRoaXMgY2FuIGJlIGNoYW5nZWQgYnkgcGFzc2luZyBhbiBhcnJheSBvZiB0eXBlcyBhbmQgYXR0cmlidXRlcyB0b1xuICAgIHVzZSBhZnRlciB0aGUgc3BsaXQuXG4gICAgKi9cbiAgICBzcGxpdChwb3MsIGRlcHRoID0gMSwgdHlwZXNBZnRlcikge1xuICAgICAgICBzcGxpdCh0aGlzLCBwb3MsIGRlcHRoLCB0eXBlc0FmdGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCB0aGUgZ2l2ZW4gbWFyayB0byB0aGUgaW5saW5lIGNvbnRlbnQgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AuXG4gICAgKi9cbiAgICBhZGRNYXJrKGZyb20sIHRvLCBtYXJrKSB7XG4gICAgICAgIGFkZE1hcmsodGhpcywgZnJvbSwgdG8sIG1hcmspO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIG1hcmtzIGZyb20gaW5saW5lIG5vZGVzIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLiBXaGVuXG4gICAgYG1hcmtgIGlzIGEgc2luZ2xlIG1hcmssIHJlbW92ZSBwcmVjaXNlbHkgdGhhdCBtYXJrLiBXaGVuIGl0IGlzXG4gICAgYSBtYXJrIHR5cGUsIHJlbW92ZSBhbGwgbWFya3Mgb2YgdGhhdCB0eXBlLiBXaGVuIGl0IGlzIG51bGwsXG4gICAgcmVtb3ZlIGFsbCBtYXJrcyBvZiBhbnkgdHlwZS5cbiAgICAqL1xuICAgIHJlbW92ZU1hcmsoZnJvbSwgdG8sIG1hcmspIHtcbiAgICAgICAgcmVtb3ZlTWFyayh0aGlzLCBmcm9tLCB0bywgbWFyayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmVzIGFsbCBtYXJrcyBhbmQgbm9kZXMgZnJvbSB0aGUgY29udGVudCBvZiB0aGUgbm9kZSBhdFxuICAgIGBwb3NgIHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIGdpdmVuIG5ldyBwYXJlbnQgbm9kZSB0eXBlLiBBY2NlcHRzXG4gICAgYW4gb3B0aW9uYWwgc3RhcnRpbmcgW2NvbnRlbnQgbWF0Y2hdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Db250ZW50TWF0Y2gpIGFzXG4gICAgdGhpcmQgYXJndW1lbnQuXG4gICAgKi9cbiAgICBjbGVhckluY29tcGF0aWJsZShwb3MsIHBhcmVudFR5cGUsIG1hdGNoKSB7XG4gICAgICAgIGNsZWFySW5jb21wYXRpYmxlKHRoaXMsIHBvcywgcGFyZW50VHlwZSwgbWF0Y2gpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmV4cG9ydCB7IEFkZE1hcmtTdGVwLCBBZGROb2RlTWFya1N0ZXAsIEF0dHJTdGVwLCBEb2NBdHRyU3RlcCwgTWFwUmVzdWx0LCBNYXBwaW5nLCBSZW1vdmVNYXJrU3RlcCwgUmVtb3ZlTm9kZU1hcmtTdGVwLCBSZXBsYWNlQXJvdW5kU3RlcCwgUmVwbGFjZVN0ZXAsIFN0ZXAsIFN0ZXBNYXAsIFN0ZXBSZXN1bHQsIFRyYW5zZm9ybSwgVHJhbnNmb3JtRXJyb3IsIGNhbkpvaW4sIGNhblNwbGl0LCBkcm9wUG9pbnQsIGZpbmRXcmFwcGluZywgaW5zZXJ0UG9pbnQsIGpvaW5Qb2ludCwgbGlmdFRhcmdldCwgcmVwbGFjZVN0ZXAgfTtcbiIsICJpbXBvcnQgeyBTbGljZSwgRnJhZ21lbnQsIE1hcmssIE5vZGUgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBSZXBsYWNlU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIFRyYW5zZm9ybSB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5cbmNvbnN0IGNsYXNzZXNCeUlkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuU3VwZXJjbGFzcyBmb3IgZWRpdG9yIHNlbGVjdGlvbnMuIEV2ZXJ5IHNlbGVjdGlvbiB0eXBlIHNob3VsZFxuZXh0ZW5kIHRoaXMuIFNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuKi9cbmNsYXNzIFNlbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgSW5pdGlhbGl6ZSBhIHNlbGVjdGlvbiB3aXRoIHRoZSBoZWFkIGFuZCBhbmNob3IgYW5kIHJhbmdlcy4gSWYgbm9cbiAgICByYW5nZXMgYXJlIGdpdmVuLCBjb25zdHJ1Y3RzIGEgc2luZ2xlIHJhbmdlIGFjcm9zcyBgJGFuY2hvcmAgYW5kXG4gICAgYCRoZWFkYC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSByZXNvbHZlZCBhbmNob3Igb2YgdGhlIHNlbGVjdGlvbiAodGhlIHNpZGUgdGhhdCBzdGF5cyBpblxuICAgIHBsYWNlIHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBtb2RpZmllZCkuXG4gICAgKi9cbiAgICAkYW5jaG9yLCBcbiAgICAvKipcbiAgICBUaGUgcmVzb2x2ZWQgaGVhZCBvZiB0aGUgc2VsZWN0aW9uICh0aGUgc2lkZSB0aGF0IG1vdmVzIHdoZW5cbiAgICB0aGUgc2VsZWN0aW9uIGlzIG1vZGlmaWVkKS5cbiAgICAqL1xuICAgICRoZWFkLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy4kYW5jaG9yID0gJGFuY2hvcjtcbiAgICAgICAgdGhpcy4kaGVhZCA9ICRoZWFkO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcyB8fCBbbmV3IFNlbGVjdGlvblJhbmdlKCRhbmNob3IubWluKCRoZWFkKSwgJGFuY2hvci5tYXgoJGhlYWQpKV07XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzZWxlY3Rpb24ncyBhbmNob3IsIGFzIGFuIHVucmVzb2x2ZWQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgYW5jaG9yKCkgeyByZXR1cm4gdGhpcy4kYW5jaG9yLnBvczsgfVxuICAgIC8qKlxuICAgIFRoZSBzZWxlY3Rpb24ncyBoZWFkLlxuICAgICovXG4gICAgZ2V0IGhlYWQoKSB7IHJldHVybiB0aGlzLiRoZWFkLnBvczsgfVxuICAgIC8qKlxuICAgIFRoZSBsb3dlciBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbiAgICAqL1xuICAgIGdldCBmcm9tKCkgeyByZXR1cm4gdGhpcy4kZnJvbS5wb3M7IH1cbiAgICAvKipcbiAgICBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIHNlbGVjdGlvbidzIG1haW4gcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLiR0by5wb3M7IH1cbiAgICAvKipcbiAgICBUaGUgcmVzb2x2ZWQgbG93ZXIgIGJvdW5kIG9mIHRoZSBzZWxlY3Rpb24ncyBtYWluIHJhbmdlLlxuICAgICovXG4gICAgZ2V0ICRmcm9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXNbMF0uJGZyb207XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSByZXNvbHZlZCB1cHBlciBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbiAgICAqL1xuICAgIGdldCAkdG8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1swXS4kdG87XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gY29udGFpbnMgYW55IGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAocmFuZ2VzW2ldLiRmcm9tLnBvcyAhPSByYW5nZXNbaV0uJHRvLnBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbnRlbnQgb2YgdGhpcyBzZWxlY3Rpb24gYXMgYSBzbGljZS5cbiAgICAqL1xuICAgIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRmcm9tLmRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8sIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIHNsaWNlIG9yLCBpZiBubyBzbGljZSBpcyBnaXZlbixcbiAgICBkZWxldGUgdGhlIHNlbGVjdGlvbi4gV2lsbCBhcHBlbmQgdG8gdGhlIGdpdmVuIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgcmVwbGFjZSh0ciwgY29udGVudCA9IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgIC8vIFB1dCB0aGUgbmV3IHNlbGVjdGlvbiBhdCB0aGUgcG9zaXRpb24gYWZ0ZXIgdGhlIGluc2VydGVkXG4gICAgICAgIC8vIGNvbnRlbnQuIFdoZW4gdGhhdCBlbmRlZCBpbiBhbiBpbmxpbmUgbm9kZSwgc2VhcmNoIGJhY2t3YXJkcyxcbiAgICAgICAgLy8gdG8gZ2V0IHRoZSBwb3NpdGlvbiBhZnRlciB0aGF0IG5vZGUuIElmIG5vdCwgc2VhcmNoIGZvcndhcmQuXG4gICAgICAgIGxldCBsYXN0Tm9kZSA9IGNvbnRlbnQuY29udGVudC5sYXN0Q2hpbGQsIGxhc3RQYXJlbnQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQub3BlbkVuZDsgaSsrKSB7XG4gICAgICAgICAgICBsYXN0UGFyZW50ID0gbGFzdE5vZGU7XG4gICAgICAgICAgICBsYXN0Tm9kZSA9IGxhc3ROb2RlLmxhc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aCwgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV0sIG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgICAgICAgICAgdHIucmVwbGFjZVJhbmdlKG1hcHBpbmcubWFwKCRmcm9tLnBvcyksIG1hcHBpbmcubWFwKCR0by5wb3MpLCBpID8gU2xpY2UuZW1wdHkgOiBjb250ZW50KTtcbiAgICAgICAgICAgIGlmIChpID09IDApXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIG1hcEZyb20sIChsYXN0Tm9kZSA/IGxhc3ROb2RlLmlzSW5saW5lIDogbGFzdFBhcmVudCAmJiBsYXN0UGFyZW50LmlzVGV4dGJsb2NrKSA/IC0xIDogMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIG5vZGUsIGFwcGVuZGluZyB0aGUgY2hhbmdlc1xuICAgIHRvIHRoZSBnaXZlbiB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHJlcGxhY2VXaXRoKHRyLCBub2RlKSB7XG4gICAgICAgIGxldCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoLCByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXSwgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwKCRmcm9tLnBvcyksIHRvID0gbWFwcGluZy5tYXAoJHRvLnBvcyk7XG4gICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgIHRyLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VSYW5nZVdpdGgoZnJvbSwgdG8sIG5vZGUpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBtYXBGcm9tLCBub2RlLmlzSW5saW5lID8gLTEgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGEgdmFsaWQgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gc3RhcnRpbmcgYXQgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24gYW5kIHNlYXJjaGluZyBiYWNrIGlmIGBkaXJgIGlzIG5lZ2F0aXZlLCBhbmQgZm9yd2FyZCBpZlxuICAgIHBvc2l0aXZlLiBXaGVuIGB0ZXh0T25seWAgaXMgdHJ1ZSwgb25seSBjb25zaWRlciBjdXJzb3JcbiAgICBzZWxlY3Rpb25zLiBXaWxsIHJldHVybiBudWxsIHdoZW4gbm8gdmFsaWQgc2VsZWN0aW9uIHBvc2l0aW9uIGlzXG4gICAgZm91bmQuXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZEZyb20oJHBvcywgZGlyLCB0ZXh0T25seSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBpbm5lciA9ICRwb3MucGFyZW50LmlubGluZUNvbnRlbnQgPyBuZXcgVGV4dFNlbGVjdGlvbigkcG9zKVxuICAgICAgICAgICAgOiBmaW5kU2VsZWN0aW9uSW4oJHBvcy5ub2RlKDApLCAkcG9zLnBhcmVudCwgJHBvcy5wb3MsICRwb3MuaW5kZXgoKSwgZGlyLCB0ZXh0T25seSk7XG4gICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoIC0gMTsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gZGlyIDwgMFxuICAgICAgICAgICAgICAgID8gZmluZFNlbGVjdGlvbkluKCRwb3Mubm9kZSgwKSwgJHBvcy5ub2RlKGRlcHRoKSwgJHBvcy5iZWZvcmUoZGVwdGggKyAxKSwgJHBvcy5pbmRleChkZXB0aCksIGRpciwgdGV4dE9ubHkpXG4gICAgICAgICAgICAgICAgOiBmaW5kU2VsZWN0aW9uSW4oJHBvcy5ub2RlKDApLCAkcG9zLm5vZGUoZGVwdGgpLCAkcG9zLmFmdGVyKGRlcHRoICsgMSksICRwb3MuaW5kZXgoZGVwdGgpICsgMSwgZGlyLCB0ZXh0T25seSk7XG4gICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGEgdmFsaWQgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gbmVhciB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbi4gU2VhcmNoZXMgZm9yd2FyZCBmaXJzdCBieSBkZWZhdWx0LCBidXQgaWYgYGJpYXNgIGlzXG4gICAgbmVnYXRpdmUsIGl0IHdpbGwgc2VhcmNoIGJhY2t3YXJkcyBmaXJzdC5cbiAgICAqL1xuICAgIHN0YXRpYyBuZWFyKCRwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRGcm9tKCRwb3MsIGJpYXMpIHx8IHRoaXMuZmluZEZyb20oJHBvcywgLWJpYXMpIHx8IG5ldyBBbGxTZWxlY3Rpb24oJHBvcy5ub2RlKDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gY2xvc2VzdCB0byB0aGUgc3RhcnQgb2ZcbiAgICB0aGUgZ2l2ZW4gZG9jdW1lbnQuIFdpbGwgcmV0dXJuIGFuXG4gICAgW2BBbGxTZWxlY3Rpb25gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuQWxsU2VsZWN0aW9uKSBpZiBubyB2YWxpZCBwb3NpdGlvblxuICAgIGV4aXN0cy5cbiAgICAqL1xuICAgIHN0YXRpYyBhdFN0YXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gZmluZFNlbGVjdGlvbkluKGRvYywgZG9jLCAwLCAwLCAxKSB8fCBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGN1cnNvciBvciBsZWFmIG5vZGUgc2VsZWN0aW9uIGNsb3Nlc3QgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBhdEVuZChkb2MpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRTZWxlY3Rpb25Jbihkb2MsIGRvYywgZG9jLmNvbnRlbnQuc2l6ZSwgZG9jLmNoaWxkQ291bnQsIC0xKSB8fCBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgc2VsZWN0aW9uLiBNdXN0IGJlXG4gICAgaW1wbGVtZW50ZWQgZm9yIGN1c3RvbSBjbGFzc2VzIChhcyBhIHN0YXRpYyBjbGFzcyBtZXRob2QpLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIWpzb24udHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgU2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgY2xzID0gY2xhc3Nlc0J5SWRbanNvbi50eXBlXTtcbiAgICAgICAgaWYgKCFjbHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gc2VsZWN0aW9uIHR5cGUgJHtqc29uLnR5cGV9IGRlZmluZWRgKTtcbiAgICAgICAgcmV0dXJuIGNscy5mcm9tSlNPTihkb2MsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBUbyBiZSBhYmxlIHRvIGRlc2VyaWFsaXplIHNlbGVjdGlvbnMgZnJvbSBKU09OLCBjdXN0b20gc2VsZWN0aW9uXG4gICAgY2xhc3NlcyBtdXN0IHJlZ2lzdGVyIHRoZW1zZWx2ZXMgd2l0aCBhbiBJRCBzdHJpbmcsIHNvIHRoYXQgdGhleVxuICAgIGNhbiBiZSBkaXNhbWJpZ3VhdGVkLiBUcnkgdG8gcGljayBzb21ldGhpbmcgdGhhdCdzIHVubGlrZWx5IHRvXG4gICAgY2xhc2ggd2l0aCBjbGFzc2VzIGZyb20gb3RoZXIgbW9kdWxlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBqc29uSUQoaWQsIHNlbGVjdGlvbkNsYXNzKSB7XG4gICAgICAgIGlmIChpZCBpbiBjbGFzc2VzQnlJZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRHVwbGljYXRlIHVzZSBvZiBzZWxlY3Rpb24gSlNPTiBJRCBcIiArIGlkKTtcbiAgICAgICAgY2xhc3Nlc0J5SWRbaWRdID0gc2VsZWN0aW9uQ2xhc3M7XG4gICAgICAgIHNlbGVjdGlvbkNsYXNzLnByb3RvdHlwZS5qc29uSUQgPSBpZDtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbkNsYXNzO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbYm9va21hcmtdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25Cb29rbWFyaykgZm9yIHRoaXMgc2VsZWN0aW9uLFxuICAgIHdoaWNoIGlzIGEgdmFsdWUgdGhhdCBjYW4gYmUgbWFwcGVkIHdpdGhvdXQgaGF2aW5nIGFjY2VzcyB0byBhXG4gICAgY3VycmVudCBkb2N1bWVudCwgYW5kIGxhdGVyIHJlc29sdmVkIHRvIGEgcmVhbCBzZWxlY3Rpb24gZm9yIGFcbiAgICBnaXZlbiBkb2N1bWVudCBhZ2Fpbi4gKFRoaXMgaXMgdXNlZCBtb3N0bHkgYnkgdGhlIGhpc3RvcnkgdG9cbiAgICB0cmFjayBhbmQgcmVzdG9yZSBvbGQgc2VsZWN0aW9ucy4pIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mXG4gICAgdGhpcyBtZXRob2QganVzdCBjb252ZXJ0cyB0aGUgc2VsZWN0aW9uIHRvIGEgdGV4dCBzZWxlY3Rpb24gYW5kXG4gICAgcmV0dXJucyB0aGUgYm9va21hcmsgZm9yIHRoYXQuXG4gICAgKi9cbiAgICBnZXRCb29rbWFyaygpIHtcbiAgICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uYmV0d2Vlbih0aGlzLiRhbmNob3IsIHRoaXMuJGhlYWQpLmdldEJvb2ttYXJrKCk7XG4gICAgfVxufVxuU2VsZWN0aW9uLnByb3RvdHlwZS52aXNpYmxlID0gdHJ1ZTtcbi8qKlxuUmVwcmVzZW50cyBhIHNlbGVjdGVkIHJhbmdlIGluIGEgZG9jdW1lbnQuXG4qL1xuY2xhc3MgU2VsZWN0aW9uUmFuZ2Uge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJhbmdlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgICRmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgJHRvKSB7XG4gICAgICAgIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgICAgICAgdGhpcy4kdG8gPSAkdG87XG4gICAgfVxufVxubGV0IHdhcm5lZEFib3V0VGV4dFNlbGVjdGlvbiA9IGZhbHNlO1xuZnVuY3Rpb24gY2hlY2tUZXh0U2VsZWN0aW9uKCRwb3MpIHtcbiAgICBpZiAoIXdhcm5lZEFib3V0VGV4dFNlbGVjdGlvbiAmJiAhJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICB3YXJuZWRBYm91dFRleHRTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb25zb2xlW1wid2FyblwiXShcIlRleHRTZWxlY3Rpb24gZW5kcG9pbnQgbm90IHBvaW50aW5nIGludG8gYSBub2RlIHdpdGggaW5saW5lIGNvbnRlbnQgKFwiICsgJHBvcy5wYXJlbnQudHlwZS5uYW1lICsgXCIpXCIpO1xuICAgIH1cbn1cbi8qKlxuQSB0ZXh0IHNlbGVjdGlvbiByZXByZXNlbnRzIGEgY2xhc3NpY2FsIGVkaXRvciBzZWxlY3Rpb24sIHdpdGggYVxuaGVhZCAodGhlIG1vdmluZyBzaWRlKSBhbmQgYW5jaG9yIChpbW1vYmlsZSBzaWRlKSwgYm90aCBvZiB3aGljaFxucG9pbnQgaW50byB0ZXh0YmxvY2sgbm9kZXMuIEl0IGNhbiBiZSBlbXB0eSAoYSByZWd1bGFyIGN1cnNvclxucG9zaXRpb24pLlxuKi9cbmNsYXNzIFRleHRTZWxlY3Rpb24gZXh0ZW5kcyBTZWxlY3Rpb24ge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIHRleHQgc2VsZWN0aW9uIGJldHdlZW4gdGhlIGdpdmVuIHBvaW50cy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCRhbmNob3IsICRoZWFkID0gJGFuY2hvcikge1xuICAgICAgICBjaGVja1RleHRTZWxlY3Rpb24oJGFuY2hvcik7XG4gICAgICAgIGNoZWNrVGV4dFNlbGVjdGlvbigkaGVhZCk7XG4gICAgICAgIHN1cGVyKCRhbmNob3IsICRoZWFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIHJlc29sdmVkIHBvc2l0aW9uIGlmIHRoaXMgaXMgYSBjdXJzb3Igc2VsZWN0aW9uIChhblxuICAgIGVtcHR5IHRleHQgc2VsZWN0aW9uKSwgYW5kIG51bGwgb3RoZXJ3aXNlLlxuICAgICovXG4gICAgZ2V0ICRjdXJzb3IoKSB7IHJldHVybiB0aGlzLiRhbmNob3IucG9zID09IHRoaXMuJGhlYWQucG9zID8gdGhpcy4kaGVhZCA6IG51bGw7IH1cbiAgICBtYXAoZG9jLCBtYXBwaW5nKSB7XG4gICAgICAgIGxldCAkaGVhZCA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICAgICAgICBpZiAoISRoZWFkLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRoZWFkKTtcbiAgICAgICAgbGV0ICRhbmNob3IgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLmFuY2hvcikpO1xuICAgICAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb24oJGFuY2hvci5wYXJlbnQuaW5saW5lQ29udGVudCA/ICRhbmNob3IgOiAkaGVhZCwgJGhlYWQpO1xuICAgIH1cbiAgICByZXBsYWNlKHRyLCBjb250ZW50ID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgc3VwZXIucmVwbGFjZSh0ciwgY29udGVudCk7XG4gICAgICAgIGlmIChjb250ZW50ID09IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSB0aGlzLiRmcm9tLm1hcmtzQWNyb3NzKHRoaXMuJHRvKTtcbiAgICAgICAgICAgIGlmIChtYXJrcylcbiAgICAgICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhtYXJrcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiAmJiBvdGhlci5hbmNob3IgPT0gdGhpcy5hbmNob3IgJiYgb3RoZXIuaGVhZCA9PSB0aGlzLmhlYWQ7XG4gICAgfVxuICAgIGdldEJvb2ttYXJrKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHRCb29rbWFyayh0aGlzLmFuY2hvciwgdGhpcy5oZWFkKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInRleHRcIiwgYW5jaG9yOiB0aGlzLmFuY2hvciwgaGVhZDogdGhpcy5oZWFkIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uYW5jaG9yICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaGVhZCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBUZXh0U2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb24oZG9jLnJlc29sdmUoanNvbi5hbmNob3IpLCBkb2MucmVzb2x2ZShqc29uLmhlYWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGV4dCBzZWxlY3Rpb24gZnJvbSBub24tcmVzb2x2ZWQgcG9zaXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGFuY2hvciwgaGVhZCA9IGFuY2hvcikge1xuICAgICAgICBsZXQgJGFuY2hvciA9IGRvYy5yZXNvbHZlKGFuY2hvcik7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcygkYW5jaG9yLCBoZWFkID09IGFuY2hvciA/ICRhbmNob3IgOiBkb2MucmVzb2x2ZShoZWFkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIHRleHQgc2VsZWN0aW9uIHRoYXQgc3BhbnMgdGhlIGdpdmVuIHBvc2l0aW9ucyBvciwgaWZcbiAgICB0aGV5IGFyZW4ndCB0ZXh0IHBvc2l0aW9ucywgZmluZCBhIHRleHQgc2VsZWN0aW9uIG5lYXIgdGhlbS5cbiAgICBgYmlhc2AgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBtZXRob2Qgc2VhcmNoZXMgZm9yd2FyZCAoZGVmYXVsdClcbiAgICBvciBiYWNrd2FyZHMgKG5lZ2F0aXZlIG51bWJlcikgZmlyc3QuIFdpbGwgZmFsbCBiYWNrIHRvIGNhbGxpbmdcbiAgICBbYFNlbGVjdGlvbi5uZWFyYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvbl5uZWFyKSB3aGVuIHRoZSBkb2N1bWVudFxuICAgIGRvZXNuJ3QgY29udGFpbiBhIHZhbGlkIHRleHQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgYmV0d2VlbigkYW5jaG9yLCAkaGVhZCwgYmlhcykge1xuICAgICAgICBsZXQgZFBvcyA9ICRhbmNob3IucG9zIC0gJGhlYWQucG9zO1xuICAgICAgICBpZiAoIWJpYXMgfHwgZFBvcylcbiAgICAgICAgICAgIGJpYXMgPSBkUG9zID49IDAgPyAxIDogLTE7XG4gICAgICAgIGlmICghJGhlYWQucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IFNlbGVjdGlvbi5maW5kRnJvbSgkaGVhZCwgYmlhcywgdHJ1ZSkgfHwgU2VsZWN0aW9uLmZpbmRGcm9tKCRoZWFkLCAtYmlhcywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgJGhlYWQgPSBmb3VuZC4kaGVhZDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJGhlYWQsIGJpYXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghJGFuY2hvci5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICAgICAgaWYgKGRQb3MgPT0gMCkge1xuICAgICAgICAgICAgICAgICRhbmNob3IgPSAkaGVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICRhbmNob3IgPSAoU2VsZWN0aW9uLmZpbmRGcm9tKCRhbmNob3IsIC1iaWFzLCB0cnVlKSB8fCBTZWxlY3Rpb24uZmluZEZyb20oJGFuY2hvciwgYmlhcywgdHJ1ZSkpLiRhbmNob3I7XG4gICAgICAgICAgICAgICAgaWYgKCgkYW5jaG9yLnBvcyA8ICRoZWFkLnBvcykgIT0gKGRQb3MgPCAwKSlcbiAgICAgICAgICAgICAgICAgICAgJGFuY2hvciA9ICRoZWFkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdGlvbigkYW5jaG9yLCAkaGVhZCk7XG4gICAgfVxufVxuU2VsZWN0aW9uLmpzb25JRChcInRleHRcIiwgVGV4dFNlbGVjdGlvbik7XG5jbGFzcyBUZXh0Qm9va21hcmsge1xuICAgIGNvbnN0cnVjdG9yKGFuY2hvciwgaGVhZCkge1xuICAgICAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgICAgdGhpcy5oZWFkID0gaGVhZDtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Qm9va21hcmsobWFwcGluZy5tYXAodGhpcy5hbmNob3IpLCBtYXBwaW5nLm1hcCh0aGlzLmhlYWQpKTtcbiAgICB9XG4gICAgcmVzb2x2ZShkb2MpIHtcbiAgICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uYmV0d2Vlbihkb2MucmVzb2x2ZSh0aGlzLmFuY2hvciksIGRvYy5yZXNvbHZlKHRoaXMuaGVhZCkpO1xuICAgIH1cbn1cbi8qKlxuQSBub2RlIHNlbGVjdGlvbiBpcyBhIHNlbGVjdGlvbiB0aGF0IHBvaW50cyBhdCBhIHNpbmdsZSBub2RlLiBBbGxcbm5vZGVzIG1hcmtlZCBbc2VsZWN0YWJsZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLnNlbGVjdGFibGUpIGNhbiBiZSB0aGVcbnRhcmdldCBvZiBhIG5vZGUgc2VsZWN0aW9uLiBJbiBzdWNoIGEgc2VsZWN0aW9uLCBgZnJvbWAgYW5kIGB0b2BcbnBvaW50IGRpcmVjdGx5IGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHNlbGVjdGVkIG5vZGUsIGBhbmNob3JgIGVxdWFsc1xuYGZyb21gLCBhbmQgYGhlYWRgIGVxdWFscyBgdG9gLi5cbiovXG5jbGFzcyBOb2RlU2VsZWN0aW9uIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBub2RlIHNlbGVjdGlvbi4gRG9lcyBub3QgdmVyaWZ5IHRoZSB2YWxpZGl0eSBvZiBpdHNcbiAgICBhcmd1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCRwb3MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgbGV0ICRlbmQgPSAkcG9zLm5vZGUoMCkucmVzb2x2ZSgkcG9zLnBvcyArIG5vZGUubm9kZVNpemUpO1xuICAgICAgICBzdXBlcigkcG9zLCAkZW5kKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgbWFwKGRvYywgbWFwcGluZykge1xuICAgICAgICBsZXQgeyBkZWxldGVkLCBwb3MgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuYW5jaG9yKTtcbiAgICAgICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgICAgICBpZiAoZGVsZXRlZClcbiAgICAgICAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpO1xuICAgIH1cbiAgICBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odGhpcy5ub2RlKSwgMCwgMCk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgb3RoZXIuYW5jaG9yID09IHRoaXMuYW5jaG9yO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibm9kZVwiLCBhbmNob3I6IHRoaXMuYW5jaG9yIH07XG4gICAgfVxuICAgIGdldEJvb2ttYXJrKCkgeyByZXR1cm4gbmV3IE5vZGVCb29rbWFyayh0aGlzLmFuY2hvcik7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmFuY2hvciAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBOb2RlU2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oZG9jLnJlc29sdmUoanNvbi5hbmNob3IpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBzZWxlY3Rpb24gZnJvbSBub24tcmVzb2x2ZWQgcG9zaXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGZyb20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKGRvYy5yZXNvbHZlKGZyb20pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBub2RlIG1heSBiZSBzZWxlY3RlZCBhcyBhIG5vZGVcbiAgICBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgaXNTZWxlY3RhYmxlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICFub2RlLmlzVGV4dCAmJiBub2RlLnR5cGUuc3BlYy5zZWxlY3RhYmxlICE9PSBmYWxzZTtcbiAgICB9XG59XG5Ob2RlU2VsZWN0aW9uLnByb3RvdHlwZS52aXNpYmxlID0gZmFsc2U7XG5TZWxlY3Rpb24uanNvbklEKFwibm9kZVwiLCBOb2RlU2VsZWN0aW9uKTtcbmNsYXNzIE5vZGVCb29rbWFyayB7XG4gICAgY29uc3RydWN0b3IoYW5jaG9yKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgeyBkZWxldGVkLCBwb3MgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuYW5jaG9yKTtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZWQgPyBuZXcgVGV4dEJvb2ttYXJrKHBvcywgcG9zKSA6IG5ldyBOb2RlQm9va21hcmsocG9zKTtcbiAgICB9XG4gICAgcmVzb2x2ZShkb2MpIHtcbiAgICAgICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZSh0aGlzLmFuY2hvciksIG5vZGUgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgaWYgKG5vZGUgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oJHBvcyk7XG4gICAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICB9XG59XG4vKipcbkEgc2VsZWN0aW9uIHR5cGUgdGhhdCByZXByZXNlbnRzIHNlbGVjdGluZyB0aGUgd2hvbGUgZG9jdW1lbnRcbih3aGljaCBjYW4gbm90IG5lY2Vzc2FyaWx5IGJlIGV4cHJlc3NlZCB3aXRoIGEgdGV4dCBzZWxlY3Rpb24sIHdoZW5cbnRoZXJlIGFyZSBmb3IgZXhhbXBsZSBsZWFmIGJsb2NrIG5vZGVzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgdGhlXG5kb2N1bWVudCkuXG4qL1xuY2xhc3MgQWxsU2VsZWN0aW9uIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gYWxsLXNlbGVjdGlvbiBvdmVyIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRvYykge1xuICAgICAgICBzdXBlcihkb2MucmVzb2x2ZSgwKSwgZG9jLnJlc29sdmUoZG9jLmNvbnRlbnQuc2l6ZSkpO1xuICAgIH1cbiAgICByZXBsYWNlKHRyLCBjb250ZW50ID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgICAgIHRyLmRlbGV0ZSgwLCB0ci5kb2MuY29udGVudC5zaXplKTtcbiAgICAgICAgICAgIGxldCBzZWwgPSBTZWxlY3Rpb24uYXRTdGFydCh0ci5kb2MpO1xuICAgICAgICAgICAgaWYgKCFzZWwuZXEodHIuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLnJlcGxhY2UodHIsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHsgcmV0dXJuIHsgdHlwZTogXCJhbGxcIiB9OyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7IH1cbiAgICBtYXAoZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7IH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb247IH1cbiAgICBnZXRCb29rbWFyaygpIHsgcmV0dXJuIEFsbEJvb2ttYXJrOyB9XG59XG5TZWxlY3Rpb24uanNvbklEKFwiYWxsXCIsIEFsbFNlbGVjdGlvbik7XG5jb25zdCBBbGxCb29rbWFyayA9IHtcbiAgICBtYXAoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgIHJlc29sdmUoZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7IH1cbn07XG4vLyBGSVhNRSB3ZSdsbCBuZWVkIHNvbWUgYXdhcmVuZXNzIG9mIHRleHQgZGlyZWN0aW9uIHdoZW4gc2Nhbm5pbmcgZm9yIHNlbGVjdGlvbnNcbi8vIFRyeSB0byBmaW5kIGEgc2VsZWN0aW9uIGluc2lkZSB0aGUgZ2l2ZW4gbm9kZS4gYHBvc2AgcG9pbnRzIGF0IHRoZVxuLy8gcG9zaXRpb24gd2hlcmUgdGhlIHNlYXJjaCBzdGFydHMuIFdoZW4gYHRleHRgIGlzIHRydWUsIG9ubHkgcmV0dXJuXG4vLyB0ZXh0IHNlbGVjdGlvbnMuXG5mdW5jdGlvbiBmaW5kU2VsZWN0aW9uSW4oZG9jLCBub2RlLCBwb3MsIGluZGV4LCBkaXIsIHRleHQgPSBmYWxzZSkge1xuICAgIGlmIChub2RlLmlubGluZUNvbnRlbnQpXG4gICAgICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHBvcyk7XG4gICAgZm9yIChsZXQgaSA9IGluZGV4IC0gKGRpciA+IDAgPyAwIDogMSk7IGRpciA+IDAgPyBpIDwgbm9kZS5jaGlsZENvdW50IDogaSA+PSAwOyBpICs9IGRpcikge1xuICAgICAgICBsZXQgY2hpbGQgPSBub2RlLmNoaWxkKGkpO1xuICAgICAgICBpZiAoIWNoaWxkLmlzQXRvbSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gZmluZFNlbGVjdGlvbkluKGRvYywgY2hpbGQsIHBvcyArIGRpciwgZGlyIDwgMCA/IGNoaWxkLmNoaWxkQ291bnQgOiAwLCBkaXIsIHRleHQpO1xuICAgICAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGV4dCAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShjaGlsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIHBvcyAtIChkaXIgPCAwID8gY2hpbGQubm9kZVNpemUgOiAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGNoaWxkLm5vZGVTaXplICogZGlyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBzdGFydExlbiwgYmlhcykge1xuICAgIGxldCBsYXN0ID0gdHIuc3RlcHMubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA8IHN0YXJ0TGVuKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHN0ZXAgPSB0ci5zdGVwc1tsYXN0XTtcbiAgICBpZiAoIShzdGVwIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXAgfHwgc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VBcm91bmRTdGVwKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbbGFzdF0sIGVuZDtcbiAgICBtYXAuZm9yRWFjaCgoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSA9PiB7IGlmIChlbmQgPT0gbnVsbClcbiAgICAgICAgZW5kID0gbmV3VG87IH0pO1xuICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShlbmQpLCBiaWFzKSk7XG59XG5cbmNvbnN0IFVQREFURURfU0VMID0gMSwgVVBEQVRFRF9NQVJLUyA9IDIsIFVQREFURURfU0NST0xMID0gNDtcbi8qKlxuQW4gZWRpdG9yIHN0YXRlIHRyYW5zYWN0aW9uLCB3aGljaCBjYW4gYmUgYXBwbGllZCB0byBhIHN0YXRlIHRvXG5jcmVhdGUgYW4gdXBkYXRlZCBzdGF0ZS4gVXNlXG5bYEVkaXRvclN0YXRlLnRyYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRyKSB0byBjcmVhdGUgYW4gaW5zdGFuY2UuXG5cblRyYW5zYWN0aW9ucyB0cmFjayBjaGFuZ2VzIHRvIHRoZSBkb2N1bWVudCAodGhleSBhcmUgYSBzdWJjbGFzcyBvZlxuW2BUcmFuc2Zvcm1gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlRyYW5zZm9ybSkpLCBidXQgYWxzbyBvdGhlciBzdGF0ZSBjaGFuZ2VzLFxubGlrZSBzZWxlY3Rpb24gdXBkYXRlcyBhbmQgYWRqdXN0bWVudHMgb2YgdGhlIHNldCBvZiBbc3RvcmVkXG5tYXJrc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnN0b3JlZE1hcmtzKS4gSW4gYWRkaXRpb24sIHlvdSBjYW4gc3RvcmVcbm1ldGFkYXRhIHByb3BlcnRpZXMgaW4gYSB0cmFuc2FjdGlvbiwgd2hpY2ggYXJlIGV4dHJhIHBpZWNlcyBvZlxuaW5mb3JtYXRpb24gdGhhdCBjbGllbnQgY29kZSBvciBwbHVnaW5zIGNhbiB1c2UgdG8gZGVzY3JpYmUgd2hhdCBhXG50cmFuc2FjdGlvbiByZXByZXNlbnRzLCBzbyB0aGF0IHRoZXkgY2FuIHVwZGF0ZSB0aGVpciBbb3duXG5zdGF0ZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRmllbGQpIGFjY29yZGluZ2x5LlxuXG5UaGUgW2VkaXRvciB2aWV3XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3KSB1c2VzIGEgZmV3IG1ldGFkYXRhXG5wcm9wZXJ0aWVzOiBpdCB3aWxsIGF0dGFjaCBhIHByb3BlcnR5IGBcInBvaW50ZXJcImAgd2l0aCB0aGUgdmFsdWVcbmB0cnVlYCB0byBzZWxlY3Rpb24gdHJhbnNhY3Rpb25zIGRpcmVjdGx5IGNhdXNlZCBieSBtb3VzZSBvciB0b3VjaFxuaW5wdXQsIGEgYFwiY29tcG9zaXRpb25cImAgcHJvcGVydHkgaG9sZGluZyBhbiBJRCBpZGVudGlmeWluZyB0aGVcbmNvbXBvc2l0aW9uIHRoYXQgY2F1c2VkIGl0IHRvIHRyYW5zYWN0aW9ucyBjYXVzZWQgYnkgY29tcG9zZWQgRE9NXG5pbnB1dCwgYW5kIGEgYFwidWlFdmVudFwiYCBwcm9wZXJ0eSBvZiB0aGF0IG1heSBiZSBgXCJwYXN0ZVwiYCxcbmBcImN1dFwiYCwgb3IgYFwiZHJvcFwiYC5cbiovXG5jbGFzcyBUcmFuc2FjdGlvbiBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdGF0ZSkge1xuICAgICAgICBzdXBlcihzdGF0ZS5kb2MpO1xuICAgICAgICAvLyBUaGUgc3RlcCBjb3VudCBmb3Igd2hpY2ggdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIHZhbGlkLlxuICAgICAgICB0aGlzLmN1clNlbGVjdGlvbkZvciA9IDA7XG4gICAgICAgIC8vIEJpdGZpZWxkIHRvIHRyYWNrIHdoaWNoIGFzcGVjdHMgb2YgdGhlIHN0YXRlIHdlcmUgdXBkYXRlZCBieVxuICAgICAgICAvLyB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAgICB0aGlzLnVwZGF0ZWQgPSAwO1xuICAgICAgICAvLyBPYmplY3QgdXNlZCB0byBzdG9yZSBtZXRhZGF0YSBwcm9wZXJ0aWVzIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgIHRoaXMubWV0YSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMudGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLnN0b3JlZE1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSB0cmFuc2FjdGlvbidzIGN1cnJlbnQgc2VsZWN0aW9uLiBUaGlzIGRlZmF1bHRzIHRvIHRoZSBlZGl0b3JcbiAgICBzZWxlY3Rpb24gW21hcHBlZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvbi5tYXApIHRocm91Z2ggdGhlIHN0ZXBzIGluIHRoZVxuICAgIHRyYW5zYWN0aW9uLCBidXQgY2FuIGJlIG92ZXJ3cml0dGVuIHdpdGhcbiAgICBbYHNldFNlbGVjdGlvbmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zZXRTZWxlY3Rpb24pLlxuICAgICovXG4gICAgZ2V0IHNlbGVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyU2VsZWN0aW9uRm9yIDwgdGhpcy5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uID0gdGhpcy5jdXJTZWxlY3Rpb24ubWFwKHRoaXMuZG9jLCB0aGlzLm1hcHBpbmcuc2xpY2UodGhpcy5jdXJTZWxlY3Rpb25Gb3IpKTtcbiAgICAgICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uRm9yID0gdGhpcy5zdGVwcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyU2VsZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHRyYW5zYWN0aW9uJ3MgY3VycmVudCBzZWxlY3Rpb24uIFdpbGwgZGV0ZXJtaW5lIHRoZVxuICAgIHNlbGVjdGlvbiB0aGF0IHRoZSBlZGl0b3IgZ2V0cyB3aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyBhcHBsaWVkLlxuICAgICovXG4gICAgc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAoc2VsZWN0aW9uLiRmcm9tLmRvYyAhPSB0aGlzLmRvYylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2VsZWN0aW9uIHBhc3NlZCB0byBzZXRTZWxlY3Rpb24gbXVzdCBwb2ludCBhdCB0aGUgY3VycmVudCBkb2N1bWVudFwiKTtcbiAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uRm9yID0gdGhpcy5zdGVwcy5sZW5ndGg7XG4gICAgICAgIHRoaXMudXBkYXRlZCA9ICh0aGlzLnVwZGF0ZWQgfCBVUERBVEVEX1NFTCkgJiB+VVBEQVRFRF9NQVJLUztcbiAgICAgICAgdGhpcy5zdG9yZWRNYXJrcyA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gd2FzIGV4cGxpY2l0bHkgdXBkYXRlZCBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZ2V0IHNlbGVjdGlvblNldCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnVwZGF0ZWQgJiBVUERBVEVEX1NFTCkgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIGN1cnJlbnQgc3RvcmVkIG1hcmtzLlxuICAgICovXG4gICAgc2V0U3RvcmVkTWFya3MobWFya3MpIHtcbiAgICAgICAgdGhpcy5zdG9yZWRNYXJrcyA9IG1hcmtzO1xuICAgICAgICB0aGlzLnVwZGF0ZWQgfD0gVVBEQVRFRF9NQVJLUztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIE1ha2Ugc3VyZSB0aGUgY3VycmVudCBzdG9yZWQgbWFya3Mgb3IsIGlmIHRoYXQgaXMgbnVsbCwgdGhlIG1hcmtzXG4gICAgYXQgdGhlIHNlbGVjdGlvbiwgbWF0Y2ggdGhlIGdpdmVuIHNldCBvZiBtYXJrcy4gRG9lcyBub3RoaW5nIGlmXG4gICAgdGhpcyBpcyBhbHJlYWR5IHRoZSBjYXNlLlxuICAgICovXG4gICAgZW5zdXJlTWFya3MobWFya3MpIHtcbiAgICAgICAgaWYgKCFNYXJrLnNhbWVTZXQodGhpcy5zdG9yZWRNYXJrcyB8fCB0aGlzLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpLCBtYXJrcykpXG4gICAgICAgICAgICB0aGlzLnNldFN0b3JlZE1hcmtzKG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIG1hcmsgdG8gdGhlIHNldCBvZiBzdG9yZWQgbWFya3MuXG4gICAgKi9cbiAgICBhZGRTdG9yZWRNYXJrKG1hcmspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlTWFya3MobWFyay5hZGRUb1NldCh0aGlzLnN0b3JlZE1hcmtzIHx8IHRoaXMuc2VsZWN0aW9uLiRoZWFkLm1hcmtzKCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIGEgbWFyayBvciBtYXJrIHR5cGUgZnJvbSB0aGUgc2V0IG9mIHN0b3JlZCBtYXJrcy5cbiAgICAqL1xuICAgIHJlbW92ZVN0b3JlZE1hcmsobWFyaykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVNYXJrcyhtYXJrLnJlbW92ZUZyb21TZXQodGhpcy5zdG9yZWRNYXJrcyB8fCB0aGlzLnNlbGVjdGlvbi4kaGVhZC5tYXJrcygpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHN0b3JlZCBtYXJrcyB3ZXJlIGV4cGxpY2l0bHkgc2V0IGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZ2V0IHN0b3JlZE1hcmtzU2V0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudXBkYXRlZCAmIFVQREFURURfTUFSS1MpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRTdGVwKHN0ZXAsIGRvYykge1xuICAgICAgICBzdXBlci5hZGRTdGVwKHN0ZXAsIGRvYyk7XG4gICAgICAgIHRoaXMudXBkYXRlZCA9IHRoaXMudXBkYXRlZCAmIH5VUERBVEVEX01BUktTO1xuICAgICAgICB0aGlzLnN0b3JlZE1hcmtzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB0aW1lc3RhbXAgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHNldFRpbWUodGltZSkge1xuICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgY3VycmVudCBzZWxlY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gc2xpY2UuXG4gICAgKi9cbiAgICByZXBsYWNlU2VsZWN0aW9uKHNsaWNlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnJlcGxhY2UodGhpcywgc2xpY2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIG5vZGUuIFdoZW4gYGluaGVyaXRNYXJrc2AgaXNcbiAgICB0cnVlIGFuZCB0aGUgY29udGVudCBpcyBpbmxpbmUsIGl0IGluaGVyaXRzIHRoZSBtYXJrcyBmcm9tIHRoZVxuICAgIHBsYWNlIHdoZXJlIGl0IGlzIGluc2VydGVkLlxuICAgICovXG4gICAgcmVwbGFjZVNlbGVjdGlvbldpdGgobm9kZSwgaW5oZXJpdE1hcmtzID0gdHJ1ZSkge1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XG4gICAgICAgIGlmIChpbmhlcml0TWFya3MpXG4gICAgICAgICAgICBub2RlID0gbm9kZS5tYXJrKHRoaXMuc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi5lbXB0eSA/IHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpIDogKHNlbGVjdGlvbi4kZnJvbS5tYXJrc0Fjcm9zcyhzZWxlY3Rpb24uJHRvKSB8fCBNYXJrLm5vbmUpKSk7XG4gICAgICAgIHNlbGVjdGlvbi5yZXBsYWNlV2l0aCh0aGlzLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSB0aGUgc2VsZWN0aW9uLlxuICAgICovXG4gICAgZGVsZXRlU2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5yZXBsYWNlKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgZ2l2ZW4gcmFuZ2UsIG9yIHRoZSBzZWxlY3Rpb24gaWYgbm8gcmFuZ2UgaXMgZ2l2ZW4sXG4gICAgd2l0aCBhIHRleHQgbm9kZSBjb250YWluaW5nIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICBpbnNlcnRUZXh0KHRleHQsIGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBzY2hlbWEgPSB0aGlzLmRvYy50eXBlLnNjaGVtYTtcbiAgICAgICAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCF0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVNlbGVjdGlvbldpdGgoc2NoZW1hLnRleHQodGV4dCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICAgICAgdG8gPSBmcm9tO1xuICAgICAgICAgICAgdG8gPSB0byA9PSBudWxsID8gZnJvbSA6IHRvO1xuICAgICAgICAgICAgaWYgKCF0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9IHRoaXMuc3RvcmVkTWFya3M7XG4gICAgICAgICAgICBpZiAoIW1hcmtzKSB7XG4gICAgICAgICAgICAgICAgbGV0ICRmcm9tID0gdGhpcy5kb2MucmVzb2x2ZShmcm9tKTtcbiAgICAgICAgICAgICAgICBtYXJrcyA9IHRvID09IGZyb20gPyAkZnJvbS5tYXJrcygpIDogJGZyb20ubWFya3NBY3Jvc3ModGhpcy5kb2MucmVzb2x2ZSh0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBzY2hlbWEudGV4dCh0ZXh0LCBtYXJrcykpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5lbXB0eSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0aGlzLnNlbGVjdGlvbi4kdG8pKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFN0b3JlIGEgbWV0YWRhdGEgcHJvcGVydHkgaW4gdGhpcyB0cmFuc2FjdGlvbiwga2V5ZWQgZWl0aGVyIGJ5XG4gICAgbmFtZSBvciBieSBwbHVnaW4uXG4gICAgKi9cbiAgICBzZXRNZXRhKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5tZXRhW3R5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiA/IGtleSA6IGtleS5rZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSBhIG1ldGFkYXRhIHByb3BlcnR5IGZvciBhIGdpdmVuIG5hbWUgb3IgcGx1Z2luLlxuICAgICovXG4gICAgZ2V0TWV0YShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YVt0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgPyBrZXkgOiBrZXkua2V5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gZG9lc24ndCBjb250YWluIGFueSBtZXRhZGF0YSxcbiAgICBhbmQgY2FuIHRodXMgc2FmZWx5IGJlIGV4dGVuZGVkLlxuICAgICovXG4gICAgZ2V0IGlzR2VuZXJpYygpIHtcbiAgICAgICAgZm9yIChsZXQgXyBpbiB0aGlzLm1ldGEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZSB0aGF0IHRoZSBlZGl0b3Igc2hvdWxkIHNjcm9sbCB0aGUgc2VsZWN0aW9uIGludG8gdmlld1xuICAgIHdoZW4gdXBkYXRlZCB0byB0aGUgc3RhdGUgcHJvZHVjZWQgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHNjcm9sbEludG9WaWV3KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZWQgfD0gVVBEQVRFRF9TQ1JPTEw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyB0cmFuc2FjdGlvbiBoYXMgaGFkIGBzY3JvbGxJbnRvVmlld2AgY2FsbGVkIG9uIGl0LlxuICAgICovXG4gICAgZ2V0IHNjcm9sbGVkSW50b1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy51cGRhdGVkICYgVVBEQVRFRF9TQ1JPTEwpID4gMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJpbmQoZiwgc2VsZikge1xuICAgIHJldHVybiAhc2VsZiB8fCAhZiA/IGYgOiBmLmJpbmQoc2VsZik7XG59XG5jbGFzcyBGaWVsZERlc2Mge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGRlc2MsIHNlbGYpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pbml0ID0gYmluZChkZXNjLmluaXQsIHNlbGYpO1xuICAgICAgICB0aGlzLmFwcGx5ID0gYmluZChkZXNjLmFwcGx5LCBzZWxmKTtcbiAgICB9XG59XG5jb25zdCBiYXNlRmllbGRzID0gW1xuICAgIG5ldyBGaWVsZERlc2MoXCJkb2NcIiwge1xuICAgICAgICBpbml0KGNvbmZpZykgeyByZXR1cm4gY29uZmlnLmRvYyB8fCBjb25maWcuc2NoZW1hLnRvcE5vZGVUeXBlLmNyZWF0ZUFuZEZpbGwoKTsgfSxcbiAgICAgICAgYXBwbHkodHIpIHsgcmV0dXJuIHRyLmRvYzsgfVxuICAgIH0pLFxuICAgIG5ldyBGaWVsZERlc2MoXCJzZWxlY3Rpb25cIiwge1xuICAgICAgICBpbml0KGNvbmZpZywgaW5zdGFuY2UpIHsgcmV0dXJuIGNvbmZpZy5zZWxlY3Rpb24gfHwgU2VsZWN0aW9uLmF0U3RhcnQoaW5zdGFuY2UuZG9jKTsgfSxcbiAgICAgICAgYXBwbHkodHIpIHsgcmV0dXJuIHRyLnNlbGVjdGlvbjsgfVxuICAgIH0pLFxuICAgIG5ldyBGaWVsZERlc2MoXCJzdG9yZWRNYXJrc1wiLCB7XG4gICAgICAgIGluaXQoY29uZmlnKSB7IHJldHVybiBjb25maWcuc3RvcmVkTWFya3MgfHwgbnVsbDsgfSxcbiAgICAgICAgYXBwbHkodHIsIF9tYXJrcywgX29sZCwgc3RhdGUpIHsgcmV0dXJuIHN0YXRlLnNlbGVjdGlvbi4kY3Vyc29yID8gdHIuc3RvcmVkTWFya3MgOiBudWxsOyB9XG4gICAgfSksXG4gICAgbmV3IEZpZWxkRGVzYyhcInNjcm9sbFRvU2VsZWN0aW9uXCIsIHtcbiAgICAgICAgaW5pdCgpIHsgcmV0dXJuIDA7IH0sXG4gICAgICAgIGFwcGx5KHRyLCBwcmV2KSB7IHJldHVybiB0ci5zY3JvbGxlZEludG9WaWV3ID8gcHJldiArIDEgOiBwcmV2OyB9XG4gICAgfSlcbl07XG4vLyBPYmplY3Qgd3JhcHBpbmcgdGhlIHBhcnQgb2YgYSBzdGF0ZSBvYmplY3QgdGhhdCBzdGF5cyB0aGUgc2FtZVxuLy8gYWNyb3NzIHRyYW5zYWN0aW9ucy4gU3RvcmVkIGluIHRoZSBzdGF0ZSdzIGBjb25maWdgIHByb3BlcnR5LlxuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hLCBwbHVnaW5zKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5wbHVnaW5zQnlLZXkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGJhc2VGaWVsZHMuc2xpY2UoKTtcbiAgICAgICAgaWYgKHBsdWdpbnMpXG4gICAgICAgICAgICBwbHVnaW5zLmZvckVhY2gocGx1Z2luID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wbHVnaW5zQnlLZXlbcGx1Z2luLmtleV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQWRkaW5nIGRpZmZlcmVudCBpbnN0YW5jZXMgb2YgYSBrZXllZCBwbHVnaW4gKFwiICsgcGx1Z2luLmtleSArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luc0J5S2V5W3BsdWdpbi5rZXldID0gcGx1Z2luO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy5zdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWVsZHMucHVzaChuZXcgRmllbGREZXNjKHBsdWdpbi5rZXksIHBsdWdpbi5zcGVjLnN0YXRlLCBwbHVnaW4pKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuVGhlIHN0YXRlIG9mIGEgUHJvc2VNaXJyb3IgZWRpdG9yIGlzIHJlcHJlc2VudGVkIGJ5IGFuIG9iamVjdCBvZlxudGhpcyB0eXBlLiBBIHN0YXRlIGlzIGEgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZVx1MjAxNGl0IGlzbid0XG51cGRhdGVkLCBidXQgcmF0aGVyIGEgbmV3IHN0YXRlIHZhbHVlIGlzIGNvbXB1dGVkIGZyb20gYW4gb2xkIG9uZVxudXNpbmcgdGhlIFtgYXBwbHlgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuYXBwbHkpIG1ldGhvZC5cblxuQSBzdGF0ZSBob2xkcyBhIG51bWJlciBvZiBidWlsdC1pbiBmaWVsZHMsIGFuZCBwbHVnaW5zIGNhblxuW2RlZmluZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlBsdWdpblNwZWMuc3RhdGUpIGFkZGl0aW9uYWwgZmllbGRzLlxuKi9cbmNsYXNzIEVkaXRvclN0YXRlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2NoZW1hIG9mIHRoZSBzdGF0ZSdzIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnNjaGVtYTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHBsdWdpbnMgdGhhdCBhcmUgYWN0aXZlIGluIHRoaXMgc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgcGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnBsdWdpbnM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGx5IHRoZSBnaXZlbiB0cmFuc2FjdGlvbiB0byBwcm9kdWNlIGEgbmV3IHN0YXRlLlxuICAgICovXG4gICAgYXBwbHkodHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUcmFuc2FjdGlvbih0cikuc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmlsdGVyVHJhbnNhY3Rpb24odHIsIGlnbm9yZSA9IC0xKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChpICE9IGlnbm9yZSkge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLmNvbmZpZy5wbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy5maWx0ZXJUcmFuc2FjdGlvbiAmJiAhcGx1Z2luLnNwZWMuZmlsdGVyVHJhbnNhY3Rpb24uY2FsbChwbHVnaW4sIHRyLCB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVmVyYm9zZSB2YXJpYW50IG9mIFtgYXBwbHlgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuYXBwbHkpIHRoYXRcbiAgICByZXR1cm5zIHRoZSBwcmVjaXNlIHRyYW5zYWN0aW9ucyB0aGF0IHdlcmUgYXBwbGllZCAod2hpY2ggbWlnaHRcbiAgICBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBbdHJhbnNhY3Rpb25cbiAgICBob29rc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlBsdWdpblNwZWMuZmlsdGVyVHJhbnNhY3Rpb24pIG9mXG4gICAgcGx1Z2lucykgYWxvbmcgd2l0aCB0aGUgbmV3IHN0YXRlLlxuICAgICovXG4gICAgYXBwbHlUcmFuc2FjdGlvbihyb290VHIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbHRlclRyYW5zYWN0aW9uKHJvb3RUcikpXG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogdGhpcywgdHJhbnNhY3Rpb25zOiBbXSB9O1xuICAgICAgICBsZXQgdHJzID0gW3Jvb3RUcl0sIG5ld1N0YXRlID0gdGhpcy5hcHBseUlubmVyKHJvb3RUciksIHNlZW4gPSBudWxsO1xuICAgICAgICAvLyBUaGlzIGxvb3AgcmVwZWF0ZWRseSBnaXZlcyBwbHVnaW5zIGEgY2hhbmNlIHRvIHJlc3BvbmQgdG9cbiAgICAgICAgLy8gdHJhbnNhY3Rpb25zIGFzIG5ldyB0cmFuc2FjdGlvbnMgYXJlIGFkZGVkLCBtYWtpbmcgc3VyZSB0byBvbmx5XG4gICAgICAgIC8vIHBhc3MgdGhlIHRyYW5zYWN0aW9ucyB0aGUgcGx1Z2luIGRpZCBub3Qgc2VlIGJlZm9yZS5cbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGhhdmVOZXcgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLmNvbmZpZy5wbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy5hcHBlbmRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbiA9IHNlZW4gPyBzZWVuW2ldLm4gOiAwLCBvbGRTdGF0ZSA9IHNlZW4gPyBzZWVuW2ldLnN0YXRlIDogdGhpcztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyID0gbiA8IHRycy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uLmNhbGwocGx1Z2luLCBuID8gdHJzLnNsaWNlKG4pIDogdHJzLCBvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHIgJiYgbmV3U3RhdGUuZmlsdGVyVHJhbnNhY3Rpb24odHIsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwiYXBwZW5kZWRUcmFuc2FjdGlvblwiLCByb290VHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vlbi5wdXNoKGogPCBpID8geyBzdGF0ZTogbmV3U3RhdGUsIG46IHRycy5sZW5ndGggfSA6IHsgc3RhdGU6IHRoaXMsIG46IDAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnMucHVzaCh0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlLmFwcGx5SW5uZXIodHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZU5ldyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuW2ldID0geyBzdGF0ZTogbmV3U3RhdGUsIG46IHRycy5sZW5ndGggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhdmVOZXcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IG5ld1N0YXRlLCB0cmFuc2FjdGlvbnM6IHRycyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYXBwbHlJbm5lcih0cikge1xuICAgICAgICBpZiAoIXRyLmJlZm9yZS5lcSh0aGlzLmRvYykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFwcGx5aW5nIGEgbWlzbWF0Y2hlZCB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgbGV0IG5ld0luc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKHRoaXMuY29uZmlnKSwgZmllbGRzID0gdGhpcy5jb25maWcuZmllbGRzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICAgICAgbmV3SW5zdGFuY2VbZmllbGQubmFtZV0gPSBmaWVsZC5hcHBseSh0ciwgdGhpc1tmaWVsZC5uYW1lXSwgdGhpcywgbmV3SW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdJbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgU3RhcnQgYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbikgZnJvbSB0aGlzIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IHRyKCkgeyByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHRoaXMpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHN0YXRlLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcpIHtcbiAgICAgICAgbGV0ICRjb25maWcgPSBuZXcgQ29uZmlndXJhdGlvbihjb25maWcuZG9jID8gY29uZmlnLmRvYy50eXBlLnNjaGVtYSA6IGNvbmZpZy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKCRjb25maWcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICRjb25maWcuZmllbGRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaW5zdGFuY2VbJGNvbmZpZy5maWVsZHNbaV0ubmFtZV0gPSAkY29uZmlnLmZpZWxkc1tpXS5pbml0KGNvbmZpZywgaW5zdGFuY2UpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBzdGF0ZSBiYXNlZCBvbiB0aGlzIG9uZSwgYnV0IHdpdGggYW4gYWRqdXN0ZWQgc2V0XG4gICAgb2YgYWN0aXZlIHBsdWdpbnMuIFN0YXRlIGZpZWxkcyB0aGF0IGV4aXN0IGluIGJvdGggc2V0cyBvZlxuICAgIHBsdWdpbnMgYXJlIGtlcHQgdW5jaGFuZ2VkLiBUaG9zZSB0aGF0IG5vIGxvbmdlciBleGlzdCBhcmVcbiAgICBkcm9wcGVkLCBhbmQgdGhvc2UgdGhhdCBhcmUgbmV3IGFyZSBpbml0aWFsaXplZCB1c2luZyB0aGVpclxuICAgIFtgaW5pdGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUZpZWxkLmluaXQpIG1ldGhvZCwgcGFzc2luZyBpbiB0aGUgbmV3XG4gICAgY29uZmlndXJhdGlvbiBvYmplY3QuLlxuICAgICovXG4gICAgcmVjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIGxldCAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24odGhpcy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgICAgICAgbGV0IGZpZWxkcyA9ICRjb25maWcuZmllbGRzLCBpbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSgkY29uZmlnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gZmllbGRzW2ldLm5hbWU7XG4gICAgICAgICAgICBpbnN0YW5jZVtuYW1lXSA9IHRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyB0aGlzW25hbWVdIDogZmllbGRzW2ldLmluaXQoY29uZmlnLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBzdGF0ZSB0byBKU09OLiBJZiB5b3Ugd2FudCB0byBzZXJpYWxpemUgdGhlIHN0YXRlXG4gICAgb2YgcGx1Z2lucywgcGFzcyBhbiBvYmplY3QgbWFwcGluZyBwcm9wZXJ0eSBuYW1lcyB0byB1c2UgaW4gdGhlXG4gICAgcmVzdWx0aW5nIEpTT04gb2JqZWN0IHRvIHBsdWdpbiBvYmplY3RzLiBUaGUgYXJndW1lbnQgbWF5IGFsc28gYmVcbiAgICBhIHN0cmluZyBvciBudW1iZXIsIGluIHdoaWNoIGNhc2UgaXQgaXMgaWdub3JlZCwgdG8gc3VwcG9ydCB0aGVcbiAgICB3YXkgYEpTT04uc3RyaW5naWZ5YCBjYWxscyBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gICAgKi9cbiAgICB0b0pTT04ocGx1Z2luRmllbGRzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IGRvYzogdGhpcy5kb2MudG9KU09OKCksIHNlbGVjdGlvbjogdGhpcy5zZWxlY3Rpb24udG9KU09OKCkgfTtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmVkTWFya3MpXG4gICAgICAgICAgICByZXN1bHQuc3RvcmVkTWFya3MgPSB0aGlzLnN0b3JlZE1hcmtzLm1hcChtID0+IG0udG9KU09OKCkpO1xuICAgICAgICBpZiAocGx1Z2luRmllbGRzICYmIHR5cGVvZiBwbHVnaW5GaWVsZHMgPT0gJ29iamVjdCcpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHBsdWdpbkZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09IFwiZG9jXCIgfHwgcHJvcCA9PSBcInNlbGVjdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBKU09OIGZpZWxkcyBgZG9jYCBhbmQgYHNlbGVjdGlvbmAgYXJlIHJlc2VydmVkXCIpO1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSBwbHVnaW5GaWVsZHNbcHJvcF0sIHN0YXRlID0gcGx1Z2luLnNwZWMuc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLnRvSlNPTilcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gc3RhdGUudG9KU09OLmNhbGwocGx1Z2luLCB0aGlzW3BsdWdpbi5rZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgc3RhdGUuIGBjb25maWdgIHNob3VsZFxuICAgIGhhdmUgYXQgbGVhc3QgYSBgc2NoZW1hYCBmaWVsZCwgYW5kIHNob3VsZCBjb250YWluIGFycmF5IG9mXG4gICAgcGx1Z2lucyB0byBpbml0aWFsaXplIHRoZSBzdGF0ZSB3aXRoLiBgcGx1Z2luRmllbGRzYCBjYW4gYmUgdXNlZFxuICAgIHRvIGRlc2VyaWFsaXplIHRoZSBzdGF0ZSBvZiBwbHVnaW5zLCBieSBhc3NvY2lhdGluZyBwbHVnaW5cbiAgICBpbnN0YW5jZXMgd2l0aCB0aGUgcHJvcGVydHkgbmFtZXMgdGhleSB1c2UgaW4gdGhlIEpTT04gb2JqZWN0LlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGNvbmZpZywganNvbiwgcGx1Z2luRmllbGRzKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgRWRpdG9yU3RhdGUuZnJvbUpTT05cIik7XG4gICAgICAgIGlmICghY29uZmlnLnNjaGVtYSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVxdWlyZWQgY29uZmlnIGZpZWxkICdzY2hlbWEnIG1pc3NpbmdcIik7XG4gICAgICAgIGxldCAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24oY29uZmlnLnNjaGVtYSwgY29uZmlnLnBsdWdpbnMpO1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBuZXcgRWRpdG9yU3RhdGUoJGNvbmZpZyk7XG4gICAgICAgICRjb25maWcuZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgPT0gXCJkb2NcIikge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRvYyA9IE5vZGUuZnJvbUpTT04oY29uZmlnLnNjaGVtYSwganNvbi5kb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQubmFtZSA9PSBcInNlbGVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2VsZWN0aW9uID0gU2VsZWN0aW9uLmZyb21KU09OKGluc3RhbmNlLmRvYywganNvbi5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQubmFtZSA9PSBcInN0b3JlZE1hcmtzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoanNvbi5zdG9yZWRNYXJrcylcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RvcmVkTWFya3MgPSBqc29uLnN0b3JlZE1hcmtzLm1hcChjb25maWcuc2NoZW1hLm1hcmtGcm9tSlNPTik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luRmllbGRzKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHBsdWdpbkZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHBsdWdpbkZpZWxkc1twcm9wXSwgc3RhdGUgPSBwbHVnaW4uc3BlYy5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ua2V5ID09IGZpZWxkLm5hbWUgJiYgc3RhdGUgJiYgc3RhdGUuZnJvbUpTT04gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoanNvbiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVtmaWVsZC5uYW1lXSA9IHN0YXRlLmZyb21KU09OLmNhbGwocGx1Z2luLCBjb25maWcsIGpzb25bcHJvcF0sIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0YW5jZVtmaWVsZC5uYW1lXSA9IGZpZWxkLmluaXQoY29uZmlnLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBiaW5kUHJvcHMob2JqLCBzZWxmLCB0YXJnZXQpIHtcbiAgICBmb3IgKGxldCBwcm9wIGluIG9iaikge1xuICAgICAgICBsZXQgdmFsID0gb2JqW3Byb3BdO1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgICAgICB2YWwgPSB2YWwuYmluZChzZWxmKTtcbiAgICAgICAgZWxzZSBpZiAocHJvcCA9PSBcImhhbmRsZURPTUV2ZW50c1wiKVxuICAgICAgICAgICAgdmFsID0gYmluZFByb3BzKHZhbCwgc2VsZiwge30pO1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG4vKipcblBsdWdpbnMgYnVuZGxlIGZ1bmN0aW9uYWxpdHkgdGhhdCBjYW4gYmUgYWRkZWQgdG8gYW4gZWRpdG9yLlxuVGhleSBhcmUgcGFydCBvZiB0aGUgW2VkaXRvciBzdGF0ZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlKSBhbmRcbm1heSBpbmZsdWVuY2UgdGhhdCBzdGF0ZSBhbmQgdGhlIHZpZXcgdGhhdCBjb250YWlucyBpdC5cbiovXG5jbGFzcyBQbHVnaW4ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBsdWdpbi5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwbHVnaW4ncyBbc3BlYyBvYmplY3RdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5QbHVnaW5TcGVjKS5cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBbcHJvcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzKSBleHBvcnRlZCBieSB0aGlzIHBsdWdpbi5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9wcyA9IHt9O1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGJpbmRQcm9wcyhzcGVjLnByb3BzLCB0aGlzLCB0aGlzLnByb3BzKTtcbiAgICAgICAgdGhpcy5rZXkgPSBzcGVjLmtleSA/IHNwZWMua2V5LmtleSA6IGNyZWF0ZUtleShcInBsdWdpblwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0cmFjdCB0aGUgcGx1Z2luJ3Mgc3RhdGUgZmllbGQgZnJvbSBhbiBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBnZXRTdGF0ZShzdGF0ZSkgeyByZXR1cm4gc3RhdGVbdGhpcy5rZXldOyB9XG59XG5jb25zdCBrZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGNyZWF0ZUtleShuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW4ga2V5cylcbiAgICAgICAgcmV0dXJuIG5hbWUgKyBcIiRcIiArICsra2V5c1tuYW1lXTtcbiAgICBrZXlzW25hbWVdID0gMDtcbiAgICByZXR1cm4gbmFtZSArIFwiJFwiO1xufVxuLyoqXG5BIGtleSBpcyB1c2VkIHRvIFt0YWddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5QbHVnaW5TcGVjLmtleSkgcGx1Z2lucyBpbiBhIHdheVxudGhhdCBtYWtlcyBpdCBwb3NzaWJsZSB0byBmaW5kIHRoZW0sIGdpdmVuIGFuIGVkaXRvciBzdGF0ZS5cbkFzc2lnbmluZyBhIGtleSBkb2VzIG1lYW4gb25seSBvbmUgcGx1Z2luIG9mIHRoYXQgdHlwZSBjYW4gYmVcbmFjdGl2ZSBpbiBhIHN0YXRlLlxuKi9cbmNsYXNzIFBsdWdpbktleSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGx1Z2luIGtleS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUgPSBcImtleVwiKSB7IHRoaXMua2V5ID0gY3JlYXRlS2V5KG5hbWUpOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBhY3RpdmUgcGx1Z2luIHdpdGggdGhpcyBrZXksIGlmIGFueSwgZnJvbSBhbiBlZGl0b3JcbiAgICBzdGF0ZS5cbiAgICAqL1xuICAgIGdldChzdGF0ZSkgeyByZXR1cm4gc3RhdGUuY29uZmlnLnBsdWdpbnNCeUtleVt0aGlzLmtleV07IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHBsdWdpbidzIHN0YXRlIGZyb20gYW4gZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgZ2V0U3RhdGUoc3RhdGUpIHsgcmV0dXJuIHN0YXRlW3RoaXMua2V5XTsgfVxufVxuXG5leHBvcnQgeyBBbGxTZWxlY3Rpb24sIEVkaXRvclN0YXRlLCBOb2RlU2VsZWN0aW9uLCBQbHVnaW4sIFBsdWdpbktleSwgU2VsZWN0aW9uLCBTZWxlY3Rpb25SYW5nZSwgVGV4dFNlbGVjdGlvbiwgVHJhbnNhY3Rpb24gfTtcbiIsICJpbXBvcnQgeyBUZXh0U2VsZWN0aW9uLCBOb2RlU2VsZWN0aW9uLCBBbGxTZWxlY3Rpb24sIFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IERPTVNlcmlhbGl6ZXIsIEZyYWdtZW50LCBNYXJrLCBTbGljZSwgRE9NUGFyc2VyIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgZHJvcFBvaW50IH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcblxuY29uc3QgZG9tSW5kZXggPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDs7IGluZGV4KyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufTtcbmNvbnN0IHBhcmVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGxldCBwYXJlbnQgPSBub2RlLmFzc2lnbmVkU2xvdCB8fCBub2RlLnBhcmVudE5vZGU7XG4gICAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMTEgPyBwYXJlbnQuaG9zdCA6IHBhcmVudDtcbn07XG5sZXQgcmV1c2VkUmFuZ2UgPSBudWxsO1xuLy8gTm90ZSB0aGF0IHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIHJhbmdlLCBiZWNhdXNlIERPTSByYW5nZVxuLy8gb2JqZWN0cyBhcmUgZXZlcnkgZXhwZW5zaXZlLCBhbmQga2VlcCBzbG93aW5nIGRvd24gc3Vic2VxdWVudCBET01cbi8vIHVwZGF0ZXMsIGZvciBzb21lIHJlYXNvbi5cbmNvbnN0IHRleHRSYW5nZSA9IGZ1bmN0aW9uIChub2RlLCBmcm9tLCB0bykge1xuICAgIGxldCByYW5nZSA9IHJldXNlZFJhbmdlIHx8IChyZXVzZWRSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkpO1xuICAgIHJhbmdlLnNldEVuZChub2RlLCB0byA9PSBudWxsID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogdG8pO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGZyb20gfHwgMCk7XG4gICAgcmV0dXJuIHJhbmdlO1xufTtcbi8vIFNjYW5zIGZvcndhcmQgYW5kIGJhY2t3YXJkIHRocm91Z2ggRE9NIHBvc2l0aW9ucyBlcXVpdmFsZW50IHRvIHRoZVxuLy8gZ2l2ZW4gb25lIHRvIHNlZSBpZiB0aGUgdHdvIGFyZSBpbiB0aGUgc2FtZSBwbGFjZSAoaS5lLiBhZnRlciBhXG4vLyB0ZXh0IG5vZGUgdnMgYXQgdGhlIGVuZCBvZiB0aGF0IHRleHQgbm9kZSlcbmNvbnN0IGlzRXF1aXZhbGVudFBvc2l0aW9uID0gZnVuY3Rpb24gKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmKSB7XG4gICAgcmV0dXJuIHRhcmdldE5vZGUgJiYgKHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIC0xKSB8fFxuICAgICAgICBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAxKSk7XG59O1xuY29uc3QgYXRvbUVsZW1lbnRzID0gL14oaW1nfGJyfGlucHV0fHRleHRhcmVhfGhyKSQvaTtcbmZ1bmN0aW9uIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIGRpcikge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gdGFyZ2V0Tm9kZSAmJiBvZmYgPT0gdGFyZ2V0T2ZmKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvZmYgPT0gKGRpciA8IDAgPyAwIDogbm9kZVNpemUobm9kZSkpKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9IDEgfHwgaGFzQmxvY2tEZXNjKG5vZGUpIHx8IGF0b21FbGVtZW50cy50ZXN0KG5vZGUubm9kZU5hbWUpIHx8XG4gICAgICAgICAgICAgICAgbm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9mZiA9IGRvbUluZGV4KG5vZGUpICsgKGRpciA8IDAgPyAwIDogMSk7XG4gICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmYgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkaXIgPCAwID8gbm9kZVNpemUobm9kZSkgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbm9kZVNpemUobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNPbkVkZ2Uobm9kZSwgb2Zmc2V0LCBwYXJlbnQpIHtcbiAgICBmb3IgKGxldCBhdFN0YXJ0ID0gb2Zmc2V0ID09IDAsIGF0RW5kID0gb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpOyBhdFN0YXJ0IHx8IGF0RW5kOykge1xuICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IGluZGV4ID0gZG9tSW5kZXgobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgYXRTdGFydCA9IGF0U3RhcnQgJiYgaW5kZXggPT0gMDtcbiAgICAgICAgYXRFbmQgPSBhdEVuZCAmJiBpbmRleCA9PSBub2RlU2l6ZShub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNCbG9ja0Rlc2MoZG9tKSB7XG4gICAgbGV0IGRlc2M7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKVxuICAgICAgICBpZiAoZGVzYyA9IGN1ci5wbVZpZXdEZXNjKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgcmV0dXJuIGRlc2MgJiYgZGVzYy5ub2RlICYmIGRlc2Mubm9kZS5pc0Jsb2NrICYmIChkZXNjLmRvbSA9PSBkb20gfHwgZGVzYy5jb250ZW50RE9NID09IGRvbSk7XG59XG4vLyBXb3JrIGFyb3VuZCBDaHJvbWUgaXNzdWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ3NTIzXG4vLyAoaXNDb2xsYXBzZWQgaW5hcHByb3ByaWF0ZWx5IHJldHVybnMgdHJ1ZSBpbiBzaGFkb3cgZG9tKVxuY29uc3Qgc2VsZWN0aW9uQ29sbGFwc2VkID0gZnVuY3Rpb24gKGRvbVNlbCkge1xuICAgIHJldHVybiBkb21TZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xufTtcbmZ1bmN0aW9uIGtleUV2ZW50KGtleUNvZGUsIGtleSkge1xuICAgIGxldCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgZXZlbnQuaW5pdEV2ZW50KFwia2V5ZG93blwiLCB0cnVlLCB0cnVlKTtcbiAgICBldmVudC5rZXlDb2RlID0ga2V5Q29kZTtcbiAgICBldmVudC5rZXkgPSBldmVudC5jb2RlID0ga2V5O1xuICAgIHJldHVybiBldmVudDtcbn1cbmZ1bmN0aW9uIGRlZXBBY3RpdmVFbGVtZW50KGRvYykge1xuICAgIGxldCBlbHQgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICB3aGlsZSAoZWx0ICYmIGVsdC5zaGFkb3dSb290KVxuICAgICAgICBlbHQgPSBlbHQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICAgIHJldHVybiBlbHQ7XG59XG5mdW5jdGlvbiBjYXJldEZyb21Qb2ludChkb2MsIHgsIHkpIHtcbiAgICBpZiAoZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQpIHtcbiAgICAgICAgdHJ5IHsgLy8gRmlyZWZveCB0aHJvd3MgZm9yIHRoaXMgY2FsbCBpbiBoYXJkLXRvLXByZWRpY3QgY2lyY3Vtc3RhbmNlcyAoIzk5NClcbiAgICAgICAgICAgIGxldCBwb3MgPSBkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgIGlmIChwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogcG9zLm9mZnNldE5vZGUsIG9mZnNldDogcG9zLm9mZnNldCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICB9XG4gICAgaWYgKGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KSB7XG4gICAgICAgIGxldCByYW5nZSA9IGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiByYW5nZS5zdGFydENvbnRhaW5lciwgb2Zmc2V0OiByYW5nZS5zdGFydE9mZnNldCB9O1xuICAgIH1cbn1cblxuY29uc3QgbmF2ID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gbmF2aWdhdG9yIDogbnVsbDtcbmNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiBudWxsO1xuY29uc3QgYWdlbnQgPSAobmF2ICYmIG5hdi51c2VyQWdlbnQpIHx8IFwiXCI7XG5jb25zdCBpZV9lZGdlID0gL0VkZ2VcXC8oXFxkKykvLmV4ZWMoYWdlbnQpO1xuY29uc3QgaWVfdXB0bzEwID0gL01TSUUgXFxkLy5leGVjKGFnZW50KTtcbmNvbnN0IGllXzExdXAgPSAvVHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMoYWdlbnQpO1xuY29uc3QgaWUgPSAhIShpZV91cHRvMTAgfHwgaWVfMTF1cCB8fCBpZV9lZGdlKTtcbmNvbnN0IGllX3ZlcnNpb24gPSBpZV91cHRvMTAgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiBpZV8xMXVwID8gK2llXzExdXBbMV0gOiBpZV9lZGdlID8gK2llX2VkZ2VbMV0gOiAwO1xuY29uc3QgZ2Vja28gPSAhaWUgJiYgL2dlY2tvXFwvKFxcZCspL2kudGVzdChhZ2VudCk7XG5nZWNrbyAmJiArKC9GaXJlZm94XFwvKFxcZCspLy5leGVjKGFnZW50KSB8fCBbMCwgMF0pWzFdO1xuY29uc3QgX2Nocm9tZSA9ICFpZSAmJiAvQ2hyb21lXFwvKFxcZCspLy5leGVjKGFnZW50KTtcbmNvbnN0IGNocm9tZSA9ICEhX2Nocm9tZTtcbmNvbnN0IGNocm9tZV92ZXJzaW9uID0gX2Nocm9tZSA/ICtfY2hyb21lWzFdIDogMDtcbmNvbnN0IHNhZmFyaSA9ICFpZSAmJiAhIW5hdiAmJiAvQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2LnZlbmRvcik7XG4vLyBJcyB0cnVlIGZvciBib3RoIGlPUyBhbmQgaVBhZE9TIGZvciBjb252ZW5pZW5jZVxuY29uc3QgaW9zID0gc2FmYXJpICYmICgvTW9iaWxlXFwvXFx3Ky8udGVzdChhZ2VudCkgfHwgISFuYXYgJiYgbmF2Lm1heFRvdWNoUG9pbnRzID4gMik7XG5jb25zdCBtYWMgPSBpb3MgfHwgKG5hdiA/IC9NYWMvLnRlc3QobmF2LnBsYXRmb3JtKSA6IGZhbHNlKTtcbmNvbnN0IHdpbmRvd3MgPSBuYXYgPyAvV2luLy50ZXN0KG5hdi5wbGF0Zm9ybSkgOiBmYWxzZTtcbmNvbnN0IGFuZHJvaWQgPSAvQW5kcm9pZCBcXGQvLnRlc3QoYWdlbnQpO1xuY29uc3Qgd2Via2l0ID0gISFkb2MgJiYgXCJ3ZWJraXRGb250U21vb3RoaW5nXCIgaW4gZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbmNvbnN0IHdlYmtpdF92ZXJzaW9uID0gd2Via2l0ID8gKygvXFxiQXBwbGVXZWJLaXRcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgWzAsIDBdKVsxXSA6IDA7XG5cbmZ1bmN0aW9uIHdpbmRvd1JlY3QoZG9jKSB7XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgcmlnaHQ6IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgIHRvcDogMCwgYm90dG9tOiBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCB9O1xufVxuZnVuY3Rpb24gZ2V0U2lkZSh2YWx1ZSwgc2lkZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IHZhbHVlIDogdmFsdWVbc2lkZV07XG59XG5mdW5jdGlvbiBjbGllbnRSZWN0KG5vZGUpIHtcbiAgICBsZXQgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLy8gQWRqdXN0IGZvciBlbGVtZW50cyB3aXRoIHN0eWxlIFwidHJhbnNmb3JtOiBzY2FsZSgpXCJcbiAgICBsZXQgc2NhbGVYID0gKHJlY3Qud2lkdGggLyBub2RlLm9mZnNldFdpZHRoKSB8fCAxO1xuICAgIGxldCBzY2FsZVkgPSAocmVjdC5oZWlnaHQgLyBub2RlLm9mZnNldEhlaWdodCkgfHwgMTtcbiAgICAvLyBNYWtlIHN1cmUgc2Nyb2xsYmFyIHdpZHRoIGlzbid0IGluY2x1ZGVkIGluIHRoZSByZWN0YW5nbGVcbiAgICByZXR1cm4geyBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgKyBub2RlLmNsaWVudFdpZHRoICogc2NhbGVYLFxuICAgICAgICB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QudG9wICsgbm9kZS5jbGllbnRIZWlnaHQgKiBzY2FsZVkgfTtcbn1cbmZ1bmN0aW9uIHNjcm9sbFJlY3RJbnRvVmlldyh2aWV3LCByZWN0LCBzdGFydERPTSkge1xuICAgIGxldCBzY3JvbGxUaHJlc2hvbGQgPSB2aWV3LnNvbWVQcm9wKFwic2Nyb2xsVGhyZXNob2xkXCIpIHx8IDAsIHNjcm9sbE1hcmdpbiA9IHZpZXcuc29tZVByb3AoXCJzY3JvbGxNYXJnaW5cIikgfHwgNTtcbiAgICBsZXQgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudDtcbiAgICBmb3IgKGxldCBwYXJlbnQgPSBzdGFydERPTSB8fCB2aWV3LmRvbTs7IHBhcmVudCA9IHBhcmVudE5vZGUocGFyZW50KSkge1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAocGFyZW50Lm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IGVsdCA9IHBhcmVudDtcbiAgICAgICAgbGV0IGF0VG9wID0gZWx0ID09IGRvYy5ib2R5O1xuICAgICAgICBsZXQgYm91bmRpbmcgPSBhdFRvcCA/IHdpbmRvd1JlY3QoZG9jKSA6IGNsaWVudFJlY3QoZWx0KTtcbiAgICAgICAgbGV0IG1vdmVYID0gMCwgbW92ZVkgPSAwO1xuICAgICAgICBpZiAocmVjdC50b3AgPCBib3VuZGluZy50b3AgKyBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJ0b3BcIikpXG4gICAgICAgICAgICBtb3ZlWSA9IC0oYm91bmRpbmcudG9wIC0gcmVjdC50b3AgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJ0b3BcIikpO1xuICAgICAgICBlbHNlIGlmIChyZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSAtIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcImJvdHRvbVwiKSlcbiAgICAgICAgICAgIG1vdmVZID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcCA+IGJvdW5kaW5nLmJvdHRvbSAtIGJvdW5kaW5nLnRvcFxuICAgICAgICAgICAgICAgID8gcmVjdC50b3AgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJ0b3BcIikgLSBib3VuZGluZy50b3BcbiAgICAgICAgICAgICAgICA6IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwiYm90dG9tXCIpO1xuICAgICAgICBpZiAocmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCArIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcImxlZnRcIikpXG4gICAgICAgICAgICBtb3ZlWCA9IC0oYm91bmRpbmcubGVmdCAtIHJlY3QubGVmdCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcImxlZnRcIikpO1xuICAgICAgICBlbHNlIGlmIChyZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQgLSBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJyaWdodFwiKSlcbiAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwicmlnaHRcIik7XG4gICAgICAgIGlmIChtb3ZlWCB8fCBtb3ZlWSkge1xuICAgICAgICAgICAgaWYgKGF0VG9wKSB7XG4gICAgICAgICAgICAgICAgZG9jLmRlZmF1bHRWaWV3LnNjcm9sbEJ5KG1vdmVYLCBtb3ZlWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRYID0gZWx0LnNjcm9sbExlZnQsIHN0YXJ0WSA9IGVsdC5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmVZKVxuICAgICAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsVG9wICs9IG1vdmVZO1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgZWx0LnNjcm9sbExlZnQgKz0gbW92ZVg7XG4gICAgICAgICAgICAgICAgbGV0IGRYID0gZWx0LnNjcm9sbExlZnQgLSBzdGFydFgsIGRZID0gZWx0LnNjcm9sbFRvcCAtIHN0YXJ0WTtcbiAgICAgICAgICAgICAgICByZWN0ID0geyBsZWZ0OiByZWN0LmxlZnQgLSBkWCwgdG9wOiByZWN0LnRvcCAtIGRZLCByaWdodDogcmVjdC5yaWdodCAtIGRYLCBib3R0b206IHJlY3QuYm90dG9tIC0gZFkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXRUb3AgfHwgL14oZml4ZWR8c3RpY2t5KSQvLnRlc3QoZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpLnBvc2l0aW9uKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbi8vIFN0b3JlIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGVkaXRvcidzIHBhcmVudCBub2RlcywgYWxvbmcgd2l0aFxuLy8gdGhlIHRvcCBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IG5lYXIgdGhlIHRvcCBvZiB0aGUgZWRpdG9yLCB3aGljaFxuLy8gd2lsbCBiZSB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgdmlzaWJsZSB2aWV3cG9ydCByZW1haW5zIHN0YWJsZSBldmVuXG4vLyB3aGVuIHRoZSBzaXplIG9mIHRoZSBjb250ZW50IGFib3ZlIGNoYW5nZXMuXG5mdW5jdGlvbiBzdG9yZVNjcm9sbFBvcyh2aWV3KSB7XG4gICAgbGV0IHJlY3QgPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc3RhcnRZID0gTWF0aC5tYXgoMCwgcmVjdC50b3ApO1xuICAgIGxldCByZWZET00sIHJlZlRvcDtcbiAgICBmb3IgKGxldCB4ID0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiwgeSA9IHN0YXJ0WSArIDE7IHkgPCBNYXRoLm1pbihpbm5lckhlaWdodCwgcmVjdC5ib3R0b20pOyB5ICs9IDUpIHtcbiAgICAgICAgbGV0IGRvbSA9IHZpZXcucm9vdC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgICAgICBpZiAoIWRvbSB8fCBkb20gPT0gdmlldy5kb20gfHwgIXZpZXcuZG9tLmNvbnRhaW5zKGRvbSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IGxvY2FsUmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGxvY2FsUmVjdC50b3AgPj0gc3RhcnRZIC0gMjApIHtcbiAgICAgICAgICAgIHJlZkRPTSA9IGRvbTtcbiAgICAgICAgICAgIHJlZlRvcCA9IGxvY2FsUmVjdC50b3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyByZWZET006IHJlZkRPTSwgcmVmVG9wOiByZWZUb3AsIHN0YWNrOiBzY3JvbGxTdGFjayh2aWV3LmRvbSkgfTtcbn1cbmZ1bmN0aW9uIHNjcm9sbFN0YWNrKGRvbSkge1xuICAgIGxldCBzdGFjayA9IFtdLCBkb2MgPSBkb20ub3duZXJEb2N1bWVudDtcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjsgY3VyID0gcGFyZW50Tm9kZShjdXIpKSB7XG4gICAgICAgIHN0YWNrLnB1c2goeyBkb206IGN1ciwgdG9wOiBjdXIuc2Nyb2xsVG9wLCBsZWZ0OiBjdXIuc2Nyb2xsTGVmdCB9KTtcbiAgICAgICAgaWYgKGRvbSA9PSBkb2MpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xufVxuLy8gUmVzZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZWRpdG9yJ3MgcGFyZW50IG5vZGVzIHRvIHRoYXQgd2hhdFxuLy8gaXQgd2FzIGJlZm9yZSwgd2hlbiBzdG9yZVNjcm9sbFBvcyB3YXMgY2FsbGVkLlxuZnVuY3Rpb24gcmVzZXRTY3JvbGxQb3MoeyByZWZET00sIHJlZlRvcCwgc3RhY2sgfSkge1xuICAgIGxldCBuZXdSZWZUb3AgPSByZWZET00gPyByZWZET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIDogMDtcbiAgICByZXN0b3JlU2Nyb2xsU3RhY2soc3RhY2ssIG5ld1JlZlRvcCA9PSAwID8gMCA6IG5ld1JlZlRvcCAtIHJlZlRvcCk7XG59XG5mdW5jdGlvbiByZXN0b3JlU2Nyb2xsU3RhY2soc3RhY2ssIGRUb3ApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB7IGRvbSwgdG9wLCBsZWZ0IH0gPSBzdGFja1tpXTtcbiAgICAgICAgaWYgKGRvbS5zY3JvbGxUb3AgIT0gdG9wICsgZFRvcClcbiAgICAgICAgICAgIGRvbS5zY3JvbGxUb3AgPSB0b3AgKyBkVG9wO1xuICAgICAgICBpZiAoZG9tLnNjcm9sbExlZnQgIT0gbGVmdClcbiAgICAgICAgICAgIGRvbS5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICB9XG59XG5sZXQgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IG51bGw7XG4vLyBGZWF0dXJlLWRldGVjdHMgc3VwcG9ydCBmb3IgLmZvY3VzKHtwcmV2ZW50U2Nyb2xsOiB0cnVlfSksIGFuZCB1c2VzXG4vLyBhIGZhbGxiYWNrIGtsdWRnZSB3aGVuIG5vdCBzdXBwb3J0ZWQuXG5mdW5jdGlvbiBmb2N1c1ByZXZlbnRTY3JvbGwoZG9tKSB7XG4gICAgaWYgKGRvbS5zZXRBY3RpdmUpXG4gICAgICAgIHJldHVybiBkb20uc2V0QWN0aXZlKCk7IC8vIGluIElFXG4gICAgaWYgKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCk7XG4gICAgbGV0IHN0b3JlZCA9IHNjcm9sbFN0YWNrKGRvbSk7XG4gICAgZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPT0gbnVsbCA/IHtcbiAgICAgICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0geyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gOiB1bmRlZmluZWQpO1xuICAgIGlmICghcHJldmVudFNjcm9sbFN1cHBvcnRlZCkge1xuICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIHJlc3RvcmVTY3JvbGxTdGFjayhzdG9yZWQsIDApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRPZmZzZXRJbk5vZGUobm9kZSwgY29vcmRzKSB7XG4gICAgbGV0IGNsb3Nlc3QsIGR4Q2xvc2VzdCA9IDJlOCwgY29vcmRzQ2xvc2VzdCwgb2Zmc2V0ID0gMDtcbiAgICBsZXQgcm93Qm90ID0gY29vcmRzLnRvcCwgcm93VG9wID0gY29vcmRzLnRvcDtcbiAgICBsZXQgZmlyc3RCZWxvdywgY29vcmRzQmVsb3c7XG4gICAgZm9yIChsZXQgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQsIGNoaWxkSW5kZXggPSAwOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZywgY2hpbGRJbmRleCsrKSB7XG4gICAgICAgIGxldCByZWN0cztcbiAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICByZWN0cyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZWN0cyA9IHRleHRSYW5nZShjaGlsZCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICBpZiAocmVjdC50b3AgPD0gcm93Qm90ICYmIHJlY3QuYm90dG9tID49IHJvd1RvcCkge1xuICAgICAgICAgICAgICAgIHJvd0JvdCA9IE1hdGgubWF4KHJlY3QuYm90dG9tLCByb3dCb3QpO1xuICAgICAgICAgICAgICAgIHJvd1RvcCA9IE1hdGgubWluKHJlY3QudG9wLCByb3dUb3ApO1xuICAgICAgICAgICAgICAgIGxldCBkeCA9IHJlY3QubGVmdCA+IGNvb3Jkcy5sZWZ0ID8gcmVjdC5sZWZ0IC0gY29vcmRzLmxlZnRcbiAgICAgICAgICAgICAgICAgICAgOiByZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgPyBjb29yZHMubGVmdCAtIHJlY3QucmlnaHQgOiAwO1xuICAgICAgICAgICAgICAgIGlmIChkeCA8IGR4Q2xvc2VzdCkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGR4Q2xvc2VzdCA9IGR4O1xuICAgICAgICAgICAgICAgICAgICBjb29yZHNDbG9zZXN0ID0gZHggJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAzID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcmVjdC5yaWdodCA8IGNvb3Jkcy5sZWZ0ID8gcmVjdC5yaWdodCA6IHJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogY29vcmRzLnRvcFxuICAgICAgICAgICAgICAgICAgICB9IDogY29vcmRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSAmJiBkeClcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGNoaWxkSW5kZXggKyAoY29vcmRzLmxlZnQgPj0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVjdC50b3AgPiBjb29yZHMudG9wICYmICFmaXJzdEJlbG93ICYmIHJlY3QubGVmdCA8PSBjb29yZHMubGVmdCAmJiByZWN0LnJpZ2h0ID49IGNvb3Jkcy5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RCZWxvdyA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGNvb3Jkc0JlbG93ID0geyBsZWZ0OiBNYXRoLm1heChyZWN0LmxlZnQsIE1hdGgubWluKHJlY3QucmlnaHQsIGNvb3Jkcy5sZWZ0KSksIHRvcDogcmVjdC50b3AgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2xvc2VzdCAmJiAoY29vcmRzLmxlZnQgPj0gcmVjdC5yaWdodCAmJiBjb29yZHMudG9wID49IHJlY3QudG9wIHx8XG4gICAgICAgICAgICAgICAgY29vcmRzLmxlZnQgPj0gcmVjdC5sZWZ0ICYmIGNvb3Jkcy50b3AgPj0gcmVjdC5ib3R0b20pKVxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGNoaWxkSW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2xvc2VzdCAmJiBmaXJzdEJlbG93KSB7XG4gICAgICAgIGNsb3Nlc3QgPSBmaXJzdEJlbG93O1xuICAgICAgICBjb29yZHNDbG9zZXN0ID0gY29vcmRzQmVsb3c7XG4gICAgICAgIGR4Q2xvc2VzdCA9IDA7XG4gICAgfVxuICAgIGlmIChjbG9zZXN0ICYmIGNsb3Nlc3Qubm9kZVR5cGUgPT0gMylcbiAgICAgICAgcmV0dXJuIGZpbmRPZmZzZXRJblRleHQoY2xvc2VzdCwgY29vcmRzQ2xvc2VzdCk7XG4gICAgaWYgKCFjbG9zZXN0IHx8IChkeENsb3Nlc3QgJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAxKSlcbiAgICAgICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0IH07XG4gICAgcmV0dXJuIGZpbmRPZmZzZXRJbk5vZGUoY2xvc2VzdCwgY29vcmRzQ2xvc2VzdCk7XG59XG5mdW5jdGlvbiBmaW5kT2Zmc2V0SW5UZXh0KG5vZGUsIGNvb3Jkcykge1xuICAgIGxldCBsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJhbmdlLnNldEVuZChub2RlLCBpICsgMSk7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGkpO1xuICAgICAgICBsZXQgcmVjdCA9IHNpbmdsZVJlY3QocmFuZ2UsIDEpO1xuICAgICAgICBpZiAocmVjdC50b3AgPT0gcmVjdC5ib3R0b20pXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGluUmVjdChjb29yZHMsIHJlY3QpKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0OiBpICsgKGNvb3Jkcy5sZWZ0ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0OiAwIH07XG59XG5mdW5jdGlvbiBpblJlY3QoY29vcmRzLCByZWN0KSB7XG4gICAgcmV0dXJuIGNvb3Jkcy5sZWZ0ID49IHJlY3QubGVmdCAtIDEgJiYgY29vcmRzLmxlZnQgPD0gcmVjdC5yaWdodCArIDEgJiZcbiAgICAgICAgY29vcmRzLnRvcCA+PSByZWN0LnRvcCAtIDEgJiYgY29vcmRzLnRvcCA8PSByZWN0LmJvdHRvbSArIDE7XG59XG5mdW5jdGlvbiB0YXJnZXRLbHVkZ2UoZG9tLCBjb29yZHMpIHtcbiAgICBsZXQgcGFyZW50ID0gZG9tLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCAmJiAvXmxpJC9pLnRlc3QocGFyZW50Lm5vZGVOYW1lKSAmJiBjb29yZHMubGVmdCA8IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KVxuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgIHJldHVybiBkb207XG59XG5mdW5jdGlvbiBwb3NGcm9tRWxlbWVudCh2aWV3LCBlbHQsIGNvb3Jkcykge1xuICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gZmluZE9mZnNldEluTm9kZShlbHQsIGNvb3JkcyksIGJpYXMgPSAtMTtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmICFub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbGV0IHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBiaWFzID0gcmVjdC5sZWZ0ICE9IHJlY3QucmlnaHQgJiYgY29vcmRzLmxlZnQgPiAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyID8gMSA6IC0xO1xuICAgIH1cbiAgICByZXR1cm4gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0LCBiaWFzKTtcbn1cbmZ1bmN0aW9uIHBvc0Zyb21DYXJldCh2aWV3LCBub2RlLCBvZmZzZXQsIGNvb3Jkcykge1xuICAgIC8vIEJyb3dzZXIgKGluIGNhcmV0UG9zaXRpb24vUmFuZ2VGcm9tUG9pbnQpIHdpbGwgYWdyZXNzaXZlbHlcbiAgICAvLyBub3JtYWxpemUgdG93YXJkcyBuZWFyYnkgaW5saW5lIG5vZGVzLiBTaW5jZSB3ZSBhcmUgaW50ZXJlc3RlZCBpblxuICAgIC8vIHBvc2l0aW9ucyBiZXR3ZWVuIGJsb2NrIG5vZGVzIHRvbywgd2UgZmlyc3Qgd2FsayB1cCB0aGUgaGllcmFyY2h5XG4gICAgLy8gb2Ygbm9kZXMgdG8gc2VlIGlmIHRoZXJlIGFyZSBibG9jayBub2RlcyB0aGF0IHRoZSBjb29yZGluYXRlc1xuICAgIC8vIGZhbGwgb3V0c2lkZSBvZi4gSWYgc28sIHdlIHRha2UgdGhlIHBvc2l0aW9uIGJlZm9yZS9hZnRlciB0aGF0XG4gICAgLy8gYmxvY2suIElmIG5vdCwgd2UgY2FsbCBgcG9zRnJvbURPTWAgb24gdGhlIHJhdyBub2RlL29mZnNldC5cbiAgICBsZXQgb3V0c2lkZUJsb2NrID0gLTE7XG4gICAgZm9yIChsZXQgY3VyID0gbm9kZSwgc2F3QmxvY2sgPSBmYWxzZTs7KSB7XG4gICAgICAgIGlmIChjdXIgPT0gdmlldy5kb20pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGRlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoY3VyLCB0cnVlKTtcbiAgICAgICAgaWYgKCFkZXNjKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChkZXNjLmRvbS5ub2RlVHlwZSA9PSAxICYmIChkZXNjLm5vZGUuaXNCbG9jayAmJiBkZXNjLnBhcmVudCAmJiAhc2F3QmxvY2sgfHwgIWRlc2MuY29udGVudERPTSkpIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gZGVzYy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBpZiAoZGVzYy5ub2RlLmlzQmxvY2sgJiYgZGVzYy5wYXJlbnQgJiYgIXNhd0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgc2F3QmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LmxlZnQgPiBjb29yZHMubGVmdCB8fCByZWN0LnRvcCA+IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICAgICAgICAgIG91dHNpZGVCbG9jayA9IGRlc2MucG9zQmVmb3JlO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCB8fCByZWN0LmJvdHRvbSA8IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICAgICAgICAgIG91dHNpZGVCbG9jayA9IGRlc2MucG9zQWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRlc2MuY29udGVudERPTSAmJiBvdXRzaWRlQmxvY2sgPCAwICYmICFkZXNjLm5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGluc2lkZSBhIGxlYWYsIHJldHVybiB0aGUgc2lkZSBvZiB0aGUgbGVhZiBjbG9zZXIgdG8gdGhlIGNvb3Jkc1xuICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBkZXNjLm5vZGUuaXNCbG9jayA/IGNvb3Jkcy50b3AgPCAocmVjdC50b3AgKyByZWN0LmJvdHRvbSkgLyAyXG4gICAgICAgICAgICAgICAgICAgIDogY29vcmRzLmxlZnQgPCAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBiZWZvcmUgPyBkZXNjLnBvc0JlZm9yZSA6IGRlc2MucG9zQWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VyID0gZGVzYy5kb20ucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHNpZGVCbG9jayA+IC0xID8gb3V0c2lkZUJsb2NrIDogdmlldy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0LCAtMSk7XG59XG5mdW5jdGlvbiBlbGVtZW50RnJvbVBvaW50KGVsZW1lbnQsIGNvb3JkcywgYm94KSB7XG4gICAgbGV0IGxlbiA9IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgaWYgKGxlbiAmJiBib3gudG9wIDwgYm94LmJvdHRvbSkge1xuICAgICAgICBmb3IgKGxldCBzdGFydEkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsZW4gLSAxLCBNYXRoLmZsb29yKGxlbiAqIChjb29yZHMudG9wIC0gYm94LnRvcCkgLyAoYm94LmJvdHRvbSAtIGJveC50b3ApKSAtIDIpKSwgaSA9IHN0YXJ0STs7KSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIGxldCByZWN0cyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZWN0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5SZWN0KGNvb3JkcywgcmVjdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudEZyb21Qb2ludChjaGlsZCwgY29vcmRzLCByZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgPSAoaSArIDEpICUgbGVuKSA9PSBzdGFydEkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG4vLyBHaXZlbiBhbiB4LHkgcG9zaXRpb24gb24gdGhlIGVkaXRvciwgZ2V0IHRoZSBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQuXG5mdW5jdGlvbiBwb3NBdENvb3Jkcyh2aWV3LCBjb29yZHMpIHtcbiAgICBsZXQgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudCwgbm9kZSwgb2Zmc2V0ID0gMDtcbiAgICBsZXQgY2FyZXQgPSBjYXJldEZyb21Qb2ludChkb2MsIGNvb3Jkcy5sZWZ0LCBjb29yZHMudG9wKTtcbiAgICBpZiAoY2FyZXQpXG4gICAgICAgICh7IG5vZGUsIG9mZnNldCB9ID0gY2FyZXQpO1xuICAgIGxldCBlbHQgPSAodmlldy5yb290LmVsZW1lbnRGcm9tUG9pbnQgPyB2aWV3LnJvb3QgOiBkb2MpXG4gICAgICAgIC5lbGVtZW50RnJvbVBvaW50KGNvb3Jkcy5sZWZ0LCBjb29yZHMudG9wKTtcbiAgICBsZXQgcG9zO1xuICAgIGlmICghZWx0IHx8ICF2aWV3LmRvbS5jb250YWlucyhlbHQubm9kZVR5cGUgIT0gMSA/IGVsdC5wYXJlbnROb2RlIDogZWx0KSkge1xuICAgICAgICBsZXQgYm94ID0gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmICghaW5SZWN0KGNvb3JkcywgYm94KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBlbHQgPSBlbGVtZW50RnJvbVBvaW50KHZpZXcuZG9tLCBjb29yZHMsIGJveCk7XG4gICAgICAgIGlmICghZWx0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNhZmFyaSdzIGNhcmV0UmFuZ2VGcm9tUG9pbnQgcmV0dXJucyBub25zZW5zZSB3aGVuIG9uIGEgZHJhZ2dhYmxlIGVsZW1lbnRcbiAgICBpZiAoc2FmYXJpKSB7XG4gICAgICAgIGZvciAobGV0IHAgPSBlbHQ7IG5vZGUgJiYgcDsgcCA9IHBhcmVudE5vZGUocCkpXG4gICAgICAgICAgICBpZiAocC5kcmFnZ2FibGUpXG4gICAgICAgICAgICAgICAgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWx0ID0gdGFyZ2V0S2x1ZGdlKGVsdCwgY29vcmRzKTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgICBpZiAoZ2Vja28gJiYgbm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IHdpbGwgc29tZXRpbWVzIHJldHVybiBvZmZzZXRzIGludG8gPGlucHV0PiBub2Rlcywgd2hpY2hcbiAgICAgICAgICAgIC8vIGhhdmUgbm8gYWN0dWFsIGNoaWxkcmVuLCBmcm9tIGNhcmV0UG9zaXRpb25Gcm9tUG9pbnQgKCM5NTMpXG4gICAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1pbihvZmZzZXQsIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAgICAgICAgLy8gSXQnbGwgYWxzbyBtb3ZlIHRoZSByZXR1cm5lZCBwb3NpdGlvbiBiZWZvcmUgaW1hZ2Ugbm9kZXMsXG4gICAgICAgICAgICAvLyBldmVuIGlmIHRob3NlIGFyZSBiZWhpbmQgaXQuXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF0sIGJveDtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5ub2RlTmFtZSA9PSBcIklNR1wiICYmIChib3ggPSBuZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKS5yaWdodCA8PSBjb29yZHMubGVmdCAmJlxuICAgICAgICAgICAgICAgICAgICBib3guYm90dG9tID4gY29vcmRzLnRvcClcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZXY7XG4gICAgICAgIC8vIFdoZW4gY2xpY2tpbmcgYWJvdmUgdGhlIHJpZ2h0IHNpZGUgb2YgYW4gdW5lZGl0YWJsZSBub2RlLCBDaHJvbWUgd2lsbCByZXBvcnQgYSBjdXJzb3IgcG9zaXRpb24gYWZ0ZXIgdGhhdCBub2RlLlxuICAgICAgICBpZiAod2Via2l0ICYmIG9mZnNldCAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgKHByZXYgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV0pLm5vZGVUeXBlID09IDEgJiZcbiAgICAgICAgICAgIHByZXYuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIiAmJiBwcmV2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA+PSBjb29yZHMudG9wKVxuICAgICAgICAgICAgb2Zmc2V0LS07XG4gICAgICAgIC8vIFN1c3BpY2lvdXNseSBzcGVjaWZpYyBrbHVkZ2UgdG8gd29yayBhcm91bmQgY2FyZXQqRnJvbVBvaW50XG4gICAgICAgIC8vIG5ldmVyIHJldHVybmluZyBhIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgIGlmIChub2RlID09IHZpZXcuZG9tICYmIG9mZnNldCA9PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMSAmJiBub2RlLmxhc3RDaGlsZC5ub2RlVHlwZSA9PSAxICYmXG4gICAgICAgICAgICBjb29yZHMudG9wID4gbm9kZS5sYXN0Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tKVxuICAgICAgICAgICAgcG9zID0gdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplO1xuICAgICAgICAvLyBJZ25vcmUgcG9zaXRpb25zIGRpcmVjdGx5IGFmdGVyIGEgQlIsIHNpbmNlIGNhcmV0KkZyb21Qb2ludFxuICAgICAgICAvLyAncm91bmQgdXAnIHBvc2l0aW9ucyB0aGF0IHdvdWxkIGJlIG1vcmUgYWNjdXJhdGVseSBwbGFjZWRcbiAgICAgICAgLy8gYmVmb3JlIHRoZSBCUiBub2RlLlxuICAgICAgICBlbHNlIGlmIChvZmZzZXQgPT0gMCB8fCBub2RlLm5vZGVUeXBlICE9IDEgfHwgbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdLm5vZGVOYW1lICE9IFwiQlJcIilcbiAgICAgICAgICAgIHBvcyA9IHBvc0Zyb21DYXJldCh2aWV3LCBub2RlLCBvZmZzZXQsIGNvb3Jkcyk7XG4gICAgfVxuICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgcG9zID0gcG9zRnJvbUVsZW1lbnQodmlldywgZWx0LCBjb29yZHMpO1xuICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGVsdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHsgcG9zLCBpbnNpZGU6IGRlc2MgPyBkZXNjLnBvc0F0U3RhcnQgLSBkZXNjLmJvcmRlciA6IC0xIH07XG59XG5mdW5jdGlvbiBub25aZXJvKHJlY3QpIHtcbiAgICByZXR1cm4gcmVjdC50b3AgPCByZWN0LmJvdHRvbSB8fCByZWN0LmxlZnQgPCByZWN0LnJpZ2h0O1xufVxuZnVuY3Rpb24gc2luZ2xlUmVjdCh0YXJnZXQsIGJpYXMpIHtcbiAgICBsZXQgcmVjdHMgPSB0YXJnZXQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBpZiAocmVjdHMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBmaXJzdCA9IHJlY3RzW2JpYXMgPCAwID8gMCA6IHJlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobm9uWmVybyhmaXJzdCkpXG4gICAgICAgICAgICByZXR1cm4gZmlyc3Q7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKHJlY3RzLCBub25aZXJvKSB8fCB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5jb25zdCBCSURJID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNdLztcbi8vIEdpdmVuIGEgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50IG1vZGVsLCBnZXQgYSBib3VuZGluZyBib3ggb2YgdGhlXG4vLyBjaGFyYWN0ZXIgYXQgdGhhdCBwb3NpdGlvbiwgcmVsYXRpdmUgdG8gdGhlIHdpbmRvdy5cbmZ1bmN0aW9uIGNvb3Jkc0F0UG9zKHZpZXcsIHBvcywgc2lkZSkge1xuICAgIGxldCB7IG5vZGUsIG9mZnNldCwgYXRvbSB9ID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCBzaWRlIDwgMCA/IC0xIDogMSk7XG4gICAgbGV0IHN1cHBvcnRFbXB0eVJhbmdlID0gd2Via2l0IHx8IGdlY2tvO1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgLy8gVGhlc2UgYnJvd3NlcnMgc3VwcG9ydCBxdWVyeWluZyBlbXB0eSB0ZXh0IHJhbmdlcy4gUHJlZmVyIHRoYXQgaW5cbiAgICAgICAgLy8gYmlkaSBjb250ZXh0IG9yIHdoZW4gYXQgdGhlIGVuZCBvZiBhIG5vZGUuXG4gICAgICAgIGlmIChzdXBwb3J0RW1wdHlSYW5nZSAmJiAoQklESS50ZXN0KG5vZGUubm9kZVZhbHVlKSB8fCAoc2lkZSA8IDAgPyAhb2Zmc2V0IDogb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkpKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCwgb2Zmc2V0KSwgc2lkZSk7XG4gICAgICAgICAgICAvLyBGaXJlZm94IHJldHVybnMgYmFkIHJlc3VsdHMgKHRoZSBwb3NpdGlvbiBiZWZvcmUgdGhlIHNwYWNlKVxuICAgICAgICAgICAgLy8gd2hlbiBxdWVyeWluZyBhIHBvc2l0aW9uIGRpcmVjdGx5IGFmdGVyIGxpbmUtYnJva2VuXG4gICAgICAgICAgICAvLyB3aGl0ZXNwYWNlLiBEZXRlY3QgdGhpcyBzaXR1YXRpb24gYW5kIGFuZCBrbHVkZ2UgYXJvdW5kIGl0XG4gICAgICAgICAgICBpZiAoZ2Vja28gJiYgb2Zmc2V0ICYmIC9cXHMvLnRlc3Qobm9kZS5ub2RlVmFsdWVbb2Zmc2V0IC0gMV0pICYmIG9mZnNldCA8IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCByZWN0QmVmb3JlID0gc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgb2Zmc2V0IC0gMSwgb2Zmc2V0IC0gMSksIC0xKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjdEJlZm9yZS50b3AgPT0gcmVjdC50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3RBZnRlciA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCwgb2Zmc2V0ICsgMSksIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RBZnRlci50b3AgIT0gcmVjdC50b3ApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlblYocmVjdEFmdGVyLCByZWN0QWZ0ZXIubGVmdCA8IHJlY3RCZWZvcmUubGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IG9mZnNldCwgdG8gPSBvZmZzZXQsIHRha2VTaWRlID0gc2lkZSA8IDAgPyAxIDogLTE7XG4gICAgICAgICAgICBpZiAoc2lkZSA8IDAgJiYgIW9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICAgICAgdGFrZVNpZGUgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpZGUgPj0gMCAmJiBvZmZzZXQgPT0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICAgICAgICAgIHRha2VTaWRlID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpZGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBmcm9tLCB0byksIHRha2VTaWRlKSwgdGFrZVNpZGUgPCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgJGRvbSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zIC0gKGF0b20gfHwgMCkpO1xuICAgIC8vIFJldHVybiBhIGhvcml6b250YWwgbGluZSBpbiBibG9jayBjb250ZXh0XG4gICAgaWYgKCEkZG9tLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0ICYmIChzaWRlIDwgMCB8fCBvZmZzZXQgPT0gbm9kZVNpemUobm9kZSkpKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgaWYgKGJlZm9yZS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmbGF0dGVuSChiZWZvcmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCA8IG5vZGVTaXplKG5vZGUpKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChhZnRlci5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmbGF0dGVuSChhZnRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5IKG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHNpZGUgPj0gMCk7XG4gICAgfVxuICAgIC8vIElubGluZSwgbm90IGluIHRleHQgbm9kZSAodGhpcyBpcyBub3QgQmlkaS1zYWZlKVxuICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0ICYmIChzaWRlIDwgMCB8fCBvZmZzZXQgPT0gbm9kZVNpemUobm9kZSkpKSB7XG4gICAgICAgIGxldCBiZWZvcmUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgIGxldCB0YXJnZXQgPSBiZWZvcmUubm9kZVR5cGUgPT0gMyA/IHRleHRSYW5nZShiZWZvcmUsIG5vZGVTaXplKGJlZm9yZSkgLSAoc3VwcG9ydEVtcHR5UmFuZ2UgPyAwIDogMSkpXG4gICAgICAgICAgICAvLyBCUiBub2RlcyB0ZW5kIHRvIG9ubHkgcmV0dXJuIHRoZSByZWN0YW5nbGUgYmVmb3JlIHRoZW0uXG4gICAgICAgICAgICAvLyBPbmx5IHVzZSB0aGVtIGlmIHRoZXkgYXJlIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlaXIgcGFyZW50XG4gICAgICAgICAgICA6IGJlZm9yZS5ub2RlVHlwZSA9PSAxICYmIChiZWZvcmUubm9kZU5hbWUgIT0gXCJCUlwiIHx8ICFiZWZvcmUubmV4dFNpYmxpbmcpID8gYmVmb3JlIDogbnVsbDtcbiAgICAgICAgaWYgKHRhcmdldClcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KHRhcmdldCwgMSksIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKGF0b20gPT0gbnVsbCAmJiBvZmZzZXQgPCBub2RlU2l6ZShub2RlKSkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgd2hpbGUgKGFmdGVyLnBtVmlld0Rlc2MgJiYgYWZ0ZXIucG1WaWV3RGVzYy5pZ25vcmVGb3JDb29yZHMpXG4gICAgICAgICAgICBhZnRlciA9IGFmdGVyLm5leHRTaWJsaW5nO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gIWFmdGVyID8gbnVsbCA6IGFmdGVyLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2UoYWZ0ZXIsIDAsIChzdXBwb3J0RW1wdHlSYW5nZSA/IDAgOiAxKSlcbiAgICAgICAgICAgIDogYWZ0ZXIubm9kZVR5cGUgPT0gMSA/IGFmdGVyIDogbnVsbDtcbiAgICAgICAgaWYgKHRhcmdldClcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KHRhcmdldCwgLTEpLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gQWxsIGVsc2UgZmFpbGVkLCBqdXN0IHRyeSB0byBnZXQgYSByZWN0YW5nbGUgZm9yIHRoZSB0YXJnZXQgbm9kZVxuICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KG5vZGUubm9kZVR5cGUgPT0gMyA/IHRleHRSYW5nZShub2RlKSA6IG5vZGUsIC1zaWRlKSwgc2lkZSA+PSAwKTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5WKHJlY3QsIGxlZnQpIHtcbiAgICBpZiAocmVjdC53aWR0aCA9PSAwKVxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICBsZXQgeCA9IGxlZnQgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0O1xuICAgIHJldHVybiB7IHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC5ib3R0b20sIGxlZnQ6IHgsIHJpZ2h0OiB4IH07XG59XG5mdW5jdGlvbiBmbGF0dGVuSChyZWN0LCB0b3ApIHtcbiAgICBpZiAocmVjdC5oZWlnaHQgPT0gMClcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgbGV0IHkgPSB0b3AgPyByZWN0LnRvcCA6IHJlY3QuYm90dG9tO1xuICAgIHJldHVybiB7IHRvcDogeSwgYm90dG9tOiB5LCBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LnJpZ2h0IH07XG59XG5mdW5jdGlvbiB3aXRoRmx1c2hlZFN0YXRlKHZpZXcsIHN0YXRlLCBmKSB7XG4gICAgbGV0IHZpZXdTdGF0ZSA9IHZpZXcuc3RhdGUsIGFjdGl2ZSA9IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50O1xuICAgIGlmICh2aWV3U3RhdGUgIT0gc3RhdGUpXG4gICAgICAgIHZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgIGlmIChhY3RpdmUgIT0gdmlldy5kb20pXG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZigpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHZpZXdTdGF0ZSAhPSBzdGF0ZSlcbiAgICAgICAgICAgIHZpZXcudXBkYXRlU3RhdGUodmlld1N0YXRlKTtcbiAgICAgICAgaWYgKGFjdGl2ZSAhPSB2aWV3LmRvbSAmJiBhY3RpdmUpXG4gICAgICAgICAgICBhY3RpdmUuZm9jdXMoKTtcbiAgICB9XG59XG4vLyBXaGV0aGVyIHZlcnRpY2FsIHBvc2l0aW9uIG1vdGlvbiBpbiBhIGdpdmVuIGRpcmVjdGlvblxuLy8gZnJvbSBhIHBvc2l0aW9uIHdvdWxkIGxlYXZlIGEgdGV4dCBibG9jay5cbmZ1bmN0aW9uIGVuZE9mVGV4dGJsb2NrVmVydGljYWwodmlldywgc3RhdGUsIGRpcikge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0ICRwb3MgPSBkaXIgPT0gXCJ1cFwiID8gc2VsLiRmcm9tIDogc2VsLiR0bztcbiAgICByZXR1cm4gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgKCkgPT4ge1xuICAgICAgICBsZXQgeyBub2RlOiBkb20gfSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKCRwb3MucG9zLCBkaXIgPT0gXCJ1cFwiID8gLTEgOiAxKTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5lYXJlc3QgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZG9tLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghbmVhcmVzdClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChuZWFyZXN0Lm5vZGUuaXNCbG9jaykge1xuICAgICAgICAgICAgICAgIGRvbSA9IG5lYXJlc3QuY29udGVudERPTSB8fCBuZWFyZXN0LmRvbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbSA9IG5lYXJlc3QuZG9tLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvb3JkcyA9IGNvb3Jkc0F0UG9zKHZpZXcsICRwb3MucG9zLCAxKTtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgPSBkb20uZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGxldCBib3hlcztcbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIGJveGVzID0gY2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICAgICAgYm94ZXMgPSB0ZXh0UmFuZ2UoY2hpbGQsIDAsIGNoaWxkLm5vZGVWYWx1ZS5sZW5ndGgpLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJveCA9IGJveGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChib3guYm90dG9tID4gYm94LnRvcCArIDEgJiZcbiAgICAgICAgICAgICAgICAgICAgKGRpciA9PSBcInVwXCIgPyBjb29yZHMudG9wIC0gYm94LnRvcCA+IChib3guYm90dG9tIC0gY29vcmRzLnRvcCkgKiAyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGJveC5ib3R0b20gLSBjb29yZHMuYm90dG9tID4gKGNvb3Jkcy5ib3R0b20gLSBib3gudG9wKSAqIDIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG59XG5jb25zdCBtYXliZVJUTCA9IC9bXFx1MDU5MC1cXHUwOGFjXS87XG5mdW5jdGlvbiBlbmRPZlRleHRibG9ja0hvcml6b250YWwodmlldywgc3RhdGUsIGRpcikge1xuICAgIGxldCB7ICRoZWFkIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQuaXNUZXh0YmxvY2spXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0ID0gJGhlYWQucGFyZW50T2Zmc2V0LCBhdFN0YXJ0ID0gIW9mZnNldCwgYXRFbmQgPSBvZmZzZXQgPT0gJGhlYWQucGFyZW50LmNvbnRlbnQuc2l6ZTtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb24oKTtcbiAgICAvLyBJZiB0aGUgdGV4dGJsb2NrIGlzIGFsbCBMVFIsIG9yIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydFxuICAgIC8vIFNlbGVjdGlvbi5tb2RpZnkgKEVkZ2UpLCBmYWxsIGJhY2sgdG8gYSBwcmltaXRpdmUgYXBwcm9hY2hcbiAgICBpZiAoIW1heWJlUlRMLnRlc3QoJGhlYWQucGFyZW50LnRleHRDb250ZW50KSB8fCAhc2VsLm1vZGlmeSlcbiAgICAgICAgcmV0dXJuIGRpciA9PSBcImxlZnRcIiB8fCBkaXIgPT0gXCJiYWNrd2FyZFwiID8gYXRTdGFydCA6IGF0RW5kO1xuICAgIHJldHVybiB3aXRoRmx1c2hlZFN0YXRlKHZpZXcsIHN0YXRlLCAoKSA9PiB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBodWdlIGhhY2ssIGJ1dCBhcHBlYXJzIHRvIGJlIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBjdXJyZW50bHkgZG86IHVzZSBgU2VsZWN0aW9uLm1vZGlmeWAgdG8gbW92ZSB0aGUgc2VsZWN0aW9uIGJ5XG4gICAgICAgIC8vIG9uZSBjaGFyYWN0ZXIsIGFuZCBzZWUgaWYgdGhhdCBtb3ZlcyB0aGUgY3Vyc29yIG91dCBvZiB0aGVcbiAgICAgICAgLy8gdGV4dGJsb2NrIChvciBkb2Vzbid0IG1vdmUgaXQgYXQgYWxsLCB3aGVuIGF0IHRoZSBzdGFydC9lbmQgb2ZcbiAgICAgICAgLy8gdGhlIGRvY3VtZW50KS5cbiAgICAgICAgbGV0IHsgZm9jdXNOb2RlOiBvbGROb2RlLCBmb2N1c09mZnNldDogb2xkT2ZmLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQgfSA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IG9sZEJpZGlMZXZlbCA9IHNlbC5jYXJldEJpZGlMZXZlbCAvLyBPbmx5IGZvciBGaXJlZm94XG4gICAgICAgIDtcbiAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgZGlyLCBcImNoYXJhY3RlclwiKTtcbiAgICAgICAgbGV0IHBhcmVudERPTSA9ICRoZWFkLmRlcHRoID8gdmlldy5kb2NWaWV3LmRvbUFmdGVyUG9zKCRoZWFkLmJlZm9yZSgpKSA6IHZpZXcuZG9tO1xuICAgICAgICBsZXQgeyBmb2N1c05vZGU6IG5ld05vZGUsIGZvY3VzT2Zmc2V0OiBuZXdPZmYgfSA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ld05vZGUgJiYgIXBhcmVudERPTS5jb250YWlucyhuZXdOb2RlLm5vZGVUeXBlID09IDEgPyBuZXdOb2RlIDogbmV3Tm9kZS5wYXJlbnROb2RlKSB8fFxuICAgICAgICAgICAgKG9sZE5vZGUgPT0gbmV3Tm9kZSAmJiBvbGRPZmYgPT0gbmV3T2ZmKTtcbiAgICAgICAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZWwuY29sbGFwc2UoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChvbGROb2RlICYmIChvbGROb2RlICE9IGFuY2hvck5vZGUgfHwgb2xkT2ZmICE9IGFuY2hvck9mZnNldCkgJiYgc2VsLmV4dGVuZClcbiAgICAgICAgICAgICAgICBzZWwuZXh0ZW5kKG9sZE5vZGUsIG9sZE9mZik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICBpZiAob2xkQmlkaUxldmVsICE9IG51bGwpXG4gICAgICAgICAgICBzZWwuY2FyZXRCaWRpTGV2ZWwgPSBvbGRCaWRpTGV2ZWw7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG59XG5sZXQgY2FjaGVkU3RhdGUgPSBudWxsO1xubGV0IGNhY2hlZERpciA9IG51bGw7XG5sZXQgY2FjaGVkUmVzdWx0ID0gZmFsc2U7XG5mdW5jdGlvbiBlbmRPZlRleHRibG9jayh2aWV3LCBzdGF0ZSwgZGlyKSB7XG4gICAgaWYgKGNhY2hlZFN0YXRlID09IHN0YXRlICYmIGNhY2hlZERpciA9PSBkaXIpXG4gICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gICAgY2FjaGVkU3RhdGUgPSBzdGF0ZTtcbiAgICBjYWNoZWREaXIgPSBkaXI7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3VsdCA9IGRpciA9PSBcInVwXCIgfHwgZGlyID09IFwiZG93blwiXG4gICAgICAgID8gZW5kT2ZUZXh0YmxvY2tWZXJ0aWNhbCh2aWV3LCBzdGF0ZSwgZGlyKVxuICAgICAgICA6IGVuZE9mVGV4dGJsb2NrSG9yaXpvbnRhbCh2aWV3LCBzdGF0ZSwgZGlyKTtcbn1cblxuLy8gVmlldyBkZXNjcmlwdGlvbnMgYXJlIGRhdGEgc3RydWN0dXJlcyB0aGF0IGRlc2NyaWJlIHRoZSBET00gdGhhdCBpc1xuLy8gdXNlZCB0byByZXByZXNlbnQgdGhlIGVkaXRvcidzIGNvbnRlbnQuIFRoZXkgYXJlIHVzZWQgZm9yOlxuLy9cbi8vIC0gSW5jcmVtZW50YWwgcmVkcmF3aW5nIHdoZW4gdGhlIGRvY3VtZW50IGNoYW5nZXNcbi8vXG4vLyAtIEZpZ3VyaW5nIG91dCB3aGF0IHBhcnQgb2YgdGhlIGRvY3VtZW50IGEgZ2l2ZW4gRE9NIHBvc2l0aW9uXG4vLyAgIGNvcnJlc3BvbmRzIHRvXG4vL1xuLy8gLSBXaXJpbmcgaW4gY3VzdG9tIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgZWRpdGluZyBpbnRlcmZhY2UgZm9yIGFcbi8vICAgZ2l2ZW4gbm9kZVxuLy9cbi8vIFRoZXkgZm9ybSBhIGRvdWJseS1saW5rZWQgbXV0YWJsZSB0cmVlLCBzdGFydGluZyBhdCBgdmlldy5kb2NWaWV3YC5cbmNvbnN0IE5PVF9ESVJUWSA9IDAsIENISUxEX0RJUlRZID0gMSwgQ09OVEVOVF9ESVJUWSA9IDIsIE5PREVfRElSVFkgPSAzO1xuLy8gU3VwZXJjbGFzcyBmb3IgdGhlIHZhcmlvdXMga2luZHMgb2YgZGVzY3JpcHRpb25zLiBEZWZpbmVzIHRoZWlyXG4vLyBiYXNpYyBzdHJ1Y3R1cmUgYW5kIHNoYXJlZCBtZXRob2RzLlxuY2xhc3MgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgY2hpbGRyZW4sIGRvbSwgXG4gICAgLy8gVGhpcyBpcyB0aGUgbm9kZSB0aGF0IGhvbGRzIHRoZSBjaGlsZCB2aWV3cy4gSXQgbWF5IGJlIG51bGwgZm9yXG4gICAgLy8gZGVzY3MgdGhhdCBkb24ndCBoYXZlIGNoaWxkcmVuLlxuICAgIGNvbnRlbnRET00pIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5kb20gPSBkb207XG4gICAgICAgIHRoaXMuY29udGVudERPTSA9IGNvbnRlbnRET007XG4gICAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgIC8vIEFuIGV4cGFuZG8gcHJvcGVydHkgb24gdGhlIERPTSBub2RlIHByb3ZpZGVzIGEgbGluayBiYWNrIHRvIGl0c1xuICAgICAgICAvLyBkZXNjcmlwdGlvbi5cbiAgICAgICAgZG9tLnBtVmlld0Rlc2MgPSB0aGlzO1xuICAgIH1cbiAgICAvLyBVc2VkIHRvIGNoZWNrIHdoZXRoZXIgYSBnaXZlbiBkZXNjcmlwdGlvbiBjb3JyZXNwb25kcyB0byBhXG4gICAgLy8gd2lkZ2V0L21hcmsvbm9kZS5cbiAgICBtYXRjaGVzV2lkZ2V0KHdpZGdldCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzTWFyayhtYXJrKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIG1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIG1hdGNoZXNIYWNrKG5vZGVOYW1lKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIFdoZW4gcGFyc2luZyBpbi1lZGl0b3IgY29udGVudCAoaW4gZG9tY2hhbmdlLmpzKSwgd2UgYWxsb3dcbiAgICAvLyBkZXNjcmlwdGlvbnMgdG8gZGV0ZXJtaW5lIHRoZSBwYXJzZSBydWxlcyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvXG4gICAgLy8gcGFyc2UgdGhlbS5cbiAgICBwYXJzZVJ1bGUoKSB7IHJldHVybiBudWxsOyB9XG4gICAgLy8gVXNlZCBieSB0aGUgZWRpdG9yJ3MgZXZlbnQgaGFuZGxlciB0byBpZ25vcmUgZXZlbnRzIHRoYXQgY29tZVxuICAgIC8vIGZyb20gY2VydGFpbiBkZXNjcy5cbiAgICBzdG9wRXZlbnQoZXZlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLy8gVGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgcmVwcmVzZW50ZWQgYnkgdGhpcyBkZXNjLlxuICAgIGdldCBzaXplKCkge1xuICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHNpemUgKz0gdGhpcy5jaGlsZHJlbltpXS5zaXplO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgLy8gRm9yIGJsb2NrIG5vZGVzLCB0aGlzIHJlcHJlc2VudHMgdGhlIHNwYWNlIHRha2VuIHVwIGJ5IHRoZWlyXG4gICAgLy8gc3RhcnQvZW5kIHRva2Vucy5cbiAgICBnZXQgYm9yZGVyKCkgeyByZXR1cm4gMDsgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5kb20ucG1WaWV3RGVzYyA9PSB0aGlzKVxuICAgICAgICAgICAgdGhpcy5kb20ucG1WaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHBvc0JlZm9yZUNoaWxkKGNoaWxkKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSB0aGlzLnBvc0F0U3RhcnQ7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGN1ciA9PSBjaGlsZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgcG9zICs9IGN1ci5zaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwb3NCZWZvcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5wb3NCZWZvcmVDaGlsZCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHBvc0F0U3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnBvc0JlZm9yZUNoaWxkKHRoaXMpICsgdGhpcy5ib3JkZXIgOiAwO1xuICAgIH1cbiAgICBnZXQgcG9zQWZ0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc0JlZm9yZSArIHRoaXMuc2l6ZTtcbiAgICB9XG4gICAgZ2V0IHBvc0F0RW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgdGhpcy5zaXplIC0gMiAqIHRoaXMuYm9yZGVyO1xuICAgIH1cbiAgICBsb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpIHtcbiAgICAgICAgLy8gSWYgdGhlIERPTSBwb3NpdGlvbiBpcyBpbiB0aGUgY29udGVudCwgdXNlIHRoZSBjaGlsZCBkZXNjIGFmdGVyXG4gICAgICAgIC8vIGl0IHRvIGZpZ3VyZSBvdXQgYSBwb3NpdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00uY29udGFpbnMoZG9tLm5vZGVUeXBlID09IDEgPyBkb20gOiBkb20ucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChiaWFzIDwgMCkge1xuICAgICAgICAgICAgICAgIGxldCBkb21CZWZvcmUsIGRlc2M7XG4gICAgICAgICAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tQmVmb3JlID0gZG9tLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChkb21CZWZvcmUgJiYgISgoZGVzYyA9IGRvbUJlZm9yZS5wbVZpZXdEZXNjKSAmJiBkZXNjLnBhcmVudCA9PSB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgZG9tQmVmb3JlID0gZG9tQmVmb3JlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tQmVmb3JlID8gdGhpcy5wb3NCZWZvcmVDaGlsZChkZXNjKSArIGRlc2Muc2l6ZSA6IHRoaXMucG9zQXRTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBkb21BZnRlciwgZGVzYztcbiAgICAgICAgICAgICAgICBpZiAoZG9tID09IHRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgICAgICAgICBkb21BZnRlciA9IGRvbS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGRvbUFmdGVyID0gZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoZG9tQWZ0ZXIgJiYgISgoZGVzYyA9IGRvbUFmdGVyLnBtVmlld0Rlc2MpICYmIGRlc2MucGFyZW50ID09IHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICBkb21BZnRlciA9IGRvbUFmdGVyLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIHJldHVybiBkb21BZnRlciA/IHRoaXMucG9zQmVmb3JlQ2hpbGQoZGVzYykgOiB0aGlzLnBvc0F0RW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIHZhcmlvdXMgaGV1cmlzdGljcywgZmFsbGluZyBiYWNrIG9uIHRoZSBiaWFzXG4gICAgICAgIC8vIHBhcmFtZXRlciwgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmV0dXJuIHRoZSBwb3NpdGlvbiBhdCB0aGVcbiAgICAgICAgLy8gc3RhcnQgb3IgYXQgdGhlIGVuZCBvZiB0aGlzIHZpZXcgZGVzYy5cbiAgICAgICAgbGV0IGF0RW5kO1xuICAgICAgICBpZiAoZG9tID09IHRoaXMuZG9tICYmIHRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgYXRFbmQgPSBvZmZzZXQgPiBkb21JbmRleCh0aGlzLmNvbnRlbnRET00pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00gIT0gdGhpcy5kb20gJiYgdGhpcy5kb20uY29udGFpbnModGhpcy5jb250ZW50RE9NKSkge1xuICAgICAgICAgICAgYXRFbmQgPSBkb20uY29tcGFyZURvY3VtZW50UG9zaXRpb24odGhpcy5jb250ZW50RE9NKSAmIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kb20uZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSAwKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNlYXJjaCA9IGRvbTs7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2ggPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0RW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoLnByZXZpb3VzU2libGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdEVuZCA9PSBudWxsICYmIG9mZnNldCA9PSBkb20uY2hpbGROb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2VhcmNoID0gZG9tOzsgc2VhcmNoID0gc2VhcmNoLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaCA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGF0RW5kID09IG51bGwgPyBiaWFzID4gMCA6IGF0RW5kKSA/IHRoaXMucG9zQXRFbmQgOiB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgfVxuICAgIG5lYXJlc3REZXNjKGRvbSwgb25seU5vZGVzID0gZmFsc2UpIHtcbiAgICAgICAgZm9yIChsZXQgZmlyc3QgPSB0cnVlLCBjdXIgPSBkb207IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gdGhpcy5nZXREZXNjKGN1ciksIG5vZGVET007XG4gICAgICAgICAgICBpZiAoZGVzYyAmJiAoIW9ubHlOb2RlcyB8fCBkZXNjLm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgZG9tIGlzIG91dHNpZGUgb2YgdGhpcyBkZXNjJ3Mgbm9kZURPTSwgZG9uJ3QgY291bnQgaXQuXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0ICYmIChub2RlRE9NID0gZGVzYy5ub2RlRE9NKSAmJlxuICAgICAgICAgICAgICAgICAgICAhKG5vZGVET00ubm9kZVR5cGUgPT0gMSA/IG5vZGVET00uY29udGFpbnMoZG9tLm5vZGVUeXBlID09IDEgPyBkb20gOiBkb20ucGFyZW50Tm9kZSkgOiBub2RlRE9NID09IGRvbSkpXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREZXNjKGRvbSkge1xuICAgICAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBkZXNjOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgICAgICBpZiAoY3VyID09IHRoaXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgfVxuICAgIHBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpIHtcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IGRvbTsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgbGV0IGRlc2MgPSB0aGlzLmdldERlc2Moc2Nhbik7XG4gICAgICAgICAgICBpZiAoZGVzYylcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5sb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgLy8gRmluZCB0aGUgZGVzYyBmb3IgdGhlIG5vZGUgYWZ0ZXIgdGhlIGdpdmVuIHBvcywgaWYgYW55LiAoV2hlbiBhXG4gICAgLy8gcGFyZW50IG5vZGUgb3ZlcnJvZGUgcmVuZGVyaW5nLCB0aGVyZSBtaWdodCBub3QgYmUgb25lLilcbiAgICBkZXNjQXQocG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gcG9zICYmIGVuZCAhPSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWNoaWxkLmJvcmRlciAmJiBjaGlsZC5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuZGVzY0F0KHBvcyAtIG9mZnNldCAtIGNoaWxkLmJvcmRlcik7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9tRnJvbVBvcyhwb3MsIHNpZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmRvbSwgb2Zmc2V0OiAwLCBhdG9tOiBwb3MgKyAxIH07XG4gICAgICAgIC8vIEZpcnN0IGZpbmQgdGhlIHBvc2l0aW9uIGluIHRoZSBjaGlsZCBhcnJheVxuICAgICAgICBsZXQgaSA9IDAsIG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGN1clBvcyA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBjdXJQb3MgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKGVuZCA+IHBvcyB8fCBjaGlsZCBpbnN0YW5jZW9mIFRyYWlsaW5nSGFja1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gcG9zIC0gY3VyUG9zO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyUG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoaXMgcG9pbnRzIGludG8gdGhlIG1pZGRsZSBvZiBhIGNoaWxkLCBjYWxsIHRocm91Z2hcbiAgICAgICAgaWYgKG9mZnNldClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldLmRvbUZyb21Qb3Mob2Zmc2V0IC0gdGhpcy5jaGlsZHJlbltpXS5ib3JkZXIsIHNpZGUpO1xuICAgICAgICAvLyBHbyBiYWNrIGlmIHRoZXJlIHdlcmUgYW55IHplcm8tbGVuZ3RoIHdpZGdldHMgd2l0aCBzaWRlID49IDAgYmVmb3JlIHRoaXMgcG9pbnRcbiAgICAgICAgZm9yIChsZXQgcHJldjsgaSAmJiAhKHByZXYgPSB0aGlzLmNoaWxkcmVuW2kgLSAxXSkuc2l6ZSAmJiBwcmV2IGluc3RhbmNlb2YgV2lkZ2V0Vmlld0Rlc2MgJiYgcHJldi5zaWRlID49IDA7IGktLSkgeyB9XG4gICAgICAgIC8vIFNjYW4gdG93YXJkcyB0aGUgZmlyc3QgdXNlYWJsZSBub2RlXG4gICAgICAgIGlmIChzaWRlIDw9IDApIHtcbiAgICAgICAgICAgIGxldCBwcmV2LCBlbnRlciA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKDs7IGktLSwgZW50ZXIgPSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHByZXYgPSBpID8gdGhpcy5jaGlsZHJlbltpIC0gMV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghcHJldiB8fCBwcmV2LmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldiAmJiBzaWRlICYmIGVudGVyICYmICFwcmV2LmJvcmRlciAmJiAhcHJldi5kb21BdG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2LmRvbUZyb21Qb3MocHJldi5zaXplLCBzaWRlKTtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgb2Zmc2V0OiBwcmV2ID8gZG9tSW5kZXgocHJldi5kb20pICsgMSA6IDAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXh0LCBlbnRlciA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKDs7IGkrKywgZW50ZXIgPSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG5leHQgPSBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggPyB0aGlzLmNoaWxkcmVuW2ldIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgJiYgZW50ZXIgJiYgIW5leHQuYm9yZGVyICYmICFuZXh0LmRvbUF0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQuZG9tRnJvbVBvcygwLCBzaWRlKTtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgb2Zmc2V0OiBuZXh0ID8gZG9tSW5kZXgobmV4dC5kb20pIDogdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlZCB0byBmaW5kIGEgRE9NIHJhbmdlIGluIGEgc2luZ2xlIHBhcmVudCBmb3IgYSBnaXZlbiBjaGFuZ2VkXG4gICAgLy8gcmFuZ2UuXG4gICAgcGFyc2VSYW5nZShmcm9tLCB0bywgYmFzZSA9IDApIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIGZyb20sIHRvLCBmcm9tT2Zmc2V0OiAwLCB0b09mZnNldDogdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoIH07XG4gICAgICAgIGxldCBmcm9tT2Zmc2V0ID0gLTEsIHRvT2Zmc2V0ID0gLTE7XG4gICAgICAgIGZvciAobGV0IG9mZnNldCA9IGJhc2UsIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKGZyb21PZmZzZXQgPT0gLTEgJiYgZnJvbSA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRCYXNlID0gb2Zmc2V0ICsgY2hpbGQuYm9yZGVyO1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIG1heWJlIGRlc2NlbmQgbWFyayB2aWV3cyB0byBwYXJzZSBhIG5hcnJvd2VyIHJhbmdlP1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IGNoaWxkQmFzZSAmJiB0byA8PSBlbmQgLSBjaGlsZC5ib3JkZXIgJiYgY2hpbGQubm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTS5jb250YWlucyhjaGlsZC5jb250ZW50RE9NKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnBhcnNlUmFuZ2UoZnJvbSwgdG8sIGNoaWxkQmFzZSk7XG4gICAgICAgICAgICAgICAgZnJvbSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldiA9IHRoaXMuY2hpbGRyZW5baiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldi5zaXplICYmIHByZXYuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFwcmV2LmVtcHR5Q2hpbGRBdCgxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbU9mZnNldCA9IGRvbUluZGV4KHByZXYuZG9tKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmcm9tIC09IHByZXYuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZyb21PZmZzZXQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGZyb21PZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyb21PZmZzZXQgPiAtMSAmJiAoZW5kID4gdG8gfHwgaSA9PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgdG8gPSBlbmQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuY2hpbGRyZW5bal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LnNpemUgJiYgbmV4dC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gJiYgIW5leHQuZW1wdHlDaGlsZEF0KC0xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9PZmZzZXQgPSBkb21JbmRleChuZXh0LmRvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0byArPSBuZXh0LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b09mZnNldCA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdG9PZmZzZXQgPSB0aGlzLmNvbnRlbnRET00uY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50RE9NLCBmcm9tLCB0bywgZnJvbU9mZnNldCwgdG9PZmZzZXQgfTtcbiAgICB9XG4gICAgZW1wdHlDaGlsZEF0KHNpZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuYm9yZGVyIHx8ICF0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW3NpZGUgPCAwID8gMCA6IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiBjaGlsZC5zaXplID09IDAgfHwgY2hpbGQuZW1wdHlDaGlsZEF0KHNpZGUpO1xuICAgIH1cbiAgICBkb21BZnRlclBvcyhwb3MpIHtcbiAgICAgICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSB0aGlzLmRvbUZyb21Qb3MocG9zLCAwKTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSB8fCBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gbm9kZSBhZnRlciBwb3MgXCIgKyBwb3MpO1xuICAgICAgICByZXR1cm4gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgfVxuICAgIC8vIFZpZXcgZGVzY3MgYXJlIHJlc3BvbnNpYmxlIGZvciBzZXR0aW5nIGFueSBzZWxlY3Rpb24gdGhhdCBmYWxsc1xuICAgIC8vIGVudGlyZWx5IGluc2lkZSBvZiB0aGVtLCBzbyB0aGF0IGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMgY2FuIGRvXG4gICAgLy8gY3VzdG9tIHRoaW5ncyB3aXRoIHRoZSBzZWxlY3Rpb24uIE5vdGUgdGhhdCB0aGlzIGZhbGxzIGFwYXJ0IHdoZW5cbiAgICAvLyBhIHNlbGVjdGlvbiBzdGFydHMgaW4gc3VjaCBhIG5vZGUgYW5kIGVuZHMgaW4gYW5vdGhlciwgaW4gd2hpY2hcbiAgICAvLyBjYXNlIHdlIGp1c3QgdXNlIHdoYXRldmVyIGRvbUZyb21Qb3MgcHJvZHVjZXMgYXMgYSBiZXN0IGVmZm9ydC5cbiAgICBzZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290LCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gZmFsbHMgZW50aXJlbHkgaW4gYSBjaGlsZCwgZ2l2ZSBpdCB0byB0aGF0IGNoaWxkXG4gICAgICAgIGxldCBmcm9tID0gTWF0aC5taW4oYW5jaG9yLCBoZWFkKSwgdG8gPSBNYXRoLm1heChhbmNob3IsIGhlYWQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IG9mZnNldCAmJiB0byA8IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuc2V0U2VsZWN0aW9uKGFuY2hvciAtIG9mZnNldCAtIGNoaWxkLmJvcmRlciwgaGVhZCAtIG9mZnNldCAtIGNoaWxkLmJvcmRlciwgcm9vdCwgZm9yY2UpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbmNob3JET00gPSB0aGlzLmRvbUZyb21Qb3MoYW5jaG9yLCBhbmNob3IgPyAtMSA6IDEpO1xuICAgICAgICBsZXQgaGVhZERPTSA9IGhlYWQgPT0gYW5jaG9yID8gYW5jaG9yRE9NIDogdGhpcy5kb21Gcm9tUG9zKGhlYWQsIGhlYWQgPyAtMSA6IDEpO1xuICAgICAgICBsZXQgZG9tU2VsID0gcm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgbGV0IGJyS2x1ZGdlID0gZmFsc2U7XG4gICAgICAgIC8vIE9uIEZpcmVmb3gsIHVzaW5nIFNlbGVjdGlvbi5jb2xsYXBzZSB0byBwdXQgdGhlIGN1cnNvciBhZnRlciBhXG4gICAgICAgIC8vIEJSIG5vZGUgZm9yIHNvbWUgcmVhc29uIGRvZXNuJ3QgYWx3YXlzIHdvcmsgKCMxMDczKS4gT24gU2FmYXJpLFxuICAgICAgICAvLyB0aGUgY3Vyc29yIHNvbWV0aW1lcyBpbmV4cGxpY2FibGUgdmlzdWFsbHkgbGFncyBiZWhpbmQgaXRzXG4gICAgICAgIC8vIHJlcG9ydGVkIHBvc2l0aW9uIGluIHN1Y2ggc2l0dWF0aW9ucyAoIzEwOTIpLlxuICAgICAgICBpZiAoKGdlY2tvIHx8IHNhZmFyaSkgJiYgYW5jaG9yID09IGhlYWQpIHtcbiAgICAgICAgICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gYW5jaG9yRE9NO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgIGJyS2x1ZGdlID0gISEob2Zmc2V0ICYmIG5vZGUubm9kZVZhbHVlW29mZnNldCAtIDFdID09IFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIC8vIElzc3VlICMxMTI4XG4gICAgICAgICAgICAgICAgaWYgKGJyS2x1ZGdlICYmIG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc2NhbiA9IG5vZGUsIGFmdGVyOyBzY2FuOyBzY2FuID0gc2Nhbi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIgPSBzY2FuLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFmdGVyLm5vZGVOYW1lID09IFwiQlJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yRE9NID0gaGVhZERPTSA9IHsgbm9kZTogYWZ0ZXIucGFyZW50Tm9kZSwgb2Zmc2V0OiBkb21JbmRleChhZnRlcikgKyAxIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVzYyA9IHNjYW4ucG1WaWV3RGVzYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXNjICYmIGRlc2Mubm9kZSAmJiBkZXNjLm5vZGUuaXNCbG9jaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIGJyS2x1ZGdlID0gcHJldiAmJiAocHJldi5ub2RlTmFtZSA9PSBcIkJSXCIgfHwgcHJldi5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJlZm94IGNhbiBhY3Qgc3RyYW5nZWx5IHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBpbiBmcm9udCBvZiBhblxuICAgICAgICAvLyB1bmVkaXRhYmxlIG5vZGUuIFNlZSAjMTE2MyBhbmQgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTcwOTUzNlxuICAgICAgICBpZiAoZ2Vja28gJiYgZG9tU2VsLmZvY3VzTm9kZSAmJiBkb21TZWwuZm9jdXNOb2RlICE9IGhlYWRET00ubm9kZSAmJiBkb21TZWwuZm9jdXNOb2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IGRvbVNlbC5mb2N1c05vZGUuY2hpbGROb2Rlc1tkb21TZWwuZm9jdXNPZmZzZXRdO1xuICAgICAgICAgICAgaWYgKGFmdGVyICYmIGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGZvcmNlIHx8IGJyS2x1ZGdlICYmIHNhZmFyaSkgJiZcbiAgICAgICAgICAgIGlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCkgJiZcbiAgICAgICAgICAgIGlzRXF1aXZhbGVudFBvc2l0aW9uKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQsIGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFNlbGVjdGlvbi5leHRlbmQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGFuICdpbnZlcnRlZCcgc2VsZWN0aW9uXG4gICAgICAgIC8vIChvbmUgd2hlcmUgdGhlIGZvY3VzIGlzIGJlZm9yZSB0aGUgYW5jaG9yKSwgYnV0IG5vdCBhbGxcbiAgICAgICAgLy8gYnJvd3NlcnMgc3VwcG9ydCBpdCB5ZXQuXG4gICAgICAgIGxldCBkb21TZWxFeHRlbmRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoKGRvbVNlbC5leHRlbmQgfHwgYW5jaG9yID09IGhlYWQpICYmICFicktsdWRnZSkge1xuICAgICAgICAgICAgZG9tU2VsLmNvbGxhcHNlKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvciAhPSBoZWFkKVxuICAgICAgICAgICAgICAgICAgICBkb21TZWwuZXh0ZW5kKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGRvbVNlbEV4dGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gc29tZSBjYXNlcyB3aXRoIENocm9tZSB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFmdGVyIGNhbGxpbmdcbiAgICAgICAgICAgICAgICAvLyBjb2xsYXBzZSwgZXZlbiB3aGVuIGl0IHNob3VsZCBiZSB2YWxpZC4gVGhpcyBhcHBlYXJzIHRvIGJlIGEgYnVnLCBidXRcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyBkaWZmaWN1bHQgdG8gaXNvbGF0ZS4gSWYgdGhpcyBoYXBwZW5zIGZhbGxiYWNrIHRvIHRoZSBvbGQgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHdpdGhvdXQgdXNpbmcgZXh0ZW5kLlxuICAgICAgICAgICAgICAgIC8vIFNpbWlsYXJseSwgdGhpcyBjb3VsZCBjcmFzaCBvbiBTYWZhcmkgaWYgdGhlIGVkaXRvciBpcyBoaWRkZW4sIGFuZFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIHdhcyBubyBzZWxlY3Rpb24uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkb21TZWxFeHRlbmRlZCkge1xuICAgICAgICAgICAgaWYgKGFuY2hvciA+IGhlYWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG1wID0gYW5jaG9yRE9NO1xuICAgICAgICAgICAgICAgIGFuY2hvckRPTSA9IGhlYWRET007XG4gICAgICAgICAgICAgICAgaGVhZERPTSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmQoaGVhZERPTS5ub2RlLCBoZWFkRE9NLm9mZnNldCk7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydChhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCk7XG4gICAgICAgICAgICBkb21TZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICBkb21TZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb250ZW50RE9NICYmIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIjtcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnRMb3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTSAhPSB0aGlzLmRvbSAmJiAhdGhpcy5kb20uY29udGFpbnModGhpcy5jb250ZW50RE9NKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGEgc3VidHJlZSBvZiB0aGUgZWxlbWVudCB0cmVlIHRoYXQgaGFzIGJlZW4gdG91Y2hlZFxuICAgIC8vIGJ5IGEgRE9NIGNoYW5nZSwgc28gdGhhdCB0aGUgbmV4dCB1cGRhdGUgd2lsbCByZWRyYXcgaXQuXG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIGZvciAobGV0IG9mZnNldCA9IDAsIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gZW5kID8gZnJvbSA8PSBlbmQgJiYgdG8gPj0gb2Zmc2V0IDogZnJvbSA8IGVuZCAmJiB0byA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluc2lkZSA9IG9mZnNldCArIGNoaWxkLmJvcmRlciwgZW5kSW5zaWRlID0gZW5kIC0gY2hpbGQuYm9yZGVyO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IHN0YXJ0SW5zaWRlICYmIHRvIDw9IGVuZEluc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gZnJvbSA9PSBvZmZzZXQgfHwgdG8gPT0gZW5kID8gQ09OVEVOVF9ESVJUWSA6IENISUxEX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSBzdGFydEluc2lkZSAmJiB0byA9PSBlbmRJbnNpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaGlsZC5jb250ZW50TG9zdCB8fCBjaGlsZC5kb20ucGFyZW50Tm9kZSAhPSB0aGlzLmNvbnRlbnRET00pKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGlydHkgPSBOT0RFX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5tYXJrRGlydHkoZnJvbSAtIHN0YXJ0SW5zaWRlLCB0byAtIHN0YXJ0SW5zaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGlydHkgPSBjaGlsZC5kb20gPT0gY2hpbGQuY29udGVudERPTSAmJiBjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gJiYgIWNoaWxkLmNoaWxkcmVuLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBDT05URU5UX0RJUlRZIDogTk9ERV9ESVJUWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXJ0eSA9IENPTlRFTlRfRElSVFk7XG4gICAgfVxuICAgIG1hcmtQYXJlbnRzRGlydHkoKSB7XG4gICAgICAgIGxldCBsZXZlbCA9IDE7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSB0aGlzLnBhcmVudDsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50LCBsZXZlbCsrKSB7XG4gICAgICAgICAgICBsZXQgZGlydHkgPSBsZXZlbCA9PSAxID8gQ09OVEVOVF9ESVJUWSA6IENISUxEX0RJUlRZO1xuICAgICAgICAgICAgaWYgKG5vZGUuZGlydHkgPCBkaXJ0eSlcbiAgICAgICAgICAgICAgICBub2RlLmRpcnR5ID0gZGlydHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBpZ25vcmVGb3JDb29yZHMoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuLy8gQSB3aWRnZXQgZGVzYyByZXByZXNlbnRzIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGlzIGEgRE9NIG5vZGVcbi8vIGRyYXduIGJldHdlZW4gdGhlIGRvY3VtZW50IG5vZGVzLlxuY2xhc3MgV2lkZ2V0Vmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB3aWRnZXQsIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgc2VsZiwgZG9tID0gd2lkZ2V0LnR5cGUudG9ET007XG4gICAgICAgIGlmICh0eXBlb2YgZG9tID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIGRvbSA9IGRvbSh2aWV3LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucGFyZW50LnBvc0JlZm9yZUNoaWxkKHNlbGYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICghd2lkZ2V0LnR5cGUuc3BlYy5yYXcpIHtcbiAgICAgICAgICAgIGlmIChkb20ubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICAgICAgICAgIGxldCB3cmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgICAgIGRvbSA9IHdyYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci13aWRnZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBudWxsKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICBzZWxmID0gdGhpcztcbiAgICB9XG4gICAgbWF0Y2hlc1dpZGdldCh3aWRnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIHdpZGdldC50eXBlLmVxKHRoaXMud2lkZ2V0LnR5cGUpO1xuICAgIH1cbiAgICBwYXJzZVJ1bGUoKSB7IHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9OyB9XG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGxldCBzdG9wID0gdGhpcy53aWRnZXQuc3BlYy5zdG9wRXZlbnQ7XG4gICAgICAgIHJldHVybiBzdG9wID8gc3RvcChldmVudCkgOiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIiB8fCB0aGlzLndpZGdldC5zcGVjLmlnbm9yZVNlbGVjdGlvbjtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy53aWRnZXQudHlwZS5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBnZXQgZG9tQXRvbSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgc2lkZSgpIHsgcmV0dXJuIHRoaXMud2lkZ2V0LnR5cGUuc2lkZTsgfVxufVxuY2xhc3MgQ29tcG9zaXRpb25WaWV3RGVzYyBleHRlbmRzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGRvbSwgdGV4dERPTSwgdGV4dCkge1xuICAgICAgICBzdXBlcihwYXJlbnQsIFtdLCBkb20sIG51bGwpO1xuICAgICAgICB0aGlzLnRleHRET00gPSB0ZXh0RE9NO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBsb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKGRvbSAhPSB0aGlzLnRleHRET00pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgKG9mZnNldCA/IHRoaXMuc2l6ZSA6IDApO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgb2Zmc2V0O1xuICAgIH1cbiAgICBkb21Gcm9tUG9zKHBvcykge1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLnRleHRET00sIG9mZnNldDogcG9zIH07XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dCkge1xuICAgICAgICByZXR1cm4gbXV0LnR5cGUgPT09ICdjaGFyYWN0ZXJEYXRhJyAmJiBtdXQudGFyZ2V0Lm5vZGVWYWx1ZSA9PSBtdXQub2xkVmFsdWU7XG4gICAgfVxufVxuLy8gQSBtYXJrIGRlc2MgcmVwcmVzZW50cyBhIG1hcmsuIE1heSBoYXZlIG11bHRpcGxlIGNoaWxkcmVuLFxuLy8gZGVwZW5kaW5nIG9uIGhvdyB0aGUgbWFyayBpcyBzcGxpdC4gTm90ZSB0aGF0IG1hcmtzIGFyZSBkcmF3biB1c2luZ1xuLy8gYSBmaXhlZCBuZXN0aW5nIG9yZGVyLCBmb3Igc2ltcGxpY2l0eSBhbmQgcHJlZGljdGFiaWxpdHksIHNvIGluXG4vLyBzb21lIGNhc2VzIHRoZXkgd2lsbCBiZSBzcGxpdCBtb3JlIG9mdGVuIHRoYW4gd291bGQgYXBwZWFyXG4vLyBuZWNlc3NhcnkuXG5jbGFzcyBNYXJrVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBtYXJrLCBkb20sIGNvbnRlbnRET00pIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBjb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShwYXJlbnQsIG1hcmssIGlubGluZSwgdmlldykge1xuICAgICAgICBsZXQgY3VzdG9tID0gdmlldy5ub2RlVmlld3NbbWFyay50eXBlLm5hbWVdO1xuICAgICAgICBsZXQgc3BlYyA9IGN1c3RvbSAmJiBjdXN0b20obWFyaywgdmlldywgaW5saW5lKTtcbiAgICAgICAgaWYgKCFzcGVjIHx8ICFzcGVjLmRvbSlcbiAgICAgICAgICAgIHNwZWMgPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jdW1lbnQsIG1hcmsudHlwZS5zcGVjLnRvRE9NKG1hcmssIGlubGluZSkpO1xuICAgICAgICByZXR1cm4gbmV3IE1hcmtWaWV3RGVzYyhwYXJlbnQsIG1hcmssIHNwZWMuZG9tLCBzcGVjLmNvbnRlbnRET00gfHwgc3BlYy5kb20pO1xuICAgIH1cbiAgICBwYXJzZVJ1bGUoKSB7XG4gICAgICAgIGlmICgodGhpcy5kaXJ0eSAmIE5PREVfRElSVFkpIHx8IHRoaXMubWFyay50eXBlLnNwZWMucmVwYXJzZUluVmlldylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4geyBtYXJrOiB0aGlzLm1hcmsudHlwZS5uYW1lLCBhdHRyczogdGhpcy5tYXJrLmF0dHJzLCBjb250ZW50RWxlbWVudDogdGhpcy5jb250ZW50RE9NIH07XG4gICAgfVxuICAgIG1hdGNoZXNNYXJrKG1hcmspIHsgcmV0dXJuIHRoaXMuZGlydHkgIT0gTk9ERV9ESVJUWSAmJiB0aGlzLm1hcmsuZXEobWFyayk7IH1cbiAgICBtYXJrRGlydHkoZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIubWFya0RpcnR5KGZyb20sIHRvKTtcbiAgICAgICAgLy8gTW92ZSBkaXJ0eSBpbmZvIHRvIG5lYXJlc3Qgbm9kZSB2aWV3XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKCFwYXJlbnQubm9kZSlcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgaWYgKHBhcmVudC5kaXJ0eSA8IHRoaXMuZGlydHkpXG4gICAgICAgICAgICAgICAgcGFyZW50LmRpcnR5ID0gdGhpcy5kaXJ0eTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2xpY2UoZnJvbSwgdG8sIHZpZXcpIHtcbiAgICAgICAgbGV0IGNvcHkgPSBNYXJrVmlld0Rlc2MuY3JlYXRlKHRoaXMucGFyZW50LCB0aGlzLm1hcmssIHRydWUsIHZpZXcpO1xuICAgICAgICBsZXQgbm9kZXMgPSB0aGlzLmNoaWxkcmVuLCBzaXplID0gdGhpcy5zaXplO1xuICAgICAgICBpZiAodG8gPCBzaXplKVxuICAgICAgICAgICAgbm9kZXMgPSByZXBsYWNlTm9kZXMobm9kZXMsIHRvLCBzaXplLCB2aWV3KTtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgbm9kZXMgPSByZXBsYWNlTm9kZXMobm9kZXMsIDAsIGZyb20sIHZpZXcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgbm9kZXNbaV0ucGFyZW50ID0gY29weTtcbiAgICAgICAgY29weS5jaGlsZHJlbiA9IG5vZGVzO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG59XG4vLyBOb2RlIHZpZXcgZGVzY3MgYXJlIHRoZSBtYWluLCBtb3N0IGNvbW1vbiB0eXBlIG9mIHZpZXcgZGVzYywgYW5kXG4vLyBjb3JyZXNwb25kIHRvIGFuIGFjdHVhbCBub2RlIGluIHRoZSBkb2N1bWVudC4gVW5saWtlIG1hcmsgZGVzY3MsXG4vLyB0aGV5IHBvcHVsYXRlIHRoZWlyIGNoaWxkIGFycmF5IHRoZW1zZWx2ZXMuXG5jbGFzcyBOb2RlVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBjb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5vdXRlckRlY28gPSBvdXRlckRlY287XG4gICAgICAgIHRoaXMuaW5uZXJEZWNvID0gaW5uZXJEZWNvO1xuICAgICAgICB0aGlzLm5vZGVET00gPSBub2RlRE9NO1xuICAgIH1cbiAgICAvLyBCeSBkZWZhdWx0LCBhIG5vZGUgaXMgcmVuZGVyZWQgdXNpbmcgdGhlIGB0b0RPTWAgbWV0aG9kIGZyb20gdGhlXG4gICAgLy8gbm9kZSB0eXBlIHNwZWMuIEJ1dCBjbGllbnQgY29kZSBjYW4gdXNlIHRoZSBgbm9kZVZpZXdzYCBzcGVjIHRvXG4gICAgLy8gc3VwcGx5IGEgY3VzdG9tIG5vZGUgdmlldywgd2hpY2ggY2FuIGluZmx1ZW5jZSB2YXJpb3VzIGFzcGVjdHMgb2ZcbiAgICAvLyB0aGUgd2F5IHRoZSBub2RlIHdvcmtzLlxuICAgIC8vXG4gICAgLy8gKFVzaW5nIHN1YmNsYXNzaW5nIGZvciB0aGlzIHdhcyBpbnRlbnRpb25hbGx5IGRlY2lkZWQgYWdhaW5zdCxcbiAgICAvLyBzaW5jZSBpdCdkIHJlcXVpcmUgZXhwb3NpbmcgYSB3aG9sZSBzbGV3IG9mIGZpbmlja3lcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIHRvIHRoZSB1c2VyIGNvZGUgdGhhdCB0aGV5IHByb2JhYmx5IHdpbGxcbiAgICAvLyBuZXZlciBuZWVkLilcbiAgICBzdGF0aWMgY3JlYXRlKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgY3VzdG9tID0gdmlldy5ub2RlVmlld3Nbbm9kZS50eXBlLm5hbWVdLCBkZXNjT2JqO1xuICAgICAgICBsZXQgc3BlYyA9IGN1c3RvbSAmJiBjdXN0b20obm9kZSwgdmlldywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gKFRoaXMgaXMgYSBmdW5jdGlvbiB0aGF0IGFsbG93cyB0aGUgY3VzdG9tIHZpZXcgdG8gZmluZCBpdHNcbiAgICAgICAgICAgIC8vIG93biBwb3NpdGlvbilcbiAgICAgICAgICAgIGlmICghZGVzY09iailcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgaWYgKGRlc2NPYmoucGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjT2JqLnBhcmVudC5wb3NCZWZvcmVDaGlsZChkZXNjT2JqKTtcbiAgICAgICAgfSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pO1xuICAgICAgICBsZXQgZG9tID0gc3BlYyAmJiBzcGVjLmRvbSwgY29udGVudERPTSA9IHNwZWMgJiYgc3BlYy5jb250ZW50RE9NO1xuICAgICAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgICAgIGlmICghZG9tKVxuICAgICAgICAgICAgICAgIGRvbSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUudGV4dCk7XG4gICAgICAgICAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgIT0gMylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRleHQgbXVzdCBiZSByZW5kZXJlZCBhcyBhIERPTSB0ZXh0IG5vZGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWRvbSkge1xuICAgICAgICAgICAgKHsgZG9tLCBjb250ZW50RE9NIH0gPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jdW1lbnQsIG5vZGUudHlwZS5zcGVjLnRvRE9NKG5vZGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250ZW50RE9NICYmICFub2RlLmlzVGV4dCAmJiBkb20ubm9kZU5hbWUgIT0gXCJCUlwiKSB7IC8vIENocm9tZSBnZXRzIGNvbmZ1c2VkIGJ5IDxiciBjb250ZW50ZWRpdGFibGU9ZmFsc2U+XG4gICAgICAgICAgICBpZiAoIWRvbS5oYXNBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikpXG4gICAgICAgICAgICAgICAgZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUpXG4gICAgICAgICAgICAgICAgZG9tLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGVET00gPSBkb207XG4gICAgICAgIGRvbSA9IGFwcGx5T3V0ZXJEZWNvKGRvbSwgb3V0ZXJEZWNvLCBub2RlKTtcbiAgICAgICAgaWYgKHNwZWMpXG4gICAgICAgICAgICByZXR1cm4gZGVzY09iaiA9IG5ldyBDdXN0b21Ob2RlVmlld0Rlc2MocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NIHx8IG51bGwsIG5vZGVET00sIHNwZWMsIHZpZXcsIHBvcyArIDEpO1xuICAgICAgICBlbHNlIGlmIChub2RlLmlzVGV4dClcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dFZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbm9kZURPTSwgdmlldyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZVZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSB8fCBudWxsLCBub2RlRE9NLCB2aWV3LCBwb3MgKyAxKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkge1xuICAgICAgICAvLyBFeHBlcmltZW50YWwga2x1ZGdlIHRvIGFsbG93IG9wdC1pbiByZS1wYXJzaW5nIG9mIG5vZGVzXG4gICAgICAgIGlmICh0aGlzLm5vZGUudHlwZS5zcGVjLnJlcGFyc2VJblZpZXcpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gRklYTUUgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGNhbiBhbHdheXMgcmV0dXJuIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIGF0dHJzIG1lYW5zIHRoYXQgaWYgdGhlIHVzZXIgc29tZWhvdyBtYW5hZ2VzIHRvIGNoYW5nZSB0aGVcbiAgICAgICAgLy8gYXR0cnMgaW4gdGhlIGRvbSwgdGhhdCB3b24ndCBiZSBwaWNrZWQgdXAuIE5vdCBlbnRpcmVseSBzdXJlXG4gICAgICAgIC8vIHdoZXRoZXIgdGhpcyBpcyBhIHByb2JsZW1cbiAgICAgICAgbGV0IHJ1bGUgPSB7IG5vZGU6IHRoaXMubm9kZS50eXBlLm5hbWUsIGF0dHJzOiB0aGlzLm5vZGUuYXR0cnMgfTtcbiAgICAgICAgaWYgKHRoaXMubm9kZS50eXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIilcbiAgICAgICAgICAgIHJ1bGUucHJlc2VydmVXaGl0ZXNwYWNlID0gXCJmdWxsXCI7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICBydWxlLmdldENvbnRlbnQgPSAoKSA9PiB0aGlzLm5vZGUuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5jb250ZW50TG9zdCkge1xuICAgICAgICAgICAgcnVsZS5jb250ZW50RWxlbWVudCA9IHRoaXMuY29udGVudERPTTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENocm9tZSBsaWtlcyB0byByYW5kb21seSByZWNyZWF0ZSBwYXJlbnQgbm9kZXMgd2hlblxuICAgICAgICAgICAgLy8gYmFja3NwYWNpbmcgdGhpbmdzLiBXaGVuIHRoYXQgaGFwcGVucywgdGhpcyB0cmllcyB0byBmaW5kIHRoZVxuICAgICAgICAgICAgLy8gbmV3IHBhcmVudC5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb20uY29udGFpbnMoY2hpbGQuZG9tLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuY29udGVudEVsZW1lbnQgPSBjaGlsZC5kb20ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFydWxlLmNvbnRlbnRFbGVtZW50KVxuICAgICAgICAgICAgICAgIHJ1bGUuZ2V0Q29udGVudCA9ICgpID0+IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydWxlO1xuICAgIH1cbiAgICBtYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJ0eSA9PSBOT1RfRElSVFkgJiYgbm9kZS5lcSh0aGlzLm5vZGUpICYmXG4gICAgICAgICAgICBzYW1lT3V0ZXJEZWNvKG91dGVyRGVjbywgdGhpcy5vdXRlckRlY28pICYmIGlubmVyRGVjby5lcSh0aGlzLmlubmVyRGVjbyk7XG4gICAgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5ub2RlLm5vZGVTaXplOyB9XG4gICAgZ2V0IGJvcmRlcigpIHsgcmV0dXJuIHRoaXMubm9kZS5pc0xlYWYgPyAwIDogMTsgfVxuICAgIC8vIFN5bmNzIGB0aGlzLmNoaWxkcmVuYCB0byBtYXRjaCBgdGhpcy5ub2RlLmNvbnRlbnRgIGFuZCB0aGUgbG9jYWxcbiAgICAvLyBkZWNvcmF0aW9ucywgcG9zc2libHkgaW50cm9kdWNpbmcgbmVzdGluZyBmb3IgbWFya3MuIFRoZW4sIGluIGFcbiAgICAvLyBzZXBhcmF0ZSBzdGVwLCBzeW5jcyB0aGUgRE9NIGluc2lkZSBgdGhpcy5jb250ZW50RE9NYCB0b1xuICAgIC8vIGB0aGlzLmNoaWxkcmVuYC5cbiAgICB1cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IGlubGluZSA9IHRoaXMubm9kZS5pbmxpbmVDb250ZW50LCBvZmYgPSBwb3M7XG4gICAgICAgIGxldCBjb21wb3NpdGlvbiA9IHZpZXcuY29tcG9zaW5nID8gdGhpcy5sb2NhbENvbXBvc2l0aW9uSW5mbyh2aWV3LCBwb3MpIDogbnVsbDtcbiAgICAgICAgbGV0IGxvY2FsQ29tcG9zaXRpb24gPSBjb21wb3NpdGlvbiAmJiBjb21wb3NpdGlvbi5wb3MgPiAtMSA/IGNvbXBvc2l0aW9uIDogbnVsbDtcbiAgICAgICAgbGV0IGNvbXBvc2l0aW9uSW5DaGlsZCA9IGNvbXBvc2l0aW9uICYmIGNvbXBvc2l0aW9uLnBvcyA8IDA7XG4gICAgICAgIGxldCB1cGRhdGVyID0gbmV3IFZpZXdUcmVlVXBkYXRlcih0aGlzLCBsb2NhbENvbXBvc2l0aW9uICYmIGxvY2FsQ29tcG9zaXRpb24ubm9kZSwgdmlldyk7XG4gICAgICAgIGl0ZXJEZWNvKHRoaXMubm9kZSwgdGhpcy5pbm5lckRlY28sICh3aWRnZXQsIGksIGluc2lkZU5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmICh3aWRnZXQuc3BlYy5tYXJrcylcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKHdpZGdldC5zcGVjLm1hcmtzLCBpbmxpbmUsIHZpZXcpO1xuICAgICAgICAgICAgZWxzZSBpZiAod2lkZ2V0LnR5cGUuc2lkZSA+PSAwICYmICFpbnNpZGVOb2RlKVxuICAgICAgICAgICAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3MoaSA9PSB0aGlzLm5vZGUuY2hpbGRDb3VudCA/IE1hcmsubm9uZSA6IHRoaXMubm9kZS5jaGlsZChpKS5tYXJrcywgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBuZXh0IG5vZGUgaXMgYSBkZXNjIG1hdGNoaW5nIHRoaXMgd2lkZ2V0LCByZXVzZSBpdCxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBpbnNlcnQgdGhlIHdpZGdldCBhcyBhIG5ldyB2aWV3IGRlc2MuXG4gICAgICAgICAgICB1cGRhdGVyLnBsYWNlV2lkZ2V0KHdpZGdldCwgdmlldywgb2ZmKTtcbiAgICAgICAgfSwgKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgaSkgPT4ge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB3cmFwcGluZyBtYXJrIGRlc2NzIG1hdGNoIHRoZSBub2RlJ3MgbWFya3MuXG4gICAgICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKGNoaWxkLm1hcmtzLCBpbmxpbmUsIHZpZXcpO1xuICAgICAgICAgICAgLy8gVHJ5IHNldmVyYWwgc3RyYXRlZ2llcyBmb3IgZHJhd2luZyB0aGlzIG5vZGVcbiAgICAgICAgICAgIGxldCBjb21wSW5kZXg7XG4gICAgICAgICAgICBpZiAodXBkYXRlci5maW5kTm9kZU1hdGNoKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgaSkpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBvc2l0aW9uSW5DaGlsZCAmJiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tID4gb2ZmICYmXG4gICAgICAgICAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gPCBvZmYgKyBjaGlsZC5ub2RlU2l6ZSAmJlxuICAgICAgICAgICAgICAgIChjb21wSW5kZXggPSB1cGRhdGVyLmZpbmRJbmRleFdpdGhDaGlsZChjb21wb3NpdGlvbi5ub2RlKSkgPiAtMSAmJlxuICAgICAgICAgICAgICAgIHVwZGF0ZXIudXBkYXRlTm9kZUF0KGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgY29tcEluZGV4LCB2aWV3KSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAodXBkYXRlci51cGRhdGVOZXh0Tm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIGksIG9mZikpIDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBpdCBhcyBhIG5ldyB2aWV3XG4gICAgICAgICAgICAgICAgdXBkYXRlci5hZGROb2RlKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgb2ZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERyb3AgYWxsIHJlbWFpbmluZyBkZXNjcyBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyhbXSwgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHVwZGF0ZXIuYWRkVGV4dGJsb2NrSGFja3MoKTtcbiAgICAgICAgdXBkYXRlci5kZXN0cm95UmVzdCgpO1xuICAgICAgICAvLyBTeW5jIHRoZSBET00gaWYgYW55dGhpbmcgY2hhbmdlZFxuICAgICAgICBpZiAodXBkYXRlci5jaGFuZ2VkIHx8IHRoaXMuZGlydHkgPT0gQ09OVEVOVF9ESVJUWSkge1xuICAgICAgICAgICAgLy8gTWF5IGhhdmUgdG8gcHJvdGVjdCBmb2N1c2VkIERPTSBmcm9tIGJlaW5nIGNoYW5nZWQgaWYgYSBjb21wb3NpdGlvbiBpcyBhY3RpdmVcbiAgICAgICAgICAgIGlmIChsb2NhbENvbXBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvdGVjdExvY2FsQ29tcG9zaXRpb24odmlldywgbG9jYWxDb21wb3NpdGlvbik7XG4gICAgICAgICAgICByZW5kZXJEZXNjcyh0aGlzLmNvbnRlbnRET00sIHRoaXMuY2hpbGRyZW4sIHZpZXcpO1xuICAgICAgICAgICAgaWYgKGlvcylcbiAgICAgICAgICAgICAgICBpb3NIYWNrcyh0aGlzLmRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9jYWxDb21wb3NpdGlvbkluZm8odmlldywgcG9zKSB7XG4gICAgICAgIC8vIE9ubHkgZG8gc29tZXRoaW5nIGlmIGJvdGggdGhlIHNlbGVjdGlvbiBhbmQgYSBmb2N1c2VkIHRleHQgbm9kZVxuICAgICAgICAvLyBhcmUgaW5zaWRlIG9mIHRoaXMgbm9kZVxuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmICghKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikgfHwgZnJvbSA8IHBvcyB8fCB0byA+IHBvcyArIHRoaXMubm9kZS5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IHRleHROb2RlID0gbmVhcmJ5VGV4dE5vZGUoc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICAgICAgaWYgKCF0ZXh0Tm9kZSB8fCAhdGhpcy5kb20uY29udGFpbnModGV4dE5vZGUucGFyZW50Tm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSB0ZXh0IGluIHRoZSBmb2N1c2VkIG5vZGUgaW4gdGhlIG5vZGUsIHN0b3AgaWYgaXQncyBub3RcbiAgICAgICAgICAgIC8vIHRoZXJlIChtYXkgaGF2ZSBiZWVuIG1vZGlmaWVkIHRocm91Z2ggb3RoZXIgbWVhbnMsIGluIHdoaWNoXG4gICAgICAgICAgICAvLyBjYXNlIGl0IHNob3VsZCBvdmVyd3JpdHRlbilcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gdGV4dE5vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgbGV0IHRleHRQb3MgPSBmaW5kVGV4dEluRnJhZ21lbnQodGhpcy5ub2RlLmNvbnRlbnQsIHRleHQsIGZyb20gLSBwb3MsIHRvIC0gcG9zKTtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0UG9zIDwgMCA/IG51bGwgOiB7IG5vZGU6IHRleHROb2RlLCBwb3M6IHRleHRQb3MsIHRleHQgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRleHROb2RlLCBwb3M6IC0xLCB0ZXh0OiBcIlwiIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvdGVjdExvY2FsQ29tcG9zaXRpb24odmlldywgeyBub2RlLCBwb3MsIHRleHQgfSkge1xuICAgICAgICAvLyBUaGUgbm9kZSBpcyBhbHJlYWR5IHBhcnQgb2YgYSBsb2NhbCB2aWV3IGRlc2MsIGxlYXZlIGl0IHRoZXJlXG4gICAgICAgIGlmICh0aGlzLmdldERlc2Mobm9kZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIENyZWF0ZSBhIGNvbXBvc2l0aW9uIHZpZXcgZm9yIHRoZSBvcnBoYW5lZCBub2Rlc1xuICAgICAgICBsZXQgdG9wTm9kZSA9IG5vZGU7XG4gICAgICAgIGZvciAoOzsgdG9wTm9kZSA9IHRvcE5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgaWYgKHRvcE5vZGUucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB3aGlsZSAodG9wTm9kZS5wcmV2aW91c1NpYmxpbmcpXG4gICAgICAgICAgICAgICAgdG9wTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRvcE5vZGUucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgICAgIHdoaWxlICh0b3BOb2RlLm5leHRTaWJsaW5nKVxuICAgICAgICAgICAgICAgIHRvcE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0b3BOb2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIGlmICh0b3BOb2RlLnBtVmlld0Rlc2MpXG4gICAgICAgICAgICAgICAgdG9wTm9kZS5wbVZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZXNjID0gbmV3IENvbXBvc2l0aW9uVmlld0Rlc2ModGhpcywgdG9wTm9kZSwgbm9kZSwgdGV4dCk7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2Rlcy5wdXNoKGRlc2MpO1xuICAgICAgICAvLyBQYXRjaCB1cCB0aGlzLmNoaWxkcmVuIHRvIGNvbnRhaW4gdGhlIGNvbXBvc2l0aW9uIHZpZXdcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IHJlcGxhY2VOb2Rlcyh0aGlzLmNoaWxkcmVuLCBwb3MsIHBvcyArIHRleHQubGVuZ3RoLCB2aWV3LCBkZXNjKTtcbiAgICB9XG4gICAgLy8gSWYgdGhpcyBkZXNjIG11c3QgYmUgdXBkYXRlZCB0byBtYXRjaCB0aGUgZ2l2ZW4gbm9kZSBkZWNvcmF0aW9uLFxuICAgIC8vIGRvIHNvIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICB1cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgPT0gTk9ERV9ESVJUWSB8fFxuICAgICAgICAgICAgIW5vZGUuc2FtZU1hcmt1cCh0aGlzLm5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHVwZGF0ZUlubmVyKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICAgIHRoaXMudXBkYXRlT3V0ZXJEZWNvKG91dGVyRGVjbyk7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuaW5uZXJEZWNvID0gaW5uZXJEZWNvO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbih2aWV3LCB0aGlzLnBvc0F0U3RhcnQpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgIH1cbiAgICB1cGRhdGVPdXRlckRlY28ob3V0ZXJEZWNvKSB7XG4gICAgICAgIGlmIChzYW1lT3V0ZXJEZWNvKG91dGVyRGVjbywgdGhpcy5vdXRlckRlY28pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbmVlZHNXcmFwID0gdGhpcy5ub2RlRE9NLm5vZGVUeXBlICE9IDE7XG4gICAgICAgIGxldCBvbGRET00gPSB0aGlzLmRvbTtcbiAgICAgICAgdGhpcy5kb20gPSBwYXRjaE91dGVyRGVjbyh0aGlzLmRvbSwgdGhpcy5ub2RlRE9NLCBjb21wdXRlT3V0ZXJEZWNvKHRoaXMub3V0ZXJEZWNvLCB0aGlzLm5vZGUsIG5lZWRzV3JhcCksIGNvbXB1dGVPdXRlckRlY28ob3V0ZXJEZWNvLCB0aGlzLm5vZGUsIG5lZWRzV3JhcCkpO1xuICAgICAgICBpZiAodGhpcy5kb20gIT0gb2xkRE9NKSB7XG4gICAgICAgICAgICBvbGRET00ucG1WaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuZG9tLnBtVmlld0Rlc2MgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0ZXJEZWNvID0gb3V0ZXJEZWNvO1xuICAgIH1cbiAgICAvLyBNYXJrIHRoaXMgbm9kZSBhcyBiZWluZyB0aGUgc2VsZWN0ZWQgbm9kZS5cbiAgICBzZWxlY3ROb2RlKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlRE9NLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICB0aGlzLm5vZGVET00uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLXNlbGVjdGVkbm9kZVwiKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSB8fCAhdGhpcy5ub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUpXG4gICAgICAgICAgICB0aGlzLmRvbS5kcmFnZ2FibGUgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgc2VsZWN0ZWQgbm9kZSBtYXJraW5nIGZyb20gdGhpcyBub2RlLlxuICAgIGRlc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZURPTS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgdGhpcy5ub2RlRE9NLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVcIik7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlQXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIpO1xuICAgIH1cbiAgICBnZXQgZG9tQXRvbSgpIHsgcmV0dXJuIHRoaXMubm9kZS5pc0F0b207IH1cbn1cbi8vIENyZWF0ZSBhIHZpZXcgZGVzYyBmb3IgdGhlIHRvcC1sZXZlbCBkb2N1bWVudCBub2RlLCB0byBiZSBleHBvcnRlZFxuLy8gYW5kIHVzZWQgYnkgdGhlIHZpZXcgY2xhc3MuXG5mdW5jdGlvbiBkb2NWaWV3RGVzYyhkb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIHZpZXcpIHtcbiAgICBhcHBseU91dGVyRGVjbyhkb20sIG91dGVyRGVjbywgZG9jKTtcbiAgICBsZXQgZG9jVmlldyA9IG5ldyBOb2RlVmlld0Rlc2ModW5kZWZpbmVkLCBkb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGRvbSwgZG9tLCB2aWV3LCAwKTtcbiAgICBpZiAoZG9jVmlldy5jb250ZW50RE9NKVxuICAgICAgICBkb2NWaWV3LnVwZGF0ZUNoaWxkcmVuKHZpZXcsIDApO1xuICAgIHJldHVybiBkb2NWaWV3O1xufVxuY2xhc3MgVGV4dFZpZXdEZXNjIGV4dGVuZHMgTm9kZVZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIG5vZGVET00sIHZpZXcpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBudWxsLCBub2RlRE9NLCB2aWV3LCAwKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkge1xuICAgICAgICBsZXQgc2tpcCA9IHRoaXMubm9kZURPTS5wYXJlbnROb2RlO1xuICAgICAgICB3aGlsZSAoc2tpcCAmJiBza2lwICE9IHRoaXMuZG9tICYmICFza2lwLnBtSXNEZWNvKVxuICAgICAgICAgICAgc2tpcCA9IHNraXAucGFyZW50Tm9kZTtcbiAgICAgICAgcmV0dXJuIHsgc2tpcDogKHNraXAgfHwgdHJ1ZSkgfTtcbiAgICB9XG4gICAgdXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IE5PREVfRElSVFkgfHwgKHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZICYmICF0aGlzLmluUGFyZW50KCkpIHx8XG4gICAgICAgICAgICAhbm9kZS5zYW1lTWFya3VwKHRoaXMubm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlT3V0ZXJEZWNvKG91dGVyRGVjbyk7XG4gICAgICAgIGlmICgodGhpcy5kaXJ0eSAhPSBOT1RfRElSVFkgfHwgbm9kZS50ZXh0ICE9IHRoaXMubm9kZS50ZXh0KSAmJiBub2RlLnRleHQgIT0gdGhpcy5ub2RlRE9NLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlRE9NLm5vZGVWYWx1ZSA9IG5vZGUudGV4dDtcbiAgICAgICAgICAgIGlmICh2aWV3LnRyYWNrV3JpdGVzID09IHRoaXMubm9kZURPTSlcbiAgICAgICAgICAgICAgICB2aWV3LnRyYWNrV3JpdGVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5QYXJlbnQoKSB7XG4gICAgICAgIGxldCBwYXJlbnRET00gPSB0aGlzLnBhcmVudC5jb250ZW50RE9NO1xuICAgICAgICBmb3IgKGxldCBuID0gdGhpcy5ub2RlRE9NOyBuOyBuID0gbi5wYXJlbnROb2RlKVxuICAgICAgICAgICAgaWYgKG4gPT0gcGFyZW50RE9NKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRvbUZyb21Qb3MocG9zKSB7XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMubm9kZURPTSwgb2Zmc2V0OiBwb3MgfTtcbiAgICB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIGlmIChkb20gPT0gdGhpcy5ub2RlRE9NKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIE1hdGgubWluKG9mZnNldCwgdGhpcy5ub2RlLnRleHQubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcyk7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbi50eXBlICE9IFwiY2hhcmFjdGVyRGF0YVwiICYmIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIjtcbiAgICB9XG4gICAgc2xpY2UoZnJvbSwgdG8sIHZpZXcpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLm5vZGUuY3V0KGZyb20sIHRvKSwgZG9tID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZS50ZXh0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Vmlld0Rlc2ModGhpcy5wYXJlbnQsIG5vZGUsIHRoaXMub3V0ZXJEZWNvLCB0aGlzLmlubmVyRGVjbywgZG9tLCBkb20sIHZpZXcpO1xuICAgIH1cbiAgICBtYXJrRGlydHkoZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIubWFya0RpcnR5KGZyb20sIHRvKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tICE9IHRoaXMubm9kZURPTSAmJiAoZnJvbSA9PSAwIHx8IHRvID09IHRoaXMubm9kZURPTS5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBOT0RFX0RJUlRZO1xuICAgIH1cbiAgICBnZXQgZG9tQXRvbSgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG4vLyBBIGR1bW15IGRlc2MgdXNlZCB0byB0YWcgdHJhaWxpbmcgQlIgb3IgSU1HIG5vZGVzIGNyZWF0ZWQgdG8gd29ya1xuLy8gYXJvdW5kIGNvbnRlbnRFZGl0YWJsZSB0ZXJyaWJsZW5lc3MuXG5jbGFzcyBUcmFpbGluZ0hhY2tWaWV3RGVzYyBleHRlbmRzIFZpZXdEZXNjIHtcbiAgICBwYXJzZVJ1bGUoKSB7IHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9OyB9XG4gICAgbWF0Y2hlc0hhY2sobm9kZU5hbWUpIHsgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIHRoaXMuZG9tLm5vZGVOYW1lID09IG5vZGVOYW1lOyB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGlnbm9yZUZvckNvb3JkcygpIHsgcmV0dXJuIHRoaXMuZG9tLm5vZGVOYW1lID09IFwiSU1HXCI7IH1cbn1cbi8vIEEgc2VwYXJhdGUgc3ViY2xhc3MgaXMgdXNlZCBmb3IgY3VzdG9taXplZCBub2RlIHZpZXdzLCBzbyB0aGF0IHRoZVxuLy8gZXh0cmEgY2hlY2tzIG9ubHkgaGF2ZSB0byBiZSBtYWRlIGZvciBub2RlcyB0aGF0IGFyZSBhY3R1YWxseVxuLy8gY3VzdG9taXplZC5cbmNsYXNzIEN1c3RvbU5vZGVWaWV3RGVzYyBleHRlbmRzIE5vZGVWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCBzcGVjLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCB2aWV3LCBwb3MpO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIH1cbiAgICAvLyBBIGN1c3RvbSBgdXBkYXRlYCBtZXRob2QgZ2V0cyB0byBkZWNpZGUgd2hldGhlciB0aGUgdXBkYXRlIGdvZXNcbiAgICAvLyB0aHJvdWdoLiBJZiBpdCBkb2VzLCBhbmQgdGhlcmUncyBhIGBjb250ZW50RE9NYCBub2RlLCBvdXIgbG9naWNcbiAgICAvLyB1cGRhdGVzIHRoZSBjaGlsZHJlbi5cbiAgICB1cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgPT0gTk9ERV9ESVJUWSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy51cGRhdGUpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnNwZWMudXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbm5lcihub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmNvbnRlbnRET00gJiYgIW5vZGUuaXNMZWFmKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIudXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3ROb2RlKCkge1xuICAgICAgICB0aGlzLnNwZWMuc2VsZWN0Tm9kZSA/IHRoaXMuc3BlYy5zZWxlY3ROb2RlKCkgOiBzdXBlci5zZWxlY3ROb2RlKCk7XG4gICAgfVxuICAgIGRlc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgdGhpcy5zcGVjLmRlc2VsZWN0Tm9kZSA/IHRoaXMuc3BlYy5kZXNlbGVjdE5vZGUoKSA6IHN1cGVyLmRlc2VsZWN0Tm9kZSgpO1xuICAgIH1cbiAgICBzZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290LCBmb3JjZSkge1xuICAgICAgICB0aGlzLnNwZWMuc2V0U2VsZWN0aW9uID8gdGhpcy5zcGVjLnNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHJvb3QpXG4gICAgICAgICAgICA6IHN1cGVyLnNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHJvb3QsIGZvcmNlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy5kZXN0cm95KVxuICAgICAgICAgICAgdGhpcy5zcGVjLmRlc3Ryb3koKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy5zdG9wRXZlbnQgPyB0aGlzLnNwZWMuc3RvcEV2ZW50KGV2ZW50KSA6IGZhbHNlO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjLmlnbm9yZU11dGF0aW9uID8gdGhpcy5zcGVjLmlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSA6IHN1cGVyLmlnbm9yZU11dGF0aW9uKG11dGF0aW9uKTtcbiAgICB9XG59XG4vLyBTeW5jIHRoZSBjb250ZW50IG9mIHRoZSBnaXZlbiBET00gbm9kZSB3aXRoIHRoZSBub2RlcyBhc3NvY2lhdGVkXG4vLyB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZiB2aWV3IGRlc2NzLCByZWN1cnNpbmcgaW50byBtYXJrIGRlc2NzXG4vLyBiZWNhdXNlIHRoaXMgc2hvdWxkIHN5bmMgdGhlIHN1YnRyZWUgZm9yIGEgd2hvbGUgbm9kZSBhdCBhIHRpbWUuXG5mdW5jdGlvbiByZW5kZXJEZXNjcyhwYXJlbnRET00sIGRlc2NzLCB2aWV3KSB7XG4gICAgbGV0IGRvbSA9IHBhcmVudERPTS5maXJzdENoaWxkLCB3cml0dGVuID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXNjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZGVzYyA9IGRlc2NzW2ldLCBjaGlsZERPTSA9IGRlc2MuZG9tO1xuICAgICAgICBpZiAoY2hpbGRET00ucGFyZW50Tm9kZSA9PSBwYXJlbnRET00pIHtcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZERPTSAhPSBkb20pIHtcbiAgICAgICAgICAgICAgICBkb20gPSBybShkb20pO1xuICAgICAgICAgICAgICAgIHdyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tID0gZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICBwYXJlbnRET00uaW5zZXJ0QmVmb3JlKGNoaWxkRE9NLCBkb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXNjIGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gZG9tID8gZG9tLnByZXZpb3VzU2libGluZyA6IHBhcmVudERPTS5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICByZW5kZXJEZXNjcyhkZXNjLmNvbnRlbnRET00sIGRlc2MuY2hpbGRyZW4sIHZpZXcpO1xuICAgICAgICAgICAgZG9tID0gcG9zID8gcG9zLm5leHRTaWJsaW5nIDogcGFyZW50RE9NLmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGRvbSkge1xuICAgICAgICBkb20gPSBybShkb20pO1xuICAgICAgICB3cml0dGVuID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHdyaXR0ZW4gJiYgdmlldy50cmFja1dyaXRlcyA9PSBwYXJlbnRET00pXG4gICAgICAgIHZpZXcudHJhY2tXcml0ZXMgPSBudWxsO1xufVxuY29uc3QgT3V0ZXJEZWNvTGV2ZWwgPSBmdW5jdGlvbiAobm9kZU5hbWUpIHtcbiAgICBpZiAobm9kZU5hbWUpXG4gICAgICAgIHRoaXMubm9kZU5hbWUgPSBub2RlTmFtZTtcbn07XG5PdXRlckRlY29MZXZlbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3Qgbm9EZWNvID0gW25ldyBPdXRlckRlY29MZXZlbF07XG5mdW5jdGlvbiBjb21wdXRlT3V0ZXJEZWNvKG91dGVyRGVjbywgbm9kZSwgbmVlZHNXcmFwKSB7XG4gICAgaWYgKG91dGVyRGVjby5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIG5vRGVjbztcbiAgICBsZXQgdG9wID0gbmVlZHNXcmFwID8gbm9EZWNvWzBdIDogbmV3IE91dGVyRGVjb0xldmVsLCByZXN1bHQgPSBbdG9wXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dGVyRGVjby5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYXR0cnMgPSBvdXRlckRlY29baV0udHlwZS5hdHRycztcbiAgICAgICAgaWYgKCFhdHRycylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoYXR0cnMubm9kZU5hbWUpXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0b3AgPSBuZXcgT3V0ZXJEZWNvTGV2ZWwoYXR0cnMubm9kZU5hbWUpKTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycykge1xuICAgICAgICAgICAgbGV0IHZhbCA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKG5lZWRzV3JhcCAmJiByZXN1bHQubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godG9wID0gbmV3IE91dGVyRGVjb0xldmVsKG5vZGUuaXNJbmxpbmUgPyBcInNwYW5cIiA6IFwiZGl2XCIpKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09IFwiY2xhc3NcIilcbiAgICAgICAgICAgICAgICB0b3AuY2xhc3MgPSAodG9wLmNsYXNzID8gdG9wLmNsYXNzICsgXCIgXCIgOiBcIlwiKSArIHZhbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJzdHlsZVwiKVxuICAgICAgICAgICAgICAgIHRvcC5zdHlsZSA9ICh0b3Auc3R5bGUgPyB0b3Auc3R5bGUgKyBcIjtcIiA6IFwiXCIpICsgdmFsO1xuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSAhPSBcIm5vZGVOYW1lXCIpXG4gICAgICAgICAgICAgICAgdG9wW25hbWVdID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXRjaE91dGVyRGVjbyhvdXRlckRPTSwgbm9kZURPTSwgcHJldkNvbXB1dGVkLCBjdXJDb21wdXRlZCkge1xuICAgIC8vIFNob3J0Y3V0IGZvciB0cml2aWFsIGNhc2VcbiAgICBpZiAocHJldkNvbXB1dGVkID09IG5vRGVjbyAmJiBjdXJDb21wdXRlZCA9PSBub0RlY28pXG4gICAgICAgIHJldHVybiBub2RlRE9NO1xuICAgIGxldCBjdXJET00gPSBub2RlRE9NO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyQ29tcHV0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlY28gPSBjdXJDb21wdXRlZFtpXSwgcHJldiA9IHByZXZDb21wdXRlZFtpXTtcbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQ7XG4gICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2Lm5vZGVOYW1lID09IGRlY28ubm9kZU5hbWUgJiYgY3VyRE9NICE9IG91dGVyRE9NICYmXG4gICAgICAgICAgICAgICAgKHBhcmVudCA9IGN1ckRPTS5wYXJlbnROb2RlKSAmJiBwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSBkZWNvLm5vZGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgY3VyRE9NID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChkZWNvLm5vZGVOYW1lKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQucG1Jc0RlY28gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjdXJET00pO1xuICAgICAgICAgICAgICAgIHByZXYgPSBub0RlY29bMF07XG4gICAgICAgICAgICAgICAgY3VyRE9NID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhdGNoQXR0cmlidXRlcyhjdXJET00sIHByZXYgfHwgbm9EZWNvWzBdLCBkZWNvKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1ckRPTTtcbn1cbmZ1bmN0aW9uIHBhdGNoQXR0cmlidXRlcyhkb20sIHByZXYsIGN1cikge1xuICAgIGZvciAobGV0IG5hbWUgaW4gcHJldilcbiAgICAgICAgaWYgKG5hbWUgIT0gXCJjbGFzc1wiICYmIG5hbWUgIT0gXCJzdHlsZVwiICYmIG5hbWUgIT0gXCJub2RlTmFtZVwiICYmICEobmFtZSBpbiBjdXIpKVxuICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBmb3IgKGxldCBuYW1lIGluIGN1cilcbiAgICAgICAgaWYgKG5hbWUgIT0gXCJjbGFzc1wiICYmIG5hbWUgIT0gXCJzdHlsZVwiICYmIG5hbWUgIT0gXCJub2RlTmFtZVwiICYmIGN1cltuYW1lXSAhPSBwcmV2W25hbWVdKVxuICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCBjdXJbbmFtZV0pO1xuICAgIGlmIChwcmV2LmNsYXNzICE9IGN1ci5jbGFzcykge1xuICAgICAgICBsZXQgcHJldkxpc3QgPSBwcmV2LmNsYXNzID8gcHJldi5jbGFzcy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgIGxldCBjdXJMaXN0ID0gY3VyLmNsYXNzID8gY3VyLmNsYXNzLnNwbGl0KFwiIFwiKS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2TGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjdXJMaXN0LmluZGV4T2YocHJldkxpc3RbaV0pID09IC0xKVxuICAgICAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QucmVtb3ZlKHByZXZMaXN0W2ldKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJMaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHByZXZMaXN0LmluZGV4T2YoY3VyTGlzdFtpXSkgPT0gLTEpXG4gICAgICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoY3VyTGlzdFtpXSk7XG4gICAgICAgIGlmIChkb20uY2xhc3NMaXN0Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgIH1cbiAgICBpZiAocHJldi5zdHlsZSAhPSBjdXIuc3R5bGUpIHtcbiAgICAgICAgaWYgKHByZXYuc3R5bGUpIHtcbiAgICAgICAgICAgIGxldCBwcm9wID0gL1xccyooW1xcd1xcLVxceGExLVxcdWZmZmZdKylcXHMqOig/OlwiKD86XFxcXC58W15cIl0pKlwifCcoPzpcXFxcLnxbXiddKSonfFxcKC4qP1xcKXxbXjtdKSovZywgbTtcbiAgICAgICAgICAgIHdoaWxlIChtID0gcHJvcC5leGVjKHByZXYuc3R5bGUpKVxuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShtWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyLnN0eWxlKVxuICAgICAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgKz0gY3VyLnN0eWxlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5T3V0ZXJEZWNvKGRvbSwgZGVjbywgbm9kZSkge1xuICAgIHJldHVybiBwYXRjaE91dGVyRGVjbyhkb20sIGRvbSwgbm9EZWNvLCBjb21wdXRlT3V0ZXJEZWNvKGRlY28sIG5vZGUsIGRvbS5ub2RlVHlwZSAhPSAxKSk7XG59XG5mdW5jdGlvbiBzYW1lT3V0ZXJEZWNvKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghYVtpXS50eXBlLmVxKGJbaV0udHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBSZW1vdmUgYSBET00gbm9kZSBhbmQgcmV0dXJuIGl0cyBuZXh0IHNpYmxpbmcuXG5mdW5jdGlvbiBybShkb20pIHtcbiAgICBsZXQgbmV4dCA9IGRvbS5uZXh0U2libGluZztcbiAgICBkb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20pO1xuICAgIHJldHVybiBuZXh0O1xufVxuLy8gSGVscGVyIGNsYXNzIGZvciBpbmNyZW1lbnRhbGx5IHVwZGF0aW5nIGEgdHJlZSBvZiBtYXJrIGRlc2NzIGFuZFxuLy8gdGhlIHdpZGdldCBhbmQgbm9kZSBkZXNjcyBpbnNpZGUgb2YgdGhlbS5cbmNsYXNzIFZpZXdUcmVlVXBkYXRlciB7XG4gICAgY29uc3RydWN0b3IodG9wLCBsb2NrLCB2aWV3KSB7XG4gICAgICAgIHRoaXMubG9jayA9IGxvY2s7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIC8vIEluZGV4IGludG8gYHRoaXMudG9wYCdzIGNoaWxkIGFycmF5LCByZXByZXNlbnRzIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbi5cbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIC8vIFdoZW4gZW50ZXJpbmcgYSBtYXJrLCB0aGUgY3VycmVudCB0b3AgYW5kIGluZGV4IGFyZSBwdXNoZWRcbiAgICAgICAgLy8gb250byB0aGlzLlxuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIC8vIFRyYWNrcyB3aGV0aGVyIGFueXRoaW5nIHdhcyBjaGFuZ2VkXG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5wcmVNYXRjaCA9IHByZU1hdGNoKHRvcC5ub2RlLmNvbnRlbnQsIHRvcCk7XG4gICAgfVxuICAgIC8vIERlc3Ryb3kgYW5kIHJlbW92ZSB0aGUgY2hpbGRyZW4gYmV0d2VlbiB0aGUgZ2l2ZW4gaW5kaWNlcyBpblxuICAgIC8vIGB0aGlzLnRvcGAuXG4gICAgZGVzdHJveUJldHdlZW4oc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoc3RhcnQgPT0gZW5kKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKylcbiAgICAgICAgICAgIHRoaXMudG9wLmNoaWxkcmVuW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIC8vIERlc3Ryb3kgYWxsIHJlbWFpbmluZyBjaGlsZHJlbiBpbiBgdGhpcy50b3BgLlxuICAgIGRlc3Ryb3lSZXN0KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN5bmMgdGhlIGN1cnJlbnQgc3RhY2sgb2YgbWFyayBkZXNjcyB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZlxuICAgIC8vIG1hcmtzLCByZXVzaW5nIGV4aXN0aW5nIG1hcmsgZGVzY3Mgd2hlbiBwb3NzaWJsZS5cbiAgICBzeW5jVG9NYXJrcyhtYXJrcywgaW5saW5lLCB2aWV3KSB7XG4gICAgICAgIGxldCBrZWVwID0gMCwgZGVwdGggPSB0aGlzLnN0YWNrLmxlbmd0aCA+PiAxO1xuICAgICAgICBsZXQgbWF4S2VlcCA9IE1hdGgubWluKGRlcHRoLCBtYXJrcy5sZW5ndGgpO1xuICAgICAgICB3aGlsZSAoa2VlcCA8IG1heEtlZXAgJiZcbiAgICAgICAgICAgIChrZWVwID09IGRlcHRoIC0gMSA/IHRoaXMudG9wIDogdGhpcy5zdGFja1soa2VlcCArIDEpIDw8IDFdKVxuICAgICAgICAgICAgICAgIC5tYXRjaGVzTWFyayhtYXJrc1trZWVwXSkgJiYgbWFya3Nba2VlcF0udHlwZS5zcGVjLnNwYW5uaW5nICE9PSBmYWxzZSlcbiAgICAgICAgICAgIGtlZXArKztcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBkZXB0aCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95UmVzdCgpO1xuICAgICAgICAgICAgdGhpcy50b3AuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMudG9wID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGRlcHRoIDwgbWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy50b3AsIHRoaXMuaW5kZXggKyAxKTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IC0xO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5kZXg7IGkgPCBNYXRoLm1pbih0aGlzLmluZGV4ICsgMywgdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5tYXRjaGVzTWFyayhtYXJrc1tkZXB0aF0pICYmICF0aGlzLmlzTG9ja2VkKG5leHQuZG9tKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kID4gdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGZvdW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50b3AgPSB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrRGVzYyA9IE1hcmtWaWV3RGVzYy5jcmVhdGUodGhpcy50b3AsIG1hcmtzW2RlcHRoXSwgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCwgMCwgbWFya0Rlc2MpO1xuICAgICAgICAgICAgICAgIHRoaXMudG9wID0gbWFya0Rlc2M7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gZmluZCBhIG5vZGUgZGVzYyBtYXRjaGluZyB0aGUgZ2l2ZW4gZGF0YS4gU2tpcCBvdmVyIGl0IGFuZFxuICAgIC8vIHJldHVybiB0cnVlIHdoZW4gc3VjY2Vzc2Z1bC5cbiAgICBmaW5kTm9kZU1hdGNoKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpbmRleCkge1xuICAgICAgICBsZXQgZm91bmQgPSAtMSwgdGFyZ2V0RGVzYztcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMucHJlTWF0Y2guaW5kZXggJiZcbiAgICAgICAgICAgICh0YXJnZXREZXNjID0gdGhpcy5wcmVNYXRjaC5tYXRjaGVzW2luZGV4IC0gdGhpcy5wcmVNYXRjaC5pbmRleF0pLnBhcmVudCA9PSB0aGlzLnRvcCAmJlxuICAgICAgICAgICAgdGFyZ2V0RGVzYy5tYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykpIHtcbiAgICAgICAgICAgIGZvdW5kID0gdGhpcy50b3AuY2hpbGRyZW4uaW5kZXhPZih0YXJnZXREZXNjLCB0aGlzLmluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4LCBlID0gTWF0aC5taW4odGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoLCBpICsgNSk7IGkgPCBlOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pICYmICF0aGlzLnByZU1hdGNoLm1hdGNoZWQuaGFzKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmQgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGZvdW5kKTtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdXBkYXRlTm9kZUF0KG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpbmRleCwgdmlldykge1xuICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLnRvcC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgIGlmIChjaGlsZC5kaXJ0eSA9PSBOT0RFX0RJUlRZICYmIGNoaWxkLmRvbSA9PSBjaGlsZC5jb250ZW50RE9NKVxuICAgICAgICAgICAgY2hpbGQuZGlydHkgPSBDT05URU5UX0RJUlRZO1xuICAgICAgICBpZiAoIWNoaWxkLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgaW5kZXgpO1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmaW5kSW5kZXhXaXRoQ2hpbGQoZG9tTm9kZSkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9PSB0aGlzLnRvcC5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlc2MgPSBkb21Ob2RlLnBtVmlld0Rlc2M7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2MpXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4OyBpIDwgdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvcC5jaGlsZHJlbltpXSA9PSBkZXNjKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tTm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gdXBkYXRlIHRoZSBuZXh0IG5vZGUsIGlmIGFueSwgdG8gdGhlIGdpdmVuIGRhdGEuIENoZWNrc1xuICAgIC8vIHByZS1tYXRjaGVzIHRvIGF2b2lkIG92ZXJ3cml0aW5nIG5vZGVzIHRoYXQgY291bGQgc3RpbGwgYmUgdXNlZC5cbiAgICB1cGRhdGVOZXh0Tm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgaW5kZXgsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleDsgaSA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMudG9wLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBOb2RlVmlld0Rlc2MpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJlTWF0Y2ggPSB0aGlzLnByZU1hdGNoLm1hdGNoZWQuZ2V0KG5leHQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVNYXRjaCAhPSBudWxsICYmIHByZU1hdGNoICE9IGluZGV4KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRET00gPSBuZXh0LmRvbSwgdXBkYXRlZDtcbiAgICAgICAgICAgICAgICAvLyBDYW4ndCB1cGRhdGUgaWYgbmV4dERPTSBpcyBvciBjb250YWlucyB0aGlzLmxvY2ssIGV4Y2VwdCBpZlxuICAgICAgICAgICAgICAgIC8vIGl0J3MgYSB0ZXh0IG5vZGUgd2hvc2UgY29udGVudCBhbHJlYWR5IG1hdGNoZXMgdGhlIG5ldyB0ZXh0XG4gICAgICAgICAgICAgICAgLy8gYW5kIHdob3NlIGRlY29yYXRpb25zIG1hdGNoIHRoZSBuZXcgb25lcy5cbiAgICAgICAgICAgICAgICBsZXQgbG9ja2VkID0gdGhpcy5pc0xvY2tlZChuZXh0RE9NKSAmJlxuICAgICAgICAgICAgICAgICAgICAhKG5vZGUuaXNUZXh0ICYmIG5leHQubm9kZSAmJiBuZXh0Lm5vZGUuaXNUZXh0ICYmIG5leHQubm9kZURPTS5ub2RlVmFsdWUgPT0gbm9kZS50ZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0LmRpcnR5ICE9IE5PREVfRElSVFkgJiYgc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIG5leHQub3V0ZXJEZWNvKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2NrZWQgJiYgbmV4dC51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmRvbSAhPSBuZXh0RE9NKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWxvY2tlZCAmJiAodXBkYXRlZCA9IHRoaXMucmVjcmVhdGVXcmFwcGVyKG5leHQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4XSA9IHVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVkLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQuZGlydHkgPSBDT05URU5UX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC51cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBXaGVuIGEgbm9kZSB3aXRoIGNvbnRlbnQgaXMgcmVwbGFjZWQgYnkgYSBkaWZmZXJlbnQgbm9kZSB3aXRoXG4gICAgLy8gaWRlbnRpY2FsIGNvbnRlbnQsIG1vdmUgb3ZlciBpdHMgY2hpbGRyZW4uXG4gICAgcmVjcmVhdGVXcmFwcGVyKG5leHQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgaWYgKG5leHQuZGlydHkgfHwgbm9kZS5pc0F0b20gfHwgIW5leHQuY2hpbGRyZW4ubGVuZ3RoIHx8XG4gICAgICAgICAgICAhbmV4dC5ub2RlLmNvbnRlbnQuZXEobm9kZS5jb250ZW50KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgd3JhcHBlciA9IE5vZGVWaWV3RGVzYy5jcmVhdGUodGhpcy50b3AsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpO1xuICAgICAgICBpZiAod3JhcHBlci5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICB3cmFwcGVyLmNoaWxkcmVuID0gbmV4dC5jaGlsZHJlbjtcbiAgICAgICAgICAgIG5leHQuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNoIG9mIHdyYXBwZXIuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2gucGFyZW50ID0gd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICBuZXh0LmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIC8vIEluc2VydCB0aGUgbm9kZSBhcyBhIG5ld2x5IGNyZWF0ZWQgbm9kZSBkZXNjLlxuICAgIGFkZE5vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgZGVzYyA9IE5vZGVWaWV3RGVzYy5jcmVhdGUodGhpcy50b3AsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpO1xuICAgICAgICBpZiAoZGVzYy5jb250ZW50RE9NKVxuICAgICAgICAgICAgZGVzYy51cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgZGVzYyk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIHBsYWNlV2lkZ2V0KHdpZGdldCwgdmlldywgcG9zKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5pbmRleCA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCA/IHRoaXMudG9wLmNoaWxkcmVuW3RoaXMuaW5kZXhdIDogbnVsbDtcbiAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5tYXRjaGVzV2lkZ2V0KHdpZGdldCkgJiZcbiAgICAgICAgICAgICh3aWRnZXQgPT0gbmV4dC53aWRnZXQgfHwgIW5leHQud2lkZ2V0LnR5cGUudG9ET00ucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gbmV3IFdpZGdldFZpZXdEZXNjKHRoaXMudG9wLCB3aWRnZXQsIHZpZXcsIHBvcyk7XG4gICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCsrLCAwLCBkZXNjKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIGEgdGV4dGJsb2NrIGxvb2tzIGFuZCBiZWhhdmVzIGNvcnJlY3RseSBpblxuICAgIC8vIGNvbnRlbnRFZGl0YWJsZS5cbiAgICBhZGRUZXh0YmxvY2tIYWNrcygpIHtcbiAgICAgICAgbGV0IGxhc3RDaGlsZCA9IHRoaXMudG9wLmNoaWxkcmVuW3RoaXMuaW5kZXggLSAxXSwgcGFyZW50ID0gdGhpcy50b3A7XG4gICAgICAgIHdoaWxlIChsYXN0Q2hpbGQgaW5zdGFuY2VvZiBNYXJrVmlld0Rlc2MpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IGxhc3RDaGlsZDtcbiAgICAgICAgICAgIGxhc3RDaGlsZCA9IHBhcmVudC5jaGlsZHJlbltwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYXN0Q2hpbGQgfHwgLy8gRW1wdHkgdGV4dGJsb2NrXG4gICAgICAgICAgICAhKGxhc3RDaGlsZCBpbnN0YW5jZW9mIFRleHRWaWV3RGVzYykgfHxcbiAgICAgICAgICAgIC9cXG4kLy50ZXN0KGxhc3RDaGlsZC5ub2RlLnRleHQpIHx8XG4gICAgICAgICAgICAodGhpcy52aWV3LnJlcXVpcmVzR2Vja29IYWNrTm9kZSAmJiAvXFxzJC8udGVzdChsYXN0Q2hpbGQubm9kZS50ZXh0KSkpIHtcbiAgICAgICAgICAgIC8vIEF2b2lkIGJ1Z3MgaW4gU2FmYXJpJ3MgY3Vyc29yIGRyYXdpbmcgKCMxMTY1KSBhbmQgQ2hyb21lJ3MgbW91c2Ugc2VsZWN0aW9uICgjMTE1MilcbiAgICAgICAgICAgIGlmICgoc2FmYXJpIHx8IGNocm9tZSkgJiYgbGFzdENoaWxkICYmIGxhc3RDaGlsZC5kb20uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEhhY2tOb2RlKFwiSU1HXCIsIHBhcmVudCk7XG4gICAgICAgICAgICB0aGlzLmFkZEhhY2tOb2RlKFwiQlJcIiwgdGhpcy50b3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEhhY2tOb2RlKG5vZGVOYW1lLCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudCA9PSB0aGlzLnRvcCAmJiB0aGlzLmluZGV4IDwgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAmJiBwYXJlbnQuY2hpbGRyZW5bdGhpcy5pbmRleF0ubWF0Y2hlc0hhY2sobm9kZU5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG4gICAgICAgICAgICBpZiAobm9kZU5hbWUgPT0gXCJJTUdcIikge1xuICAgICAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLXNlcGFyYXRvclwiO1xuICAgICAgICAgICAgICAgIGRvbS5hbHQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09IFwiQlJcIilcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci10cmFpbGluZ0JyZWFrXCI7XG4gICAgICAgICAgICBsZXQgaGFjayA9IG5ldyBUcmFpbGluZ0hhY2tWaWV3RGVzYyh0aGlzLnRvcCwgW10sIGRvbSwgbnVsbCk7XG4gICAgICAgICAgICBpZiAocGFyZW50ICE9IHRoaXMudG9wKVxuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKGhhY2spO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCsrLCAwLCBoYWNrKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNMb2NrZWQobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NrICYmIChub2RlID09IHRoaXMubG9jayB8fCBub2RlLm5vZGVUeXBlID09IDEgJiYgbm9kZS5jb250YWlucyh0aGlzLmxvY2sucGFyZW50Tm9kZSkpO1xuICAgIH1cbn1cbi8vIEl0ZXJhdGUgZnJvbSB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudCBhbmQgYXJyYXkgb2YgZGVzY3MgdG8gZmluZFxuLy8gZGlyZWN0bHkgbWF0Y2hpbmcgb25lcywgaW4gb3JkZXIgdG8gYXZvaWQgb3ZlcmVhZ2VybHkgcmV1c2luZyB0aG9zZVxuLy8gZm9yIG90aGVyIG5vZGVzLiBSZXR1cm5zIHRoZSBmcmFnbWVudCBpbmRleCBvZiB0aGUgZmlyc3Qgbm9kZSB0aGF0XG4vLyBpcyBwYXJ0IG9mIHRoZSBzZXF1ZW5jZSBvZiBtYXRjaGVkIG5vZGVzIGF0IHRoZSBlbmQgb2YgdGhlXG4vLyBmcmFnbWVudC5cbmZ1bmN0aW9uIHByZU1hdGNoKGZyYWcsIHBhcmVudERlc2MpIHtcbiAgICBsZXQgY3VyRGVzYyA9IHBhcmVudERlc2MsIGRlc2NJID0gY3VyRGVzYy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgbGV0IGZJID0gZnJhZy5jaGlsZENvdW50LCBtYXRjaGVkID0gbmV3IE1hcCwgbWF0Y2hlcyA9IFtdO1xuICAgIG91dGVyOiB3aGlsZSAoZkkgPiAwKSB7XG4gICAgICAgIGxldCBkZXNjO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoZGVzY0kpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGN1ckRlc2MuY2hpbGRyZW5bZGVzY0kgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIE1hcmtWaWV3RGVzYykge1xuICAgICAgICAgICAgICAgICAgICBjdXJEZXNjID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZGVzY0kgPSBuZXh0LmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBkZXNjSS0tO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJEZXNjID09IHBhcmVudERlc2MpIHtcbiAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgZGVzY0kgPSBjdXJEZXNjLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGN1ckRlc2MpO1xuICAgICAgICAgICAgICAgIGN1ckRlc2MgPSBjdXJEZXNjLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9kZSA9IGRlc2Mubm9kZTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChub2RlICE9IGZyYWcuY2hpbGQoZkkgLSAxKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAtLWZJO1xuICAgICAgICBtYXRjaGVkLnNldChkZXNjLCBmSSk7XG4gICAgICAgIG1hdGNoZXMucHVzaChkZXNjKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaW5kZXg6IGZJLCBtYXRjaGVkLCBtYXRjaGVzOiBtYXRjaGVzLnJldmVyc2UoKSB9O1xufVxuZnVuY3Rpb24gY29tcGFyZVNpZGUoYSwgYikge1xuICAgIHJldHVybiBhLnR5cGUuc2lkZSAtIGIudHlwZS5zaWRlO1xufVxuLy8gVGhpcyBmdW5jdGlvbiBhYnN0cmFjdHMgaXRlcmF0aW5nIG92ZXIgdGhlIG5vZGVzIGFuZCBkZWNvcmF0aW9ucyBpblxuLy8gYSBmcmFnbWVudC4gQ2FsbHMgYG9uTm9kZWAgZm9yIGVhY2ggbm9kZSwgd2l0aCBpdHMgbG9jYWwgYW5kIGNoaWxkXG4vLyBkZWNvcmF0aW9ucy4gU3BsaXRzIHRleHQgbm9kZXMgd2hlbiB0aGVyZSBpcyBhIGRlY29yYXRpb24gc3RhcnRpbmdcbi8vIG9yIGVuZGluZyBpbnNpZGUgb2YgdGhlbS4gQ2FsbHMgYG9uV2lkZ2V0YCBmb3IgZWFjaCB3aWRnZXQuXG5mdW5jdGlvbiBpdGVyRGVjbyhwYXJlbnQsIGRlY28sIG9uV2lkZ2V0LCBvbk5vZGUpIHtcbiAgICBsZXQgbG9jYWxzID0gZGVjby5sb2NhbHMocGFyZW50KSwgb2Zmc2V0ID0gMDtcbiAgICAvLyBTaW1wbGUsIGNoZWFwIHZhcmlhbnQgZm9yIHdoZW4gdGhlcmUgYXJlIG5vIGxvY2FsIGRlY29yYXRpb25zXG4gICAgaWYgKGxvY2Fscy5sZW5ndGggPT0gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudC5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHBhcmVudC5jaGlsZChpKTtcbiAgICAgICAgICAgIG9uTm9kZShjaGlsZCwgbG9jYWxzLCBkZWNvLmZvckNoaWxkKG9mZnNldCwgY2hpbGQpLCBpKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBkZWNvSW5kZXggPSAwLCBhY3RpdmUgPSBbXSwgcmVzdE5vZGUgPSBudWxsO1xuICAgIGZvciAobGV0IHBhcmVudEluZGV4ID0gMDs7KSB7XG4gICAgICAgIGxldCB3aWRnZXQsIHdpZGdldHM7XG4gICAgICAgIHdoaWxlIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvID09IG9mZnNldCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBsb2NhbHNbZGVjb0luZGV4KytdO1xuICAgICAgICAgICAgaWYgKG5leHQud2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3aWRnZXQpXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAod2lkZ2V0cyB8fCAod2lkZ2V0cyA9IFt3aWRnZXRdKSkucHVzaChuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkZ2V0KSB7XG4gICAgICAgICAgICBpZiAod2lkZ2V0cykge1xuICAgICAgICAgICAgICAgIHdpZGdldHMuc29ydChjb21wYXJlU2lkZSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWRnZXRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBvbldpZGdldCh3aWRnZXRzW2ldLCBwYXJlbnRJbmRleCwgISFyZXN0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvbldpZGdldCh3aWRnZXQsIHBhcmVudEluZGV4LCAhIXJlc3ROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hpbGQsIGluZGV4O1xuICAgICAgICBpZiAocmVzdE5vZGUpIHtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBjaGlsZCA9IHJlc3ROb2RlO1xuICAgICAgICAgICAgcmVzdE5vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmVudEluZGV4IDwgcGFyZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgICAgICAgICBjaGlsZCA9IHBhcmVudC5jaGlsZChwYXJlbnRJbmRleCsrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGFjdGl2ZVtpXS50byA8PSBvZmZzZXQpXG4gICAgICAgICAgICAgICAgYWN0aXZlLnNwbGljZShpLS0sIDEpO1xuICAgICAgICB3aGlsZSAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS5mcm9tIDw9IG9mZnNldCAmJiBsb2NhbHNbZGVjb0luZGV4XS50byA+IG9mZnNldClcbiAgICAgICAgICAgIGFjdGl2ZS5wdXNoKGxvY2Fsc1tkZWNvSW5kZXgrK10pO1xuICAgICAgICBsZXQgZW5kID0gb2Zmc2V0ICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgIGlmIChjaGlsZC5pc1RleHQpIHtcbiAgICAgICAgICAgIGxldCBjdXRBdCA9IGVuZDtcbiAgICAgICAgICAgIGlmIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLmZyb20gPCBjdXRBdClcbiAgICAgICAgICAgICAgICBjdXRBdCA9IGxvY2Fsc1tkZWNvSW5kZXhdLmZyb207XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlW2ldLnRvIDwgY3V0QXQpXG4gICAgICAgICAgICAgICAgICAgIGN1dEF0ID0gYWN0aXZlW2ldLnRvO1xuICAgICAgICAgICAgaWYgKGN1dEF0IDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgcmVzdE5vZGUgPSBjaGlsZC5jdXQoY3V0QXQgLSBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY3V0KDAsIGN1dEF0IC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBlbmQgPSBjdXRBdDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBvdXRlckRlY28gPSBjaGlsZC5pc0lubGluZSAmJiAhY2hpbGQuaXNMZWFmID8gYWN0aXZlLmZpbHRlcihkID0+ICFkLmlubGluZSkgOiBhY3RpdmUuc2xpY2UoKTtcbiAgICAgICAgb25Ob2RlKGNoaWxkLCBvdXRlckRlY28sIGRlY28uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCksIGluZGV4KTtcbiAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgIH1cbn1cbi8vIExpc3QgbWFya2VycyBpbiBNb2JpbGUgU2FmYXJpIHdpbGwgbXlzdGVyaW91c2x5IGRpc2FwcGVhclxuLy8gc29tZXRpbWVzLiBUaGlzIHdvcmtzIGFyb3VuZCB0aGF0LlxuZnVuY3Rpb24gaW9zSGFja3MoZG9tKSB7XG4gICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIlVMXCIgfHwgZG9tLm5vZGVOYW1lID09IFwiT0xcIikge1xuICAgICAgICBsZXQgb2xkQ1NTID0gZG9tLnN0eWxlLmNzc1RleHQ7XG4gICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTICsgXCI7IGxpc3Qtc3R5bGU6IHNxdWFyZSAhaW1wb3J0YW50XCI7XG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbSkubGlzdFN0eWxlO1xuICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IG9sZENTUztcbiAgICB9XG59XG5mdW5jdGlvbiBuZWFyYnlUZXh0Tm9kZShub2RlLCBvZmZzZXQpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IG9mZnNldCAmJiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBvZmZzZXQgPSBub2RlU2l6ZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gRmluZCBhIHBpZWNlIG9mIHRleHQgaW4gYW4gaW5saW5lIGZyYWdtZW50LCBvdmVybGFwcGluZyBmcm9tLXRvXG5mdW5jdGlvbiBmaW5kVGV4dEluRnJhZ21lbnQoZnJhZywgdGV4dCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IGZyYWcuY2hpbGRDb3VudCAmJiBwb3MgPD0gdG87KSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGZyYWcuY2hpbGQoaSsrKSwgY2hpbGRTdGFydCA9IHBvcztcbiAgICAgICAgcG9zICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBpZiAoIWNoaWxkLmlzVGV4dClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgc3RyID0gY2hpbGQudGV4dDtcbiAgICAgICAgd2hpbGUgKGkgPCBmcmFnLmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZnJhZy5jaGlsZChpKyspO1xuICAgICAgICAgICAgcG9zICs9IG5leHQubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoIW5leHQuaXNUZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3RyICs9IG5leHQudGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IGZyb20pIHtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdG8gJiYgc3RyLnNsaWNlKHRvIC0gdGV4dC5sZW5ndGggLSBjaGlsZFN0YXJ0LCB0byAtIGNoaWxkU3RhcnQpID09IHRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvIC0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBjaGlsZFN0YXJ0IDwgdG8gPyBzdHIubGFzdEluZGV4T2YodGV4dCwgdG8gLSBjaGlsZFN0YXJ0IC0gMSkgOiAtMTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA+PSAwICYmIGZvdW5kICsgdGV4dC5sZW5ndGggKyBjaGlsZFN0YXJ0ID49IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkU3RhcnQgKyBmb3VuZDtcbiAgICAgICAgICAgIGlmIChmcm9tID09IHRvICYmIHN0ci5sZW5ndGggPj0gKHRvICsgdGV4dC5sZW5ndGgpIC0gY2hpbGRTdGFydCAmJlxuICAgICAgICAgICAgICAgIHN0ci5zbGljZSh0byAtIGNoaWxkU3RhcnQsIHRvIC0gY2hpbGRTdGFydCArIHRleHQubGVuZ3RoKSA9PSB0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0bztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4vLyBSZXBsYWNlIHJhbmdlIGZyb20tdG8gaW4gYW4gYXJyYXkgb2YgdmlldyBkZXNjcyB3aXRoIHJlcGxhY2VtZW50XG4vLyAobWF5IGJlIG51bGwgdG8ganVzdCBkZWxldGUpLiBUaGlzIGdvZXMgdmVyeSBtdWNoIGFnYWluc3QgdGhlIGdyYWluXG4vLyBvZiB0aGUgcmVzdCBvZiB0aGlzIGNvZGUsIHdoaWNoIHRlbmRzIHRvIGNyZWF0ZSBub2RlcyB3aXRoIHRoZVxuLy8gcmlnaHQgc2hhcGUgaW4gb25lIGdvLCByYXRoZXIgdGhhbiBtZXNzaW5nIHdpdGggdGhlbSBhZnRlclxuLy8gY3JlYXRpb24sIGJ1dCBpcyBuZWNlc3NhcnkgaW4gdGhlIGNvbXBvc2l0aW9uIGhhY2suXG5mdW5jdGlvbiByZXBsYWNlTm9kZXMobm9kZXMsIGZyb20sIHRvLCB2aWV3LCByZXBsYWNlbWVudCkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgb2ZmID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IG5vZGVzW2ldLCBzdGFydCA9IG9mZiwgZW5kID0gb2ZmICs9IGNoaWxkLnNpemU7XG4gICAgICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZnJvbSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZC5zbGljZSgwLCBmcm9tIC0gc3RhcnQsIHZpZXcpKTtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJlcGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZC5zbGljZSh0byAtIHN0YXJ0LCBjaGlsZC5zaXplLCB2aWV3KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uRnJvbURPTSh2aWV3LCBvcmlnaW4gPSBudWxsKSB7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKSwgZG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgaWYgKCFkb21TZWwuZm9jdXNOb2RlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbmVhcmVzdERlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZG9tU2VsLmZvY3VzTm9kZSksIGluV2lkZ2V0ID0gbmVhcmVzdERlc2MgJiYgbmVhcmVzdERlc2Muc2l6ZSA9PSAwO1xuICAgIGxldCBoZWFkID0gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0LCAxKTtcbiAgICBpZiAoaGVhZCA8IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCAkaGVhZCA9IGRvYy5yZXNvbHZlKGhlYWQpLCAkYW5jaG9yLCBzZWxlY3Rpb247XG4gICAgaWYgKHNlbGVjdGlvbkNvbGxhcHNlZChkb21TZWwpKSB7XG4gICAgICAgICRhbmNob3IgPSAkaGVhZDtcbiAgICAgICAgd2hpbGUgKG5lYXJlc3REZXNjICYmICFuZWFyZXN0RGVzYy5ub2RlKVxuICAgICAgICAgICAgbmVhcmVzdERlc2MgPSBuZWFyZXN0RGVzYy5wYXJlbnQ7XG4gICAgICAgIGxldCBuZWFyZXN0RGVzY05vZGUgPSBuZWFyZXN0RGVzYy5ub2RlO1xuICAgICAgICBpZiAobmVhcmVzdERlc2MgJiYgbmVhcmVzdERlc2NOb2RlLmlzQXRvbSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShuZWFyZXN0RGVzY05vZGUpICYmIG5lYXJlc3REZXNjLnBhcmVudFxuICAgICAgICAgICAgJiYgIShuZWFyZXN0RGVzY05vZGUuaXNJbmxpbmUgJiYgaXNPbkVkZ2UoZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0LCBuZWFyZXN0RGVzYy5kb20pKSkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IG5lYXJlc3REZXNjLnBvc0JlZm9yZTtcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IG5ldyBOb2RlU2VsZWN0aW9uKGhlYWQgPT0gcG9zID8gJGhlYWQgOiBkb2MucmVzb2x2ZShwb3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGFuY2hvciA9IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0LCAxKTtcbiAgICAgICAgaWYgKGFuY2hvciA8IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgJGFuY2hvciA9IGRvYy5yZXNvbHZlKGFuY2hvcik7XG4gICAgfVxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBiaWFzID0gb3JpZ2luID09IFwicG9pbnRlclwiIHx8ICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5oZWFkIDwgJGhlYWQucG9zICYmICFpbldpZGdldCkgPyAxIDogLTE7XG4gICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbkJldHdlZW4odmlldywgJGFuY2hvciwgJGhlYWQsIGJpYXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSB7XG4gICAgcmV0dXJuIHZpZXcuZWRpdGFibGUgPyB2aWV3Lmhhc0ZvY3VzKCkgOlxuICAgICAgICBoYXNTZWxlY3Rpb24odmlldykgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmNvbnRhaW5zKHZpZXcuZG9tKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvblRvRE9NKHZpZXcsIGZvcmNlID0gZmFsc2UpIHtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgc3luY05vZGVTZWxlY3Rpb24odmlldywgc2VsKTtcbiAgICBpZiAoIWVkaXRvck93bnNTZWxlY3Rpb24odmlldykpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBUaGUgZGVsYXllZCBkcmFnIHNlbGVjdGlvbiBjYXVzZXMgaXNzdWVzIHdpdGggQ2VsbCBTZWxlY3Rpb25zXG4gICAgLy8gaW4gU2FmYXJpLiBBbmQgdGhlIGRyYWcgc2VsZWN0aW9uIGRlbGF5IGlzIHRvIHdvcmthcm9uZCBpc3N1ZXNcbiAgICAvLyB3aGljaCBvbmx5IHByZXNlbnQgaW4gQ2hyb21lLlxuICAgIGlmICghZm9yY2UgJiYgdmlldy5pbnB1dC5tb3VzZURvd24gJiYgdmlldy5pbnB1dC5tb3VzZURvd24uYWxsb3dEZWZhdWx0ICYmIGNocm9tZSkge1xuICAgICAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpLCBjdXJTZWwgPSB2aWV3LmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgIGlmIChkb21TZWwuYW5jaG9yTm9kZSAmJiBjdXJTZWwuYW5jaG9yTm9kZSAmJlxuICAgICAgICAgICAgaXNFcXVpdmFsZW50UG9zaXRpb24oZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQsIGN1clNlbC5hbmNob3JOb2RlLCBjdXJTZWwuYW5jaG9yT2Zmc2V0KSkge1xuICAgICAgICAgICAgdmlldy5pbnB1dC5tb3VzZURvd24uZGVsYXllZFNlbGVjdGlvblN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aWV3LmRvbU9ic2VydmVyLmRpc2Nvbm5lY3RTZWxlY3Rpb24oKTtcbiAgICBpZiAodmlldy5jdXJzb3JXcmFwcGVyKSB7XG4gICAgICAgIHNlbGVjdEN1cnNvcldyYXBwZXIodmlldyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgeyBhbmNob3IsIGhlYWQgfSA9IHNlbCwgcmVzZXRFZGl0YWJsZUZyb20sIHJlc2V0RWRpdGFibGVUbztcbiAgICAgICAgaWYgKGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlICYmICEoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmICghc2VsLiRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGVGcm9tID0gdGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIodmlldywgc2VsLmZyb20pO1xuICAgICAgICAgICAgaWYgKCFzZWwuZW1wdHkgJiYgIXNlbC4kZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgICAgICByZXNldEVkaXRhYmxlVG8gPSB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBzZWwudG8pO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcuZG9jVmlldy5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCB2aWV3LnJvb3QsIGZvcmNlKTtcbiAgICAgICAgaWYgKGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlKSB7XG4gICAgICAgICAgICBpZiAocmVzZXRFZGl0YWJsZUZyb20pXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZShyZXNldEVkaXRhYmxlRnJvbSk7XG4gICAgICAgICAgICBpZiAocmVzZXRFZGl0YWJsZVRvKVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGUocmVzZXRFZGl0YWJsZVRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsLnZpc2libGUpIHtcbiAgICAgICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb25cIik7XG4gICAgICAgICAgICBpZiAoXCJvbnNlbGVjdGlvbmNoYW5nZVwiIGluIGRvY3VtZW50KVxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzT25TZWxlY3Rpb25DaGFuZ2Uodmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlldy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICB2aWV3LmRvbU9ic2VydmVyLmNvbm5lY3RTZWxlY3Rpb24oKTtcbn1cbi8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBXZWJraXQgbm90IGFsbG93aW5nIGEgc2VsZWN0aW9uIHRvIHN0YXJ0L2VuZFxuLy8gYmV0d2VlbiBub24tZWRpdGFibGUgYmxvY2sgbm9kZXMuIFdlIGJyaWVmbHkgbWFrZSBzb21ldGhpbmdcbi8vIGVkaXRhYmxlLCBzZXQgdGhlIHNlbGVjdGlvbiwgdGhlbiBzZXQgaXQgdW5lZGl0YWJsZSBhZ2Fpbi5cbmNvbnN0IGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlID0gc2FmYXJpIHx8IGNocm9tZSAmJiBjaHJvbWVfdmVyc2lvbiA8IDYzO1xuZnVuY3Rpb24gdGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIodmlldywgcG9zKSB7XG4gICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcyhwb3MsIDApO1xuICAgIGxldCBhZnRlciA9IG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPyBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSA6IG51bGw7XG4gICAgbGV0IGJlZm9yZSA9IG9mZnNldCA/IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXSA6IG51bGw7XG4gICAgaWYgKHNhZmFyaSAmJiBhZnRlciAmJiBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYWZ0ZXIpO1xuICAgIGlmICgoIWFmdGVyIHx8IGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpICYmXG4gICAgICAgICghYmVmb3JlIHx8IGJlZm9yZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSkge1xuICAgICAgICBpZiAoYWZ0ZXIpXG4gICAgICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYWZ0ZXIpO1xuICAgICAgICBlbHNlIGlmIChiZWZvcmUpXG4gICAgICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYmVmb3JlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRFZGl0YWJsZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5jb250ZW50RWRpdGFibGUgPSBcInRydWVcIjtcbiAgICBpZiAoc2FmYXJpICYmIGVsZW1lbnQuZHJhZ2dhYmxlKSB7XG4gICAgICAgIGVsZW1lbnQuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIGVsZW1lbnQud2FzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiByZXNldEVkaXRhYmxlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICBpZiAoZWxlbWVudC53YXNEcmFnZ2FibGUpIHtcbiAgICAgICAgZWxlbWVudC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICBlbGVtZW50Lndhc0RyYWdnYWJsZSA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NPblNlbGVjdGlvbkNoYW5nZSh2aWV3KSB7XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdmlldy5pbnB1dC5oaWRlU2VsZWN0aW9uR3VhcmQpO1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IG5vZGUgPSBkb21TZWwuYW5jaG9yTm9kZSwgb2Zmc2V0ID0gZG9tU2VsLmFuY2hvck9mZnNldDtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB2aWV3LmlucHV0LmhpZGVTZWxlY3Rpb25HdWFyZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGRvbVNlbC5hbmNob3JOb2RlICE9IG5vZGUgfHwgZG9tU2VsLmFuY2hvck9mZnNldCAhPSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaW5wdXQuaGlkZVNlbGVjdGlvbkd1YXJkKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbi52aXNpYmxlKVxuICAgICAgICAgICAgICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvblwiKTtcbiAgICAgICAgICAgIH0sIDIwKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc2VsZWN0Q3Vyc29yV3JhcHBlcih2aWV3KSB7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCksIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBsZXQgbm9kZSA9IHZpZXcuY3Vyc29yV3JhcHBlci5kb20sIGltZyA9IG5vZGUubm9kZU5hbWUgPT0gXCJJTUdcIjtcbiAgICBpZiAoaW1nKVxuICAgICAgICByYW5nZS5zZXRFbmQobm9kZS5wYXJlbnROb2RlLCBkb21JbmRleChub2RlKSArIDEpO1xuICAgIGVsc2VcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIDApO1xuICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICBkb21TZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgZG9tU2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAvLyBLbHVkZ2UgdG8ga2lsbCAnY29udHJvbCBzZWxlY3Rpb24nIGluIElFMTEgd2hlbiBzZWxlY3RpbmcgYW5cbiAgICAvLyBpbnZpc2libGUgY3Vyc29yIHdyYXBwZXIsIHNpbmNlIHRoYXQgd291bGQgcmVzdWx0IGluIHRob3NlIHdlaXJkXG4gICAgLy8gcmVzaXplIGhhbmRsZXMgYW5kIGEgc2VsZWN0aW9uIHRoYXQgY29uc2lkZXJzIHRoZSBhYnNvbHV0ZWx5XG4gICAgLy8gcG9zaXRpb25lZCB3cmFwcGVyLCByYXRoZXIgdGhhbiB0aGUgcm9vdCBlZGl0YWJsZSBub2RlLCB0aGVcbiAgICAvLyBmb2N1c2VkIGVsZW1lbnQuXG4gICAgaWYgKCFpbWcgJiYgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLnZpc2libGUgJiYgaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSkge1xuICAgICAgICBub2RlLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgbm9kZS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN5bmNOb2RlU2VsZWN0aW9uKHZpZXcsIHNlbCkge1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3LmRlc2NBdChzZWwuZnJvbSk7XG4gICAgICAgIGlmIChkZXNjICE9IHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MpIHtcbiAgICAgICAgICAgIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KTtcbiAgICAgICAgICAgIGlmIChkZXNjKVxuICAgICAgICAgICAgICAgIGRlc2Muc2VsZWN0Tm9kZSgpO1xuICAgICAgICAgICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IGRlc2M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KTtcbiAgICB9XG59XG4vLyBDbGVhciBhbGwgRE9NIHN0YXRlZnVsbmVzcyBvZiB0aGUgbGFzdCBub2RlIHNlbGVjdGlvbi5cbmZ1bmN0aW9uIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KSB7XG4gICAgaWYgKHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MpIHtcbiAgICAgICAgaWYgKHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MucGFyZW50KVxuICAgICAgICAgICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYy5kZXNlbGVjdE5vZGUoKTtcbiAgICAgICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsICRhbmNob3IsICRoZWFkLCBiaWFzKSB7XG4gICAgcmV0dXJuIHZpZXcuc29tZVByb3AoXCJjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuXCIsIGYgPT4gZih2aWV3LCAkYW5jaG9yLCAkaGVhZCkpXG4gICAgICAgIHx8IFRleHRTZWxlY3Rpb24uYmV0d2VlbigkYW5jaG9yLCAkaGVhZCwgYmlhcyk7XG59XG5mdW5jdGlvbiBoYXNGb2N1c0FuZFNlbGVjdGlvbih2aWV3KSB7XG4gICAgaWYgKHZpZXcuZWRpdGFibGUgJiYgIXZpZXcuaGFzRm9jdXMoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBoYXNTZWxlY3Rpb24odmlldyk7XG59XG5mdW5jdGlvbiBoYXNTZWxlY3Rpb24odmlldykge1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgaWYgKCFzZWwuYW5jaG9yTm9kZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEZpcmVmb3ggd2lsbCByYWlzZSAncGVybWlzc2lvbiBkZW5pZWQnIGVycm9ycyB3aGVuIGFjY2Vzc2luZ1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIG9mIGBzZWwuYW5jaG9yTm9kZWAgd2hlbiBpdCdzIGluIGEgZ2VuZXJhdGVkIENTU1xuICAgICAgICAvLyBlbGVtZW50LlxuICAgICAgICByZXR1cm4gdmlldy5kb20uY29udGFpbnMoc2VsLmFuY2hvck5vZGUubm9kZVR5cGUgPT0gMyA/IHNlbC5hbmNob3JOb2RlLnBhcmVudE5vZGUgOiBzZWwuYW5jaG9yTm9kZSkgJiZcbiAgICAgICAgICAgICh2aWV3LmVkaXRhYmxlIHx8IHZpZXcuZG9tLmNvbnRhaW5zKHNlbC5mb2N1c05vZGUubm9kZVR5cGUgPT0gMyA/IHNlbC5mb2N1c05vZGUucGFyZW50Tm9kZSA6IHNlbC5mb2N1c05vZGUpKTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFuY2hvckluUmlnaHRQbGFjZSh2aWV3KSB7XG4gICAgbGV0IGFuY2hvckRPTSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmFuY2hvciwgMCk7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICByZXR1cm4gaXNFcXVpdmFsZW50UG9zaXRpb24oYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQsIGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbn1cblxuZnVuY3Rpb24gbW92ZVNlbGVjdGlvbkJsb2NrKHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgeyAkYW5jaG9yLCAkaGVhZCB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCAkc2lkZSA9IGRpciA+IDAgPyAkYW5jaG9yLm1heCgkaGVhZCkgOiAkYW5jaG9yLm1pbigkaGVhZCk7XG4gICAgbGV0ICRzdGFydCA9ICEkc2lkZS5wYXJlbnQuaW5saW5lQ29udGVudCA/ICRzaWRlIDogJHNpZGUuZGVwdGggPyBzdGF0ZS5kb2MucmVzb2x2ZShkaXIgPiAwID8gJHNpZGUuYWZ0ZXIoKSA6ICRzaWRlLmJlZm9yZSgpKSA6IG51bGw7XG4gICAgcmV0dXJuICRzdGFydCAmJiBTZWxlY3Rpb24uZmluZEZyb20oJHN0YXJ0LCBkaXIpO1xufVxuZnVuY3Rpb24gYXBwbHkodmlldywgc2VsKSB7XG4gICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2VsZWN0SG9yaXpvbnRhbGx5KHZpZXcsIGRpciwgbW9kcykge1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikge1xuICAgICAgICBpZiAoIXNlbC5lbXB0eSB8fCBtb2RzLmluZGV4T2YoXCJzXCIpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA+IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIikpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgICAgICAgICBpZiAobmV4dCAmJiAobmV4dCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pKVxuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKG1hYyAmJiBtb2RzLmluZGV4T2YoXCJtXCIpID4gLTEpKSB7XG4gICAgICAgICAgICBsZXQgJGhlYWQgPSBzZWwuJGhlYWQsIG5vZGUgPSAkaGVhZC50ZXh0T2Zmc2V0ID8gbnVsbCA6IGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyLCBkZXNjO1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUuaXNUZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBub2RlUG9zID0gZGlyIDwgMCA/ICRoZWFkLnBvcyAtIG5vZGUubm9kZVNpemUgOiAkaGVhZC5wb3M7XG4gICAgICAgICAgICBpZiAoIShub2RlLmlzQXRvbSB8fCAoZGVzYyA9IHZpZXcuZG9jVmlldy5kZXNjQXQobm9kZVBvcykpICYmICFkZXNjLmNvbnRlbnRET00pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgTm9kZVNlbGVjdGlvbihkaXIgPCAwID8gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZSgkaGVhZC5wb3MgLSBub2RlLm5vZGVTaXplKSA6ICRoZWFkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3ZWJraXQpIHtcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaSB3aWxsIGludHJvZHVjZSBleHRyYSBwb2ludGxlc3MgY3Vyc29yXG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb25zIGFyb3VuZCBpbmxpbmUgdW5lZGl0YWJsZSBub2Rlcywgc28gd2UgaGF2ZSB0b1xuICAgICAgICAgICAgICAgIC8vIHRha2Ugb3ZlciBhbmQgbW92ZSB0aGUgY3Vyc29yIHBhc3QgdGhlbSAoIzkzNylcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IFRleHRTZWxlY3Rpb24odmlldy5zdGF0ZS5kb2MucmVzb2x2ZShkaXIgPCAwID8gbm9kZVBvcyA6IG5vZGVQb3MgKyBub2RlLm5vZGVTaXplKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc2VsLm5vZGUuaXNJbmxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBUZXh0U2VsZWN0aW9uKGRpciA+IDAgPyBzZWwuJHRvIDogc2VsLiRmcm9tKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgbmV4dCA9IG1vdmVTZWxlY3Rpb25CbG9jayh2aWV3LnN0YXRlLCBkaXIpO1xuICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vZGVMZW4obm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNJZ25vcmFibGUoZG9tLCBkaXIpIHtcbiAgICBpZiAoZG9tLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gICAgcmV0dXJuIGRlc2MgJiYgZGVzYy5zaXplID09IDAgJiYgKGRpciA8IDAgfHwgZG9tLm5leHRTaWJsaW5nIHx8IGRvbS5ub2RlTmFtZSAhPSBcIkJSXCIpO1xufVxuZnVuY3Rpb24gc2tpcElnbm9yZWROb2Rlcyh2aWV3LCBkaXIpIHtcbiAgICByZXR1cm4gZGlyIDwgMCA/IHNraXBJZ25vcmVkTm9kZXNCZWZvcmUodmlldykgOiBza2lwSWdub3JlZE5vZGVzQWZ0ZXIodmlldyk7XG59XG4vLyBNYWtlIHN1cmUgdGhlIGN1cnNvciBpc24ndCBkaXJlY3RseSBhZnRlciBvbmUgb3IgbW9yZSBpZ25vcmVkXG4vLyBub2Rlcywgd2hpY2ggd2lsbCBjb25mdXNlIHRoZSBicm93c2VyJ3MgY3Vyc29yIG1vdGlvbiBsb2dpYy5cbmZ1bmN0aW9uIHNraXBJZ25vcmVkTm9kZXNCZWZvcmUodmlldykge1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IG5vZGUgPSBzZWwuZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IG1vdmVOb2RlLCBtb3ZlT2Zmc2V0LCBmb3JjZSA9IGZhbHNlO1xuICAgIC8vIEdlY2tvIHdpbGwgZG8gb2RkIHRoaW5ncyB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgZGlyZWN0bHkgaW4gZnJvbnRcbiAgICAvLyBvZiBhIG5vbi1lZGl0YWJsZSBub2RlLCBzbyBpbiB0aGF0IGNhc2UsIG1vdmUgaXQgaW50byB0aGUgbmV4dFxuICAgIC8vIG5vZGUgaWYgcG9zc2libGUuIElzc3VlIHByb3NlbWlycm9yL3Byb3NlbWlycm9yIzgzMi5cbiAgICBpZiAoZ2Vja28gJiYgbm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA8IG5vZGVMZW4obm9kZSkgJiYgaXNJZ25vcmFibGUobm9kZS5jaGlsZE5vZGVzW29mZnNldF0sIC0xKSlcbiAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGlzSWdub3JhYmxlKGJlZm9yZSwgLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9IC0tb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gYmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCbG9ja05vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIHdoaWxlIChwcmV2ICYmIGlzSWdub3JhYmxlKHByZXYsIC0xKSkge1xuICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSBkb21JbmRleChwcmV2KTtcbiAgICAgICAgICAgICAgICBwcmV2ID0gcHJldi5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09IHZpZXcuZG9tKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHByZXY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZUxlbihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZm9yY2UpXG4gICAgICAgIHNldFNlbEZvY3VzKHZpZXcsIG5vZGUsIG9mZnNldCk7XG4gICAgZWxzZSBpZiAobW92ZU5vZGUpXG4gICAgICAgIHNldFNlbEZvY3VzKHZpZXcsIG1vdmVOb2RlLCBtb3ZlT2Zmc2V0KTtcbn1cbi8vIE1ha2Ugc3VyZSB0aGUgY3Vyc29yIGlzbid0IGRpcmVjdGx5IGJlZm9yZSBvbmUgb3IgbW9yZSBpZ25vcmVkXG4vLyBub2Rlcy5cbmZ1bmN0aW9uIHNraXBJZ25vcmVkTm9kZXNBZnRlcih2aWV3KSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgbm9kZSA9IHNlbC5mb2N1c05vZGUsIG9mZnNldCA9IHNlbC5mb2N1c09mZnNldDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbGVuID0gbm9kZUxlbihub2RlKTtcbiAgICBsZXQgbW92ZU5vZGUsIG1vdmVPZmZzZXQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBpZiAoaXNJZ25vcmFibGUoYWZ0ZXIsIDEpKSB7XG4gICAgICAgICAgICAgICAgbW92ZU5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSArK29mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Jsb2NrTm9kZShub2RlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCAmJiBpc0lnbm9yYWJsZShuZXh0LCAxKSkge1xuICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbmV4dC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSBkb21JbmRleChuZXh0KSArIDE7XG4gICAgICAgICAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09IHZpZXcuZG9tKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBsZW4gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICBsZW4gPSBub2RlTGVuKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtb3ZlTm9kZSlcbiAgICAgICAgc2V0U2VsRm9jdXModmlldywgbW92ZU5vZGUsIG1vdmVPZmZzZXQpO1xufVxuZnVuY3Rpb24gaXNCbG9ja05vZGUoZG9tKSB7XG4gICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICByZXR1cm4gZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2s7XG59XG5mdW5jdGlvbiB0ZXh0Tm9kZUFmdGVyKG5vZGUsIG9mZnNldCkge1xuICAgIHdoaWxlIChub2RlICYmIG9mZnNldCA9PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICYmICFoYXNCbG9ja0Rlc2Mobm9kZSkpIHtcbiAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSkgKyAxO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT0gMSAmJiBuZXh0LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxufVxuZnVuY3Rpb24gdGV4dE5vZGVCZWZvcmUobm9kZSwgb2Zmc2V0KSB7XG4gICAgd2hpbGUgKG5vZGUgJiYgIW9mZnNldCAmJiAhaGFzQmxvY2tEZXNjKG5vZGUpKSB7XG4gICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAmJiBvZmZzZXQpIHtcbiAgICAgICAgbGV0IG5leHQgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT0gMSAmJiBuZXh0LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIG9mZnNldCA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0U2VsRm9jdXModmlldywgbm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMykge1xuICAgICAgICBsZXQgYmVmb3JlLCBhZnRlcjtcbiAgICAgICAgaWYgKGFmdGVyID0gdGV4dE5vZGVBZnRlcihub2RlLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICBub2RlID0gYWZ0ZXI7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJlZm9yZSA9IHRleHROb2RlQmVmb3JlKG5vZGUsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBiZWZvcmU7XG4gICAgICAgICAgICBvZmZzZXQgPSBiZWZvcmUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uQ29sbGFwc2VkKHNlbCkpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsLmV4dGVuZCkge1xuICAgICAgICBzZWwuZXh0ZW5kKG5vZGUsIG9mZnNldCk7XG4gICAgfVxuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXc7XG4gICAgLy8gSWYgbm8gc3RhdGUgdXBkYXRlIGVuZHMgdXAgaGFwcGVuaW5nLCByZXNldCB0aGUgc2VsZWN0aW9uLlxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodmlldy5zdGF0ZSA9PSBzdGF0ZSlcbiAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGZpbmREaXJlY3Rpb24odmlldywgcG9zKSB7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCEoY2hyb21lIHx8IHdpbmRvd3MpICYmICRwb3MucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MocG9zKTtcbiAgICAgICAgaWYgKHBvcyA+ICRwb3Muc3RhcnQoKSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHZpZXcuY29vcmRzQXRQb3MocG9zIC0gMSk7XG4gICAgICAgICAgICBsZXQgbWlkID0gKGJlZm9yZS50b3AgKyBiZWZvcmUuYm90dG9tKSAvIDI7XG4gICAgICAgICAgICBpZiAobWlkID4gY29vcmRzLnRvcCAmJiBtaWQgPCBjb29yZHMuYm90dG9tICYmIE1hdGguYWJzKGJlZm9yZS5sZWZ0IC0gY29vcmRzLmxlZnQpID4gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlLmxlZnQgPCBjb29yZHMubGVmdCA/IFwibHRyXCIgOiBcInJ0bFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPCAkcG9zLmVuZCgpKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSB2aWV3LmNvb3Jkc0F0UG9zKHBvcyArIDEpO1xuICAgICAgICAgICAgbGV0IG1pZCA9IChhZnRlci50b3AgKyBhZnRlci5ib3R0b20pIC8gMjtcbiAgICAgICAgICAgIGlmIChtaWQgPiBjb29yZHMudG9wICYmIG1pZCA8IGNvb3Jkcy5ib3R0b20gJiYgTWF0aC5hYnMoYWZ0ZXIubGVmdCAtIGNvb3Jkcy5sZWZ0KSA+IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyLmxlZnQgPiBjb29yZHMubGVmdCA/IFwibHRyXCIgOiBcInJ0bFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjb21wdXRlZCA9IGdldENvbXB1dGVkU3R5bGUodmlldy5kb20pLmRpcmVjdGlvbjtcbiAgICByZXR1cm4gY29tcHV0ZWQgPT0gXCJydGxcIiA/IFwicnRsXCIgOiBcImx0clwiO1xufVxuLy8gQ2hlY2sgd2hldGhlciB2ZXJ0aWNhbCBzZWxlY3Rpb24gbW90aW9uIHdvdWxkIGludm9sdmUgbm9kZVxuLy8gc2VsZWN0aW9ucy4gSWYgc28sIGFwcGx5IGl0IChpZiBub3QsIHRoZSByZXN1bHQgaXMgbGVmdCB0byB0aGVcbi8vIGJyb3dzZXIpXG5mdW5jdGlvbiBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIGRpciwgbW9kcykge1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiAmJiAhc2VsLmVtcHR5IHx8IG1vZHMuaW5kZXhPZihcInNcIikgPiAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChtYWMgJiYgbW9kcy5pbmRleE9mKFwibVwiKSA+IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgJGZyb20sICR0byB9ID0gc2VsO1xuICAgIGlmICghJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgfHwgdmlldy5lbmRPZlRleHRibG9jayhkaXIgPCAwID8gXCJ1cFwiIDogXCJkb3duXCIpKSB7XG4gICAgICAgIGxldCBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgICAgIGlmIChuZXh0ICYmIChuZXh0IGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV4dCk7XG4gICAgfVxuICAgIGlmICghJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHNpZGUgPSBkaXIgPCAwID8gJGZyb20gOiAkdG87XG4gICAgICAgIGxldCBiZXlvbmQgPSBzZWwgaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24gPyBTZWxlY3Rpb24ubmVhcihzaWRlLCBkaXIpIDogU2VsZWN0aW9uLmZpbmRGcm9tKHNpZGUsIGRpcik7XG4gICAgICAgIHJldHVybiBiZXlvbmQgPyBhcHBseSh2aWV3LCBiZXlvbmQpIDogZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlKHZpZXcsIGRpcikge1xuICAgIGlmICghKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yLCBlbXB0eSB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyID4gMCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IG5leHROb2RlID0gISRoZWFkLnRleHRPZmZzZXQgJiYgKGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyKTtcbiAgICBpZiAobmV4dE5vZGUgJiYgIW5leHROb2RlLmlzVGV4dCkge1xuICAgICAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyO1xuICAgICAgICBpZiAoZGlyIDwgMClcbiAgICAgICAgICAgIHRyLmRlbGV0ZSgkaGVhZC5wb3MgLSBuZXh0Tm9kZS5ub2RlU2l6ZSwgJGhlYWQucG9zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHIuZGVsZXRlKCRoZWFkLnBvcywgJGhlYWQucG9zICsgbmV4dE5vZGUubm9kZVNpemUpO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHN3aXRjaEVkaXRhYmxlKHZpZXcsIG5vZGUsIHN0YXRlKSB7XG4gICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgbm9kZS5jb250ZW50RWRpdGFibGUgPSBzdGF0ZTtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG59XG4vLyBJc3N1ZSAjODY3IC8gIzEwOTAgLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05MDM4MjFcbi8vIEluIHdoaWNoIFNhZmFyaSAoYW5kIGF0IHNvbWUgcG9pbnQgaW4gdGhlIHBhc3QsIENocm9tZSkgZG9lcyByZWFsbHlcbi8vIHdyb25nIHRoaW5ncyB3aGVuIHRoZSBkb3duIGFycm93IGlzIHByZXNzZWQgd2hlbiB0aGUgY3Vyc29yIGlzXG4vLyBkaXJlY3RseSBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2sgYW5kIGhhcyBhbiB1bmVkaXRhYmxlIG5vZGVcbi8vIGFmdGVyIGl0XG5mdW5jdGlvbiBzYWZhcmlEb3duQXJyb3dCdWcodmlldykge1xuICAgIGlmICghc2FmYXJpIHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRoZWFkLnBhcmVudE9mZnNldCA+IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgaWYgKGZvY3VzTm9kZSAmJiBmb2N1c05vZGUubm9kZVR5cGUgPT0gMSAmJiBmb2N1c09mZnNldCA9PSAwICYmXG4gICAgICAgIGZvY3VzTm9kZS5maXJzdENoaWxkICYmIGZvY3VzTm9kZS5maXJzdENoaWxkLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gZm9jdXNOb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHN3aXRjaEVkaXRhYmxlKHZpZXcsIGNoaWxkLCBcInRydWVcIik7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc3dpdGNoRWRpdGFibGUodmlldywgY2hpbGQsIFwiZmFsc2VcIiksIDIwKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQSBiYWNrZHJvcCBrZXkgbWFwcGluZyB1c2VkIHRvIG1ha2Ugc3VyZSB3ZSBhbHdheXMgc3VwcHJlc3Mga2V5c1xuLy8gdGhhdCBoYXZlIGEgZGFuZ2Vyb3VzIGRlZmF1bHQgZWZmZWN0LCBldmVuIGlmIHRoZSBjb21tYW5kcyB0aGV5IGFyZVxuLy8gYm91bmQgdG8gcmV0dXJuIGZhbHNlLCBhbmQgdG8gbWFrZSBzdXJlIHRoYXQgY3Vyc29yLW1vdGlvbiBrZXlzXG4vLyBmaW5kIGEgY3Vyc29yIChhcyBvcHBvc2VkIHRvIGEgbm9kZSBzZWxlY3Rpb24pIHdoZW4gcHJlc3NlZC4gRm9yXG4vLyBjdXJzb3ItbW90aW9uIGtleXMsIHRoZSBjb2RlIGluIHRoZSBoYW5kbGVycyBhbHNvIHRha2VzIGNhcmUgb2Zcbi8vIGJsb2NrIHNlbGVjdGlvbnMuXG5mdW5jdGlvbiBnZXRNb2RzKGV2ZW50KSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcImNcIjtcbiAgICBpZiAoZXZlbnQubWV0YUtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwibVwiO1xuICAgIGlmIChldmVudC5hbHRLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcImFcIjtcbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcInNcIjtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2FwdHVyZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgY29kZSA9IGV2ZW50LmtleUNvZGUsIG1vZHMgPSBnZXRNb2RzKGV2ZW50KTtcbiAgICBpZiAoY29kZSA9PSA4IHx8IChtYWMgJiYgY29kZSA9PSA3MiAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBCYWNrc3BhY2UsIEN0cmwtaCBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlKHZpZXcsIC0xKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIC0xKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGNvZGUgPT0gNDYgJiYgIWV2ZW50LnNoaWZ0S2V5KSB8fCAobWFjICYmIGNvZGUgPT0gNjggJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gRGVsZXRlLCBDdHJsLWQgb24gTWFjXG4gICAgICAgIHJldHVybiBzdG9wTmF0aXZlSG9yaXpvbnRhbERlbGV0ZSh2aWV3LCAxKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIDEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDEzIHx8IGNvZGUgPT0gMjcpIHsgLy8gRW50ZXIsIEVzY1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAzNyB8fCAobWFjICYmIGNvZGUgPT0gNjYgJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gTGVmdCBhcnJvdywgQ3RybC1iIG9uIE1hY1xuICAgICAgICBsZXQgZGlyID0gY29kZSA9PSAzNyA/IChmaW5kRGlyZWN0aW9uKHZpZXcsIHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20pID09IFwibHRyXCIgPyAtMSA6IDEpIDogLTE7XG4gICAgICAgIHJldHVybiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIGRpcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMzkgfHwgKG1hYyAmJiBjb2RlID09IDcwICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIFJpZ2h0IGFycm93LCBDdHJsLWYgb24gTWFjXG4gICAgICAgIGxldCBkaXIgPSBjb2RlID09IDM5ID8gKGZpbmREaXJlY3Rpb24odmlldywgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSkgPT0gXCJsdHJcIiA/IDEgOiAtMSkgOiAxO1xuICAgICAgICByZXR1cm4gc2VsZWN0SG9yaXpvbnRhbGx5KHZpZXcsIGRpciwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCBkaXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDM4IHx8IChtYWMgJiYgY29kZSA9PSA4MCAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBVcCBhcnJvdywgQ3RybC1wIG9uIE1hY1xuICAgICAgICByZXR1cm4gc2VsZWN0VmVydGljYWxseSh2aWV3LCAtMSwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCAtMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gNDAgfHwgKG1hYyAmJiBjb2RlID09IDc4ICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIERvd24gYXJyb3csIEN0cmwtbiBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHNhZmFyaURvd25BcnJvd0J1Zyh2aWV3KSB8fCBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIDEsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1vZHMgPT0gKG1hYyA/IFwibVwiIDogXCJjXCIpICYmXG4gICAgICAgIChjb2RlID09IDY2IHx8IGNvZGUgPT0gNzMgfHwgY29kZSA9PSA4OSB8fCBjb2RlID09IDkwKSkgeyAvLyBNb2QtW2JpeXpdXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBzbGljZSkge1xuICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1Db3BpZWRcIiwgZiA9PiB7IHNsaWNlID0gZihzbGljZSwgdmlldyk7IH0pO1xuICAgIGxldCBjb250ZXh0ID0gW10sIHsgY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSBzbGljZTtcbiAgICB3aGlsZSAob3BlblN0YXJ0ID4gMSAmJiBvcGVuRW5kID4gMSAmJiBjb250ZW50LmNoaWxkQ291bnQgPT0gMSAmJiBjb250ZW50LmZpcnN0Q2hpbGQuY2hpbGRDb3VudCA9PSAxKSB7XG4gICAgICAgIG9wZW5TdGFydC0tO1xuICAgICAgICBvcGVuRW5kLS07XG4gICAgICAgIGxldCBub2RlID0gY29udGVudC5maXJzdENoaWxkO1xuICAgICAgICBjb250ZXh0LnB1c2gobm9kZS50eXBlLm5hbWUsIG5vZGUuYXR0cnMgIT0gbm9kZS50eXBlLmRlZmF1bHRBdHRycyA/IG5vZGUuYXR0cnMgOiBudWxsKTtcbiAgICAgICAgY29udGVudCA9IG5vZGUuY29udGVudDtcbiAgICB9XG4gICAgbGV0IHNlcmlhbGl6ZXIgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkU2VyaWFsaXplclwiKSB8fCBET01TZXJpYWxpemVyLmZyb21TY2hlbWEodmlldy5zdGF0ZS5zY2hlbWEpO1xuICAgIGxldCBkb2MgPSBkZXRhY2hlZERvYygpLCB3cmFwID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgd3JhcC5hcHBlbmRDaGlsZChzZXJpYWxpemVyLnNlcmlhbGl6ZUZyYWdtZW50KGNvbnRlbnQsIHsgZG9jdW1lbnQ6IGRvYyB9KSk7XG4gICAgbGV0IGZpcnN0Q2hpbGQgPSB3cmFwLmZpcnN0Q2hpbGQsIG5lZWRzV3JhcCwgd3JhcHBlcnMgPSAwO1xuICAgIHdoaWxlIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMSAmJiAobmVlZHNXcmFwID0gd3JhcE1hcFtmaXJzdENoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gbmVlZHNXcmFwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgd3JhcHBlciA9IGRvYy5jcmVhdGVFbGVtZW50KG5lZWRzV3JhcFtpXSk7XG4gICAgICAgICAgICB3aGlsZSAod3JhcC5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQod3JhcC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICAgICAgICB3cmFwcGVycysrO1xuICAgICAgICB9XG4gICAgICAgIGZpcnN0Q2hpbGQgPSB3cmFwLmZpcnN0Q2hpbGQ7XG4gICAgfVxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBtLXNsaWNlXCIsIGAke29wZW5TdGFydH0gJHtvcGVuRW5kfSR7d3JhcHBlcnMgPyBgIC0ke3dyYXBwZXJzfWAgOiBcIlwifSAke0pTT04uc3RyaW5naWZ5KGNvbnRleHQpfWApO1xuICAgIGxldCB0ZXh0ID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFRleHRTZXJpYWxpemVyXCIsIGYgPT4gZihzbGljZSwgdmlldykpIHx8XG4gICAgICAgIHNsaWNlLmNvbnRlbnQudGV4dEJldHdlZW4oMCwgc2xpY2UuY29udGVudC5zaXplLCBcIlxcblxcblwiKTtcbiAgICByZXR1cm4geyBkb206IHdyYXAsIHRleHQgfTtcbn1cbi8vIFJlYWQgYSBzbGljZSBvZiBjb250ZW50IGZyb20gdGhlIGNsaXBib2FyZCAob3IgZHJvcCBkYXRhKS5cbmZ1bmN0aW9uIHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCB0ZXh0LCBodG1sLCBwbGFpblRleHQsICRjb250ZXh0KSB7XG4gICAgbGV0IGluQ29kZSA9ICRjb250ZXh0LnBhcmVudC50eXBlLnNwZWMuY29kZTtcbiAgICBsZXQgZG9tLCBzbGljZTtcbiAgICBpZiAoIWh0bWwgJiYgIXRleHQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBhc1RleHQgPSB0ZXh0ICYmIChwbGFpblRleHQgfHwgaW5Db2RlIHx8ICFodG1sKTtcbiAgICBpZiAoYXNUZXh0KSB7XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRUZXh0XCIsIGYgPT4geyB0ZXh0ID0gZih0ZXh0LCBpbkNvZGUgfHwgcGxhaW5UZXh0LCB2aWV3KTsgfSk7XG4gICAgICAgIGlmIChpbkNvZGUpXG4gICAgICAgICAgICByZXR1cm4gdGV4dCA/IG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHZpZXcuc3RhdGUuc2NoZW1hLnRleHQodGV4dC5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpKSksIDAsIDApIDogU2xpY2UuZW1wdHk7XG4gICAgICAgIGxldCBwYXJzZWQgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkVGV4dFBhcnNlclwiLCBmID0+IGYodGV4dCwgJGNvbnRleHQsIHBsYWluVGV4dCwgdmlldykpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICBzbGljZSA9IHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9ICRjb250ZXh0Lm1hcmtzKCk7XG4gICAgICAgICAgICBsZXQgeyBzY2hlbWEgfSA9IHZpZXcuc3RhdGUsIHNlcmlhbGl6ZXIgPSBET01TZXJpYWxpemVyLmZyb21TY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgICAgIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0ZXh0LnNwbGl0KC8oPzpcXHJcXG4/fFxcbikrLykuZm9yRWFjaChibG9jayA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHAgPSBkb20uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIikpO1xuICAgICAgICAgICAgICAgIGlmIChibG9jaylcbiAgICAgICAgICAgICAgICAgICAgcC5hcHBlbmRDaGlsZChzZXJpYWxpemVyLnNlcmlhbGl6ZU5vZGUoc2NoZW1hLnRleHQoYmxvY2ssIG1hcmtzKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRIVE1MXCIsIGYgPT4geyBodG1sID0gZihodG1sLCB2aWV3KTsgfSk7XG4gICAgICAgIGRvbSA9IHJlYWRIVE1MKGh0bWwpO1xuICAgICAgICBpZiAod2Via2l0KVxuICAgICAgICAgICAgcmVzdG9yZVJlcGxhY2VkU3BhY2VzKGRvbSk7XG4gICAgfVxuICAgIGxldCBjb250ZXh0Tm9kZSA9IGRvbSAmJiBkb20ucXVlcnlTZWxlY3RvcihcIltkYXRhLXBtLXNsaWNlXVwiKTtcbiAgICBsZXQgc2xpY2VEYXRhID0gY29udGV4dE5vZGUgJiYgL14oXFxkKykgKFxcZCspKD86IC0oXFxkKykpPyAoLiopLy5leGVjKGNvbnRleHROb2RlLmdldEF0dHJpYnV0ZShcImRhdGEtcG0tc2xpY2VcIikgfHwgXCJcIik7XG4gICAgaWYgKHNsaWNlRGF0YSAmJiBzbGljZURhdGFbM10pXG4gICAgICAgIGZvciAobGV0IGkgPSArc2xpY2VEYXRhWzNdOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBkb20uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZCAmJiBjaGlsZC5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZG9tID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICBpZiAoIXNsaWNlKSB7XG4gICAgICAgIGxldCBwYXJzZXIgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkUGFyc2VyXCIpIHx8IHZpZXcuc29tZVByb3AoXCJkb21QYXJzZXJcIikgfHwgRE9NUGFyc2VyLmZyb21TY2hlbWEodmlldy5zdGF0ZS5zY2hlbWEpO1xuICAgICAgICBzbGljZSA9IHBhcnNlci5wYXJzZVNsaWNlKGRvbSwge1xuICAgICAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAhIShhc1RleHQgfHwgc2xpY2VEYXRhKSxcbiAgICAgICAgICAgIGNvbnRleHQ6ICRjb250ZXh0LFxuICAgICAgICAgICAgcnVsZUZyb21Ob2RlKGRvbSkge1xuICAgICAgICAgICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmICFkb20ubmV4dFNpYmxpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgZG9tLnBhcmVudE5vZGUgJiYgIWlubGluZVBhcmVudHMudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNsaWNlRGF0YSkge1xuICAgICAgICBzbGljZSA9IGFkZENvbnRleHQoY2xvc2VTbGljZShzbGljZSwgK3NsaWNlRGF0YVsxXSwgK3NsaWNlRGF0YVsyXSksIHNsaWNlRGF0YVs0XSk7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBIVE1MIHdhc24ndCBjcmVhdGVkIGJ5IFByb3NlTWlycm9yLiBNYWtlIHN1cmUgdG9wLWxldmVsIHNpYmxpbmdzIGFyZSBjb2hlcmVudFxuICAgICAgICBzbGljZSA9IFNsaWNlLm1heE9wZW4obm9ybWFsaXplU2libGluZ3Moc2xpY2UuY29udGVudCwgJGNvbnRleHQpLCB0cnVlKTtcbiAgICAgICAgaWYgKHNsaWNlLm9wZW5TdGFydCB8fCBzbGljZS5vcGVuRW5kKSB7XG4gICAgICAgICAgICBsZXQgb3BlblN0YXJ0ID0gMCwgb3BlbkVuZCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBub2RlID0gc2xpY2UuY29udGVudC5maXJzdENoaWxkOyBvcGVuU3RhcnQgPCBzbGljZS5vcGVuU3RhcnQgJiYgIW5vZGUudHlwZS5zcGVjLmlzb2xhdGluZzsgb3BlblN0YXJ0KyssIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQpIHsgfVxuICAgICAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNsaWNlLmNvbnRlbnQubGFzdENoaWxkOyBvcGVuRW5kIDwgc2xpY2Uub3BlbkVuZCAmJiAhbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nOyBvcGVuRW5kKyssIG5vZGUgPSBub2RlLmxhc3RDaGlsZCkgeyB9XG4gICAgICAgICAgICBzbGljZSA9IGNsb3NlU2xpY2Uoc2xpY2UsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFwiLCBmID0+IHsgc2xpY2UgPSBmKHNsaWNlLCB2aWV3KTsgfSk7XG4gICAgcmV0dXJuIHNsaWNlO1xufVxuY29uc3QgaW5saW5lUGFyZW50cyA9IC9eKGF8YWJicnxhY3JvbnltfGJ8Y2l0ZXxjb2RlfGRlbHxlbXxpfGluc3xrYmR8bGFiZWx8b3V0cHV0fHF8cnVieXxzfHNhbXB8c3BhbnxzdHJvbmd8c3VifHN1cHx0aW1lfHV8dHR8dmFyKSQvaTtcbi8vIFRha2VzIGEgc2xpY2UgcGFyc2VkIHdpdGggcGFyc2VTbGljZSwgd2hpY2ggbWVhbnMgdGhlcmUgaGFzbid0IGJlZW5cbi8vIGFueSBjb250ZW50LWV4cHJlc3Npb24gY2hlY2tpbmcgZG9uZSBvbiB0aGUgdG9wIG5vZGVzLCB0cmllcyB0b1xuLy8gZmluZCBhIHBhcmVudCBub2RlIGluIHRoZSBjdXJyZW50IGNvbnRleHQgdGhhdCBtaWdodCBmaXQgdGhlIG5vZGVzLFxuLy8gYW5kIGlmIHN1Y2Nlc3NmdWwsIHJlYnVpbGRzIHRoZSBzbGljZSBzbyB0aGF0IGl0IGZpdHMgaW50byB0aGF0IHBhcmVudC5cbi8vXG4vLyBUaGlzIGFkZHJlc3NlcyB0aGUgcHJvYmxlbSB0aGF0IFRyYW5zZm9ybS5yZXBsYWNlIGV4cGVjdHMgYVxuLy8gY29oZXJlbnQgc2xpY2UsIGFuZCB3aWxsIGZhaWwgdG8gcGxhY2UgYSBzZXQgb2Ygc2libGluZ3MgdGhhdCBkb24ndFxuLy8gZml0IGFueXdoZXJlIGluIHRoZSBzY2hlbWEuXG5mdW5jdGlvbiBub3JtYWxpemVTaWJsaW5ncyhmcmFnbWVudCwgJGNvbnRleHQpIHtcbiAgICBpZiAoZnJhZ21lbnQuY2hpbGRDb3VudCA8IDIpXG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICBmb3IgKGxldCBkID0gJGNvbnRleHQuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSAkY29udGV4dC5ub2RlKGQpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJlbnQuY29udGVudE1hdGNoQXQoJGNvbnRleHQuaW5kZXgoZCkpO1xuICAgICAgICBsZXQgbGFzdFdyYXAsIHJlc3VsdCA9IFtdO1xuICAgICAgICBmcmFnbWVudC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHdyYXAgPSBtYXRjaC5maW5kV3JhcHBpbmcobm9kZS50eXBlKSwgaW5MYXN0O1xuICAgICAgICAgICAgaWYgKCF3cmFwKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGluTGFzdCA9IHJlc3VsdC5sZW5ndGggJiYgbGFzdFdyYXAubGVuZ3RoICYmIGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gaW5MYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBjbG9zZVJpZ2h0KHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0sIGxhc3RXcmFwLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGV0IHdyYXBwZWQgPSB3aXRoV3JhcHBlcnMobm9kZSwgd3JhcCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2god3JhcHBlZCk7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaC5tYXRjaFR5cGUod3JhcHBlZC50eXBlKTtcbiAgICAgICAgICAgICAgICBsYXN0V3JhcCA9IHdyYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb20ocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gd2l0aFdyYXBwZXJzKG5vZGUsIHdyYXAsIGZyb20gPSAwKSB7XG4gICAgZm9yIChsZXQgaSA9IHdyYXAubGVuZ3RoIC0gMTsgaSA+PSBmcm9tOyBpLS0pXG4gICAgICAgIG5vZGUgPSB3cmFwW2ldLmNyZWF0ZShudWxsLCBGcmFnbWVudC5mcm9tKG5vZGUpKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cbi8vIFVzZWQgdG8gZ3JvdXAgYWRqYWNlbnQgbm9kZXMgd3JhcHBlZCBpbiBzaW1pbGFyIHBhcmVudHMgYnlcbi8vIG5vcm1hbGl6ZVNpYmxpbmdzIGludG8gdGhlIHNhbWUgcGFyZW50IG5vZGVcbmZ1bmN0aW9uIGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgc2libGluZywgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPCB3cmFwLmxlbmd0aCAmJiBkZXB0aCA8IGxhc3RXcmFwLmxlbmd0aCAmJiB3cmFwW2RlcHRoXSA9PSBsYXN0V3JhcFtkZXB0aF0pIHtcbiAgICAgICAgbGV0IGlubmVyID0gYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCBzaWJsaW5nLmxhc3RDaGlsZCwgZGVwdGggKyAxKTtcbiAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmcuY29weShzaWJsaW5nLmNvbnRlbnQucmVwbGFjZUNoaWxkKHNpYmxpbmcuY2hpbGRDb3VudCAtIDEsIGlubmVyKSk7XG4gICAgICAgIGxldCBtYXRjaCA9IHNpYmxpbmcuY29udGVudE1hdGNoQXQoc2libGluZy5jaGlsZENvdW50KTtcbiAgICAgICAgaWYgKG1hdGNoLm1hdGNoVHlwZShkZXB0aCA9PSB3cmFwLmxlbmd0aCAtIDEgPyBub2RlLnR5cGUgOiB3cmFwW2RlcHRoICsgMV0pKVxuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmcuY29weShzaWJsaW5nLmNvbnRlbnQuYXBwZW5kKEZyYWdtZW50LmZyb20od2l0aFdyYXBwZXJzKG5vZGUsIHdyYXAsIGRlcHRoICsgMSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xvc2VSaWdodChub2RlLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICBsZXQgZnJhZ21lbnQgPSBub2RlLmNvbnRlbnQucmVwbGFjZUNoaWxkKG5vZGUuY2hpbGRDb3VudCAtIDEsIGNsb3NlUmlnaHQobm9kZS5sYXN0Q2hpbGQsIGRlcHRoIC0gMSkpO1xuICAgIGxldCBmaWxsID0gbm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgIHJldHVybiBub2RlLmNvcHkoZnJhZ21lbnQuYXBwZW5kKGZpbGwpKTtcbn1cbmZ1bmN0aW9uIGNsb3NlUmFuZ2UoZnJhZ21lbnQsIHNpZGUsIGZyb20sIHRvLCBkZXB0aCwgb3BlbkVuZCkge1xuICAgIGxldCBub2RlID0gc2lkZSA8IDAgPyBmcmFnbWVudC5maXJzdENoaWxkIDogZnJhZ21lbnQubGFzdENoaWxkLCBpbm5lciA9IG5vZGUuY29udGVudDtcbiAgICBpZiAoZnJhZ21lbnQuY2hpbGRDb3VudCA+IDEpXG4gICAgICAgIG9wZW5FbmQgPSAwO1xuICAgIGlmIChkZXB0aCA8IHRvIC0gMSlcbiAgICAgICAgaW5uZXIgPSBjbG9zZVJhbmdlKGlubmVyLCBzaWRlLCBmcm9tLCB0bywgZGVwdGggKyAxLCBvcGVuRW5kKTtcbiAgICBpZiAoZGVwdGggPj0gZnJvbSlcbiAgICAgICAgaW5uZXIgPSBzaWRlIDwgMCA/IG5vZGUuY29udGVudE1hdGNoQXQoMCkuZmlsbEJlZm9yZShpbm5lciwgb3BlbkVuZCA8PSBkZXB0aCkuYXBwZW5kKGlubmVyKVxuICAgICAgICAgICAgOiBpbm5lci5hcHBlbmQobm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZUNoaWxkKHNpZGUgPCAwID8gMCA6IGZyYWdtZW50LmNoaWxkQ291bnQgLSAxLCBub2RlLmNvcHkoaW5uZXIpKTtcbn1cbmZ1bmN0aW9uIGNsb3NlU2xpY2Uoc2xpY2UsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGlmIChvcGVuU3RhcnQgPCBzbGljZS5vcGVuU3RhcnQpXG4gICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKGNsb3NlUmFuZ2Uoc2xpY2UuY29udGVudCwgLTEsIG9wZW5TdGFydCwgc2xpY2Uub3BlblN0YXJ0LCAwLCBzbGljZS5vcGVuRW5kKSwgb3BlblN0YXJ0LCBzbGljZS5vcGVuRW5kKTtcbiAgICBpZiAob3BlbkVuZCA8IHNsaWNlLm9wZW5FbmQpXG4gICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKGNsb3NlUmFuZ2Uoc2xpY2UuY29udGVudCwgMSwgb3BlbkVuZCwgc2xpY2Uub3BlbkVuZCwgMCwgMCksIHNsaWNlLm9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgcmV0dXJuIHNsaWNlO1xufVxuLy8gVHJpY2sgZnJvbSBqUXVlcnkgLS0gc29tZSBlbGVtZW50cyBtdXN0IGJlIHdyYXBwZWQgaW4gb3RoZXJcbi8vIGVsZW1lbnRzIGZvciBpbm5lckhUTUwgdG8gd29yay4gSS5lLiBpZiB5b3UgZG8gYGRpdi5pbm5lckhUTUwgPVxuLy8gXCI8dGQ+Li48L3RkPlwiYCB0aGUgdGFibGUgY2VsbHMgYXJlIGlnbm9yZWQuXG5jb25zdCB3cmFwTWFwID0ge1xuICAgIHRoZWFkOiBbXCJ0YWJsZVwiXSxcbiAgICB0Ym9keTogW1widGFibGVcIl0sXG4gICAgdGZvb3Q6IFtcInRhYmxlXCJdLFxuICAgIGNhcHRpb246IFtcInRhYmxlXCJdLFxuICAgIGNvbGdyb3VwOiBbXCJ0YWJsZVwiXSxcbiAgICBjb2w6IFtcInRhYmxlXCIsIFwiY29sZ3JvdXBcIl0sXG4gICAgdHI6IFtcInRhYmxlXCIsIFwidGJvZHlcIl0sXG4gICAgdGQ6IFtcInRhYmxlXCIsIFwidGJvZHlcIiwgXCJ0clwiXSxcbiAgICB0aDogW1widGFibGVcIiwgXCJ0Ym9keVwiLCBcInRyXCJdXG59O1xubGV0IF9kZXRhY2hlZERvYyA9IG51bGw7XG5mdW5jdGlvbiBkZXRhY2hlZERvYygpIHtcbiAgICByZXR1cm4gX2RldGFjaGVkRG9jIHx8IChfZGV0YWNoZWREb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJ0aXRsZVwiKSk7XG59XG5mdW5jdGlvbiByZWFkSFRNTChodG1sKSB7XG4gICAgbGV0IG1ldGFzID0gL14oXFxzKjxtZXRhIFtePl0qPikqLy5leGVjKGh0bWwpO1xuICAgIGlmIChtZXRhcylcbiAgICAgICAgaHRtbCA9IGh0bWwuc2xpY2UobWV0YXNbMF0ubGVuZ3RoKTtcbiAgICBsZXQgZWx0ID0gZGV0YWNoZWREb2MoKS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGxldCBmaXJzdFRhZyA9IC88KFthLXpdW14+XFxzXSspL2kuZXhlYyhodG1sKSwgd3JhcDtcbiAgICBpZiAod3JhcCA9IGZpcnN0VGFnICYmIHdyYXBNYXBbZmlyc3RUYWdbMV0udG9Mb3dlckNhc2UoKV0pXG4gICAgICAgIGh0bWwgPSB3cmFwLm1hcChuID0+IFwiPFwiICsgbiArIFwiPlwiKS5qb2luKFwiXCIpICsgaHRtbCArIHdyYXAubWFwKG4gPT4gXCI8L1wiICsgbiArIFwiPlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICBlbHQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICBpZiAod3JhcClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cmFwLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZWx0ID0gZWx0LnF1ZXJ5U2VsZWN0b3Iod3JhcFtpXSkgfHwgZWx0O1xuICAgIHJldHVybiBlbHQ7XG59XG4vLyBXZWJraXQgYnJvd3NlcnMgZG8gc29tZSBoYXJkLXRvLXByZWRpY3QgcmVwbGFjZW1lbnQgb2YgcmVndWxhclxuLy8gc3BhY2VzIHdpdGggbm9uLWJyZWFraW5nIHNwYWNlcyB3aGVuIHB1dHRpbmcgY29udGVudCBvbiB0aGVcbi8vIGNsaXBib2FyZC4gVGhpcyB0cmllcyB0byBjb252ZXJ0IHN1Y2ggbm9uLWJyZWFraW5nIHNwYWNlcyAod2hpY2hcbi8vIHdpbGwgYmUgd3JhcHBlZCBpbiBhIHBsYWluIHNwYW4gb24gQ2hyb21lLCBhIHNwYW4gd2l0aCBjbGFzc1xuLy8gQXBwbGUtY29udmVydGVkLXNwYWNlIG9uIFNhZmFyaSkgYmFjayB0byByZWd1bGFyIHNwYWNlcy5cbmZ1bmN0aW9uIHJlc3RvcmVSZXBsYWNlZFNwYWNlcyhkb20pIHtcbiAgICBsZXQgbm9kZXMgPSBkb20ucXVlcnlTZWxlY3RvckFsbChjaHJvbWUgPyBcInNwYW46bm90KFtjbGFzc10pOm5vdChbc3R5bGVdKVwiIDogXCJzcGFuLkFwcGxlLWNvbnZlcnRlZC1zcGFjZVwiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09IDEgJiYgbm9kZS50ZXh0Q29udGVudCA9PSBcIlxcdTAwYTBcIiAmJiBub2RlLnBhcmVudE5vZGUpXG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGRvbS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiIFwiKSwgbm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkQ29udGV4dChzbGljZSwgY29udGV4dCkge1xuICAgIGlmICghc2xpY2Uuc2l6ZSlcbiAgICAgICAgcmV0dXJuIHNsaWNlO1xuICAgIGxldCBzY2hlbWEgPSBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQudHlwZS5zY2hlbWEsIGFycmF5O1xuICAgIHRyeSB7XG4gICAgICAgIGFycmF5ID0gSlNPTi5wYXJzZShjb250ZXh0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlO1xuICAgIH1cbiAgICBsZXQgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHNsaWNlO1xuICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICBsZXQgdHlwZSA9IHNjaGVtYS5ub2Rlc1thcnJheVtpXV07XG4gICAgICAgIGlmICghdHlwZSB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZShhcnJheVtpICsgMV0sIGNvbnRlbnQpKTtcbiAgICAgICAgb3BlblN0YXJ0Kys7XG4gICAgICAgIG9wZW5FbmQrKztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTbGljZShjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xufVxuXG4vLyBBIGNvbGxlY3Rpb24gb2YgRE9NIGV2ZW50cyB0aGF0IG9jY3VyIHdpdGhpbiB0aGUgZWRpdG9yLCBhbmQgY2FsbGJhY2sgZnVuY3Rpb25zXG4vLyB0byBpbnZva2Ugd2hlbiB0aGUgZXZlbnQgZmlyZXMuXG5jb25zdCBoYW5kbGVycyA9IHt9O1xuY29uc3QgZWRpdEhhbmRsZXJzID0ge307XG5jb25zdCBwYXNzaXZlSGFuZGxlcnMgPSB7IHRvdWNoc3RhcnQ6IHRydWUsIHRvdWNobW92ZTogdHJ1ZSB9O1xuY2xhc3MgSW5wdXRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2hpZnRLZXkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZVRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDbGljayA9IHsgdGltZTogMCwgeDogMCwgeTogMCwgdHlwZTogXCJcIiB9O1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25PcmlnaW4gPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICB0aGlzLmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RGb2N1cyA9IDA7XG4gICAgICAgIHRoaXMubGFzdFRvdWNoID0gMDtcbiAgICAgICAgdGhpcy5sYXN0QW5kcm9pZERlbGV0ZSA9IDA7XG4gICAgICAgIHRoaXMuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcG9zaW5nVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPSAtMmU4O1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uSUQgPSAxO1xuICAgICAgICAvLyBTZXQgdG8gYSBjb21wb3NpdGlvbiBJRCB3aGVuIHRoZXJlIGFyZSBwZW5kaW5nIGNoYW5nZXMgYXQgY29tcG9zaXRpb25lbmRcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzID0gMDtcbiAgICAgICAgdGhpcy5kb21DaGFuZ2VDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuaGlkZVNlbGVjdGlvbkd1YXJkID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBpbml0SW5wdXQodmlldykge1xuICAgIGZvciAobGV0IGV2ZW50IGluIGhhbmRsZXJzKSB7XG4gICAgICAgIGxldCBoYW5kbGVyID0gaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbZXZlbnRdID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnRCZWxvbmdzVG9WaWV3KHZpZXcsIGV2ZW50KSAmJiAhcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkgJiZcbiAgICAgICAgICAgICAgICAodmlldy5lZGl0YWJsZSB8fCAhKGV2ZW50LnR5cGUgaW4gZWRpdEhhbmRsZXJzKSkpXG4gICAgICAgICAgICAgICAgaGFuZGxlcih2aWV3LCBldmVudCk7XG4gICAgICAgIH0sIHBhc3NpdmVIYW5kbGVyc1tldmVudF0gPyB7IHBhc3NpdmU6IHRydWUgfSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8vIE9uIFNhZmFyaSwgZm9yIHJlYXNvbnMgYmV5b25kIG15IHVuZGVyc3RhbmRpbmcsIGFkZGluZyBhbiBpbnB1dFxuICAgIC8vIGV2ZW50IGhhbmRsZXIgbWFrZXMgYW4gaXNzdWUgd2hlcmUgdGhlIGNvbXBvc2l0aW9uIHZhbmlzaGVzIHdoZW5cbiAgICAvLyB5b3UgcHJlc3MgZW50ZXIgZ28gYXdheS5cbiAgICBpZiAoc2FmYXJpKVxuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKCkgPT4gbnVsbCk7XG4gICAgZW5zdXJlTGlzdGVuZXJzKHZpZXcpO1xufVxuZnVuY3Rpb24gc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIG9yaWdpbikge1xuICAgIHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG9yaWdpbjtcbiAgICB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25UaW1lID0gRGF0ZS5ub3coKTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lJbnB1dCh2aWV3KSB7XG4gICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgZm9yIChsZXQgdHlwZSBpbiB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnMpXG4gICAgICAgIHZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzW3R5cGVdKTtcbiAgICBjbGVhclRpbWVvdXQodmlldy5pbnB1dC5jb21wb3NpbmdUaW1lb3V0KTtcbiAgICBjbGVhclRpbWVvdXQodmlldy5pbnB1dC5sYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQpO1xufVxuZnVuY3Rpb24gZW5zdXJlTGlzdGVuZXJzKHZpZXcpIHtcbiAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRE9NRXZlbnRzXCIsIGN1cnJlbnRIYW5kbGVycyA9PiB7XG4gICAgICAgIGZvciAobGV0IHR5cGUgaW4gY3VycmVudEhhbmRsZXJzKVxuICAgICAgICAgICAgaWYgKCF2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbdHlwZV0pXG4gICAgICAgICAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbdHlwZV0gPSBldmVudCA9PiBydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSB7XG4gICAgcmV0dXJuIHZpZXcuc29tZVByb3AoXCJoYW5kbGVET01FdmVudHNcIiwgaGFuZGxlcnMgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlciA9IGhhbmRsZXJzW2V2ZW50LnR5cGVdO1xuICAgICAgICByZXR1cm4gaGFuZGxlciA/IGhhbmRsZXIodmlldywgZXZlbnQpIHx8IGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBmYWxzZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGV2ZW50QmVsb25nc1RvVmlldyh2aWV3LCBldmVudCkge1xuICAgIGlmICghZXZlbnQuYnViYmxlcylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBub2RlID0gZXZlbnQudGFyZ2V0OyBub2RlICE9IHZpZXcuZG9tOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKVxuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSB8fFxuICAgICAgICAgICAgKG5vZGUucG1WaWV3RGVzYyAmJiBub2RlLnBtVmlld0Rlc2Muc3RvcEV2ZW50KGV2ZW50KSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCFydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSAmJiBoYW5kbGVyc1tldmVudC50eXBlXSAmJlxuICAgICAgICAodmlldy5lZGl0YWJsZSB8fCAhKGV2ZW50LnR5cGUgaW4gZWRpdEhhbmRsZXJzKSkpXG4gICAgICAgIGhhbmRsZXJzW2V2ZW50LnR5cGVdKHZpZXcsIGV2ZW50KTtcbn1cbmVkaXRIYW5kbGVycy5rZXlkb3duID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICB2aWV3LmlucHV0LnNoaWZ0S2V5ID0gZXZlbnQua2V5Q29kZSA9PSAxNiB8fCBldmVudC5zaGlmdEtleTtcbiAgICBpZiAoaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkpXG4gICAgICAgIHJldHVybjtcbiAgICB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlVGltZSA9IERhdGUubm93KCk7XG4gICAgLy8gU3VwcHJlc3MgZW50ZXIga2V5IGV2ZW50cyBvbiBDaHJvbWUgQW5kcm9pZCwgYmVjYXVzZSB0aG9zZSB0ZW5kXG4gICAgLy8gdG8gYmUgcGFydCBvZiBhIGNvbmZ1c2VkIHNlcXVlbmNlIG9mIGNvbXBvc2l0aW9uIGV2ZW50cyBmaXJlZCxcbiAgICAvLyBhbmQgaGFuZGxpbmcgdGhlbSBlYWdlcmx5IHRlbmRzIHRvIGNvcnJ1cHQgdGhlIGlucHV0LlxuICAgIGlmIChhbmRyb2lkICYmIGNocm9tZSAmJiBldmVudC5rZXlDb2RlID09IDEzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgIT0gMjI5KVxuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAvLyBPbiBpT1MsIGlmIHdlIHByZXZlbnREZWZhdWx0IGVudGVyIGtleSBwcmVzc2VzLCB0aGUgdmlydHVhbFxuICAgIC8vIGtleWJvYXJkIGdldHMgY29uZnVzZWQuIFNvIHRoZSBoYWNrIGhlcmUgaXMgdG8gc2V0IGEgZmxhZyB0aGF0XG4gICAgLy8gbWFrZXMgdGhlIERPTSBjaGFuZ2UgY29kZSByZWNvZ25pemUgdGhhdCB3aGF0IGp1c3QgaGFwcGVucyBzaG91bGRcbiAgICAvLyBiZSByZXBsYWNlZCBieSB3aGF0ZXZlciB0aGUgRW50ZXIga2V5IGhhbmRsZXJzIGRvLlxuICAgIGlmIChpb3MgJiYgZXZlbnQua2V5Q29kZSA9PSAxMyAmJiAhZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuYWx0S2V5ICYmICFldmVudC5tZXRhS2V5KSB7XG4gICAgICAgIGxldCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IG5vdztcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9PSBub3cpIHtcbiAgICAgICAgICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKTtcbiAgICAgICAgICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDIwMCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBldmVudCkpIHx8IGNhcHR1cmVLZXlEb3duKHZpZXcsIGV2ZW50KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwia2V5XCIpO1xuICAgIH1cbn07XG5lZGl0SGFuZGxlcnMua2V5dXAgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAxNilcbiAgICAgICAgdmlldy5pbnB1dC5zaGlmdEtleSA9IGZhbHNlO1xufTtcbmVkaXRIYW5kbGVycy5rZXlwcmVzcyA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgaWYgKGluT3JOZWFyQ29tcG9zaXRpb24odmlldywgZXZlbnQpIHx8ICFldmVudC5jaGFyQ29kZSB8fFxuICAgICAgICBldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgfHwgbWFjICYmIGV2ZW50Lm1ldGFLZXkpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleVByZXNzXCIsIGYgPT4gZih2aWV3LCBldmVudCkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHx8ICFzZWwuJGZyb20uc2FtZVBhcmVudChzZWwuJHRvKSkge1xuICAgICAgICBsZXQgdGV4dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQuY2hhckNvZGUpO1xuICAgICAgICBpZiAoIS9bXFxyXFxuXS8udGVzdCh0ZXh0KSAmJiAhdmlldy5zb21lUHJvcChcImhhbmRsZVRleHRJbnB1dFwiLCBmID0+IGYodmlldywgc2VsLiRmcm9tLnBvcywgc2VsLiR0by5wb3MsIHRleHQpKSlcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5pbnNlcnRUZXh0KHRleHQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBldmVudENvb3JkcyhldmVudCkgeyByZXR1cm4geyBsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFkgfTsgfVxuZnVuY3Rpb24gaXNOZWFyKGV2ZW50LCBjbGljaykge1xuICAgIGxldCBkeCA9IGNsaWNrLnggLSBldmVudC5jbGllbnRYLCBkeSA9IGNsaWNrLnkgLSBldmVudC5jbGllbnRZO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA8IDEwMDtcbn1cbmZ1bmN0aW9uIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgcHJvcE5hbWUsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIGlmIChpbnNpZGUgPT0gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHZpZXcuc29tZVByb3AocHJvcE5hbWUsIGYgPT4gaSA+ICRwb3MuZGVwdGggPyBmKHZpZXcsIHBvcywgJHBvcy5ub2RlQWZ0ZXIsICRwb3MuYmVmb3JlKGkpLCBldmVudCwgdHJ1ZSlcbiAgICAgICAgICAgIDogZih2aWV3LCBwb3MsICRwb3Mubm9kZShpKSwgJHBvcy5iZWZvcmUoaSksIGV2ZW50LCBmYWxzZSkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBzZWxlY3Rpb24sIG9yaWdpbikge1xuICAgIGlmICghdmlldy5mb2N1c2VkKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICBpZiAob3JpZ2luID09IFwicG9pbnRlclwiKVxuICAgICAgICB0ci5zZXRNZXRhKFwicG9pbnRlclwiLCB0cnVlKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdENsaWNrZWRMZWFmKHZpZXcsIGluc2lkZSkge1xuICAgIGlmIChpbnNpZGUgPT0gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKSwgbm9kZSA9ICRwb3Mubm9kZUFmdGVyO1xuICAgIGlmIChub2RlICYmIG5vZGUuaXNBdG9tICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBuZXcgTm9kZVNlbGVjdGlvbigkcG9zKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2VsZWN0Q2xpY2tlZE5vZGUodmlldywgaW5zaWRlKSB7XG4gICAgaWYgKGluc2lkZSA9PSAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiwgc2VsZWN0ZWROb2RlLCBzZWxlY3RBdDtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbilcbiAgICAgICAgc2VsZWN0ZWROb2RlID0gc2VsLm5vZGU7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGluc2lkZSk7XG4gICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGxldCBub2RlID0gaSA+ICRwb3MuZGVwdGggPyAkcG9zLm5vZGVBZnRlciA6ICRwb3Mubm9kZShpKTtcbiAgICAgICAgaWYgKE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlICYmIHNlbC4kZnJvbS5kZXB0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBpID49IHNlbC4kZnJvbS5kZXB0aCAmJiAkcG9zLmJlZm9yZShzZWwuJGZyb20uZGVwdGggKyAxKSA9PSBzZWwuJGZyb20ucG9zKVxuICAgICAgICAgICAgICAgIHNlbGVjdEF0ID0gJHBvcy5iZWZvcmUoc2VsLiRmcm9tLmRlcHRoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZWxlY3RBdCA9ICRwb3MuYmVmb3JlKGkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGVjdEF0ICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBzZWxlY3RBdCksIFwicG9pbnRlclwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlQ2xpY2sodmlldywgcG9zLCBpbnNpZGUsIGV2ZW50LCBzZWxlY3ROb2RlKSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHxcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUNsaWNrXCIsIGYgPT4gZih2aWV3LCBwb3MsIGV2ZW50KSkgfHxcbiAgICAgICAgKHNlbGVjdE5vZGUgPyBzZWxlY3RDbGlja2VkTm9kZSh2aWV3LCBpbnNpZGUpIDogc2VsZWN0Q2xpY2tlZExlYWYodmlldywgaW5zaWRlKSk7XG59XG5mdW5jdGlvbiBoYW5kbGVEb3VibGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgICByZXR1cm4gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBcImhhbmRsZURvdWJsZUNsaWNrT25cIiwgcG9zLCBpbnNpZGUsIGV2ZW50KSB8fFxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRG91YmxlQ2xpY2tcIiwgZiA9PiBmKHZpZXcsIHBvcywgZXZlbnQpKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVRyaXBsZUNsaWNrKHZpZXcsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIHJldHVybiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIFwiaGFuZGxlVHJpcGxlQ2xpY2tPblwiLCBwb3MsIGluc2lkZSwgZXZlbnQpIHx8XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVUcmlwbGVDbGlja1wiLCBmID0+IGYodmlldywgcG9zLCBldmVudCkpIHx8XG4gICAgICAgIGRlZmF1bHRUcmlwbGVDbGljayh2aWV3LCBpbnNpZGUsIGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRUcmlwbGVDbGljayh2aWV3LCBpbnNpZGUsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgIGlmIChpbnNpZGUgPT0gLTEpIHtcbiAgICAgICAgaWYgKGRvYy5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCAwLCBkb2MuY29udGVudC5zaXplKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKGluc2lkZSk7XG4gICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGxldCBub2RlID0gaSA+ICRwb3MuZGVwdGggPyAkcG9zLm5vZGVBZnRlciA6ICRwb3Mubm9kZShpKTtcbiAgICAgICAgbGV0IG5vZGVQb3MgPSAkcG9zLmJlZm9yZShpKTtcbiAgICAgICAgaWYgKG5vZGUuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIG5vZGVQb3MgKyAxLCBub2RlUG9zICsgMSArIG5vZGUuY29udGVudC5zaXplKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICBlbHNlIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSlcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIG5vZGVQb3MpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmb3JjZURPTUZsdXNoKHZpZXcpIHtcbiAgICByZXR1cm4gZW5kQ29tcG9zaXRpb24odmlldyk7XG59XG5jb25zdCBzZWxlY3ROb2RlTW9kaWZpZXIgPSBtYWMgPyBcIm1ldGFLZXlcIiA6IFwiY3RybEtleVwiO1xuaGFuZGxlcnMubW91c2Vkb3duID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICB2aWV3LmlucHV0LnNoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgbGV0IGZsdXNoZWQgPSBmb3JjZURPTUZsdXNoKHZpZXcpO1xuICAgIGxldCBub3cgPSBEYXRlLm5vdygpLCB0eXBlID0gXCJzaW5nbGVDbGlja1wiO1xuICAgIGlmIChub3cgLSB2aWV3LmlucHV0Lmxhc3RDbGljay50aW1lIDwgNTAwICYmIGlzTmVhcihldmVudCwgdmlldy5pbnB1dC5sYXN0Q2xpY2spICYmICFldmVudFtzZWxlY3ROb2RlTW9kaWZpZXJdKSB7XG4gICAgICAgIGlmICh2aWV3LmlucHV0Lmxhc3RDbGljay50eXBlID09IFwic2luZ2xlQ2xpY2tcIilcbiAgICAgICAgICAgIHR5cGUgPSBcImRvdWJsZUNsaWNrXCI7XG4gICAgICAgIGVsc2UgaWYgKHZpZXcuaW5wdXQubGFzdENsaWNrLnR5cGUgPT0gXCJkb3VibGVDbGlja1wiKVxuICAgICAgICAgICAgdHlwZSA9IFwidHJpcGxlQ2xpY2tcIjtcbiAgICB9XG4gICAgdmlldy5pbnB1dC5sYXN0Q2xpY2sgPSB7IHRpbWU6IG5vdywgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSwgdHlwZSB9O1xuICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gICAgaWYgKCFwb3MpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZSA9PSBcInNpbmdsZUNsaWNrXCIpIHtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXQubW91c2VEb3duKVxuICAgICAgICAgICAgdmlldy5pbnB1dC5tb3VzZURvd24uZG9uZSgpO1xuICAgICAgICB2aWV3LmlucHV0Lm1vdXNlRG93biA9IG5ldyBNb3VzZURvd24odmlldywgcG9zLCBldmVudCwgISFmbHVzaGVkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHR5cGUgPT0gXCJkb3VibGVDbGlja1wiID8gaGFuZGxlRG91YmxlQ2xpY2sgOiBoYW5kbGVUcmlwbGVDbGljaykodmlldywgcG9zLnBvcywgcG9zLmluc2lkZSwgZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xuICAgIH1cbn07XG5jbGFzcyBNb3VzZURvd24ge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHBvcywgZXZlbnQsIGZsdXNoZWQpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICAgICAgdGhpcy5mbHVzaGVkID0gZmx1c2hlZDtcbiAgICAgICAgdGhpcy5kZWxheWVkU2VsZWN0aW9uU3luYyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1pZ2h0RHJhZyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhcnREb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICAgICAgdGhpcy5zZWxlY3ROb2RlID0gISFldmVudFtzZWxlY3ROb2RlTW9kaWZpZXJdO1xuICAgICAgICB0aGlzLmFsbG93RGVmYXVsdCA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgICAgICBsZXQgdGFyZ2V0Tm9kZSwgdGFyZ2V0UG9zO1xuICAgICAgICBpZiAocG9zLmluc2lkZSA+IC0xKSB7XG4gICAgICAgICAgICB0YXJnZXROb2RlID0gdmlldy5zdGF0ZS5kb2Mubm9kZUF0KHBvcy5pbnNpZGUpO1xuICAgICAgICAgICAgdGFyZ2V0UG9zID0gcG9zLmluc2lkZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MucG9zKTtcbiAgICAgICAgICAgIHRhcmdldE5vZGUgPSAkcG9zLnBhcmVudDtcbiAgICAgICAgICAgIHRhcmdldFBvcyA9ICRwb3MuZGVwdGggPyAkcG9zLmJlZm9yZSgpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSBmbHVzaGVkID8gbnVsbCA6IGV2ZW50LnRhcmdldDtcbiAgICAgICAgY29uc3QgdGFyZ2V0RGVzYyA9IHRhcmdldCA/IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyh0YXJnZXQsIHRydWUpIDogbnVsbDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXREZXNjID8gdGFyZ2V0RGVzYy5kb20gOiBudWxsO1xuICAgICAgICBsZXQgeyBzZWxlY3Rpb24gfSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gPT0gMCAmJlxuICAgICAgICAgICAgdGFyZ2V0Tm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlICYmIHRhcmdldE5vZGUudHlwZS5zcGVjLnNlbGVjdGFibGUgIT09IGZhbHNlIHx8XG4gICAgICAgICAgICBzZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHNlbGVjdGlvbi5mcm9tIDw9IHRhcmdldFBvcyAmJiBzZWxlY3Rpb24udG8gPiB0YXJnZXRQb3MpXG4gICAgICAgICAgICB0aGlzLm1pZ2h0RHJhZyA9IHtcbiAgICAgICAgICAgICAgICBub2RlOiB0YXJnZXROb2RlLFxuICAgICAgICAgICAgICAgIHBvczogdGFyZ2V0UG9zLFxuICAgICAgICAgICAgICAgIGFkZEF0dHI6ICEhKHRoaXMudGFyZ2V0ICYmICF0aGlzLnRhcmdldC5kcmFnZ2FibGUpLFxuICAgICAgICAgICAgICAgIHNldFVuZWRpdGFibGU6ICEhKHRoaXMudGFyZ2V0ICYmIGdlY2tvICYmICF0aGlzLnRhcmdldC5oYXNBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIikpXG4gICAgICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy50YXJnZXQgJiYgdGhpcy5taWdodERyYWcgJiYgKHRoaXMubWlnaHREcmFnLmFkZEF0dHIgfHwgdGhpcy5taWdodERyYWcuc2V0VW5lZGl0YWJsZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5taWdodERyYWcuYWRkQXR0cilcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaW5wdXQubW91c2VEb3duID09IHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIiwgXCJmYWxzZVwiKTtcbiAgICAgICAgICAgICAgICB9LCAyMCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCA9IHRoaXMudXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHZpZXcucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSA9IHRoaXMubW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbiAgICB9XG4gICAgZG9uZSgpIHtcbiAgICAgICAgdGhpcy52aWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCk7XG4gICAgICAgIHRoaXMudmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlKTtcbiAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnICYmIHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLmFkZEF0dHIpXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIpO1xuICAgICAgICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZFNlbGVjdGlvblN5bmMpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNlbGVjdGlvblRvRE9NKHRoaXMudmlldykpO1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXQubW91c2VEb3duID0gbnVsbDtcbiAgICB9XG4gICAgdXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgIGlmICghdGhpcy52aWV3LmRvbS5jb250YWlucyhldmVudC50YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZG9jICE9IHRoaXMuc3RhcnREb2MpXG4gICAgICAgICAgICBwb3MgPSB0aGlzLnZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICAgICAgdGhpcy51cGRhdGVBbGxvd0RlZmF1bHQoZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5hbGxvd0RlZmF1bHQgfHwgIXBvcykge1xuICAgICAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZVNpbmdsZUNsaWNrKHRoaXMudmlldywgcG9zLnBvcywgcG9zLmluc2lkZSwgZXZlbnQsIHRoaXMuc2VsZWN0Tm9kZSkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuYnV0dG9uID09IDAgJiZcbiAgICAgICAgICAgICh0aGlzLmZsdXNoZWQgfHxcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgaWdub3JlcyBjbGlja3Mgb24gZHJhZ2dhYmxlIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgKHNhZmFyaSAmJiB0aGlzLm1pZ2h0RHJhZyAmJiAhdGhpcy5taWdodERyYWcubm9kZS5pc0F0b20pIHx8XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIHdpbGwgc29tZXRpbWVzIHRyZWF0IGEgbm9kZSBzZWxlY3Rpb24gYXMgYVxuICAgICAgICAgICAgICAgIC8vIGN1cnNvciwgYnV0IHN0aWxsIHJlcG9ydCB0aGF0IHRoZSBub2RlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBhc2tlZCB0aHJvdWdoIGdldFNlbGVjdGlvbi4gWW91J2xsIHRoZW4gZ2V0IGFcbiAgICAgICAgICAgICAgICAvLyBzaXR1YXRpb24gd2hlcmUgY2xpY2tpbmcgYXQgdGhlIHBvaW50IHdoZXJlIHRoYXRcbiAgICAgICAgICAgICAgICAvLyAoaGlkZGVuKSBjdXJzb3IgaXMgZG9lc24ndCBjaGFuZ2UgdGhlIHNlbGVjdGlvbiwgYW5kXG4gICAgICAgICAgICAgICAgLy8gdGh1cyBkb2Vzbid0IGdldCBhIHJlYWN0aW9uIGZyb20gUHJvc2VNaXJyb3IuIFRoaXNcbiAgICAgICAgICAgICAgICAvLyB3b3JrcyBhcm91bmQgdGhhdC5cbiAgICAgICAgICAgICAgICAoY2hyb21lICYmICF0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLnZpc2libGUgJiZcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oTWF0aC5hYnMocG9zLnBvcyAtIHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSksIE1hdGguYWJzKHBvcy5wb3MgLSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvKSkgPD0gMikpKSB7XG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24odGhpcy52aWV3LCBTZWxlY3Rpb24ubmVhcih0aGlzLnZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zLnBvcykpLCBcInBvaW50ZXJcIik7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVBbGxvd0RlZmF1bHQoZXZlbnQpO1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gICAgICAgIGlmIChldmVudC5idXR0b25zID09IDApXG4gICAgICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICB9XG4gICAgdXBkYXRlQWxsb3dEZWZhdWx0KGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxvd0RlZmF1bHQgJiYgKE1hdGguYWJzKHRoaXMuZXZlbnQueCAtIGV2ZW50LmNsaWVudFgpID4gNCB8fFxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5ldmVudC55IC0gZXZlbnQuY2xpZW50WSkgPiA0KSlcbiAgICAgICAgICAgIHRoaXMuYWxsb3dEZWZhdWx0ID0gdHJ1ZTtcbiAgICB9XG59XG5oYW5kbGVycy50b3VjaHN0YXJ0ID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dC5sYXN0VG91Y2ggPSBEYXRlLm5vdygpO1xuICAgIGZvcmNlRE9NRmx1c2godmlldyk7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbn07XG5oYW5kbGVycy50b3VjaG1vdmUgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0Lmxhc3RUb3VjaCA9IERhdGUubm93KCk7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbn07XG5oYW5kbGVycy5jb250ZXh0bWVudSA9IHZpZXcgPT4gZm9yY2VET01GbHVzaCh2aWV3KTtcbmZ1bmN0aW9uIGluT3JOZWFyQ29tcG9zaXRpb24odmlldywgZXZlbnQpIHtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIFNlZSBodHRwczovL3d3dy5zdHVtLmRlLzIwMTYvMDYvMjQvaGFuZGxpbmctaW1lLWV2ZW50cy1pbi1qYXZhc2NyaXB0Ly5cbiAgICAvLyBPbiBKYXBhbmVzZSBpbnB1dCBtZXRob2QgZWRpdG9ycyAoSU1FcyksIHRoZSBFbnRlciBrZXkgaXMgdXNlZCB0byBjb25maXJtIGNoYXJhY3RlclxuICAgIC8vIHNlbGVjdGlvbi4gT24gU2FmYXJpLCB3aGVuIEVudGVyIGlzIHByZXNzZWQsIGNvbXBvc2l0aW9uZW5kIGFuZCBrZXlkb3duIGV2ZW50cyBhcmVcbiAgICAvLyBlbWl0dGVkLiBUaGUga2V5ZG93biBldmVudCB0cmlnZ2VycyBuZXdsaW5lIGluc2VydGlvbiwgd2hpY2ggd2UgZG9uJ3Qgd2FudC5cbiAgICAvLyBUaGlzIG1ldGhvZCByZXR1cm5zIHRydWUgaWYgdGhlIGtleWRvd24gZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQuXG4gICAgLy8gV2Ugb25seSBpZ25vcmUgaXQgb25jZSwgYXMgcHJlc3NpbmcgRW50ZXIgYSBzZWNvbmQgdGltZSAqc2hvdWxkKiBpbnNlcnQgYSBuZXdsaW5lLlxuICAgIC8vIEZ1cnRoZXJtb3JlLCB0aGUga2V5ZG93biBldmVudCB0aW1lc3RhbXAgbXVzdCBiZSBjbG9zZSB0byB0aGUgY29tcG9zaXRpb25FbmRlZEF0IHRpbWVzdGFtcC5cbiAgICAvLyBUaGlzIGd1YXJkcyBhZ2FpbnN0IHRoZSBjYXNlIHdoZXJlIGNvbXBvc2l0aW9uZW5kIGlzIHRyaWdnZXJlZCB3aXRob3V0IHRoZSBrZXlib2FyZFxuICAgIC8vIChlLmcuIGNoYXJhY3RlciBjb25maXJtYXRpb24gbWF5IGJlIGRvbmUgd2l0aCB0aGUgbW91c2UpLCBhbmQga2V5ZG93biBpcyB0cmlnZ2VyZWRcbiAgICAvLyBhZnRlcndhcmRzLSB3ZSB3b3VsZG4ndCB3YW50IHRvIGlnbm9yZSB0aGUga2V5ZG93biBldmVudCBpbiB0aGlzIGNhc2UuXG4gICAgaWYgKHNhZmFyaSAmJiBNYXRoLmFicyhldmVudC50aW1lU3RhbXAgLSB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCkgPCA1MDApIHtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQgPSAtMmU4O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gRHJvcCBhY3RpdmUgY29tcG9zaXRpb24gYWZ0ZXIgNSBzZWNvbmRzIG9mIGluYWN0aXZpdHkgb24gQW5kcm9pZFxuY29uc3QgdGltZW91dENvbXBvc2l0aW9uID0gYW5kcm9pZCA/IDUwMDAgOiAtMTtcbmVkaXRIYW5kbGVycy5jb21wb3NpdGlvbnN0YXJ0ID0gZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9udXBkYXRlID0gdmlldyA9PiB7XG4gICAgaWYgKCF2aWV3LmNvbXBvc2luZykge1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmZsdXNoKCk7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCAkcG9zID0gc3RhdGUuc2VsZWN0aW9uLiRmcm9tO1xuICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmXG4gICAgICAgICAgICAoc3RhdGUuc3RvcmVkTWFya3MgfHxcbiAgICAgICAgICAgICAgICAoISRwb3MudGV4dE9mZnNldCAmJiAkcG9zLnBhcmVudE9mZnNldCAmJiAkcG9zLm5vZGVCZWZvcmUubWFya3Muc29tZShtID0+IG0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UpKSkpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gd3JhcCB0aGUgY3Vyc29yIGluIG1hcmsgbm9kZXMgZGlmZmVyZW50IGZyb20gdGhlIG9uZXMgaW4gdGhlIERPTSBjb250ZXh0XG4gICAgICAgICAgICB2aWV3Lm1hcmtDdXJzb3IgPSB2aWV3LnN0YXRlLnN0b3JlZE1hcmtzIHx8ICRwb3MubWFya3MoKTtcbiAgICAgICAgICAgIGVuZENvbXBvc2l0aW9uKHZpZXcsIHRydWUpO1xuICAgICAgICAgICAgdmlldy5tYXJrQ3Vyc29yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZENvbXBvc2l0aW9uKHZpZXcpO1xuICAgICAgICAgICAgLy8gSW4gZmlyZWZveCwgaWYgdGhlIGN1cnNvciBpcyBhZnRlciBidXQgb3V0c2lkZSBhIG1hcmtlZCBub2RlLFxuICAgICAgICAgICAgLy8gdGhlIGluc2VydGVkIHRleHQgd29uJ3QgaW5oZXJpdCB0aGUgbWFya3MuIFNvIHRoaXMgbW92ZXMgaXRcbiAgICAgICAgICAgIC8vIGluc2lkZSBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICBpZiAoZ2Vja28gJiYgc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmICRwb3MucGFyZW50T2Zmc2V0ICYmICEkcG9zLnRleHRPZmZzZXQgJiYgJHBvcy5ub2RlQmVmb3JlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNlbC5mb2N1c05vZGUsIG9mZnNldCA9IHNlbC5mb2N1c09mZnNldDsgbm9kZSAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0ICE9IDA7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBvZmZzZXQgPCAwID8gbm9kZS5sYXN0Q2hpbGQgOiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kb21TZWxlY3Rpb24oKS5jb2xsYXBzZShiZWZvcmUsIGJlZm9yZS5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIHRpbWVvdXRDb21wb3NpdGlvbik7XG59O1xuZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9uZW5kID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0ID0gZXZlbnQudGltZVN0YW1wO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgPSB2aWV3LmRvbU9ic2VydmVyLnBlbmRpbmdSZWNvcmRzKCkubGVuZ3RoID8gdmlldy5pbnB1dC5jb21wb3NpdGlvbklEIDogMDtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXQuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcylcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gdmlldy5kb21PYnNlcnZlci5mbHVzaCgpKTtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbklEKys7XG4gICAgICAgIHNjaGVkdWxlQ29tcG9zZUVuZCh2aWV3LCAyMCk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHNjaGVkdWxlQ29tcG9zZUVuZCh2aWV3LCBkZWxheSkge1xuICAgIGNsZWFyVGltZW91dCh2aWV3LmlucHV0LmNvbXBvc2luZ1RpbWVvdXQpO1xuICAgIGlmIChkZWxheSA+IC0xKVxuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2luZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGVuZENvbXBvc2l0aW9uKHZpZXcpLCBkZWxheSk7XG59XG5mdW5jdGlvbiBjbGVhckNvbXBvc2l0aW9uKHZpZXcpIHtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpIHtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQgPSB0aW1lc3RhbXBGcm9tQ3VzdG9tRXZlbnQoKTtcbiAgICB9XG4gICAgd2hpbGUgKHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2Rlcy5sZW5ndGggPiAwKVxuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZXMucG9wKCkubWFya1BhcmVudHNEaXJ0eSgpO1xufVxuZnVuY3Rpb24gdGltZXN0YW1wRnJvbUN1c3RvbUV2ZW50KCkge1xuICAgIGxldCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgZXZlbnQuaW5pdEV2ZW50KFwiZXZlbnRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcDtcbn1cbi8qKlxuQGludGVybmFsXG4qL1xuZnVuY3Rpb24gZW5kQ29tcG9zaXRpb24odmlldywgZm9yY2VVcGRhdGUgPSBmYWxzZSkge1xuICAgIGlmIChhbmRyb2lkICYmIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2hpbmdTb29uID49IDApXG4gICAgICAgIHJldHVybjtcbiAgICB2aWV3LmRvbU9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICBjbGVhckNvbXBvc2l0aW9uKHZpZXcpO1xuICAgIGlmIChmb3JjZVVwZGF0ZSB8fCB2aWV3LmRvY1ZpZXcgJiYgdmlldy5kb2NWaWV3LmRpcnR5KSB7XG4gICAgICAgIGxldCBzZWwgPSBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcpO1xuICAgICAgICBpZiAoc2VsICYmICFzZWwuZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmlldy51cGRhdGVTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVDb3B5KHZpZXcsIGRvbSkge1xuICAgIC8vIFRoZSBleHRyYSB3cmFwcGVyIGlzIHNvbWVob3cgbmVjZXNzYXJ5IG9uIElFL0VkZ2UgdG8gcHJldmVudCB0aGVcbiAgICAvLyBjb250ZW50IGZyb20gYmVpbmcgbWFuZ2xlZCB3aGVuIGl0IGlzIHB1dCBvbnRvIHRoZSBjbGlwYm9hcmRcbiAgICBpZiAoIXZpZXcuZG9tLnBhcmVudE5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgd3JhcCA9IHZpZXcuZG9tLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgIHdyYXAuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbigpLCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGRvbSk7XG4gICAgLy8gRG9uZSBiZWNhdXNlIElFIHdpbGwgZmlyZSBhIHNlbGVjdGlvbmNoYW5nZSBtb3ZpbmcgdGhlIHNlbGVjdGlvblxuICAgIC8vIHRvIGl0cyBzdGFydCB3aGVuIHJlbW92ZUFsbFJhbmdlcyBpcyBjYWxsZWQgYW5kIHRoZSBlZGl0b3Igc3RpbGxcbiAgICAvLyBoYXMgZm9jdXMgKHdoaWNoIHdpbGwgbWVzcyB1cCB0aGUgZWRpdG9yJ3Mgc2VsZWN0aW9uIHN0YXRlKS5cbiAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh3cmFwLnBhcmVudE5vZGUpXG4gICAgICAgICAgICB3cmFwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQod3JhcCk7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB9LCA1MCk7XG59XG4vLyBUaGlzIGlzIHZlcnkgY3J1ZGUsIGJ1dCB1bmZvcnR1bmF0ZWx5IGJvdGggdGhlc2UgYnJvd3NlcnMgX3ByZXRlbmRfXG4vLyB0aGF0IHRoZXkgaGF2ZSBhIGNsaXBib2FyZCBBUElcdTIwMTRhbGwgdGhlIG9iamVjdHMgYW5kIG1ldGhvZHMgYXJlXG4vLyB0aGVyZSwgdGhleSBqdXN0IGRvbid0IHdvcmssIGFuZCB0aGV5IGFyZSBoYXJkIHRvIHRlc3QuXG5jb25zdCBicm9rZW5DbGlwYm9hcmRBUEkgPSAoaWUgJiYgaWVfdmVyc2lvbiA8IDE1KSB8fFxuICAgIChpb3MgJiYgd2Via2l0X3ZlcnNpb24gPCA2MDQpO1xuaGFuZGxlcnMuY29weSA9IGVkaXRIYW5kbGVycy5jdXQgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiwgY3V0ID0gZXZlbnQudHlwZSA9PSBcImN1dFwiO1xuICAgIGlmIChzZWwuZW1wdHkpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBJRSBhbmQgRWRnZSdzIGNsaXBib2FyZCBpbnRlcmZhY2UgaXMgY29tcGxldGVseSBicm9rZW5cbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGxldCBzbGljZSA9IHNlbC5jb250ZW50KCksIHsgZG9tLCB0ZXh0IH0gPSBzZXJpYWxpemVGb3JDbGlwYm9hcmQodmlldywgc2xpY2UpO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRhdGEuY2xlYXJEYXRhKCk7XG4gICAgICAgIGRhdGEuc2V0RGF0YShcInRleHQvaHRtbFwiLCBkb20uaW5uZXJIVE1MKTtcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVDb3B5KHZpZXcsIGRvbSk7XG4gICAgfVxuICAgIGlmIChjdXQpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwiY3V0XCIpKTtcbn07XG5mdW5jdGlvbiBzbGljZVNpbmdsZU5vZGUoc2xpY2UpIHtcbiAgICByZXR1cm4gc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uub3BlbkVuZCA9PSAwICYmIHNsaWNlLmNvbnRlbnQuY2hpbGRDb3VudCA9PSAxID8gc2xpY2UuY29udGVudC5maXJzdENoaWxkIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVQYXN0ZSh2aWV3LCBldmVudCkge1xuICAgIGlmICghdmlldy5kb20ucGFyZW50Tm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBwbGFpblRleHQgPSB2aWV3LmlucHV0LnNoaWZ0S2V5IHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBhcmVudC50eXBlLnNwZWMuY29kZTtcbiAgICBsZXQgdGFyZ2V0ID0gdmlldy5kb20ucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KHBsYWluVGV4dCA/IFwidGV4dGFyZWFcIiA6IFwiZGl2XCIpKTtcbiAgICBpZiAoIXBsYWluVGV4dClcbiAgICAgICAgdGFyZ2V0LmNvbnRlbnRFZGl0YWJsZSA9IFwidHJ1ZVwiO1xuICAgIHRhcmdldC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICBsZXQgcGxhaW4gPSB2aWV3LmlucHV0LnNoaWZ0S2V5ICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgIT0gNDU7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgaWYgKHRhcmdldC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcbiAgICAgICAgaWYgKHBsYWluVGV4dClcbiAgICAgICAgICAgIGRvUGFzdGUodmlldywgdGFyZ2V0LnZhbHVlLCBudWxsLCBwbGFpbiwgZXZlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkb1Bhc3RlKHZpZXcsIHRhcmdldC50ZXh0Q29udGVudCwgdGFyZ2V0LmlubmVySFRNTCwgcGxhaW4sIGV2ZW50KTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiBkb1Bhc3RlKHZpZXcsIHRleHQsIGh0bWwsIHByZWZlclBsYWluLCBldmVudCkge1xuICAgIGxldCBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCB0ZXh0LCBodG1sLCBwcmVmZXJQbGFpbiwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb20pO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlUGFzdGVcIiwgZiA9PiBmKHZpZXcsIGV2ZW50LCBzbGljZSB8fCBTbGljZS5lbXB0eSkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIXNsaWNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNpbmdsZU5vZGUgPSBzbGljZVNpbmdsZU5vZGUoc2xpY2UpO1xuICAgIGxldCB0ciA9IHNpbmdsZU5vZGVcbiAgICAgICAgPyB2aWV3LnN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHNpbmdsZU5vZGUsIHByZWZlclBsYWluKVxuICAgICAgICA6IHZpZXcuc3RhdGUudHIucmVwbGFjZVNlbGVjdGlvbihzbGljZSk7XG4gICAgdmlldy5kaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJwYXN0ZVwiLCB0cnVlKS5zZXRNZXRhKFwidWlFdmVudFwiLCBcInBhc3RlXCIpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmVkaXRIYW5kbGVycy5wYXN0ZSA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgLy8gSGFuZGxpbmcgcGFzdGUgZnJvbSBKYXZhU2NyaXB0IGR1cmluZyBjb21wb3NpdGlvbiBpcyB2ZXJ5IHBvb3JseVxuICAgIC8vIGhhbmRsZWQgYnkgYnJvd3NlcnMsIHNvIGFzIGEgZG9kZ3kgYnV0IHByZWZlcmFibGUga2x1ZGdlLCB3ZSBqdXN0XG4gICAgLy8gbGV0IHRoZSBicm93c2VyIGRvIGl0cyBuYXRpdmUgdGhpbmcgdGhlcmUsIGV4Y2VwdCBvbiBBbmRyb2lkLFxuICAgIC8vIHdoZXJlIHRoZSBlZGl0b3IgaXMgYWxtb3N0IGFsd2F5cyBjb21wb3NpbmcuXG4gICAgaWYgKHZpZXcuY29tcG9zaW5nICYmICFhbmRyb2lkKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBsZXQgcGxhaW4gPSB2aWV3LmlucHV0LnNoaWZ0S2V5ICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgIT0gNDU7XG4gICAgaWYgKGRhdGEgJiYgZG9QYXN0ZSh2aWV3LCBkYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpLCBkYXRhLmdldERhdGEoXCJ0ZXh0L2h0bWxcIiksIHBsYWluLCBldmVudCkpXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZWxzZVxuICAgICAgICBjYXB0dXJlUGFzdGUodmlldywgZXZlbnQpO1xufTtcbmNsYXNzIERyYWdnaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihzbGljZSwgbW92ZSkge1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMubW92ZSA9IG1vdmU7XG4gICAgfVxufVxuY29uc3QgZHJhZ0NvcHlNb2RpZmllciA9IG1hYyA/IFwiYWx0S2V5XCIgOiBcImN0cmxLZXlcIjtcbmhhbmRsZXJzLmRyYWdzdGFydCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgbGV0IG1vdXNlRG93biA9IHZpZXcuaW5wdXQubW91c2VEb3duO1xuICAgIGlmIChtb3VzZURvd24pXG4gICAgICAgIG1vdXNlRG93bi5kb25lKCk7XG4gICAgaWYgKCFldmVudC5kYXRhVHJhbnNmZXIpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IHBvcyA9IHNlbC5lbXB0eSA/IG51bGwgOiB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gICAgaWYgKHBvcyAmJiBwb3MucG9zID49IHNlbC5mcm9tICYmIHBvcy5wb3MgPD0gKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gPyBzZWwudG8gLSAxIDogc2VsLnRvKSkgO1xuICAgIGVsc2UgaWYgKG1vdXNlRG93biAmJiBtb3VzZURvd24ubWlnaHREcmFnKSB7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIG1vdXNlRG93bi5taWdodERyYWcucG9zKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudC50YXJnZXQgJiYgZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgbGV0IGRlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZXZlbnQudGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5ub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUgJiYgZGVzYyAhPSB2aWV3LmRvY1ZpZXcpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBkZXNjLnBvc0JlZm9yZSkpKTtcbiAgICB9XG4gICAgbGV0IHNsaWNlID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uY29udGVudCgpLCB7IGRvbSwgdGV4dCB9ID0gc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHZpZXcsIHNsaWNlKTtcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuY2xlYXJEYXRhKCk7XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoYnJva2VuQ2xpcGJvYXJkQVBJID8gXCJUZXh0XCIgOiBcInRleHQvaHRtbFwiLCBkb20uaW5uZXJIVE1MKTtcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1Byb3NlTWlycm9yL3Byb3NlbWlycm9yL2lzc3Vlcy8xMTU2XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcImNvcHlNb3ZlXCI7XG4gICAgaWYgKCFicm9rZW5DbGlwYm9hcmRBUEkpXG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICB2aWV3LmRyYWdnaW5nID0gbmV3IERyYWdnaW5nKHNsaWNlLCAhZXZlbnRbZHJhZ0NvcHlNb2RpZmllcl0pO1xufTtcbmhhbmRsZXJzLmRyYWdlbmQgPSB2aWV3ID0+IHtcbiAgICBsZXQgZHJhZ2dpbmcgPSB2aWV3LmRyYWdnaW5nO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHZpZXcuZHJhZ2dpbmcgPT0gZHJhZ2dpbmcpXG4gICAgICAgICAgICB2aWV3LmRyYWdnaW5nID0gbnVsbDtcbiAgICB9LCA1MCk7XG59O1xuZWRpdEhhbmRsZXJzLmRyYWdvdmVyID0gZWRpdEhhbmRsZXJzLmRyYWdlbnRlciA9IChfLCBlKSA9PiBlLnByZXZlbnREZWZhdWx0KCk7XG5lZGl0SGFuZGxlcnMuZHJvcCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgbGV0IGRyYWdnaW5nID0gdmlldy5kcmFnZ2luZztcbiAgICB2aWV3LmRyYWdnaW5nID0gbnVsbDtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBldmVudFBvcyA9IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICBpZiAoIWV2ZW50UG9zKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0ICRtb3VzZSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZXZlbnRQb3MucG9zKTtcbiAgICBsZXQgc2xpY2UgPSBkcmFnZ2luZyAmJiBkcmFnZ2luZy5zbGljZTtcbiAgICBpZiAoc2xpY2UpIHtcbiAgICAgICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFwiLCBmID0+IHsgc2xpY2UgPSBmKHNsaWNlLCB2aWV3KTsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShicm9rZW5DbGlwYm9hcmRBUEkgPyBcIlRleHRcIiA6IFwidGV4dC9wbGFpblwiKSwgYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwidGV4dC9odG1sXCIpLCBmYWxzZSwgJG1vdXNlKTtcbiAgICB9XG4gICAgbGV0IG1vdmUgPSAhIShkcmFnZ2luZyAmJiAhZXZlbnRbZHJhZ0NvcHlNb2RpZmllcl0pO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRHJvcFwiLCBmID0+IGYodmlldywgZXZlbnQsIHNsaWNlIHx8IFNsaWNlLmVtcHR5LCBtb3ZlKSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXNsaWNlKVxuICAgICAgICByZXR1cm47XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgaW5zZXJ0UG9zID0gc2xpY2UgPyBkcm9wUG9pbnQodmlldy5zdGF0ZS5kb2MsICRtb3VzZS5wb3MsIHNsaWNlKSA6ICRtb3VzZS5wb3M7XG4gICAgaWYgKGluc2VydFBvcyA9PSBudWxsKVxuICAgICAgICBpbnNlcnRQb3MgPSAkbW91c2UucG9zO1xuICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgaWYgKG1vdmUpXG4gICAgICAgIHRyLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgIGxldCBwb3MgPSB0ci5tYXBwaW5nLm1hcChpbnNlcnRQb3MpO1xuICAgIGxldCBpc05vZGUgPSBzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5vcGVuRW5kID09IDAgJiYgc2xpY2UuY29udGVudC5jaGlsZENvdW50ID09IDE7XG4gICAgbGV0IGJlZm9yZUluc2VydCA9IHRyLmRvYztcbiAgICBpZiAoaXNOb2RlKVxuICAgICAgICB0ci5yZXBsYWNlUmFuZ2VXaXRoKHBvcywgcG9zLCBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgIGVsc2VcbiAgICAgICAgdHIucmVwbGFjZVJhbmdlKHBvcywgcG9zLCBzbGljZSk7XG4gICAgaWYgKHRyLmRvYy5lcShiZWZvcmVJbnNlcnQpKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0ICRwb3MgPSB0ci5kb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmIChpc05vZGUgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoc2xpY2UuY29udGVudC5maXJzdENoaWxkKSAmJlxuICAgICAgICAkcG9zLm5vZGVBZnRlciAmJiAkcG9zLm5vZGVBZnRlci5zYW1lTWFya3VwKHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBlbmQgPSB0ci5tYXBwaW5nLm1hcChpbnNlcnRQb3MpO1xuICAgICAgICB0ci5tYXBwaW5nLm1hcHNbdHIubWFwcGluZy5tYXBzLmxlbmd0aCAtIDFdLmZvckVhY2goKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgPT4gZW5kID0gbmV3VG8pO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkcG9zLCB0ci5kb2MucmVzb2x2ZShlbmQpKSk7XG4gICAgfVxuICAgIHZpZXcuZm9jdXMoKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwiZHJvcFwiKSk7XG59O1xuaGFuZGxlcnMuZm9jdXMgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0Lmxhc3RGb2N1cyA9IERhdGUubm93KCk7XG4gICAgaWYgKCF2aWV3LmZvY3VzZWQpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIHZpZXcuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuZG9jVmlldyAmJiB2aWV3Lmhhc0ZvY3VzKCkgJiYgIXZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5lcSh2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCkpKVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgICAgICB9LCAyMCk7XG4gICAgfVxufTtcbmhhbmRsZXJzLmJsdXIgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGlmICh2aWV3LmZvY3VzZWQpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIGlmIChldmVudC5yZWxhdGVkVGFyZ2V0ICYmIHZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICAgIHZpZXcuZm9jdXNlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5oYW5kbGVycy5iZWZvcmVpbnB1dCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgLy8gV2Ugc2hvdWxkIHByb2JhYmx5IGRvIG1vcmUgd2l0aCBiZWZvcmVpbnB1dCBldmVudHMsIGJ1dCBzdXBwb3J0XG4gICAgLy8gaXMgc28gc3BvdHR5IHRoYXQgSSdtIHN0aWxsIHdhaXRpbmcgdG8gc2VlIHdoZXJlIHRoZXkgYXJlIGdvaW5nLlxuICAgIC8vIFZlcnkgc3BlY2lmaWMgaGFjayB0byBkZWFsIHdpdGggYmFja3NwYWNlIHNvbWV0aW1lcyBmYWlsaW5nIG9uXG4gICAgLy8gQ2hyb21lIEFuZHJvaWQgd2hlbiBhZnRlciBhbiB1bmVkaXRhYmxlIG5vZGUuXG4gICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkICYmIGV2ZW50LmlucHV0VHlwZSA9PSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2hTb29uKCk7XG4gICAgICAgIGxldCB7IGRvbUNoYW5nZUNvdW50IH0gPSB2aWV3LmlucHV0O1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0LmRvbUNoYW5nZUNvdW50ICE9IGRvbUNoYW5nZUNvdW50KVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gRXZlbnQgYWxyZWFkeSBoYWQgc29tZSBlZmZlY3RcbiAgICAgICAgICAgIC8vIFRoaXMgYnVnIHRlbmRzIHRvIGNsb3NlIHRoZSB2aXJ0dWFsIGtleWJvYXJkLCBzbyB3ZSByZWZvY3VzXG4gICAgICAgICAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDgsIFwiQmFja3NwYWNlXCIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAvLyBDcnVkZSBhcHByb3hpbWF0aW9uIG9mIGJhY2tzcGFjZSBiZWhhdmlvciB3aGVuIG5vIGNvbW1hbmQgaGFuZGxlZCBpdFxuICAgICAgICAgICAgaWYgKCRjdXJzb3IgJiYgJGN1cnNvci5wb3MgPiAwKVxuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGUoJGN1cnNvci5wb3MgLSAxLCAkY3Vyc29yLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH0sIDUwKTtcbiAgICB9XG59O1xuLy8gTWFrZSBzdXJlIGFsbCBoYW5kbGVycyBnZXQgcmVnaXN0ZXJlZFxuZm9yIChsZXQgcHJvcCBpbiBlZGl0SGFuZGxlcnMpXG4gICAgaGFuZGxlcnNbcHJvcF0gPSBlZGl0SGFuZGxlcnNbcHJvcF07XG5cbmZ1bmN0aW9uIGNvbXBhcmVPYmpzKGEsIGIpIHtcbiAgICBpZiAoYSA9PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBmb3IgKGxldCBwIGluIGEpXG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IHAgaW4gYilcbiAgICAgICAgaWYgKCEocCBpbiBhKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHRvRE9NLCBzcGVjKSB7XG4gICAgICAgIHRoaXMudG9ET00gPSB0b0RPTTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgICAgIHRoaXMuc2lkZSA9IHRoaXMuc3BlYy5zaWRlIHx8IDA7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgeyBwb3MsIGRlbGV0ZWQgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4uZnJvbSArIG9sZE9mZnNldCwgdGhpcy5zaWRlIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHJldHVybiBkZWxldGVkID8gbnVsbCA6IG5ldyBEZWNvcmF0aW9uKHBvcyAtIG9mZnNldCwgcG9zIC0gb2Zmc2V0LCB0aGlzKTtcbiAgICB9XG4gICAgdmFsaWQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIFdpZGdldFR5cGUgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5zcGVjLmtleSAmJiB0aGlzLnNwZWMua2V5ID09IG90aGVyLnNwZWMua2V5IHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9ET00gPT0gb3RoZXIudG9ET00gJiYgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSkpO1xuICAgIH1cbiAgICBkZXN0cm95KG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy5kZXN0cm95KVxuICAgICAgICAgICAgdGhpcy5zcGVjLmRlc3Ryb3kobm9kZSk7XG4gICAgfVxufVxuY2xhc3MgSW5saW5lVHlwZSB7XG4gICAgY29uc3RydWN0b3IoYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIHNwYW4sIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAoc3Bhbi5mcm9tICsgb2xkT2Zmc2V0LCB0aGlzLnNwZWMuaW5jbHVzaXZlU3RhcnQgPyAtMSA6IDEpIC0gb2Zmc2V0O1xuICAgICAgICBsZXQgdG8gPSBtYXBwaW5nLm1hcChzcGFuLnRvICsgb2xkT2Zmc2V0LCB0aGlzLnNwZWMuaW5jbHVzaXZlRW5kID8gMSA6IC0xKSAtIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIGZyb20gPj0gdG8gPyBudWxsIDogbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIHRoaXMpO1xuICAgIH1cbiAgICB2YWxpZChfLCBzcGFuKSB7IHJldHVybiBzcGFuLmZyb20gPCBzcGFuLnRvOyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIElubGluZVR5cGUgJiYgY29tcGFyZU9ianModGhpcy5hdHRycywgb3RoZXIuYXR0cnMpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSk7XG4gICAgfVxuICAgIHN0YXRpYyBpcyhzcGFuKSB7IHJldHVybiBzcGFuLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlOyB9XG4gICAgZGVzdHJveSgpIHsgfVxufVxuY2xhc3MgTm9kZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4uZnJvbSArIG9sZE9mZnNldCwgMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHRvID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi50byArIG9sZE9mZnNldCwgLTEpO1xuICAgICAgICBpZiAodG8uZGVsZXRlZCB8fCB0by5wb3MgPD0gZnJvbS5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20ucG9zIC0gb2Zmc2V0LCB0by5wb3MgLSBvZmZzZXQsIHRoaXMpO1xuICAgIH1cbiAgICB2YWxpZChub2RlLCBzcGFuKSB7XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgoc3Bhbi5mcm9tKSwgY2hpbGQ7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPT0gc3Bhbi5mcm9tICYmICEoY2hpbGQgPSBub2RlLmNoaWxkKGluZGV4KSkuaXNUZXh0ICYmIG9mZnNldCArIGNoaWxkLm5vZGVTaXplID09IHNwYW4udG87XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBOb2RlVHlwZSAmJiBjb21wYXJlT2Jqcyh0aGlzLmF0dHJzLCBvdGhlci5hdHRycykgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlT2Jqcyh0aGlzLnNwZWMsIG90aGVyLnNwZWMpKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHsgfVxufVxuLyoqXG5EZWNvcmF0aW9uIG9iamVjdHMgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSB2aWV3IHRocm91Z2ggdGhlXG5bYGRlY29yYXRpb25zYCBwcm9wXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcy5kZWNvcmF0aW9ucykuIFRoZXkgY29tZSBpblxuc2V2ZXJhbCB2YXJpYW50c1x1MjAxNHNlZSB0aGUgc3RhdGljIG1lbWJlcnMgb2YgdGhpcyBjbGFzcyBmb3IgZGV0YWlscy5cbiovXG5jbGFzcyBEZWNvcmF0aW9uIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgZGVjb3JhdGlvbi5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24uIFdpbGwgYmUgdGhlIHNhbWUgYXMgYGZyb21gIGZvciBbd2lkZ2V0XG4gICAgZGVjb3JhdGlvbnNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25ed2lkZ2V0KS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHR5cGUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvcHkoZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCB0aGlzLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVxKG90aGVyLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuZXEob3RoZXIudHlwZSkgJiYgdGhpcy5mcm9tICsgb2Zmc2V0ID09IG90aGVyLmZyb20gJiYgdGhpcy50byArIG9mZnNldCA9PSBvdGhlci50bztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5tYXAobWFwcGluZywgdGhpcywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGlzIGEgRE9NIG5vZGUgdGhhdCdzIHNob3duIGluXG4gICAgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3VcbiAgICBkZWxheSByZW5kZXJpbmcgdGhlIHdpZGdldCBieSBwYXNzaW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlXG4gICAgY2FsbGVkIHdoZW4gdGhlIHdpZGdldCBpcyBhY3R1YWxseSBkcmF3biBpbiBhIHZpZXcsIGJ1dCB5b3UgY2FuXG4gICAgYWxzbyBkaXJlY3RseSBwYXNzIGEgRE9NIG5vZGUuIGBnZXRQb3NgIGNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlXG4gICAgd2lkZ2V0J3MgY3VycmVudCBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyB3aWRnZXQocG9zLCB0b0RPTSwgc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24ocG9zLCBwb3MsIG5ldyBXaWRnZXRUeXBlKHRvRE9NLCBzcGVjKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZXMgYW4gaW5saW5lIGRlY29yYXRpb24sIHdoaWNoIGFkZHMgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgdG9cbiAgICBlYWNoIGlubGluZSBub2RlIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLlxuICAgICovXG4gICAgc3RhdGljIGlubGluZShmcm9tLCB0bywgYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCBuZXcgSW5saW5lVHlwZShhdHRycywgc3BlYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGEgbm9kZSBkZWNvcmF0aW9uLiBgZnJvbWAgYW5kIGB0b2Agc2hvdWxkIHBvaW50IHByZWNpc2VseVxuICAgIGJlZm9yZSBhbmQgYWZ0ZXIgYSBub2RlIGluIHRoZSBkb2N1bWVudC4gVGhhdCBub2RlLCBhbmQgb25seSB0aGF0XG4gICAgbm9kZSwgd2lsbCByZWNlaXZlIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgc3RhdGljIG5vZGUoZnJvbSwgdG8sIGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgbmV3IE5vZGVUeXBlKGF0dHJzLCBzcGVjKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzcGVjIHByb3ZpZGVkIHdoZW4gY3JlYXRpbmcgdGhpcyBkZWNvcmF0aW9uLiBDYW4gYmUgdXNlZnVsXG4gICAgaWYgeW91J3ZlIHN0b3JlZCBleHRyYSBpbmZvcm1hdGlvbiBpbiB0aGF0IG9iamVjdC5cbiAgICAqL1xuICAgIGdldCBzcGVjKCkgeyByZXR1cm4gdGhpcy50eXBlLnNwZWM7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpbmxpbmUoKSB7IHJldHVybiB0aGlzLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgd2lkZ2V0KCkgeyByZXR1cm4gdGhpcy50eXBlIGluc3RhbmNlb2YgV2lkZ2V0VHlwZTsgfVxufVxuY29uc3Qgbm9uZSA9IFtdLCBub1NwZWMgPSB7fTtcbi8qKlxuQSBjb2xsZWN0aW9uIG9mIFtkZWNvcmF0aW9uc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbiksIG9yZ2FuaXplZCBpbiBzdWNoXG5hIHdheSB0aGF0IHRoZSBkcmF3aW5nIGFsZ29yaXRobSBjYW4gZWZmaWNpZW50bHkgdXNlIGFuZCBjb21wYXJlXG50aGVtLiBUaGlzIGlzIGEgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZVx1MjAxNGl0IGlzIG5vdCBtb2RpZmllZCxcbnVwZGF0ZXMgY3JlYXRlIGEgbmV3IHZhbHVlLlxuKi9cbmNsYXNzIERlY29yYXRpb25TZXQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IobG9jYWwsIGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbC5sZW5ndGggPyBsb2NhbCA6IG5vbmU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlbiA6IG5vbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiBkZWNvcmF0aW9ucywgdXNpbmcgdGhlIHN0cnVjdHVyZSBvZiB0aGUgZ2l2ZW5cbiAgICBkb2N1bWVudC4gVGhpcyB3aWxsIGNvbnN1bWUgKG1vZGlmeSkgdGhlIGBkZWNvcmF0aW9uc2AgYXJyYXksIHNvXG4gICAgeW91IG11c3QgbWFrZSBhIGNvcHkgaWYgeW91IHdhbnQgbmVlZCB0byBwcmVzZXJ2ZSB0aGF0LlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGRlY29yYXRpb25zKSB7XG4gICAgICAgIHJldHVybiBkZWNvcmF0aW9ucy5sZW5ndGggPyBidWlsZFRyZWUoZGVjb3JhdGlvbnMsIGRvYywgMCwgbm9TcGVjKSA6IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGFsbCBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCB3aGljaCB0b3VjaCB0aGUgZ2l2ZW4gcmFuZ2VcbiAgICAoaW5jbHVkaW5nIGRlY29yYXRpb25zIHRoYXQgc3RhcnQgb3IgZW5kIGRpcmVjdGx5IGF0IHRoZVxuICAgIGJvdW5kYXJpZXMpIGFuZCBtYXRjaCB0aGUgZ2l2ZW4gcHJlZGljYXRlIG9uIHRoZWlyIHNwZWMuIFdoZW5cbiAgICBgc3RhcnRgIGFuZCBgZW5kYCBhcmUgb21pdHRlZCwgYWxsIGRlY29yYXRpb25zIGluIHRoZSBzZXQgYXJlXG4gICAgY29uc2lkZXJlZC4gV2hlbiBgcHJlZGljYXRlYCBpc24ndCBnaXZlbiwgYWxsIGRlY29yYXRpb25zIGFyZVxuICAgIGFzc3VtZWQgdG8gbWF0Y2guXG4gICAgKi9cbiAgICBmaW5kKHN0YXJ0LCBlbmQsIHByZWRpY2F0ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZmluZElubmVyKHN0YXJ0ID09IG51bGwgPyAwIDogc3RhcnQsIGVuZCA9PSBudWxsID8gMWU5IDogZW5kLCByZXN1bHQsIDAsIHByZWRpY2F0ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZpbmRJbm5lcihzdGFydCwgZW5kLCByZXN1bHQsIG9mZnNldCwgcHJlZGljYXRlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSB0aGlzLmxvY2FsW2ldO1xuICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA8PSBlbmQgJiYgc3Bhbi50byA+PSBzdGFydCAmJiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoc3Bhbi5zcGVjKSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Bhbi5jb3B5KHNwYW4uZnJvbSArIG9mZnNldCwgc3Bhbi50byArIG9mZnNldCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPCBlbmQgJiYgdGhpcy5jaGlsZHJlbltpICsgMV0gPiBzdGFydCkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZE9mZiA9IHRoaXMuY2hpbGRyZW5baV0gKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baSArIDJdLmZpbmRJbm5lcihzdGFydCAtIGNoaWxkT2ZmLCBlbmQgLSBjaGlsZE9mZiwgcmVzdWx0LCBvZmZzZXQgKyBjaGlsZE9mZiwgcHJlZGljYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhlIHNldCBvZiBkZWNvcmF0aW9ucyBpbiByZXNwb25zZSB0byBhIGNoYW5nZSBpbiB0aGVcbiAgICBkb2N1bWVudC5cbiAgICAqL1xuICAgIG1hcChtYXBwaW5nLCBkb2MsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkgfHwgbWFwcGluZy5tYXBzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcElubmVyKG1hcHBpbmcsIGRvYywgMCwgMCwgb3B0aW9ucyB8fCBub1NwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hcElubmVyKG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBuZXdMb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gdGhpcy5sb2NhbFtpXS5tYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZCAmJiBtYXBwZWQudHlwZS52YWxpZChub2RlLCBtYXBwZWQpKVxuICAgICAgICAgICAgICAgIChuZXdMb2NhbCB8fCAobmV3TG9jYWwgPSBbXSkpLnB1c2gobWFwcGVkKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMub25SZW1vdmUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlbW92ZSh0aGlzLmxvY2FsW2ldLnNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBtYXBDaGlsZHJlbih0aGlzLmNoaWxkcmVuLCBuZXdMb2NhbCB8fCBbXSwgbWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3TG9jYWwgPyBuZXcgRGVjb3JhdGlvblNldChuZXdMb2NhbC5zb3J0KGJ5UG9zKSwgbm9uZSkgOiBlbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIHRoZSBnaXZlbiBhcnJheSBvZiBkZWNvcmF0aW9ucyB0byB0aGUgb25lcyBpbiB0aGUgc2V0LFxuICAgIHByb2R1Y2luZyBhIG5ldyBzZXQuIENvbnN1bWVzIHRoZSBgZGVjb3JhdGlvbnNgIGFycmF5LiBOZWVkc1xuICAgIGFjY2VzcyB0byB0aGUgY3VycmVudCBkb2N1bWVudCB0byBjcmVhdGUgdGhlIGFwcHJvcHJpYXRlIHRyZWVcbiAgICBzdHJ1Y3R1cmUuXG4gICAgKi9cbiAgICBhZGQoZG9jLCBkZWNvcmF0aW9ucykge1xuICAgICAgICBpZiAoIWRlY29yYXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGRlY29yYXRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkSW5uZXIoZG9jLCBkZWNvcmF0aW9ucywgMCk7XG4gICAgfVxuICAgIGFkZElubmVyKGRvYywgZGVjb3JhdGlvbnMsIG9mZnNldCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4sIGNoaWxkSW5kZXggPSAwO1xuICAgICAgICBkb2MuZm9yRWFjaCgoY2hpbGROb2RlLCBjaGlsZE9mZnNldCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJhc2VPZmZzZXQgPSBjaGlsZE9mZnNldCArIG9mZnNldCwgZm91bmQ7XG4gICAgICAgICAgICBpZiAoIShmb3VuZCA9IHRha2VTcGFuc0Zvck5vZGUoZGVjb3JhdGlvbnMsIGNoaWxkTm9kZSwgYmFzZU9mZnNldCkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGRJbmRleCA8IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlbltjaGlsZEluZGV4XSA8IGNoaWxkT2Zmc2V0KVxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXggKz0gMztcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltjaGlsZEluZGV4XSA9PSBjaGlsZE9mZnNldClcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0gPSBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0uYWRkSW5uZXIoY2hpbGROb2RlLCBmb3VuZCwgYmFzZU9mZnNldCArIDEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShjaGlsZEluZGV4LCAwLCBjaGlsZE9mZnNldCwgY2hpbGRPZmZzZXQgKyBjaGlsZE5vZGUubm9kZVNpemUsIGJ1aWxkVHJlZShmb3VuZCwgY2hpbGROb2RlLCBiYXNlT2Zmc2V0ICsgMSwgbm9TcGVjKSk7XG4gICAgICAgICAgICBjaGlsZEluZGV4ICs9IDM7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbG9jYWwgPSBtb3ZlU3BhbnMoY2hpbGRJbmRleCA/IHdpdGhvdXROdWxscyhkZWNvcmF0aW9ucykgOiBkZWNvcmF0aW9ucywgLW9mZnNldCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWxvY2FsW2ldLnR5cGUudmFsaWQoZG9jLCBsb2NhbFtpXSkpXG4gICAgICAgICAgICAgICAgbG9jYWwuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvblNldChsb2NhbC5sZW5ndGggPyB0aGlzLmxvY2FsLmNvbmNhdChsb2NhbCkuc29ydChieVBvcykgOiB0aGlzLmxvY2FsLCBjaGlsZHJlbiB8fCB0aGlzLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHNldCB0aGF0IGNvbnRhaW5zIHRoZSBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCwgbWludXNcbiAgICB0aGUgb25lcyBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG4gICAgKi9cbiAgICByZW1vdmUoZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgaWYgKGRlY29yYXRpb25zLmxlbmd0aCA9PSAwIHx8IHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlSW5uZXIoZGVjb3JhdGlvbnMsIDApO1xuICAgIH1cbiAgICByZW1vdmVJbm5lcihkZWNvcmF0aW9ucywgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4sIGxvY2FsID0gdGhpcy5sb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IGZvdW5kO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBjaGlsZHJlbltpXSArIG9mZnNldCwgdG8gPSBjaGlsZHJlbltpICsgMV0gKyBvZmZzZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgc3BhbjsgaiA8IGRlY29yYXRpb25zLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIGlmIChzcGFuID0gZGVjb3JhdGlvbnNbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA+IGZyb20gJiYgc3Bhbi50byA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0aW9uc1tqXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAoZm91bmQgfHwgKGZvdW5kID0gW10pKS5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbiA9PSB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICAgICAgbGV0IHJlbW92ZWQgPSBjaGlsZHJlbltpICsgMl0ucmVtb3ZlSW5uZXIoZm91bmQsIGZyb20gKyAxKTtcbiAgICAgICAgICAgIGlmIChyZW1vdmVkICE9IGVtcHR5KSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDJdID0gcmVtb3ZlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAzKTtcbiAgICAgICAgICAgICAgICBpIC09IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzcGFuOyBpIDwgZGVjb3JhdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHNwYW4gPSBkZWNvcmF0aW9uc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxvY2FsLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsW2pdLmVxKHNwYW4sIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWwgPT0gdGhpcy5sb2NhbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWwgPSB0aGlzLmxvY2FsLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWwuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4gPT0gdGhpcy5jaGlsZHJlbiAmJiBsb2NhbCA9PSB0aGlzLmxvY2FsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBsb2NhbC5sZW5ndGggfHwgY2hpbGRyZW4ubGVuZ3RoID8gbmV3IERlY29yYXRpb25TZXQobG9jYWwsIGNoaWxkcmVuKSA6IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZvckNoaWxkKG9mZnNldCwgbm9kZSkge1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5lbXB0eTtcbiAgICAgICAgbGV0IGNoaWxkLCBsb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPj0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPT0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baSArIDJdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSBvZmZzZXQgKyAxLCBlbmQgPSBzdGFydCArIG5vZGUuY29udGVudC5zaXplO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBkZWMgPSB0aGlzLmxvY2FsW2ldO1xuICAgICAgICAgICAgaWYgKGRlYy5mcm9tIDwgZW5kICYmIGRlYy50byA+IHN0YXJ0ICYmIChkZWMudHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChzdGFydCwgZGVjLmZyb20pIC0gc3RhcnQsIHRvID0gTWF0aC5taW4oZW5kLCBkZWMudG8pIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0bylcbiAgICAgICAgICAgICAgICAgICAgKGxvY2FsIHx8IChsb2NhbCA9IFtdKSkucHVzaChkZWMuY29weShmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICAgICAgbGV0IGxvY2FsU2V0ID0gbmV3IERlY29yYXRpb25TZXQobG9jYWwuc29ydChieVBvcyksIG5vbmUpO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkID8gbmV3IERlY29yYXRpb25Hcm91cChbbG9jYWxTZXQsIGNoaWxkXSkgOiBsb2NhbFNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gb3RoZXIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEZWNvcmF0aW9uU2V0KSB8fFxuICAgICAgICAgICAgdGhpcy5sb2NhbC5sZW5ndGggIT0gb3RoZXIubG9jYWwubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCAhPSBvdGhlci5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5sb2NhbFtpXS5lcShvdGhlci5sb2NhbFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSAhPSBvdGhlci5jaGlsZHJlbltpXSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baSArIDFdICE9IG90aGVyLmNoaWxkcmVuW2kgKyAxXSB8fFxuICAgICAgICAgICAgICAgICF0aGlzLmNoaWxkcmVuW2kgKyAyXS5lcShvdGhlci5jaGlsZHJlbltpICsgMl0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbG9jYWxzKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZU92ZXJsYXAodGhpcy5sb2NhbHNJbm5lcihub2RlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbG9jYWxzSW5uZXIobm9kZSkge1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBub25lO1xuICAgICAgICBpZiAobm9kZS5pbmxpbmVDb250ZW50IHx8ICF0aGlzLmxvY2FsLnNvbWUoSW5saW5lVHlwZS5pcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMubG9jYWxbaV0udHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGUpKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubG9jYWxbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIGRlY29yYXRpb25zLlxuKi9cbkRlY29yYXRpb25TZXQuZW1wdHkgPSBuZXcgRGVjb3JhdGlvblNldChbXSwgW10pO1xuLyoqXG5AaW50ZXJuYWxcbiovXG5EZWNvcmF0aW9uU2V0LnJlbW92ZU92ZXJsYXAgPSByZW1vdmVPdmVybGFwO1xuY29uc3QgZW1wdHkgPSBEZWNvcmF0aW9uU2V0LmVtcHR5O1xuLy8gQW4gYWJzdHJhY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGNvZGUgZGVhbGluZyB3aXRoIGRlY29yYXRpb25zIHRvXG4vLyB0cmVhdCBtdWx0aXBsZSBEZWNvcmF0aW9uU2V0IG9iamVjdHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZSBvYmplY3Rcbi8vIHdpdGggKGEgc3Vic2V0IG9mKSB0aGUgc2FtZSBpbnRlcmZhY2UuXG5jbGFzcyBEZWNvcmF0aW9uR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKG1lbWJlcnMpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIGRvYykge1xuICAgICAgICBjb25zdCBtYXBwZWREZWNvcyA9IHRoaXMubWVtYmVycy5tYXAobWVtYmVyID0+IG1lbWJlci5tYXAobWFwcGluZywgZG9jLCBub1NwZWMpKTtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKG1hcHBlZERlY29zKTtcbiAgICB9XG4gICAgZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQuaXNMZWFmKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuZW1wdHk7XG4gICAgICAgIGxldCBmb3VuZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMubWVtYmVyc1tpXS5mb3JDaGlsZChvZmZzZXQsIGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gZW1wdHkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRGVjb3JhdGlvbkdyb3VwKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gZm91bmQuY29uY2F0KHJlc3VsdC5tZW1iZXJzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKGZvdW5kKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEZWNvcmF0aW9uR3JvdXApIHx8XG4gICAgICAgICAgICBvdGhlci5tZW1iZXJzLmxlbmd0aCAhPSB0aGlzLm1lbWJlcnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5tZW1iZXJzW2ldLmVxKG90aGVyLm1lbWJlcnNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxvY2Fscyhub2RlKSB7XG4gICAgICAgIGxldCByZXN1bHQsIHNvcnRlZCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbG9jYWxzID0gdGhpcy5tZW1iZXJzW2ldLmxvY2Fsc0lubmVyKG5vZGUpO1xuICAgICAgICAgICAgaWYgKCFsb2NhbHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsb2NhbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsb2NhbHMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxvY2Fsc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlbW92ZU92ZXJsYXAoc29ydGVkID8gcmVzdWx0IDogcmVzdWx0LnNvcnQoYnlQb3MpKSA6IG5vbmU7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIGdyb3VwIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVjb3JhdGlvbiBzZXRzLCBvciByZXR1cm5cbiAgICAvLyBhIHNpbmdsZSBzZXQgd2hlbiBwb3NzaWJsZS5cbiAgICBzdGF0aWMgZnJvbShtZW1iZXJzKSB7XG4gICAgICAgIHN3aXRjaCAobWVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIGVtcHR5O1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbWVtYmVyc1swXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBuZXcgRGVjb3JhdGlvbkdyb3VwKG1lbWJlcnMuZXZlcnkobSA9PiBtIGluc3RhbmNlb2YgRGVjb3JhdGlvblNldCkgPyBtZW1iZXJzIDpcbiAgICAgICAgICAgICAgICBtZW1iZXJzLnJlZHVjZSgociwgbSkgPT4gci5jb25jYXQobSBpbnN0YW5jZW9mIERlY29yYXRpb25TZXQgPyBtIDogbS5tZW1iZXJzKSwgW10pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKG9sZENoaWxkcmVuLCBuZXdMb2NhbCwgbWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSBvbGRDaGlsZHJlbi5zbGljZSgpO1xuICAgIC8vIE1hcmsgdGhlIGNoaWxkcmVuIHRoYXQgYXJlIGRpcmVjdGx5IHRvdWNoZWQgYnkgY2hhbmdlcywgYW5kXG4gICAgLy8gbW92ZSB0aG9zZSB0aGF0IGFyZSBhZnRlciB0aGUgY2hhbmdlcy5cbiAgICBmb3IgKGxldCBpID0gMCwgYmFzZU9mZnNldCA9IG9sZE9mZnNldDsgaSA8IG1hcHBpbmcubWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbW92ZWQgPSAwO1xuICAgICAgICBtYXBwaW5nLm1hcHNbaV0uZm9yRWFjaCgob2xkU3RhcnQsIG9sZEVuZCwgbmV3U3RhcnQsIG5ld0VuZCkgPT4ge1xuICAgICAgICAgICAgbGV0IGRTaXplID0gKG5ld0VuZCAtIG5ld1N0YXJ0KSAtIChvbGRFbmQgLSBvbGRTdGFydCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGNoaWxkcmVuW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kIDwgMCB8fCBvbGRTdGFydCA+IGVuZCArIGJhc2VPZmZzZXQgLSBtb3ZlZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gY2hpbGRyZW5baV0gKyBiYXNlT2Zmc2V0IC0gbW92ZWQ7XG4gICAgICAgICAgICAgICAgaWYgKG9sZEVuZCA+PSBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSBvbGRTdGFydCA8PSBzdGFydCA/IC0yIDogLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld1N0YXJ0ID49IG9mZnNldCAmJiBkU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSArPSBkU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdICs9IGRTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vdmVkICs9IGRTaXplO1xuICAgICAgICB9KTtcbiAgICAgICAgYmFzZU9mZnNldCA9IG1hcHBpbmcubWFwc1tpXS5tYXAoYmFzZU9mZnNldCwgLTEpO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBjaGlsZCBub2RlcyB0aGF0IHN0aWxsIGNvcnJlc3BvbmQgdG8gYSBzaW5nbGUgbm9kZSxcbiAgICAvLyByZWN1cnNpdmVseSBjYWxsIG1hcElubmVyIG9uIHRoZW0gYW5kIHVwZGF0ZSB0aGVpciBwb3NpdGlvbnMuXG4gICAgbGV0IG11c3RSZWJ1aWxkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA8IDApIHsgLy8gVG91Y2hlZCBub2Rlc1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA9PSAtMikge1xuICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSAtMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAob2xkQ2hpbGRyZW5baV0gKyBvbGRPZmZzZXQpLCBmcm9tTG9jYWwgPSBmcm9tIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGZyb21Mb2NhbCA8IDAgfHwgZnJvbUxvY2FsID49IG5vZGUuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTXVzdCByZWFkIG9sZENoaWxkcmVuIGJlY2F1c2UgY2hpbGRyZW4gd2FzIHRhZ2dlZCB3aXRoIC0xXG4gICAgICAgICAgICBsZXQgdG8gPSBtYXBwaW5nLm1hcChvbGRDaGlsZHJlbltpICsgMV0gKyBvbGRPZmZzZXQsIC0xKSwgdG9Mb2NhbCA9IHRvIC0gb2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldDogY2hpbGRPZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgoZnJvbUxvY2FsKTtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSBub2RlLm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE9mZnNldCA9PSBmcm9tTG9jYWwgJiYgY2hpbGRPZmZzZXQgKyBjaGlsZE5vZGUubm9kZVNpemUgPT0gdG9Mb2NhbCkge1xuICAgICAgICAgICAgICAgIGxldCBtYXBwZWQgPSBjaGlsZHJlbltpICsgMl1cbiAgICAgICAgICAgICAgICAgICAgLm1hcElubmVyKG1hcHBpbmcsIGNoaWxkTm9kZSwgZnJvbSArIDEsIG9sZENoaWxkcmVuW2ldICsgb2xkT2Zmc2V0ICsgMSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZCAhPSBlbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSA9IGZyb21Mb2NhbDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gdG9Mb2NhbDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDJdID0gbWFwcGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gLTI7XG4gICAgICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAvLyBSZW1haW5pbmcgY2hpbGRyZW4gbXVzdCBiZSBjb2xsZWN0ZWQgYW5kIHJlYnVpbHQgaW50byB0aGUgYXBwcm9wcmlhdGUgc3RydWN0dXJlXG4gICAgaWYgKG11c3RSZWJ1aWxkKSB7XG4gICAgICAgIGxldCBkZWNvcmF0aW9ucyA9IG1hcEFuZEdhdGhlclJlbWFpbmluZ0RlY29yYXRpb25zKGNoaWxkcmVuLCBvbGRDaGlsZHJlbiwgbmV3TG9jYWwsIG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKTtcbiAgICAgICAgbGV0IGJ1aWx0ID0gYnVpbGRUcmVlKGRlY29yYXRpb25zLCBub2RlLCAwLCBvcHRpb25zKTtcbiAgICAgICAgbmV3TG9jYWwgPSBidWlsdC5sb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltpICsgMV0gPCAwKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDMpO1xuICAgICAgICAgICAgICAgIGkgLT0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgYnVpbHQuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gYnVpbHQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICB3aGlsZSAoaiA8IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlbltqXSA8IGZyb20pXG4gICAgICAgICAgICAgICAgaiArPSAzO1xuICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGosIDAsIGJ1aWx0LmNoaWxkcmVuW2ldLCBidWlsdC5jaGlsZHJlbltpICsgMV0sIGJ1aWx0LmNoaWxkcmVuW2kgKyAyXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uU2V0KG5ld0xvY2FsLnNvcnQoYnlQb3MpLCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBtb3ZlU3BhbnMoc3BhbnMsIG9mZnNldCkge1xuICAgIGlmICghb2Zmc2V0IHx8ICFzcGFucy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBzcGFucztcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgICByZXN1bHQucHVzaChuZXcgRGVjb3JhdGlvbihzcGFuLmZyb20gKyBvZmZzZXQsIHNwYW4udG8gKyBvZmZzZXQsIHNwYW4udHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWFwQW5kR2F0aGVyUmVtYWluaW5nRGVjb3JhdGlvbnMoY2hpbGRyZW4sIG9sZENoaWxkcmVuLCBkZWNvcmF0aW9ucywgbWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIHtcbiAgICAvLyBHYXRoZXIgYWxsIGRlY29yYXRpb25zIGZyb20gdGhlIHJlbWFpbmluZyBtYXJrZWQgY2hpbGRyZW5cbiAgICBmdW5jdGlvbiBnYXRoZXIoc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSBzZXQubG9jYWxbaV0ubWFwKG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChtYXBwZWQpXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaChtYXBwZWQpO1xuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vblJlbW92ZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVtb3ZlKHNldC5sb2NhbFtpXS5zcGVjKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGdhdGhlcihzZXQuY2hpbGRyZW5baSArIDJdLCBzZXQuY2hpbGRyZW5baV0gKyBvbGRPZmZzZXQgKyAxKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA9PSAtMSlcbiAgICAgICAgICAgIGdhdGhlcihjaGlsZHJlbltpICsgMl0sIG9sZENoaWxkcmVuW2ldICsgb2xkT2Zmc2V0ICsgMSk7XG4gICAgcmV0dXJuIGRlY29yYXRpb25zO1xufVxuZnVuY3Rpb24gdGFrZVNwYW5zRm9yTm9kZShzcGFucywgbm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZW5kID0gb2Zmc2V0ICsgbm9kZS5ub2RlU2l6ZSwgZm91bmQgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwLCBzcGFuOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKChzcGFuID0gc3BhbnNbaV0pICYmIHNwYW4uZnJvbSA+IG9mZnNldCAmJiBzcGFuLnRvIDwgZW5kKSB7XG4gICAgICAgICAgICAoZm91bmQgfHwgKGZvdW5kID0gW10pKS5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgc3BhbnNbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIHdpdGhvdXROdWxscyhhcnJheSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYXJyYXlbaV0gIT0gbnVsbClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQnVpbGQgdXAgYSB0cmVlIHRoYXQgY29ycmVzcG9uZHMgdG8gYSBzZXQgb2YgZGVjb3JhdGlvbnMuIGBvZmZzZXRgXG4vLyBpcyBhIGJhc2Ugb2Zmc2V0IHRoYXQgc2hvdWxkIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgYGZyb21gIGFuZCBgdG9gXG4vLyBwb3NpdGlvbnMgaW4gdGhlIHNwYW5zIChzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gYWxsb2NhdGUgbmV3IHNwYW5zXG4vLyBmb3IgcmVjdXJzaXZlIGNhbGxzKS5cbmZ1bmN0aW9uIGJ1aWxkVHJlZShzcGFucywgbm9kZSwgb2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIGhhc051bGxzID0gZmFsc2U7XG4gICAgbm9kZS5mb3JFYWNoKChjaGlsZE5vZGUsIGxvY2FsU3RhcnQpID0+IHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGFrZVNwYW5zRm9yTm9kZShzcGFucywgY2hpbGROb2RlLCBsb2NhbFN0YXJ0ICsgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICBoYXNOdWxscyA9IHRydWU7XG4gICAgICAgICAgICBsZXQgc3VidHJlZSA9IGJ1aWxkVHJlZShmb3VuZCwgY2hpbGROb2RlLCBvZmZzZXQgKyBsb2NhbFN0YXJ0ICsgMSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoc3VidHJlZSAhPSBlbXB0eSlcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGxvY2FsU3RhcnQsIGxvY2FsU3RhcnQgKyBjaGlsZE5vZGUubm9kZVNpemUsIHN1YnRyZWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGxvY2FscyA9IG1vdmVTcGFucyhoYXNOdWxscyA/IHdpdGhvdXROdWxscyhzcGFucykgOiBzcGFucywgLW9mZnNldCkuc29ydChieVBvcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbHMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghbG9jYWxzW2ldLnR5cGUudmFsaWQobm9kZSwgbG9jYWxzW2ldKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25SZW1vdmUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlbW92ZShsb2NhbHNbaV0uc3BlYyk7XG4gICAgICAgICAgICBsb2NhbHMuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbG9jYWxzLmxlbmd0aCB8fCBjaGlsZHJlbi5sZW5ndGggPyBuZXcgRGVjb3JhdGlvblNldChsb2NhbHMsIGNoaWxkcmVuKSA6IGVtcHR5O1xufVxuLy8gVXNlZCB0byBzb3J0IGRlY29yYXRpb25zIHNvIHRoYXQgb25lcyB3aXRoIGEgbG93IHN0YXJ0IHBvc2l0aW9uXG4vLyBjb21lIGZpcnN0LCBhbmQgd2l0aGluIGEgc2V0IHdpdGggdGhlIHNhbWUgc3RhcnQgcG9zaXRpb24sIHRob3NlXG4vLyB3aXRoIGFuIHNtYWxsZXIgZW5kIHBvc2l0aW9uIGNvbWUgZmlyc3QuXG5mdW5jdGlvbiBieVBvcyhhLCBiKSB7XG4gICAgcmV0dXJuIGEuZnJvbSAtIGIuZnJvbSB8fCBhLnRvIC0gYi50bztcbn1cbi8vIFNjYW4gYSBzb3J0ZWQgYXJyYXkgb2YgZGVjb3JhdGlvbnMgZm9yIHBhcnRpYWxseSBvdmVybGFwcGluZyBzcGFucyxcbi8vIGFuZCBzcGxpdCB0aG9zZSBzbyB0aGF0IG9ubHkgZnVsbHkgb3ZlcmxhcHBpbmcgc3BhbnMgYXJlIGxlZnQgKHRvXG4vLyBtYWtlIHN1YnNlcXVlbnQgcmVuZGVyaW5nIGVhc2llcikuIFdpbGwgcmV0dXJuIHRoZSBpbnB1dCBhcnJheSBpZlxuLy8gbm8gcGFydGlhbGx5IG92ZXJsYXBwaW5nIHNwYW5zIGFyZSBmb3VuZCAodGhlIGNvbW1vbiBjYXNlKS5cbmZ1bmN0aW9uIHJlbW92ZU92ZXJsYXAoc3BhbnMpIHtcbiAgICBsZXQgd29ya2luZyA9IHNwYW5zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29ya2luZy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbGV0IHNwYW4gPSB3b3JraW5nW2ldO1xuICAgICAgICBpZiAoc3Bhbi5mcm9tICE9IHNwYW4udG8pXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCB3b3JraW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB3b3JraW5nW2pdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LmZyb20gPT0gc3Bhbi5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LnRvICE9IHNwYW4udG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JraW5nID09IHNwYW5zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmcgPSBzcGFucy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9sbG93ZWQgYnkgYSBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgbGFyZ2VyIHNwYW4uIFNwbGl0IHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwYW4uXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nW2pdID0gbmV4dC5jb3B5KG5leHQuZnJvbSwgc3Bhbi50byk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBaGVhZCh3b3JraW5nLCBqICsgMSwgbmV4dC5jb3B5KHNwYW4udG8sIG5leHQudG8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmZyb20gPCBzcGFuLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod29ya2luZyA9PSBzcGFucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nID0gc3BhbnMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBlbmQgb2YgdGhpcyBvbmUgb3ZlcmxhcHMgd2l0aCBhIHN1YnNlcXVlbnQgc3Bhbi4gU3BsaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1tpXSA9IHNwYW4uY29weShzcGFuLmZyb20sIG5leHQuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBaGVhZCh3b3JraW5nLCBqLCBzcGFuLmNvcHkobmV4dC5mcm9tLCBzcGFuLnRvKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd29ya2luZztcbn1cbmZ1bmN0aW9uIGluc2VydEFoZWFkKGFycmF5LCBpLCBkZWNvKSB7XG4gICAgd2hpbGUgKGkgPCBhcnJheS5sZW5ndGggJiYgYnlQb3MoZGVjbywgYXJyYXlbaV0pID4gMClcbiAgICAgICAgaSsrO1xuICAgIGFycmF5LnNwbGljZShpLCAwLCBkZWNvKTtcbn1cbi8vIEdldCB0aGUgZGVjb3JhdGlvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IHByb3BzIG9mIGEgdmlldy5cbmZ1bmN0aW9uIHZpZXdEZWNvcmF0aW9ucyh2aWV3KSB7XG4gICAgbGV0IGZvdW5kID0gW107XG4gICAgdmlldy5zb21lUHJvcChcImRlY29yYXRpb25zXCIsIGYgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0ID0gZih2aWV3LnN0YXRlKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgIT0gZW1wdHkpXG4gICAgICAgICAgICBmb3VuZC5wdXNoKHJlc3VsdCk7XG4gICAgfSk7XG4gICAgaWYgKHZpZXcuY3Vyc29yV3JhcHBlcilcbiAgICAgICAgZm91bmQucHVzaChEZWNvcmF0aW9uU2V0LmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgW3ZpZXcuY3Vyc29yV3JhcHBlci5kZWNvXSkpO1xuICAgIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShmb3VuZCk7XG59XG5cbmNvbnN0IG9ic2VydmVPcHRpb25zID0ge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWVcbn07XG4vLyBJRTExIGhhcyB2ZXJ5IGJyb2tlbiBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHdlIGFsc28gbGlzdGVuIHRvIERPTUNoYXJhY3RlckRhdGFNb2RpZmllZFxuY29uc3QgdXNlQ2hhckRhdGEgPSBpZSAmJiBpZV92ZXJzaW9uIDw9IDExO1xuY2xhc3MgU2VsZWN0aW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IDA7XG4gICAgfVxuICAgIHNldChzZWwpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gc2VsLmFuY2hvck5vZGU7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gc2VsLmFuY2hvck9mZnNldDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBzZWwuZm9jdXNOb2RlO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICAgIH1cbiAgICBlcShzZWwpIHtcbiAgICAgICAgcmV0dXJuIHNlbC5hbmNob3JOb2RlID09IHRoaXMuYW5jaG9yTm9kZSAmJiBzZWwuYW5jaG9yT2Zmc2V0ID09IHRoaXMuYW5jaG9yT2Zmc2V0ICYmXG4gICAgICAgICAgICBzZWwuZm9jdXNOb2RlID09IHRoaXMuZm9jdXNOb2RlICYmIHNlbC5mb2N1c09mZnNldCA9PSB0aGlzLmZvY3VzT2Zmc2V0O1xuICAgIH1cbn1cbmNsYXNzIERPTU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBoYW5kbGVET01DaGFuZ2UpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5oYW5kbGVET01DaGFuZ2UgPSBoYW5kbGVET01DaGFuZ2U7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb25TdGF0ZTtcbiAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyICYmXG4gICAgICAgICAgICBuZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG11dGF0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgLy8gSUUxMSB3aWxsIHNvbWV0aW1lcyAob24gYmFja3NwYWNpbmcgb3V0IGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIC8vIHRleHQgbm9kZSBhZnRlciBhIEJSIG5vZGUpIGNhbGwgdGhlIG9ic2VydmVyIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlIGFjdHVhbGx5IHVwZGF0aW5nIHRoZSBET00sIHdoaWNoIHdpbGwgY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBQcm9zZU1pcnJvciB0byBtaXNzIHRoZSBjaGFuZ2UgKHNlZSAjOTMwKVxuICAgICAgICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmIG11dGF0aW9ucy5zb21lKG0gPT4gbS50eXBlID09IFwiY2hpbGRMaXN0XCIgJiYgbS5yZW1vdmVkTm9kZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIG0udHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIiAmJiBtLm9sZFZhbHVlLmxlbmd0aCA+IG0udGFyZ2V0Lm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgdGFyZ2V0OiBlLnRhcmdldCwgdHlwZTogXCJjaGFyYWN0ZXJEYXRhXCIsIG9sZFZhbHVlOiBlLnByZXZWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlID0gdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBmbHVzaFNvb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmZsdXNoaW5nU29vbiA8IDApXG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nU29vbiA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTsgdGhpcy5mbHVzaCgpOyB9LCAyMCk7XG4gICAgfVxuICAgIGZvcmNlRmx1c2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZsdXNoaW5nU29vbiA+IC0xKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuZmx1c2hpbmdTb29uKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hpbmdTb29uID0gLTE7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUodGhpcy52aWV3LmRvbSwgb2JzZXJ2ZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9uQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICAgICAgdGhpcy5jb25uZWN0U2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICBsZXQgdGFrZSA9IHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgICAgICAgIGlmICh0YWtlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHRha2VbaV0pO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuZmx1c2goKSwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub25DaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgY29ubmVjdFNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5vd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlldy5kb20ub3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICBzdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKSB7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyA9IGZhbHNlLCA1MCk7XG4gICAgfVxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKCkge1xuICAgICAgICBpZiAoIWhhc0ZvY3VzQW5kU2VsZWN0aW9uKHRoaXMudmlldykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcylcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25Ub0RPTSh0aGlzLnZpZXcpO1xuICAgICAgICAvLyBEZWxldGlvbnMgb24gSUUxMSBmaXJlIHRoZWlyIGV2ZW50cyBpbiB0aGUgd3Jvbmcgb3JkZXIsIGdpdmluZ1xuICAgICAgICAvLyB1cyBhIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQgYmVmb3JlIHRoZSBET00gY2hhbmdlcyBhcmVcbiAgICAgICAgLy8gcmVwb3J0ZWQuXG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmICF0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgc2VsID0gdGhpcy52aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICAvLyBTZWxlY3Rpb24uaXNDb2xsYXBzZWQgaXNuJ3QgcmVsaWFibGUgb24gSUVcbiAgICAgICAgICAgIGlmIChzZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgc2V0Q3VyU2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uc2V0KHRoaXMudmlldy5kb21TZWxlY3Rpb25SYW5nZSgpKTtcbiAgICB9XG4gICAgaWdub3JlU2VsZWN0aW9uQ2hhbmdlKHNlbCkge1xuICAgICAgICBpZiAoIXNlbC5mb2N1c05vZGUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IGFuY2VzdG9ycyA9IG5ldyBTZXQsIGNvbnRhaW5lcjtcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IHNlbC5mb2N1c05vZGU7IHNjYW47IHNjYW4gPSBwYXJlbnROb2RlKHNjYW4pKVxuICAgICAgICAgICAgYW5jZXN0b3JzLmFkZChzY2FuKTtcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IHNlbC5hbmNob3JOb2RlOyBzY2FuOyBzY2FuID0gcGFyZW50Tm9kZShzY2FuKSlcbiAgICAgICAgICAgIGlmIChhbmNlc3RvcnMuaGFzKHNjYW4pKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gc2NhbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IGRlc2MgPSBjb250YWluZXIgJiYgdGhpcy52aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoY29udGFpbmVyKTtcbiAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5pZ25vcmVNdXRhdGlvbih7XG4gICAgICAgICAgICB0eXBlOiBcInNlbGVjdGlvblwiLFxuICAgICAgICAgICAgdGFyZ2V0OiBjb250YWluZXIubm9kZVR5cGUgPT0gMyA/IGNvbnRhaW5lci5wYXJlbnROb2RlIDogY29udGFpbmVyXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgICB0aGlzLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGVuZGluZ1JlY29yZHMoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKVxuICAgICAgICAgICAgZm9yIChsZXQgbXV0IG9mIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSlcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWU7XG4gICAgfVxuICAgIGZsdXNoKCkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXZpZXcuZG9jVmlldyB8fCB0aGlzLmZsdXNoaW5nU29vbiA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbXV0YXRpb25zID0gdGhpcy5wZW5kaW5nUmVjb3JkcygpO1xuICAgICAgICBpZiAobXV0YXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IG5ld1NlbCA9ICF0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyAmJiAhdGhpcy5jdXJyZW50U2VsZWN0aW9uLmVxKHNlbCkgJiYgaGFzRm9jdXNBbmRTZWxlY3Rpb24odmlldykgJiYgIXRoaXMuaWdub3JlU2VsZWN0aW9uQ2hhbmdlKHNlbCk7XG4gICAgICAgIGxldCBmcm9tID0gLTEsIHRvID0gLTEsIHR5cGVPdmVyID0gZmFsc2UsIGFkZGVkID0gW107XG4gICAgICAgIGlmICh2aWV3LmVkaXRhYmxlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnJlZ2lzdGVyTXV0YXRpb24obXV0YXRpb25zW2ldLCBhZGRlZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gZnJvbSA8IDAgPyByZXN1bHQuZnJvbSA6IE1hdGgubWluKHJlc3VsdC5mcm9tLCBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSB0byA8IDAgPyByZXN1bHQudG8gOiBNYXRoLm1heChyZXN1bHQudG8sIHRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlT3ZlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVPdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlY2tvICYmIGFkZGVkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCBicnMgPSBhZGRlZC5maWx0ZXIobiA9PiBuLm5vZGVOYW1lID09IFwiQlJcIik7XG4gICAgICAgICAgICBpZiAoYnJzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGEgPSBicnNbMF0sIGIgPSBicnNbMV07XG4gICAgICAgICAgICAgICAgaWYgKGEucGFyZW50Tm9kZSAmJiBhLnBhcmVudE5vZGUucGFyZW50Tm9kZSA9PSBiLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBhLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZWFkU2VsID0gbnVsbDtcbiAgICAgICAgLy8gSWYgaXQgbG9va3MgbGlrZSB0aGUgYnJvd3NlciBoYXMgcmVzZXQgdGhlIHNlbGVjdGlvbiB0byB0aGVcbiAgICAgICAgLy8gc3RhcnQgb2YgdGhlIGRvY3VtZW50IGFmdGVyIGZvY3VzLCByZXN0b3JlIHRoZSBzZWxlY3Rpb24gZnJvbVxuICAgICAgICAvLyB0aGUgc3RhdGVcbiAgICAgICAgaWYgKGZyb20gPCAwICYmIG5ld1NlbCAmJiB2aWV3LmlucHV0Lmxhc3RGb2N1cyA+IERhdGUubm93KCkgLSAyMDAgJiZcbiAgICAgICAgICAgIE1hdGgubWF4KHZpZXcuaW5wdXQubGFzdFRvdWNoLCB2aWV3LmlucHV0Lmxhc3RDbGljay50aW1lKSA8IERhdGUubm93KCkgLSAzMDAgJiZcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbGxhcHNlZChzZWwpICYmIChyZWFkU2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3KSkgJiZcbiAgICAgICAgICAgIHJlYWRTZWwuZXEoU2VsZWN0aW9uLm5lYXIodmlldy5zdGF0ZS5kb2MucmVzb2x2ZSgwKSwgMSkpKSB7XG4gICAgICAgICAgICB2aWV3LmlucHV0Lmxhc3RGb2N1cyA9IDA7XG4gICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQoc2VsKTtcbiAgICAgICAgICAgIHZpZXcuc2Nyb2xsVG9TZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcm9tID4gLTEgfHwgbmV3U2VsKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdmlldy5kb2NWaWV3Lm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgY2hlY2tDU1Modmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURPTUNoYW5nZShmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKTtcbiAgICAgICAgICAgIGlmICh2aWV3LmRvY1ZpZXcgJiYgdmlldy5kb2NWaWV3LmRpcnR5KVxuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlU3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jdXJyZW50U2VsZWN0aW9uLmVxKHNlbCkpXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uc2V0KHNlbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJNdXRhdGlvbihtdXQsIGFkZGVkKSB7XG4gICAgICAgIC8vIElnbm9yZSBtdXRhdGlvbnMgaW5zaWRlIG5vZGVzIHRoYXQgd2VyZSBhbHJlYWR5IG5vdGVkIGFzIGluc2VydGVkXG4gICAgICAgIGlmIChhZGRlZC5pbmRleE9mKG11dC50YXJnZXQpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGRlc2MgPSB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhtdXQudGFyZ2V0KTtcbiAgICAgICAgaWYgKG11dC50eXBlID09IFwiYXR0cmlidXRlc1wiICYmXG4gICAgICAgICAgICAoZGVzYyA9PSB0aGlzLnZpZXcuZG9jVmlldyB8fCBtdXQuYXR0cmlidXRlTmFtZSA9PSBcImNvbnRlbnRlZGl0YWJsZVwiIHx8XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBzb21ldGltZXMgZmlyZXMgc3B1cmlvdXMgZXZlbnRzIGZvciBudWxsL2VtcHR5IHN0eWxlc1xuICAgICAgICAgICAgICAgIChtdXQuYXR0cmlidXRlTmFtZSA9PSBcInN0eWxlXCIgJiYgIW11dC5vbGRWYWx1ZSAmJiAhbXV0LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSkpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghZGVzYyB8fCBkZXNjLmlnbm9yZU11dGF0aW9uKG11dCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKG11dC50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0LmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgYWRkZWQucHVzaChtdXQuYWRkZWROb2Rlc1tpXSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5jb250ZW50RE9NICYmIGRlc2MuY29udGVudERPTSAhPSBkZXNjLmRvbSAmJiAhZGVzYy5jb250ZW50RE9NLmNvbnRhaW5zKG11dC50YXJnZXQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGZyb206IGRlc2MucG9zQmVmb3JlLCB0bzogZGVzYy5wb3NBZnRlciB9O1xuICAgICAgICAgICAgbGV0IHByZXYgPSBtdXQucHJldmlvdXNTaWJsaW5nLCBuZXh0ID0gbXV0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgbXV0LmFkZGVkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gSUUxMSBnaXZlcyB1cyBpbmNvcnJlY3QgbmV4dC9wcmV2IHNpYmxpbmdzIGZvciBzb21lXG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0aW9ucywgc28gaWYgdGhlcmUgYXJlIGFkZGVkIG5vZGVzLCByZWNvbXB1dGUgdGhvc2VcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dC5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHByZXZpb3VzU2libGluZywgbmV4dFNpYmxpbmcgfSA9IG11dC5hZGRlZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXZpb3VzU2libGluZyB8fCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKG11dC5hZGRlZE5vZGVzLCBwcmV2aW91c1NpYmxpbmcpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBwcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dFNpYmxpbmcgfHwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChtdXQuYWRkZWROb2RlcywgbmV4dFNpYmxpbmcpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZnJvbU9mZnNldCA9IHByZXYgJiYgcHJldi5wYXJlbnROb2RlID09IG11dC50YXJnZXRcbiAgICAgICAgICAgICAgICA/IGRvbUluZGV4KHByZXYpICsgMSA6IDA7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGRlc2MubG9jYWxQb3NGcm9tRE9NKG11dC50YXJnZXQsIGZyb21PZmZzZXQsIC0xKTtcbiAgICAgICAgICAgIGxldCB0b09mZnNldCA9IG5leHQgJiYgbmV4dC5wYXJlbnROb2RlID09IG11dC50YXJnZXRcbiAgICAgICAgICAgICAgICA/IGRvbUluZGV4KG5leHQpIDogbXV0LnRhcmdldC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCB0byA9IGRlc2MubG9jYWxQb3NGcm9tRE9NKG11dC50YXJnZXQsIHRvT2Zmc2V0LCAxKTtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb20sIHRvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXV0LnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb206IGRlc2MucG9zQXRTdGFydCAtIGRlc2MuYm9yZGVyLCB0bzogZGVzYy5wb3NBdEVuZCArIGRlc2MuYm9yZGVyIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIFwiY2hhcmFjdGVyRGF0YVwiXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IGRlc2MucG9zQXRTdGFydCxcbiAgICAgICAgICAgICAgICB0bzogZGVzYy5wb3NBdEVuZCxcbiAgICAgICAgICAgICAgICAvLyBBbiBldmVudCB3YXMgZ2VuZXJhdGVkIGZvciBhIHRleHQgY2hhbmdlIHRoYXQgZGlkbid0IGNoYW5nZVxuICAgICAgICAgICAgICAgIC8vIGFueSB0ZXh0LiBNYXJrIHRoZSBkb20gY2hhbmdlIHRvIGZhbGwgYmFjayB0byBhc3N1bWluZyB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3Rpb24gd2FzIHR5cGVkIG92ZXIgd2l0aCBhbiBpZGVudGljYWwgdmFsdWUgaWYgaXQgY2FuJ3RcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGFub3RoZXIgY2hhbmdlLlxuICAgICAgICAgICAgICAgIHR5cGVPdmVyOiBtdXQudGFyZ2V0Lm5vZGVWYWx1ZSA9PSBtdXQub2xkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5sZXQgY3NzQ2hlY2tlZCA9IG5ldyBXZWFrTWFwKCk7XG5sZXQgY3NzQ2hlY2tXYXJuZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGNoZWNrQ1NTKHZpZXcpIHtcbiAgICBpZiAoY3NzQ2hlY2tlZC5oYXModmlldykpXG4gICAgICAgIHJldHVybjtcbiAgICBjc3NDaGVja2VkLnNldCh2aWV3LCBudWxsKTtcbiAgICBpZiAoWydub3JtYWwnLCAnbm93cmFwJywgJ3ByZS1saW5lJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKHZpZXcuZG9tKS53aGl0ZVNwYWNlKSAhPT0gLTEpIHtcbiAgICAgICAgdmlldy5yZXF1aXJlc0dlY2tvSGFja05vZGUgPSBnZWNrbztcbiAgICAgICAgaWYgKGNzc0NoZWNrV2FybmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlW1wid2FyblwiXShcIlByb3NlTWlycm9yIGV4cGVjdHMgdGhlIENTUyB3aGl0ZS1zcGFjZSBwcm9wZXJ0eSB0byBiZSBzZXQsIHByZWZlcmFibHkgdG8gJ3ByZS13cmFwJy4gSXQgaXMgcmVjb21tZW5kZWQgdG8gbG9hZCBzdHlsZS9wcm9zZW1pcnJvci5jc3MgZnJvbSB0aGUgcHJvc2VtaXJyb3ItdmlldyBwYWNrYWdlLlwiKTtcbiAgICAgICAgY3NzQ2hlY2tXYXJuZWQgPSB0cnVlO1xuICAgIH1cbn1cbi8vIFVzZWQgdG8gd29yayBhcm91bmQgYSBTYWZhcmkgU2VsZWN0aW9uL3NoYWRvdyBET00gYnVnXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9kZXYvaXNzdWVzLzQxNCBmaXhcbmZ1bmN0aW9uIHNhZmFyaVNoYWRvd1NlbGVjdGlvblJhbmdlKHZpZXcpIHtcbiAgICBsZXQgZm91bmQ7XG4gICAgZnVuY3Rpb24gcmVhZChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZm91bmQgPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKVswXTtcbiAgICB9XG4gICAgLy8gQmVjYXVzZSBTYWZhcmkgKGF0IGxlYXN0IGluIDIwMTgtMjAyMikgZG9lc24ndCBwcm92aWRlIHJlZ3VsYXJcbiAgICAvLyBhY2Nlc3MgdG8gdGhlIHNlbGVjdGlvbiBpbnNpZGUgYSBzaGFkb3dSb290LCB3ZSBoYXZlIHRvIHBlcmZvcm0gYVxuICAgIC8vIHJpZGljdWxvdXMgaGFjayB0byBnZXQgYXQgaXRcdTIwMTR1c2luZyBgZXhlY0NvbW1hbmRgIHRvIHRyaWdnZXIgYVxuICAgIC8vIGBiZWZvcmVJbnB1dGAgZXZlbnQgc28gdGhhdCB3ZSBjYW4gcmVhZCB0aGUgdGFyZ2V0IHJhbmdlIGZyb20gdGhlXG4gICAgLy8gZXZlbnQuXG4gICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiaW5kZW50XCIpO1xuICAgIHZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCByZWFkLCB0cnVlKTtcbiAgICBsZXQgYW5jaG9yTm9kZSA9IGZvdW5kLnN0YXJ0Q29udGFpbmVyLCBhbmNob3JPZmZzZXQgPSBmb3VuZC5zdGFydE9mZnNldDtcbiAgICBsZXQgZm9jdXNOb2RlID0gZm91bmQuZW5kQ29udGFpbmVyLCBmb2N1c09mZnNldCA9IGZvdW5kLmVuZE9mZnNldDtcbiAgICBsZXQgY3VycmVudEFuY2hvciA9IHZpZXcuZG9tQXRQb3Modmlldy5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yKTtcbiAgICAvLyBTaW5jZSBzdWNoIGEgcmFuZ2UgZG9lc24ndCBkaXN0aW5ndWlzaCBiZXR3ZWVuIGFuY2hvciBhbmQgaGVhZCxcbiAgICAvLyB1c2UgYSBoZXVyaXN0aWMgdGhhdCBmbGlwcyBpdCBhcm91bmQgaWYgaXRzIGVuZCBtYXRjaGVzIHRoZVxuICAgIC8vIGN1cnJlbnQgYW5jaG9yLlxuICAgIGlmIChpc0VxdWl2YWxlbnRQb3NpdGlvbihjdXJyZW50QW5jaG9yLm5vZGUsIGN1cnJlbnRBbmNob3Iub2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSlcbiAgICAgICAgW2FuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldF0gPSBbZm9jdXNOb2RlLCBmb2N1c09mZnNldCwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0XTtcbiAgICByZXR1cm4geyBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQgfTtcbn1cblxuLy8gTm90ZSB0aGF0IGFsbCByZWZlcmVuY2luZyBhbmQgcGFyc2luZyBpcyBkb25lIHdpdGggdGhlXG4vLyBzdGFydC1vZi1vcGVyYXRpb24gc2VsZWN0aW9uIGFuZCBkb2N1bWVudCwgc2luY2UgdGhhdCdzIHRoZSBvbmVcbi8vIHRoYXQgdGhlIERPTSByZXByZXNlbnRzLiBJZiBhbnkgY2hhbmdlcyBjYW1lIGluIGluIHRoZSBtZWFudGltZSxcbi8vIHRoZSBtb2RpZmljYXRpb24gaXMgbWFwcGVkIG92ZXIgdGhvc2UgYmVmb3JlIGl0IGlzIGFwcGxpZWQsIGluXG4vLyByZWFkRE9NQ2hhbmdlLlxuZnVuY3Rpb24gcGFyc2VCZXR3ZWVuKHZpZXcsIGZyb21fLCB0b18pIHtcbiAgICBsZXQgeyBub2RlOiBwYXJlbnQsIGZyb21PZmZzZXQsIHRvT2Zmc2V0LCBmcm9tLCB0byB9ID0gdmlldy5kb2NWaWV3LnBhcnNlUmFuZ2UoZnJvbV8sIHRvXyk7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgZmluZDtcbiAgICBsZXQgYW5jaG9yID0gZG9tU2VsLmFuY2hvck5vZGU7XG4gICAgaWYgKGFuY2hvciAmJiB2aWV3LmRvbS5jb250YWlucyhhbmNob3Iubm9kZVR5cGUgPT0gMSA/IGFuY2hvciA6IGFuY2hvci5wYXJlbnROb2RlKSkge1xuICAgICAgICBmaW5kID0gW3sgbm9kZTogYW5jaG9yLCBvZmZzZXQ6IGRvbVNlbC5hbmNob3JPZmZzZXQgfV07XG4gICAgICAgIGlmICghc2VsZWN0aW9uQ29sbGFwc2VkKGRvbVNlbCkpXG4gICAgICAgICAgICBmaW5kLnB1c2goeyBub2RlOiBkb21TZWwuZm9jdXNOb2RlLCBvZmZzZXQ6IGRvbVNlbC5mb2N1c09mZnNldCB9KTtcbiAgICB9XG4gICAgLy8gV29yayBhcm91bmQgaXNzdWUgaW4gQ2hyb21lIHdoZXJlIGJhY2tzcGFjaW5nIHNvbWV0aW1lcyByZXBsYWNlc1xuICAgIC8vIHRoZSBkZWxldGVkIGNvbnRlbnQgd2l0aCBhIHJhbmRvbSBCUiBub2RlIChpc3N1ZXMgIzc5OSwgIzgzMSlcbiAgICBpZiAoY2hyb21lICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT09IDgpIHtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gdG9PZmZzZXQ7IG9mZiA+IGZyb21PZmZzZXQ7IG9mZi0tKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHBhcmVudC5jaGlsZE5vZGVzW29mZiAtIDFdLCBkZXNjID0gbm9kZS5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJCUlwiICYmICFkZXNjKSB7XG4gICAgICAgICAgICAgICAgdG9PZmZzZXQgPSBvZmY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgZGVzYy5zaXplKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdGFydERvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgIGxldCBwYXJzZXIgPSB2aWV3LnNvbWVQcm9wKFwiZG9tUGFyc2VyXCIpIHx8IERPTVBhcnNlci5mcm9tU2NoZW1hKHZpZXcuc3RhdGUuc2NoZW1hKTtcbiAgICBsZXQgJGZyb20gPSBzdGFydERvYy5yZXNvbHZlKGZyb20pO1xuICAgIGxldCBzZWwgPSBudWxsLCBkb2MgPSBwYXJzZXIucGFyc2UocGFyZW50LCB7XG4gICAgICAgIHRvcE5vZGU6ICRmcm9tLnBhcmVudCxcbiAgICAgICAgdG9wTWF0Y2g6ICRmcm9tLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleCgpKSxcbiAgICAgICAgdG9wT3BlbjogdHJ1ZSxcbiAgICAgICAgZnJvbTogZnJvbU9mZnNldCxcbiAgICAgICAgdG86IHRvT2Zmc2V0LFxuICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICRmcm9tLnBhcmVudC50eXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIiA/IFwiZnVsbFwiIDogdHJ1ZSxcbiAgICAgICAgZmluZFBvc2l0aW9uczogZmluZCxcbiAgICAgICAgcnVsZUZyb21Ob2RlLFxuICAgICAgICBjb250ZXh0OiAkZnJvbVxuICAgIH0pO1xuICAgIGlmIChmaW5kICYmIGZpbmRbMF0ucG9zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGFuY2hvciA9IGZpbmRbMF0ucG9zLCBoZWFkID0gZmluZFsxXSAmJiBmaW5kWzFdLnBvcztcbiAgICAgICAgaWYgKGhlYWQgPT0gbnVsbClcbiAgICAgICAgICAgIGhlYWQgPSBhbmNob3I7XG4gICAgICAgIHNlbCA9IHsgYW5jaG9yOiBhbmNob3IgKyBmcm9tLCBoZWFkOiBoZWFkICsgZnJvbSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBkb2MsIHNlbCwgZnJvbSwgdG8gfTtcbn1cbmZ1bmN0aW9uIHJ1bGVGcm9tTm9kZShkb20pIHtcbiAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgIGlmIChkZXNjKSB7XG4gICAgICAgIHJldHVybiBkZXNjLnBhcnNlUnVsZSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmIGRvbS5wYXJlbnROb2RlKSB7XG4gICAgICAgIC8vIFNhZmFyaSByZXBsYWNlcyB0aGUgbGlzdCBpdGVtIG9yIHRhYmxlIGNlbGwgd2l0aCBhIEJSXG4gICAgICAgIC8vIGRpcmVjdGx5IGluIHRoZSBsaXN0IG5vZGUgKD8hKSBpZiB5b3UgZGVsZXRlIHRoZSBsYXN0XG4gICAgICAgIC8vIGNoYXJhY3RlciBpbiBhIGxpc3QgaXRlbSBvciB0YWJsZSBjZWxsICgjNzA4LCAjODYyKVxuICAgICAgICBpZiAoc2FmYXJpICYmIC9eKHVsfG9sKSQvaS50ZXN0KGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgbGV0IHNraXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgc2tpcC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHsgc2tpcCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvbS5wYXJlbnROb2RlLmxhc3RDaGlsZCA9PSBkb20gfHwgc2FmYXJpICYmIC9eKHRyfHRhYmxlKSQvaS50ZXN0KGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZG9tLm5vZGVOYW1lID09IFwiSU1HXCIgJiYgZG9tLmdldEF0dHJpYnV0ZShcIm1hcmstcGxhY2Vob2xkZXJcIikpIHtcbiAgICAgICAgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgaXNJbmxpbmUgPSAvXihhfGFiYnJ8YWNyb255bXxifGJkW2lvXXxiaWd8YnJ8YnV0dG9ufGNpdGV8Y29kZXxkYXRhKGxpc3QpP3xkZWx8ZGZufGVtfGl8aW5zfGtiZHxsYWJlbHxtYXB8bWFya3xtZXRlcnxvdXRwdXR8cXxydWJ5fHN8c2FtcHxzbWFsbHxzcGFufHN0cm9uZ3xzdVticF18dGltZXx1fHR0fHZhcikkL2k7XG5mdW5jdGlvbiByZWFkRE9NQ2hhbmdlKHZpZXcsIGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWROb2Rlcykge1xuICAgIGxldCBjb21wb3NpdGlvbklEID0gdmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzIHx8ICh2aWV3LmNvbXBvc2luZyA/IHZpZXcuaW5wdXQuY29tcG9zaXRpb25JRCA6IDApO1xuICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcyA9IDA7XG4gICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgIGxldCBvcmlnaW4gPSB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwID8gdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uT3JpZ2luIDogbnVsbDtcbiAgICAgICAgbGV0IG5ld1NlbCA9IHNlbGVjdGlvbkZyb21ET00odmlldywgb3JpZ2luKTtcbiAgICAgICAgaWYgKG5ld1NlbCAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24uZXEobmV3U2VsKSkge1xuICAgICAgICAgICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkICYmXG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9PT0gMTMgJiYgRGF0ZS5ub3coKSAtIDEwMCA8IHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lICYmXG4gICAgICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3U2VsKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW4gPT0gXCJwb2ludGVyXCIpXG4gICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcInBvaW50ZXJcIiwgdHJ1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChvcmlnaW4gPT0gXCJrZXlcIilcbiAgICAgICAgICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uSUQpXG4gICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcImNvbXBvc2l0aW9uXCIsIGNvbXBvc2l0aW9uSUQpO1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgJGJlZm9yZSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgbGV0IHNoYXJlZCA9ICRiZWZvcmUuc2hhcmVkRGVwdGgodG8pO1xuICAgIGZyb20gPSAkYmVmb3JlLmJlZm9yZShzaGFyZWQgKyAxKTtcbiAgICB0byA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUodG8pLmFmdGVyKHNoYXJlZCArIDEpO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgcGFyc2UgPSBwYXJzZUJldHdlZW4odmlldywgZnJvbSwgdG8pO1xuICAgIGxldCBkb2MgPSB2aWV3LnN0YXRlLmRvYywgY29tcGFyZSA9IGRvYy5zbGljZShwYXJzZS5mcm9tLCBwYXJzZS50byk7XG4gICAgbGV0IHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZTtcbiAgICAvLyBQcmVmZXIgYW5jaG9yaW5nIHRvIGVuZCB3aGVuIEJhY2tzcGFjZSBpcyBwcmVzc2VkXG4gICAgaWYgKHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT09IDggJiYgRGF0ZS5ub3coKSAtIDEwMCA8IHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lKSB7XG4gICAgICAgIHByZWZlcnJlZFBvcyA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvO1xuICAgICAgICBwcmVmZXJyZWRTaWRlID0gXCJlbmRcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHByZWZlcnJlZFBvcyA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb207XG4gICAgICAgIHByZWZlcnJlZFNpZGUgPSBcInN0YXJ0XCI7XG4gICAgfVxuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPSBudWxsO1xuICAgIGxldCBjaGFuZ2UgPSBmaW5kRGlmZihjb21wYXJlLmNvbnRlbnQsIHBhcnNlLmRvYy5jb250ZW50LCBwYXJzZS5mcm9tLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpO1xuICAgIGlmICgoaW9zICYmIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSB8fCBhbmRyb2lkKSAmJlxuICAgICAgICBhZGRlZE5vZGVzLnNvbWUobiA9PiBuLm5vZGVUeXBlID09IDEgJiYgIWlzSW5saW5lLnRlc3Qobi5ub2RlTmFtZSkpICYmXG4gICAgICAgICghY2hhbmdlIHx8IGNoYW5nZS5lbmRBID49IGNoYW5nZS5lbmRCKSAmJlxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKSkge1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVPdmVyICYmIHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgIXNlbC5lbXB0eSAmJiBzZWwuJGhlYWQuc2FtZVBhcmVudChzZWwuJGFuY2hvcikgJiZcbiAgICAgICAgICAgICF2aWV3LmNvbXBvc2luZyAmJiAhKHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yICE9IHBhcnNlLnNlbC5oZWFkKSkge1xuICAgICAgICAgICAgY2hhbmdlID0geyBzdGFydDogc2VsLmZyb20sIGVuZEE6IHNlbC50bywgZW5kQjogc2VsLnRvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocGFyc2Uuc2VsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IHJlc29sdmVTZWxlY3Rpb24odmlldywgdmlldy5zdGF0ZS5kb2MsIHBhcnNlLnNlbCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbCAmJiAhc2VsLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9zaXRpb25JRClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldE1ldGEoXCJjb21wb3NpdGlvblwiLCBjb21wb3NpdGlvbklEKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENocm9tZSBzb21ldGltZXMgbGVhdmVzIHRoZSBjdXJzb3IgYmVmb3JlIHRoZSBpbnNlcnRlZCB0ZXh0IHdoZW5cbiAgICAvLyBjb21wb3NpbmcgYWZ0ZXIgYSBjdXJzb3Igd3JhcHBlci4gVGhpcyBtb3ZlcyBpdCBmb3J3YXJkLlxuICAgIGlmIChjaHJvbWUgJiYgdmlldy5jdXJzb3JXcmFwcGVyICYmIHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yID09IHZpZXcuY3Vyc29yV3JhcHBlci5kZWNvLmZyb20gJiZcbiAgICAgICAgcGFyc2Uuc2VsLmhlYWQgPT0gcGFyc2Uuc2VsLmFuY2hvcikge1xuICAgICAgICBsZXQgc2l6ZSA9IGNoYW5nZS5lbmRCIC0gY2hhbmdlLnN0YXJ0O1xuICAgICAgICBwYXJzZS5zZWwgPSB7IGFuY2hvcjogcGFyc2Uuc2VsLmFuY2hvciArIHNpemUsIGhlYWQ6IHBhcnNlLnNlbC5hbmNob3IgKyBzaXplIH07XG4gICAgfVxuICAgIHZpZXcuaW5wdXQuZG9tQ2hhbmdlQ291bnQrKztcbiAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgb3ZlcndyaXRpbmcgYSBzZWxlY3Rpb24gYnkgdHlwaW5nIG1hdGNoZXNcbiAgICAvLyB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBzZWxlY3RlZCBjb250ZW50LCBjcmVhdGluZyBhIGNoYW5nZVxuICAgIC8vIHRoYXQncyBzbWFsbGVyIHRoYW4gd2hhdCB3YXMgYWN0dWFsbHkgb3ZlcndyaXR0ZW4uXG4gICAgaWYgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gPCB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAmJlxuICAgICAgICBjaGFuZ2Uuc3RhcnQgPT0gY2hhbmdlLmVuZEIgJiZcbiAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChjaGFuZ2Uuc3RhcnQgPiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tICYmIGNoYW5nZS5zdGFydCA8PSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tICsgMiAmJlxuICAgICAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+PSBwYXJzZS5mcm9tKSB7XG4gICAgICAgICAgICBjaGFuZ2Uuc3RhcnQgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS5lbmRBIDwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gJiYgY2hhbmdlLmVuZEEgPj0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gLSAyICYmXG4gICAgICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byA8PSBwYXJzZS50bykge1xuICAgICAgICAgICAgY2hhbmdlLmVuZEIgKz0gKHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIC0gY2hhbmdlLmVuZEEpO1xuICAgICAgICAgICAgY2hhbmdlLmVuZEEgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50bztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJRTExIHdpbGwgaW5zZXJ0IGEgbm9uLWJyZWFraW5nIHNwYWNlIF9haGVhZF8gb2YgdGhlIHNwYWNlIGFmdGVyXG4gICAgLy8gdGhlIGN1cnNvciBzcGFjZSB3aGVuIGFkZGluZyBhIHNwYWNlIGJlZm9yZSBhbm90aGVyIHNwYWNlLiBXaGVuXG4gICAgLy8gdGhhdCBoYXBwZW5lZCwgYWRqdXN0IHRoZSBjaGFuZ2UgdG8gY292ZXIgdGhlIHNwYWNlIGluc3RlYWQuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgY2hhbmdlLmVuZEIgPT0gY2hhbmdlLnN0YXJ0ICsgMSAmJlxuICAgICAgICBjaGFuZ2UuZW5kQSA9PSBjaGFuZ2Uuc3RhcnQgJiYgY2hhbmdlLnN0YXJ0ID4gcGFyc2UuZnJvbSAmJlxuICAgICAgICBwYXJzZS5kb2MudGV4dEJldHdlZW4oY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSAtIDEsIGNoYW5nZS5zdGFydCAtIHBhcnNlLmZyb20gKyAxKSA9PSBcIiBcXHUwMGEwXCIpIHtcbiAgICAgICAgY2hhbmdlLnN0YXJ0LS07XG4gICAgICAgIGNoYW5nZS5lbmRBLS07XG4gICAgICAgIGNoYW5nZS5lbmRCLS07XG4gICAgfVxuICAgIGxldCAkZnJvbSA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tKTtcbiAgICBsZXQgJHRvID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSk7XG4gICAgbGV0ICRmcm9tQSA9IGRvYy5yZXNvbHZlKGNoYW5nZS5zdGFydCk7XG4gICAgbGV0IGlubGluZUNoYW5nZSA9ICRmcm9tLnNhbWVQYXJlbnQoJHRvKSAmJiAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCAmJiAkZnJvbUEuZW5kKCkgPj0gY2hhbmdlLmVuZEE7XG4gICAgbGV0IG5leHRTZWw7XG4gICAgLy8gSWYgdGhpcyBsb29rcyBsaWtlIHRoZSBlZmZlY3Qgb2YgcHJlc3NpbmcgRW50ZXIgKG9yIHdhcyByZWNvcmRlZFxuICAgIC8vIGFzIGJlaW5nIGFuIGlPUyBlbnRlciBwcmVzcyksIGp1c3QgZGlzcGF0Y2ggYW4gRW50ZXIga2V5IGluc3RlYWQuXG4gICAgaWYgKCgoaW9zICYmIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSAmJlxuICAgICAgICAoIWlubGluZUNoYW5nZSB8fCBhZGRlZE5vZGVzLnNvbWUobiA9PiBuLm5vZGVOYW1lID09IFwiRElWXCIgfHwgbi5ub2RlTmFtZSA9PSBcIlBcIikpKSB8fFxuICAgICAgICAoIWlubGluZUNoYW5nZSAmJiAkZnJvbS5wb3MgPCBwYXJzZS5kb2MuY29udGVudC5zaXplICYmICEkZnJvbS5zYW1lUGFyZW50KCR0bykgJiZcbiAgICAgICAgICAgIChuZXh0U2VsID0gU2VsZWN0aW9uLmZpbmRGcm9tKHBhcnNlLmRvYy5yZXNvbHZlKCRmcm9tLnBvcyArIDEpLCAxLCB0cnVlKSkgJiZcbiAgICAgICAgICAgIG5leHRTZWwuaGVhZCA9PSAkdG8ucG9zKSkgJiZcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpIHtcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFNhbWUgZm9yIGJhY2tzcGFjZVxuICAgIGlmICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IgPiBjaGFuZ2Uuc3RhcnQgJiZcbiAgICAgICAgbG9va3NMaWtlSm9pbihkb2MsIGNoYW5nZS5zdGFydCwgY2hhbmdlLmVuZEEsICRmcm9tLCAkdG8pICYmXG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCg4LCBcIkJhY2tzcGFjZVwiKSkpKSB7XG4gICAgICAgIGlmIChhbmRyb2lkICYmIGNocm9tZSlcbiAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCk7IC8vICM4MjBcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDaHJvbWUgQW5kcm9pZCB3aWxsIG9jY2FzaW9uYWxseSwgZHVyaW5nIGNvbXBvc2l0aW9uLCBkZWxldGUgdGhlXG4gICAgLy8gZW50aXJlIGNvbXBvc2l0aW9uIGFuZCB0aGVuIGltbWVkaWF0ZWx5IGluc2VydCBpdCBhZ2Fpbi4gVGhpcyBpc1xuICAgIC8vIHVzZWQgdG8gZGV0ZWN0IHRoYXQgc2l0dWF0aW9uLlxuICAgIGlmIChjaHJvbWUgJiYgYW5kcm9pZCAmJiBjaGFuZ2UuZW5kQiA9PSBjaGFuZ2Uuc3RhcnQpXG4gICAgICAgIHZpZXcuaW5wdXQubGFzdEFuZHJvaWREZWxldGUgPSBEYXRlLm5vdygpO1xuICAgIC8vIFRoaXMgdHJpZXMgdG8gZGV0ZWN0IEFuZHJvaWQgdmlydHVhbCBrZXlib2FyZFxuICAgIC8vIGVudGVyLWFuZC1waWNrLXN1Z2dlc3Rpb24gYWN0aW9uLiBUaGF0IHNvbWV0aW1lcyAoc2VlIGlzc3VlXG4gICAgLy8gIzEwNTkpIGZpcnN0IGZpcmVzIGEgRE9NIG11dGF0aW9uLCBiZWZvcmUgbW92aW5nIHRoZSBzZWxlY3Rpb24gdG9cbiAgICAvLyB0aGUgbmV3bHkgY3JlYXRlZCBibG9jay4gQW5kIHRoZW4sIGJlY2F1c2UgUHJvc2VNaXJyb3IgY2xlYW5zIHVwXG4gICAgLy8gdGhlIERPTSBzZWxlY3Rpb24sIGl0IGdpdmVzIHVwIG1vdmluZyB0aGUgc2VsZWN0aW9uIGVudGlyZWx5LFxuICAgIC8vIGxlYXZpbmcgdGhlIGN1cnNvciBpbiB0aGUgd3JvbmcgcGxhY2UuIFdoZW4gdGhhdCBoYXBwZW5zLCB3ZSBkcm9wXG4gICAgLy8gdGhlIG5ldyBwYXJhZ3JhcGggZnJvbSB0aGUgaW5pdGlhbCBjaGFuZ2UsIGFuZCBmaXJlIGEgc2ltdWxhdGVkXG4gICAgLy8gZW50ZXIga2V5IGFmdGVyd2FyZHMuXG4gICAgaWYgKGFuZHJvaWQgJiYgIWlubGluZUNoYW5nZSAmJiAkZnJvbS5zdGFydCgpICE9ICR0by5zdGFydCgpICYmICR0by5wYXJlbnRPZmZzZXQgPT0gMCAmJiAkZnJvbS5kZXB0aCA9PSAkdG8uZGVwdGggJiZcbiAgICAgICAgcGFyc2Uuc2VsICYmIHBhcnNlLnNlbC5hbmNob3IgPT0gcGFyc2Uuc2VsLmhlYWQgJiYgcGFyc2Uuc2VsLmhlYWQgPT0gY2hhbmdlLmVuZEEpIHtcbiAgICAgICAgY2hhbmdlLmVuZEIgLT0gMjtcbiAgICAgICAgJHRvID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpOyB9KTtcbiAgICAgICAgfSwgMjApO1xuICAgIH1cbiAgICBsZXQgY2hGcm9tID0gY2hhbmdlLnN0YXJ0LCBjaFRvID0gY2hhbmdlLmVuZEE7XG4gICAgbGV0IHRyLCBzdG9yZWRNYXJrcywgbWFya0NoYW5nZTtcbiAgICBpZiAoaW5saW5lQ2hhbmdlKSB7XG4gICAgICAgIGlmICgkZnJvbS5wb3MgPT0gJHRvLnBvcykgeyAvLyBEZWxldGlvblxuICAgICAgICAgICAgLy8gSUUxMSBzb21ldGltZXMgd2VpcmRseSBtb3ZlcyB0aGUgRE9NIHNlbGVjdGlvbiBhcm91bmQgYWZ0ZXJcbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIG91dCB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIHRleHRibG9ja1xuICAgICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgJGZyb20ucGFyZW50T2Zmc2V0ID09IDApIHtcbiAgICAgICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcygpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2VsZWN0aW9uVG9ET00odmlldyksIDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyID0gdmlldy5zdGF0ZS50ci5kZWxldGUoY2hGcm9tLCBjaFRvKTtcbiAgICAgICAgICAgIHN0b3JlZE1hcmtzID0gZG9jLnJlc29sdmUoY2hhbmdlLnN0YXJ0KS5tYXJrc0Fjcm9zcyhkb2MucmVzb2x2ZShjaGFuZ2UuZW5kQSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCAvLyBBZGRpbmcgb3IgcmVtb3ZpbmcgYSBtYXJrXG4gICAgICAgIGNoYW5nZS5lbmRBID09IGNoYW5nZS5lbmRCICYmXG4gICAgICAgICAgICAobWFya0NoYW5nZSA9IGlzTWFya0NoYW5nZSgkZnJvbS5wYXJlbnQuY29udGVudC5jdXQoJGZyb20ucGFyZW50T2Zmc2V0LCAkdG8ucGFyZW50T2Zmc2V0KSwgJGZyb21BLnBhcmVudC5jb250ZW50LmN1dCgkZnJvbUEucGFyZW50T2Zmc2V0LCBjaGFuZ2UuZW5kQSAtICRmcm9tQS5zdGFydCgpKSkpKSB7XG4gICAgICAgICAgICB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgICAgICAgICBpZiAobWFya0NoYW5nZS50eXBlID09IFwiYWRkXCIpXG4gICAgICAgICAgICAgICAgdHIuYWRkTWFyayhjaEZyb20sIGNoVG8sIG1hcmtDaGFuZ2UubWFyayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdHIucmVtb3ZlTWFyayhjaEZyb20sIGNoVG8sIG1hcmtDaGFuZ2UubWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJGZyb20ucGFyZW50LmNoaWxkKCRmcm9tLmluZGV4KCkpLmlzVGV4dCAmJiAkZnJvbS5pbmRleCgpID09ICR0by5pbmRleCgpIC0gKCR0by50ZXh0T2Zmc2V0ID8gMCA6IDEpKSB7XG4gICAgICAgICAgICAvLyBCb3RoIHBvc2l0aW9ucyBpbiB0aGUgc2FtZSB0ZXh0IG5vZGUgLS0gc2ltcGx5IGluc2VydCB0ZXh0XG4gICAgICAgICAgICBsZXQgdGV4dCA9ICRmcm9tLnBhcmVudC50ZXh0QmV0d2VlbigkZnJvbS5wYXJlbnRPZmZzZXQsICR0by5wYXJlbnRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVUZXh0SW5wdXRcIiwgZiA9PiBmKHZpZXcsIGNoRnJvbSwgY2hUbywgdGV4dCkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRyID0gdmlldy5zdGF0ZS50ci5pbnNlcnRUZXh0KHRleHQsIGNoRnJvbSwgY2hUbyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0cilcbiAgICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyLnJlcGxhY2UoY2hGcm9tLCBjaFRvLCBwYXJzZS5kb2Muc2xpY2UoY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSwgY2hhbmdlLmVuZEIgLSBwYXJzZS5mcm9tKSk7XG4gICAgaWYgKHBhcnNlLnNlbCkge1xuICAgICAgICBsZXQgc2VsID0gcmVzb2x2ZVNlbGVjdGlvbih2aWV3LCB0ci5kb2MsIHBhcnNlLnNlbCk7XG4gICAgICAgIC8vIENocm9tZSBBbmRyb2lkIHdpbGwgc29tZXRpbWVzLCBkdXJpbmcgY29tcG9zaXRpb24sIHJlcG9ydCB0aGVcbiAgICAgICAgLy8gc2VsZWN0aW9uIGluIHRoZSB3cm9uZyBwbGFjZS4gSWYgaXQgbG9va3MgbGlrZSB0aGF0IGlzXG4gICAgICAgIC8vIGhhcHBlbmluZywgZG9uJ3QgdXBkYXRlIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgIC8vIEVkZ2UganVzdCBkb2Vzbid0IG1vdmUgdGhlIGN1cnNvciBmb3J3YXJkIHdoZW4geW91IHN0YXJ0IHR5cGluZ1xuICAgICAgICAvLyBpbiBhbiBlbXB0eSBibG9jayBvciBiZXR3ZWVuIGJyIG5vZGVzLlxuICAgICAgICBpZiAoc2VsICYmICEoY2hyb21lICYmIGFuZHJvaWQgJiYgdmlldy5jb21wb3NpbmcgJiYgc2VsLmVtcHR5ICYmXG4gICAgICAgICAgICAoY2hhbmdlLnN0YXJ0ICE9IGNoYW5nZS5lbmRCIHx8IHZpZXcuaW5wdXQubGFzdEFuZHJvaWREZWxldGUgPCBEYXRlLm5vdygpIC0gMTAwKSAmJlxuICAgICAgICAgICAgKHNlbC5oZWFkID09IGNoRnJvbSB8fCBzZWwuaGVhZCA9PSB0ci5tYXBwaW5nLm1hcChjaFRvKSAtIDEpIHx8XG4gICAgICAgICAgICBpZSAmJiBzZWwuZW1wdHkgJiYgc2VsLmhlYWQgPT0gY2hGcm9tKSlcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgIH1cbiAgICBpZiAoc3RvcmVkTWFya3MpXG4gICAgICAgIHRyLmVuc3VyZU1hcmtzKHN0b3JlZE1hcmtzKTtcbiAgICBpZiAoY29tcG9zaXRpb25JRClcbiAgICAgICAgdHIuc2V0TWV0YShcImNvbXBvc2l0aW9uXCIsIGNvbXBvc2l0aW9uSUQpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG59XG5mdW5jdGlvbiByZXNvbHZlU2VsZWN0aW9uKHZpZXcsIGRvYywgcGFyc2VkU2VsKSB7XG4gICAgaWYgKE1hdGgubWF4KHBhcnNlZFNlbC5hbmNob3IsIHBhcnNlZFNlbC5oZWFkKSA+IGRvYy5jb250ZW50LnNpemUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsIGRvYy5yZXNvbHZlKHBhcnNlZFNlbC5hbmNob3IpLCBkb2MucmVzb2x2ZShwYXJzZWRTZWwuaGVhZCkpO1xufVxuLy8gR2l2ZW4gdHdvIHNhbWUtbGVuZ3RoLCBub24tZW1wdHkgZnJhZ21lbnRzIG9mIGlubGluZSBjb250ZW50LFxuLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGZpcnN0IGNvdWxkIGJlIGNyZWF0ZWQgZnJvbSB0aGUgc2Vjb25kIGJ5XG4vLyByZW1vdmluZyBvciBhZGRpbmcgYSBzaW5nbGUgbWFyayB0eXBlLlxuZnVuY3Rpb24gaXNNYXJrQ2hhbmdlKGN1ciwgcHJldikge1xuICAgIGxldCBjdXJNYXJrcyA9IGN1ci5maXJzdENoaWxkLm1hcmtzLCBwcmV2TWFya3MgPSBwcmV2LmZpcnN0Q2hpbGQubWFya3M7XG4gICAgbGV0IGFkZGVkID0gY3VyTWFya3MsIHJlbW92ZWQgPSBwcmV2TWFya3MsIHR5cGUsIG1hcmssIHVwZGF0ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgYWRkZWQgPSBwcmV2TWFya3NbaV0ucmVtb3ZlRnJvbVNldChhZGRlZCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVtb3ZlZCA9IGN1ck1hcmtzW2ldLnJlbW92ZUZyb21TZXQocmVtb3ZlZCk7XG4gICAgaWYgKGFkZGVkLmxlbmd0aCA9PSAxICYmIHJlbW92ZWQubGVuZ3RoID09IDApIHtcbiAgICAgICAgbWFyayA9IGFkZGVkWzBdO1xuICAgICAgICB0eXBlID0gXCJhZGRcIjtcbiAgICAgICAgdXBkYXRlID0gKG5vZGUpID0+IG5vZGUubWFyayhtYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWRkZWQubGVuZ3RoID09IDAgJiYgcmVtb3ZlZC5sZW5ndGggPT0gMSkge1xuICAgICAgICBtYXJrID0gcmVtb3ZlZFswXTtcbiAgICAgICAgdHlwZSA9IFwicmVtb3ZlXCI7XG4gICAgICAgIHVwZGF0ZSA9IChub2RlKSA9PiBub2RlLm1hcmsobWFyay5yZW1vdmVGcm9tU2V0KG5vZGUubWFya3MpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgdXBkYXRlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldi5jaGlsZENvdW50OyBpKyspXG4gICAgICAgIHVwZGF0ZWQucHVzaCh1cGRhdGUocHJldi5jaGlsZChpKSkpO1xuICAgIGlmIChGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLmVxKGN1cikpXG4gICAgICAgIHJldHVybiB7IG1hcmssIHR5cGUgfTtcbn1cbmZ1bmN0aW9uIGxvb2tzTGlrZUpvaW4ob2xkLCBzdGFydCwgZW5kLCAkbmV3U3RhcnQsICRuZXdFbmQpIHtcbiAgICBpZiAoISRuZXdTdGFydC5wYXJlbnQuaXNUZXh0YmxvY2sgfHxcbiAgICAgICAgLy8gVGhlIGNvbnRlbnQgbXVzdCBoYXZlIHNocnVua1xuICAgICAgICBlbmQgLSBzdGFydCA8PSAkbmV3RW5kLnBvcyAtICRuZXdTdGFydC5wb3MgfHxcbiAgICAgICAgLy8gbmV3RW5kIG11c3QgcG9pbnQgZGlyZWN0bHkgYXQgb3IgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgYmxvY2sgdGhhdCBuZXdTdGFydCBwb2ludHMgaW50b1xuICAgICAgICBza2lwQ2xvc2luZ0FuZE9wZW5pbmcoJG5ld1N0YXJ0LCB0cnVlLCBmYWxzZSkgPCAkbmV3RW5kLnBvcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkc3RhcnQgPSBvbGQucmVzb2x2ZShzdGFydCk7XG4gICAgLy8gU3RhcnQgbXVzdCBiZSBhdCB0aGUgZW5kIG9mIGEgYmxvY2tcbiAgICBpZiAoJHN0YXJ0LnBhcmVudE9mZnNldCA8ICRzdGFydC5wYXJlbnQuY29udGVudC5zaXplIHx8ICEkc3RhcnQucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRuZXh0ID0gb2xkLnJlc29sdmUoc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRzdGFydCwgdHJ1ZSwgdHJ1ZSkpO1xuICAgIC8vIFRoZSBuZXh0IHRleHRibG9jayBtdXN0IHN0YXJ0IGJlZm9yZSBlbmQgYW5kIGVuZCBuZWFyIGl0XG4gICAgaWYgKCEkbmV4dC5wYXJlbnQuaXNUZXh0YmxvY2sgfHwgJG5leHQucG9zID4gZW5kIHx8XG4gICAgICAgIHNraXBDbG9zaW5nQW5kT3BlbmluZygkbmV4dCwgdHJ1ZSwgZmFsc2UpIDwgZW5kKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gVGhlIGZyYWdtZW50cyBhZnRlciB0aGUgam9pbiBwb2ludCBtdXN0IG1hdGNoXG4gICAgcmV0dXJuICRuZXdTdGFydC5wYXJlbnQuY29udGVudC5jdXQoJG5ld1N0YXJ0LnBhcmVudE9mZnNldCkuZXEoJG5leHQucGFyZW50LmNvbnRlbnQpO1xufVxuZnVuY3Rpb24gc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRwb3MsIGZyb21FbmQsIG1heU9wZW4pIHtcbiAgICBsZXQgZGVwdGggPSAkcG9zLmRlcHRoLCBlbmQgPSBmcm9tRW5kID8gJHBvcy5lbmQoKSA6ICRwb3MucG9zO1xuICAgIHdoaWxlIChkZXB0aCA+IDAgJiYgKGZyb21FbmQgfHwgJHBvcy5pbmRleEFmdGVyKGRlcHRoKSA9PSAkcG9zLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpKSB7XG4gICAgICAgIGRlcHRoLS07XG4gICAgICAgIGVuZCsrO1xuICAgICAgICBmcm9tRW5kID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChtYXlPcGVuKSB7XG4gICAgICAgIGxldCBuZXh0ID0gJHBvcy5ub2RlKGRlcHRoKS5tYXliZUNoaWxkKCRwb3MuaW5kZXhBZnRlcihkZXB0aCkpO1xuICAgICAgICB3aGlsZSAobmV4dCAmJiAhbmV4dC5pc0xlYWYpIHtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5kO1xufVxuZnVuY3Rpb24gZmluZERpZmYoYSwgYiwgcG9zLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpIHtcbiAgICBsZXQgc3RhcnQgPSBhLmZpbmREaWZmU3RhcnQoYiwgcG9zKTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHsgYTogZW5kQSwgYjogZW5kQiB9ID0gYS5maW5kRGlmZkVuZChiLCBwb3MgKyBhLnNpemUsIHBvcyArIGIuc2l6ZSk7XG4gICAgaWYgKHByZWZlcnJlZFNpZGUgPT0gXCJlbmRcIikge1xuICAgICAgICBsZXQgYWRqdXN0ID0gTWF0aC5tYXgoMCwgc3RhcnQgLSBNYXRoLm1pbihlbmRBLCBlbmRCKSk7XG4gICAgICAgIHByZWZlcnJlZFBvcyAtPSBlbmRBICsgYWRqdXN0IC0gc3RhcnQ7XG4gICAgfVxuICAgIGlmIChlbmRBIDwgc3RhcnQgJiYgYS5zaXplIDwgYi5zaXplKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IHN0YXJ0ICYmIHByZWZlcnJlZFBvcyA+PSBlbmRBID8gc3RhcnQgLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBzdGFydCAtPSBtb3ZlO1xuICAgICAgICBlbmRCID0gc3RhcnQgKyAoZW5kQiAtIGVuZEEpO1xuICAgICAgICBlbmRBID0gc3RhcnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVuZEIgPCBzdGFydCkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBzdGFydCAmJiBwcmVmZXJyZWRQb3MgPj0gZW5kQiA/IHN0YXJ0IC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgc3RhcnQgLT0gbW92ZTtcbiAgICAgICAgZW5kQSA9IHN0YXJ0ICsgKGVuZEEgLSBlbmRCKTtcbiAgICAgICAgZW5kQiA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydCwgZW5kQSwgZW5kQiB9O1xufVxuXG4vKipcbkBpbnRlcm5hbFxuKi9cbmNvbnN0IF9fc2VyaWFsaXplRm9yQ2xpcGJvYXJkID0gc2VyaWFsaXplRm9yQ2xpcGJvYXJkO1xuLyoqXG5AaW50ZXJuYWxcbiovXG5jb25zdCBfX3BhcnNlRnJvbUNsaXBib2FyZCA9IHBhcnNlRnJvbUNsaXBib2FyZDtcbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX19lbmRDb21wb3NpdGlvbiA9IGVuZENvbXBvc2l0aW9uO1xuLyoqXG5BbiBlZGl0b3IgdmlldyBtYW5hZ2VzIHRoZSBET00gc3RydWN0dXJlIHRoYXQgcmVwcmVzZW50cyBhblxuZWRpdGFibGUgZG9jdW1lbnQuIEl0cyBzdGF0ZSBhbmQgYmVoYXZpb3IgYXJlIGRldGVybWluZWQgYnkgaXRzXG5bcHJvcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRpcmVjdEVkaXRvclByb3BzKS5cbiovXG5jbGFzcyBFZGl0b3JWaWV3IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB2aWV3LiBgcGxhY2VgIG1heSBiZSBhIERPTSBub2RlIHRoYXQgdGhlIGVkaXRvciBzaG91bGRcbiAgICBiZSBhcHBlbmRlZCB0bywgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcGxhY2UgaXQgaW50byB0aGUgZG9jdW1lbnQsXG4gICAgb3IgYW4gb2JqZWN0IHdob3NlIGBtb3VudGAgcHJvcGVydHkgaG9sZHMgdGhlIG5vZGUgdG8gdXNlIGFzIHRoZVxuICAgIGRvY3VtZW50IGNvbnRhaW5lci4gSWYgaXQgaXMgYG51bGxgLCB0aGUgZWRpdG9yIHdpbGwgbm90IGJlXG4gICAgYWRkZWQgdG8gdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IocGxhY2UsIHByb3BzKSB7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgS2x1ZGdlIHVzZWQgdG8gd29yayBhcm91bmQgYSBDaHJvbWUgYnVnIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyYWNrV3JpdGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXJrQ3Vyc29yID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnNvcldyYXBwZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGVkVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnB1dCA9IG5ldyBJbnB1dFN0YXRlO1xuICAgICAgICB0aGlzLnByZXZEaXJlY3RQbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMucGx1Z2luVmlld3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEhvbGRzIGB0cnVlYCB3aGVuIGEgaGFjayBub2RlIGlzIG5lZWRlZCBpbiBGaXJlZm94IHRvIHByZXZlbnQgdGhlXG4gICAgICAgIFtzcGFjZSBpcyBlYXRlbiBpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL1Byb3NlTWlycm9yL3Byb3NlbWlycm9yL2lzc3Vlcy82NTEpXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlcXVpcmVzR2Vja29IYWNrTm9kZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgV2hlbiBlZGl0b3IgY29udGVudCBpcyBiZWluZyBkcmFnZ2VkLCB0aGlzIG9iamVjdCBjb250YWluc1xuICAgICAgICBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZHJhZ2dlZCBzbGljZSBhbmQgd2hldGhlciBpdCBpcyBiZWluZ1xuICAgICAgICBjb3BpZWQgb3IgbW92ZWQuIEF0IGFueSBvdGhlciB0aW1lLCBpdCBpcyBudWxsLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHByb3BzLnN0YXRlO1xuICAgICAgICB0aGlzLmRpcmVjdFBsdWdpbnMgPSBwcm9wcy5wbHVnaW5zIHx8IFtdO1xuICAgICAgICB0aGlzLmRpcmVjdFBsdWdpbnMuZm9yRWFjaChjaGVja1N0YXRlQ29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kb20gPSAocGxhY2UgJiYgcGxhY2UubW91bnQpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmIChwbGFjZSkge1xuICAgICAgICAgICAgaWYgKHBsYWNlLmFwcGVuZENoaWxkKVxuICAgICAgICAgICAgICAgIHBsYWNlLmFwcGVuZENoaWxkKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwbGFjZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgcGxhY2UodGhpcy5kb20pO1xuICAgICAgICAgICAgZWxzZSBpZiAocGxhY2UubW91bnQpXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRhYmxlID0gZ2V0RWRpdGFibGUodGhpcyk7XG4gICAgICAgIHVwZGF0ZUN1cnNvcldyYXBwZXIodGhpcyk7XG4gICAgICAgIHRoaXMubm9kZVZpZXdzID0gYnVpbGROb2RlVmlld3ModGhpcyk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IGRvY1ZpZXdEZXNjKHRoaXMuc3RhdGUuZG9jLCBjb21wdXRlRG9jRGVjbyh0aGlzKSwgdmlld0RlY29yYXRpb25zKHRoaXMpLCB0aGlzLmRvbSwgdGhpcyk7XG4gICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIgPSBuZXcgRE9NT2JzZXJ2ZXIodGhpcywgKGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpID0+IHJlYWRET01DaGFuZ2UodGhpcywgZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZCkpO1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIGluaXRJbnB1dCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5WaWV3cygpO1xuICAgIH1cbiAgICAvKipcbiAgICBIb2xkcyBgdHJ1ZWAgd2hlbiBhXG4gICAgW2NvbXBvc2l0aW9uXShodHRwczovL3czYy5naXRodWIuaW8vdWlldmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50cylcbiAgICBpcyBhY3RpdmUuXG4gICAgKi9cbiAgICBnZXQgY29tcG9zaW5nKCkgeyByZXR1cm4gdGhpcy5pbnB1dC5jb21wb3Npbmc7IH1cbiAgICAvKipcbiAgICBUaGUgdmlldydzIGN1cnJlbnQgW3Byb3BzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcykuXG4gICAgKi9cbiAgICBnZXQgcHJvcHMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm9wcy5zdGF0ZSAhPSB0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IHRoaXMuX3Byb3BzO1xuICAgICAgICAgICAgdGhpcy5fcHJvcHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gcHJldilcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9wc1tuYW1lXSA9IHByZXZbbmFtZV07XG4gICAgICAgICAgICB0aGlzLl9wcm9wcy5zdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BzO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHZpZXcncyBwcm9wcy4gV2lsbCBpbW1lZGlhdGVseSBjYXVzZSBhbiB1cGRhdGUgdG9cbiAgICB0aGUgRE9NLlxuICAgICovXG4gICAgdXBkYXRlKHByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wcy5oYW5kbGVET01FdmVudHMgIT0gdGhpcy5fcHJvcHMuaGFuZGxlRE9NRXZlbnRzKVxuICAgICAgICAgICAgZW5zdXJlTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICBsZXQgcHJldlByb3BzID0gdGhpcy5fcHJvcHM7XG4gICAgICAgIHRoaXMuX3Byb3BzID0gcHJvcHM7XG4gICAgICAgIGlmIChwcm9wcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICBwcm9wcy5wbHVnaW5zLmZvckVhY2goY2hlY2tTdGF0ZUNvbXBvbmVudCk7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdFBsdWdpbnMgPSBwcm9wcy5wbHVnaW5zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGVJbm5lcihwcm9wcy5zdGF0ZSwgcHJldlByb3BzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB2aWV3IGJ5IHVwZGF0aW5nIGV4aXN0aW5nIHByb3BzIG9iamVjdCB3aXRoIHRoZSBvYmplY3RcbiAgICBnaXZlbiBhcyBhcmd1bWVudC4gRXF1aXZhbGVudCB0byBgdmlldy51cGRhdGUoT2JqZWN0LmFzc2lnbih7fSxcbiAgICB2aWV3LnByb3BzLCBwcm9wcykpYC5cbiAgICAqL1xuICAgIHNldFByb3BzKHByb3BzKSB7XG4gICAgICAgIGxldCB1cGRhdGVkID0ge307XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5fcHJvcHMpXG4gICAgICAgICAgICB1cGRhdGVkW25hbWVdID0gdGhpcy5fcHJvcHNbbmFtZV07XG4gICAgICAgIHVwZGF0ZWQuc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByb3BzKVxuICAgICAgICAgICAgdXBkYXRlZFtuYW1lXSA9IHByb3BzW25hbWVdO1xuICAgICAgICB0aGlzLnVwZGF0ZSh1cGRhdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSBlZGl0b3IncyBgc3RhdGVgIHByb3AsIHdpdGhvdXQgdG91Y2hpbmcgYW55IG9mIHRoZVxuICAgIG90aGVyIHByb3BzLlxuICAgICovXG4gICAgdXBkYXRlU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZUlubmVyKHN0YXRlLCB0aGlzLl9wcm9wcyk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlSW5uZXIoc3RhdGUsIHByZXZQcm9wcykge1xuICAgICAgICBsZXQgcHJldiA9IHRoaXMuc3RhdGUsIHJlZHJhdyA9IGZhbHNlLCB1cGRhdGVTZWwgPSBmYWxzZTtcbiAgICAgICAgLy8gV2hlbiBzdG9yZWQgbWFya3MgYXJlIGFkZGVkLCBzdG9wIGNvbXBvc2l0aW9uLCBzbyB0aGF0IHRoZXkgY2FuXG4gICAgICAgIC8vIGJlIGRpc3BsYXllZC5cbiAgICAgICAgaWYgKHN0YXRlLnN0b3JlZE1hcmtzICYmIHRoaXMuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICBjbGVhckNvbXBvc2l0aW9uKHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlU2VsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIGxldCBwbHVnaW5zQ2hhbmdlZCA9IHByZXYucGx1Z2lucyAhPSBzdGF0ZS5wbHVnaW5zIHx8IHRoaXMuX3Byb3BzLnBsdWdpbnMgIT0gcHJldlByb3BzLnBsdWdpbnM7XG4gICAgICAgIGlmIChwbHVnaW5zQ2hhbmdlZCB8fCB0aGlzLl9wcm9wcy5wbHVnaW5zICE9IHByZXZQcm9wcy5wbHVnaW5zIHx8IHRoaXMuX3Byb3BzLm5vZGVWaWV3cyAhPSBwcmV2UHJvcHMubm9kZVZpZXdzKSB7XG4gICAgICAgICAgICBsZXQgbm9kZVZpZXdzID0gYnVpbGROb2RlVmlld3ModGhpcyk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZE5vZGVWaWV3cyhub2RlVmlld3MsIHRoaXMubm9kZVZpZXdzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZVZpZXdzID0gbm9kZVZpZXdzO1xuICAgICAgICAgICAgICAgIHJlZHJhdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsdWdpbnNDaGFuZ2VkIHx8IHByZXZQcm9wcy5oYW5kbGVET01FdmVudHMgIT0gdGhpcy5fcHJvcHMuaGFuZGxlRE9NRXZlbnRzKSB7XG4gICAgICAgICAgICBlbnN1cmVMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGdldEVkaXRhYmxlKHRoaXMpO1xuICAgICAgICB1cGRhdGVDdXJzb3JXcmFwcGVyKHRoaXMpO1xuICAgICAgICBsZXQgaW5uZXJEZWNvID0gdmlld0RlY29yYXRpb25zKHRoaXMpLCBvdXRlckRlY28gPSBjb21wdXRlRG9jRGVjbyh0aGlzKTtcbiAgICAgICAgbGV0IHNjcm9sbCA9IHByZXYucGx1Z2lucyAhPSBzdGF0ZS5wbHVnaW5zICYmICFwcmV2LmRvYy5lcShzdGF0ZS5kb2MpID8gXCJyZXNldFwiXG4gICAgICAgICAgICA6IHN0YXRlLnNjcm9sbFRvU2VsZWN0aW9uID4gcHJldi5zY3JvbGxUb1NlbGVjdGlvbiA/IFwidG8gc2VsZWN0aW9uXCIgOiBcInByZXNlcnZlXCI7XG4gICAgICAgIGxldCB1cGRhdGVEb2MgPSByZWRyYXcgfHwgIXRoaXMuZG9jVmlldy5tYXRjaGVzTm9kZShzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgICAgaWYgKHVwZGF0ZURvYyB8fCAhc3RhdGUuc2VsZWN0aW9uLmVxKHByZXYuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHVwZGF0ZVNlbCA9IHRydWU7XG4gICAgICAgIGxldCBvbGRTY3JvbGxQb3MgPSBzY3JvbGwgPT0gXCJwcmVzZXJ2ZVwiICYmIHVwZGF0ZVNlbCAmJiB0aGlzLmRvbS5zdHlsZS5vdmVyZmxvd0FuY2hvciA9PSBudWxsICYmIHN0b3JlU2Nyb2xsUG9zKHRoaXMpO1xuICAgICAgICBpZiAodXBkYXRlU2VsKSB7XG4gICAgICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGFuIGlzc3VlIGluIENocm9tZSwgSUUsIGFuZCBFZGdlIHdoZXJlIGNoYW5naW5nXG4gICAgICAgICAgICAvLyB0aGUgRE9NIGFyb3VuZCBhbiBhY3RpdmUgc2VsZWN0aW9uIHB1dHMgaXQgaW50byBhIGJyb2tlblxuICAgICAgICAgICAgLy8gc3RhdGUgd2hlcmUgdGhlIHRoaW5nIHRoZSB1c2VyIHNlZXMgZGlmZmVycyBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gc2VsZWN0aW9uIHJlcG9ydGVkIGJ5IHRoZSBTZWxlY3Rpb24gb2JqZWN0ICgjNzEwLCAjOTczLFxuICAgICAgICAgICAgLy8gIzEwMTEsICMxMDEzLCAjMTAzNSkuXG4gICAgICAgICAgICBsZXQgZm9yY2VTZWxVcGRhdGUgPSB1cGRhdGVEb2MgJiYgKGllIHx8IGNocm9tZSkgJiYgIXRoaXMuY29tcG9zaW5nICYmXG4gICAgICAgICAgICAgICAgIXByZXYuc2VsZWN0aW9uLmVtcHR5ICYmICFzdGF0ZS5zZWxlY3Rpb24uZW1wdHkgJiYgc2VsZWN0aW9uQ29udGV4dENoYW5nZWQocHJldi5zZWxlY3Rpb24sIHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICBpZiAodXBkYXRlRG9jKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgdGhhdCB0aGUgc2VsZWN0aW9uIHBvaW50cyBpbnRvIGlzIHdyaXR0ZW4gdG8sXG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIHNvbWV0aW1lcyBzdGFydHMgbWlzcmVwb3J0aW5nIHRoZSBzZWxlY3Rpb24sIHNvIHRoaXNcbiAgICAgICAgICAgICAgICAvLyB0cmFja3MgdGhhdCBhbmQgZm9yY2VzIGEgc2VsZWN0aW9uIHJlc2V0IHdoZW4gb3VyIHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIGRpZCB3cml0ZSB0byB0aGUgbm9kZS5cbiAgICAgICAgICAgICAgICBsZXQgY2hyb21lS2x1ZGdlID0gY2hyb21lID8gKHRoaXMudHJhY2tXcml0ZXMgPSB0aGlzLmRvbVNlbGVjdGlvblJhbmdlKCkuZm9jdXNOb2RlKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHJhdyB8fCAhdGhpcy5kb2NWaWV3LnVwZGF0ZShzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlT3V0ZXJEZWNvKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3ID0gZG9jVmlld0Rlc2Moc3RhdGUuZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgdGhpcy5kb20sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hyb21lS2x1ZGdlICYmICF0aGlzLnRyYWNrV3JpdGVzKVxuICAgICAgICAgICAgICAgICAgICBmb3JjZVNlbFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBmb3IgYW4gaXNzdWUgd2hlcmUgYW4gdXBkYXRlIGFycml2aW5nIHJpZ2h0IGJldHdlZW5cbiAgICAgICAgICAgIC8vIGEgRE9NIHNlbGVjdGlvbiBjaGFuZ2UgYW5kIHRoZSBcInNlbGVjdGlvbmNoYW5nZVwiIGV2ZW50IGZvciBpdFxuICAgICAgICAgICAgLy8gY2FuIGNhdXNlIGEgc3B1cmlvdXMgRE9NIHNlbGVjdGlvbiB1cGRhdGUsIGRpc3J1cHRpbmcgbW91c2VcbiAgICAgICAgICAgIC8vIGRyYWcgc2VsZWN0aW9uLlxuICAgICAgICAgICAgaWYgKGZvcmNlU2VsVXBkYXRlIHx8XG4gICAgICAgICAgICAgICAgISh0aGlzLmlucHV0Lm1vdXNlRG93biAmJiB0aGlzLmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb24uZXEodGhpcy5kb21TZWxlY3Rpb25SYW5nZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICBhbmNob3JJblJpZ2h0UGxhY2UodGhpcykpKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odGhpcywgZm9yY2VTZWxVcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3luY05vZGVTZWxlY3Rpb24odGhpcywgc3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUGx1Z2luVmlld3MocHJldik7XG4gICAgICAgIGlmIChzY3JvbGwgPT0gXCJyZXNldFwiKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5zY3JvbGxUb3AgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjcm9sbCA9PSBcInRvIHNlbGVjdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2xkU2Nyb2xsUG9zKSB7XG4gICAgICAgICAgICByZXNldFNjcm9sbFBvcyhvbGRTY3JvbGxQb3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2Nyb2xsVG9TZWxlY3Rpb24oKSB7XG4gICAgICAgIGxldCBzdGFydERPTSA9IHRoaXMuZG9tU2VsZWN0aW9uUmFuZ2UoKS5mb2N1c05vZGU7XG4gICAgICAgIGlmICh0aGlzLnNvbWVQcm9wKFwiaGFuZGxlU2Nyb2xsVG9TZWxlY3Rpb25cIiwgZiA9PiBmKHRoaXMpKSkgO1xuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLmRvY1ZpZXcuZG9tQWZ0ZXJQb3ModGhpcy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICAgICAgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMsIHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc3RhcnRET00pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMsIHRoaXMuY29vcmRzQXRQb3ModGhpcy5zdGF0ZS5zZWxlY3Rpb24uaGVhZCwgMSksIHN0YXJ0RE9NKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95UGx1Z2luVmlld3MoKSB7XG4gICAgICAgIGxldCB2aWV3O1xuICAgICAgICB3aGlsZSAodmlldyA9IHRoaXMucGx1Z2luVmlld3MucG9wKCkpXG4gICAgICAgICAgICBpZiAodmlldy5kZXN0cm95KVxuICAgICAgICAgICAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgIH1cbiAgICB1cGRhdGVQbHVnaW5WaWV3cyhwcmV2U3RhdGUpIHtcbiAgICAgICAgaWYgKCFwcmV2U3RhdGUgfHwgcHJldlN0YXRlLnBsdWdpbnMgIT0gdGhpcy5zdGF0ZS5wbHVnaW5zIHx8IHRoaXMuZGlyZWN0UGx1Z2lucyAhPSB0aGlzLnByZXZEaXJlY3RQbHVnaW5zKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZEaXJlY3RQbHVnaW5zID0gdGhpcy5kaXJlY3RQbHVnaW5zO1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95UGx1Z2luVmlld3MoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kaXJlY3RQbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMuZGlyZWN0UGx1Z2luc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMudmlldylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW5WaWV3cy5wdXNoKHBsdWdpbi5zcGVjLnZpZXcodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRlLnBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5zdGF0ZS5wbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy52aWV3KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpblZpZXdzLnB1c2gocGx1Z2luLnNwZWMudmlldyh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2luVmlld3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luVmlldyA9IHRoaXMucGx1Z2luVmlld3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpblZpZXcudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICBwbHVnaW5WaWV3LnVwZGF0ZSh0aGlzLCBwcmV2U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNvbWVQcm9wKHByb3BOYW1lLCBmKSB7XG4gICAgICAgIGxldCBwcm9wID0gdGhpcy5fcHJvcHMgJiYgdGhpcy5fcHJvcHNbcHJvcE5hbWVdLCB2YWx1ZTtcbiAgICAgICAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGlyZWN0UGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHByb3AgPSB0aGlzLmRpcmVjdFBsdWdpbnNbaV0ucHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGx1Z2lucyA9IHRoaXMuc3RhdGUucGx1Z2lucztcbiAgICAgICAgaWYgKHBsdWdpbnMpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcCA9IHBsdWdpbnNbaV0ucHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wICE9IG51bGwgJiYgKHZhbHVlID0gZiA/IGYocHJvcCkgOiBwcm9wKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBRdWVyeSB3aGV0aGVyIHRoZSB2aWV3IGhhcyBmb2N1cy5cbiAgICAqL1xuICAgIGhhc0ZvY3VzKCkge1xuICAgICAgICAvLyBXb3JrIGFyb3VuZCBJRSBub3QgaGFuZGxpbmcgZm9jdXMgY29ycmVjdGx5IGlmIHJlc2l6ZSBoYW5kbGVzIGFyZSBzaG93bi5cbiAgICAgICAgLy8gSWYgdGhlIGN1cnNvciBpcyBpbnNpZGUgYW4gZWxlbWVudCB3aXRoIHJlc2l6ZSBoYW5kbGVzLCBhY3RpdmVFbGVtZW50XG4gICAgICAgIC8vIHdpbGwgYmUgdGhhdCBlbGVtZW50IGluc3RlYWQgb2YgdGhpcy5kb20uXG4gICAgICAgIGlmIChpZSkge1xuICAgICAgICAgICAgLy8gSWYgYWN0aXZlRWxlbWVudCBpcyB3aXRoaW4gdGhpcy5kb20sIGFuZCB0aGVyZSBhcmUgbm8gb3RoZXIgZWxlbWVudHNcbiAgICAgICAgICAgIC8vIHNldHRpbmcgYGNvbnRlbnRlZGl0YWJsZWAgdG8gZmFsc2UgaW4gYmV0d2VlbiwgdHJlYXQgaXQgYXMgZm9jdXNlZC5cbiAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAobm9kZSA9PSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCAhdGhpcy5kb20uY29udGFpbnMobm9kZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUgJiYgdGhpcy5kb20gIT0gbm9kZSAmJiB0aGlzLmRvbS5jb250YWlucyhub2RlKSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSAnZmFsc2UnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmRvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgRm9jdXMgdGhlIGVkaXRvci5cbiAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdGFibGUpXG4gICAgICAgICAgICBmb2N1c1ByZXZlbnRTY3JvbGwodGhpcy5kb20pO1xuICAgICAgICBzZWxlY3Rpb25Ub0RPTSh0aGlzKTtcbiAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGRvY3VtZW50IHJvb3QgaW4gd2hpY2ggdGhlIGVkaXRvciBleGlzdHMuIFRoaXMgd2lsbFxuICAgIHVzdWFsbHkgYmUgdGhlIHRvcC1sZXZlbCBgZG9jdW1lbnRgLCBidXQgbWlnaHQgYmUgYSBbc2hhZG93XG4gICAgRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9XZWJfQ29tcG9uZW50cy9TaGFkb3dfRE9NKVxuICAgIHJvb3QgaWYgdGhlIGVkaXRvciBpcyBpbnNpZGUgb25lLlxuICAgICovXG4gICAgZ2V0IHJvb3QoKSB7XG4gICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLl9yb290O1xuICAgICAgICBpZiAoY2FjaGVkID09IG51bGwpXG4gICAgICAgICAgICBmb3IgKGxldCBzZWFyY2ggPSB0aGlzLmRvbS5wYXJlbnROb2RlOyBzZWFyY2g7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5ub2RlVHlwZSA9PSA5IHx8IChzZWFyY2gubm9kZVR5cGUgPT0gMTEgJiYgc2VhcmNoLmhvc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VhcmNoLmdldFNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihzZWFyY2gpLmdldFNlbGVjdGlvbiA9ICgpID0+IHNlYXJjaC5vd25lckRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdCA9IHNlYXJjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZWQgfHwgZG9jdW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZW4gYW4gZXhpc3RpbmcgZWRpdG9yIHZpZXcgaXMgbW92ZWQgdG8gYSBuZXcgZG9jdW1lbnQgb3JcbiAgICBzaGFkb3cgdHJlZSwgY2FsbCB0aGlzIHRvIG1ha2UgaXQgcmVjb21wdXRlIGl0cyByb290LlxuICAgICovXG4gICAgdXBkYXRlUm9vdCgpIHtcbiAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEdpdmVuIGEgcGFpciBvZiB2aWV3cG9ydCBjb29yZGluYXRlcywgcmV0dXJuIHRoZSBkb2N1bWVudFxuICAgIHBvc2l0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlbS4gTWF5IHJldHVybiBudWxsIGlmIHRoZSBnaXZlblxuICAgIGNvb3JkaW5hdGVzIGFyZW4ndCBpbnNpZGUgb2YgdGhlIGVkaXRvci4gV2hlbiBhbiBvYmplY3QgaXNcbiAgICByZXR1cm5lZCwgaXRzIGBwb3NgIHByb3BlcnR5IGlzIHRoZSBwb3NpdGlvbiBuZWFyZXN0IHRvIHRoZVxuICAgIGNvb3JkaW5hdGVzLCBhbmQgaXRzIGBpbnNpZGVgIHByb3BlcnR5IGhvbGRzIHRoZSBwb3NpdGlvbiBvZiB0aGVcbiAgICBpbm5lciBub2RlIHRoYXQgdGhlIHBvc2l0aW9uIGZhbGxzIGluc2lkZSBvZiwgb3IgLTEgaWYgaXQgaXMgYXRcbiAgICB0aGUgdG9wIGxldmVsLCBub3QgaW4gYW55IG5vZGUuXG4gICAgKi9cbiAgICBwb3NBdENvb3Jkcyhjb29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHBvc0F0Q29vcmRzKHRoaXMsIGNvb3Jkcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIHZpZXdwb3J0IHJlY3RhbmdsZSBhdCBhIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLlxuICAgIGBsZWZ0YCBhbmQgYHJpZ2h0YCB3aWxsIGJlIHRoZSBzYW1lIG51bWJlciwgYXMgdGhpcyByZXR1cm5zIGFcbiAgICBmbGF0IGN1cnNvci1pc2ggcmVjdGFuZ2xlLiBJZiB0aGUgcG9zaXRpb24gaXMgYmV0d2VlbiB0d28gdGhpbmdzXG4gICAgdGhhdCBhcmVuJ3QgZGlyZWN0bHkgYWRqYWNlbnQsIGBzaWRlYCBkZXRlcm1pbmVzIHdoaWNoIGVsZW1lbnRcbiAgICBpcyB1c2VkLiBXaGVuIDwgMCwgdGhlIGVsZW1lbnQgYmVmb3JlIHRoZSBwb3NpdGlvbiBpcyB1c2VkLFxuICAgIG90aGVyd2lzZSB0aGUgZWxlbWVudCBhZnRlci5cbiAgICAqL1xuICAgIGNvb3Jkc0F0UG9zKHBvcywgc2lkZSA9IDEpIHtcbiAgICAgICAgcmV0dXJuIGNvb3Jkc0F0UG9zKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIERPTSBwb3NpdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBkb2N1bWVudFxuICAgIHBvc2l0aW9uLiBXaGVuIGBzaWRlYCBpcyBuZWdhdGl2ZSwgZmluZCB0aGUgcG9zaXRpb24gYXMgY2xvc2UgYXNcbiAgICBwb3NzaWJsZSB0byB0aGUgY29udGVudCBiZWZvcmUgdGhlIHBvc2l0aW9uLiBXaGVuIHBvc2l0aXZlLFxuICAgIHByZWZlciBwb3NpdGlvbnMgY2xvc2UgdG8gdGhlIGNvbnRlbnQgYWZ0ZXIgdGhlIHBvc2l0aW9uLiBXaGVuXG4gICAgemVybywgcHJlZmVyIGFzIHNoYWxsb3cgYSBwb3NpdGlvbiBhcyBwb3NzaWJsZS5cbiAgICBcbiAgICBOb3RlIHRoYXQgeW91IHNob3VsZCAqKm5vdCoqIG11dGF0ZSB0aGUgZWRpdG9yJ3MgaW50ZXJuYWwgRE9NLFxuICAgIG9ubHkgaW5zcGVjdCBpdCAoYW5kIGV2ZW4gdGhhdCBpcyB1c3VhbGx5IG5vdCBuZWNlc3NhcnkpLlxuICAgICovXG4gICAgZG9tQXRQb3MocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgRE9NIG5vZGUgdGhhdCByZXByZXNlbnRzIHRoZSBkb2N1bWVudCBub2RlIGFmdGVyIHRoZVxuICAgIGdpdmVuIHBvc2l0aW9uLiBNYXkgcmV0dXJuIGBudWxsYCB3aGVuIHRoZSBwb3NpdGlvbiBkb2Vzbid0IHBvaW50XG4gICAgaW4gZnJvbnQgb2YgYSBub2RlIG9yIGlmIHRoZSBub2RlIGlzIGluc2lkZSBhbiBvcGFxdWUgbm9kZSB2aWV3LlxuICAgIFxuICAgIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgYWJsZSB0byBjYWxsIHRoaW5ncyBsaWtlXG4gICAgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgb24gdGhhdCBET00gbm9kZS4gRG8gKipub3QqKiBtdXRhdGUgdGhlXG4gICAgZWRpdG9yIERPTSBkaXJlY3RseSwgb3IgYWRkIHN0eWxpbmcgdGhpcyB3YXksIHNpbmNlIHRoYXQgd2lsbCBiZVxuICAgIGltbWVkaWF0ZWx5IG92ZXJyaWRlbiBieSB0aGUgZWRpdG9yIGFzIGl0IHJlZHJhd3MgdGhlIG5vZGUuXG4gICAgKi9cbiAgICBub2RlRE9NKHBvcykge1xuICAgICAgICBsZXQgZGVzYyA9IHRoaXMuZG9jVmlldy5kZXNjQXQocG9zKTtcbiAgICAgICAgcmV0dXJuIGRlc2MgPyBkZXNjLm5vZGVET00gOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBkb2N1bWVudCBwb3NpdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgZ2l2ZW4gRE9NXG4gICAgcG9zaXRpb24uIChXaGVuZXZlciBwb3NzaWJsZSwgaXQgaXMgcHJlZmVyYWJsZSB0byBpbnNwZWN0IHRoZVxuICAgIGRvY3VtZW50IHN0cnVjdHVyZSBkaXJlY3RseSwgcmF0aGVyIHRoYW4gcG9raW5nIGFyb3VuZCBpbiB0aGVcbiAgICBET00sIGJ1dCBzb21ldGltZXNcdTIwMTRmb3IgZXhhbXBsZSB3aGVuIGludGVycHJldGluZyBhbiBldmVudFxuICAgIHRhcmdldFx1MjAxNHlvdSBkb24ndCBoYXZlIGEgY2hvaWNlLilcbiAgICBcbiAgICBUaGUgYGJpYXNgIHBhcmFtZXRlciBjYW4gYmUgdXNlZCB0byBpbmZsdWVuY2Ugd2hpY2ggc2lkZSBvZiBhIERPTVxuICAgIG5vZGUgdG8gdXNlIHdoZW4gdGhlIHBvc2l0aW9uIGlzIGluc2lkZSBhIGxlYWYgbm9kZS5cbiAgICAqL1xuICAgIHBvc0F0RE9NKG5vZGUsIG9mZnNldCwgYmlhcyA9IC0xKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQsIGJpYXMpO1xuICAgICAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRPTSBwb3NpdGlvbiBub3QgaW5zaWRlIHRoZSBlZGl0b3JcIik7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgb3V0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBhdCB0aGUgZW5kIG9mIGEgdGV4dGJsb2NrIHdoZW5cbiAgICBtb3ZpbmcgaW4gYSBnaXZlbiBkaXJlY3Rpb24uIFdoZW4sIGZvciBleGFtcGxlLCBnaXZlbiBgXCJsZWZ0XCJgLFxuICAgIGl0IHdpbGwgcmV0dXJuIHRydWUgaWYgbW92aW5nIGxlZnQgZnJvbSB0aGUgY3VycmVudCBjdXJzb3JcbiAgICBwb3NpdGlvbiB3b3VsZCBsZWF2ZSB0aGF0IHBvc2l0aW9uJ3MgcGFyZW50IHRleHRibG9jay4gV2lsbCBhcHBseVxuICAgIHRvIHRoZSB2aWV3J3MgY3VycmVudCBzdGF0ZSBieSBkZWZhdWx0LCBidXQgaXQgaXMgcG9zc2libGUgdG9cbiAgICBwYXNzIGEgZGlmZmVyZW50IHN0YXRlLlxuICAgICovXG4gICAgZW5kT2ZUZXh0YmxvY2soZGlyLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gZW5kT2ZUZXh0YmxvY2sodGhpcywgc3RhdGUgfHwgdGhpcy5zdGF0ZSwgZGlyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUnVuIHRoZSBlZGl0b3IncyBwYXN0ZSBsb2dpYyB3aXRoIHRoZSBnaXZlbiBIVE1MIHN0cmluZy4gVGhlXG4gICAgYGV2ZW50YCwgaWYgZ2l2ZW4sIHdpbGwgYmUgcGFzc2VkIHRvIHRoZVxuICAgIFtgaGFuZGxlUGFzdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcy5oYW5kbGVQYXN0ZSkgaG9vay5cbiAgICAqL1xuICAgIHBhc3RlSFRNTChodG1sLCBldmVudCkge1xuICAgICAgICByZXR1cm4gZG9QYXN0ZSh0aGlzLCBcIlwiLCBodG1sLCBmYWxzZSwgZXZlbnQgfHwgbmV3IENsaXBib2FyZEV2ZW50KFwicGFzdGVcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICBSdW4gdGhlIGVkaXRvcidzIHBhc3RlIGxvZ2ljIHdpdGggdGhlIGdpdmVuIHBsYWluLXRleHQgaW5wdXQuXG4gICAgKi9cbiAgICBwYXN0ZVRleHQodGV4dCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvUGFzdGUodGhpcywgdGV4dCwgbnVsbCwgdHJ1ZSwgZXZlbnQgfHwgbmV3IENsaXBib2FyZEV2ZW50KFwicGFzdGVcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmVzIHRoZSBlZGl0b3IgZnJvbSB0aGUgRE9NIGFuZCBkZXN0cm95cyBhbGwgW25vZGVcbiAgICB2aWV3c10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuTm9kZVZpZXcpLlxuICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvY1ZpZXcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlc3Ryb3lJbnB1dCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXN0cm95UGx1Z2luVmlld3MoKTtcbiAgICAgICAgaWYgKHRoaXMubW91bnRlZCkge1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZSh0aGlzLnN0YXRlLmRvYywgW10sIHZpZXdEZWNvcmF0aW9ucyh0aGlzKSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRvbS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kb20ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5kb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb2NWaWV3ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhpcyBpcyB0cnVlIHdoZW4gdGhlIHZpZXcgaGFzIGJlZW5cbiAgICBbZGVzdHJveWVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRlc3Ryb3kpIChhbmQgdGh1cyBzaG91bGQgbm90IGJlXG4gICAgdXNlZCBhbnltb3JlKS5cbiAgICAqL1xuICAgIGdldCBpc0Rlc3Ryb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldyA9PSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBVc2VkIGZvciB0ZXN0aW5nLlxuICAgICovXG4gICAgZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCBldmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIERpc3BhdGNoIGEgdHJhbnNhY3Rpb24uIFdpbGwgY2FsbFxuICAgIFtgZGlzcGF0Y2hUcmFuc2FjdGlvbmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRpcmVjdEVkaXRvclByb3BzLmRpc3BhdGNoVHJhbnNhY3Rpb24pXG4gICAgd2hlbiBnaXZlbiwgYW5kIG90aGVyd2lzZSBkZWZhdWx0cyB0byBhcHBseWluZyB0aGUgdHJhbnNhY3Rpb24gdG9cbiAgICB0aGUgY3VycmVudCBzdGF0ZSBhbmQgY2FsbGluZ1xuICAgIFtgdXBkYXRlU3RhdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnVwZGF0ZVN0YXRlKSB3aXRoIHRoZSByZXN1bHQuXG4gICAgVGhpcyBtZXRob2QgaXMgYm91bmQgdG8gdGhlIHZpZXcgaW5zdGFuY2UsIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgZWFzaWx5IHBhc3NlZCBhcm91bmQuXG4gICAgKi9cbiAgICBkaXNwYXRjaCh0cikge1xuICAgICAgICBsZXQgZGlzcGF0Y2hUcmFuc2FjdGlvbiA9IHRoaXMuX3Byb3BzLmRpc3BhdGNoVHJhbnNhY3Rpb247XG4gICAgICAgIGlmIChkaXNwYXRjaFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgZGlzcGF0Y2hUcmFuc2FjdGlvbi5jYWxsKHRoaXMsIHRyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSh0aGlzLnN0YXRlLmFwcGx5KHRyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tU2VsZWN0aW9uUmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiBzYWZhcmkgJiYgdGhpcy5yb290Lm5vZGVUeXBlID09PSAxMSAmJiBkZWVwQWN0aXZlRWxlbWVudCh0aGlzLmRvbS5vd25lckRvY3VtZW50KSA9PSB0aGlzLmRvbVxuICAgICAgICAgICAgPyBzYWZhcmlTaGFkb3dTZWxlY3Rpb25SYW5nZSh0aGlzKSA6IHRoaXMuZG9tU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tU2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290LmdldFNlbGVjdGlvbigpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVEb2NEZWNvKHZpZXcpIHtcbiAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGF0dHJzLmNsYXNzID0gXCJQcm9zZU1pcnJvclwiO1xuICAgIGF0dHJzLmNvbnRlbnRlZGl0YWJsZSA9IFN0cmluZyh2aWV3LmVkaXRhYmxlKTtcbiAgICB2aWV3LnNvbWVQcm9wKFwiYXR0cmlidXRlc1wiLCB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgZm9yIChsZXQgYXR0ciBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyID09IFwiY2xhc3NcIilcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuY2xhc3MgKz0gXCIgXCIgKyB2YWx1ZVthdHRyXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRyID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuc3R5bGUgPSAoYXR0cnMuc3R5bGUgPyBhdHRycy5zdHlsZSArIFwiO1wiIDogXCJcIikgKyB2YWx1ZVthdHRyXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghYXR0cnNbYXR0cl0gJiYgYXR0ciAhPSBcImNvbnRlbnRlZGl0YWJsZVwiICYmIGF0dHIgIT0gXCJub2RlTmFtZVwiKVxuICAgICAgICAgICAgICAgICAgICBhdHRyc1thdHRyXSA9IFN0cmluZyh2YWx1ZVthdHRyXSk7XG4gICAgICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFhdHRycy50cmFuc2xhdGUpXG4gICAgICAgIGF0dHJzLnRyYW5zbGF0ZSA9IFwibm9cIjtcbiAgICByZXR1cm4gW0RlY29yYXRpb24ubm9kZSgwLCB2aWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemUsIGF0dHJzKV07XG59XG5mdW5jdGlvbiB1cGRhdGVDdXJzb3JXcmFwcGVyKHZpZXcpIHtcbiAgICBpZiAodmlldy5tYXJrQ3Vyc29yKSB7XG4gICAgICAgIGxldCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIjtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShcIm1hcmstcGxhY2Vob2xkZXJcIiwgXCJ0cnVlXCIpO1xuICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwiYWx0XCIsIFwiXCIpO1xuICAgICAgICB2aWV3LmN1cnNvcldyYXBwZXIgPSB7IGRvbSwgZGVjbzogRGVjb3JhdGlvbi53aWRnZXQodmlldy5zdGF0ZS5zZWxlY3Rpb24uaGVhZCwgZG9tLCB7IHJhdzogdHJ1ZSwgbWFya3M6IHZpZXcubWFya0N1cnNvciB9KSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5jdXJzb3JXcmFwcGVyID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRFZGl0YWJsZSh2aWV3KSB7XG4gICAgcmV0dXJuICF2aWV3LnNvbWVQcm9wKFwiZWRpdGFibGVcIiwgdmFsdWUgPT4gdmFsdWUodmlldy5zdGF0ZSkgPT09IGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkNvbnRleHRDaGFuZ2VkKHNlbDEsIHNlbDIpIHtcbiAgICBsZXQgZGVwdGggPSBNYXRoLm1pbihzZWwxLiRhbmNob3Iuc2hhcmVkRGVwdGgoc2VsMS5oZWFkKSwgc2VsMi4kYW5jaG9yLnNoYXJlZERlcHRoKHNlbDIuaGVhZCkpO1xuICAgIHJldHVybiBzZWwxLiRhbmNob3Iuc3RhcnQoZGVwdGgpICE9IHNlbDIuJGFuY2hvci5zdGFydChkZXB0aCk7XG59XG5mdW5jdGlvbiBidWlsZE5vZGVWaWV3cyh2aWV3KSB7XG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZnVuY3Rpb24gYWRkKG9iaikge1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG9iailcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgcHJvcCkpXG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIH1cbiAgICB2aWV3LnNvbWVQcm9wKFwibm9kZVZpZXdzXCIsIGFkZCk7XG4gICAgdmlldy5zb21lUHJvcChcIm1hcmtWaWV3c1wiLCBhZGQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjaGFuZ2VkTm9kZVZpZXdzKGEsIGIpIHtcbiAgICBsZXQgbkEgPSAwLCBuQiA9IDA7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBhKSB7XG4gICAgICAgIGlmIChhW3Byb3BdICE9IGJbcHJvcF0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbkErKztcbiAgICB9XG4gICAgZm9yIChsZXQgXyBpbiBiKVxuICAgICAgICBuQisrO1xuICAgIHJldHVybiBuQSAhPSBuQjtcbn1cbmZ1bmN0aW9uIGNoZWNrU3RhdGVDb21wb25lbnQocGx1Z2luKSB7XG4gICAgaWYgKHBsdWdpbi5zcGVjLnN0YXRlIHx8IHBsdWdpbi5zcGVjLmZpbHRlclRyYW5zYWN0aW9uIHx8IHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlBsdWdpbnMgcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSB2aWV3IG11c3Qgbm90IGhhdmUgYSBzdGF0ZSBjb21wb25lbnRcIik7XG59XG5cbmV4cG9ydCB7IERlY29yYXRpb24sIERlY29yYXRpb25TZXQsIEVkaXRvclZpZXcsIF9fZW5kQ29tcG9zaXRpb24sIF9fcGFyc2VGcm9tQ2xpcGJvYXJkLCBfX3NlcmlhbGl6ZUZvckNsaXBib2FyZCB9O1xuIiwgImV4cG9ydCB2YXIgYmFzZSA9IHtcbiAgODogXCJCYWNrc3BhY2VcIixcbiAgOTogXCJUYWJcIixcbiAgMTA6IFwiRW50ZXJcIixcbiAgMTI6IFwiTnVtTG9ja1wiLFxuICAxMzogXCJFbnRlclwiLFxuICAxNjogXCJTaGlmdFwiLFxuICAxNzogXCJDb250cm9sXCIsXG4gIDE4OiBcIkFsdFwiLFxuICAyMDogXCJDYXBzTG9ja1wiLFxuICAyNzogXCJFc2NhcGVcIixcbiAgMzI6IFwiIFwiLFxuICAzMzogXCJQYWdlVXBcIixcbiAgMzQ6IFwiUGFnZURvd25cIixcbiAgMzU6IFwiRW5kXCIsXG4gIDM2OiBcIkhvbWVcIixcbiAgMzc6IFwiQXJyb3dMZWZ0XCIsXG4gIDM4OiBcIkFycm93VXBcIixcbiAgMzk6IFwiQXJyb3dSaWdodFwiLFxuICA0MDogXCJBcnJvd0Rvd25cIixcbiAgNDQ6IFwiUHJpbnRTY3JlZW5cIixcbiAgNDU6IFwiSW5zZXJ0XCIsXG4gIDQ2OiBcIkRlbGV0ZVwiLFxuICA1OTogXCI7XCIsXG4gIDYxOiBcIj1cIixcbiAgOTE6IFwiTWV0YVwiLFxuICA5MjogXCJNZXRhXCIsXG4gIDEwNjogXCIqXCIsXG4gIDEwNzogXCIrXCIsXG4gIDEwODogXCIsXCIsXG4gIDEwOTogXCItXCIsXG4gIDExMDogXCIuXCIsXG4gIDExMTogXCIvXCIsXG4gIDE0NDogXCJOdW1Mb2NrXCIsXG4gIDE0NTogXCJTY3JvbGxMb2NrXCIsXG4gIDE2MDogXCJTaGlmdFwiLFxuICAxNjE6IFwiU2hpZnRcIixcbiAgMTYyOiBcIkNvbnRyb2xcIixcbiAgMTYzOiBcIkNvbnRyb2xcIixcbiAgMTY0OiBcIkFsdFwiLFxuICAxNjU6IFwiQWx0XCIsXG4gIDE3MzogXCItXCIsXG4gIDE4NjogXCI7XCIsXG4gIDE4NzogXCI9XCIsXG4gIDE4ODogXCIsXCIsXG4gIDE4OTogXCItXCIsXG4gIDE5MDogXCIuXCIsXG4gIDE5MTogXCIvXCIsXG4gIDE5MjogXCJgXCIsXG4gIDIxOTogXCJbXCIsXG4gIDIyMDogXCJcXFxcXCIsXG4gIDIyMTogXCJdXCIsXG4gIDIyMjogXCInXCJcbn1cblxuZXhwb3J0IHZhciBzaGlmdCA9IHtcbiAgNDg6IFwiKVwiLFxuICA0OTogXCIhXCIsXG4gIDUwOiBcIkBcIixcbiAgNTE6IFwiI1wiLFxuICA1MjogXCIkXCIsXG4gIDUzOiBcIiVcIixcbiAgNTQ6IFwiXlwiLFxuICA1NTogXCImXCIsXG4gIDU2OiBcIipcIixcbiAgNTc6IFwiKFwiLFxuICA1OTogXCI6XCIsXG4gIDYxOiBcIitcIixcbiAgMTczOiBcIl9cIixcbiAgMTg2OiBcIjpcIixcbiAgMTg3OiBcIitcIixcbiAgMTg4OiBcIjxcIixcbiAgMTg5OiBcIl9cIixcbiAgMTkwOiBcIj5cIixcbiAgMTkxOiBcIj9cIixcbiAgMTkyOiBcIn5cIixcbiAgMjE5OiBcIntcIixcbiAgMjIwOiBcInxcIixcbiAgMjIxOiBcIn1cIixcbiAgMjIyOiBcIlxcXCJcIlxufVxuXG52YXIgbWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKVxudmFyIGllID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9NU0lFIFxcZHxUcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVxuXG4vLyBGaWxsIGluIHRoZSBkaWdpdCBrZXlzXG5mb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIGJhc2VbNDggKyBpXSA9IGJhc2VbOTYgKyBpXSA9IFN0cmluZyhpKVxuXG4vLyBUaGUgZnVuY3Rpb24ga2V5c1xuZm9yICh2YXIgaSA9IDE7IGkgPD0gMjQ7IGkrKykgYmFzZVtpICsgMTExXSA9IFwiRlwiICsgaVxuXG4vLyBBbmQgdGhlIGFscGhhYmV0aWMga2V5c1xuZm9yICh2YXIgaSA9IDY1OyBpIDw9IDkwOyBpKyspIHtcbiAgYmFzZVtpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSArIDMyKVxuICBzaGlmdFtpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSlcbn1cblxuLy8gRm9yIGVhY2ggY29kZSB0aGF0IGRvZXNuJ3QgaGF2ZSBhIHNoaWZ0LWVxdWl2YWxlbnQsIGNvcHkgdGhlIGJhc2UgbmFtZVxuZm9yICh2YXIgY29kZSBpbiBiYXNlKSBpZiAoIXNoaWZ0Lmhhc093blByb3BlcnR5KGNvZGUpKSBzaGlmdFtjb2RlXSA9IGJhc2VbY29kZV1cblxuZXhwb3J0IGZ1bmN0aW9uIGtleU5hbWUoZXZlbnQpIHtcbiAgLy8gT24gbWFjT1MsIGtleXMgaGVsZCB3aXRoIFNoaWZ0IGFuZCBDbWQgZG9uJ3QgcmVmbGVjdCB0aGUgZWZmZWN0IG9mIFNoaWZ0IGluIGAua2V5YC5cbiAgLy8gT24gSUUsIHNoaWZ0IGVmZmVjdCBpcyBuZXZlciBpbmNsdWRlZCBpbiBgLmtleWAuXG4gIHZhciBpZ25vcmVLZXkgPSBtYWMgJiYgZXZlbnQubWV0YUtleSAmJiBldmVudC5zaGlmdEtleSAmJiAhZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuYWx0S2V5IHx8XG4gICAgICBpZSAmJiBldmVudC5zaGlmdEtleSAmJiBldmVudC5rZXkgJiYgZXZlbnQua2V5Lmxlbmd0aCA9PSAxIHx8XG4gICAgICBldmVudC5rZXkgPT0gXCJVbmlkZW50aWZpZWRcIlxuICB2YXIgbmFtZSA9ICghaWdub3JlS2V5ICYmIGV2ZW50LmtleSkgfHxcbiAgICAoZXZlbnQuc2hpZnRLZXkgPyBzaGlmdCA6IGJhc2UpW2V2ZW50LmtleUNvZGVdIHx8XG4gICAgZXZlbnQua2V5IHx8IFwiVW5pZGVudGlmaWVkXCJcbiAgLy8gRWRnZSBzb21ldGltZXMgcHJvZHVjZXMgd3JvbmcgbmFtZXMgKElzc3VlICMzKVxuICBpZiAobmFtZSA9PSBcIkVzY1wiKSBuYW1lID0gXCJFc2NhcGVcIlxuICBpZiAobmFtZSA9PSBcIkRlbFwiKSBuYW1lID0gXCJEZWxldGVcIlxuICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy84ODYwNTcxL1xuICBpZiAobmFtZSA9PSBcIkxlZnRcIikgbmFtZSA9IFwiQXJyb3dMZWZ0XCJcbiAgaWYgKG5hbWUgPT0gXCJVcFwiKSBuYW1lID0gXCJBcnJvd1VwXCJcbiAgaWYgKG5hbWUgPT0gXCJSaWdodFwiKSBuYW1lID0gXCJBcnJvd1JpZ2h0XCJcbiAgaWYgKG5hbWUgPT0gXCJEb3duXCIpIG5hbWUgPSBcIkFycm93RG93blwiXG4gIHJldHVybiBuYW1lXG59XG4iLCAiaW1wb3J0IHsga2V5TmFtZSwgYmFzZSB9IGZyb20gJ3czYy1rZXluYW1lJztcbmltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcblxuY29uc3QgbWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gL01hY3xpUChob25lfFtvYV1kKS8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pIDogZmFsc2U7XG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUpIHtcbiAgICBsZXQgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKSwgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHJlc3VsdCA9PSBcIlNwYWNlXCIpXG4gICAgICAgIHJlc3VsdCA9IFwiIFwiO1xuICAgIGxldCBhbHQsIGN0cmwsIHNoaWZ0LCBtZXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGxldCBtb2QgPSBwYXJ0c1tpXTtcbiAgICAgICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBhbHQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ecyhoaWZ0KT8kL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgc2hpZnQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICAgIGlmIChtYWMpXG4gICAgICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6IFwiICsgbW9kKTtcbiAgICB9XG4gICAgaWYgKGFsdClcbiAgICAgICAgcmVzdWx0ID0gXCJBbHQtXCIgKyByZXN1bHQ7XG4gICAgaWYgKGN0cmwpXG4gICAgICAgIHJlc3VsdCA9IFwiQ3RybC1cIiArIHJlc3VsdDtcbiAgICBpZiAobWV0YSlcbiAgICAgICAgcmVzdWx0ID0gXCJNZXRhLVwiICsgcmVzdWx0O1xuICAgIGlmIChzaGlmdClcbiAgICAgICAgcmVzdWx0ID0gXCJTaGlmdC1cIiArIHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplKG1hcCkge1xuICAgIGxldCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBwcm9wIGluIG1hcClcbiAgICAgICAgY29weVtub3JtYWxpemVLZXlOYW1lKHByb3ApXSA9IG1hcFtwcm9wXTtcbiAgICByZXR1cm4gY29weTtcbn1cbmZ1bmN0aW9uIG1vZGlmaWVycyhuYW1lLCBldmVudCwgc2hpZnQgPSB0cnVlKSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSlcbiAgICAgICAgbmFtZSA9IFwiQWx0LVwiICsgbmFtZTtcbiAgICBpZiAoZXZlbnQuY3RybEtleSlcbiAgICAgICAgbmFtZSA9IFwiQ3RybC1cIiArIG5hbWU7XG4gICAgaWYgKGV2ZW50Lm1ldGFLZXkpXG4gICAgICAgIG5hbWUgPSBcIk1ldGEtXCIgKyBuYW1lO1xuICAgIGlmIChzaGlmdCAmJiBldmVudC5zaGlmdEtleSlcbiAgICAgICAgbmFtZSA9IFwiU2hpZnQtXCIgKyBuYW1lO1xuICAgIHJldHVybiBuYW1lO1xufVxuLyoqXG5DcmVhdGUgYSBrZXltYXAgcGx1Z2luIGZvciB0aGUgZ2l2ZW4gc2V0IG9mIGJpbmRpbmdzLlxuXG5CaW5kaW5ncyBzaG91bGQgbWFwIGtleSBuYW1lcyB0byBbY29tbWFuZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzKS1zdHlsZVxuZnVuY3Rpb25zLCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aXRoIGAoRWRpdG9yU3RhdGUsIGRpc3BhdGNoLFxuRWRpdG9yVmlldylgIGFyZ3VtZW50cywgYW5kIHNob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIHRoZXkndmUgaGFuZGxlZFxudGhlIGtleS4gTm90ZSB0aGF0IHRoZSB2aWV3IGFyZ3VtZW50IGlzbid0IHBhcnQgb2YgdGhlIGNvbW1hbmRcbnByb3RvY29sLCBidXQgY2FuIGJlIHVzZWQgYXMgYW4gZXNjYXBlIGhhdGNoIGlmIGEgYmluZGluZyBuZWVkcyB0b1xuZGlyZWN0bHkgaW50ZXJhY3Qgd2l0aCB0aGUgVUkuXG5cbktleSBuYW1lcyBtYXkgYmUgc3RyaW5ncyBsaWtlIGBcIlNoaWZ0LUN0cmwtRW50ZXJcImBcdTIwMTRhIGtleVxuaWRlbnRpZmllciBwcmVmaXhlZCB3aXRoIHplcm8gb3IgbW9yZSBtb2RpZmllcnMuIEtleSBpZGVudGlmaWVyc1xuYXJlIGJhc2VkIG9uIHRoZSBzdHJpbmdzIHRoYXQgY2FuIGFwcGVhciBpblxuW2BLZXlFdmVudC5rZXlgXShodHRwczpkZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5KS5cblVzZSBsb3dlcmNhc2UgbGV0dGVycyB0byByZWZlciB0byBsZXR0ZXIga2V5cyAob3IgdXBwZXJjYXNlIGxldHRlcnNcbmlmIHlvdSB3YW50IHNoaWZ0IHRvIGJlIGhlbGQpLiBZb3UgbWF5IHVzZSBgXCJTcGFjZVwiYCBhcyBhbiBhbGlhc1xuZm9yIHRoZSBgXCIgXCJgIG5hbWUuXG5cbk1vZGlmaWVycyBjYW4gYmUgZ2l2ZW4gaW4gYW55IG9yZGVyLiBgU2hpZnQtYCAob3IgYHMtYCksIGBBbHQtYCAob3JcbmBhLWApLCBgQ3RybC1gIChvciBgYy1gIG9yIGBDb250cm9sLWApIGFuZCBgQ21kLWAgKG9yIGBtLWAgb3JcbmBNZXRhLWApIGFyZSByZWNvZ25pemVkLiBGb3IgY2hhcmFjdGVycyB0aGF0IGFyZSBjcmVhdGVkIGJ5IGhvbGRpbmdcbnNoaWZ0LCB0aGUgYFNoaWZ0LWAgcHJlZml4IGlzIGltcGxpZWQsIGFuZCBzaG91bGQgbm90IGJlIGFkZGVkXG5leHBsaWNpdGx5LlxuXG5Zb3UgY2FuIHVzZSBgTW9kLWAgYXMgYSBzaG9ydGhhbmQgZm9yIGBDbWQtYCBvbiBNYWMgYW5kIGBDdHJsLWAgb25cbm90aGVyIHBsYXRmb3Jtcy5cblxuWW91IGNhbiBhZGQgbXVsdGlwbGUga2V5bWFwIHBsdWdpbnMgdG8gYW4gZWRpdG9yLiBUaGUgb3JkZXIgaW5cbndoaWNoIHRoZXkgYXBwZWFyIGRldGVybWluZXMgdGhlaXIgcHJlY2VkZW5jZSAodGhlIG9uZXMgZWFybHkgaW5cbnRoZSBhcnJheSBnZXQgdG8gZGlzcGF0Y2ggZmlyc3QpLlxuKi9cbmZ1bmN0aW9uIGtleW1hcChiaW5kaW5ncykge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHsgcHJvcHM6IHsgaGFuZGxlS2V5RG93bjoga2V5ZG93bkhhbmRsZXIoYmluZGluZ3MpIH0gfSk7XG59XG4vKipcbkdpdmVuIGEgc2V0IG9mIGJpbmRpbmdzICh1c2luZyB0aGUgc2FtZSBmb3JtYXQgYXNcbltga2V5bWFwYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2tleW1hcC5rZXltYXApKSwgcmV0dXJuIGEgW2tleWRvd25cbmhhbmRsZXJdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzLmhhbmRsZUtleURvd24pIHRoYXQgaGFuZGxlcyB0aGVtLlxuKi9cbmZ1bmN0aW9uIGtleWRvd25IYW5kbGVyKGJpbmRpbmdzKSB7XG4gICAgbGV0IG1hcCA9IG5vcm1hbGl6ZShiaW5kaW5ncyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2aWV3LCBldmVudCkge1xuICAgICAgICBsZXQgbmFtZSA9IGtleU5hbWUoZXZlbnQpLCBiYXNlTmFtZSwgZGlyZWN0ID0gbWFwW21vZGlmaWVycyhuYW1lLCBldmVudCldO1xuICAgICAgICBpZiAoZGlyZWN0ICYmIGRpcmVjdCh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoLCB2aWV3KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBBIGNoYXJhY3RlciBrZXlcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09IDEgJiYgbmFtZSAhPSBcIiBcIikge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB0aGUgbmFtZSB3YXMgYWxyZWFkeSBtb2RpZmllZCBieSBzaGlmdCwgdHJ5IGxvb2tpbmdcbiAgICAgICAgICAgICAgICAvLyBpdCB1cCB3aXRob3V0IGl0cyBzaGlmdCBtb2RpZmllclxuICAgICAgICAgICAgICAgIGxldCBub1NoaWZ0ID0gbWFwW21vZGlmaWVycyhuYW1lLCBldmVudCwgZmFsc2UpXTtcbiAgICAgICAgICAgICAgICBpZiAobm9TaGlmdCAmJiBub1NoaWZ0KHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHZpZXcpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgbmFtZS5jaGFyQ29kZUF0KDApID4gMTI3KSAmJlxuICAgICAgICAgICAgICAgIChiYXNlTmFtZSA9IGJhc2VbZXZlbnQua2V5Q29kZV0pICYmIGJhc2VOYW1lICE9IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgZmFsbGluZyBiYWNrIHRvIHRoZSBrZXlDb2RlIHdoZW4gdGhlcmUncyBhIG1vZGlmaWVyXG4gICAgICAgICAgICAgICAgLy8gYWN0aXZlIG9yIHRoZSBjaGFyYWN0ZXIgcHJvZHVjZWQgaXNuJ3QgQVNDSUksIGFuZCBvdXIgdGFibGVcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWNlcyBhIGRpZmZlcmVudCBuYW1lIGZyb20gdGhlIHRoZSBrZXlDb2RlLiBTZWUgIzY2OCxcbiAgICAgICAgICAgICAgICAvLyAjMTA2MFxuICAgICAgICAgICAgICAgIGxldCBmcm9tQ29kZSA9IG1hcFttb2RpZmllcnMoYmFzZU5hbWUsIGV2ZW50KV07XG4gICAgICAgICAgICAgICAgaWYgKGZyb21Db2RlICYmIGZyb21Db2RlKHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHZpZXcpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxuZXhwb3J0IHsga2V5ZG93bkhhbmRsZXIsIGtleW1hcCB9O1xuIiwgImltcG9ydCB7IGxpZnRUYXJnZXQsIHJlcGxhY2VTdGVwLCBSZXBsYWNlU3RlcCwgY2FuSm9pbiwgam9pblBvaW50LCBjYW5TcGxpdCwgUmVwbGFjZUFyb3VuZFN0ZXAsIGZpbmRXcmFwcGluZyB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBTbGljZSwgRnJhZ21lbnQgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uLCBTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24sIEFsbFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcblxuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgaWYgdGhlcmUgaXMgb25lLlxuKi9cbmNvbnN0IGRlbGV0ZVNlbGVjdGlvbiA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBhdEJsb2NrU3RhcnQoc3RhdGUsIHZpZXcpIHtcbiAgICBsZXQgeyAkY3Vyc29yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJiYWNrd2FyZFwiLCBzdGF0ZSlcbiAgICAgICAgOiAkY3Vyc29yLnBhcmVudE9mZnNldCA+IDApKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gJGN1cnNvcjtcbn1cbi8qKlxuSWYgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLCB0cnkgdG9cbnJlZHVjZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGF0IGJsb2NrIGFuZCB0aGUgb25lIGJlZm9yZSBpdFx1MjAxNGlmXG50aGVyZSdzIGEgYmxvY2sgZGlyZWN0bHkgYmVmb3JlIGl0IHRoYXQgY2FuIGJlIGpvaW5lZCwgam9pbiB0aGVtLlxuSWYgbm90LCB0cnkgdG8gbW92ZSB0aGUgc2VsZWN0ZWQgYmxvY2sgY2xvc2VyIHRvIHRoZSBuZXh0IG9uZSBpblxudGhlIGRvY3VtZW50IHN0cnVjdHVyZSBieSBsaWZ0aW5nIGl0IG91dCBvZiBpdHMgcGFyZW50IG9yIG1vdmluZyBpdFxuaW50byBhIHBhcmVudCBvZiB0aGUgcHJldmlvdXMgYmxvY2suIFdpbGwgdXNlIHRoZSB2aWV3IGZvciBhY2N1cmF0ZVxuKGJpZGktYXdhcmUpIHN0YXJ0LW9mLXRleHRibG9jayBkZXRlY3Rpb24gaWYgZ2l2ZW4uXG4qL1xuY29uc3Qgam9pbkJhY2t3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCAkY3Vyc29yID0gYXRCbG9ja1N0YXJ0KHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGN1cnNvcik7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gbm9kZSBiZWZvcmUgdGhpcywgdHJ5IHRvIGxpZnRcbiAgICBpZiAoISRjdXQpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gJGN1cnNvci5ibG9ja1JhbmdlKCksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlO1xuICAgIC8vIEFwcGx5IHRoZSBqb2luaW5nIGFsZ29yaXRobVxuICAgIGlmICghYmVmb3JlLnR5cGUuc3BlYy5pc29sYXRpbmcgJiYgZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvLyBJZiB0aGUgbm9kZSBiZWxvdyBoYXMgbm8gY29udGVudCBhbmQgdGhlIG5vZGUgYWJvdmUgaXNcbiAgICAvLyBzZWxlY3RhYmxlLCBkZWxldGUgdGhlIG5vZGUgYmVsb3cgYW5kIHNlbGVjdCB0aGUgb25lIGFib3ZlLlxuICAgIGlmICgkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJlxuICAgICAgICAodGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSB8fCBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShiZWZvcmUpKSkge1xuICAgICAgICBsZXQgZGVsU3RlcCA9IHJlcGxhY2VTdGVwKHN0YXRlLmRvYywgJGN1cnNvci5iZWZvcmUoKSwgJGN1cnNvci5hZnRlcigpLCBTbGljZS5lbXB0eSk7XG4gICAgICAgIGlmIChkZWxTdGVwICYmIGRlbFN0ZXAuc2xpY2Uuc2l6ZSA8IGRlbFN0ZXAudG8gLSBkZWxTdGVwLmZyb20pIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAoZGVsU3RlcCk7XG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIikgPyBTZWxlY3Rpb24uZmluZEZyb20odHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5tYXAoJGN1dC5wb3MsIC0xKSksIC0xKVxuICAgICAgICAgICAgICAgICAgICA6IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJGN1dC5wb3MgLSBiZWZvcmUubm9kZVNpemUpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBub2RlIGJlZm9yZSBpcyBhbiBhdG9tLCBkZWxldGUgaXRcbiAgICBpZiAoYmVmb3JlLmlzQXRvbSAmJiAkY3V0LmRlcHRoID09ICRjdXJzb3IuZGVwdGggLSAxKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZSgkY3V0LnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSwgJGN1dC5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuQSBtb3JlIGxpbWl0ZWQgZm9ybSBvZiBbYGpvaW5CYWNrd2FyZGBdKCRjb21tYW5kcy5qb2luQmFja3dhcmQpXG50aGF0IG9ubHkgdHJpZXMgdG8gam9pbiB0aGUgY3VycmVudCB0ZXh0YmxvY2sgdG8gdGhlIG9uZSBiZWZvcmVcbml0LCBpZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jay5cbiovXG5jb25zdCBqb2luVGV4dGJsb2NrQmFja3dhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrU3RhcnQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEJlZm9yZSgkY3Vyc29yKTtcbiAgICByZXR1cm4gJGN1dCA/IGpvaW5UZXh0YmxvY2tzQXJvdW5kKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkgOiBmYWxzZTtcbn07XG4vKipcbkEgbW9yZSBsaW1pdGVkIGZvcm0gb2YgW2Bqb2luRm9yd2FyZGBdKCRjb21tYW5kcy5qb2luRm9yd2FyZClcbnRoYXQgb25seSB0cmllcyB0byBqb2luIHRoZSBjdXJyZW50IHRleHRibG9jayB0byB0aGUgb25lIGFmdGVyXG5pdCwgaWYgdGhlIGN1cnNvciBpcyBhdCB0aGUgZW5kIG9mIGEgdGV4dGJsb2NrLlxuKi9cbmNvbnN0IGpvaW5UZXh0YmxvY2tGb3J3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCAkY3Vyc29yID0gYXRCbG9ja0VuZChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QWZ0ZXIoJGN1cnNvcik7XG4gICAgcmV0dXJuICRjdXQgPyBqb2luVGV4dGJsb2Nrc0Fyb3VuZChzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpIDogZmFsc2U7XG59O1xuZnVuY3Rpb24gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSB7XG4gICAgbGV0IGJlZm9yZSA9ICRjdXQubm9kZUJlZm9yZSwgYmVmb3JlVGV4dCA9IGJlZm9yZSwgYmVmb3JlUG9zID0gJGN1dC5wb3MgLSAxO1xuICAgIGZvciAoOyAhYmVmb3JlVGV4dC5pc1RleHRibG9jazsgYmVmb3JlUG9zLS0pIHtcbiAgICAgICAgaWYgKGJlZm9yZVRleHQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gYmVmb3JlVGV4dC5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGJlZm9yZVRleHQgPSBjaGlsZDtcbiAgICB9XG4gICAgbGV0IGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXIsIGFmdGVyVGV4dCA9IGFmdGVyLCBhZnRlclBvcyA9ICRjdXQucG9zICsgMTtcbiAgICBmb3IgKDsgIWFmdGVyVGV4dC5pc1RleHRibG9jazsgYWZ0ZXJQb3MrKykge1xuICAgICAgICBpZiAoYWZ0ZXJUZXh0LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBjaGlsZCA9IGFmdGVyVGV4dC5maXJzdENoaWxkO1xuICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBhZnRlclRleHQgPSBjaGlsZDtcbiAgICB9XG4gICAgbGV0IHN0ZXAgPSByZXBsYWNlU3RlcChzdGF0ZS5kb2MsIGJlZm9yZVBvcywgYWZ0ZXJQb3MsIFNsaWNlLmVtcHR5KTtcbiAgICBpZiAoIXN0ZXAgfHwgc3RlcC5mcm9tICE9IGJlZm9yZVBvcyB8fFxuICAgICAgICBzdGVwIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXAgJiYgc3RlcC5zbGljZS5zaXplID49IGFmdGVyUG9zIC0gYmVmb3JlUG9zKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAoc3RlcCk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIGJlZm9yZVBvcykpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB0ZXh0YmxvY2tBdChub2RlLCBzaWRlLCBvbmx5ID0gZmFsc2UpIHtcbiAgICBmb3IgKGxldCBzY2FuID0gbm9kZTsgc2Nhbjsgc2NhbiA9IChzaWRlID09IFwic3RhcnRcIiA/IHNjYW4uZmlyc3RDaGlsZCA6IHNjYW4ubGFzdENoaWxkKSkge1xuICAgICAgICBpZiAoc2Nhbi5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob25seSAmJiBzY2FuLmNoaWxkQ291bnQgIT0gMSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG5XaGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jaywgc2VsZWN0XG50aGUgbm9kZSBiZWZvcmUgdGhhdCB0ZXh0YmxvY2ssIGlmIHBvc3NpYmxlLiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG5ib3VuZCB0byBrZXlzIGxpa2UgYmFja3NwYWNlLCBhZnRlclxuW2Bqb2luQmFja3dhcmRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuam9pbkJhY2t3YXJkKSBvciBvdGhlciBkZWxldGluZ1xuY29tbWFuZHMsIGFzIGEgZmFsbC1iYWNrIGJlaGF2aW9yIHdoZW4gdGhlIHNjaGVtYSBkb2Vzbid0IGFsbG93XG5kZWxldGlvbiBhdCB0aGUgc2VsZWN0ZWQgcG9pbnQuXG4qL1xuY29uc3Qgc2VsZWN0Tm9kZUJhY2t3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCB7ICRoZWFkLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uLCAkY3V0ID0gJGhlYWQ7XG4gICAgaWYgKCFlbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgkaGVhZC5wYXJlbnQuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgaWYgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImJhY2t3YXJkXCIsIHN0YXRlKSA6ICRoZWFkLnBhcmVudE9mZnNldCA+IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRoZWFkKTtcbiAgICB9XG4gICAgbGV0IG5vZGUgPSAkY3V0ICYmICRjdXQubm9kZUJlZm9yZTtcbiAgICBpZiAoIW5vZGUgfHwgIU5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCAkY3V0LnBvcyAtIG5vZGUubm9kZVNpemUpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBmaW5kQ3V0QmVmb3JlKCRwb3MpIHtcbiAgICBpZiAoISRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICgkcG9zLmluZGV4KGkpID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5kb2MucmVzb2x2ZSgkcG9zLmJlZm9yZShpICsgMSkpO1xuICAgICAgICAgICAgaWYgKCRwb3Mubm9kZShpKS50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBhdEJsb2NrRW5kKHN0YXRlLCB2aWV3KSB7XG4gICAgbGV0IHsgJGN1cnNvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGN1cnNvciB8fCAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiZm9yd2FyZFwiLCBzdGF0ZSlcbiAgICAgICAgOiAkY3Vyc29yLnBhcmVudE9mZnNldCA8ICRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiAkY3Vyc29yO1xufVxuLyoqXG5JZiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCB0aGUgY3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgYVxudGV4dGJsb2NrLCB0cnkgdG8gcmVkdWNlIG9yIHJlbW92ZSB0aGUgYm91bmRhcnkgYmV0d2VlbiB0aGF0IGJsb2NrXG5hbmQgdGhlIG9uZSBhZnRlciBpdCwgZWl0aGVyIGJ5IGpvaW5pbmcgdGhlbSBvciBieSBtb3ZpbmcgdGhlIG90aGVyXG5ibG9jayBjbG9zZXIgdG8gdGhpcyBvbmUgaW4gdGhlIHRyZWUgc3RydWN0dXJlLiBXaWxsIHVzZSB0aGUgdmlld1xuZm9yIGFjY3VyYXRlIHN0YXJ0LW9mLXRleHRibG9jayBkZXRlY3Rpb24gaWYgZ2l2ZW4uXG4qL1xuY29uc3Qgam9pbkZvcndhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrRW5kKHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRBZnRlcigkY3Vyc29yKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBub2RlIGFmdGVyIHRoaXMsIHRoZXJlJ3Mgbm90aGluZyB0byBkb1xuICAgIGlmICghJGN1dClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhZnRlciA9ICRjdXQubm9kZUFmdGVyO1xuICAgIC8vIFRyeSB0aGUgam9pbmluZyBhbGdvcml0aG1cbiAgICBpZiAoZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvLyBJZiB0aGUgbm9kZSBhYm92ZSBoYXMgbm8gY29udGVudCBhbmQgdGhlIG5vZGUgYmVsb3cgaXNcbiAgICAvLyBzZWxlY3RhYmxlLCBkZWxldGUgdGhlIG5vZGUgYWJvdmUgYW5kIHNlbGVjdCB0aGUgb25lIGJlbG93LlxuICAgIGlmICgkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJlxuICAgICAgICAodGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIikgfHwgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoYWZ0ZXIpKSkge1xuICAgICAgICBsZXQgZGVsU3RlcCA9IHJlcGxhY2VTdGVwKHN0YXRlLmRvYywgJGN1cnNvci5iZWZvcmUoKSwgJGN1cnNvci5hZnRlcigpLCBTbGljZS5lbXB0eSk7XG4gICAgICAgIGlmIChkZWxTdGVwICYmIGRlbFN0ZXAuc2xpY2Uuc2l6ZSA8IGRlbFN0ZXAudG8gLSBkZWxTdGVwLmZyb20pIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAoZGVsU3RlcCk7XG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIpID8gU2VsZWN0aW9uLmZpbmRGcm9tKHRyLmRvYy5yZXNvbHZlKHRyLm1hcHBpbmcubWFwKCRjdXQucG9zKSksIDEpXG4gICAgICAgICAgICAgICAgICAgIDogTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkY3V0LnBvcykpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBuZXh0IG5vZGUgaXMgYW4gYXRvbSwgZGVsZXRlIGl0XG4gICAgaWYgKGFmdGVyLmlzQXRvbSAmJiAkY3V0LmRlcHRoID09ICRjdXJzb3IuZGVwdGggLSAxKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZSgkY3V0LnBvcywgJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG5XaGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2ssIHNlbGVjdFxudGhlIG5vZGUgY29taW5nIGFmdGVyIHRoYXQgdGV4dGJsb2NrLCBpZiBwb3NzaWJsZS4gVGhpcyBpcyBpbnRlbmRlZFxudG8gYmUgYm91bmQgdG8ga2V5cyBsaWtlIGRlbGV0ZSwgYWZ0ZXJcbltgam9pbkZvcndhcmRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuam9pbkZvcndhcmQpIGFuZCBzaW1pbGFyIGRlbGV0aW5nXG5jb21tYW5kcywgdG8gcHJvdmlkZSBhIGZhbGwtYmFjayBiZWhhdmlvciB3aGVuIHRoZSBzY2hlbWEgZG9lc24ndFxuYWxsb3cgZGVsZXRpb24gYXQgdGhlIHNlbGVjdGVkIHBvaW50LlxuKi9cbmNvbnN0IHNlbGVjdE5vZGVGb3J3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCB7ICRoZWFkLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uLCAkY3V0ID0gJGhlYWQ7XG4gICAgaWYgKCFlbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgkaGVhZC5wYXJlbnQuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgaWYgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImZvcndhcmRcIiwgc3RhdGUpIDogJGhlYWQucGFyZW50T2Zmc2V0IDwgJGhlYWQucGFyZW50LmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgJGN1dCA9IGZpbmRDdXRBZnRlcigkaGVhZCk7XG4gICAgfVxuICAgIGxldCBub2RlID0gJGN1dCAmJiAkY3V0Lm5vZGVBZnRlcjtcbiAgICBpZiAoIW5vZGUgfHwgIU5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCAkY3V0LnBvcykpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGZpbmRDdXRBZnRlcigkcG9zKSB7XG4gICAgaWYgKCEkcG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gJHBvcy5ub2RlKGkpO1xuICAgICAgICAgICAgaWYgKCRwb3MuaW5kZXgoaSkgKyAxIDwgcGFyZW50LmNoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3MuZG9jLnJlc29sdmUoJHBvcy5hZnRlcihpICsgMSkpO1xuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbkpvaW4gdGhlIHNlbGVjdGVkIGJsb2NrIG9yLCBpZiB0aGVyZSBpcyBhIHRleHQgc2VsZWN0aW9uLCB0aGVcbmNsb3Nlc3QgYW5jZXN0b3IgYmxvY2sgb2YgdGhlIHNlbGVjdGlvbiB0aGF0IGNhbiBiZSBqb2luZWQsIHdpdGhcbnRoZSBzaWJsaW5nIGFib3ZlIGl0LlxuKi9cbmNvbnN0IGpvaW5VcCA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCBub2RlU2VsID0gc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiwgcG9pbnQ7XG4gICAgaWYgKG5vZGVTZWwpIHtcbiAgICAgICAgaWYgKHNlbC5ub2RlLmlzVGV4dGJsb2NrIHx8ICFjYW5Kb2luKHN0YXRlLmRvYywgc2VsLmZyb20pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwb2ludCA9IHNlbC5mcm9tO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzZWwuZnJvbSwgLTEpO1xuICAgICAgICBpZiAocG9pbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLmpvaW4ocG9pbnQpO1xuICAgICAgICBpZiAobm9kZVNlbClcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHBvaW50IC0gc3RhdGUuZG9jLnJlc29sdmUocG9pbnQpLm5vZGVCZWZvcmUubm9kZVNpemUpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSm9pbiB0aGUgc2VsZWN0ZWQgYmxvY2ssIG9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yIG9mIHRoZSBzZWxlY3Rpb25cbnRoYXQgY2FuIGJlIGpvaW5lZCwgd2l0aCB0aGUgc2libGluZyBhZnRlciBpdC5cbiovXG5jb25zdCBqb2luRG93biA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCBwb2ludDtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikge1xuICAgICAgICBpZiAoc2VsLm5vZGUuaXNUZXh0YmxvY2sgfHwgIWNhbkpvaW4oc3RhdGUuZG9jLCBzZWwudG8pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwb2ludCA9IHNlbC50bztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc2VsLnRvLCAxKTtcbiAgICAgICAgaWYgKHBvaW50ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuam9pbihwb2ludCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5MaWZ0IHRoZSBzZWxlY3RlZCBibG9jaywgb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgYmxvY2sgb2YgdGhlXG5zZWxlY3Rpb24gdGhhdCBjYW4gYmUgbGlmdGVkLCBvdXQgb2YgaXRzIHBhcmVudCBub2RlLlxuKi9cbmNvbnN0IGxpZnQgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSWYgdGhlIHNlbGVjdGlvbiBpcyBpbiBhIG5vZGUgd2hvc2UgdHlwZSBoYXMgYSB0cnV0aHlcbltgY29kZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5jb2RlKSBwcm9wZXJ0eSBpbiBpdHMgc3BlYywgcmVwbGFjZSB0aGVcbnNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZSBjaGFyYWN0ZXIuXG4qL1xuY29uc3QgbmV3bGluZUluQ29kZSA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkaGVhZCwgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQucGFyZW50LnR5cGUuc3BlYy5jb2RlIHx8ICEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5pbnNlcnRUZXh0KFwiXFxuXCIpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGRlZmF1bHRCbG9ja0F0KG1hdGNoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkrKykge1xuICAgICAgICBsZXQgeyB0eXBlIH0gPSBtYXRjaC5lZGdlKGkpO1xuICAgICAgICBpZiAodHlwZS5pc1RleHRibG9jayAmJiAhdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpXG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbldoZW4gdGhlIHNlbGVjdGlvbiBpcyBpbiBhIG5vZGUgd2l0aCBhIHRydXRoeVxuW2Bjb2RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmNvZGUpIHByb3BlcnR5IGluIGl0cyBzcGVjLCBjcmVhdGUgYVxuZGVmYXVsdCBibG9jayBhZnRlciB0aGUgY29kZSBibG9jaywgYW5kIG1vdmUgdGhlIGN1cnNvciB0aGVyZS5cbiovXG5jb25zdCBleGl0Q29kZSA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkaGVhZCwgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQucGFyZW50LnR5cGUuc3BlYy5jb2RlIHx8ICEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGFib3ZlID0gJGhlYWQubm9kZSgtMSksIGFmdGVyID0gJGhlYWQuaW5kZXhBZnRlcigtMSksIHR5cGUgPSBkZWZhdWx0QmxvY2tBdChhYm92ZS5jb250ZW50TWF0Y2hBdChhZnRlcikpO1xuICAgIGlmICghdHlwZSB8fCAhYWJvdmUuY2FuUmVwbGFjZVdpdGgoYWZ0ZXIsIGFmdGVyLCB0eXBlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgcG9zID0gJGhlYWQuYWZ0ZXIoKSwgdHIgPSBzdGF0ZS50ci5yZXBsYWNlV2l0aChwb3MsIHBvcywgdHlwZS5jcmVhdGVBbmRGaWxsKCkpO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUocG9zKSwgMSkpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JZiBhIGJsb2NrIG5vZGUgaXMgc2VsZWN0ZWQsIGNyZWF0ZSBhbiBlbXB0eSBwYXJhZ3JhcGggYmVmb3JlIChpZlxuaXQgaXMgaXRzIHBhcmVudCdzIGZpcnN0IGNoaWxkKSBvciBhZnRlciBpdC5cbiovXG5jb25zdCBjcmVhdGVQYXJhZ3JhcGhOZWFyID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIHsgJGZyb20sICR0byB9ID0gc2VsO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24gfHwgJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgfHwgJHRvLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHR5cGUgPSBkZWZhdWx0QmxvY2tBdCgkdG8ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCR0by5pbmRleEFmdGVyKCkpKTtcbiAgICBpZiAoIXR5cGUgfHwgIXR5cGUuaXNUZXh0YmxvY2spXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHNpZGUgPSAoISRmcm9tLnBhcmVudE9mZnNldCAmJiAkdG8uaW5kZXgoKSA8ICR0by5wYXJlbnQuY2hpbGRDb3VudCA/ICRmcm9tIDogJHRvKS5wb3M7XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLmluc2VydChzaWRlLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHNpZGUgKyAxKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbklmIHRoZSBjdXJzb3IgaXMgaW4gYW4gZW1wdHkgdGV4dGJsb2NrIHRoYXQgY2FuIGJlIGxpZnRlZCwgbGlmdCB0aGVcbmJsb2NrLlxuKi9cbmNvbnN0IGxpZnRFbXB0eUJsb2NrID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRjdXJzb3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRjdXJzb3IgfHwgJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRjdXJzb3IuZGVwdGggPiAxICYmICRjdXJzb3IuYWZ0ZXIoKSAhPSAkY3Vyc29yLmVuZCgtMSkpIHtcbiAgICAgICAgbGV0IGJlZm9yZSA9ICRjdXJzb3IuYmVmb3JlKCk7XG4gICAgICAgIGlmIChjYW5TcGxpdChzdGF0ZS5kb2MsIGJlZm9yZSkpIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zcGxpdChiZWZvcmUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJhbmdlID0gJGN1cnNvci5ibG9ja1JhbmdlKCksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkNyZWF0ZSBhIHZhcmlhbnQgb2YgW2BzcGxpdEJsb2NrYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLnNwbGl0QmxvY2spIHRoYXQgdXNlc1xuYSBjdXN0b20gZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIHRoZSBuZXdseSBzcGxpdCBvZmYgYmxvY2suXG4qL1xuZnVuY3Rpb24gc3BsaXRCbG9ja0FzKHNwbGl0Tm9kZSkge1xuICAgIHJldHVybiAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc3RhdGUuc2VsZWN0aW9uLm5vZGUuaXNCbG9jaykge1xuICAgICAgICAgICAgaWYgKCEkZnJvbS5wYXJlbnRPZmZzZXQgfHwgIWNhblNwbGl0KHN0YXRlLmRvYywgJGZyb20ucG9zKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc3BsaXQoJGZyb20ucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghJGZyb20ucGFyZW50LmlzQmxvY2spXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgbGV0IGF0RW5kID0gJHRvLnBhcmVudE9mZnNldCA9PSAkdG8ucGFyZW50LmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gfHwgc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgIHRyLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgbGV0IGRlZmx0ID0gJGZyb20uZGVwdGggPT0gMCA/IG51bGwgOiBkZWZhdWx0QmxvY2tBdCgkZnJvbS5ub2RlKC0xKS5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleEFmdGVyKC0xKSkpO1xuICAgICAgICAgICAgbGV0IHNwbGl0VHlwZSA9IHNwbGl0Tm9kZSAmJiBzcGxpdE5vZGUoJHRvLnBhcmVudCwgYXRFbmQpO1xuICAgICAgICAgICAgbGV0IHR5cGVzID0gc3BsaXRUeXBlID8gW3NwbGl0VHlwZV0gOiBhdEVuZCAmJiBkZWZsdCA/IFt7IHR5cGU6IGRlZmx0IH1dIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGNhbiA9IGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpO1xuICAgICAgICAgICAgaWYgKCF0eXBlcyAmJiAhY2FuICYmIGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgZGVmbHQgPyBbeyB0eXBlOiBkZWZsdCB9XSA6IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmbHQpXG4gICAgICAgICAgICAgICAgICAgIHR5cGVzID0gW3sgdHlwZTogZGVmbHQgfV07XG4gICAgICAgICAgICAgICAgY2FuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW4pIHtcbiAgICAgICAgICAgICAgICB0ci5zcGxpdCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFhdEVuZCAmJiAhJGZyb20ucGFyZW50T2Zmc2V0ICYmICRmcm9tLnBhcmVudC50eXBlICE9IGRlZmx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKSwgJGZpcnN0ID0gdHIuZG9jLnJlc29sdmUoZmlyc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmbHQgJiYgJGZyb20ubm9kZSgtMSkuY2FuUmVwbGFjZVdpdGgoJGZpcnN0LmluZGV4KCksICRmaXJzdC5pbmRleCgpICsgMSwgZGVmbHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSksIGRlZmx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5TcGxpdCB0aGUgcGFyZW50IGJsb2NrIG9mIHRoZSBzZWxlY3Rpb24uIElmIHRoZSBzZWxlY3Rpb24gaXMgYSB0ZXh0XG5zZWxlY3Rpb24sIGFsc28gZGVsZXRlIGl0cyBjb250ZW50LlxuKi9cbmNvbnN0IHNwbGl0QmxvY2sgPSBzcGxpdEJsb2NrQXMoKTtcbi8qKlxuQWN0cyBsaWtlIFtgc3BsaXRCbG9ja2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5zcGxpdEJsb2NrKSwgYnV0IHdpdGhvdXRcbnJlc2V0dGluZyB0aGUgc2V0IG9mIGFjdGl2ZSBtYXJrcyBhdCB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IHNwbGl0QmxvY2tLZWVwTWFya3MgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgcmV0dXJuIHNwbGl0QmxvY2soc3RhdGUsIGRpc3BhdGNoICYmICh0ciA9PiB7XG4gICAgICAgIGxldCBtYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzIHx8IChzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XG4gICAgICAgIGlmIChtYXJrcylcbiAgICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKG1hcmtzKTtcbiAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgIH0pKTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgbm9kZSB3cmFwcGluZyB0aGUgY3VycmVudCBzZWxlY3Rpb24sIGlmXG5hbnkuIChXaWxsIG5vdCBzZWxlY3QgdGhlIGRvY3VtZW50IG5vZGUuKVxuKi9cbmNvbnN0IHNlbGVjdFBhcmVudE5vZGUgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGZyb20sIHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb24sIHBvcztcbiAgICBsZXQgc2FtZSA9ICRmcm9tLnNoYXJlZERlcHRoKHRvKTtcbiAgICBpZiAoc2FtZSA9PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcG9zID0gJGZyb20uYmVmb3JlKHNhbWUpO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgcG9zKSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuU2VsZWN0IHRoZSB3aG9sZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3RBbGwgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IEFsbFNlbGVjdGlvbihzdGF0ZS5kb2MpKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gam9pbk1heWJlQ2xlYXIoc3RhdGUsICRwb3MsIGRpc3BhdGNoKSB7XG4gICAgbGV0IGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZSwgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlciwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgaWYgKCFiZWZvcmUgfHwgIWFmdGVyIHx8ICFiZWZvcmUudHlwZS5jb21wYXRpYmxlQ29udGVudChhZnRlci50eXBlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghYmVmb3JlLmNvbnRlbnQuc2l6ZSAmJiAkcG9zLnBhcmVudC5jYW5SZXBsYWNlKGluZGV4IC0gMSwgaW5kZXgpKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZSgkcG9zLnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSwgJHBvcy5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCEkcG9zLnBhcmVudC5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCArIDEpIHx8ICEoYWZ0ZXIuaXNUZXh0YmxvY2sgfHwgY2FuSm9pbihzdGF0ZS5kb2MsICRwb3MucG9zKSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyXG4gICAgICAgICAgICAuY2xlYXJJbmNvbXBhdGlibGUoJHBvcy5wb3MsIGJlZm9yZS50eXBlLCBiZWZvcmUuY29udGVudE1hdGNoQXQoYmVmb3JlLmNoaWxkQ291bnQpKVxuICAgICAgICAgICAgLmpvaW4oJHBvcy5wb3MpXG4gICAgICAgICAgICAuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkge1xuICAgIGxldCBiZWZvcmUgPSAkY3V0Lm5vZGVCZWZvcmUsIGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXIsIGNvbm4sIG1hdGNoO1xuICAgIGlmIChiZWZvcmUudHlwZS5zcGVjLmlzb2xhdGluZyB8fCBhZnRlci50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGpvaW5NYXliZUNsZWFyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBjYW5EZWxBZnRlciA9ICRjdXQucGFyZW50LmNhblJlcGxhY2UoJGN1dC5pbmRleCgpLCAkY3V0LmluZGV4KCkgKyAxKTtcbiAgICBpZiAoY2FuRGVsQWZ0ZXIgJiZcbiAgICAgICAgKGNvbm4gPSAobWF0Y2ggPSBiZWZvcmUuY29udGVudE1hdGNoQXQoYmVmb3JlLmNoaWxkQ291bnQpKS5maW5kV3JhcHBpbmcoYWZ0ZXIudHlwZSkpICYmXG4gICAgICAgIG1hdGNoLm1hdGNoVHlwZShjb25uWzBdIHx8IGFmdGVyLnR5cGUpLnZhbGlkRW5kKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgbGV0IGVuZCA9ICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUsIHdyYXAgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBjb25uLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgIHdyYXAgPSBGcmFnbWVudC5mcm9tKGNvbm5baV0uY3JlYXRlKG51bGwsIHdyYXApKTtcbiAgICAgICAgICAgIHdyYXAgPSBGcmFnbWVudC5mcm9tKGJlZm9yZS5jb3B5KHdyYXApKTtcbiAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKCRjdXQucG9zIC0gMSwgZW5kLCAkY3V0LnBvcywgZW5kLCBuZXcgU2xpY2Uod3JhcCwgMSwgMCksIGNvbm4ubGVuZ3RoLCB0cnVlKSk7XG4gICAgICAgICAgICBsZXQgam9pbkF0ID0gZW5kICsgMiAqIGNvbm4ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGNhbkpvaW4odHIuZG9jLCBqb2luQXQpKVxuICAgICAgICAgICAgICAgIHRyLmpvaW4oam9pbkF0KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgc2VsQWZ0ZXIgPSBTZWxlY3Rpb24uZmluZEZyb20oJGN1dCwgMSk7XG4gICAgbGV0IHJhbmdlID0gc2VsQWZ0ZXIgJiYgc2VsQWZ0ZXIuJGZyb20uYmxvY2tSYW5nZShzZWxBZnRlci4kdG8pLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ICE9IG51bGwgJiYgdGFyZ2V0ID49ICRjdXQuZGVwdGgpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjYW5EZWxBZnRlciAmJiB0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiLCB0cnVlKSAmJiB0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpKSB7XG4gICAgICAgIGxldCBhdCA9IGJlZm9yZSwgd3JhcCA9IFtdO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICB3cmFwLnB1c2goYXQpO1xuICAgICAgICAgICAgaWYgKGF0LmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgYXQgPSBhdC5sYXN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFmdGVyVGV4dCA9IGFmdGVyLCBhZnRlckRlcHRoID0gMTtcbiAgICAgICAgZm9yICg7ICFhZnRlclRleHQuaXNUZXh0YmxvY2s7IGFmdGVyVGV4dCA9IGFmdGVyVGV4dC5maXJzdENoaWxkKVxuICAgICAgICAgICAgYWZ0ZXJEZXB0aCsrO1xuICAgICAgICBpZiAoYXQuY2FuUmVwbGFjZShhdC5jaGlsZENvdW50LCBhdC5jaGlsZENvdW50LCBhZnRlclRleHQuY29udGVudCkpIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gd3JhcC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gRnJhZ21lbnQuZnJvbSh3cmFwW2ldLmNvcHkoZW5kKSk7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGN1dC5wb3MgLSB3cmFwLmxlbmd0aCwgJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSwgJGN1dC5wb3MgKyBhZnRlckRlcHRoLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplIC0gYWZ0ZXJEZXB0aCwgbmV3IFNsaWNlKGVuZCwgd3JhcC5sZW5ndGgsIDApLCAwLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3RUZXh0YmxvY2tTaWRlKHNpZGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCAkcG9zID0gc2lkZSA8IDAgPyBzZWwuJGZyb20gOiBzZWwuJHRvO1xuICAgICAgICBsZXQgZGVwdGggPSAkcG9zLmRlcHRoO1xuICAgICAgICB3aGlsZSAoJHBvcy5ub2RlKGRlcHRoKS5pc0lubGluZSkge1xuICAgICAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9XG4gICAgICAgIGlmICghJHBvcy5ub2RlKGRlcHRoKS5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgc2lkZSA8IDAgPyAkcG9zLnN0YXJ0KGRlcHRoKSA6ICRwb3MuZW5kKGRlcHRoKSkpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuTW92ZXMgdGhlIGN1cnNvciB0byB0aGUgc3RhcnQgb2YgY3VycmVudCB0ZXh0IGJsb2NrLlxuKi9cbmNvbnN0IHNlbGVjdFRleHRibG9ja1N0YXJ0ID0gc2VsZWN0VGV4dGJsb2NrU2lkZSgtMSk7XG4vKipcbk1vdmVzIHRoZSBjdXJzb3IgdG8gdGhlIGVuZCBvZiBjdXJyZW50IHRleHQgYmxvY2suXG4qL1xuY29uc3Qgc2VsZWN0VGV4dGJsb2NrRW5kID0gc2VsZWN0VGV4dGJsb2NrU2lkZSgxKTtcbi8vIFBhcmFtZXRlcml6ZWQgY29tbWFuZHNcbi8qKlxuV3JhcCB0aGUgc2VsZWN0aW9uIGluIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSB3aXRoIHRoZSBnaXZlblxuYXR0cmlidXRlcy5cbiovXG5mdW5jdGlvbiB3cmFwSW4obm9kZVR5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLCB3cmFwcGluZyA9IHJhbmdlICYmIGZpbmRXcmFwcGluZyhyYW5nZSwgbm9kZVR5cGUsIGF0dHJzKTtcbiAgICAgICAgaWYgKCF3cmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIud3JhcChyYW5nZSwgd3JhcHBpbmcpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5SZXR1cm5zIGEgY29tbWFuZCB0aGF0IHRyaWVzIHRvIHNldCB0aGUgc2VsZWN0ZWQgdGV4dGJsb2NrcyB0byB0aGVcbmdpdmVuIG5vZGUgdHlwZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuKi9cbmZ1bmN0aW9uIHNldEJsb2NrVHlwZShub2RlVHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IGFwcGxpY2FibGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aCAmJiAhYXBwbGljYWJsZTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyAkZnJvbTogeyBwb3M6IGZyb20gfSwgJHRvOiB7IHBvczogdG8gfSB9ID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlc1tpXTtcbiAgICAgICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwbGljYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5pc1RleHRibG9jayB8fCBub2RlLmhhc01hcmt1cChub2RlVHlwZSwgYXR0cnMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWNhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCAkcG9zID0gc3RhdGUuZG9jLnJlc29sdmUocG9zKSwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2FibGUgPSAkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXggKyAxLCBub2RlVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcHBsaWNhYmxlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgJGZyb206IHsgcG9zOiBmcm9tIH0sICR0bzogeyBwb3M6IHRvIH0gfSA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgdHIuc2V0QmxvY2tUeXBlKGZyb20sIHRvLCBub2RlVHlwZSwgYXR0cnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1hcmtBcHBsaWVzKGRvYywgcmFuZ2VzLCB0eXBlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICBsZXQgY2FuID0gJGZyb20uZGVwdGggPT0gMCA/IGRvYy5pbmxpbmVDb250ZW50ICYmIGRvYy50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpIDogZmFsc2U7XG4gICAgICAgIGRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCBub2RlID0+IHtcbiAgICAgICAgICAgIGlmIChjYW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FuID0gbm9kZS5pbmxpbmVDb250ZW50ICYmIG5vZGUudHlwZS5hbGxvd3NNYXJrVHlwZSh0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjYW4pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG5DcmVhdGUgYSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgdG9nZ2xlcyB0aGUgZ2l2ZW4gbWFyayB3aXRoIHRoZVxuZ2l2ZW4gYXR0cmlidXRlcy4gV2lsbCByZXR1cm4gYGZhbHNlYCB3aGVuIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuZG9lc24ndCBzdXBwb3J0IHRoYXQgbWFyay4gVGhpcyB3aWxsIHJlbW92ZSB0aGUgbWFyayBpZiBhbnkgbWFya3Ncbm9mIHRoYXQgdHlwZSBleGlzdCBpbiB0aGUgc2VsZWN0aW9uLCBvciBhZGQgaXQgb3RoZXJ3aXNlLiBJZiB0aGVcbnNlbGVjdGlvbiBpcyBlbXB0eSwgdGhpcyBhcHBsaWVzIHRvIHRoZSBbc3RvcmVkXG5tYXJrc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnN0b3JlZE1hcmtzKSBpbnN0ZWFkIG9mIGEgcmFuZ2Ugb2YgdGhlXG5kb2N1bWVudC5cbiovXG5mdW5jdGlvbiB0b2dnbGVNYXJrKG1hcmtUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyBlbXB0eSwgJGN1cnNvciwgcmFuZ2VzIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmICgoZW1wdHkgJiYgISRjdXJzb3IpIHx8ICFtYXJrQXBwbGllcyhzdGF0ZS5kb2MsIHJhbmdlcywgbWFya1R5cGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGlmICgkY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtUeXBlLmlzSW5TZXQoc3RhdGUuc3RvcmVkTWFya3MgfHwgJGN1cnNvci5tYXJrcygpKSlcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIucmVtb3ZlU3RvcmVkTWFyayhtYXJrVHlwZSkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuYWRkU3RvcmVkTWFyayhtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaGFzID0gZmFsc2UsIHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7ICFoYXMgJiYgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGhhcyA9IHN0YXRlLmRvYy5yYW5nZUhhc01hcmsoJGZyb20ucG9zLCAkdG8ucG9zLCBtYXJrVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIucmVtb3ZlTWFyaygkZnJvbS5wb3MsICR0by5wb3MsIG1hcmtUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gJGZyb20ucG9zLCB0byA9ICR0by5wb3MsIHN0YXJ0ID0gJGZyb20ubm9kZUFmdGVyLCBlbmQgPSAkdG8ubm9kZUJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZVN0YXJ0ID0gc3RhcnQgJiYgc3RhcnQuaXNUZXh0ID8gL15cXHMqLy5leGVjKHN0YXJ0LnRleHQpWzBdLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2VFbmQgPSBlbmQgJiYgZW5kLmlzVGV4dCA/IC9cXHMqJC8uZXhlYyhlbmQudGV4dClbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tICsgc3BhY2VTdGFydCA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSArPSBzcGFjZVN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIC09IHNwYWNlRW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkTWFyayhmcm9tLCB0bywgbWFya1R5cGUuY3JlYXRlKGF0dHJzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHdyYXBEaXNwYXRjaEZvckpvaW4oZGlzcGF0Y2gsIGlzSm9pbmFibGUpIHtcbiAgICByZXR1cm4gKHRyKSA9PiB7XG4gICAgICAgIGlmICghdHIuaXNHZW5lcmljKVxuICAgICAgICAgICAgcmV0dXJuIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyLm1hcHBpbmcubWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcCA9IHRyLm1hcHBpbmcubWFwc1tpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmFuZ2VzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIHJhbmdlc1tqXSA9IG1hcC5tYXAocmFuZ2VzW2pdKTtcbiAgICAgICAgICAgIG1hcC5mb3JFYWNoKChfcywgX2UsIGZyb20sIHRvKSA9PiByYW5nZXMucHVzaChmcm9tLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2ggam9pbmFibGUgcG9pbnRzIGV4aXN0IGluc2lkZSB0aG9zZSByYW5nZXMsXG4gICAgICAgIC8vIGJ5IGNoZWNraW5nIGFsbCBub2RlIGJvdW5kYXJpZXMgaW4gdGhlaXIgcGFyZW50IG5vZGVzLlxuICAgICAgICBsZXQgam9pbmFibGUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gcmFuZ2VzW2ldLCB0byA9IHJhbmdlc1tpICsgMV07XG4gICAgICAgICAgICBsZXQgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSwgZGVwdGggPSAkZnJvbS5zaGFyZWREZXB0aCh0byksIHBhcmVudCA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSwgcG9zID0gJGZyb20uYWZ0ZXIoZGVwdGggKyAxKTsgcG9zIDw9IHRvOyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFmdGVyID0gcGFyZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAmJiBqb2luYWJsZS5pbmRleE9mKHBvcykgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHBhcmVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmVmb3JlLnR5cGUgPT0gYWZ0ZXIudHlwZSAmJiBpc0pvaW5hYmxlKGJlZm9yZSwgYWZ0ZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbmFibGUucHVzaChwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgKz0gYWZ0ZXIubm9kZVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSm9pbiB0aGUgam9pbmFibGUgcG9pbnRzXG4gICAgICAgIGpvaW5hYmxlLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGpvaW5hYmxlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoY2FuSm9pbih0ci5kb2MsIGpvaW5hYmxlW2ldKSlcbiAgICAgICAgICAgICAgICB0ci5qb2luKGpvaW5hYmxlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgfTtcbn1cbi8qKlxuV3JhcCBhIGNvbW1hbmQgc28gdGhhdCwgd2hlbiBpdCBwcm9kdWNlcyBhIHRyYW5zZm9ybSB0aGF0IGNhdXNlc1xudHdvIGpvaW5hYmxlIG5vZGVzIHRvIGVuZCB1cCBuZXh0IHRvIGVhY2ggb3RoZXIsIHRob3NlIGFyZSBqb2luZWQuXG5Ob2RlcyBhcmUgY29uc2lkZXJlZCBqb2luYWJsZSB3aGVuIHRoZXkgYXJlIG9mIHRoZSBzYW1lIHR5cGUgYW5kXG53aGVuIHRoZSBgaXNKb2luYWJsZWAgcHJlZGljYXRlIHJldHVybnMgdHJ1ZSBmb3IgdGhlbSBvciwgaWYgYW5cbmFycmF5IG9mIHN0cmluZ3Mgd2FzIHBhc3NlZCwgaWYgdGhlaXIgbm9kZSB0eXBlIG5hbWUgaXMgaW4gdGhhdFxuYXJyYXkuXG4qL1xuZnVuY3Rpb24gYXV0b0pvaW4oY29tbWFuZCwgaXNKb2luYWJsZSkge1xuICAgIGxldCBjYW5Kb2luID0gQXJyYXkuaXNBcnJheShpc0pvaW5hYmxlKSA/IChub2RlKSA9PiBpc0pvaW5hYmxlLmluZGV4T2Yobm9kZS50eXBlLm5hbWUpID4gLTFcbiAgICAgICAgOiBpc0pvaW5hYmxlO1xuICAgIHJldHVybiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiBjb21tYW5kKHN0YXRlLCBkaXNwYXRjaCAmJiB3cmFwRGlzcGF0Y2hGb3JKb2luKGRpc3BhdGNoLCBjYW5Kb2luKSwgdmlldyk7XG59XG4vKipcbkNvbWJpbmUgYSBudW1iZXIgb2YgY29tbWFuZCBmdW5jdGlvbnMgaW50byBhIHNpbmdsZSBmdW5jdGlvbiAod2hpY2hcbmNhbGxzIHRoZW0gb25lIGJ5IG9uZSB1bnRpbCBvbmUgcmV0dXJucyB0cnVlKS5cbiovXG5mdW5jdGlvbiBjaGFpbkNvbW1hbmRzKC4uLmNvbW1hbmRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjb21tYW5kc1tpXShzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cbmxldCBiYWNrc3BhY2UgPSBjaGFpbkNvbW1hbmRzKGRlbGV0ZVNlbGVjdGlvbiwgam9pbkJhY2t3YXJkLCBzZWxlY3ROb2RlQmFja3dhcmQpO1xubGV0IGRlbCA9IGNoYWluQ29tbWFuZHMoZGVsZXRlU2VsZWN0aW9uLCBqb2luRm9yd2FyZCwgc2VsZWN0Tm9kZUZvcndhcmQpO1xuLyoqXG5BIGJhc2ljIGtleW1hcCBjb250YWluaW5nIGJpbmRpbmdzIG5vdCBzcGVjaWZpYyB0byBhbnkgc2NoZW1hLlxuQmluZHMgdGhlIGZvbGxvd2luZyBrZXlzICh3aGVuIG11bHRpcGxlIGNvbW1hbmRzIGFyZSBsaXN0ZWQsIHRoZXlcbmFyZSBjaGFpbmVkIHdpdGggW2BjaGFpbkNvbW1hbmRzYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLmNoYWluQ29tbWFuZHMpKTpcblxuKiAqKkVudGVyKiogdG8gYG5ld2xpbmVJbkNvZGVgLCBgY3JlYXRlUGFyYWdyYXBoTmVhcmAsIGBsaWZ0RW1wdHlCbG9ja2AsIGBzcGxpdEJsb2NrYFxuKiAqKk1vZC1FbnRlcioqIHRvIGBleGl0Q29kZWBcbiogKipCYWNrc3BhY2UqKiBhbmQgKipNb2QtQmFja3NwYWNlKiogdG8gYGRlbGV0ZVNlbGVjdGlvbmAsIGBqb2luQmFja3dhcmRgLCBgc2VsZWN0Tm9kZUJhY2t3YXJkYFxuKiAqKkRlbGV0ZSoqIGFuZCAqKk1vZC1EZWxldGUqKiB0byBgZGVsZXRlU2VsZWN0aW9uYCwgYGpvaW5Gb3J3YXJkYCwgYHNlbGVjdE5vZGVGb3J3YXJkYFxuKiAqKk1vZC1EZWxldGUqKiB0byBgZGVsZXRlU2VsZWN0aW9uYCwgYGpvaW5Gb3J3YXJkYCwgYHNlbGVjdE5vZGVGb3J3YXJkYFxuKiAqKk1vZC1hKiogdG8gYHNlbGVjdEFsbGBcbiovXG5jb25zdCBwY0Jhc2VLZXltYXAgPSB7XG4gICAgXCJFbnRlclwiOiBjaGFpbkNvbW1hbmRzKG5ld2xpbmVJbkNvZGUsIGNyZWF0ZVBhcmFncmFwaE5lYXIsIGxpZnRFbXB0eUJsb2NrLCBzcGxpdEJsb2NrKSxcbiAgICBcIk1vZC1FbnRlclwiOiBleGl0Q29kZSxcbiAgICBcIkJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gICAgXCJNb2QtQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgICBcIlNoaWZ0LUJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gICAgXCJEZWxldGVcIjogZGVsLFxuICAgIFwiTW9kLURlbGV0ZVwiOiBkZWwsXG4gICAgXCJNb2QtYVwiOiBzZWxlY3RBbGxcbn07XG4vKipcbkEgY29weSBvZiBgcGNCYXNlS2V5bWFwYCB0aGF0IGFsc28gYmluZHMgKipDdHJsLWgqKiBsaWtlIEJhY2tzcGFjZSxcbioqQ3RybC1kKiogbGlrZSBEZWxldGUsICoqQWx0LUJhY2tzcGFjZSoqIGxpa2UgQ3RybC1CYWNrc3BhY2UsIGFuZFxuKipDdHJsLUFsdC1CYWNrc3BhY2UqKiwgKipBbHQtRGVsZXRlKiosIGFuZCAqKkFsdC1kKiogbGlrZVxuQ3RybC1EZWxldGUuXG4qL1xuY29uc3QgbWFjQmFzZUtleW1hcCA9IHtcbiAgICBcIkN0cmwtaFwiOiBwY0Jhc2VLZXltYXBbXCJCYWNrc3BhY2VcIl0sXG4gICAgXCJBbHQtQmFja3NwYWNlXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1CYWNrc3BhY2VcIl0sXG4gICAgXCJDdHJsLWRcIjogcGNCYXNlS2V5bWFwW1wiRGVsZXRlXCJdLFxuICAgIFwiQ3RybC1BbHQtQmFja3NwYWNlXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gICAgXCJBbHQtRGVsZXRlXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gICAgXCJBbHQtZFwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICAgIFwiQ3RybC1hXCI6IHNlbGVjdFRleHRibG9ja1N0YXJ0LFxuICAgIFwiQ3RybC1lXCI6IHNlbGVjdFRleHRibG9ja0VuZFxufTtcbmZvciAobGV0IGtleSBpbiBwY0Jhc2VLZXltYXApXG4gICAgbWFjQmFzZUtleW1hcFtrZXldID0gcGNCYXNlS2V5bWFwW2tleV07XG5jb25zdCBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyAvTWFjfGlQKGhvbmV8W29hXWQpLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgOiB0eXBlb2Ygb3MgIT0gXCJ1bmRlZmluZWRcIiAmJiBvcy5wbGF0Zm9ybSA/IG9zLnBsYXRmb3JtKCkgPT0gXCJkYXJ3aW5cIiA6IGZhbHNlO1xuLyoqXG5EZXBlbmRpbmcgb24gdGhlIGRldGVjdGVkIHBsYXRmb3JtLCB0aGlzIHdpbGwgaG9sZFxuW2BwY0Jhc2VrZXltYXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMucGNCYXNlS2V5bWFwKSBvclxuW2BtYWNCYXNlS2V5bWFwYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLm1hY0Jhc2VLZXltYXApLlxuKi9cbmNvbnN0IGJhc2VLZXltYXAgPSBtYWMgPyBtYWNCYXNlS2V5bWFwIDogcGNCYXNlS2V5bWFwO1xuXG5leHBvcnQgeyBhdXRvSm9pbiwgYmFzZUtleW1hcCwgY2hhaW5Db21tYW5kcywgY3JlYXRlUGFyYWdyYXBoTmVhciwgZGVsZXRlU2VsZWN0aW9uLCBleGl0Q29kZSwgam9pbkJhY2t3YXJkLCBqb2luRG93biwgam9pbkZvcndhcmQsIGpvaW5UZXh0YmxvY2tCYWNrd2FyZCwgam9pblRleHRibG9ja0ZvcndhcmQsIGpvaW5VcCwgbGlmdCwgbGlmdEVtcHR5QmxvY2ssIG1hY0Jhc2VLZXltYXAsIG5ld2xpbmVJbkNvZGUsIHBjQmFzZUtleW1hcCwgc2VsZWN0QWxsLCBzZWxlY3ROb2RlQmFja3dhcmQsIHNlbGVjdE5vZGVGb3J3YXJkLCBzZWxlY3RQYXJlbnROb2RlLCBzZWxlY3RUZXh0YmxvY2tFbmQsIHNlbGVjdFRleHRibG9ja1N0YXJ0LCBzZXRCbG9ja1R5cGUsIHNwbGl0QmxvY2ssIHNwbGl0QmxvY2tBcywgc3BsaXRCbG9ja0tlZXBNYXJrcywgdG9nZ2xlTWFyaywgd3JhcEluIH07XG4iLCAiaW1wb3J0IHsgZmluZFdyYXBwaW5nLCBSZXBsYWNlQXJvdW5kU3RlcCwgY2FuU3BsaXQsIGxpZnRUYXJnZXQsIGNhbkpvaW4gfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgTm9kZVJhbmdlLCBGcmFnbWVudCwgU2xpY2UgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBTZWxlY3Rpb24gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5cbmNvbnN0IG9sRE9NID0gW1wib2xcIiwgMF0sIHVsRE9NID0gW1widWxcIiwgMF0sIGxpRE9NID0gW1wibGlcIiwgMF07XG4vKipcbkFuIG9yZGVyZWQgbGlzdCBbbm9kZSBzcGVjXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMpLiBIYXMgYSBzaW5nbGVcbmF0dHJpYnV0ZSwgYG9yZGVyYCwgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIGF0IHdoaWNoIHRoZSBsaXN0XG5zdGFydHMgY291bnRpbmcsIGFuZCBkZWZhdWx0cyB0byAxLiBSZXByZXNlbnRlZCBhcyBhbiBgPG9sPmBcbmVsZW1lbnQuXG4qL1xuY29uc3Qgb3JkZXJlZExpc3QgPSB7XG4gICAgYXR0cnM6IHsgb3JkZXI6IHsgZGVmYXVsdDogMSB9IH0sXG4gICAgcGFyc2VET006IFt7IHRhZzogXCJvbFwiLCBnZXRBdHRycyhkb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBvcmRlcjogZG9tLmhhc0F0dHJpYnV0ZShcInN0YXJ0XCIpID8gK2RvbS5nZXRBdHRyaWJ1dGUoXCJzdGFydFwiKSA6IDEgfTtcbiAgICAgICAgICAgIH0gfV0sXG4gICAgdG9ET00obm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5hdHRycy5vcmRlciA9PSAxID8gb2xET00gOiBbXCJvbFwiLCB7IHN0YXJ0OiBub2RlLmF0dHJzLm9yZGVyIH0sIDBdO1xuICAgIH1cbn07XG4vKipcbkEgYnVsbGV0IGxpc3Qgbm9kZSBzcGVjLCByZXByZXNlbnRlZCBpbiB0aGUgRE9NIGFzIGA8dWw+YC5cbiovXG5jb25zdCBidWxsZXRMaXN0ID0ge1xuICAgIHBhcnNlRE9NOiBbeyB0YWc6IFwidWxcIiB9XSxcbiAgICB0b0RPTSgpIHsgcmV0dXJuIHVsRE9NOyB9XG59O1xuLyoqXG5BIGxpc3QgaXRlbSAoYDxsaT5gKSBzcGVjLlxuKi9cbmNvbnN0IGxpc3RJdGVtID0ge1xuICAgIHBhcnNlRE9NOiBbeyB0YWc6IFwibGlcIiB9XSxcbiAgICB0b0RPTSgpIHsgcmV0dXJuIGxpRE9NOyB9LFxuICAgIGRlZmluaW5nOiB0cnVlXG59O1xuZnVuY3Rpb24gYWRkKG9iaiwgcHJvcHMpIHtcbiAgICBsZXQgY29weSA9IHt9O1xuICAgIGZvciAobGV0IHByb3AgaW4gb2JqKVxuICAgICAgICBjb3B5W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIGZvciAobGV0IHByb3AgaW4gcHJvcHMpXG4gICAgICAgIGNvcHlbcHJvcF0gPSBwcm9wc1twcm9wXTtcbiAgICByZXR1cm4gY29weTtcbn1cbi8qKlxuQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGFkZGluZyBsaXN0LXJlbGF0ZWQgbm9kZSB0eXBlcyB0byBhIG1hcFxuc3BlY2lmeWluZyB0aGUgbm9kZXMgZm9yIGEgc2NoZW1hLiBBZGRzXG5bYG9yZGVyZWRMaXN0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3NjaGVtYS1saXN0Lm9yZGVyZWRMaXN0KSBhcyBgXCJvcmRlcmVkX2xpc3RcImAsXG5bYGJ1bGxldExpc3RgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc2NoZW1hLWxpc3QuYnVsbGV0TGlzdCkgYXMgYFwiYnVsbGV0X2xpc3RcImAsIGFuZFxuW2BsaXN0SXRlbWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzY2hlbWEtbGlzdC5saXN0SXRlbSkgYXMgYFwibGlzdF9pdGVtXCJgLlxuXG5gaXRlbUNvbnRlbnRgIGRldGVybWluZXMgdGhlIGNvbnRlbnQgZXhwcmVzc2lvbiBmb3IgdGhlIGxpc3QgaXRlbXMuXG5JZiB5b3Ugd2FudCB0aGUgY29tbWFuZHMgZGVmaW5lZCBpbiB0aGlzIG1vZHVsZSB0byBhcHBseSB0byB5b3VyXG5saXN0IHN0cnVjdHVyZSwgaXQgc2hvdWxkIGhhdmUgYSBzaGFwZSBsaWtlIGBcInBhcmFncmFwaCBibG9jaypcImAgb3JcbmBcInBhcmFncmFwaCAob3JkZXJlZF9saXN0IHwgYnVsbGV0X2xpc3QpKlwiYC4gYGxpc3RHcm91cGAgY2FuIGJlXG5naXZlbiB0byBhc3NpZ24gYSBncm91cCBuYW1lIHRvIHRoZSBsaXN0IG5vZGUgdHlwZXMsIGZvciBleGFtcGxlXG5gXCJibG9ja1wiYC5cbiovXG5mdW5jdGlvbiBhZGRMaXN0Tm9kZXMobm9kZXMsIGl0ZW1Db250ZW50LCBsaXN0R3JvdXApIHtcbiAgICByZXR1cm4gbm9kZXMuYXBwZW5kKHtcbiAgICAgICAgb3JkZXJlZF9saXN0OiBhZGQob3JkZXJlZExpc3QsIHsgY29udGVudDogXCJsaXN0X2l0ZW0rXCIsIGdyb3VwOiBsaXN0R3JvdXAgfSksXG4gICAgICAgIGJ1bGxldF9saXN0OiBhZGQoYnVsbGV0TGlzdCwgeyBjb250ZW50OiBcImxpc3RfaXRlbStcIiwgZ3JvdXA6IGxpc3RHcm91cCB9KSxcbiAgICAgICAgbGlzdF9pdGVtOiBhZGQobGlzdEl0ZW0sIHsgY29udGVudDogaXRlbUNvbnRlbnQgfSlcbiAgICB9KTtcbn1cbi8qKlxuUmV0dXJucyBhIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB3cmFwcyB0aGUgc2VsZWN0aW9uIGluIGEgbGlzdCB3aXRoXG50aGUgZ2l2ZW4gdHlwZSBhbiBhdHRyaWJ1dGVzLiBJZiBgZGlzcGF0Y2hgIGlzIG51bGwsIG9ubHkgcmV0dXJuIGFcbnZhbHVlIHRvIGluZGljYXRlIHdoZXRoZXIgdGhpcyBpcyBwb3NzaWJsZSwgYnV0IGRvbid0IGFjdHVhbGx5XG5wZXJmb3JtIHRoZSBjaGFuZ2UuXG4qL1xuZnVuY3Rpb24gd3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byksIGRvSm9pbiA9IGZhbHNlLCBvdXRlclJhbmdlID0gcmFuZ2U7XG4gICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFRoaXMgaXMgYXQgdGhlIHRvcCBvZiBhbiBleGlzdGluZyBsaXN0IGl0ZW1cbiAgICAgICAgaWYgKHJhbmdlLmRlcHRoID49IDIgJiYgJGZyb20ubm9kZShyYW5nZS5kZXB0aCAtIDEpLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQobGlzdFR5cGUpICYmIHJhbmdlLnN0YXJ0SW5kZXggPT0gMCkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhpcyBpcyB0aGUgdG9wIG9mIHRoZSBsaXN0XG4gICAgICAgICAgICBpZiAoJGZyb20uaW5kZXgocmFuZ2UuZGVwdGggLSAxKSA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCAkaW5zZXJ0ID0gc3RhdGUuZG9jLnJlc29sdmUocmFuZ2Uuc3RhcnQgLSAyKTtcbiAgICAgICAgICAgIG91dGVyUmFuZ2UgPSBuZXcgTm9kZVJhbmdlKCRpbnNlcnQsICRpbnNlcnQsIHJhbmdlLmRlcHRoKTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbmRJbmRleCA8IHJhbmdlLnBhcmVudC5jaGlsZENvdW50KVxuICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IE5vZGVSYW5nZSgkZnJvbSwgc3RhdGUuZG9jLnJlc29sdmUoJHRvLmVuZChyYW5nZS5kZXB0aCkpLCByYW5nZS5kZXB0aCk7XG4gICAgICAgICAgICBkb0pvaW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3cmFwID0gZmluZFdyYXBwaW5nKG91dGVyUmFuZ2UsIGxpc3RUeXBlLCBhdHRycywgcmFuZ2UpO1xuICAgICAgICBpZiAoIXdyYXApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKGRvV3JhcEluTGlzdChzdGF0ZS50ciwgcmFuZ2UsIHdyYXAsIGRvSm9pbiwgbGlzdFR5cGUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZG9XcmFwSW5MaXN0KHRyLCByYW5nZSwgd3JhcHBlcnMsIGpvaW5CZWZvcmUsIGxpc3RUeXBlKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBpID0gd3JhcHBlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHdyYXBwZXJzW2ldLnR5cGUuY3JlYXRlKHdyYXBwZXJzW2ldLmF0dHJzLCBjb250ZW50KSk7XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAocmFuZ2Uuc3RhcnQgLSAoam9pbkJlZm9yZSA/IDIgOiAwKSwgcmFuZ2UuZW5kLCByYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBuZXcgU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpO1xuICAgIGxldCBmb3VuZCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cmFwcGVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKHdyYXBwZXJzW2ldLnR5cGUgPT0gbGlzdFR5cGUpXG4gICAgICAgICAgICBmb3VuZCA9IGkgKyAxO1xuICAgIGxldCBzcGxpdERlcHRoID0gd3JhcHBlcnMubGVuZ3RoIC0gZm91bmQ7XG4gICAgbGV0IHNwbGl0UG9zID0gcmFuZ2Uuc3RhcnQgKyB3cmFwcGVycy5sZW5ndGggLSAoam9pbkJlZm9yZSA/IDIgOiAwKSwgcGFyZW50ID0gcmFuZ2UucGFyZW50O1xuICAgIGZvciAobGV0IGkgPSByYW5nZS5zdGFydEluZGV4LCBlID0gcmFuZ2UuZW5kSW5kZXgsIGZpcnN0ID0gdHJ1ZTsgaSA8IGU7IGkrKywgZmlyc3QgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIWZpcnN0ICYmIGNhblNwbGl0KHRyLmRvYywgc3BsaXRQb3MsIHNwbGl0RGVwdGgpKSB7XG4gICAgICAgICAgICB0ci5zcGxpdChzcGxpdFBvcywgc3BsaXREZXB0aCk7XG4gICAgICAgICAgICBzcGxpdFBvcyArPSAyICogc3BsaXREZXB0aDtcbiAgICAgICAgfVxuICAgICAgICBzcGxpdFBvcyArPSBwYXJlbnQuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbi8qKlxuQnVpbGQgYSBjb21tYW5kIHRoYXQgc3BsaXRzIGEgbm9uLWVtcHR5IHRleHRibG9jayBhdCB0aGUgdG9wIGxldmVsXG5vZiBhIGxpc3QgaXRlbSBieSBhbHNvIHNwbGl0dGluZyB0aGF0IGxpc3QgaXRlbS5cbiovXG5mdW5jdGlvbiBzcGxpdExpc3RJdGVtKGl0ZW1UeXBlLCBpdGVtQXR0cnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvLCBub2RlIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmICgobm9kZSAmJiBub2RlLmlzQmxvY2spIHx8ICRmcm9tLmRlcHRoIDwgMiB8fCAhJGZyb20uc2FtZVBhcmVudCgkdG8pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgZ3JhbmRQYXJlbnQgPSAkZnJvbS5ub2RlKC0xKTtcbiAgICAgICAgaWYgKGdyYW5kUGFyZW50LnR5cGUgIT0gaXRlbVR5cGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICgkZnJvbS5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiYgJGZyb20ubm9kZSgtMSkuY2hpbGRDb3VudCA9PSAkZnJvbS5pbmRleEFmdGVyKC0xKSkge1xuICAgICAgICAgICAgLy8gSW4gYW4gZW1wdHkgYmxvY2suIElmIHRoaXMgaXMgYSBuZXN0ZWQgbGlzdCwgdGhlIHdyYXBwaW5nXG4gICAgICAgICAgICAvLyBsaXN0IGl0ZW0gc2hvdWxkIGJlIHNwbGl0LiBPdGhlcndpc2UsIGJhaWwgb3V0IGFuZCBsZXQgbmV4dFxuICAgICAgICAgICAgLy8gY29tbWFuZCBoYW5kbGUgbGlmdGluZy5cbiAgICAgICAgICAgIGlmICgkZnJvbS5kZXB0aCA9PSAzIHx8ICRmcm9tLm5vZGUoLTMpLnR5cGUgIT0gaXRlbVR5cGUgfHxcbiAgICAgICAgICAgICAgICAkZnJvbS5pbmRleCgtMikgIT0gJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHdyYXAgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgICAgICAgICBsZXQgZGVwdGhCZWZvcmUgPSAkZnJvbS5pbmRleCgtMSkgPyAxIDogJGZyb20uaW5kZXgoLTIpID8gMiA6IDM7XG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgYSBmcmFnbWVudCBjb250YWluaW5nIGVtcHR5IHZlcnNpb25zIG9mIHRoZSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBvdXRlciBsaXN0IGl0ZW0gdG8gdGhlIHBhcmVudCBub2RlIG9mIHRoZSBjdXJzb3JcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGggLSBkZXB0aEJlZm9yZTsgZCA+PSAkZnJvbS5kZXB0aCAtIDM7IGQtLSlcbiAgICAgICAgICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KHdyYXApKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVwdGhBZnRlciA9ICRmcm9tLmluZGV4QWZ0ZXIoLTEpIDwgJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCA/IDFcbiAgICAgICAgICAgICAgICAgICAgOiAkZnJvbS5pbmRleEFmdGVyKC0yKSA8ICRmcm9tLm5vZGUoLTMpLmNoaWxkQ291bnQgPyAyIDogMztcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBzZWNvbmQgbGlzdCBpdGVtIHdpdGggYW4gZW1wdHkgZGVmYXVsdCBzdGFydCBub2RlXG4gICAgICAgICAgICAgICAgd3JhcCA9IHdyYXAuYXBwZW5kKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlQW5kRmlsbCgpKSk7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gJGZyb20uYmVmb3JlKCRmcm9tLmRlcHRoIC0gKGRlcHRoQmVmb3JlIC0gMSkpO1xuICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnJlcGxhY2Uoc3RhcnQsICRmcm9tLmFmdGVyKC1kZXB0aEFmdGVyKSwgbmV3IFNsaWNlKHdyYXAsIDQgLSBkZXB0aEJlZm9yZSwgMCkpO1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSAtMTtcbiAgICAgICAgICAgICAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKHN0YXJ0LCB0ci5kb2MuY29udGVudC5zaXplLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWwgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaXNUZXh0YmxvY2sgJiYgbm9kZS5jb250ZW50LnNpemUgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoc2VsKSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRUeXBlID0gJHRvLnBvcyA9PSAkZnJvbS5lbmQoKSA/IGdyYW5kUGFyZW50LmNvbnRlbnRNYXRjaEF0KDApLmRlZmF1bHRUeXBlIDogbnVsbDtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuZGVsZXRlKCRmcm9tLnBvcywgJHRvLnBvcyk7XG4gICAgICAgIGxldCB0eXBlcyA9IG5leHRUeXBlID8gW2l0ZW1BdHRycyA/IHsgdHlwZTogaXRlbVR5cGUsIGF0dHJzOiBpdGVtQXR0cnMgfSA6IG51bGwsIHsgdHlwZTogbmV4dFR5cGUgfV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghY2FuU3BsaXQodHIuZG9jLCAkZnJvbS5wb3MsIDIsIHR5cGVzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2godHIuc3BsaXQoJGZyb20ucG9zLCAyLCB0eXBlcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkNyZWF0ZSBhIGNvbW1hbmQgdG8gbGlmdCB0aGUgbGlzdCBpdGVtIGFyb3VuZCB0aGUgc2VsZWN0aW9uIHVwIGludG9cbmEgd3JhcHBpbmcgbGlzdC5cbiovXG5mdW5jdGlvbiBsaWZ0TGlzdEl0ZW0oaXRlbVR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBub2RlID0+IG5vZGUuY2hpbGRDb3VudCA+IDAgJiYgbm9kZS5maXJzdENoaWxkLnR5cGUgPT0gaXRlbVR5cGUpO1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWRpc3BhdGNoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICgkZnJvbS5ub2RlKHJhbmdlLmRlcHRoIC0gMSkudHlwZSA9PSBpdGVtVHlwZSkgLy8gSW5zaWRlIGEgcGFyZW50IGxpc3RcbiAgICAgICAgICAgIHJldHVybiBsaWZ0VG9PdXRlckxpc3Qoc3RhdGUsIGRpc3BhdGNoLCBpdGVtVHlwZSwgcmFuZ2UpO1xuICAgICAgICBlbHNlIC8vIE91dGVyIGxpc3Qgbm9kZVxuICAgICAgICAgICAgcmV0dXJuIGxpZnRPdXRPZkxpc3Qoc3RhdGUsIGRpc3BhdGNoLCByYW5nZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpZnRUb091dGVyTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIGl0ZW1UeXBlLCByYW5nZSkge1xuICAgIGxldCB0ciA9IHN0YXRlLnRyLCBlbmQgPSByYW5nZS5lbmQsIGVuZE9mTGlzdCA9IHJhbmdlLiR0by5lbmQocmFuZ2UuZGVwdGgpO1xuICAgIGlmIChlbmQgPCBlbmRPZkxpc3QpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHNpYmxpbmdzIGFmdGVyIHRoZSBsaWZ0ZWQgaXRlbXMsIHdoaWNoIG11c3QgYmVjb21lXG4gICAgICAgIC8vIGNoaWxkcmVuIG9mIHRoZSBsYXN0IGl0ZW1cbiAgICAgICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoZW5kIC0gMSwgZW5kT2ZMaXN0LCBlbmQsIGVuZE9mTGlzdCwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlKG51bGwsIHJhbmdlLnBhcmVudC5jb3B5KCkpKSwgMSwgMCksIDEsIHRydWUpKTtcbiAgICAgICAgcmFuZ2UgPSBuZXcgTm9kZVJhbmdlKHRyLmRvYy5yZXNvbHZlKHJhbmdlLiRmcm9tLnBvcyksIHRyLmRvYy5yZXNvbHZlKGVuZE9mTGlzdCksIHJhbmdlLmRlcHRoKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHIubGlmdChyYW5nZSwgdGFyZ2V0KTtcbiAgICBsZXQgYWZ0ZXIgPSB0ci5tYXBwaW5nLm1hcChlbmQsIC0xKSAtIDE7XG4gICAgaWYgKGNhbkpvaW4odHIuZG9jLCBhZnRlcikpXG4gICAgICAgIHRyLmpvaW4oYWZ0ZXIpO1xuICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbGlmdE91dE9mTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIHJhbmdlKSB7XG4gICAgbGV0IHRyID0gc3RhdGUudHIsIGxpc3QgPSByYW5nZS5wYXJlbnQ7XG4gICAgLy8gTWVyZ2UgdGhlIGxpc3QgaXRlbXMgaW50byBhIHNpbmdsZSBiaWcgaXRlbVxuICAgIGZvciAobGV0IHBvcyA9IHJhbmdlLmVuZCwgaSA9IHJhbmdlLmVuZEluZGV4IC0gMSwgZSA9IHJhbmdlLnN0YXJ0SW5kZXg7IGkgPiBlOyBpLS0pIHtcbiAgICAgICAgcG9zIC09IGxpc3QuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgICAgIHRyLmRlbGV0ZShwb3MgLSAxLCBwb3MgKyAxKTtcbiAgICB9XG4gICAgbGV0ICRzdGFydCA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLnN0YXJ0KSwgaXRlbSA9ICRzdGFydC5ub2RlQWZ0ZXI7XG4gICAgaWYgKHRyLm1hcHBpbmcubWFwKHJhbmdlLmVuZCkgIT0gcmFuZ2Uuc3RhcnQgKyAkc3RhcnQubm9kZUFmdGVyLm5vZGVTaXplKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGF0U3RhcnQgPSByYW5nZS5zdGFydEluZGV4ID09IDAsIGF0RW5kID0gcmFuZ2UuZW5kSW5kZXggPT0gbGlzdC5jaGlsZENvdW50O1xuICAgIGxldCBwYXJlbnQgPSAkc3RhcnQubm9kZSgtMSksIGluZGV4QmVmb3JlID0gJHN0YXJ0LmluZGV4KC0xKTtcbiAgICBpZiAoIXBhcmVudC5jYW5SZXBsYWNlKGluZGV4QmVmb3JlICsgKGF0U3RhcnQgPyAwIDogMSksIGluZGV4QmVmb3JlICsgMSwgaXRlbS5jb250ZW50LmFwcGVuZChhdEVuZCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0KSkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHN0YXJ0ID0gJHN0YXJ0LnBvcywgZW5kID0gc3RhcnQgKyBpdGVtLm5vZGVTaXplO1xuICAgIC8vIFN0cmlwIG9mZiB0aGUgc3Vycm91bmRpbmcgbGlzdC4gQXQgdGhlIHNpZGVzIHdoZXJlIHdlJ3JlIG5vdCBhdFxuICAgIC8vIHRoZSBlbmQgb2YgdGhlIGxpc3QsIHRoZSBleGlzdGluZyBsaXN0IGlzIGNsb3NlZC4gQXQgc2lkZXMgd2hlcmVcbiAgICAvLyB0aGlzIGlzIHRoZSBlbmQsIGl0IGlzIG92ZXJ3cml0dGVuIHRvIGl0cyBlbmQuXG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQgLSAoYXRTdGFydCA/IDEgOiAwKSwgZW5kICsgKGF0RW5kID8gMSA6IDApLCBzdGFydCArIDEsIGVuZCAtIDEsIG5ldyBTbGljZSgoYXRTdGFydCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0LmNvcHkoRnJhZ21lbnQuZW1wdHkpKSlcbiAgICAgICAgLmFwcGVuZChhdEVuZCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0LmNvcHkoRnJhZ21lbnQuZW1wdHkpKSksIGF0U3RhcnQgPyAwIDogMSwgYXRFbmQgPyAwIDogMSksIGF0U3RhcnQgPyAwIDogMSkpO1xuICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5DcmVhdGUgYSBjb21tYW5kIHRvIHNpbmsgdGhlIGxpc3QgaXRlbSBhcm91bmQgdGhlIHNlbGVjdGlvbiBkb3duXG5pbnRvIGFuIGlubmVyIGxpc3QuXG4qL1xuZnVuY3Rpb24gc2lua0xpc3RJdGVtKGl0ZW1UeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bywgbm9kZSA9PiBub2RlLmNoaWxkQ291bnQgPiAwICYmIG5vZGUuZmlyc3RDaGlsZC50eXBlID09IGl0ZW1UeXBlKTtcbiAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSByYW5nZS5zdGFydEluZGV4O1xuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgcGFyZW50ID0gcmFuZ2UucGFyZW50LCBub2RlQmVmb3JlID0gcGFyZW50LmNoaWxkKHN0YXJ0SW5kZXggLSAxKTtcbiAgICAgICAgaWYgKG5vZGVCZWZvcmUudHlwZSAhPSBpdGVtVHlwZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgbmVzdGVkQmVmb3JlID0gbm9kZUJlZm9yZS5sYXN0Q2hpbGQgJiYgbm9kZUJlZm9yZS5sYXN0Q2hpbGQudHlwZSA9PSBwYXJlbnQudHlwZTtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IEZyYWdtZW50LmZyb20obmVzdGVkQmVmb3JlID8gaXRlbVR5cGUuY3JlYXRlKCkgOiBudWxsKTtcbiAgICAgICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShGcmFnbWVudC5mcm9tKGl0ZW1UeXBlLmNyZWF0ZShudWxsLCBGcmFnbWVudC5mcm9tKHBhcmVudC50eXBlLmNyZWF0ZShudWxsLCBpbm5lcikpKSksIG5lc3RlZEJlZm9yZSA/IDMgOiAxLCAwKTtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSByYW5nZS5zdGFydCwgYWZ0ZXIgPSByYW5nZS5lbmQ7XG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChiZWZvcmUgLSAobmVzdGVkQmVmb3JlID8gMyA6IDEpLCBhZnRlciwgYmVmb3JlLCBhZnRlciwgc2xpY2UsIDEsIHRydWUpKVxuICAgICAgICAgICAgICAgIC5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBhZGRMaXN0Tm9kZXMsIGJ1bGxldExpc3QsIGxpZnRMaXN0SXRlbSwgbGlzdEl0ZW0sIG9yZGVyZWRMaXN0LCBzaW5rTGlzdEl0ZW0sIHNwbGl0TGlzdEl0ZW0sIHdyYXBJbkxpc3QgfTtcbiIsICJpbXBvcnQgeyBFZGl0b3JTdGF0ZSwgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoY29uZmlnOiB7XG4gIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblxuICBzdGF0ZTogRWRpdG9yU3RhdGVcbn0pOiBFZGl0b3JTdGF0ZSB7XG4gIGNvbnN0IHsgc3RhdGUsIHRyYW5zYWN0aW9uIH0gPSBjb25maWdcbiAgbGV0IHsgc2VsZWN0aW9uIH0gPSB0cmFuc2FjdGlvblxuICBsZXQgeyBkb2MgfSA9IHRyYW5zYWN0aW9uXG4gIGxldCB7IHN0b3JlZE1hcmtzIH0gPSB0cmFuc2FjdGlvblxuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgYXBwbHk6IHN0YXRlLmFwcGx5LmJpbmQoc3RhdGUpLFxuICAgIGFwcGx5VHJhbnNhY3Rpb246IHN0YXRlLmFwcGx5VHJhbnNhY3Rpb24uYmluZChzdGF0ZSksXG4gICAgZmlsdGVyVHJhbnNhY3Rpb246IHN0YXRlLmZpbHRlclRyYW5zYWN0aW9uLFxuICAgIHBsdWdpbnM6IHN0YXRlLnBsdWdpbnMsXG4gICAgc2NoZW1hOiBzdGF0ZS5zY2hlbWEsXG4gICAgcmVjb25maWd1cmU6IHN0YXRlLnJlY29uZmlndXJlLmJpbmQoc3RhdGUpLFxuICAgIHRvSlNPTjogc3RhdGUudG9KU09OLmJpbmQoc3RhdGUpLFxuICAgIGdldCBzdG9yZWRNYXJrcygpIHtcbiAgICAgIHJldHVybiBzdG9yZWRNYXJrc1xuICAgIH0sXG4gICAgZ2V0IHNlbGVjdGlvbigpIHtcbiAgICAgIHJldHVybiBzZWxlY3Rpb25cbiAgICB9LFxuICAgIGdldCBkb2MoKSB7XG4gICAgICByZXR1cm4gZG9jXG4gICAgfSxcbiAgICBnZXQgdHIoKSB7XG4gICAgICBzZWxlY3Rpb24gPSB0cmFuc2FjdGlvbi5zZWxlY3Rpb25cbiAgICAgIGRvYyA9IHRyYW5zYWN0aW9uLmRvY1xuICAgICAgc3RvcmVkTWFya3MgPSB0cmFuc2FjdGlvbi5zdG9yZWRNYXJrc1xuXG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb25cbiAgICB9LFxuICB9XG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUsIFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBjcmVhdGVDaGFpbmFibGVTdGF0ZSB9IGZyb20gJy4vaGVscGVycy9jcmVhdGVDaGFpbmFibGVTdGF0ZS5qcydcbmltcG9ydCB7XG4gIEFueUNvbW1hbmRzLCBDYW5Db21tYW5kcywgQ2hhaW5lZENvbW1hbmRzLCBDb21tYW5kUHJvcHMsIFNpbmdsZUNvbW1hbmRzLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuXG5leHBvcnQgY2xhc3MgQ29tbWFuZE1hbmFnZXIge1xuICBlZGl0b3I6IEVkaXRvclxuXG4gIHJhd0NvbW1hbmRzOiBBbnlDb21tYW5kc1xuXG4gIGN1c3RvbVN0YXRlPzogRWRpdG9yU3RhdGVcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogeyBlZGl0b3I6IEVkaXRvcjsgc3RhdGU/OiBFZGl0b3JTdGF0ZSB9KSB7XG4gICAgdGhpcy5lZGl0b3IgPSBwcm9wcy5lZGl0b3JcbiAgICB0aGlzLnJhd0NvbW1hbmRzID0gdGhpcy5lZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5jb21tYW5kc1xuICAgIHRoaXMuY3VzdG9tU3RhdGUgPSBwcm9wcy5zdGF0ZVxuICB9XG5cbiAgZ2V0IGhhc0N1c3RvbVN0YXRlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuY3VzdG9tU3RhdGVcbiAgfVxuXG4gIGdldCBzdGF0ZSgpOiBFZGl0b3JTdGF0ZSB7XG4gICAgcmV0dXJuIHRoaXMuY3VzdG9tU3RhdGUgfHwgdGhpcy5lZGl0b3Iuc3RhdGVcbiAgfVxuXG4gIGdldCBjb21tYW5kcygpOiBTaW5nbGVDb21tYW5kcyB7XG4gICAgY29uc3QgeyByYXdDb21tYW5kcywgZWRpdG9yLCBzdGF0ZSB9ID0gdGhpc1xuICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yXG4gICAgY29uc3QgeyB0ciB9ID0gc3RhdGVcbiAgICBjb25zdCBwcm9wcyA9IHRoaXMuYnVpbGRQcm9wcyh0cilcblxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjb21tYW5kKC4uLmFyZ3MpKHByb3BzKVxuXG4gICAgICAgICAgaWYgKCF0ci5nZXRNZXRhKCdwcmV2ZW50RGlzcGF0Y2gnKSAmJiAhdGhpcy5oYXNDdXN0b21TdGF0ZSkge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2tcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbmFtZSwgbWV0aG9kXVxuICAgICAgfSksXG4gICAgKSBhcyB1bmtub3duIGFzIFNpbmdsZUNvbW1hbmRzXG4gIH1cblxuICBnZXQgY2hhaW4oKTogKCkgPT4gQ2hhaW5lZENvbW1hbmRzIHtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5jcmVhdGVDaGFpbigpXG4gIH1cblxuICBnZXQgY2FuKCk6ICgpID0+IENhbkNvbW1hbmRzIHtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5jcmVhdGVDYW4oKVxuICB9XG5cbiAgcHVibGljIGNyZWF0ZUNoYWluKHN0YXJ0VHI/OiBUcmFuc2FjdGlvbiwgc2hvdWxkRGlzcGF0Y2ggPSB0cnVlKTogQ2hhaW5lZENvbW1hbmRzIHtcbiAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzXG4gICAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3JcbiAgICBjb25zdCBjYWxsYmFja3M6IGJvb2xlYW5bXSA9IFtdXG4gICAgY29uc3QgaGFzU3RhcnRUcmFuc2FjdGlvbiA9ICEhc3RhcnRUclxuICAgIGNvbnN0IHRyID0gc3RhcnRUciB8fCBzdGF0ZS50clxuXG4gICAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAhaGFzU3RhcnRUcmFuc2FjdGlvblxuICAgICAgICAmJiBzaG91bGREaXNwYXRjaFxuICAgICAgICAmJiAhdHIuZ2V0TWV0YSgncHJldmVudERpc3BhdGNoJylcbiAgICAgICAgJiYgIXRoaXMuaGFzQ3VzdG9tU3RhdGVcbiAgICAgICkge1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FsbGJhY2tzLmV2ZXJ5KGNhbGxiYWNrID0+IGNhbGxiYWNrID09PSB0cnVlKVxuICAgIH1cblxuICAgIGNvbnN0IGNoYWluID0ge1xuICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgICBjb25zdCBjaGFpbmVkQ29tbWFuZCA9ICguLi5hcmdzOiBuZXZlcltdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuYnVpbGRQcm9wcyh0ciwgc2hvdWxkRGlzcGF0Y2gpXG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGNvbW1hbmQoLi4uYXJncykocHJvcHMpXG5cbiAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKVxuXG4gICAgICAgICAgICByZXR1cm4gY2hhaW5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gW25hbWUsIGNoYWluZWRDb21tYW5kXVxuICAgICAgICB9KSxcbiAgICAgICksXG4gICAgICBydW4sXG4gICAgfSBhcyB1bmtub3duIGFzIENoYWluZWRDb21tYW5kc1xuXG4gICAgcmV0dXJuIGNoYWluXG4gIH1cblxuICBwdWJsaWMgY3JlYXRlQ2FuKHN0YXJ0VHI/OiBUcmFuc2FjdGlvbik6IENhbkNvbW1hbmRzIHtcbiAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBzdGF0ZSB9ID0gdGhpc1xuICAgIGNvbnN0IGRpc3BhdGNoID0gZmFsc2VcbiAgICBjb25zdCB0ciA9IHN0YXJ0VHIgfHwgc3RhdGUudHJcbiAgICBjb25zdCBwcm9wcyA9IHRoaXMuYnVpbGRQcm9wcyh0ciwgZGlzcGF0Y2gpXG4gICAgY29uc3QgZm9ybWF0dGVkQ29tbWFuZHMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgcmV0dXJuIFtuYW1lLCAoLi4uYXJnczogbmV2ZXJbXSkgPT4gY29tbWFuZCguLi5hcmdzKSh7IC4uLnByb3BzLCBkaXNwYXRjaDogdW5kZWZpbmVkIH0pXVxuICAgICAgfSksXG4gICAgKSBhcyB1bmtub3duIGFzIFNpbmdsZUNvbW1hbmRzXG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZm9ybWF0dGVkQ29tbWFuZHMsXG4gICAgICBjaGFpbjogKCkgPT4gdGhpcy5jcmVhdGVDaGFpbih0ciwgZGlzcGF0Y2gpLFxuICAgIH0gYXMgQ2FuQ29tbWFuZHNcbiAgfVxuXG4gIHB1YmxpYyBidWlsZFByb3BzKHRyOiBUcmFuc2FjdGlvbiwgc2hvdWxkRGlzcGF0Y2ggPSB0cnVlKTogQ29tbWFuZFByb3BzIHtcbiAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzXG4gICAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3JcblxuICAgIGNvbnN0IHByb3BzOiBDb21tYW5kUHJvcHMgPSB7XG4gICAgICB0cixcbiAgICAgIGVkaXRvcixcbiAgICAgIHZpZXcsXG4gICAgICBzdGF0ZTogY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgdHJhbnNhY3Rpb246IHRyLFxuICAgICAgfSksXG4gICAgICBkaXNwYXRjaDogc2hvdWxkRGlzcGF0Y2ggPyAoKSA9PiB1bmRlZmluZWQgOiB1bmRlZmluZWQsXG4gICAgICBjaGFpbjogKCkgPT4gdGhpcy5jcmVhdGVDaGFpbih0ciwgc2hvdWxkRGlzcGF0Y2gpLFxuICAgICAgY2FuOiAoKSA9PiB0aGlzLmNyZWF0ZUNhbih0ciksXG4gICAgICBnZXQgY29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMocmF3Q29tbWFuZHMpLm1hcCgoW25hbWUsIGNvbW1hbmRdKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW25hbWUsICguLi5hcmdzOiBuZXZlcltdKSA9PiBjb21tYW5kKC4uLmFyZ3MpKHByb3BzKV1cbiAgICAgICAgICB9KSxcbiAgICAgICAgKSBhcyB1bmtub3duIGFzIFNpbmdsZUNvbW1hbmRzXG4gICAgICB9LFxuICAgIH1cblxuICAgIHJldHVybiBwcm9wc1xuICB9XG59XG4iLCAidHlwZSBTdHJpbmdLZXlPZjxUPiA9IEV4dHJhY3Q8a2V5b2YgVCwgc3RyaW5nPlxudHlwZSBDYWxsYmFja1R5cGU8XG4gIFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBFdmVudE5hbWUgZXh0ZW5kcyBTdHJpbmdLZXlPZjxUPixcbj4gPSBUW0V2ZW50TmFtZV0gZXh0ZW5kcyBhbnlbXSA/IFRbRXZlbnROYW1lXSA6IFtUW0V2ZW50TmFtZV1dXG50eXBlIENhbGxiYWNrRnVuY3Rpb248XG4gIFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBFdmVudE5hbWUgZXh0ZW5kcyBTdHJpbmdLZXlPZjxUPixcbj4gPSAoLi4ucHJvcHM6IENhbGxiYWNrVHlwZTxULCBFdmVudE5hbWU+KSA9PiBhbnlcblxuZXhwb3J0IGNsYXNzIEV2ZW50RW1pdHRlcjxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4ge1xuXG4gIHByaXZhdGUgY2FsbGJhY2tzOiB7IFtrZXk6IHN0cmluZ106IEZ1bmN0aW9uW10gfSA9IHt9XG5cbiAgcHVibGljIG9uPEV2ZW50TmFtZSBleHRlbmRzIFN0cmluZ0tleU9mPFQ+PihldmVudDogRXZlbnROYW1lLCBmbjogQ2FsbGJhY2tGdW5jdGlvbjxULCBFdmVudE5hbWU+KTogdGhpcyB7XG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrc1tldmVudF0pIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IFtdXG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdLnB1c2goZm4pXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJvdGVjdGVkIGVtaXQ8RXZlbnROYW1lIGV4dGVuZHMgU3RyaW5nS2V5T2Y8VD4+KGV2ZW50OiBFdmVudE5hbWUsIC4uLmFyZ3M6IENhbGxiYWNrVHlwZTxULCBFdmVudE5hbWU+KTogdGhpcyB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3NbZXZlbnRdXG5cbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICBjYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHVibGljIG9mZjxFdmVudE5hbWUgZXh0ZW5kcyBTdHJpbmdLZXlPZjxUPj4oZXZlbnQ6IEV2ZW50TmFtZSwgZm4/OiBDYWxsYmFja0Z1bmN0aW9uPFQsIEV2ZW50TmFtZT4pOiB0aGlzIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF1cblxuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGlmIChmbikge1xuICAgICAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0gPSBjYWxsYmFja3MuZmlsdGVyKGNhbGxiYWNrID0+IGNhbGxiYWNrICE9PSBmbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1tldmVudF1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlbW92ZUFsbExpc3RlbmVycygpOiB2b2lkIHtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IHt9XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBBbnlFeHRlbnNpb24sIE1heWJlVGhpc1BhcmFtZXRlclR5cGUsIFJlbW92ZVRoaXMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEV4dGVuc2lvbkZpZWxkPFQgPSBhbnk+KFxuICBleHRlbnNpb246IEFueUV4dGVuc2lvbixcbiAgZmllbGQ6IHN0cmluZyxcbiAgY29udGV4dD86IE9taXQ8TWF5YmVUaGlzUGFyYW1ldGVyVHlwZTxUPiwgJ3BhcmVudCc+LFxuKTogUmVtb3ZlVGhpczxUPiB7XG5cbiAgaWYgKGV4dGVuc2lvbi5jb25maWdbZmllbGRdID09PSB1bmRlZmluZWQgJiYgZXh0ZW5zaW9uLnBhcmVudCkge1xuICAgIHJldHVybiBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24ucGFyZW50LCBmaWVsZCwgY29udGV4dClcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGV4dGVuc2lvbi5jb25maWdbZmllbGRdLmJpbmQoe1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIHBhcmVudDogZXh0ZW5zaW9uLnBhcmVudFxuICAgICAgICA/IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbi5wYXJlbnQsIGZpZWxkLCBjb250ZXh0KVxuICAgICAgICA6IG51bGwsXG4gICAgfSlcblxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgcmV0dXJuIGV4dGVuc2lvbi5jb25maWdbZmllbGRdXG59XG4iLCAiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnLi4vRXh0ZW5zaW9uLmpzJ1xuaW1wb3J0IHsgTWFyayB9IGZyb20gJy4uL01hcmsuanMnXG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi4vTm9kZS5qcydcbmltcG9ydCB7IEV4dGVuc2lvbnMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zOiBFeHRlbnNpb25zKSB7XG4gIGNvbnN0IGJhc2VFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi50eXBlID09PSAnZXh0ZW5zaW9uJykgYXMgRXh0ZW5zaW9uW11cbiAgY29uc3Qgbm9kZUV4dGVuc2lvbnMgPSBleHRlbnNpb25zLmZpbHRlcihleHRlbnNpb24gPT4gZXh0ZW5zaW9uLnR5cGUgPT09ICdub2RlJykgYXMgTm9kZVtdXG4gIGNvbnN0IG1hcmtFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi50eXBlID09PSAnbWFyaycpIGFzIE1hcmtbXVxuXG4gIHJldHVybiB7XG4gICAgYmFzZUV4dGVuc2lvbnMsXG4gICAgbm9kZUV4dGVuc2lvbnMsXG4gICAgbWFya0V4dGVuc2lvbnMsXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBNYXJrQ29uZmlnLCBOb2RlQ29uZmlnIH0gZnJvbSAnLi4vaW5kZXguanMnXG5pbXBvcnQge1xuICBBbnlDb25maWcsXG4gIEF0dHJpYnV0ZSxcbiAgQXR0cmlidXRlcyxcbiAgRXh0ZW5zaW9uQXR0cmlidXRlLFxuICBFeHRlbnNpb25zLFxuICBHbG9iYWxBdHRyaWJ1dGVzLFxufSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSAnLi9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IHNwbGl0RXh0ZW5zaW9ucyB9IGZyb20gJy4vc3BsaXRFeHRlbnNpb25zLmpzJ1xuXG4vKipcbiAqIEdldCBhIGxpc3Qgb2YgYWxsIGV4dGVuc2lvbiBhdHRyaWJ1dGVzIGRlZmluZWQgaW4gYGFkZEF0dHJpYnV0ZWAgYW5kIGBhZGRHbG9iYWxBdHRyaWJ1dGVgLlxuICogQHBhcmFtIGV4dGVuc2lvbnMgTGlzdCBvZiBleHRlbnNpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyk6IEV4dGVuc2lvbkF0dHJpYnV0ZVtdIHtcbiAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlczogRXh0ZW5zaW9uQXR0cmlidXRlW10gPSBbXVxuICBjb25zdCB7IG5vZGVFeHRlbnNpb25zLCBtYXJrRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpXG4gIGNvbnN0IG5vZGVBbmRNYXJrRXh0ZW5zaW9ucyA9IFsuLi5ub2RlRXh0ZW5zaW9ucywgLi4ubWFya0V4dGVuc2lvbnNdXG4gIGNvbnN0IGRlZmF1bHRBdHRyaWJ1dGU6IFJlcXVpcmVkPEF0dHJpYnV0ZT4gPSB7XG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICByZW5kZXJlZDogdHJ1ZSxcbiAgICByZW5kZXJIVE1MOiBudWxsLFxuICAgIHBhcnNlSFRNTDogbnVsbCxcbiAgICBrZWVwT25TcGxpdDogdHJ1ZSxcbiAgICBpc1JlcXVpcmVkOiBmYWxzZSxcbiAgfVxuXG4gIGV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgfVxuXG4gICAgY29uc3QgYWRkR2xvYmFsQXR0cmlidXRlcyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkR2xvYmFsQXR0cmlidXRlcyddPihcbiAgICAgIGV4dGVuc2lvbixcbiAgICAgICdhZGRHbG9iYWxBdHRyaWJ1dGVzJyxcbiAgICAgIGNvbnRleHQsXG4gICAgKVxuXG4gICAgaWYgKCFhZGRHbG9iYWxBdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgYGFzIEdsb2JhbEF0dHJpYnV0ZXNgXG4gICAgY29uc3QgZ2xvYmFsQXR0cmlidXRlcyA9IGFkZEdsb2JhbEF0dHJpYnV0ZXMoKSBhcyBHbG9iYWxBdHRyaWJ1dGVzXG5cbiAgICBnbG9iYWxBdHRyaWJ1dGVzLmZvckVhY2goZ2xvYmFsQXR0cmlidXRlID0+IHtcbiAgICAgIGdsb2JhbEF0dHJpYnV0ZS50eXBlcy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgICBPYmplY3RcbiAgICAgICAgICAuZW50cmllcyhnbG9iYWxBdHRyaWJ1dGUuYXR0cmlidXRlcylcbiAgICAgICAgICAuZm9yRWFjaCgoW25hbWUsIGF0dHJpYnV0ZV0pID0+IHtcbiAgICAgICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZToge1xuICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxuXG4gIG5vZGVBbmRNYXJrRXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICB9XG5cbiAgICBjb25zdCBhZGRBdHRyaWJ1dGVzID0gZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snYWRkQXR0cmlidXRlcyddIHwgTWFya0NvbmZpZ1snYWRkQXR0cmlidXRlcyddPihcbiAgICAgIGV4dGVuc2lvbixcbiAgICAgICdhZGRBdHRyaWJ1dGVzJyxcbiAgICAgIGNvbnRleHQsXG4gICAgKVxuXG4gICAgaWYgKCFhZGRBdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgYGFzIEF0dHJpYnV0ZXNgXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGFkZEF0dHJpYnV0ZXMoKSBhcyBBdHRyaWJ1dGVzXG5cbiAgICBPYmplY3RcbiAgICAgIC5lbnRyaWVzKGF0dHJpYnV0ZXMpXG4gICAgICAuZm9yRWFjaCgoW25hbWUsIGF0dHJpYnV0ZV0pID0+IHtcbiAgICAgICAgY29uc3QgbWVyZ2VkQXR0ciA9IHtcbiAgICAgICAgICAuLi5kZWZhdWx0QXR0cmlidXRlLFxuICAgICAgICAgIC4uLmF0dHJpYnV0ZSxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWVyZ2VkQXR0cj8uZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG1lcmdlZEF0dHIuZGVmYXVsdCA9IG1lcmdlZEF0dHIuZGVmYXVsdCgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVyZ2VkQXR0cj8uaXNSZXF1aXJlZCAmJiBtZXJnZWRBdHRyPy5kZWZhdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgbWVyZ2VkQXR0ci5kZWZhdWx0XG4gICAgICAgIH1cblxuICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgYXR0cmlidXRlOiBtZXJnZWRBdHRyLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgfSlcblxuICByZXR1cm4gZXh0ZW5zaW9uQXR0cmlidXRlc1xufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlLCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZVR5cGUobmFtZU9yVHlwZTogc3RyaW5nIHwgTm9kZVR5cGUsIHNjaGVtYTogU2NoZW1hKTogTm9kZVR5cGUge1xuICBpZiAodHlwZW9mIG5hbWVPclR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCFzY2hlbWEubm9kZXNbbmFtZU9yVHlwZV0pIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgVGhlcmUgaXMgbm8gbm9kZSB0eXBlIG5hbWVkICcke25hbWVPclR5cGV9Jy4gTWF5YmUgeW91IGZvcmdvdCB0byBhZGQgdGhlIGV4dGVuc2lvbj9gLFxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWEubm9kZXNbbmFtZU9yVHlwZV1cbiAgfVxuXG4gIHJldHVybiBuYW1lT3JUeXBlXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQXR0cmlidXRlcyguLi5vYmplY3RzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+W10pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgcmV0dXJuIG9iamVjdHNcbiAgICAuZmlsdGVyKGl0ZW0gPT4gISFpdGVtKVxuICAgIC5yZWR1Y2UoKGl0ZW1zLCBpdGVtKSA9PiB7XG4gICAgICBjb25zdCBtZXJnZWRBdHRyaWJ1dGVzID0geyAuLi5pdGVtcyB9XG5cbiAgICAgIE9iamVjdC5lbnRyaWVzKGl0ZW0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBjb25zdCBleGlzdHMgPSBtZXJnZWRBdHRyaWJ1dGVzW2tleV1cblxuICAgICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICAgIG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlXG5cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZUNsYXNzZXM6IHN0cmluZ1tdID0gdmFsdWUgPyB2YWx1ZS5zcGxpdCgnICcpIDogW11cbiAgICAgICAgICBjb25zdCBleGlzdGluZ0NsYXNzZXM6IHN0cmluZ1tdID0gbWVyZ2VkQXR0cmlidXRlc1trZXldID8gbWVyZ2VkQXR0cmlidXRlc1trZXldLnNwbGl0KCcgJykgOiBbXVxuXG4gICAgICAgICAgY29uc3QgaW5zZXJ0Q2xhc3NlcyA9IHZhbHVlQ2xhc3Nlcy5maWx0ZXIoXG4gICAgICAgICAgICB2YWx1ZUNsYXNzID0+ICFleGlzdGluZ0NsYXNzZXMuaW5jbHVkZXModmFsdWVDbGFzcyksXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gWy4uLmV4aXN0aW5nQ2xhc3NlcywgLi4uaW5zZXJ0Q2xhc3Nlc10uam9pbignICcpXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gW21lcmdlZEF0dHJpYnV0ZXNba2V5XSwgdmFsdWVdLmpvaW4oJzsgJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gbWVyZ2VkQXR0cmlidXRlc1xuICAgIH0sIHt9KVxufVxuIiwgImltcG9ydCB7IE1hcmssIE5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb25BdHRyaWJ1dGUgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcyB9IGZyb20gJy4uL3V0aWxpdGllcy9tZXJnZUF0dHJpYnV0ZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMoXG4gIG5vZGVPck1hcms6IE5vZGUgfCBNYXJrLFxuICBleHRlbnNpb25BdHRyaWJ1dGVzOiBFeHRlbnNpb25BdHRyaWJ1dGVbXSxcbik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICByZXR1cm4gZXh0ZW5zaW9uQXR0cmlidXRlc1xuICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLmF0dHJpYnV0ZS5yZW5kZXJlZClcbiAgICAubWFwKGl0ZW0gPT4ge1xuICAgICAgaWYgKCFpdGVtLmF0dHJpYnV0ZS5yZW5kZXJIVE1MKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgW2l0ZW0ubmFtZV06IG5vZGVPck1hcmsuYXR0cnNbaXRlbS5uYW1lXSxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbS5hdHRyaWJ1dGUucmVuZGVySFRNTChub2RlT3JNYXJrLmF0dHJzKSB8fCB7fVxuICAgIH0pXG4gICAgLnJlZHVjZSgoYXR0cmlidXRlcywgYXR0cmlidXRlKSA9PiBtZXJnZUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgYXR0cmlidXRlKSwge30pXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWU6IGFueSk6IHZhbHVlIGlzIEZ1bmN0aW9uIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xufVxuIiwgImltcG9ydCB7IE1heWJlUmV0dXJuVHlwZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4vaXNGdW5jdGlvbi5qcydcblxuLyoqXG4gKiBPcHRpb25hbGx5IGNhbGxzIGB2YWx1ZWAgYXMgYSBmdW5jdGlvbi5cbiAqIE90aGVyd2lzZSBpdCBpcyByZXR1cm5lZCBkaXJlY3RseS5cbiAqIEBwYXJhbSB2YWx1ZSBGdW5jdGlvbiBvciBhbnkgdmFsdWUuXG4gKiBAcGFyYW0gY29udGV4dCBPcHRpb25hbCBjb250ZXh0IHRvIGJpbmQgdG8gZnVuY3Rpb24uXG4gKiBAcGFyYW0gcHJvcHMgT3B0aW9uYWwgcHJvcHMgdG8gcGFzcyB0byBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGxPclJldHVybjxUPih2YWx1ZTogVCwgY29udGV4dDogYW55ID0gdW5kZWZpbmVkLCAuLi5wcm9wczogYW55W10pOiBNYXliZVJldHVyblR5cGU8VD4ge1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgcmV0dXJuIHZhbHVlLmJpbmQoY29udGV4dCkoLi4ucHJvcHMpXG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlKC4uLnByb3BzKVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlIGFzIE1heWJlUmV0dXJuVHlwZTxUPlxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5T2JqZWN0KHZhbHVlID0ge30pOiBib29sZWFuIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDAgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdFxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlOiBhbnkpOiBhbnkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgaWYgKHZhbHVlLm1hdGNoKC9eWystXT8oPzpcXGQqXFwuKT9cXGQrJC8pKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJ3RydWUnKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlXG59XG4iLCAiaW1wb3J0IHsgUGFyc2VSdWxlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRXh0ZW5zaW9uQXR0cmlidXRlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBmcm9tU3RyaW5nIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2Zyb21TdHJpbmcuanMnXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBtZXJnZXMgZXh0ZW5zaW9uIGF0dHJpYnV0ZXMgaW50byBwYXJzZXJ1bGUgYXR0cmlidXRlcyAoYGF0dHJzYCBvciBgZ2V0QXR0cnNgKS5cbiAqIENhbmNlbHMgd2hlbiBgZ2V0QXR0cnNgIHJldHVybmVkIGBmYWxzZWAuXG4gKiBAcGFyYW0gcGFyc2VSdWxlIFByb3NlTWlycm9yIFBhcnNlUnVsZVxuICogQHBhcmFtIGV4dGVuc2lvbkF0dHJpYnV0ZXMgTGlzdCBvZiBhdHRyaWJ1dGVzIHRvIGluamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlKFxuICBwYXJzZVJ1bGU6IFBhcnNlUnVsZSxcbiAgZXh0ZW5zaW9uQXR0cmlidXRlczogRXh0ZW5zaW9uQXR0cmlidXRlW10sXG4pOiBQYXJzZVJ1bGUge1xuICBpZiAocGFyc2VSdWxlLnN0eWxlKSB7XG4gICAgcmV0dXJuIHBhcnNlUnVsZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5wYXJzZVJ1bGUsXG4gICAgZ2V0QXR0cnM6IG5vZGUgPT4ge1xuICAgICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IHBhcnNlUnVsZS5nZXRBdHRycyA/IHBhcnNlUnVsZS5nZXRBdHRycyhub2RlKSA6IHBhcnNlUnVsZS5hdHRyc1xuXG4gICAgICBpZiAob2xkQXR0cmlidXRlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBleHRlbnNpb25BdHRyaWJ1dGVzLnJlZHVjZSgoaXRlbXMsIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpdGVtLmF0dHJpYnV0ZS5wYXJzZUhUTUxcbiAgICAgICAgICA/IGl0ZW0uYXR0cmlidXRlLnBhcnNlSFRNTChub2RlIGFzIEhUTUxFbGVtZW50KVxuICAgICAgICAgIDogZnJvbVN0cmluZygobm9kZSBhcyBIVE1MRWxlbWVudCkuZ2V0QXR0cmlidXRlKGl0ZW0ubmFtZSkpXG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gaXRlbXNcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uaXRlbXMsXG4gICAgICAgICAgW2l0ZW0ubmFtZV06IHZhbHVlLFxuICAgICAgICB9XG4gICAgICB9LCB7fSlcblxuICAgICAgcmV0dXJuIHsgLi4ub2xkQXR0cmlidXRlcywgLi4ubmV3QXR0cmlidXRlcyB9XG4gICAgfSxcbiAgfVxufVxuIiwgImltcG9ydCB7IE1hcmtTcGVjLCBOb2RlU3BlYywgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRWRpdG9yLCBNYXJrQ29uZmlnLCBOb2RlQ29uZmlnIH0gZnJvbSAnLi4vaW5kZXguanMnXG5pbXBvcnQgeyBBbnlDb25maWcsIEV4dGVuc2lvbnMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4uL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5pbXBvcnQgeyBpc0VtcHR5T2JqZWN0IH0gZnJvbSAnLi4vdXRpbGl0aWVzL2lzRW1wdHlPYmplY3QuanMnXG5pbXBvcnQgeyBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMgfSBmcm9tICcuL2dldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucy5qcydcbmltcG9ydCB7IGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSAnLi9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IGdldFJlbmRlcmVkQXR0cmlidXRlcyB9IGZyb20gJy4vZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzLmpzJ1xuaW1wb3J0IHsgaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlIH0gZnJvbSAnLi9pbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUuanMnXG5pbXBvcnQgeyBzcGxpdEV4dGVuc2lvbnMgfSBmcm9tICcuL3NwbGl0RXh0ZW5zaW9ucy5qcydcblxuZnVuY3Rpb24gY2xlYW5VcFNjaGVtYUl0ZW08VD4oZGF0YTogVCkge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBPYmplY3QuZW50cmllcyhkYXRhKS5maWx0ZXIoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gJ2F0dHJzJyAmJiBpc0VtcHR5T2JqZWN0KHZhbHVlIGFzIHt9IHwgdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWRcbiAgICB9KSxcbiAgKSBhcyBUXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyhleHRlbnNpb25zOiBFeHRlbnNpb25zLCBlZGl0b3I/OiBFZGl0b3IpOiBTY2hlbWEge1xuICBjb25zdCBhbGxBdHRyaWJ1dGVzID0gZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zKGV4dGVuc2lvbnMpXG4gIGNvbnN0IHsgbm9kZUV4dGVuc2lvbnMsIG1hcmtFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnMoZXh0ZW5zaW9ucylcbiAgY29uc3QgdG9wTm9kZSA9IG5vZGVFeHRlbnNpb25zLmZpbmQoZXh0ZW5zaW9uID0+IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3RvcE5vZGUnKSk/Lm5hbWVcblxuICBjb25zdCBub2RlcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBub2RlRXh0ZW5zaW9ucy5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBhbGxBdHRyaWJ1dGVzLmZpbHRlcihcbiAgICAgICAgYXR0cmlidXRlID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSxcbiAgICAgIClcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgIGVkaXRvcixcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXh0cmFOb2RlRmllbGRzID0gZXh0ZW5zaW9ucy5yZWR1Y2UoKGZpZWxkcywgZSkgPT4ge1xuICAgICAgICBjb25zdCBleHRlbmROb2RlU2NoZW1hID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydleHRlbmROb2RlU2NoZW1hJ10+KFxuICAgICAgICAgIGUsXG4gICAgICAgICAgJ2V4dGVuZE5vZGVTY2hlbWEnLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIClcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAuLi4oZXh0ZW5kTm9kZVNjaGVtYSA/IGV4dGVuZE5vZGVTY2hlbWEoZXh0ZW5zaW9uKSA6IHt9KSxcbiAgICAgICAgfVxuICAgICAgfSwge30pXG5cbiAgICAgIGNvbnN0IHNjaGVtYTogTm9kZVNwZWMgPSBjbGVhblVwU2NoZW1hSXRlbSh7XG4gICAgICAgIC4uLmV4dHJhTm9kZUZpZWxkcyxcbiAgICAgICAgY29udGVudDogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2NvbnRlbnQnXT4oZXh0ZW5zaW9uLCAnY29udGVudCcsIGNvbnRleHQpLFxuICAgICAgICApLFxuICAgICAgICBtYXJrczogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ21hcmtzJ10+KGV4dGVuc2lvbiwgJ21hcmtzJywgY29udGV4dCkpLFxuICAgICAgICBncm91cDogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2dyb3VwJ10+KGV4dGVuc2lvbiwgJ2dyb3VwJywgY29udGV4dCkpLFxuICAgICAgICBpbmxpbmU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydpbmxpbmUnXT4oZXh0ZW5zaW9uLCAnaW5saW5lJywgY29udGV4dCkpLFxuICAgICAgICBhdG9tOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snYXRvbSddPihleHRlbnNpb24sICdhdG9tJywgY29udGV4dCkpLFxuICAgICAgICBzZWxlY3RhYmxlOiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snc2VsZWN0YWJsZSddPihleHRlbnNpb24sICdzZWxlY3RhYmxlJywgY29udGV4dCksXG4gICAgICAgICksXG4gICAgICAgIGRyYWdnYWJsZTogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2RyYWdnYWJsZSddPihleHRlbnNpb24sICdkcmFnZ2FibGUnLCBjb250ZXh0KSxcbiAgICAgICAgKSxcbiAgICAgICAgY29kZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2NvZGUnXT4oZXh0ZW5zaW9uLCAnY29kZScsIGNvbnRleHQpKSxcbiAgICAgICAgZGVmaW5pbmc6IGNhbGxPclJldHVybihcbiAgICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydkZWZpbmluZyddPihleHRlbnNpb24sICdkZWZpbmluZycsIGNvbnRleHQpLFxuICAgICAgICApLFxuICAgICAgICBpc29sYXRpbmc6IGNhbGxPclJldHVybihcbiAgICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydpc29sYXRpbmcnXT4oZXh0ZW5zaW9uLCAnaXNvbGF0aW5nJywgY29udGV4dCksXG4gICAgICAgICksXG4gICAgICAgIGF0dHJzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcy5tYXAoZXh0ZW5zaW9uQXR0cmlidXRlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uQXR0cmlidXRlLm5hbWUsIHsgZGVmYXVsdDogZXh0ZW5zaW9uQXR0cmlidXRlPy5hdHRyaWJ1dGU/LmRlZmF1bHQgfV1cbiAgICAgICAgICB9KSxcbiAgICAgICAgKSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHBhcnNlSFRNTCA9IGNhbGxPclJldHVybihcbiAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1sncGFyc2VIVE1MJ10+KGV4dGVuc2lvbiwgJ3BhcnNlSFRNTCcsIGNvbnRleHQpLFxuICAgICAgKVxuXG4gICAgICBpZiAocGFyc2VIVE1MKSB7XG4gICAgICAgIHNjaGVtYS5wYXJzZURPTSA9IHBhcnNlSFRNTC5tYXAocGFyc2VSdWxlID0+IGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZShwYXJzZVJ1bGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpKVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZW5kZXJIVE1MID0gZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1sncmVuZGVySFRNTCddPihcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAncmVuZGVySFRNTCcsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApXG5cbiAgICAgIGlmIChyZW5kZXJIVE1MKSB7XG4gICAgICAgIHNjaGVtYS50b0RPTSA9IG5vZGUgPT4gcmVuZGVySFRNTCh7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBIVE1MQXR0cmlidXRlczogZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG5vZGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZW5kZXJUZXh0ID0gZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1sncmVuZGVyVGV4dCddPihcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAncmVuZGVyVGV4dCcsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApXG5cbiAgICAgIGlmIChyZW5kZXJUZXh0KSB7XG4gICAgICAgIHNjaGVtYS50b1RleHQgPSByZW5kZXJUZXh0XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIHNjaGVtYV1cbiAgICB9KSxcbiAgKVxuXG4gIGNvbnN0IG1hcmtzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIG1hcmtFeHRlbnNpb25zLm1hcChleHRlbnNpb24gPT4ge1xuICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGFsbEF0dHJpYnV0ZXMuZmlsdGVyKFxuICAgICAgICBhdHRyaWJ1dGUgPT4gYXR0cmlidXRlLnR5cGUgPT09IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgKVxuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgZWRpdG9yLFxuICAgICAgfVxuXG4gICAgICBjb25zdCBleHRyYU1hcmtGaWVsZHMgPSBleHRlbnNpb25zLnJlZHVjZSgoZmllbGRzLCBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4dGVuZE1hcmtTY2hlbWEgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2V4dGVuZE1hcmtTY2hlbWEnXT4oXG4gICAgICAgICAgZSxcbiAgICAgICAgICAnZXh0ZW5kTWFya1NjaGVtYScsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgIC4uLihleHRlbmRNYXJrU2NoZW1hID8gZXh0ZW5kTWFya1NjaGVtYShleHRlbnNpb24pIDoge30pLFxuICAgICAgICB9XG4gICAgICB9LCB7fSlcblxuICAgICAgY29uc3Qgc2NoZW1hOiBNYXJrU3BlYyA9IGNsZWFuVXBTY2hlbWFJdGVtKHtcbiAgICAgICAgLi4uZXh0cmFNYXJrRmllbGRzLFxuICAgICAgICBpbmNsdXNpdmU6IGNhbGxPclJldHVybihcbiAgICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydpbmNsdXNpdmUnXT4oZXh0ZW5zaW9uLCAnaW5jbHVzaXZlJywgY29udGV4dCksXG4gICAgICAgICksXG4gICAgICAgIGV4Y2x1ZGVzOiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1snZXhjbHVkZXMnXT4oZXh0ZW5zaW9uLCAnZXhjbHVkZXMnLCBjb250ZXh0KSxcbiAgICAgICAgKSxcbiAgICAgICAgZ3JvdXA6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydncm91cCddPihleHRlbnNpb24sICdncm91cCcsIGNvbnRleHQpKSxcbiAgICAgICAgc3Bhbm5pbmc6IGNhbGxPclJldHVybihcbiAgICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydzcGFubmluZyddPihleHRlbnNpb24sICdzcGFubmluZycsIGNvbnRleHQpLFxuICAgICAgICApLFxuICAgICAgICBjb2RlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1snY29kZSddPihleHRlbnNpb24sICdjb2RlJywgY29udGV4dCkpLFxuICAgICAgICBhdHRyczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMubWFwKGV4dGVuc2lvbkF0dHJpYnV0ZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbkF0dHJpYnV0ZS5uYW1lLCB7IGRlZmF1bHQ6IGV4dGVuc2lvbkF0dHJpYnV0ZT8uYXR0cmlidXRlPy5kZWZhdWx0IH1dXG4gICAgICAgICAgfSksXG4gICAgICAgICksXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBwYXJzZUhUTUwgPSBjYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE1hcmtDb25maWdbJ3BhcnNlSFRNTCddPihleHRlbnNpb24sICdwYXJzZUhUTUwnLCBjb250ZXh0KSxcbiAgICAgIClcblxuICAgICAgaWYgKHBhcnNlSFRNTCkge1xuICAgICAgICBzY2hlbWEucGFyc2VET00gPSBwYXJzZUhUTUwubWFwKHBhcnNlUnVsZSA9PiBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUocGFyc2VSdWxlLCBleHRlbnNpb25BdHRyaWJ1dGVzKSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVuZGVySFRNTCA9IGdldEV4dGVuc2lvbkZpZWxkPE1hcmtDb25maWdbJ3JlbmRlckhUTUwnXT4oXG4gICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgJ3JlbmRlckhUTUwnLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuXG4gICAgICBpZiAocmVuZGVySFRNTCkge1xuICAgICAgICBzY2hlbWEudG9ET00gPSBtYXJrID0+IHJlbmRlckhUTUwoe1xuICAgICAgICAgIG1hcmssXG4gICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IGdldFJlbmRlcmVkQXR0cmlidXRlcyhtYXJrLCBleHRlbnNpb25BdHRyaWJ1dGVzKSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtleHRlbnNpb24ubmFtZSwgc2NoZW1hXVxuICAgIH0pLFxuICApXG5cbiAgcmV0dXJuIG5ldyBTY2hlbWEoe1xuICAgIHRvcE5vZGUsXG4gICAgbm9kZXMsXG4gICAgbWFya3MsXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUsIE5vZGVUeXBlLCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZUJ5TmFtZShuYW1lOiBzdHJpbmcsIHNjaGVtYTogU2NoZW1hKTogTm9kZVR5cGUgfCBNYXJrVHlwZSB8IG51bGwge1xuICByZXR1cm4gc2NoZW1hLm5vZGVzW25hbWVdIHx8IHNjaGVtYS5tYXJrc1tuYW1lXSB8fCBudWxsXG59XG4iLCAiaW1wb3J0IHsgQW55RXh0ZW5zaW9uLCBFbmFibGVSdWxlcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQoZXh0ZW5zaW9uOiBBbnlFeHRlbnNpb24sIGVuYWJsZWQ6IEVuYWJsZVJ1bGVzKTogYm9vbGVhbiB7XG4gIGlmIChBcnJheS5pc0FycmF5KGVuYWJsZWQpKSB7XG4gICAgcmV0dXJuIGVuYWJsZWQuc29tZShlbmFibGVkRXh0ZW5zaW9uID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgZW5hYmxlZEV4dGVuc2lvbiA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBlbmFibGVkRXh0ZW5zaW9uXG4gICAgICAgIDogZW5hYmxlZEV4dGVuc2lvbi5uYW1lXG5cbiAgICAgIHJldHVybiBuYW1lID09PSBleHRlbnNpb24ubmFtZVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gZW5hYmxlZFxufVxuIiwgImltcG9ydCB7IFJlc29sdmVkUG9zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGNvbnN0IGdldFRleHRDb250ZW50RnJvbU5vZGVzID0gKCRmcm9tOiBSZXNvbHZlZFBvcywgbWF4TWF0Y2ggPSA1MDApID0+IHtcbiAgbGV0IHRleHRCZWZvcmUgPSAnJ1xuXG4gIGNvbnN0IHNsaWNlRW5kUG9zID0gJGZyb20ucGFyZW50T2Zmc2V0XG5cbiAgJGZyb20ucGFyZW50Lm5vZGVzQmV0d2VlbihcbiAgICBNYXRoLm1heCgwLCBzbGljZUVuZFBvcyAtIG1heE1hdGNoKSxcbiAgICBzbGljZUVuZFBvcyxcbiAgICAobm9kZSwgcG9zLCBwYXJlbnQsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBjaHVuayA9IG5vZGUudHlwZS5zcGVjLnRvVGV4dD8uKHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgcG9zLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIGluZGV4LFxuICAgICAgfSlcbiAgICAgICAgfHwgbm9kZS50ZXh0Q29udGVudFxuICAgICAgICB8fCAnJWxlYWYlJ1xuXG4gICAgICB0ZXh0QmVmb3JlICs9IGNodW5rLnNsaWNlKDAsIE1hdGgubWF4KDAsIHNsaWNlRW5kUG9zIC0gcG9zKSlcbiAgICB9LFxuICApXG5cbiAgcmV0dXJuIHRleHRCZWZvcmVcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNSZWdFeHAodmFsdWU6IGFueSk6IHZhbHVlIGlzIFJlZ0V4cCB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBSZWdFeHBdJ1xufVxuIiwgImltcG9ydCB7IEVkaXRvclN0YXRlLCBQbHVnaW4sIFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBDb21tYW5kTWFuYWdlciB9IGZyb20gJy4vQ29tbWFuZE1hbmFnZXIuanMnXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB7IGNyZWF0ZUNoYWluYWJsZVN0YXRlIH0gZnJvbSAnLi9oZWxwZXJzL2NyZWF0ZUNoYWluYWJsZVN0YXRlLmpzJ1xuaW1wb3J0IHsgZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMgfSBmcm9tICcuL2hlbHBlcnMvZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMuanMnXG5pbXBvcnQge1xuICBDYW5Db21tYW5kcyxcbiAgQ2hhaW5lZENvbW1hbmRzLFxuICBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXksXG4gIFJhbmdlLFxuICBTaW5nbGVDb21tYW5kcyxcbn0gZnJvbSAnLi90eXBlcy5qcydcbmltcG9ydCB7IGlzUmVnRXhwIH0gZnJvbSAnLi91dGlsaXRpZXMvaXNSZWdFeHAuanMnXG5cbmV4cG9ydCB0eXBlIElucHV0UnVsZU1hdGNoID0ge1xuICBpbmRleDogbnVtYmVyXG4gIHRleHQ6IHN0cmluZ1xuICByZXBsYWNlV2l0aD86IHN0cmluZ1xuICBtYXRjaD86IFJlZ0V4cE1hdGNoQXJyYXlcbiAgZGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT5cbn1cblxuZXhwb3J0IHR5cGUgSW5wdXRSdWxlRmluZGVyID0gUmVnRXhwIHwgKCh0ZXh0OiBzdHJpbmcpID0+IElucHV0UnVsZU1hdGNoIHwgbnVsbClcblxuZXhwb3J0IGNsYXNzIElucHV0UnVsZSB7XG4gIGZpbmQ6IElucHV0UnVsZUZpbmRlclxuXG4gIGhhbmRsZXI6IChwcm9wczoge1xuICAgIHN0YXRlOiBFZGl0b3JTdGF0ZVxuICAgIHJhbmdlOiBSYW5nZVxuICAgIG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXlcbiAgICBjb21tYW5kczogU2luZ2xlQ29tbWFuZHNcbiAgICBjaGFpbjogKCkgPT4gQ2hhaW5lZENvbW1hbmRzXG4gICAgY2FuOiAoKSA9PiBDYW5Db21tYW5kc1xuICB9KSA9PiB2b2lkIHwgbnVsbFxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzoge1xuICAgIGZpbmQ6IElucHV0UnVsZUZpbmRlclxuICAgIGhhbmRsZXI6IChwcm9wczoge1xuICAgICAgc3RhdGU6IEVkaXRvclN0YXRlXG4gICAgICByYW5nZTogUmFuZ2VcbiAgICAgIG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXlcbiAgICAgIGNvbW1hbmRzOiBTaW5nbGVDb21tYW5kc1xuICAgICAgY2hhaW46ICgpID0+IENoYWluZWRDb21tYW5kc1xuICAgICAgY2FuOiAoKSA9PiBDYW5Db21tYW5kc1xuICAgIH0pID0+IHZvaWQgfCBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmZpbmQgPSBjb25maWcuZmluZFxuICAgIHRoaXMuaGFuZGxlciA9IGNvbmZpZy5oYW5kbGVyXG4gIH1cbn1cblxuY29uc3QgaW5wdXRSdWxlTWF0Y2hlckhhbmRsZXIgPSAoXG4gIHRleHQ6IHN0cmluZyxcbiAgZmluZDogSW5wdXRSdWxlRmluZGVyLFxuKTogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IHwgbnVsbCA9PiB7XG4gIGlmIChpc1JlZ0V4cChmaW5kKSkge1xuICAgIHJldHVybiBmaW5kLmV4ZWModGV4dClcbiAgfVxuXG4gIGNvbnN0IGlucHV0UnVsZU1hdGNoID0gZmluZCh0ZXh0KVxuXG4gIGlmICghaW5wdXRSdWxlTWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgcmVzdWx0OiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkgPSBbaW5wdXRSdWxlTWF0Y2gudGV4dF1cblxuICByZXN1bHQuaW5kZXggPSBpbnB1dFJ1bGVNYXRjaC5pbmRleFxuICByZXN1bHQuaW5wdXQgPSB0ZXh0XG4gIHJlc3VsdC5kYXRhID0gaW5wdXRSdWxlTWF0Y2guZGF0YVxuXG4gIGlmIChpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkge1xuICAgIGlmICghaW5wdXRSdWxlTWF0Y2gudGV4dC5pbmNsdWRlcyhpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1t0aXB0YXAgd2Fybl06IFwiaW5wdXRSdWxlTWF0Y2gucmVwbGFjZVdpdGhcIiBtdXN0IGJlIHBhcnQgb2YgXCJpbnB1dFJ1bGVNYXRjaC50ZXh0XCIuJyxcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXN1bHQucHVzaChpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gcnVuKGNvbmZpZzoge1xuICBlZGl0b3I6IEVkaXRvclxuICBmcm9tOiBudW1iZXJcbiAgdG86IG51bWJlclxuICB0ZXh0OiBzdHJpbmdcbiAgcnVsZXM6IElucHV0UnVsZVtdXG4gIHBsdWdpbjogUGx1Z2luXG59KTogYm9vbGVhbiB7XG4gIGNvbnN0IHtcbiAgICBlZGl0b3IsIGZyb20sIHRvLCB0ZXh0LCBydWxlcywgcGx1Z2luLFxuICB9ID0gY29uZmlnXG4gIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yXG5cbiAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCAkZnJvbSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZnJvbSlcblxuICBpZiAoXG4gICAgLy8gY2hlY2sgZm9yIGNvZGUgbm9kZVxuICAgICRmcm9tLnBhcmVudC50eXBlLnNwZWMuY29kZVxuICAgIC8vIGNoZWNrIGZvciBjb2RlIG1hcmtcbiAgICB8fCAhISgkZnJvbS5ub2RlQmVmb3JlIHx8ICRmcm9tLm5vZGVBZnRlcik/Lm1hcmtzLmZpbmQobWFyayA9PiBtYXJrLnR5cGUuc3BlYy5jb2RlKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGxldCBtYXRjaGVkID0gZmFsc2VcblxuICBjb25zdCB0ZXh0QmVmb3JlID0gZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMoJGZyb20pICsgdGV4dFxuXG4gIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoID0gaW5wdXRSdWxlTWF0Y2hlckhhbmRsZXIodGV4dEJlZm9yZSwgcnVsZS5maW5kKVxuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyXG4gICAgY29uc3Qgc3RhdGUgPSBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XG4gICAgICBzdGF0ZTogdmlldy5zdGF0ZSxcbiAgICAgIHRyYW5zYWN0aW9uOiB0cixcbiAgICB9KVxuICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgZnJvbTogZnJvbSAtIChtYXRjaFswXS5sZW5ndGggLSB0ZXh0Lmxlbmd0aCksXG4gICAgICB0byxcbiAgICB9XG5cbiAgICBjb25zdCB7IGNvbW1hbmRzLCBjaGFpbiwgY2FuIH0gPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgICAgZWRpdG9yLFxuICAgICAgc3RhdGUsXG4gICAgfSlcblxuICAgIGNvbnN0IGhhbmRsZXIgPSBydWxlLmhhbmRsZXIoe1xuICAgICAgc3RhdGUsXG4gICAgICByYW5nZSxcbiAgICAgIG1hdGNoLFxuICAgICAgY29tbWFuZHMsXG4gICAgICBjaGFpbixcbiAgICAgIGNhbixcbiAgICB9KVxuXG4gICAgLy8gc3RvcCBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlc1xuICAgIGlmIChoYW5kbGVyID09PSBudWxsIHx8ICF0ci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHN0b3JlIHRyYW5zZm9ybSBhcyBtZXRhIGRhdGFcbiAgICAvLyBzbyB3ZSBjYW4gdW5kbyBpbnB1dCBydWxlcyB3aXRoaW4gdGhlIGB1bmRvSW5wdXRSdWxlc2AgY29tbWFuZFxuICAgIHRyLnNldE1ldGEocGx1Z2luLCB7XG4gICAgICB0cmFuc2Zvcm06IHRyLFxuICAgICAgZnJvbSxcbiAgICAgIHRvLFxuICAgICAgdGV4dCxcbiAgICB9KVxuXG4gICAgdmlldy5kaXNwYXRjaCh0cilcbiAgICBtYXRjaGVkID0gdHJ1ZVxuICB9KVxuXG4gIHJldHVybiBtYXRjaGVkXG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGlucHV0IHJ1bGVzIHBsdWdpbi4gV2hlbiBlbmFibGVkLCBpdCB3aWxsIGNhdXNlIHRleHRcbiAqIGlucHV0IHRoYXQgbWF0Y2hlcyBhbnkgb2YgdGhlIGdpdmVuIHJ1bGVzIHRvIHRyaWdnZXIgdGhlIHJ1bGXigJlzXG4gKiBhY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnB1dFJ1bGVzUGx1Z2luKHByb3BzOiB7IGVkaXRvcjogRWRpdG9yOyBydWxlczogSW5wdXRSdWxlW10gfSk6IFBsdWdpbiB7XG4gIGNvbnN0IHsgZWRpdG9yLCBydWxlcyB9ID0gcHJvcHNcbiAgY29uc3QgcGx1Z2luID0gbmV3IFBsdWdpbih7XG4gICAgc3RhdGU6IHtcbiAgICAgIGluaXQoKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9LFxuICAgICAgYXBwbHkodHIsIHByZXYpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVkID0gdHIuZ2V0TWV0YShwbHVnaW4pXG5cbiAgICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICAgIHJldHVybiBzdG9yZWRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ci5zZWxlY3Rpb25TZXQgfHwgdHIuZG9jQ2hhbmdlZCA/IG51bGwgOiBwcmV2XG4gICAgICB9LFxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuICAgICAgaGFuZGxlVGV4dElucHV0KHZpZXcsIGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiBydW4oe1xuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICBmcm9tLFxuICAgICAgICAgIHRvLFxuICAgICAgICAgIHRleHQsXG4gICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgcGx1Z2luLFxuICAgICAgICB9KVxuICAgICAgfSxcblxuICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgIGNvbXBvc2l0aW9uZW5kOiB2aWV3ID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24gYXMgVGV4dFNlbGVjdGlvblxuXG4gICAgICAgICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICAgICAgICBydW4oe1xuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICBmcm9tOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgICAgICB0bzogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgICAgICAgcGx1Z2luLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSxcbiAgICAgIH0sXG5cbiAgICAgIC8vIGFkZCBzdXBwb3J0IGZvciBpbnB1dCBydWxlcyB0byB0cmlnZ2VyIG9uIGVudGVyXG4gICAgICAvLyB0aGlzIGlzIHVzZWZ1bCBmb3IgZXhhbXBsZSBmb3IgY29kZSBibG9ja3NcbiAgICAgIGhhbmRsZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSAhPT0gJ0VudGVyJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyAkY3Vyc29yIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiBhcyBUZXh0U2VsZWN0aW9uXG5cbiAgICAgICAgaWYgKCRjdXJzb3IpIHtcbiAgICAgICAgICByZXR1cm4gcnVuKHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGZyb206ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgdG86ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgdGV4dDogJ1xcbicsXG4gICAgICAgICAgICBydWxlcyxcbiAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9LFxuICAgIH0sXG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaXNJbnB1dFJ1bGVzOiB0cnVlLFxuICB9KSBhcyBQbHVnaW5cblxuICByZXR1cm4gcGx1Z2luXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBudW1iZXIge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xufVxuIiwgImltcG9ydCB7IEVkaXRvclN0YXRlLCBQbHVnaW4gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBDb21tYW5kTWFuYWdlciB9IGZyb20gJy4vQ29tbWFuZE1hbmFnZXIuanMnXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB7IGNyZWF0ZUNoYWluYWJsZVN0YXRlIH0gZnJvbSAnLi9oZWxwZXJzL2NyZWF0ZUNoYWluYWJsZVN0YXRlLmpzJ1xuaW1wb3J0IHtcbiAgQ2FuQ29tbWFuZHMsXG4gIENoYWluZWRDb21tYW5kcyxcbiAgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5LFxuICBSYW5nZSxcbiAgU2luZ2xlQ29tbWFuZHMsXG59IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBpc051bWJlciB9IGZyb20gJy4vdXRpbGl0aWVzL2lzTnVtYmVyLmpzJ1xuaW1wb3J0IHsgaXNSZWdFeHAgfSBmcm9tICcuL3V0aWxpdGllcy9pc1JlZ0V4cC5qcydcblxuZXhwb3J0IHR5cGUgUGFzdGVSdWxlTWF0Y2ggPSB7XG4gIGluZGV4OiBudW1iZXJcbiAgdGV4dDogc3RyaW5nXG4gIHJlcGxhY2VXaXRoPzogc3RyaW5nXG4gIG1hdGNoPzogUmVnRXhwTWF0Y2hBcnJheVxuICBkYXRhPzogUmVjb3JkPHN0cmluZywgYW55PlxufVxuXG5leHBvcnQgdHlwZSBQYXN0ZVJ1bGVGaW5kZXIgPSBSZWdFeHAgfCAoKHRleHQ6IHN0cmluZykgPT4gUGFzdGVSdWxlTWF0Y2hbXSB8IG51bGwgfCB1bmRlZmluZWQpXG5cbmV4cG9ydCBjbGFzcyBQYXN0ZVJ1bGUge1xuICBmaW5kOiBQYXN0ZVJ1bGVGaW5kZXJcblxuICBoYW5kbGVyOiAocHJvcHM6IHtcbiAgICBzdGF0ZTogRWRpdG9yU3RhdGVcbiAgICByYW5nZTogUmFuZ2VcbiAgICBtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5XG4gICAgY29tbWFuZHM6IFNpbmdsZUNvbW1hbmRzXG4gICAgY2hhaW46ICgpID0+IENoYWluZWRDb21tYW5kc1xuICAgIGNhbjogKCkgPT4gQ2FuQ29tbWFuZHNcbiAgfSkgPT4gdm9pZCB8IG51bGxcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IHtcbiAgICBmaW5kOiBQYXN0ZVJ1bGVGaW5kZXJcbiAgICBoYW5kbGVyOiAocHJvcHM6IHtcbiAgICAgIHN0YXRlOiBFZGl0b3JTdGF0ZVxuICAgICAgcmFuZ2U6IFJhbmdlXG4gICAgICBtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5XG4gICAgICBjb21tYW5kczogU2luZ2xlQ29tbWFuZHNcbiAgICAgIGNoYWluOiAoKSA9PiBDaGFpbmVkQ29tbWFuZHNcbiAgICAgIGNhbjogKCkgPT4gQ2FuQ29tbWFuZHNcbiAgICB9KSA9PiB2b2lkIHwgbnVsbFxuICB9KSB7XG4gICAgdGhpcy5maW5kID0gY29uZmlnLmZpbmRcbiAgICB0aGlzLmhhbmRsZXIgPSBjb25maWcuaGFuZGxlclxuICB9XG59XG5cbmNvbnN0IHBhc3RlUnVsZU1hdGNoZXJIYW5kbGVyID0gKFxuICB0ZXh0OiBzdHJpbmcsXG4gIGZpbmQ6IFBhc3RlUnVsZUZpbmRlcixcbik6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheVtdID0+IHtcbiAgaWYgKGlzUmVnRXhwKGZpbmQpKSB7XG4gICAgcmV0dXJuIFsuLi50ZXh0Lm1hdGNoQWxsKGZpbmQpXVxuICB9XG5cbiAgY29uc3QgbWF0Y2hlcyA9IGZpbmQodGV4dClcblxuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzLm1hcChwYXN0ZVJ1bGVNYXRjaCA9PiB7XG4gICAgY29uc3QgcmVzdWx0OiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkgPSBbcGFzdGVSdWxlTWF0Y2gudGV4dF1cblxuICAgIHJlc3VsdC5pbmRleCA9IHBhc3RlUnVsZU1hdGNoLmluZGV4XG4gICAgcmVzdWx0LmlucHV0ID0gdGV4dFxuICAgIHJlc3VsdC5kYXRhID0gcGFzdGVSdWxlTWF0Y2guZGF0YVxuXG4gICAgaWYgKHBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoKSB7XG4gICAgICBpZiAoIXBhc3RlUnVsZU1hdGNoLnRleHQuaW5jbHVkZXMocGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnW3RpcHRhcCB3YXJuXTogXCJwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aFwiIG11c3QgYmUgcGFydCBvZiBcInBhc3RlUnVsZU1hdGNoLnRleHRcIi4nLFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5wdXNoKHBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoKVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfSlcbn1cblxuZnVuY3Rpb24gcnVuKGNvbmZpZzoge1xuICBlZGl0b3I6IEVkaXRvclxuICBzdGF0ZTogRWRpdG9yU3RhdGVcbiAgZnJvbTogbnVtYmVyXG4gIHRvOiBudW1iZXJcbiAgcnVsZTogUGFzdGVSdWxlXG59KTogYm9vbGVhbiB7XG4gIGNvbnN0IHtcbiAgICBlZGl0b3IsIHN0YXRlLCBmcm9tLCB0bywgcnVsZSxcbiAgfSA9IGNvbmZpZ1xuXG4gIGNvbnN0IHsgY29tbWFuZHMsIGNoYWluLCBjYW4gfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgZWRpdG9yLFxuICAgIHN0YXRlLFxuICB9KVxuXG4gIGNvbnN0IGhhbmRsZXJzOiAodm9pZCB8IG51bGwpW10gPSBbXVxuXG4gIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICBpZiAoIW5vZGUuaXNUZXh0YmxvY2sgfHwgbm9kZS50eXBlLnNwZWMuY29kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVzb2x2ZWRGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKVxuICAgIGNvbnN0IHJlc29sdmVkVG8gPSBNYXRoLm1pbih0bywgcG9zICsgbm9kZS5jb250ZW50LnNpemUpXG4gICAgY29uc3QgdGV4dFRvTWF0Y2ggPSBub2RlLnRleHRCZXR3ZWVuKHJlc29sdmVkRnJvbSAtIHBvcywgcmVzb2x2ZWRUbyAtIHBvcywgdW5kZWZpbmVkLCAnXFx1ZmZmYycpXG5cbiAgICBjb25zdCBtYXRjaGVzID0gcGFzdGVSdWxlTWF0Y2hlckhhbmRsZXIodGV4dFRvTWF0Y2gsIHJ1bGUuZmluZClcblxuICAgIG1hdGNoZXMuZm9yRWFjaChtYXRjaCA9PiB7XG4gICAgICBpZiAobWF0Y2guaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhcnQgPSByZXNvbHZlZEZyb20gKyBtYXRjaC5pbmRleCArIDFcbiAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgICAgZnJvbTogc3RhdGUudHIubWFwcGluZy5tYXAoc3RhcnQpLFxuICAgICAgICB0bzogc3RhdGUudHIubWFwcGluZy5tYXAoZW5kKSxcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGFuZGxlciA9IHJ1bGUuaGFuZGxlcih7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICByYW5nZSxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGNvbW1hbmRzLFxuICAgICAgICBjaGFpbixcbiAgICAgICAgY2FuLFxuICAgICAgfSlcblxuICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKVxuICAgIH0pXG4gIH0pXG5cbiAgY29uc3Qgc3VjY2VzcyA9IGhhbmRsZXJzLmV2ZXJ5KGhhbmRsZXIgPT4gaGFuZGxlciAhPT0gbnVsbClcblxuICByZXR1cm4gc3VjY2Vzc1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBwYXN0ZSBydWxlcyBwbHVnaW4uIFdoZW4gZW5hYmxlZCwgaXQgd2lsbCBjYXVzZSBwYXN0ZWRcbiAqIHRleHQgdGhhdCBtYXRjaGVzIGFueSBvZiB0aGUgZ2l2ZW4gcnVsZXMgdG8gdHJpZ2dlciB0aGUgcnVsZeKAmXNcbiAqIGFjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhc3RlUnVsZXNQbHVnaW4ocHJvcHM6IHsgZWRpdG9yOiBFZGl0b3I7IHJ1bGVzOiBQYXN0ZVJ1bGVbXSB9KTogUGx1Z2luW10ge1xuICBjb25zdCB7IGVkaXRvciwgcnVsZXMgfSA9IHByb3BzXG4gIGxldCBkcmFnU291cmNlRWxlbWVudDogRWxlbWVudCB8IG51bGwgPSBudWxsXG4gIGxldCBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9IGZhbHNlXG4gIGxldCBpc0Ryb3BwZWRGcm9tUHJvc2VNaXJyb3IgPSBmYWxzZVxuXG4gIGNvbnN0IHBsdWdpbnMgPSBydWxlcy5tYXAocnVsZSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgLy8gd2UgcmVnaXN0ZXIgYSBnbG9iYWwgZHJhZyBoYW5kbGVyIHRvIHRyYWNrIHRoZSBjdXJyZW50IGRyYWcgc291cmNlIGVsZW1lbnRcbiAgICAgIHZpZXcodmlldykge1xuICAgICAgICBjb25zdCBoYW5kbGVEcmFnc3RhcnQgPSAoZXZlbnQ6IERyYWdFdmVudCkgPT4ge1xuICAgICAgICAgIGRyYWdTb3VyY2VFbGVtZW50ID0gdmlldy5kb20ucGFyZW50RWxlbWVudD8uY29udGFpbnMoZXZlbnQudGFyZ2V0IGFzIEVsZW1lbnQpXG4gICAgICAgICAgICA/IHZpZXcuZG9tLnBhcmVudEVsZW1lbnRcbiAgICAgICAgICAgIDogbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIGhhbmRsZURyYWdzdGFydClcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgaGFuZGxlRHJhZ3N0YXJ0KVxuICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgIGRyb3A6IHZpZXcgPT4ge1xuICAgICAgICAgICAgaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yID0gZHJhZ1NvdXJjZUVsZW1lbnQgPT09IHZpZXcuZG9tLnBhcmVudEVsZW1lbnRcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHBhc3RlOiAodmlldywgZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBodG1sID0gKGV2ZW50IGFzIENsaXBib2FyZEV2ZW50KS5jbGlwYm9hcmREYXRhPy5nZXREYXRhKCd0ZXh0L2h0bWwnKVxuXG4gICAgICAgICAgICBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9ICEhaHRtbD8uaW5jbHVkZXMoJ2RhdGEtcG0tc2xpY2UnKVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcblxuICAgICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbnMsIG9sZFN0YXRlLCBzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uc1swXVxuICAgICAgICBjb25zdCBpc1Bhc3RlID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgndWlFdmVudCcpID09PSAncGFzdGUnICYmICFpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvclxuICAgICAgICBjb25zdCBpc0Ryb3AgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCd1aUV2ZW50JykgPT09ICdkcm9wJyAmJiAhaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yXG5cbiAgICAgICAgaWYgKCFpc1Bhc3RlICYmICFpc0Ryb3ApIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0b3AgaWYgdGhlcmUgaXMgbm8gY2hhbmdlZCByYW5nZVxuICAgICAgICBjb25zdCBmcm9tID0gb2xkU3RhdGUuZG9jLmNvbnRlbnQuZmluZERpZmZTdGFydChzdGF0ZS5kb2MuY29udGVudClcbiAgICAgICAgY29uc3QgdG8gPSBvbGRTdGF0ZS5kb2MuY29udGVudC5maW5kRGlmZkVuZChzdGF0ZS5kb2MuY29udGVudClcblxuICAgICAgICBpZiAoIWlzTnVtYmVyKGZyb20pIHx8ICF0byB8fCBmcm9tID09PSB0by5iKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBidWlsZCBhIGNoYWluYWJsZSBzdGF0ZVxuICAgICAgICAvLyBzbyB3ZSBjYW4gdXNlIGEgc2luZ2xlIHRyYW5zYWN0aW9uIGZvciBhbGwgcGFzdGUgcnVsZXNcbiAgICAgICAgY29uc3QgdHIgPSBzdGF0ZS50clxuICAgICAgICBjb25zdCBjaGFpbmFibGVTdGF0ZSA9IGNyZWF0ZUNoYWluYWJsZVN0YXRlKHtcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHJ1bih7XG4gICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgIHN0YXRlOiBjaGFpbmFibGVTdGF0ZSxcbiAgICAgICAgICBmcm9tOiBNYXRoLm1heChmcm9tIC0gMSwgMCksXG4gICAgICAgICAgdG86IHRvLmIgLSAxLFxuICAgICAgICAgIHJ1bGUsXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gc3RvcCBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlc1xuICAgICAgICBpZiAoIWhhbmRsZXIgfHwgIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyXG4gICAgICB9LFxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHBsdWdpbnNcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZmluZER1cGxpY2F0ZXMoaXRlbXM6IGFueVtdKTogYW55W10ge1xuICBjb25zdCBmaWx0ZXJlZCA9IGl0ZW1zLmZpbHRlcigoZWwsIGluZGV4KSA9PiBpdGVtcy5pbmRleE9mKGVsKSAhPT0gaW5kZXgpXG5cbiAgcmV0dXJuIFsuLi5uZXcgU2V0KGZpbHRlcmVkKV1cbn1cbiIsICJpbXBvcnQgeyBrZXltYXAgfSBmcm9tICdAdGlwdGFwL3BtL2tleW1hcCdcbmltcG9ydCB7IE5vZGUgYXMgUHJvc2VtaXJyb3JOb2RlLCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IERlY29yYXRpb24sIEVkaXRvclZpZXcgfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnXG5cbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zIH0gZnJvbSAnLi9oZWxwZXJzL2dldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucy5qcydcbmltcG9ydCB7IGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSAnLi9oZWxwZXJzL2dldEV4dGVuc2lvbkZpZWxkLmpzJ1xuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMgfSBmcm9tICcuL2hlbHBlcnMvZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzLmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMgfSBmcm9tICcuL2hlbHBlcnMvZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFUeXBlQnlOYW1lIH0gZnJvbSAnLi9oZWxwZXJzL2dldFNjaGVtYVR5cGVCeU5hbWUuanMnXG5pbXBvcnQgeyBpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZCB9IGZyb20gJy4vaGVscGVycy9pc0V4dGVuc2lvblJ1bGVzRW5hYmxlZC5qcydcbmltcG9ydCB7IHNwbGl0RXh0ZW5zaW9ucyB9IGZyb20gJy4vaGVscGVycy9zcGxpdEV4dGVuc2lvbnMuanMnXG5pbXBvcnQgeyBNYXJrLCBOb2RlQ29uZmlnIH0gZnJvbSAnLi9pbmRleC5qcydcbmltcG9ydCB7IGlucHV0UnVsZXNQbHVnaW4gfSBmcm9tICcuL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IHBhc3RlUnVsZXNQbHVnaW4gfSBmcm9tICcuL1Bhc3RlUnVsZS5qcydcbmltcG9ydCB7IEFueUNvbmZpZywgRXh0ZW5zaW9ucywgUmF3Q29tbWFuZHMgfSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuaW1wb3J0IHsgZmluZER1cGxpY2F0ZXMgfSBmcm9tICcuL3V0aWxpdGllcy9maW5kRHVwbGljYXRlcy5qcydcblxuZXhwb3J0IGNsYXNzIEV4dGVuc2lvbk1hbmFnZXIge1xuICBlZGl0b3I6IEVkaXRvclxuXG4gIHNjaGVtYTogU2NoZW1hXG5cbiAgZXh0ZW5zaW9uczogRXh0ZW5zaW9uc1xuXG4gIHNwbGl0dGFibGVNYXJrczogc3RyaW5nW10gPSBbXVxuXG4gIGNvbnN0cnVjdG9yKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMsIGVkaXRvcjogRWRpdG9yKSB7XG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSBFeHRlbnNpb25NYW5hZ2VyLnJlc29sdmUoZXh0ZW5zaW9ucylcbiAgICB0aGlzLnNjaGVtYSA9IGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucywgZWRpdG9yKVxuXG4gICAgdGhpcy5leHRlbnNpb25zLmZvckVhY2goZXh0ZW5zaW9uID0+IHtcbiAgICAgIC8vIHN0b3JlIGV4dGVuc2lvbiBzdG9yYWdlIGluIGVkaXRvclxuICAgICAgdGhpcy5lZGl0b3IuZXh0ZW5zaW9uU3RvcmFnZVtleHRlbnNpb24ubmFtZV0gPSBleHRlbnNpb24uc3RvcmFnZVxuXG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXG4gICAgICB9XG5cbiAgICAgIGlmIChleHRlbnNpb24udHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgICAgIGNvbnN0IGtlZXBPblNwbGl0ID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2tlZXBPblNwbGl0JywgY29udGV4dCkpID8/IHRydWVcblxuICAgICAgICBpZiAoa2VlcE9uU3BsaXQpIHtcbiAgICAgICAgICB0aGlzLnNwbGl0dGFibGVNYXJrcy5wdXNoKGV4dGVuc2lvbi5uYW1lKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uQmVmb3JlQ3JlYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvbkJlZm9yZUNyZWF0ZSddPihcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAnb25CZWZvcmVDcmVhdGUnLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuXG4gICAgICBpZiAob25CZWZvcmVDcmVhdGUpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2JlZm9yZUNyZWF0ZScsIG9uQmVmb3JlQ3JlYXRlKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvbkNyZWF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25DcmVhdGUnXT4oZXh0ZW5zaW9uLCAnb25DcmVhdGUnLCBjb250ZXh0KVxuXG4gICAgICBpZiAob25DcmVhdGUpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2NyZWF0ZScsIG9uQ3JlYXRlKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvblVwZGF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25VcGRhdGUnXT4oZXh0ZW5zaW9uLCAnb25VcGRhdGUnLCBjb250ZXh0KVxuXG4gICAgICBpZiAob25VcGRhdGUpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3VwZGF0ZScsIG9uVXBkYXRlKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvblNlbGVjdGlvblVwZGF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25TZWxlY3Rpb25VcGRhdGUnXT4oXG4gICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgJ29uU2VsZWN0aW9uVXBkYXRlJyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgIClcblxuICAgICAgaWYgKG9uU2VsZWN0aW9uVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdzZWxlY3Rpb25VcGRhdGUnLCBvblNlbGVjdGlvblVwZGF0ZSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25UcmFuc2FjdGlvbiA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25UcmFuc2FjdGlvbiddPihcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAnb25UcmFuc2FjdGlvbicsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApXG5cbiAgICAgIGlmIChvblRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCd0cmFuc2FjdGlvbicsIG9uVHJhbnNhY3Rpb24pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uRm9jdXMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ29uRm9jdXMnXT4oZXh0ZW5zaW9uLCAnb25Gb2N1cycsIGNvbnRleHQpXG5cbiAgICAgIGlmIChvbkZvY3VzKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdmb2N1cycsIG9uRm9jdXMpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uQmx1ciA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25CbHVyJ10+KGV4dGVuc2lvbiwgJ29uQmx1cicsIGNvbnRleHQpXG5cbiAgICAgIGlmIChvbkJsdXIpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2JsdXInLCBvbkJsdXIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uRGVzdHJveSA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25EZXN0cm95J10+KGV4dGVuc2lvbiwgJ29uRGVzdHJveScsIGNvbnRleHQpXG5cbiAgICAgIGlmIChvbkRlc3Ryb3kpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2Rlc3Ryb3knLCBvbkRlc3Ryb3kpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHN0YXRpYyByZXNvbHZlKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpOiBFeHRlbnNpb25zIHtcbiAgICBjb25zdCByZXNvbHZlZEV4dGVuc2lvbnMgPSBFeHRlbnNpb25NYW5hZ2VyLnNvcnQoRXh0ZW5zaW9uTWFuYWdlci5mbGF0dGVuKGV4dGVuc2lvbnMpKVxuICAgIGNvbnN0IGR1cGxpY2F0ZWROYW1lcyA9IGZpbmREdXBsaWNhdGVzKHJlc29sdmVkRXh0ZW5zaW9ucy5tYXAoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi5uYW1lKSlcblxuICAgIGlmIChkdXBsaWNhdGVkTmFtZXMubGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbdGlwdGFwIHdhcm5dOiBEdXBsaWNhdGUgZXh0ZW5zaW9uIG5hbWVzIGZvdW5kOiBbJHtkdXBsaWNhdGVkTmFtZXNcbiAgICAgICAgICAubWFwKGl0ZW0gPT4gYCcke2l0ZW19J2ApXG4gICAgICAgICAgLmpvaW4oJywgJyl9XS4gVGhpcyBjYW4gbGVhZCB0byBpc3N1ZXMuYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzb2x2ZWRFeHRlbnNpb25zXG4gIH1cblxuICBzdGF0aWMgZmxhdHRlbihleHRlbnNpb25zOiBFeHRlbnNpb25zKTogRXh0ZW5zaW9ucyB7XG4gICAgcmV0dXJuIChcbiAgICAgIGV4dGVuc2lvbnNcbiAgICAgICAgLm1hcChleHRlbnNpb24gPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgYWRkRXh0ZW5zaW9ucyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkRXh0ZW5zaW9ucyddPihcbiAgICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAgICdhZGRFeHRlbnNpb25zJyxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgaWYgKGFkZEV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLCAuLi50aGlzLmZsYXR0ZW4oYWRkRXh0ZW5zaW9ucygpKV1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uXG4gICAgICAgIH0pXG4gICAgICAgIC8vIGBJbmZpbml0eWAgd2lsbCBicmVhayBUeXBlU2NyaXB0IHNvIHdlIHNldCBhIG51bWJlciB0aGF0IGlzIHByb2JhYmx5IGhpZ2ggZW5vdWdoXG4gICAgICAgIC5mbGF0KDEwKVxuICAgIClcbiAgfVxuXG4gIHN0YXRpYyBzb3J0KGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpOiBFeHRlbnNpb25zIHtcbiAgICBjb25zdCBkZWZhdWx0UHJpb3JpdHkgPSAxMDBcblxuICAgIHJldHVybiBleHRlbnNpb25zLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IHByaW9yaXR5QSA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1sncHJpb3JpdHknXT4oYSwgJ3ByaW9yaXR5JykgfHwgZGVmYXVsdFByaW9yaXR5XG4gICAgICBjb25zdCBwcmlvcml0eUIgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ3ByaW9yaXR5J10+KGIsICdwcmlvcml0eScpIHx8IGRlZmF1bHRQcmlvcml0eVxuXG4gICAgICBpZiAocHJpb3JpdHlBID4gcHJpb3JpdHlCKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuXG4gICAgICBpZiAocHJpb3JpdHlBIDwgcHJpb3JpdHlCKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwXG4gICAgfSlcbiAgfVxuXG4gIGdldCBjb21tYW5kcygpOiBSYXdDb21tYW5kcyB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5yZWR1Y2UoKGNvbW1hbmRzLCBleHRlbnNpb24pID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgIHR5cGU6IGdldFNjaGVtYVR5cGVCeU5hbWUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKSxcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWRkQ29tbWFuZHMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZENvbW1hbmRzJ10+KFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICdhZGRDb21tYW5kcycsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApXG5cbiAgICAgIGlmICghYWRkQ29tbWFuZHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmNvbW1hbmRzLFxuICAgICAgICAuLi5hZGRDb21tYW5kcygpLFxuICAgICAgfVxuICAgIH0sIHt9IGFzIFJhd0NvbW1hbmRzKVxuICB9XG5cbiAgZ2V0IHBsdWdpbnMoKTogUGx1Z2luW10ge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzXG5cbiAgICAvLyBXaXRoIFByb3NlTWlycm9yLCBmaXJzdCBwbHVnaW5zIHdpdGhpbiBhbiBhcnJheSBhcmUgZXhlY3V0ZWQgZmlyc3QuXG4gICAgLy8gSW4gVGlwdGFwLCB3ZSBwcm92aWRlIHRoZSBhYmlsaXR5IHRvIG92ZXJyaWRlIHBsdWdpbnMsXG4gICAgLy8gc28gaXQgZmVlbHMgbW9yZSBuYXR1cmFsIHRvIHJ1biBwbHVnaW5zIGF0IHRoZSBlbmQgb2YgYW4gYXJyYXkgZmlyc3QuXG4gICAgLy8gVGhhdOKAmXMgd2h5IHdlIGhhdmUgdG8gcmV2ZXJzZSB0aGUgYGV4dGVuc2lvbnNgIGFycmF5IGFuZCBzb3J0IGFnYWluXG4gICAgLy8gYmFzZWQgb24gdGhlIGBwcmlvcml0eWAgb3B0aW9uLlxuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBFeHRlbnNpb25NYW5hZ2VyLnNvcnQoWy4uLnRoaXMuZXh0ZW5zaW9uc10ucmV2ZXJzZSgpKVxuXG4gICAgY29uc3QgaW5wdXRSdWxlczogYW55W10gPSBbXVxuICAgIGNvbnN0IHBhc3RlUnVsZXM6IGFueVtdID0gW11cblxuICAgIGNvbnN0IGFsbFBsdWdpbnMgPSBleHRlbnNpb25zXG4gICAgICAubWFwKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgIHR5cGU6IGdldFNjaGVtYVR5cGVCeU5hbWUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKSxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBsdWdpbnM6IFBsdWdpbltdID0gW11cblxuICAgICAgICBjb25zdCBhZGRLZXlib2FyZFNob3J0Y3V0cyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkS2V5Ym9hcmRTaG9ydGN1dHMnXT4oXG4gICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICdhZGRLZXlib2FyZFNob3J0Y3V0cycsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgKVxuXG4gICAgICAgIGxldCBkZWZhdWx0QmluZGluZ3M6IFJlY29yZDxzdHJpbmcsICgpID0+IGJvb2xlYW4+ID0ge31cblxuICAgICAgICAvLyBiaW5kIGV4aXQgaGFuZGxpbmdcbiAgICAgICAgaWYgKGV4dGVuc2lvbi50eXBlID09PSAnbWFyaycgJiYgZXh0ZW5zaW9uLmNvbmZpZy5leGl0YWJsZSkge1xuICAgICAgICAgIGRlZmF1bHRCaW5kaW5ncy5BcnJvd1JpZ2h0ID0gKCkgPT4gTWFyay5oYW5kbGVFeGl0KHsgZWRpdG9yLCBtYXJrOiBleHRlbnNpb24gYXMgTWFyayB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFkZEtleWJvYXJkU2hvcnRjdXRzKSB7XG4gICAgICAgICAgY29uc3QgYmluZGluZ3MgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhhZGRLZXlib2FyZFNob3J0Y3V0cygpKS5tYXAoKFtzaG9ydGN1dCwgbWV0aG9kXSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gW3Nob3J0Y3V0LCAoKSA9PiBtZXRob2QoeyBlZGl0b3IgfSldXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApXG5cbiAgICAgICAgICBkZWZhdWx0QmluZGluZ3MgPSB7IC4uLmRlZmF1bHRCaW5kaW5ncywgLi4uYmluZGluZ3MgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qga2V5TWFwUGx1Z2luID0ga2V5bWFwKGRlZmF1bHRCaW5kaW5ncylcblxuICAgICAgICBwbHVnaW5zLnB1c2goa2V5TWFwUGx1Z2luKVxuXG4gICAgICAgIGNvbnN0IGFkZElucHV0UnVsZXMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZElucHV0UnVsZXMnXT4oXG4gICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICdhZGRJbnB1dFJ1bGVzJyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkKGV4dGVuc2lvbiwgZWRpdG9yLm9wdGlvbnMuZW5hYmxlSW5wdXRSdWxlcykgJiYgYWRkSW5wdXRSdWxlcykge1xuICAgICAgICAgIGlucHV0UnVsZXMucHVzaCguLi5hZGRJbnB1dFJ1bGVzKCkpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhZGRQYXN0ZVJ1bGVzID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRQYXN0ZVJ1bGVzJ10+KFxuICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAnYWRkUGFzdGVSdWxlcycsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZChleHRlbnNpb24sIGVkaXRvci5vcHRpb25zLmVuYWJsZVBhc3RlUnVsZXMpICYmIGFkZFBhc3RlUnVsZXMpIHtcbiAgICAgICAgICBwYXN0ZVJ1bGVzLnB1c2goLi4uYWRkUGFzdGVSdWxlcygpKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWRkUHJvc2VNaXJyb3JQbHVnaW5zID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRQcm9zZU1pcnJvclBsdWdpbnMnXT4oXG4gICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICdhZGRQcm9zZU1pcnJvclBsdWdpbnMnLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIClcblxuICAgICAgICBpZiAoYWRkUHJvc2VNaXJyb3JQbHVnaW5zKSB7XG4gICAgICAgICAgY29uc3QgcHJvc2VNaXJyb3JQbHVnaW5zID0gYWRkUHJvc2VNaXJyb3JQbHVnaW5zKClcblxuICAgICAgICAgIHBsdWdpbnMucHVzaCguLi5wcm9zZU1pcnJvclBsdWdpbnMpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGx1Z2luc1xuICAgICAgfSlcbiAgICAgIC5mbGF0KClcblxuICAgIHJldHVybiBbXG4gICAgICBpbnB1dFJ1bGVzUGx1Z2luKHtcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICBydWxlczogaW5wdXRSdWxlcyxcbiAgICAgIH0pLFxuICAgICAgLi4ucGFzdGVSdWxlc1BsdWdpbih7XG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgcnVsZXM6IHBhc3RlUnVsZXMsXG4gICAgICB9KSxcbiAgICAgIC4uLmFsbFBsdWdpbnMsXG4gICAgXVxuICB9XG5cbiAgZ2V0IGF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyh0aGlzLmV4dGVuc2lvbnMpXG4gIH1cblxuICBnZXQgbm9kZVZpZXdzKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzXG4gICAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucylcblxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBub2RlRXh0ZW5zaW9uc1xuICAgICAgICAuZmlsdGVyKGV4dGVuc2lvbiA9PiAhIWdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZE5vZGVWaWV3JykpXG4gICAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLmZpbHRlcihcbiAgICAgICAgICAgIGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICB0eXBlOiBnZXROb2RlVHlwZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhZGROb2RlVmlldyA9IGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2FkZE5vZGVWaWV3J10+KFxuICAgICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICAgJ2FkZE5vZGVWaWV3JyxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgaWYgKCFhZGROb2RlVmlldykge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgbm9kZXZpZXcgPSAoXG4gICAgICAgICAgICBub2RlOiBQcm9zZW1pcnJvck5vZGUsXG4gICAgICAgICAgICB2aWV3OiBFZGl0b3JWaWV3LFxuICAgICAgICAgICAgZ2V0UG9zOiAoKCkgPT4gbnVtYmVyKSB8IGJvb2xlYW4sXG4gICAgICAgICAgICBkZWNvcmF0aW9uczogRGVjb3JhdGlvbltdLFxuICAgICAgICAgICkgPT4ge1xuICAgICAgICAgICAgY29uc3QgSFRNTEF0dHJpYnV0ZXMgPSBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobm9kZSwgZXh0ZW5zaW9uQXR0cmlidXRlcylcblxuICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVWaWV3KCkoe1xuICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIGdldFBvcyxcbiAgICAgICAgICAgICAgZGVjb3JhdGlvbnMsXG4gICAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIG5vZGV2aWV3XVxuICAgICAgICB9KSxcbiAgICApXG4gIH1cbn1cbiIsICIvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tZXNxdWVlYi9pcy13aGF0L2Jsb2IvODhkNmU0Y2E5MmZiMmJhYWI2MDAzYzU0ZTAyZWVkZjRlNzI5ZTVhYi9zcmMvaW5kZXgudHNcblxuZnVuY3Rpb24gZ2V0VHlwZSh2YWx1ZTogYW55KTogc3RyaW5nIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgaWYgKGdldFR5cGUodmFsdWUpICE9PSAnT2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gT2JqZWN0LnByb3RvdHlwZVxufVxuIiwgImltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICcuL2lzUGxhaW5PYmplY3QuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZURlZXAodGFyZ2V0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBzb3VyY2U6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgY29uc3Qgb3V0cHV0ID0geyAuLi50YXJnZXQgfVxuXG4gIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKG91dHB1dCwgeyBba2V5XTogc291cmNlW2tleV0gfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXRba2V5XSA9IG1lcmdlRGVlcCh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3V0cHV0LCB7IFtrZXldOiBzb3VyY2Vba2V5XSB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gb3V0cHV0XG59XG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgZ2V0RXh0ZW5zaW9uRmllbGQgfSBmcm9tICcuL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBFeHRlbnNpb25Db25maWcgfSBmcm9tICcuL2luZGV4LmpzJ1xuaW1wb3J0IHsgSW5wdXRSdWxlIH0gZnJvbSAnLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgeyBNYXJrIH0gZnJvbSAnLi9NYXJrLmpzJ1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4vTm9kZS5qcydcbmltcG9ydCB7IFBhc3RlUnVsZSB9IGZyb20gJy4vUGFzdGVSdWxlLmpzJ1xuaW1wb3J0IHtcbiAgQW55Q29uZmlnLFxuICBFeHRlbnNpb25zLFxuICBHbG9iYWxBdHRyaWJ1dGVzLFxuICBLZXlib2FyZFNob3J0Y3V0Q29tbWFuZCxcbiAgUGFyZW50Q29uZmlnLFxuICBSYXdDb21tYW5kcyxcbn0gZnJvbSAnLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcbmltcG9ydCB7IG1lcmdlRGVlcCB9IGZyb20gJy4vdXRpbGl0aWVzL21lcmdlRGVlcC5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgRXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMgPSBhbnksIFN0b3JhZ2UgPSBhbnk+IHtcbiAgICBba2V5OiBzdHJpbmddOiBhbnlcblxuICAgIC8qKlxuICAgICAqIE5hbWVcbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmdcblxuICAgIC8qKlxuICAgICAqIFByaW9yaXR5XG4gICAgICovXG4gICAgcHJpb3JpdHk/OiBudW1iZXJcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgb3B0aW9uc1xuICAgICAqL1xuICAgIGRlZmF1bHRPcHRpb25zPzogT3B0aW9uc1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBPcHRpb25zXG4gICAgICovXG4gICAgYWRkT3B0aW9ucz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIHBhcmVudDogRXhjbHVkZTxQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkT3B0aW9ucyddLCB1bmRlZmluZWQ+XG4gICAgfSkgPT4gT3B0aW9uc1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBTdG9yYWdlXG4gICAgICovXG4gICAgYWRkU3RvcmFnZT86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHBhcmVudDogRXhjbHVkZTxQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkU3RvcmFnZSddLCB1bmRlZmluZWQ+XG4gICAgfSkgPT4gU3RvcmFnZVxuXG4gICAgLyoqXG4gICAgICogR2xvYmFsIGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBhZGRHbG9iYWxBdHRyaWJ1dGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkR2xvYmFsQXR0cmlidXRlcyddXG4gICAgfSkgPT4gR2xvYmFsQXR0cmlidXRlcyB8IHt9XG5cbiAgICAvKipcbiAgICAgKiBSYXdcbiAgICAgKi9cbiAgICBhZGRDb21tYW5kcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRDb21tYW5kcyddXG4gICAgfSkgPT4gUGFydGlhbDxSYXdDb21tYW5kcz5cblxuICAgIC8qKlxuICAgICAqIEtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAqL1xuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEtleWJvYXJkU2hvcnRjdXRzJ11cbiAgICB9KSA9PiB7XG4gICAgICBba2V5OiBzdHJpbmddOiBLZXlib2FyZFNob3J0Y3V0Q29tbWFuZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElucHV0IHJ1bGVzXG4gICAgICovXG4gICAgYWRkSW5wdXRSdWxlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRJbnB1dFJ1bGVzJ11cbiAgICB9KSA9PiBJbnB1dFJ1bGVbXVxuXG4gICAgLyoqXG4gICAgICogUGFzdGUgcnVsZXNcbiAgICAgKi9cbiAgICBhZGRQYXN0ZVJ1bGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFBhc3RlUnVsZXMnXVxuICAgIH0pID0+IFBhc3RlUnVsZVtdXG5cbiAgICAvKipcbiAgICAgKiBQcm9zZU1pcnJvciBwbHVnaW5zXG4gICAgICovXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFByb3NlTWlycm9yUGx1Z2lucyddXG4gICAgfSkgPT4gUGx1Z2luW11cblxuICAgIC8qKlxuICAgICAqIEV4dGVuc2lvbnNcbiAgICAgKi9cbiAgICBhZGRFeHRlbnNpb25zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkRXh0ZW5zaW9ucyddXG4gICAgfSkgPT4gRXh0ZW5zaW9uc1xuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIE5vZGUgU2NoZW1hXG4gICAgICovXG4gICAgZXh0ZW5kTm9kZVNjaGVtYT86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydleHRlbmROb2RlU2NoZW1hJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4dGVuc2lvbjogTm9kZSxcbiAgICAgICAgKSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgTWFyayBTY2hlbWFcbiAgICAgKi9cbiAgICBleHRlbmRNYXJrU2NoZW1hPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4dGVuZE1hcmtTY2hlbWEnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXh0ZW5zaW9uOiBNYXJrLFxuICAgICAgICApID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgbm90IHJlYWR5IHlldC5cbiAgICAgKi9cbiAgICBvbkJlZm9yZUNyZWF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkJlZm9yZUNyZWF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgcmVhZHkuXG4gICAgICovXG4gICAgb25DcmVhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25DcmVhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGVudCBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblVwZGF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblVwZGF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3Rpb24gaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25TZWxlY3Rpb25VcGRhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25TZWxlY3Rpb25VcGRhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIHN0YXRlIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uVHJhbnNhY3Rpb24/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uVHJhbnNhY3Rpb24nXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBmb2N1c2VkLlxuICAgICAqL1xuICAgIG9uRm9jdXM/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uRm9jdXMnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGV2ZW50OiBGb2N1c0V2ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzbuKAmXQgZm9jdXNlZCBhbnltb3JlLlxuICAgICAqL1xuICAgIG9uQmx1cj86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25CbHVyJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBldmVudDogRm9jdXNFdmVudFxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgb25EZXN0cm95PzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uRGVzdHJveSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRXh0ZW5zaW9uPE9wdGlvbnMgPSBhbnksIFN0b3JhZ2UgPSBhbnk+IHtcbiAgdHlwZSA9ICdleHRlbnNpb24nXG5cbiAgbmFtZSA9ICdleHRlbnNpb24nXG5cbiAgcGFyZW50OiBFeHRlbnNpb24gfCBudWxsID0gbnVsbFxuXG4gIGNoaWxkOiBFeHRlbnNpb24gfCBudWxsID0gbnVsbFxuXG4gIG9wdGlvbnM6IE9wdGlvbnNcblxuICBzdG9yYWdlOiBTdG9yYWdlXG5cbiAgY29uZmlnOiBFeHRlbnNpb25Db25maWcgPSB7XG4gICAgbmFtZTogdGhpcy5uYW1lLFxuICAgIGRlZmF1bHRPcHRpb25zOiB7fSxcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogUGFydGlhbDxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+ID0ge30pIHtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgLi4uY29uZmlnLFxuICAgIH1cblxuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uZmlnLm5hbWVcblxuICAgIGlmIChjb25maWcuZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7dGhpcy5uYW1lfVwiLmAsXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGBhZGRPcHRpb25zYCBmYWxsYmFja1xuICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuY29uZmlnLmRlZmF1bHRPcHRpb25zXG5cbiAgICBpZiAodGhpcy5jb25maWcuYWRkT3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gY2FsbE9yUmV0dXJuKFxuICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZE9wdGlvbnMnXT4odGhpcywgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4odGhpcywgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKSB8fCB7fVxuICB9XG5cbiAgc3RhdGljIGNyZWF0ZTxPID0gYW55LCBTID0gYW55Pihjb25maWc6IFBhcnRpYWw8RXh0ZW5zaW9uQ29uZmlnPE8sIFM+PiA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBFeHRlbnNpb248TywgUz4oY29uZmlnKVxuICB9XG5cbiAgY29uZmlndXJlKG9wdGlvbnM6IFBhcnRpYWw8T3B0aW9ucz4gPSB7fSkge1xuICAgIC8vIHJldHVybiBhIG5ldyBpbnN0YW5jZSBzbyB3ZSBjYW4gdXNlIHRoZSBzYW1lIGV4dGVuc2lvblxuICAgIC8vIHdpdGggZGlmZmVyZW50IGNhbGxzIG9mIGBjb25maWd1cmVgXG4gICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5leHRlbmQoKVxuXG4gICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBtZXJnZURlZXAodGhpcy5vcHRpb25zIGFzIFJlY29yZDxzdHJpbmcsIGFueT4sIG9wdGlvbnMpIGFzIE9wdGlvbnNcblxuICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRTdG9yYWdlJ10+KGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIH0pLFxuICAgIClcblxuICAgIHJldHVybiBleHRlbnNpb25cbiAgfVxuXG4gIGV4dGVuZDxFeHRlbmRlZE9wdGlvbnMgPSBPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2UgPSBTdG9yYWdlPihcbiAgICBleHRlbmRlZENvbmZpZzogUGFydGlhbDxFeHRlbnNpb25Db25maWc8RXh0ZW5kZWRPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2U+PiA9IHt9LFxuICApIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSBuZXcgRXh0ZW5zaW9uPEV4dGVuZGVkT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlPihleHRlbmRlZENvbmZpZylcblxuICAgIGV4dGVuc2lvbi5wYXJlbnQgPSB0aGlzXG5cbiAgICB0aGlzLmNoaWxkID0gZXh0ZW5zaW9uXG5cbiAgICBleHRlbnNpb24ubmFtZSA9IGV4dGVuZGVkQ29uZmlnLm5hbWUgPyBleHRlbmRlZENvbmZpZy5uYW1lIDogZXh0ZW5zaW9uLnBhcmVudC5uYW1lXG5cbiAgICBpZiAoZXh0ZW5kZWRDb25maWcuZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7ZXh0ZW5zaW9uLm5hbWV9XCIuYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICBleHRlbnNpb24ub3B0aW9ucyA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkT3B0aW9ucyddPihleHRlbnNpb24sICdhZGRPcHRpb25zJywge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIH0pLFxuICAgIClcblxuICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRTdG9yYWdlJ10+KGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIH0pLFxuICAgIClcblxuICAgIHJldHVybiBleHRlbnNpb25cbiAgfVxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgUmFuZ2UsIFRleHRTZXJpYWxpemVyIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXh0QmV0d2VlbihcbiAgc3RhcnROb2RlOiBQcm9zZU1pcnJvck5vZGUsXG4gIHJhbmdlOiBSYW5nZSxcbiAgb3B0aW9ucz86IHtcbiAgICBibG9ja1NlcGFyYXRvcj86IHN0cmluZ1xuICAgIHRleHRTZXJpYWxpemVycz86IFJlY29yZDxzdHJpbmcsIFRleHRTZXJpYWxpemVyPlxuICB9LFxuKTogc3RyaW5nIHtcbiAgY29uc3QgeyBmcm9tLCB0byB9ID0gcmFuZ2VcbiAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9ICdcXG5cXG4nLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fVxuICBsZXQgdGV4dCA9ICcnXG4gIGxldCBzZXBhcmF0ZWQgPSB0cnVlXG5cbiAgc3RhcnROb2RlLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcywgcGFyZW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHRleHRTZXJpYWxpemVyID0gdGV4dFNlcmlhbGl6ZXJzPy5bbm9kZS50eXBlLm5hbWVdXG5cbiAgICBpZiAodGV4dFNlcmlhbGl6ZXIpIHtcbiAgICAgIGlmIChub2RlLmlzQmxvY2sgJiYgIXNlcGFyYXRlZCkge1xuICAgICAgICB0ZXh0ICs9IGJsb2NrU2VwYXJhdG9yXG4gICAgICAgIHNlcGFyYXRlZCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICB0ZXh0ICs9IHRleHRTZXJpYWxpemVyKHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIHBvcyxcbiAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgcmFuZ2UsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgdGV4dCArPSBub2RlPy50ZXh0Py5zbGljZShNYXRoLm1heChmcm9tLCBwb3MpIC0gcG9zLCB0byAtIHBvcykgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgc2VwYXJhdGVkID0gZmFsc2VcbiAgICB9IGVsc2UgaWYgKG5vZGUuaXNCbG9jayAmJiAhc2VwYXJhdGVkKSB7XG4gICAgICB0ZXh0ICs9IGJsb2NrU2VwYXJhdG9yXG4gICAgICBzZXBhcmF0ZWQgPSB0cnVlXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiB0ZXh0XG59XG4iLCAiaW1wb3J0IHsgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgVGV4dFNlcmlhbGl6ZXIgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hOiBTY2hlbWEpOiBSZWNvcmQ8c3RyaW5nLCBUZXh0U2VyaWFsaXplcj4ge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5ub2RlcylcbiAgICAgIC5maWx0ZXIoKFssIG5vZGVdKSA9PiBub2RlLnNwZWMudG9UZXh0KVxuICAgICAgLm1hcCgoW25hbWUsIG5vZGVdKSA9PiBbbmFtZSwgbm9kZS5zcGVjLnRvVGV4dF0pLFxuICApXG59XG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5pbXBvcnQgeyBnZXRUZXh0QmV0d2VlbiB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0VGV4dEJldHdlZW4uanMnXG5pbXBvcnQgeyBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hIH0gZnJvbSAnLi4vaGVscGVycy9nZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hLmpzJ1xuXG5leHBvcnQgY29uc3QgQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogJ2NsaXBib2FyZFRleHRTZXJpYWxpemVyJyxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2NsaXBib2FyZFRleHRTZXJpYWxpemVyJyksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXI6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzXG4gICAgICAgICAgICBjb25zdCB7IHN0YXRlLCBzY2hlbWEgfSA9IGVkaXRvclxuICAgICAgICAgICAgY29uc3QgeyBkb2MsIHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBNYXRoLm1pbiguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiRmcm9tLnBvcykpXG4gICAgICAgICAgICBjb25zdCB0byA9IE1hdGgubWF4KC4uLnJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuJHRvLnBvcykpXG4gICAgICAgICAgICBjb25zdCB0ZXh0U2VyaWFsaXplcnMgPSBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hKHNjaGVtYSlcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0geyBmcm9tLCB0byB9XG5cbiAgICAgICAgICAgIHJldHVybiBnZXRUZXh0QmV0d2Vlbihkb2MsIHJhbmdlLCB7XG4gICAgICAgICAgICAgIHRleHRTZXJpYWxpemVycyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGJsdXI6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBmb2N1cyBmcm9tIHRoZSBlZGl0b3IuXG4gICAgICAgKi9cbiAgICAgIGJsdXI6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBibHVyOiBSYXdDb21tYW5kc1snYmx1ciddID0gKCkgPT4gKHsgZWRpdG9yLCB2aWV3IH0pID0+IHtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICBpZiAoIWVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgKHZpZXcuZG9tIGFzIEhUTUxFbGVtZW50KS5ibHVyKClcblxuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIHJlbW92ZSB0aGUgY2FyZXQgb24gYmx1ciBidXQgc2FmYXJpIGRvZXMgbm90LlxuICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzI0MDVcbiAgICAgIHdpbmRvdz8uZ2V0U2VsZWN0aW9uKCk/LnJlbW92ZUFsbFJhbmdlcygpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGNsZWFyQ29udGVudDoge1xuICAgICAgLyoqXG4gICAgICAgKiBDbGVhciB0aGUgd2hvbGUgZG9jdW1lbnQuXG4gICAgICAgKi9cbiAgICAgIGNsZWFyQ29udGVudDogKGVtaXRVcGRhdGU/OiBib29sZWFuKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY2xlYXJDb250ZW50OiBSYXdDb21tYW5kc1snY2xlYXJDb250ZW50J10gPSAoZW1pdFVwZGF0ZSA9IGZhbHNlKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gIHJldHVybiBjb21tYW5kcy5zZXRDb250ZW50KCcnLCBlbWl0VXBkYXRlKVxufVxuIiwgImltcG9ydCB7IGxpZnRUYXJnZXQgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGNsZWFyTm9kZXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogTm9ybWFsaXplIG5vZGVzIHRvIGEgc2ltcGxlIHBhcmFncmFwaC5cbiAgICAgICAqL1xuICAgICAgY2xlYXJOb2RlczogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFyTm9kZXM6IFJhd0NvbW1hbmRzWydjbGVhck5vZGVzJ10gPSAoKSA9PiAoeyBzdGF0ZSwgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyXG4gIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb25cblxuICBpZiAoIWRpc3BhdGNoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJhbmdlcy5mb3JFYWNoKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICBpZiAobm9kZS50eXBlLmlzVGV4dCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBkb2MsIG1hcHBpbmcgfSA9IHRyXG4gICAgICBjb25zdCAkbWFwcGVkRnJvbSA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHBvcykpXG4gICAgICBjb25zdCAkbWFwcGVkVG8gPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcChwb3MgKyBub2RlLm5vZGVTaXplKSlcbiAgICAgIGNvbnN0IG5vZGVSYW5nZSA9ICRtYXBwZWRGcm9tLmJsb2NrUmFuZ2UoJG1hcHBlZFRvKVxuXG4gICAgICBpZiAoIW5vZGVSYW5nZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFyZ2V0TGlmdERlcHRoID0gbGlmdFRhcmdldChub2RlUmFuZ2UpXG5cbiAgICAgIGlmIChub2RlLnR5cGUuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0VHlwZSB9ID0gJG1hcHBlZEZyb20ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCRtYXBwZWRGcm9tLmluZGV4KCkpXG5cbiAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChub2RlUmFuZ2Uuc3RhcnQsIGRlZmF1bHRUeXBlKVxuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0TGlmdERlcHRoIHx8IHRhcmdldExpZnREZXB0aCA9PT0gMCkge1xuICAgICAgICB0ci5saWZ0KG5vZGVSYW5nZSwgdGFyZ2V0TGlmdERlcHRoKVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBDb21tYW5kLCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgY29tbWFuZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBEZWZpbmUgYSBjb21tYW5kIGlubGluZS5cbiAgICAgICAqL1xuICAgICAgY29tbWFuZDogKGZuOiAocHJvcHM6IFBhcmFtZXRlcnM8Q29tbWFuZD5bMF0pID0+IGJvb2xlYW4pID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjb21tYW5kOiBSYXdDb21tYW5kc1snY29tbWFuZCddID0gZm4gPT4gcHJvcHMgPT4ge1xuICByZXR1cm4gZm4ocHJvcHMpXG59XG4iLCAiaW1wb3J0IHsgY3JlYXRlUGFyYWdyYXBoTmVhciBhcyBvcmlnaW5hbENyZWF0ZVBhcmFncmFwaE5lYXIgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgY3JlYXRlUGFyYWdyYXBoTmVhcjoge1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgYSBwYXJhZ3JhcGggbmVhcmJ5LlxuICAgICAgICovXG4gICAgICBjcmVhdGVQYXJhZ3JhcGhOZWFyOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQYXJhZ3JhcGhOZWFyOiBSYXdDb21tYW5kc1snY3JlYXRlUGFyYWdyYXBoTmVhciddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsQ3JlYXRlUGFyYWdyYXBoTmVhcihzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBjdXQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogQ3V0cyBjb250ZW50IGZyb20gYSByYW5nZSBhbmQgaW5zZXJ0cyBpdCBhdCBhIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgICovXG4gICAgICBjdXQ6ICh7IGZyb20sIHRvIH06IHsgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyIH0sIHRhcmdldFBvczogbnVtYmVyKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY3V0OiBSYXdDb21tYW5kc1snY3V0J10gPSAob3JpZ2luUmFuZ2UsIHRhcmdldFBvcykgPT4gKHsgZWRpdG9yLCB0ciB9KSA9PiB7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvclxuXG4gIGNvbnN0IGNvbnRlbnRTbGljZSA9IHN0YXRlLmRvYy5zbGljZShvcmlnaW5SYW5nZS5mcm9tLCBvcmlnaW5SYW5nZS50bylcblxuICB0ci5kZWxldGVSYW5nZShvcmlnaW5SYW5nZS5mcm9tLCBvcmlnaW5SYW5nZS50bylcbiAgY29uc3QgbmV3UG9zID0gdHIubWFwcGluZy5tYXAodGFyZ2V0UG9zKVxuXG4gIHRyLmluc2VydChuZXdQb3MsIGNvbnRlbnRTbGljZS5jb250ZW50KVxuXG4gIHRyLnNldFNlbGVjdGlvbihuZXcgVGV4dFNlbGVjdGlvbih0ci5kb2MucmVzb2x2ZShuZXdQb3MgLSAxKSkpXG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZGVsZXRlQ3VycmVudE5vZGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogRGVsZXRlIHRoZSBub2RlIHRoYXQgY3VycmVudGx5IGhhcyB0aGUgc2VsZWN0aW9uIGFuY2hvci5cbiAgICAgICAqL1xuICAgICAgZGVsZXRlQ3VycmVudE5vZGU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWxldGVDdXJyZW50Tm9kZTogUmF3Q29tbWFuZHNbJ2RlbGV0ZUN1cnJlbnROb2RlJ10gPSAoKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHJcbiAgY29uc3QgY3VycmVudE5vZGUgPSBzZWxlY3Rpb24uJGFuY2hvci5ub2RlKClcblxuICAvLyBpZiB0aGVyZSBpcyBjb250ZW50IGluc2lkZSB0aGUgY3VycmVudCBub2RlLCBicmVhayBvdXQgb2YgdGhpcyBjb21tYW5kXG4gIGlmIChjdXJyZW50Tm9kZS5jb250ZW50LnNpemUgPiAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCAkcG9zID0gdHIuc2VsZWN0aW9uLiRhbmNob3JcblxuICBmb3IgKGxldCBkZXB0aCA9ICRwb3MuZGVwdGg7IGRlcHRoID4gMDsgZGVwdGggLT0gMSkge1xuICAgIGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoZGVwdGgpXG5cbiAgICBpZiAobm9kZS50eXBlID09PSBjdXJyZW50Tm9kZS50eXBlKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgZnJvbSA9ICRwb3MuYmVmb3JlKGRlcHRoKVxuICAgICAgICBjb25zdCB0byA9ICRwb3MuYWZ0ZXIoZGVwdGgpXG5cbiAgICAgICAgdHIuZGVsZXRlKGZyb20sIHRvKS5zY3JvbGxJbnRvVmlldygpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZGVsZXRlTm9kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBEZWxldGUgYSBub2RlLlxuICAgICAgICovXG4gICAgICBkZWxldGVOb2RlOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWxldGVOb2RlOiBSYXdDb21tYW5kc1snZGVsZXRlTm9kZSddID0gdHlwZU9yTmFtZSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgJHBvcyA9IHRyLnNlbGVjdGlvbi4kYW5jaG9yXG5cbiAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoIC09IDEpIHtcbiAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGRlcHRoKVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gdHlwZSkge1xuICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSAkcG9zLmJlZm9yZShkZXB0aClcbiAgICAgICAgY29uc3QgdG8gPSAkcG9zLmFmdGVyKGRlcHRoKVxuXG4gICAgICAgIHRyLmRlbGV0ZShmcm9tLCB0bykuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwgImltcG9ydCB7IFJhbmdlLCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZGVsZXRlUmFuZ2U6IHtcbiAgICAgIC8qKlxuICAgICAgICogRGVsZXRlIGEgZ2l2ZW4gcmFuZ2UuXG4gICAgICAgKi9cbiAgICAgIGRlbGV0ZVJhbmdlOiAocmFuZ2U6IFJhbmdlKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZGVsZXRlUmFuZ2U6IFJhd0NvbW1hbmRzWydkZWxldGVSYW5nZSddID0gcmFuZ2UgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBmcm9tLCB0byB9ID0gcmFuZ2VcblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5kZWxldGUoZnJvbSwgdG8pXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IGRlbGV0ZVNlbGVjdGlvbiBhcyBvcmlnaW5hbERlbGV0ZVNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBkZWxldGVTZWxlY3Rpb246IHtcbiAgICAgIC8qKlxuICAgICAgICogRGVsZXRlIHRoZSBzZWxlY3Rpb24sIGlmIHRoZXJlIGlzIG9uZS5cbiAgICAgICAqL1xuICAgICAgZGVsZXRlU2VsZWN0aW9uOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWxldGVTZWxlY3Rpb246IFJhd0NvbW1hbmRzWydkZWxldGVTZWxlY3Rpb24nXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbERlbGV0ZVNlbGVjdGlvbihzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGVudGVyOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRyaWdnZXIgZW50ZXIuXG4gICAgICAgKi9cbiAgICAgIGVudGVyOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZW50ZXI6IFJhd0NvbW1hbmRzWydlbnRlciddID0gKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICByZXR1cm4gY29tbWFuZHMua2V5Ym9hcmRTaG9ydGN1dCgnRW50ZXInKVxufVxuIiwgImltcG9ydCB7IGV4aXRDb2RlIGFzIG9yaWdpbmFsRXhpdENvZGUgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZXhpdENvZGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogRXhpdCBmcm9tIGEgY29kZSBibG9jay5cbiAgICAgICAqL1xuICAgICAgZXhpdENvZGU6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGV4aXRDb2RlOiBSYXdDb21tYW5kc1snZXhpdENvZGUnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbEV4aXRDb2RlKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBpc1JlZ0V4cCB9IGZyb20gJy4vaXNSZWdFeHAuanMnXG5cbi8qKlxuICogQ2hlY2sgaWYgb2JqZWN0MSBpbmNsdWRlcyBvYmplY3QyXG4gKiBAcGFyYW0gb2JqZWN0MSBPYmplY3RcbiAqIEBwYXJhbSBvYmplY3QyIE9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0SW5jbHVkZXMoXG4gIG9iamVjdDE6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIG9iamVjdDI6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIG9wdGlvbnM6IHsgc3RyaWN0OiBib29sZWFuIH0gPSB7IHN0cmljdDogdHJ1ZSB9LFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QyKVxuXG4gIGlmICgha2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGtleXMuZXZlcnkoa2V5ID0+IHtcbiAgICBpZiAob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QyW2tleV0gPT09IG9iamVjdDFba2V5XVxuICAgIH1cblxuICAgIGlmIChpc1JlZ0V4cChvYmplY3QyW2tleV0pKSB7XG4gICAgICByZXR1cm4gb2JqZWN0MltrZXldLnRlc3Qob2JqZWN0MVtrZXldKVxuICAgIH1cblxuICAgIHJldHVybiBvYmplY3QyW2tleV0gPT09IG9iamVjdDFba2V5XVxuICB9KVxufVxuIiwgImltcG9ydCB7IE1hcmsgYXMgUHJvc2VNaXJyb3JNYXJrLCBNYXJrVHlwZSwgUmVzb2x2ZWRQb3MgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgb2JqZWN0SW5jbHVkZXMgfSBmcm9tICcuLi91dGlsaXRpZXMvb2JqZWN0SW5jbHVkZXMuanMnXG5cbmZ1bmN0aW9uIGZpbmRNYXJrSW5TZXQoXG4gIG1hcmtzOiBQcm9zZU1pcnJvck1hcmtbXSxcbiAgdHlwZTogTWFya1R5cGUsXG4gIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSxcbik6IFByb3NlTWlycm9yTWFyayB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBtYXJrcy5maW5kKGl0ZW0gPT4ge1xuICAgIHJldHVybiBpdGVtLnR5cGUgPT09IHR5cGUgJiYgb2JqZWN0SW5jbHVkZXMoaXRlbS5hdHRycywgYXR0cmlidXRlcylcbiAgfSlcbn1cblxuZnVuY3Rpb24gaXNNYXJrSW5TZXQoXG4gIG1hcmtzOiBQcm9zZU1pcnJvck1hcmtbXSxcbiAgdHlwZTogTWFya1R5cGUsXG4gIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSxcbik6IGJvb2xlYW4ge1xuICByZXR1cm4gISFmaW5kTWFya0luU2V0KG1hcmtzLCB0eXBlLCBhdHRyaWJ1dGVzKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFya1JhbmdlKFxuICAkcG9zOiBSZXNvbHZlZFBvcyxcbiAgdHlwZTogTWFya1R5cGUsXG4gIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSxcbik6IFJhbmdlIHwgdm9pZCB7XG4gIGlmICghJHBvcyB8fCAhdHlwZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IHN0YXJ0ID0gJHBvcy5wYXJlbnQuY2hpbGRBZnRlcigkcG9zLnBhcmVudE9mZnNldClcblxuICBpZiAoJHBvcy5wYXJlbnRPZmZzZXQgPT09IHN0YXJ0Lm9mZnNldCAmJiBzdGFydC5vZmZzZXQgIT09IDApIHtcbiAgICBzdGFydCA9ICRwb3MucGFyZW50LmNoaWxkQmVmb3JlKCRwb3MucGFyZW50T2Zmc2V0KVxuICB9XG5cbiAgaWYgKCFzdGFydC5ub2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBtYXJrID0gZmluZE1hcmtJblNldChbLi4uc3RhcnQubm9kZS5tYXJrc10sIHR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgaWYgKCFtYXJrKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgc3RhcnRJbmRleCA9IHN0YXJ0LmluZGV4XG4gIGxldCBzdGFydFBvcyA9ICRwb3Muc3RhcnQoKSArIHN0YXJ0Lm9mZnNldFxuICBsZXQgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgMVxuICBsZXQgZW5kUG9zID0gc3RhcnRQb3MgKyBzdGFydC5ub2RlLm5vZGVTaXplXG5cbiAgZmluZE1hcmtJblNldChbLi4uc3RhcnQubm9kZS5tYXJrc10sIHR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgd2hpbGUgKHN0YXJ0SW5kZXggPiAwICYmIG1hcmsuaXNJblNldCgkcG9zLnBhcmVudC5jaGlsZChzdGFydEluZGV4IC0gMSkubWFya3MpKSB7XG4gICAgc3RhcnRJbmRleCAtPSAxXG4gICAgc3RhcnRQb3MgLT0gJHBvcy5wYXJlbnQuY2hpbGQoc3RhcnRJbmRleCkubm9kZVNpemVcbiAgfVxuXG4gIHdoaWxlIChcbiAgICBlbmRJbmRleCA8ICRwb3MucGFyZW50LmNoaWxkQ291bnRcbiAgICAmJiBpc01hcmtJblNldChbLi4uJHBvcy5wYXJlbnQuY2hpbGQoZW5kSW5kZXgpLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcylcbiAgKSB7XG4gICAgZW5kUG9zICs9ICRwb3MucGFyZW50LmNoaWxkKGVuZEluZGV4KS5ub2RlU2l6ZVxuICAgIGVuZEluZGV4ICs9IDFcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZnJvbTogc3RhcnRQb3MsXG4gICAgdG86IGVuZFBvcyxcbiAgfVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlLCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFya1R5cGUobmFtZU9yVHlwZTogc3RyaW5nIHwgTWFya1R5cGUsIHNjaGVtYTogU2NoZW1hKTogTWFya1R5cGUge1xuICBpZiAodHlwZW9mIG5hbWVPclR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCFzY2hlbWEubWFya3NbbmFtZU9yVHlwZV0pIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgVGhlcmUgaXMgbm8gbWFyayB0eXBlIG5hbWVkICcke25hbWVPclR5cGV9Jy4gTWF5YmUgeW91IGZvcmdvdCB0byBhZGQgdGhlIGV4dGVuc2lvbj9gLFxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWEubWFya3NbbmFtZU9yVHlwZV1cbiAgfVxuXG4gIHJldHVybiBuYW1lT3JUeXBlXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IGdldE1hcmtSYW5nZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1JhbmdlLmpzJ1xuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtUeXBlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGV4dGVuZE1hcmtSYW5nZToge1xuICAgICAgLyoqXG4gICAgICAgKiBFeHRlbmRzIHRoZSB0ZXh0IHNlbGVjdGlvbiB0byB0aGUgY3VycmVudCBtYXJrLlxuICAgICAgICovXG4gICAgICBleHRlbmRNYXJrUmFuZ2U6IChcbiAgICAgICAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTWFya1R5cGUsXG4gICAgICAgIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBleHRlbmRNYXJrUmFuZ2U6IFJhd0NvbW1hbmRzWydleHRlbmRNYXJrUmFuZ2UnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSB0clxuICBjb25zdCB7ICRmcm9tLCBmcm9tLCB0byB9ID0gc2VsZWN0aW9uXG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgcmFuZ2UgPSBnZXRNYXJrUmFuZ2UoJGZyb20sIHR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgICBpZiAocmFuZ2UgJiYgcmFuZ2UuZnJvbSA8PSBmcm9tICYmIHJhbmdlLnRvID49IHRvKSB7XG4gICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHJhbmdlLmZyb20sIHJhbmdlLnRvKVxuXG4gICAgICB0ci5zZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgQ29tbWFuZCwgQ29tbWFuZFByb3BzLCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZmlyc3Q6IHtcbiAgICAgIC8qKlxuICAgICAgICogUnVucyBvbmUgY29tbWFuZCBhZnRlciB0aGUgb3RoZXIgYW5kIHN0b3BzIGF0IHRoZSBmaXJzdCB3aGljaCByZXR1cm5zIHRydWUuXG4gICAgICAgKi9cbiAgICAgIGZpcnN0OiAoY29tbWFuZHM6IENvbW1hbmRbXSB8ICgocHJvcHM6IENvbW1hbmRQcm9wcykgPT4gQ29tbWFuZFtdKSkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGZpcnN0OiBSYXdDb21tYW5kc1snZmlyc3QnXSA9IGNvbW1hbmRzID0+IHByb3BzID0+IHtcbiAgY29uc3QgaXRlbXMgPSB0eXBlb2YgY29tbWFuZHMgPT09ICdmdW5jdGlvbidcbiAgICA/IGNvbW1hbmRzKHByb3BzKVxuICAgIDogY29tbWFuZHNcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGl0ZW1zW2ldKHByb3BzKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cbiIsICJpbXBvcnQgeyBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVGV4dFNlbGVjdGlvbih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFRleHRTZWxlY3Rpb24ge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIG1pbk1heCh2YWx1ZSA9IDAsIG1pbiA9IDAsIG1heCA9IDApOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heClcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBGb2N1c1Bvc2l0aW9uIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBtaW5NYXggfSBmcm9tICcuLi91dGlsaXRpZXMvbWluTWF4LmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUZvY3VzUG9zaXRpb24oXG4gIGRvYzogUHJvc2VNaXJyb3JOb2RlLFxuICBwb3NpdGlvbjogRm9jdXNQb3NpdGlvbiA9IG51bGwsXG4pOiBTZWxlY3Rpb24gfCBudWxsIHtcbiAgaWYgKCFwb3NpdGlvbikge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBzZWxlY3Rpb25BdFN0YXJ0ID0gU2VsZWN0aW9uLmF0U3RhcnQoZG9jKVxuICBjb25zdCBzZWxlY3Rpb25BdEVuZCA9IFNlbGVjdGlvbi5hdEVuZChkb2MpXG5cbiAgaWYgKHBvc2l0aW9uID09PSAnc3RhcnQnIHx8IHBvc2l0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvbkF0U3RhcnRcbiAgfVxuXG4gIGlmIChwb3NpdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uQXRFbmRcbiAgfVxuXG4gIGNvbnN0IG1pblBvcyA9IHNlbGVjdGlvbkF0U3RhcnQuZnJvbVxuICBjb25zdCBtYXhQb3MgPSBzZWxlY3Rpb25BdEVuZC50b1xuXG4gIGlmIChwb3NpdGlvbiA9PT0gJ2FsbCcpIHtcbiAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5jcmVhdGUoXG4gICAgICBkb2MsXG4gICAgICBtaW5NYXgoMCwgbWluUG9zLCBtYXhQb3MpLFxuICAgICAgbWluTWF4KGRvYy5jb250ZW50LnNpemUsIG1pblBvcywgbWF4UG9zKSxcbiAgICApXG4gIH1cblxuICByZXR1cm4gVGV4dFNlbGVjdGlvbi5jcmVhdGUoXG4gICAgZG9jLFxuICAgIG1pbk1heChwb3NpdGlvbiwgbWluUG9zLCBtYXhQb3MpLFxuICAgIG1pbk1heChwb3NpdGlvbiwgbWluUG9zLCBtYXhQb3MpLFxuICApXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzaU9TKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gW1xuICAgICdpUGFkIFNpbXVsYXRvcicsXG4gICAgJ2lQaG9uZSBTaW11bGF0b3InLFxuICAgICdpUG9kIFNpbXVsYXRvcicsXG4gICAgJ2lQYWQnLFxuICAgICdpUGhvbmUnLFxuICAgICdpUG9kJyxcbiAgXS5pbmNsdWRlcyhuYXZpZ2F0b3IucGxhdGZvcm0pXG4gIC8vIGlQYWQgb24gaU9TIDEzIGRldGVjdGlvblxuICB8fCAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygnTWFjJykgJiYgJ29udG91Y2hlbmQnIGluIGRvY3VtZW50KVxufVxuIiwgImltcG9ydCB7IGlzVGV4dFNlbGVjdGlvbiB9IGZyb20gJy4uL2hlbHBlcnMvaXNUZXh0U2VsZWN0aW9uLmpzJ1xuaW1wb3J0IHsgcmVzb2x2ZUZvY3VzUG9zaXRpb24gfSBmcm9tICcuLi9oZWxwZXJzL3Jlc29sdmVGb2N1c1Bvc2l0aW9uLmpzJ1xuaW1wb3J0IHsgRm9jdXNQb3NpdGlvbiwgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGlzaU9TIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2lzaU9TLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZm9jdXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogRm9jdXMgdGhlIGVkaXRvciBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICAgKi9cbiAgICAgIGZvY3VzOiAoXG4gICAgICAgIHBvc2l0aW9uPzogRm9jdXNQb3NpdGlvbixcbiAgICAgICAgb3B0aW9ucz86IHtcbiAgICAgICAgICBzY3JvbGxJbnRvVmlldz86IGJvb2xlYW4sXG4gICAgICAgIH0sXG4gICAgICApID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBmb2N1czogUmF3Q29tbWFuZHNbJ2ZvY3VzJ10gPSAocG9zaXRpb24gPSBudWxsLCBvcHRpb25zID0ge30pID0+ICh7XG4gIGVkaXRvcixcbiAgdmlldyxcbiAgdHIsXG4gIGRpc3BhdGNoLFxufSkgPT4ge1xuICBvcHRpb25zID0ge1xuICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cblxuICBjb25zdCBkZWxheWVkRm9jdXMgPSAoKSA9PiB7XG4gICAgLy8gZm9jdXMgd2l0aGluIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGJyZWFrcyBmb2N1cyBvbiBpT1NcbiAgICAvLyBzbyB3ZSBoYXZlIHRvIGNhbGwgdGhpc1xuICAgIGlmIChpc2lPUygpKSB7XG4gICAgICAodmlldy5kb20gYXMgSFRNTEVsZW1lbnQpLmZvY3VzKClcbiAgICB9XG5cbiAgICAvLyBGb3IgUmVhY3Qgd2UgaGF2ZSB0byBmb2N1cyBhc3luY2hyb25vdXNseS4gT3RoZXJ3aXNlIHdpbGQgdGhpbmdzIGhhcHBlbi5cbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMTUyMFxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgICB2aWV3LmZvY3VzKClcblxuICAgICAgICBpZiAob3B0aW9ucz8uc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgICBlZGl0b3IuY29tbWFuZHMuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGlmICgodmlldy5oYXNGb2N1cygpICYmIHBvc2l0aW9uID09PSBudWxsKSB8fCBwb3NpdGlvbiA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gd2UgZG9u4oCZdCB0cnkgdG8gcmVzb2x2ZSBhIE5vZGVTZWxlY3Rpb24gb3IgQ2VsbFNlbGVjdGlvblxuICBpZiAoZGlzcGF0Y2ggJiYgcG9zaXRpb24gPT09IG51bGwgJiYgIWlzVGV4dFNlbGVjdGlvbihlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uKSkge1xuICAgIGRlbGF5ZWRGb2N1cygpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIHBhc3MgdGhyb3VnaCB0ci5kb2MgaW5zdGVhZCBvZiBlZGl0b3Iuc3RhdGUuZG9jXG4gIC8vIHNpbmNlIHRyYW5zYWN0aW9ucyBjb3VsZCBjaGFuZ2UgdGhlIGVkaXRvcnMgc3RhdGUgYmVmb3JlIHRoaXMgY29tbWFuZCBoYXMgYmVlbiBydW5cbiAgY29uc3Qgc2VsZWN0aW9uID0gcmVzb2x2ZUZvY3VzUG9zaXRpb24odHIuZG9jLCBwb3NpdGlvbikgfHwgZWRpdG9yLnN0YXRlLnNlbGVjdGlvblxuICBjb25zdCBpc1NhbWVTZWxlY3Rpb24gPSBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmVxKHNlbGVjdGlvbilcblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBpZiAoIWlzU2FtZVNlbGVjdGlvbikge1xuICAgICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbilcbiAgICB9XG5cbiAgICAvLyBgdHIuc2V0U2VsZWN0aW9uYCByZXNldHMgdGhlIHN0b3JlZCBtYXJrc1xuICAgIC8vIHNvIHdl4oCZbGwgcmVzdG9yZSB0aGVtIGlmIHRoZSBzZWxlY3Rpb24gaXMgdGhlIHNhbWUgYXMgYmVmb3JlXG4gICAgaWYgKGlzU2FtZVNlbGVjdGlvbiAmJiB0ci5zdG9yZWRNYXJrcykge1xuICAgICAgdHIuc2V0U3RvcmVkTWFya3ModHIuc3RvcmVkTWFya3MpXG4gICAgfVxuXG4gICAgZGVsYXllZEZvY3VzKClcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgQ29tbWFuZFByb3BzLCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZm9yRWFjaDoge1xuICAgICAgLyoqXG4gICAgICAgKiBMb29wIHRocm91Z2ggYW4gYXJyYXkgb2YgaXRlbXMuXG4gICAgICAgKi9cbiAgICAgIGZvckVhY2g6IDxUPihcbiAgICAgICAgaXRlbXM6IFRbXSxcbiAgICAgICAgZm46IChcbiAgICAgICAgICBpdGVtOiBULFxuICAgICAgICAgIHByb3BzOiBDb21tYW5kUHJvcHMgJiB7XG4gICAgICAgICAgICBpbmRleDogbnVtYmVyLFxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gYm9vbGVhbixcbiAgICAgICkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGZvckVhY2g6IFJhd0NvbW1hbmRzWydmb3JFYWNoJ10gPSAoaXRlbXMsIGZuKSA9PiBwcm9wcyA9PiB7XG4gIHJldHVybiBpdGVtcy5ldmVyeSgoaXRlbSwgaW5kZXgpID0+IGZuKGl0ZW0sIHsgLi4ucHJvcHMsIGluZGV4IH0pKVxufVxuIiwgImltcG9ydCB7IFBhcnNlT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IENvbnRlbnQsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBpbnNlcnRDb250ZW50OiB7XG4gICAgICAvKipcbiAgICAgICAqIEluc2VydCBhIG5vZGUgb3Igc3RyaW5nIG9mIEhUTUwgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgKi9cbiAgICAgIGluc2VydENvbnRlbnQ6IChcbiAgICAgICAgdmFsdWU6IENvbnRlbnQsXG4gICAgICAgIG9wdGlvbnM/OiB7XG4gICAgICAgICAgcGFyc2VPcHRpb25zPzogUGFyc2VPcHRpb25zXG4gICAgICAgICAgdXBkYXRlU2VsZWN0aW9uPzogYm9vbGVhblxuICAgICAgICB9LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbnNlcnRDb250ZW50OiBSYXdDb21tYW5kc1snaW5zZXJ0Q29udGVudCddID0gKHZhbHVlLCBvcHRpb25zKSA9PiAoeyB0ciwgY29tbWFuZHMgfSkgPT4ge1xuICByZXR1cm4gY29tbWFuZHMuaW5zZXJ0Q29udGVudEF0KFxuICAgIHsgZnJvbTogdHIuc2VsZWN0aW9uLmZyb20sIHRvOiB0ci5zZWxlY3Rpb24udG8gfSxcbiAgICB2YWx1ZSxcbiAgICBvcHRpb25zLFxuICApXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnRGcm9tU3RyaW5nKHZhbHVlOiBzdHJpbmcpOiBIVE1MRWxlbWVudCB7XG4gIC8vIGFkZCBhIHdyYXBwZXIgdG8gcHJlc2VydmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICBjb25zdCB3cmFwcGVkVmFsdWUgPSBgPGJvZHk+JHt2YWx1ZX08L2JvZHk+YFxuXG4gIHJldHVybiBuZXcgd2luZG93LkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh3cmFwcGVkVmFsdWUsICd0ZXh0L2h0bWwnKS5ib2R5XG59XG4iLCAiaW1wb3J0IHtcbiAgRE9NUGFyc2VyLFxuICBGcmFnbWVudCxcbiAgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUsXG4gIFBhcnNlT3B0aW9ucyxcbiAgU2NoZW1hLFxufSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBDb250ZW50IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBlbGVtZW50RnJvbVN0cmluZyB9IGZyb20gJy4uL3V0aWxpdGllcy9lbGVtZW50RnJvbVN0cmluZy5qcydcblxuZXhwb3J0IHR5cGUgQ3JlYXRlTm9kZUZyb21Db250ZW50T3B0aW9ucyA9IHtcbiAgc2xpY2U/OiBib29sZWFuXG4gIHBhcnNlT3B0aW9ucz86IFBhcnNlT3B0aW9uc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTm9kZUZyb21Db250ZW50KFxuICBjb250ZW50OiBDb250ZW50LFxuICBzY2hlbWE6IFNjaGVtYSxcbiAgb3B0aW9ucz86IENyZWF0ZU5vZGVGcm9tQ29udGVudE9wdGlvbnMsXG4pOiBQcm9zZU1pcnJvck5vZGUgfCBGcmFnbWVudCB7XG4gIG9wdGlvbnMgPSB7XG4gICAgc2xpY2U6IHRydWUsXG4gICAgcGFyc2VPcHRpb25zOiB7fSxcbiAgICAuLi5vcHRpb25zLFxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnb2JqZWN0JyAmJiBjb250ZW50ICE9PSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnQpICYmIGNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbUFycmF5KGNvbnRlbnQubWFwKGl0ZW0gPT4gc2NoZW1hLm5vZGVGcm9tSlNPTihpdGVtKSkpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzY2hlbWEubm9kZUZyb21KU09OKGNvbnRlbnQpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignW3RpcHRhcCB3YXJuXTogSW52YWxpZCBjb250ZW50LicsICdQYXNzZWQgdmFsdWU6JywgY29udGVudCwgJ0Vycm9yOicsIGVycm9yKVxuXG4gICAgICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KCcnLCBzY2hlbWEsIG9wdGlvbnMpXG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IHBhcnNlciA9IERPTVBhcnNlci5mcm9tU2NoZW1hKHNjaGVtYSlcblxuICAgIHJldHVybiBvcHRpb25zLnNsaWNlXG4gICAgICA/IHBhcnNlci5wYXJzZVNsaWNlKGVsZW1lbnRGcm9tU3RyaW5nKGNvbnRlbnQpLCBvcHRpb25zLnBhcnNlT3B0aW9ucykuY29udGVudFxuICAgICAgOiBwYXJzZXIucGFyc2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZU5vZGVGcm9tQ29udGVudCgnJywgc2NoZW1hLCBvcHRpb25zKVxufVxuIiwgImltcG9ydCB7IFNlbGVjdGlvbiwgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgUmVwbGFjZUFyb3VuZFN0ZXAsIFJlcGxhY2VTdGVwIH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL1Byb3NlTWlycm9yL3Byb3NlbWlycm9yLXN0YXRlL2Jsb2IvbWFzdGVyL3NyYy9zZWxlY3Rpb24uanMjTDQ2NlxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyOiBUcmFuc2FjdGlvbiwgc3RhcnRMZW46IG51bWJlciwgYmlhczogbnVtYmVyKSB7XG4gIGNvbnN0IGxhc3QgPSB0ci5zdGVwcy5sZW5ndGggLSAxXG5cbiAgaWYgKGxhc3QgPCBzdGFydExlbikge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3Qgc3RlcCA9IHRyLnN0ZXBzW2xhc3RdXG5cbiAgaWYgKCEoc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VTdGVwIHx8IHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlQXJvdW5kU3RlcCkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IG1hcCA9IHRyLm1hcHBpbmcubWFwc1tsYXN0XVxuICBsZXQgZW5kID0gMFxuXG4gIG1hcC5mb3JFYWNoKChfZnJvbSwgX3RvLCBfbmV3RnJvbSwgbmV3VG8pID0+IHtcbiAgICBpZiAoZW5kID09PSAwKSB7XG4gICAgICBlbmQgPSBuZXdUb1xuICAgIH1cbiAgfSlcblxuICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoZW5kKSwgYmlhcykpXG59XG4iLCAiaW1wb3J0IHsgRnJhZ21lbnQsIE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLCBQYXJzZU9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBjcmVhdGVOb2RlRnJvbUNvbnRlbnQgfSBmcm9tICcuLi9oZWxwZXJzL2NyZWF0ZU5vZGVGcm9tQ29udGVudC5qcydcbmltcG9ydCB7IHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kIH0gZnJvbSAnLi4vaGVscGVycy9zZWxlY3Rpb25Ub0luc2VydGlvbkVuZC5qcydcbmltcG9ydCB7IENvbnRlbnQsIFJhbmdlLCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgaW5zZXJ0Q29udGVudEF0OiB7XG4gICAgICAvKipcbiAgICAgICAqIEluc2VydCBhIG5vZGUgb3Igc3RyaW5nIG9mIEhUTUwgYXQgYSBzcGVjaWZpYyBwb3NpdGlvbi5cbiAgICAgICAqL1xuICAgICAgaW5zZXJ0Q29udGVudEF0OiAoXG4gICAgICAgIHBvc2l0aW9uOiBudW1iZXIgfCBSYW5nZSxcbiAgICAgICAgdmFsdWU6IENvbnRlbnQsXG4gICAgICAgIG9wdGlvbnM/OiB7XG4gICAgICAgICAgcGFyc2VPcHRpb25zPzogUGFyc2VPcHRpb25zXG4gICAgICAgICAgdXBkYXRlU2VsZWN0aW9uPzogYm9vbGVhblxuICAgICAgICB9LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGlzRnJhZ21lbnQgPSAobm9kZU9yRnJhZ21lbnQ6IFByb3NlTWlycm9yTm9kZSB8IEZyYWdtZW50KTogbm9kZU9yRnJhZ21lbnQgaXMgRnJhZ21lbnQgPT4ge1xuICByZXR1cm4gbm9kZU9yRnJhZ21lbnQudG9TdHJpbmcoKS5zdGFydHNXaXRoKCc8Jylcbn1cblxuZXhwb3J0IGNvbnN0IGluc2VydENvbnRlbnRBdDogUmF3Q29tbWFuZHNbJ2luc2VydENvbnRlbnRBdCddID0gKHBvc2l0aW9uLCB2YWx1ZSwgb3B0aW9ucykgPT4gKHsgdHIsIGRpc3BhdGNoLCBlZGl0b3IgfSkgPT4ge1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgcGFyc2VPcHRpb25zOiB7fSxcbiAgICAgIHVwZGF0ZVNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfVxuXG4gICAgY29uc3QgY29udGVudCA9IGNyZWF0ZU5vZGVGcm9tQ29udGVudCh2YWx1ZSwgZWRpdG9yLnNjaGVtYSwge1xuICAgICAgcGFyc2VPcHRpb25zOiB7XG4gICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogJ2Z1bGwnLFxuICAgICAgICAuLi5vcHRpb25zLnBhcnNlT3B0aW9ucyxcbiAgICAgIH0sXG4gICAgfSlcblxuICAgIC8vIGRvbuKAmXQgZGlzcGF0Y2ggYW4gZW1wdHkgZnJhZ21lbnQgYmVjYXVzZSB0aGlzIGNhbiBsZWFkIHRvIHN0cmFuZ2UgZXJyb3JzXG4gICAgaWYgKGNvbnRlbnQudG9TdHJpbmcoKSA9PT0gJzw+Jykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBsZXQgeyBmcm9tLCB0byB9ID0gdHlwZW9mIHBvc2l0aW9uID09PSAnbnVtYmVyJyA/IHsgZnJvbTogcG9zaXRpb24sIHRvOiBwb3NpdGlvbiB9IDogeyBmcm9tOiBwb3NpdGlvbi5mcm9tLCB0bzogcG9zaXRpb24udG8gfVxuXG4gICAgbGV0IGlzT25seVRleHRDb250ZW50ID0gdHJ1ZVxuICAgIGxldCBpc09ubHlCbG9ja0NvbnRlbnQgPSB0cnVlXG4gICAgY29uc3Qgbm9kZXMgPSBpc0ZyYWdtZW50KGNvbnRlbnQpID8gY29udGVudCA6IFtjb250ZW50XVxuXG4gICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIC8vIGNoZWNrIGlmIGFkZGVkIG5vZGUgaXMgdmFsaWRcbiAgICAgIG5vZGUuY2hlY2soKVxuXG4gICAgICBpc09ubHlUZXh0Q29udGVudCA9IGlzT25seVRleHRDb250ZW50ID8gbm9kZS5pc1RleHQgJiYgbm9kZS5tYXJrcy5sZW5ndGggPT09IDAgOiBmYWxzZVxuXG4gICAgICBpc09ubHlCbG9ja0NvbnRlbnQgPSBpc09ubHlCbG9ja0NvbnRlbnQgPyBub2RlLmlzQmxvY2sgOiBmYWxzZVxuICAgIH0pXG5cbiAgICAvLyBjaGVjayBpZiB3ZSBjYW4gcmVwbGFjZSB0aGUgd3JhcHBpbmcgbm9kZSBieVxuICAgIC8vIHRoZSBuZXdseSBpbnNlcnRlZCBjb250ZW50XG4gICAgLy8gZXhhbXBsZTpcbiAgICAvLyByZXBsYWNlIGFuIGVtcHR5IHBhcmFncmFwaCBieSBhbiBpbnNlcnRlZCBpbWFnZVxuICAgIC8vIGluc3RlYWQgb2YgaW5zZXJ0aW5nIHRoZSBpbWFnZSBiZWxvdyB0aGUgcGFyYWdyYXBoXG4gICAgaWYgKGZyb20gPT09IHRvICYmIGlzT25seUJsb2NrQ29udGVudCkge1xuICAgICAgY29uc3QgeyBwYXJlbnQgfSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pXG4gICAgICBjb25zdCBpc0VtcHR5VGV4dEJsb2NrID0gcGFyZW50LmlzVGV4dGJsb2NrICYmICFwYXJlbnQudHlwZS5zcGVjLmNvZGUgJiYgIXBhcmVudC5jaGlsZENvdW50XG5cbiAgICAgIGlmIChpc0VtcHR5VGV4dEJsb2NrKSB7XG4gICAgICAgIGZyb20gLT0gMVxuICAgICAgICB0byArPSAxXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUgaXMgb25seSBwbGFpbiB0ZXh0IHdlIGhhdmUgdG8gdXNlIGBpbnNlcnRUZXh0YFxuICAgIC8vIGJlY2F1c2UgdGhpcyB3aWxsIGtlZXAgdGhlIGN1cnJlbnQgbWFya3NcbiAgICBpZiAoaXNPbmx5VGV4dENvbnRlbnQpIHtcbiAgICAgIC8vIGlmIHZhbHVlIGlzIHN0cmluZywgd2UgY2FuIHVzZSBpdCBkaXJlY3RseVxuICAgICAgLy8gb3RoZXJ3aXNlIGlmIGl0IGlzIGFuIGFycmF5LCB3ZSBoYXZlIHRvIGpvaW4gaXRcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB0ci5pbnNlcnRUZXh0KHZhbHVlLm1hcCh2ID0+IHYudGV4dCB8fCAnJykuam9pbignJyksIGZyb20sIHRvKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICEhdmFsdWUgJiYgISF2YWx1ZS50ZXh0KSB7XG4gICAgICAgIHRyLmluc2VydFRleHQodmFsdWUudGV4dCwgZnJvbSwgdG8pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ci5pbnNlcnRUZXh0KHZhbHVlIGFzIHN0cmluZywgZnJvbSwgdG8pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyLnJlcGxhY2VXaXRoKGZyb20sIHRvLCBjb250ZW50KVxuICAgIH1cblxuICAgIC8vIHNldCBjdXJzb3IgYXQgZW5kIG9mIGluc2VydGVkIGNvbnRlbnRcbiAgICBpZiAob3B0aW9ucy51cGRhdGVTZWxlY3Rpb24pIHtcbiAgICAgIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCB0ci5zdGVwcy5sZW5ndGggLSAxLCAtMSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7XG4gIGpvaW5CYWNrd2FyZCBhcyBvcmlnaW5hbEpvaW5CYWNrd2FyZCxcbiAgam9pbkRvd24gYXMgb3JpZ2luYWxKb2luRG93bixcbiAgam9pbkZvcndhcmQgYXMgb3JpZ2luYWxKb2luRm9yd2FyZCxcbiAgam9pblVwIGFzIG9yaWdpbmFsSm9pblVwLFxufSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgam9pblVwOiB7XG4gICAgICAvKipcbiAgICAgICAqIEpvaW4gdHdvIG5vZGVzIFVwLlxuICAgICAgICovXG4gICAgICBqb2luVXA6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gICAgam9pbkRvd246IHtcbiAgICAgIC8qKlxuICAgICAgICogSm9pbiB0d28gbm9kZXMgRG93bi5cbiAgICAgICAqL1xuICAgICAgam9pbkRvd246ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gICAgam9pbkJhY2t3YXJkOiB7XG4gICAgICAvKipcbiAgICAgICAqIEpvaW4gdHdvIG5vZGVzIEJhY2t3YXJkcy5cbiAgICAgICAqL1xuICAgICAgam9pbkJhY2t3YXJkOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICAgIGpvaW5Gb3J3YXJkOiB7XG4gICAgICAvKipcbiAgICAgICAqIEpvaW4gdHdvIG5vZGVzIEZvcndhcmRzLlxuICAgICAgICovXG4gICAgICBqb2luRm9yd2FyZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgam9pblVwOiBSYXdDb21tYW5kc1snam9pblVwJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxKb2luVXAoc3RhdGUsIGRpc3BhdGNoKVxufVxuXG5leHBvcnQgY29uc3Qgam9pbkRvd246IFJhd0NvbW1hbmRzWydqb2luRG93biddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsSm9pbkRvd24oc3RhdGUsIGRpc3BhdGNoKVxufVxuXG5leHBvcnQgY29uc3Qgam9pbkJhY2t3YXJkOiBSYXdDb21tYW5kc1snam9pbkJhY2t3YXJkJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxKb2luQmFja3dhcmQoc3RhdGUsIGRpc3BhdGNoKVxufVxuXG5leHBvcnQgY29uc3Qgam9pbkZvcndhcmQ6IFJhd0NvbW1hbmRzWydqb2luRm9yd2FyZCddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsSm9pbkZvcndhcmQoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IGpvaW5Qb2ludCB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgam9pbkl0ZW1CYWNrd2FyZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBKb2luIHR3byBub2RlcyBGb3J3YXJkcy5cbiAgICAgICAqL1xuICAgICAgam9pbkl0ZW1CYWNrd2FyZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgam9pbkl0ZW1CYWNrd2FyZDogUmF3Q29tbWFuZHNbJ2pvaW5JdGVtQmFja3dhcmQnXSA9ICgpID0+ICh7XG4gIHRyLCBzdGF0ZSwgZGlzcGF0Y2gsXG59KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ucG9zLCAtMSlcblxuICAgIGlmIChwb2ludCA9PT0gbnVsbCB8fCBwb2ludCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB0ci5qb2luKHBvaW50LCAyKVxuXG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBkaXNwYXRjaCh0cilcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIiwgImltcG9ydCB7IGpvaW5Qb2ludCB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgam9pbkl0ZW1Gb3J3YXJkOiB7XG4gICAgICAvKipcbiAgICAgICAqIEpvaW4gdHdvIG5vZGVzIEZvcndhcmRzLlxuICAgICAgICovXG4gICAgICBqb2luSXRlbUZvcndhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5JdGVtRm9yd2FyZDogUmF3Q29tbWFuZHNbJ2pvaW5JdGVtRm9yd2FyZCddID0gKCkgPT4gKHtcbiAgc3RhdGUsXG4gIGRpc3BhdGNoLFxuICB0cixcbn0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wb3MsICsxKVxuXG4gICAgaWYgKHBvaW50ID09PSBudWxsIHx8IHBvaW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHRyLmpvaW4ocG9pbnQsIDIpXG5cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGRpc3BhdGNoKHRyKVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBpc01hY09TKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKVxuICAgIDogZmFsc2Vcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgaXNpT1MgfSBmcm9tICcuLi91dGlsaXRpZXMvaXNpT1MuanMnXG5pbXBvcnQgeyBpc01hY09TIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2lzTWFjT1MuanMnXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleU5hbWUobmFtZTogc3RyaW5nKSB7XG4gIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLylcbiAgbGV0IHJlc3VsdCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdXG5cbiAgaWYgKHJlc3VsdCA9PT0gJ1NwYWNlJykge1xuICAgIHJlc3VsdCA9ICcgJ1xuICB9XG5cbiAgbGV0IGFsdFxuICBsZXQgY3RybFxuICBsZXQgc2hpZnRcbiAgbGV0IG1ldGFcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgIGNvbnN0IG1vZCA9IHBhcnRzW2ldXG5cbiAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKSB7XG4gICAgICBtZXRhID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoL15hKGx0KT8kL2kudGVzdChtb2QpKSB7XG4gICAgICBhbHQgPSB0cnVlXG4gICAgfSBlbHNlIGlmICgvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKSB7XG4gICAgICBjdHJsID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIHNoaWZ0ID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoL15tb2QkL2kudGVzdChtb2QpKSB7XG4gICAgICBpZiAoaXNpT1MoKSB8fCBpc01hY09TKCkpIHtcbiAgICAgICAgbWV0YSA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0cmwgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6ICR7bW9kfWApXG4gICAgfVxuICB9XG5cbiAgaWYgKGFsdCkge1xuICAgIHJlc3VsdCA9IGBBbHQtJHtyZXN1bHR9YFxuICB9XG5cbiAgaWYgKGN0cmwpIHtcbiAgICByZXN1bHQgPSBgQ3RybC0ke3Jlc3VsdH1gXG4gIH1cblxuICBpZiAobWV0YSkge1xuICAgIHJlc3VsdCA9IGBNZXRhLSR7cmVzdWx0fWBcbiAgfVxuXG4gIGlmIChzaGlmdCkge1xuICAgIHJlc3VsdCA9IGBTaGlmdC0ke3Jlc3VsdH1gXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBrZXlib2FyZFNob3J0Y3V0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFRyaWdnZXIgYSBrZXlib2FyZCBzaG9ydGN1dC5cbiAgICAgICAqL1xuICAgICAga2V5Ym9hcmRTaG9ydGN1dDogKG5hbWU6IHN0cmluZykgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGtleWJvYXJkU2hvcnRjdXQ6IFJhd0NvbW1hbmRzWydrZXlib2FyZFNob3J0Y3V0J10gPSBuYW1lID0+ICh7XG4gIGVkaXRvcixcbiAgdmlldyxcbiAgdHIsXG4gIGRpc3BhdGNoLFxufSkgPT4ge1xuICBjb25zdCBrZXlzID0gbm9ybWFsaXplS2V5TmFtZShuYW1lKS5zcGxpdCgvLSg/ISQpLylcbiAgY29uc3Qga2V5ID0ga2V5cy5maW5kKGl0ZW0gPT4gIVsnQWx0JywgJ0N0cmwnLCAnTWV0YScsICdTaGlmdCddLmluY2x1ZGVzKGl0ZW0pKVxuICBjb25zdCBldmVudCA9IG5ldyBLZXlib2FyZEV2ZW50KCdrZXlkb3duJywge1xuICAgIGtleToga2V5ID09PSAnU3BhY2UnXG4gICAgICA/ICcgJ1xuICAgICAgOiBrZXksXG4gICAgYWx0S2V5OiBrZXlzLmluY2x1ZGVzKCdBbHQnKSxcbiAgICBjdHJsS2V5OiBrZXlzLmluY2x1ZGVzKCdDdHJsJyksXG4gICAgbWV0YUtleToga2V5cy5pbmNsdWRlcygnTWV0YScpLFxuICAgIHNoaWZ0S2V5OiBrZXlzLmluY2x1ZGVzKCdTaGlmdCcpLFxuICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgfSlcblxuICBjb25zdCBjYXB0dXJlZFRyYW5zYWN0aW9uID0gZWRpdG9yLmNhcHR1cmVUcmFuc2FjdGlvbigoKSA9PiB7XG4gICAgdmlldy5zb21lUHJvcCgnaGFuZGxlS2V5RG93bicsIGYgPT4gZih2aWV3LCBldmVudCkpXG4gIH0pXG5cbiAgY2FwdHVyZWRUcmFuc2FjdGlvbj8uc3RlcHMuZm9yRWFjaChzdGVwID0+IHtcbiAgICBjb25zdCBuZXdTdGVwID0gc3RlcC5tYXAodHIubWFwcGluZylcblxuICAgIGlmIChuZXdTdGVwICYmIGRpc3BhdGNoKSB7XG4gICAgICB0ci5tYXliZVN0ZXAobmV3U3RlcClcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IE5vZGVSYW5nZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgb2JqZWN0SW5jbHVkZXMgfSBmcm9tICcuLi91dGlsaXRpZXMvb2JqZWN0SW5jbHVkZXMuanMnXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4vZ2V0Tm9kZVR5cGUuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVBY3RpdmUoXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZSxcbiAgdHlwZU9yTmFtZTogTm9kZVR5cGUgfCBzdHJpbmcgfCBudWxsLFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30sXG4pOiBib29sZWFuIHtcbiAgY29uc3QgeyBmcm9tLCB0bywgZW1wdHkgfSA9IHN0YXRlLnNlbGVjdGlvblxuICBjb25zdCB0eXBlID0gdHlwZU9yTmFtZSA/IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSkgOiBudWxsXG5cbiAgY29uc3Qgbm9kZVJhbmdlczogTm9kZVJhbmdlW10gPSBbXVxuXG4gIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlbGF0aXZlRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcylcbiAgICBjb25zdCByZWxhdGl2ZVRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUubm9kZVNpemUpXG5cbiAgICBub2RlUmFuZ2VzLnB1c2goe1xuICAgICAgbm9kZSxcbiAgICAgIGZyb206IHJlbGF0aXZlRnJvbSxcbiAgICAgIHRvOiByZWxhdGl2ZVRvLFxuICAgIH0pXG4gIH0pXG5cbiAgY29uc3Qgc2VsZWN0aW9uUmFuZ2UgPSB0byAtIGZyb21cbiAgY29uc3QgbWF0Y2hlZE5vZGVSYW5nZXMgPSBub2RlUmFuZ2VzXG4gICAgLmZpbHRlcihub2RlUmFuZ2UgPT4ge1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09IG5vZGVSYW5nZS5ub2RlLnR5cGUubmFtZVxuICAgIH0pXG4gICAgLmZpbHRlcihub2RlUmFuZ2UgPT4gb2JqZWN0SW5jbHVkZXMobm9kZVJhbmdlLm5vZGUuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSlcblxuICBpZiAoZW1wdHkpIHtcbiAgICByZXR1cm4gISFtYXRjaGVkTm9kZVJhbmdlcy5sZW5ndGhcbiAgfVxuXG4gIGNvbnN0IHJhbmdlID0gbWF0Y2hlZE5vZGVSYW5nZXMucmVkdWNlKChzdW0sIG5vZGVSYW5nZSkgPT4gc3VtICsgbm9kZVJhbmdlLnRvIC0gbm9kZVJhbmdlLmZyb20sIDApXG5cbiAgcmV0dXJuIHJhbmdlID49IHNlbGVjdGlvblJhbmdlXG59XG4iLCAiaW1wb3J0IHsgbGlmdCBhcyBvcmlnaW5hbExpZnQgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBpc05vZGVBY3RpdmUgfSBmcm9tICcuLi9oZWxwZXJzL2lzTm9kZUFjdGl2ZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBsaWZ0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgYW4gZXhpc3Rpbmcgd3JhcC5cbiAgICAgICAqL1xuICAgICAgbGlmdDogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbGlmdDogUmF3Q29tbWFuZHNbJ2xpZnQnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IGlzQWN0aXZlID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKVxuXG4gIGlmICghaXNBY3RpdmUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBvcmlnaW5hbExpZnQoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IGxpZnRFbXB0eUJsb2NrIGFzIG9yaWdpbmFsTGlmdEVtcHR5QmxvY2sgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgbGlmdEVtcHR5QmxvY2s6IHtcbiAgICAgIC8qKlxuICAgICAgICogTGlmdCBibG9jayBpZiBlbXB0eS5cbiAgICAgICAqL1xuICAgICAgbGlmdEVtcHR5QmxvY2s6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBsaWZ0RW1wdHlCbG9jazogUmF3Q29tbWFuZHNbJ2xpZnRFbXB0eUJsb2NrJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxMaWZ0RW1wdHlCbG9jayhzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgbGlmdExpc3RJdGVtIGFzIG9yaWdpbmFsTGlmdExpc3RJdGVtIH0gZnJvbSAnQHRpcHRhcC9wbS9zY2hlbWEtbGlzdCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGxpZnRMaXN0SXRlbToge1xuICAgICAgLyoqXG4gICAgICAgKiBMaWZ0IHRoZSBsaXN0IGl0ZW0gaW50byBhIHdyYXBwaW5nIGxpc3QuXG4gICAgICAgKi9cbiAgICAgIGxpZnRMaXN0SXRlbTogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBsaWZ0TGlzdEl0ZW06IFJhd0NvbW1hbmRzWydsaWZ0TGlzdEl0ZW0nXSA9IHR5cGVPck5hbWUgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcblxuICByZXR1cm4gb3JpZ2luYWxMaWZ0TGlzdEl0ZW0odHlwZSkoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IG5ld2xpbmVJbkNvZGUgYXMgb3JpZ2luYWxOZXdsaW5lSW5Db2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIG5ld2xpbmVJbkNvZGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogQWRkIGEgbmV3bGluZSBjaGFyYWN0ZXIgaW4gY29kZS5cbiAgICAgICAqL1xuICAgICAgbmV3bGluZUluQ29kZTogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbmV3bGluZUluQ29kZTogUmF3Q29tbWFuZHNbJ25ld2xpbmVJbkNvZGUnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbE5ld2xpbmVJbkNvZGUoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShuYW1lOiBzdHJpbmcsIHNjaGVtYTogU2NoZW1hKTogJ25vZGUnIHwgJ21hcmsnIHwgbnVsbCB7XG4gIGlmIChzY2hlbWEubm9kZXNbbmFtZV0pIHtcbiAgICByZXR1cm4gJ25vZGUnXG4gIH1cblxuICBpZiAoc2NoZW1hLm1hcmtzW25hbWVdKSB7XG4gICAgcmV0dXJuICdtYXJrJ1xuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbiIsICIvKipcbiAqIFJlbW92ZSBhIHByb3BlcnR5IG9yIGFuIGFycmF5IG9mIHByb3BlcnRpZXMgZnJvbSBhbiBvYmplY3RcbiAqIEBwYXJhbSBvYmogT2JqZWN0XG4gKiBAcGFyYW0ga2V5IEtleSB0byByZW1vdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZVByb3BzKG9iajogUmVjb3JkPHN0cmluZywgYW55PiwgcHJvcE9yUHJvcHM6IHN0cmluZyB8IHN0cmluZ1tdKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGNvbnN0IHByb3BzID0gdHlwZW9mIHByb3BPclByb3BzID09PSAnc3RyaW5nJ1xuICAgID8gW3Byb3BPclByb3BzXVxuICAgIDogcHJvcE9yUHJvcHNcblxuICByZXR1cm4gT2JqZWN0XG4gICAgLmtleXMob2JqKVxuICAgIC5yZWR1Y2UoKG5ld09iajogUmVjb3JkPHN0cmluZywgYW55PiwgcHJvcCkgPT4ge1xuICAgICAgaWYgKCFwcm9wcy5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgICBuZXdPYmpbcHJvcF0gPSBvYmpbcHJvcF1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld09ialxuICAgIH0sIHt9KVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlLCBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE1hcmtUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrVHlwZS5qcydcbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lIH0gZnJvbSAnLi4vaGVscGVycy9nZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBkZWxldGVQcm9wcyB9IGZyb20gJy4uL3V0aWxpdGllcy9kZWxldGVQcm9wcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHJlc2V0QXR0cmlidXRlczoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZXNldHMgc29tZSBub2RlIGF0dHJpYnV0ZXMgdG8gdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgKi9cbiAgICAgIHJlc2V0QXR0cmlidXRlczogKFxuICAgICAgICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSB8IE1hcmtUeXBlLFxuICAgICAgICBhdHRyaWJ1dGVzOiBzdHJpbmcgfCBzdHJpbmdbXSxcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcmVzZXRBdHRyaWJ1dGVzOiBSYXdDb21tYW5kc1sncmVzZXRBdHRyaWJ1dGVzJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcykgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGxldCBub2RlVHlwZTogTm9kZVR5cGUgfCBudWxsID0gbnVsbFxuICBsZXQgbWFya1R5cGU6IE1hcmtUeXBlIHwgbnVsbCA9IG51bGxcblxuICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUoXG4gICAgdHlwZW9mIHR5cGVPck5hbWUgPT09ICdzdHJpbmcnID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSxcbiAgICBzdGF0ZS5zY2hlbWEsXG4gIClcblxuICBpZiAoIXNjaGVtYVR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcbiAgICBub2RlVHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUgYXMgTm9kZVR5cGUsIHN0YXRlLnNjaGVtYSlcbiAgfVxuXG4gIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcbiAgICBtYXJrVHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUgYXMgTWFya1R5cGUsIHN0YXRlLnNjaGVtYSlcbiAgfVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHRyLnNlbGVjdGlvbi5yYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKHJhbmdlLiRmcm9tLnBvcywgcmFuZ2UuJHRvLnBvcywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB1bmRlZmluZWQsIGRlbGV0ZVByb3BzKG5vZGUuYXR0cnMsIGF0dHJpYnV0ZXMpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hcmtUeXBlICYmIG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgbm9kZS5tYXJrcy5mb3JFYWNoKG1hcmsgPT4ge1xuICAgICAgICAgICAgaWYgKG1hcmtUeXBlID09PSBtYXJrLnR5cGUpIHtcbiAgICAgICAgICAgICAgdHIuYWRkTWFyayhcbiAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgcG9zICsgbm9kZS5ub2RlU2l6ZSxcbiAgICAgICAgICAgICAgICBtYXJrVHlwZS5jcmVhdGUoZGVsZXRlUHJvcHMobWFyay5hdHRycywgYXR0cmlidXRlcykpLFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2Nyb2xsSW50b1ZpZXc6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIHRoZSBzZWxlY3Rpb24gaW50byB2aWV3LlxuICAgICAgICovXG4gICAgICBzY3JvbGxJbnRvVmlldzogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNjcm9sbEludG9WaWV3OiBSYXdDb21tYW5kc1snc2Nyb2xsSW50b1ZpZXcnXSA9ICgpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHRyLnNjcm9sbEludG9WaWV3KClcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNlbGVjdEFsbDoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZWxlY3QgdGhlIHdob2xlIGRvY3VtZW50LlxuICAgICAgICovXG4gICAgICBzZWxlY3RBbGw6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZWxlY3RBbGw6IFJhd0NvbW1hbmRzWydzZWxlY3RBbGwnXSA9ICgpID0+ICh7IHRyLCBjb21tYW5kcyB9KSA9PiB7XG4gIHJldHVybiBjb21tYW5kcy5zZXRUZXh0U2VsZWN0aW9uKHtcbiAgICBmcm9tOiAwLFxuICAgIHRvOiB0ci5kb2MuY29udGVudC5zaXplLFxuICB9KVxufVxuIiwgImltcG9ydCB7IHNlbGVjdE5vZGVCYWNrd2FyZCBhcyBvcmlnaW5hbFNlbGVjdE5vZGVCYWNrd2FyZCB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZWxlY3ROb2RlQmFja3dhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2VsZWN0IGEgbm9kZSBiYWNrd2FyZC5cbiAgICAgICAqL1xuICAgICAgc2VsZWN0Tm9kZUJhY2t3YXJkOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZWxlY3ROb2RlQmFja3dhcmQ6IFJhd0NvbW1hbmRzWydzZWxlY3ROb2RlQmFja3dhcmQnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbFNlbGVjdE5vZGVCYWNrd2FyZChzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgc2VsZWN0Tm9kZUZvcndhcmQgYXMgb3JpZ2luYWxTZWxlY3ROb2RlRm9yd2FyZCB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZWxlY3ROb2RlRm9yd2FyZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZWxlY3QgYSBub2RlIGZvcndhcmQuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdE5vZGVGb3J3YXJkOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZWxlY3ROb2RlRm9yd2FyZDogUmF3Q29tbWFuZHNbJ3NlbGVjdE5vZGVGb3J3YXJkJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3ROb2RlRm9yd2FyZChzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgc2VsZWN0UGFyZW50Tm9kZSBhcyBvcmlnaW5hbFNlbGVjdFBhcmVudE5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2VsZWN0UGFyZW50Tm9kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBTZWxlY3QgdGhlIHBhcmVudCBub2RlLlxuICAgICAgICovXG4gICAgICBzZWxlY3RQYXJlbnROb2RlOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZWxlY3RQYXJlbnROb2RlOiBSYXdDb21tYW5kc1snc2VsZWN0UGFyZW50Tm9kZSddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0UGFyZW50Tm9kZShzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiLy8gQHRzLWlnbm9yZVxuLy8gVE9ETzogYWRkIHR5cGVzIHRvIEB0eXBlcy9wcm9zZW1pcnJvci1jb21tYW5kc1xuaW1wb3J0IHsgc2VsZWN0VGV4dGJsb2NrRW5kIGFzIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrRW5kIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNlbGVjdFRleHRibG9ja0VuZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBNb3ZlcyB0aGUgY3Vyc29yIHRvIHRoZSBlbmQgb2YgY3VycmVudCB0ZXh0IGJsb2NrLlxuICAgICAgICovXG4gICAgICBzZWxlY3RUZXh0YmxvY2tFbmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNlbGVjdFRleHRibG9ja0VuZDogUmF3Q29tbWFuZHNbJ3NlbGVjdFRleHRibG9ja0VuZCddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrRW5kKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICIvLyBAdHMtaWdub3JlXG4vLyBUT0RPOiBhZGQgdHlwZXMgdG8gQHR5cGVzL3Byb3NlbWlycm9yLWNvbW1hbmRzXG5pbXBvcnQgeyBzZWxlY3RUZXh0YmxvY2tTdGFydCBhcyBvcmlnaW5hbFNlbGVjdFRleHRibG9ja1N0YXJ0IH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNlbGVjdFRleHRibG9ja1N0YXJ0OiB7XG4gICAgICAvKipcbiAgICAgICAqIE1vdmVzIHRoZSBjdXJzb3IgdG8gdGhlIHN0YXJ0IG9mIGN1cnJlbnQgdGV4dCBibG9jay5cbiAgICAgICAqL1xuICAgICAgc2VsZWN0VGV4dGJsb2NrU3RhcnQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNlbGVjdFRleHRibG9ja1N0YXJ0OiBSYXdDb21tYW5kc1snc2VsZWN0VGV4dGJsb2NrU3RhcnQnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbFNlbGVjdFRleHRibG9ja1N0YXJ0KHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgUGFyc2VPcHRpb25zLCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBDb250ZW50IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjcmVhdGVOb2RlRnJvbUNvbnRlbnQgfSBmcm9tICcuL2NyZWF0ZU5vZGVGcm9tQ29udGVudC5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50KFxuICBjb250ZW50OiBDb250ZW50LFxuICBzY2hlbWE6IFNjaGVtYSxcbiAgcGFyc2VPcHRpb25zOiBQYXJzZU9wdGlvbnMgPSB7fSxcbik6IFByb3NlTWlycm9yTm9kZSB7XG4gIHJldHVybiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoY29udGVudCwgc2NoZW1hLCB7IHNsaWNlOiBmYWxzZSwgcGFyc2VPcHRpb25zIH0pIGFzIFByb3NlTWlycm9yTm9kZVxufVxuIiwgImltcG9ydCB7IFBhcnNlT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGNyZWF0ZURvY3VtZW50IH0gZnJvbSAnLi4vaGVscGVycy9jcmVhdGVEb2N1bWVudC5qcydcbmltcG9ydCB7IENvbnRlbnQsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZXRDb250ZW50OiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlcGxhY2UgdGhlIHdob2xlIGRvY3VtZW50IHdpdGggbmV3IGNvbnRlbnQuXG4gICAgICAgKi9cbiAgICAgIHNldENvbnRlbnQ6IChcbiAgICAgICAgY29udGVudDogQ29udGVudCxcbiAgICAgICAgZW1pdFVwZGF0ZT86IGJvb2xlYW4sXG4gICAgICAgIHBhcnNlT3B0aW9ucz86IFBhcnNlT3B0aW9ucyxcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2V0Q29udGVudDogUmF3Q29tbWFuZHNbJ3NldENvbnRlbnQnXSA9IChjb250ZW50LCBlbWl0VXBkYXRlID0gZmFsc2UsIHBhcnNlT3B0aW9ucyA9IHt9KSA9PiAoeyB0ciwgZWRpdG9yLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgZG9jIH0gPSB0clxuICBjb25zdCBkb2N1bWVudCA9IGNyZWF0ZURvY3VtZW50KGNvbnRlbnQsIGVkaXRvci5zY2hlbWEsIHBhcnNlT3B0aW9ucylcblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5yZXBsYWNlV2l0aCgwLCBkb2MuY29udGVudC5zaXplLCBkb2N1bWVudCkuc2V0TWV0YSgncHJldmVudFVwZGF0ZScsICFlbWl0VXBkYXRlKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBNYXJrLCBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IGdldE1hcmtUeXBlIH0gZnJvbSAnLi9nZXRNYXJrVHlwZS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmtBdHRyaWJ1dGVzKFxuICBzdGF0ZTogRWRpdG9yU3RhdGUsXG4gIHR5cGVPck5hbWU6IHN0cmluZyB8IE1hcmtUeXBlLFxuKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgZnJvbSwgdG8sIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb25cbiAgY29uc3QgbWFya3M6IE1hcmtbXSA9IFtdXG5cbiAgaWYgKGVtcHR5KSB7XG4gICAgaWYgKHN0YXRlLnN0b3JlZE1hcmtzKSB7XG4gICAgICBtYXJrcy5wdXNoKC4uLnN0YXRlLnN0b3JlZE1hcmtzKVxuICAgIH1cblxuICAgIG1hcmtzLnB1c2goLi4uc3RhdGUuc2VsZWN0aW9uLiRoZWFkLm1hcmtzKCkpXG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgbm9kZSA9PiB7XG4gICAgICBtYXJrcy5wdXNoKC4uLm5vZGUubWFya3MpXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IG1hcmsgPSBtYXJrcy5maW5kKG1hcmtJdGVtID0+IG1hcmtJdGVtLnR5cGUubmFtZSA9PT0gdHlwZS5uYW1lKVxuXG4gIGlmICghbWFyaykge1xuICAgIHJldHVybiB7fVxuICB9XG5cbiAgcmV0dXJuIHsgLi4ubWFyay5hdHRycyB9XG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBgVHJhbnNmb3JtYCBiYXNlZCBvbiBhbGwgc3RlcHMgb2YgdGhlIHBhc3NlZCB0cmFuc2FjdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lVHJhbnNhY3Rpb25TdGVwcyhcbiAgb2xkRG9jOiBQcm9zZU1pcnJvck5vZGUsXG4gIHRyYW5zYWN0aW9uczogVHJhbnNhY3Rpb25bXSxcbik6IFRyYW5zZm9ybSB7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0ob2xkRG9jKVxuXG4gIHRyYW5zYWN0aW9ucy5mb3JFYWNoKHRyYW5zYWN0aW9uID0+IHtcbiAgICB0cmFuc2FjdGlvbi5zdGVwcy5mb3JFYWNoKHN0ZXAgPT4ge1xuICAgICAgdHJhbnNmb3JtLnN0ZXAoc3RlcClcbiAgICB9KVxuICB9KVxuXG4gIHJldHVybiB0cmFuc2Zvcm1cbn1cbiIsICJpbXBvcnQgeyBDb250ZW50TWF0Y2gsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRCbG9ja0F0KG1hdGNoOiBDb250ZW50TWF0Y2gpOiBOb2RlVHlwZSB8IG51bGwge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSArPSAxKSB7XG4gICAgY29uc3QgeyB0eXBlIH0gPSBtYXRjaC5lZGdlKGkpXG5cbiAgICBpZiAodHlwZS5pc1RleHRibG9jayAmJiAhdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpIHtcbiAgICAgIHJldHVybiB0eXBlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IE5vZGVXaXRoUG9zLCBQcmVkaWNhdGUgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRDaGlsZHJlbihub2RlOiBQcm9zZU1pcnJvck5vZGUsIHByZWRpY2F0ZTogUHJlZGljYXRlKTogTm9kZVdpdGhQb3NbXSB7XG4gIGNvbnN0IG5vZGVzV2l0aFBvczogTm9kZVdpdGhQb3NbXSA9IFtdXG5cbiAgbm9kZS5kZXNjZW5kYW50cygoY2hpbGQsIHBvcykgPT4ge1xuICAgIGlmIChwcmVkaWNhdGUoY2hpbGQpKSB7XG4gICAgICBub2Rlc1dpdGhQb3MucHVzaCh7XG4gICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICBwb3MsXG4gICAgICB9KVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gbm9kZXNXaXRoUG9zXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBOb2RlV2l0aFBvcywgUHJlZGljYXRlLCBSYW5nZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG4vKipcbiAqIFNhbWUgYXMgYGZpbmRDaGlsZHJlbmAgYnV0IHNlYXJjaGVzIG9ubHkgd2l0aGluIGEgYHJhbmdlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRDaGlsZHJlbkluUmFuZ2UoXG4gIG5vZGU6IFByb3NlTWlycm9yTm9kZSxcbiAgcmFuZ2U6IFJhbmdlLFxuICBwcmVkaWNhdGU6IFByZWRpY2F0ZSxcbik6IE5vZGVXaXRoUG9zW10ge1xuICBjb25zdCBub2Rlc1dpdGhQb3M6IE5vZGVXaXRoUG9zW10gPSBbXVxuXG4gIC8vIGlmIChyYW5nZS5mcm9tID09PSByYW5nZS50bykge1xuICAvLyAgIGNvbnN0IG5vZGVBdCA9IG5vZGUubm9kZUF0KHJhbmdlLmZyb20pXG5cbiAgLy8gICBpZiAobm9kZUF0KSB7XG4gIC8vICAgICBub2Rlc1dpdGhQb3MucHVzaCh7XG4gIC8vICAgICAgIG5vZGU6IG5vZGVBdCxcbiAgLy8gICAgICAgcG9zOiByYW5nZS5mcm9tLFxuICAvLyAgICAgfSlcbiAgLy8gICB9XG4gIC8vIH1cblxuICBub2RlLm5vZGVzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgKGNoaWxkLCBwb3MpID0+IHtcbiAgICBpZiAocHJlZGljYXRlKGNoaWxkKSkge1xuICAgICAgbm9kZXNXaXRoUG9zLnB1c2goe1xuICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgcG9zLFxuICAgICAgfSlcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIG5vZGVzV2l0aFBvc1xufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLCBSZXNvbHZlZFBvcyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IFByZWRpY2F0ZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MoXG4gICRwb3M6IFJlc29sdmVkUG9zLFxuICBwcmVkaWNhdGU6IFByZWRpY2F0ZSxcbik6XG4gIHwge1xuICAgICAgcG9zOiBudW1iZXJcbiAgICAgIHN0YXJ0OiBudW1iZXJcbiAgICAgIGRlcHRoOiBudW1iZXJcbiAgICAgIG5vZGU6IFByb3NlTWlycm9yTm9kZVxuICAgIH1cbiAgfCB1bmRlZmluZWQge1xuICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aDsgaSA+IDA7IGkgLT0gMSkge1xuICAgIGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoaSlcblxuICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvczogaSA+IDAgPyAkcG9zLmJlZm9yZShpKSA6IDAsXG4gICAgICAgIHN0YXJ0OiAkcG9zLnN0YXJ0KGkpLFxuICAgICAgICBkZXB0aDogaSxcbiAgICAgICAgbm9kZSxcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBQcmVkaWNhdGUgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zIH0gZnJvbSAnLi9maW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1Bvcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRQYXJlbnROb2RlKHByZWRpY2F0ZTogUHJlZGljYXRlKSB7XG4gIHJldHVybiAoc2VsZWN0aW9uOiBTZWxlY3Rpb24pID0+IGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zKHNlbGVjdGlvbi4kZnJvbSwgcHJlZGljYXRlKVxufVxuIiwgImltcG9ydCB7IERPTVNlcmlhbGl6ZXIsIEZyYWdtZW50LCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SFRNTEZyb21GcmFnbWVudChmcmFnbWVudDogRnJhZ21lbnQsIHNjaGVtYTogU2NoZW1hKTogc3RyaW5nIHtcbiAgY29uc3QgZG9jdW1lbnRGcmFnbWVudCA9IERPTVNlcmlhbGl6ZXIuZnJvbVNjaGVtYShzY2hlbWEpLnNlcmlhbGl6ZUZyYWdtZW50KGZyYWdtZW50KVxuXG4gIGNvbnN0IHRlbXBvcmFyeURvY3VtZW50ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KClcbiAgY29uc3QgY29udGFpbmVyID0gdGVtcG9yYXJ5RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcblxuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnRGcmFnbWVudClcblxuICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxufVxuIiwgImltcG9ydCB7IFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJy4uL0VkaXRvci5qcydcbmltcG9ydCB7IEV4dGVuc2lvbk1hbmFnZXIgfSBmcm9tICcuLi9FeHRlbnNpb25NYW5hZ2VyLmpzJ1xuaW1wb3J0IHsgRXh0ZW5zaW9ucyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMgfSBmcm9tICcuL2dldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMsIGVkaXRvcj86IEVkaXRvcik6IFNjaGVtYSB7XG4gIGNvbnN0IHJlc29sdmVkRXh0ZW5zaW9ucyA9IEV4dGVuc2lvbk1hbmFnZXIucmVzb2x2ZShleHRlbnNpb25zKVxuXG4gIHJldHVybiBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyhyZXNvbHZlZEV4dGVuc2lvbnMsIGVkaXRvcilcbn1cbiIsICJpbXBvcnQgeyBOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRXh0ZW5zaW9ucywgSlNPTkNvbnRlbnQgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGdldEhUTUxGcm9tRnJhZ21lbnQgfSBmcm9tICcuL2dldEhUTUxGcm9tRnJhZ21lbnQuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWEgfSBmcm9tICcuL2dldFNjaGVtYS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlSFRNTChkb2M6IEpTT05Db250ZW50LCBleHRlbnNpb25zOiBFeHRlbnNpb25zKTogc3RyaW5nIHtcbiAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpXG4gIGNvbnN0IGNvbnRlbnROb2RlID0gTm9kZS5mcm9tSlNPTihzY2hlbWEsIGRvYylcblxuICByZXR1cm4gZ2V0SFRNTEZyb21GcmFnbWVudChjb250ZW50Tm9kZS5jb250ZW50LCBzY2hlbWEpXG59XG4iLCAiaW1wb3J0IHsgRE9NUGFyc2VyIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRXh0ZW5zaW9ucyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZWxlbWVudEZyb21TdHJpbmcgfSBmcm9tICcuLi91dGlsaXRpZXMvZWxlbWVudEZyb21TdHJpbmcuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWEgfSBmcm9tICcuL2dldFNjaGVtYS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlSlNPTihodG1sOiBzdHJpbmcsIGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpXG4gIGNvbnN0IGRvbSA9IGVsZW1lbnRGcm9tU3RyaW5nKGh0bWwpXG5cbiAgcmV0dXJuIERPTVBhcnNlci5mcm9tU2NoZW1hKHNjaGVtYSkucGFyc2UoZG9tKS50b0pTT04oKVxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgVGV4dFNlcmlhbGl6ZXIgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGdldFRleHRCZXR3ZWVuIH0gZnJvbSAnLi9nZXRUZXh0QmV0d2Vlbi5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRleHQoXG4gIG5vZGU6IFByb3NlTWlycm9yTm9kZSxcbiAgb3B0aW9ucz86IHtcbiAgICBibG9ja1NlcGFyYXRvcj86IHN0cmluZ1xuICAgIHRleHRTZXJpYWxpemVycz86IFJlY29yZDxzdHJpbmcsIFRleHRTZXJpYWxpemVyPlxuICB9LFxuKSB7XG4gIGNvbnN0IHJhbmdlID0ge1xuICAgIGZyb206IDAsXG4gICAgdG86IG5vZGUuY29udGVudC5zaXplLFxuICB9XG5cbiAgcmV0dXJuIGdldFRleHRCZXR3ZWVuKG5vZGUsIHJhbmdlLCBvcHRpb25zKVxufVxuIiwgImltcG9ydCB7IE5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb25zLCBKU09OQ29udGVudCwgVGV4dFNlcmlhbGl6ZXIgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGdldFNjaGVtYSB9IGZyb20gJy4vZ2V0U2NoZW1hLmpzJ1xuaW1wb3J0IHsgZ2V0VGV4dCB9IGZyb20gJy4vZ2V0VGV4dC5qcydcbmltcG9ydCB7IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEgfSBmcm9tICcuL2dldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVRleHQoXG4gIGRvYzogSlNPTkNvbnRlbnQsXG4gIGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMsXG4gIG9wdGlvbnM/OiB7XG4gICAgYmxvY2tTZXBhcmF0b3I/OiBzdHJpbmdcbiAgICB0ZXh0U2VyaWFsaXplcnM/OiBSZWNvcmQ8c3RyaW5nLCBUZXh0U2VyaWFsaXplcj5cbiAgfSxcbik6IHN0cmluZyB7XG4gIGNvbnN0IHsgYmxvY2tTZXBhcmF0b3IgPSAnXFxuXFxuJywgdGV4dFNlcmlhbGl6ZXJzID0ge30gfSA9IG9wdGlvbnMgfHwge31cbiAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpXG4gIGNvbnN0IGNvbnRlbnROb2RlID0gTm9kZS5mcm9tSlNPTihzY2hlbWEsIGRvYylcblxuICByZXR1cm4gZ2V0VGV4dChjb250ZW50Tm9kZSwge1xuICAgIGJsb2NrU2VwYXJhdG9yLFxuICAgIHRleHRTZXJpYWxpemVyczoge1xuICAgICAgLi4uZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWEpLFxuICAgICAgLi4udGV4dFNlcmlhbGl6ZXJzLFxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgTm9kZSwgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4vZ2V0Tm9kZVR5cGUuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlQXR0cmlidXRlcyhcbiAgc3RhdGU6IEVkaXRvclN0YXRlLFxuICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSxcbik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCB7IGZyb20sIHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb25cbiAgY29uc3Qgbm9kZXM6IE5vZGVbXSA9IFtdXG5cbiAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgbm9kZSA9PiB7XG4gICAgbm9kZXMucHVzaChub2RlKVxuICB9KVxuXG4gIGNvbnN0IG5vZGUgPSBub2Rlcy5yZXZlcnNlKCkuZmluZChub2RlSXRlbSA9PiBub2RlSXRlbS50eXBlLm5hbWUgPT09IHR5cGUubmFtZSlcblxuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuXG4gIHJldHVybiB7IC4uLm5vZGUuYXR0cnMgfVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlLCBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IGdldE1hcmtBdHRyaWJ1dGVzIH0gZnJvbSAnLi9nZXRNYXJrQXR0cmlidXRlcy5qcydcbmltcG9ydCB7IGdldE5vZGVBdHRyaWJ1dGVzIH0gZnJvbSAnLi9nZXROb2RlQXR0cmlidXRlcy5qcydcbmltcG9ydCB7IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lIH0gZnJvbSAnLi9nZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMoXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZSxcbiAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUgfCBNYXJrVHlwZSxcbik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUoXG4gICAgdHlwZW9mIHR5cGVPck5hbWUgPT09ICdzdHJpbmcnID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSxcbiAgICBzdGF0ZS5zY2hlbWEsXG4gIClcblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgcmV0dXJuIGdldE5vZGVBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lIGFzIE5vZGVUeXBlKVxuICB9XG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09ICdtYXJrJykge1xuICAgIHJldHVybiBnZXRNYXJrQXR0cmlidXRlcyhzdGF0ZSwgdHlwZU9yTmFtZSBhcyBNYXJrVHlwZSlcbiAgfVxuXG4gIHJldHVybiB7fVxufVxuIiwgIi8qKlxuICogUmVtb3ZlcyBkdXBsaWNhdGVkIHZhbHVlcyB3aXRoaW4gYW4gYXJyYXkuXG4gKiBTdXBwb3J0cyBudW1iZXJzLCBzdHJpbmdzIGFuZCBvYmplY3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlczxUPihhcnJheTogVFtdLCBieSA9IEpTT04uc3RyaW5naWZ5KTogVFtdIHtcbiAgY29uc3Qgc2VlbjogUmVjb3JkPGFueSwgYW55PiA9IHt9XG5cbiAgcmV0dXJuIGFycmF5LmZpbHRlcihpdGVtID0+IHtcbiAgICBjb25zdCBrZXkgPSBieShpdGVtKVxuXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZWVuLCBrZXkpXG4gICAgICA/IGZhbHNlXG4gICAgICA6IChzZWVuW2tleV0gPSB0cnVlKVxuICB9KVxufVxuIiwgImltcG9ydCB7IFN0ZXAsIFRyYW5zZm9ybSB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgcmVtb3ZlRHVwbGljYXRlcyB9IGZyb20gJy4uL3V0aWxpdGllcy9yZW1vdmVEdXBsaWNhdGVzLmpzJ1xuXG5leHBvcnQgdHlwZSBDaGFuZ2VkUmFuZ2UgPSB7XG4gIG9sZFJhbmdlOiBSYW5nZSxcbiAgbmV3UmFuZ2U6IFJhbmdlLFxufVxuXG4vKipcbiAqIFJlbW92ZXMgZHVwbGljYXRlZCByYW5nZXMgYW5kIHJhbmdlcyB0aGF0IGFyZVxuICogZnVsbHkgY2FwdHVyZWQgYnkgb3RoZXIgcmFuZ2VzLlxuICovXG5mdW5jdGlvbiBzaW1wbGlmeUNoYW5nZWRSYW5nZXMoY2hhbmdlczogQ2hhbmdlZFJhbmdlW10pOiBDaGFuZ2VkUmFuZ2VbXSB7XG4gIGNvbnN0IHVuaXF1ZUNoYW5nZXMgPSByZW1vdmVEdXBsaWNhdGVzKGNoYW5nZXMpXG5cbiAgcmV0dXJuIHVuaXF1ZUNoYW5nZXMubGVuZ3RoID09PSAxXG4gICAgPyB1bmlxdWVDaGFuZ2VzXG4gICAgOiB1bmlxdWVDaGFuZ2VzLmZpbHRlcigoY2hhbmdlLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcmVzdCA9IHVuaXF1ZUNoYW5nZXMuZmlsdGVyKChfLCBpKSA9PiBpICE9PSBpbmRleClcblxuICAgICAgcmV0dXJuICFyZXN0LnNvbWUob3RoZXJDaGFuZ2UgPT4ge1xuICAgICAgICByZXR1cm4gY2hhbmdlLm9sZFJhbmdlLmZyb20gPj0gb3RoZXJDaGFuZ2Uub2xkUmFuZ2UuZnJvbVxuICAgICAgICAgICYmIGNoYW5nZS5vbGRSYW5nZS50byA8PSBvdGhlckNoYW5nZS5vbGRSYW5nZS50b1xuICAgICAgICAgICYmIGNoYW5nZS5uZXdSYW5nZS5mcm9tID49IG90aGVyQ2hhbmdlLm5ld1JhbmdlLmZyb21cbiAgICAgICAgICAmJiBjaGFuZ2UubmV3UmFuZ2UudG8gPD0gb3RoZXJDaGFuZ2UubmV3UmFuZ2UudG9cbiAgICAgIH0pXG4gICAgfSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBjaGFuZ2VkIHJhbmdlc1xuICogYmFzZWQgb24gdGhlIGZpcnN0IGFuZCBsYXN0IHN0YXRlIG9mIGFsbCBzdGVwcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENoYW5nZWRSYW5nZXModHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiBDaGFuZ2VkUmFuZ2VbXSB7XG4gIGNvbnN0IHsgbWFwcGluZywgc3RlcHMgfSA9IHRyYW5zZm9ybVxuICBjb25zdCBjaGFuZ2VzOiBDaGFuZ2VkUmFuZ2VbXSA9IFtdXG5cbiAgbWFwcGluZy5tYXBzLmZvckVhY2goKHN0ZXBNYXAsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcmFuZ2VzOiBSYW5nZVtdID0gW11cblxuICAgIC8vIFRoaXMgYWNjb3VudHMgZm9yIHN0ZXAgY2hhbmdlcyB3aGVyZSBubyByYW5nZSB3YXMgYWN0dWFsbHkgYWx0ZXJlZFxuICAgIC8vIGUuZy4gd2hlbiBzZXR0aW5nIGEgbWFyaywgbm9kZSBhdHRyaWJ1dGUsIGV0Yy5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKCFzdGVwTWFwLnJhbmdlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHN0ZXBzW2luZGV4XSBhcyBTdGVwICYge1xuICAgICAgICBmcm9tPzogbnVtYmVyLFxuICAgICAgICB0bz86IG51bWJlcixcbiAgICAgIH1cblxuICAgICAgaWYgKGZyb20gPT09IHVuZGVmaW5lZCB8fCB0byA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICByYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ZXBNYXAuZm9yRWFjaCgoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByYW5nZXMuZm9yRWFjaCgoeyBmcm9tLCB0byB9KSA9PiB7XG4gICAgICBjb25zdCBuZXdTdGFydCA9IG1hcHBpbmcuc2xpY2UoaW5kZXgpLm1hcChmcm9tLCAtMSlcbiAgICAgIGNvbnN0IG5ld0VuZCA9IG1hcHBpbmcuc2xpY2UoaW5kZXgpLm1hcCh0bylcbiAgICAgIGNvbnN0IG9sZFN0YXJ0ID0gbWFwcGluZy5pbnZlcnQoKS5tYXAobmV3U3RhcnQsIC0xKVxuICAgICAgY29uc3Qgb2xkRW5kID0gbWFwcGluZy5pbnZlcnQoKS5tYXAobmV3RW5kKVxuXG4gICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICBvbGRSYW5nZToge1xuICAgICAgICAgIGZyb206IG9sZFN0YXJ0LFxuICAgICAgICAgIHRvOiBvbGRFbmQsXG4gICAgICAgIH0sXG4gICAgICAgIG5ld1JhbmdlOiB7XG4gICAgICAgICAgZnJvbTogbmV3U3RhcnQsXG4gICAgICAgICAgdG86IG5ld0VuZCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gc2ltcGxpZnlDaGFuZ2VkUmFuZ2VzKGNoYW5nZXMpXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBKU09OQ29udGVudCB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5pbnRlcmZhY2UgRGVidWdKU09OQ29udGVudCBleHRlbmRzIEpTT05Db250ZW50IHtcbiAgZnJvbTogbnVtYmVyXG4gIHRvOiBudW1iZXJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlYnVnSlNPTihub2RlOiBQcm9zZU1pcnJvck5vZGUsIHN0YXJ0T2Zmc2V0ID0gMCk6IERlYnVnSlNPTkNvbnRlbnQge1xuICBjb25zdCBpc1RvcE5vZGUgPSBub2RlLnR5cGUgPT09IG5vZGUudHlwZS5zY2hlbWEudG9wTm9kZVR5cGVcbiAgY29uc3QgaW5jcmVtZW50ID0gaXNUb3BOb2RlID8gMCA6IDFcbiAgY29uc3QgZnJvbSA9IHN0YXJ0T2Zmc2V0XG4gIGNvbnN0IHRvID0gZnJvbSArIG5vZGUubm9kZVNpemVcbiAgY29uc3QgbWFya3MgPSBub2RlLm1hcmtzLm1hcChtYXJrID0+IHtcbiAgICBjb25zdCBvdXRwdXQ6IHsgdHlwZTogc3RyaW5nOyBhdHRycz86IFJlY29yZDxzdHJpbmcsIGFueT4gfSA9IHtcbiAgICAgIHR5cGU6IG1hcmsudHlwZS5uYW1lLFxuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhtYXJrLmF0dHJzKS5sZW5ndGgpIHtcbiAgICAgIG91dHB1dC5hdHRycyA9IHsgLi4ubWFyay5hdHRycyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dFxuICB9KVxuICBjb25zdCBhdHRycyA9IHsgLi4ubm9kZS5hdHRycyB9XG4gIGNvbnN0IG91dHB1dDogRGVidWdKU09OQ29udGVudCA9IHtcbiAgICB0eXBlOiBub2RlLnR5cGUubmFtZSxcbiAgICBmcm9tLFxuICAgIHRvLFxuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKGF0dHJzKS5sZW5ndGgpIHtcbiAgICBvdXRwdXQuYXR0cnMgPSBhdHRyc1xuICB9XG5cbiAgaWYgKG1hcmtzLmxlbmd0aCkge1xuICAgIG91dHB1dC5tYXJrcyA9IG1hcmtzXG4gIH1cblxuICBpZiAobm9kZS5jb250ZW50LmNoaWxkQ291bnQpIHtcbiAgICBvdXRwdXQuY29udGVudCA9IFtdXG5cbiAgICBub2RlLmZvckVhY2goKGNoaWxkLCBvZmZzZXQpID0+IHtcbiAgICAgIG91dHB1dC5jb250ZW50Py5wdXNoKGdldERlYnVnSlNPTihjaGlsZCwgc3RhcnRPZmZzZXQgKyBvZmZzZXQgKyBpbmNyZW1lbnQpKVxuICAgIH0pXG4gIH1cblxuICBpZiAobm9kZS50ZXh0KSB7XG4gICAgb3V0cHV0LnRleHQgPSBub2RlLnRleHRcbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IE1hcmtSYW5nZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZ2V0TWFya1JhbmdlIH0gZnJvbSAnLi9nZXRNYXJrUmFuZ2UuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXJrc0JldHdlZW4oZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyLCBkb2M6IFByb3NlTWlycm9yTm9kZSk6IE1hcmtSYW5nZVtdIHtcbiAgY29uc3QgbWFya3M6IE1hcmtSYW5nZVtdID0gW11cblxuICAvLyBnZXQgYWxsIGluY2x1c2l2ZSBtYXJrcyBvbiBlbXB0eSBzZWxlY3Rpb25cbiAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgZG9jXG4gICAgICAucmVzb2x2ZShmcm9tKVxuICAgICAgLm1hcmtzKClcbiAgICAgIC5mb3JFYWNoKG1hcmsgPT4ge1xuICAgICAgICBjb25zdCAkcG9zID0gZG9jLnJlc29sdmUoZnJvbSAtIDEpXG4gICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0TWFya1JhbmdlKCRwb3MsIG1hcmsudHlwZSlcblxuICAgICAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICBtYXJrLFxuICAgICAgICAgIC4uLnJhbmdlLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgfSBlbHNlIHtcbiAgICBkb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICBtYXJrcy5wdXNoKFxuICAgICAgICAuLi5ub2RlLm1hcmtzLm1hcChtYXJrID0+ICh7XG4gICAgICAgICAgZnJvbTogcG9zLFxuICAgICAgICAgIHRvOiBwb3MgKyBub2RlLm5vZGVTaXplLFxuICAgICAgICAgIG1hcmssXG4gICAgICAgIH0pKSxcbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIG1hcmtzXG59XG4iLCAiaW1wb3J0IHsgTm9kZSwgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBub2RlIG9mIGEgZ2l2ZW4gdHlwZSBvciBuYW1lIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqIEBwYXJhbSBzdGF0ZSBUaGUgZWRpdG9yIHN0YXRlLlxuICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIG5vZGUgdHlwZSBvciBuYW1lLlxuICogQHBhcmFtIHBvcyBUaGUgcG9zaXRpb24gdG8gc3RhcnQgc2VhcmNoaW5nIGZyb20uXG4gKiBAcGFyYW0gbWF4RGVwdGggVGhlIG1heGltdW0gZGVwdGggdG8gc2VhcmNoLlxuICogQHJldHVybnMgVGhlIG5vZGUgYW5kIHRoZSBkZXB0aCBhcyBhbiBhcnJheS5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldE5vZGVBdFBvc2l0aW9uID0gKHN0YXRlOiBFZGl0b3JTdGF0ZSwgdHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsIHBvczogbnVtYmVyLCBtYXhEZXB0aCA9IDIwKSA9PiB7XG4gIGNvbnN0ICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpXG5cbiAgbGV0IGN1cnJlbnREZXB0aCA9IG1heERlcHRoXG4gIGxldCBub2RlOiBOb2RlIHwgbnVsbCA9IG51bGxcblxuICB3aGlsZSAoY3VycmVudERlcHRoID4gMCAmJiBub2RlID09PSBudWxsKSB7XG4gICAgY29uc3QgY3VycmVudE5vZGUgPSAkcG9zLm5vZGUoY3VycmVudERlcHRoKVxuXG4gICAgaWYgKGN1cnJlbnROb2RlPy50eXBlLm5hbWUgPT09IHR5cGVPck5hbWUpIHtcbiAgICAgIG5vZGUgPSBjdXJyZW50Tm9kZVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50RGVwdGggLT0gMVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbbm9kZSwgY3VycmVudERlcHRoXSBhcyBbTm9kZSB8IG51bGwsIG51bWJlcl1cbn1cbiIsICJpbXBvcnQgeyBFeHRlbnNpb25BdHRyaWJ1dGUgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNwbGl0dGVkQXR0cmlidXRlcyhcbiAgZXh0ZW5zaW9uQXR0cmlidXRlczogRXh0ZW5zaW9uQXR0cmlidXRlW10sXG4gIHR5cGVOYW1lOiBzdHJpbmcsXG4gIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3RcbiAgICAuZW50cmllcyhhdHRyaWJ1dGVzKVxuICAgIC5maWx0ZXIoKFtuYW1lXSkgPT4ge1xuICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlID0gZXh0ZW5zaW9uQXR0cmlidXRlcy5maW5kKGl0ZW0gPT4ge1xuICAgICAgICByZXR1cm4gaXRlbS50eXBlID09PSB0eXBlTmFtZSAmJiBpdGVtLm5hbWUgPT09IG5hbWVcbiAgICAgIH0pXG5cbiAgICAgIGlmICghZXh0ZW5zaW9uQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXh0ZW5zaW9uQXR0cmlidXRlLmF0dHJpYnV0ZS5rZWVwT25TcGxpdFxuICAgIH0pKVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgTWFya1JhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBvYmplY3RJbmNsdWRlcyB9IGZyb20gJy4uL3V0aWxpdGllcy9vYmplY3RJbmNsdWRlcy5qcydcbmltcG9ydCB7IGdldE1hcmtUeXBlIH0gZnJvbSAnLi9nZXRNYXJrVHlwZS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTWFya0FjdGl2ZShcbiAgc3RhdGU6IEVkaXRvclN0YXRlLFxuICB0eXBlT3JOYW1lOiBNYXJrVHlwZSB8IHN0cmluZyB8IG51bGwsXG4gIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSxcbik6IGJvb2xlYW4ge1xuICBjb25zdCB7IGVtcHR5LCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvblxuICBjb25zdCB0eXBlID0gdHlwZU9yTmFtZSA/IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSkgOiBudWxsXG5cbiAgaWYgKGVtcHR5KSB7XG4gICAgcmV0dXJuICEhKHN0YXRlLnN0b3JlZE1hcmtzIHx8IHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKVxuICAgICAgLmZpbHRlcihtYXJrID0+IHtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09IG1hcmsudHlwZS5uYW1lXG4gICAgICB9KVxuICAgICAgLmZpbmQobWFyayA9PiBvYmplY3RJbmNsdWRlcyhtYXJrLmF0dHJzLCBhdHRyaWJ1dGVzLCB7IHN0cmljdDogZmFsc2UgfSkpXG4gIH1cblxuICBsZXQgc2VsZWN0aW9uUmFuZ2UgPSAwXG4gIGNvbnN0IG1hcmtSYW5nZXM6IE1hcmtSYW5nZVtdID0gW11cblxuICByYW5nZXMuZm9yRWFjaCgoeyAkZnJvbSwgJHRvIH0pID0+IHtcbiAgICBjb25zdCBmcm9tID0gJGZyb20ucG9zXG4gICAgY29uc3QgdG8gPSAkdG8ucG9zXG5cbiAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICBpZiAoIW5vZGUuaXNUZXh0ICYmICFub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVsYXRpdmVGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKVxuICAgICAgY29uc3QgcmVsYXRpdmVUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBub2RlLm5vZGVTaXplKVxuICAgICAgY29uc3QgcmFuZ2UgPSByZWxhdGl2ZVRvIC0gcmVsYXRpdmVGcm9tXG5cbiAgICAgIHNlbGVjdGlvblJhbmdlICs9IHJhbmdlXG5cbiAgICAgIG1hcmtSYW5nZXMucHVzaChcbiAgICAgICAgLi4ubm9kZS5tYXJrcy5tYXAobWFyayA9PiAoe1xuICAgICAgICAgIG1hcmssXG4gICAgICAgICAgZnJvbTogcmVsYXRpdmVGcm9tLFxuICAgICAgICAgIHRvOiByZWxhdGl2ZVRvLFxuICAgICAgICB9KSksXG4gICAgICApXG4gICAgfSlcbiAgfSlcblxuICBpZiAoc2VsZWN0aW9uUmFuZ2UgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSByYW5nZSBvZiBtYXRjaGVkIG1hcmtcbiAgY29uc3QgbWF0Y2hlZFJhbmdlID0gbWFya1Jhbmdlc1xuICAgIC5maWx0ZXIobWFya1JhbmdlID0+IHtcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZS5uYW1lID09PSBtYXJrUmFuZ2UubWFyay50eXBlLm5hbWVcbiAgICB9KVxuICAgIC5maWx0ZXIobWFya1JhbmdlID0+IG9iamVjdEluY2x1ZGVzKG1hcmtSYW5nZS5tYXJrLmF0dHJzLCBhdHRyaWJ1dGVzLCB7IHN0cmljdDogZmFsc2UgfSkpXG4gICAgLnJlZHVjZSgoc3VtLCBtYXJrUmFuZ2UpID0+IHN1bSArIG1hcmtSYW5nZS50byAtIG1hcmtSYW5nZS5mcm9tLCAwKVxuXG4gIC8vIGNhbGN1bGF0ZSByYW5nZSBvZiBtYXJrcyB0aGF0IGV4Y2x1ZGVzIHRoZSBzZWFyY2hlZCBtYXJrXG4gIC8vIGZvciBleGFtcGxlIGBjb2RlYCBkb2VzbuKAmXQgYWxsb3cgYW55IG90aGVyIG1hcmtzXG4gIGNvbnN0IGV4Y2x1ZGVkUmFuZ2UgPSBtYXJrUmFuZ2VzXG4gICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4ge1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXJrUmFuZ2UubWFyay50eXBlICE9PSB0eXBlICYmIG1hcmtSYW5nZS5tYXJrLnR5cGUuZXhjbHVkZXModHlwZSlcbiAgICB9KVxuICAgIC5yZWR1Y2UoKHN1bSwgbWFya1JhbmdlKSA9PiBzdW0gKyBtYXJrUmFuZ2UudG8gLSBtYXJrUmFuZ2UuZnJvbSwgMClcblxuICAvLyB3ZSBvbmx5IGluY2x1ZGUgdGhlIHJlc3VsdCBvZiBgZXhjbHVkZWRSYW5nZWBcbiAgLy8gaWYgdGhlcmUgaXMgYSBtYXRjaCBhdCBhbGxcbiAgY29uc3QgcmFuZ2UgPSBtYXRjaGVkUmFuZ2UgPiAwID8gbWF0Y2hlZFJhbmdlICsgZXhjbHVkZWRSYW5nZSA6IG1hdGNoZWRSYW5nZVxuXG4gIHJldHVybiByYW5nZSA+PSBzZWxlY3Rpb25SYW5nZVxufVxuIiwgImltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUgfSBmcm9tICcuL2dldFNjaGVtYVR5cGVOYW1lQnlOYW1lLmpzJ1xuaW1wb3J0IHsgaXNNYXJrQWN0aXZlIH0gZnJvbSAnLi9pc01hcmtBY3RpdmUuanMnXG5pbXBvcnQgeyBpc05vZGVBY3RpdmUgfSBmcm9tICcuL2lzTm9kZUFjdGl2ZS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQWN0aXZlKFxuICBzdGF0ZTogRWRpdG9yU3RhdGUsXG4gIG5hbWU6IHN0cmluZyB8IG51bGwsXG4gIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSxcbik6IGJvb2xlYW4ge1xuICBpZiAoIW5hbWUpIHtcbiAgICByZXR1cm4gaXNOb2RlQWN0aXZlKHN0YXRlLCBudWxsLCBhdHRyaWJ1dGVzKSB8fCBpc01hcmtBY3RpdmUoc3RhdGUsIG51bGwsIGF0dHJpYnV0ZXMpXG4gIH1cblxuICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUobmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcbiAgICByZXR1cm4gaXNOb2RlQWN0aXZlKHN0YXRlLCBuYW1lLCBhdHRyaWJ1dGVzKVxuICB9XG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09ICdtYXJrJykge1xuICAgIHJldHVybiBpc01hcmtBY3RpdmUoc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMpXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cbiIsICJpbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IGZpbmRQYXJlbnROb2RlIH0gZnJvbSAnLi9maW5kUGFyZW50Tm9kZS5qcydcblxuZXhwb3J0IGNvbnN0IGlzQXRFbmRPZk5vZGUgPSAoc3RhdGU6IEVkaXRvclN0YXRlLCBub2RlVHlwZT86IHN0cmluZykgPT4ge1xuICBjb25zdCB7ICRmcm9tLCAkdG8sICRhbmNob3IgfSA9IHN0YXRlLnNlbGVjdGlvblxuXG4gIGlmIChub2RlVHlwZSkge1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBmaW5kUGFyZW50Tm9kZShub2RlID0+IG5vZGUudHlwZS5uYW1lID09PSBub2RlVHlwZSkoc3RhdGUuc2VsZWN0aW9uKVxuXG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCAkcGFyZW50UG9zID0gc3RhdGUuZG9jLnJlc29sdmUocGFyZW50Tm9kZS5wb3MgKyAxKVxuXG4gICAgaWYgKCRhbmNob3IucG9zICsgMSA9PT0gJHBhcmVudFBvcy5lbmQoKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmICgkdG8ucGFyZW50T2Zmc2V0IDwgJHRvLnBhcmVudC5ub2RlU2l6ZSAtIDIgfHwgJGZyb20ucG9zICE9PSAkdG8ucG9zKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuZXhwb3J0IGNvbnN0IGlzQXRTdGFydE9mTm9kZSA9IChzdGF0ZTogRWRpdG9yU3RhdGUpID0+IHtcbiAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb25cblxuICBpZiAoJGZyb20ucGFyZW50T2Zmc2V0ID4gMCB8fCAkZnJvbS5wb3MgIT09ICR0by5wb3MpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgZ2V0RXh0ZW5zaW9uRmllbGQgfSBmcm9tICcuLi9oZWxwZXJzL2dldEV4dGVuc2lvbkZpZWxkLmpzJ1xuaW1wb3J0IHsgTm9kZUNvbmZpZyB9IGZyb20gJy4uL2luZGV4LmpzJ1xuaW1wb3J0IHsgRXh0ZW5zaW9ucyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcbmltcG9ydCB7IHNwbGl0RXh0ZW5zaW9ucyB9IGZyb20gJy4vc3BsaXRFeHRlbnNpb25zLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNMaXN0KG5hbWU6IHN0cmluZywgZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyk6IGJvb2xlYW4ge1xuICBjb25zdCB7IG5vZGVFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnMoZXh0ZW5zaW9ucylcbiAgY29uc3QgZXh0ZW5zaW9uID0gbm9kZUV4dGVuc2lvbnMuZmluZChpdGVtID0+IGl0ZW0ubmFtZSA9PT0gbmFtZSlcblxuICBpZiAoIWV4dGVuc2lvbikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgY29udGV4dCA9IHtcbiAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgfVxuICBjb25zdCBncm91cCA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydncm91cCddPihleHRlbnNpb24sICdncm91cCcsIGNvbnRleHQpKVxuXG4gIGlmICh0eXBlb2YgZ3JvdXAgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gZ3JvdXAuc3BsaXQoJyAnKS5pbmNsdWRlcygnbGlzdCcpXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNOb2RlRW1wdHkobm9kZTogUHJvc2VNaXJyb3JOb2RlKTogYm9vbGVhbiB7XG4gIGNvbnN0IGRlZmF1bHRDb250ZW50ID0gbm9kZS50eXBlLmNyZWF0ZUFuZEZpbGwoKT8udG9KU09OKClcbiAgY29uc3QgY29udGVudCA9IG5vZGUudG9KU09OKClcblxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGVmYXVsdENvbnRlbnQpID09PSBKU09OLnN0cmluZ2lmeShjb250ZW50KVxufVxuIiwgImltcG9ydCB7IE5vZGVTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNOb2RlU2VsZWN0aW9uKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgTm9kZVNlbGVjdGlvbiB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb25cbn1cbiIsICJpbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3J1xuXG5pbXBvcnQgeyBtaW5NYXggfSBmcm9tICcuLi91dGlsaXRpZXMvbWluTWF4LmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gcG9zVG9ET01SZWN0KHZpZXc6IEVkaXRvclZpZXcsIGZyb206IG51bWJlciwgdG86IG51bWJlcik6IERPTVJlY3Qge1xuICBjb25zdCBtaW5Qb3MgPSAwXG4gIGNvbnN0IG1heFBvcyA9IHZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZVxuICBjb25zdCByZXNvbHZlZEZyb20gPSBtaW5NYXgoZnJvbSwgbWluUG9zLCBtYXhQb3MpXG4gIGNvbnN0IHJlc29sdmVkRW5kID0gbWluTWF4KHRvLCBtaW5Qb3MsIG1heFBvcylcbiAgY29uc3Qgc3RhcnQgPSB2aWV3LmNvb3Jkc0F0UG9zKHJlc29sdmVkRnJvbSlcbiAgY29uc3QgZW5kID0gdmlldy5jb29yZHNBdFBvcyhyZXNvbHZlZEVuZCwgLTEpXG4gIGNvbnN0IHRvcCA9IE1hdGgubWluKHN0YXJ0LnRvcCwgZW5kLnRvcClcbiAgY29uc3QgYm90dG9tID0gTWF0aC5tYXgoc3RhcnQuYm90dG9tLCBlbmQuYm90dG9tKVxuICBjb25zdCBsZWZ0ID0gTWF0aC5taW4oc3RhcnQubGVmdCwgZW5kLmxlZnQpXG4gIGNvbnN0IHJpZ2h0ID0gTWF0aC5tYXgoc3RhcnQucmlnaHQsIGVuZC5yaWdodClcbiAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnRcbiAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wXG4gIGNvbnN0IHggPSBsZWZ0XG4gIGNvbnN0IHkgPSB0b3BcbiAgY29uc3QgZGF0YSA9IHtcbiAgICB0b3AsXG4gICAgYm90dG9tLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeSxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICB0b0pTT046ICgpID0+IGRhdGEsXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSwgUmVzb2x2ZWRQb3MgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUsIFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgZ2V0TWFya0F0dHJpYnV0ZXMgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtBdHRyaWJ1dGVzLmpzJ1xuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtUeXBlLmpzJ1xuaW1wb3J0IHsgaXNUZXh0U2VsZWN0aW9uIH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZXRNYXJrOiB7XG4gICAgICAvKipcbiAgICAgICAqIEFkZCBhIG1hcmsgd2l0aCBuZXcgYXR0cmlidXRlcy5cbiAgICAgICAqL1xuICAgICAgc2V0TWFyazogKHR5cGVPck5hbWU6IHN0cmluZyB8IE1hcmtUeXBlLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5TZXRNYXJrKHN0YXRlOiBFZGl0b3JTdGF0ZSwgdHI6IFRyYW5zYWN0aW9uLCBuZXdNYXJrVHlwZTogTWFya1R5cGUpIHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyXG4gIGxldCBjdXJzb3I6IFJlc29sdmVkUG9zIHwgbnVsbCA9IG51bGxcblxuICBpZiAoaXNUZXh0U2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjdXJzb3IgPSBzZWxlY3Rpb24uJGN1cnNvclxuICB9XG5cbiAgaWYgKGN1cnNvcikge1xuICAgIGNvbnN0IGN1cnJlbnRNYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzID8/IGN1cnNvci5tYXJrcygpXG5cbiAgICAvLyBUaGVyZSBjYW4gYmUgbm8gY3VycmVudCBtYXJrcyB0aGF0IGV4Y2x1ZGUgdGhlIG5ldyBtYXJrXG4gICAgcmV0dXJuIChcbiAgICAgICEhbmV3TWFya1R5cGUuaXNJblNldChjdXJyZW50TWFya3MpXG4gICAgICB8fCAhY3VycmVudE1hcmtzLnNvbWUobWFyayA9PiBtYXJrLnR5cGUuZXhjbHVkZXMobmV3TWFya1R5cGUpKVxuICAgIClcbiAgfVxuXG4gIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb25cblxuICByZXR1cm4gcmFuZ2VzLnNvbWUoKHsgJGZyb20sICR0byB9KSA9PiB7XG4gICAgbGV0IHNvbWVOb2RlU3VwcG9ydHNNYXJrID0gJGZyb20uZGVwdGggPT09IDBcbiAgICAgID8gc3RhdGUuZG9jLmlubGluZUNvbnRlbnQgJiYgc3RhdGUuZG9jLnR5cGUuYWxsb3dzTWFya1R5cGUobmV3TWFya1R5cGUpXG4gICAgICA6IGZhbHNlXG5cbiAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKCRmcm9tLnBvcywgJHRvLnBvcywgKG5vZGUsIF9wb3MsIHBhcmVudCkgPT4ge1xuICAgICAgLy8gSWYgd2UgYWxyZWFkeSBmb3VuZCBhIG1hcmsgdGhhdCB3ZSBjYW4gZW5hYmxlLCByZXR1cm4gZmFsc2UgdG8gYnlwYXNzIHRoZSByZW1haW5pbmcgc2VhcmNoXG4gICAgICBpZiAoc29tZU5vZGVTdXBwb3J0c01hcmspIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLmlzSW5saW5lKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEFsbG93c01hcmtUeXBlID0gIXBhcmVudCB8fCBwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZShuZXdNYXJrVHlwZSlcbiAgICAgICAgY29uc3QgY3VycmVudE1hcmtzQWxsb3dNYXJrVHlwZSA9ICEhbmV3TWFya1R5cGUuaXNJblNldChub2RlLm1hcmtzKVxuICAgICAgICAgIHx8ICFub2RlLm1hcmtzLnNvbWUob3RoZXJNYXJrID0+IG90aGVyTWFyay50eXBlLmV4Y2x1ZGVzKG5ld01hcmtUeXBlKSlcblxuICAgICAgICBzb21lTm9kZVN1cHBvcnRzTWFyayA9IHBhcmVudEFsbG93c01hcmtUeXBlICYmIGN1cnJlbnRNYXJrc0FsbG93TWFya1R5cGVcbiAgICAgIH1cbiAgICAgIHJldHVybiAhc29tZU5vZGVTdXBwb3J0c01hcmtcbiAgICB9KVxuXG4gICAgcmV0dXJuIHNvbWVOb2RlU3VwcG9ydHNNYXJrXG4gIH0pXG59XG5leHBvcnQgY29uc3Qgc2V0TWFyazogUmF3Q29tbWFuZHNbJ3NldE1hcmsnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHJcbiAgY29uc3QgeyBlbXB0eSwgcmFuZ2VzIH0gPSBzZWxlY3Rpb25cbiAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBpZiAoZW1wdHkpIHtcbiAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBnZXRNYXJrQXR0cmlidXRlcyhzdGF0ZSwgdHlwZSlcblxuICAgICAgdHIuYWRkU3RvcmVkTWFyayhcbiAgICAgICAgdHlwZS5jcmVhdGUoe1xuICAgICAgICAgIC4uLm9sZEF0dHJpYnV0ZXMsXG4gICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgfSksXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHJhbmdlLiRmcm9tLnBvc1xuICAgICAgICBjb25zdCB0byA9IHJhbmdlLiR0by5wb3NcblxuICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgY29uc3QgdHJpbW1lZEZyb20gPSBNYXRoLm1heChwb3MsIGZyb20pXG4gICAgICAgICAgY29uc3QgdHJpbW1lZFRvID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pXG4gICAgICAgICAgY29uc3Qgc29tZUhhc01hcmsgPSBub2RlLm1hcmtzLmZpbmQobWFyayA9PiBtYXJrLnR5cGUgPT09IHR5cGUpXG5cbiAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgbWFyayBvZiB0aGlzIHR5cGVcbiAgICAgICAgICAvLyB3ZSBrbm93IHRoYXQgd2UgaGF2ZSB0byBtZXJnZSBpdHMgYXR0cmlidXRlc1xuICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBhZGQgYSBmcmVzaCBuZXcgbWFya1xuICAgICAgICAgIGlmIChzb21lSGFzTWFyaykge1xuICAgICAgICAgICAgbm9kZS5tYXJrcy5mb3JFYWNoKG1hcmsgPT4ge1xuICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgICAgdHIuYWRkTWFyayhcbiAgICAgICAgICAgICAgICAgIHRyaW1tZWRGcm9tLFxuICAgICAgICAgICAgICAgICAgdHJpbW1lZFRvLFxuICAgICAgICAgICAgICAgICAgdHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAuLi5tYXJrLmF0dHJzLFxuICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ci5hZGRNYXJrKHRyaW1tZWRGcm9tLCB0cmltbWVkVG8sIHR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNhblNldE1hcmsoc3RhdGUsIHRyLCB0eXBlKVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZXRNZXRhOiB7XG4gICAgICAvKipcbiAgICAgICAqIFN0b3JlIGEgbWV0YWRhdGEgcHJvcGVydHkgaW4gdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24uXG4gICAgICAgKi9cbiAgICAgIHNldE1ldGE6IChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNldE1ldGE6IFJhd0NvbW1hbmRzWydzZXRNZXRhJ10gPSAoa2V5LCB2YWx1ZSkgPT4gKHsgdHIgfSkgPT4ge1xuICB0ci5zZXRNZXRhKGtleSwgdmFsdWUpXG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBzZXRCbG9ja1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2V0Tm9kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBSZXBsYWNlIGEgZ2l2ZW4gcmFuZ2Ugd2l0aCBhIG5vZGUuXG4gICAgICAgKi9cbiAgICAgIHNldE5vZGU6ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNldE5vZGU6IFJhd0NvbW1hbmRzWydzZXROb2RlJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2gsIGNoYWluIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcblxuICAvLyBUT0RPOiB1c2UgYSBmYWxsYmFjayBsaWtlIGluc2VydENvbnRlbnQ/XG4gIGlmICghdHlwZS5pc1RleHRibG9jaykge1xuICAgIGNvbnNvbGUud2FybignW3RpcHRhcCB3YXJuXTogQ3VycmVudGx5IFwic2V0Tm9kZSgpXCIgb25seSBzdXBwb3J0cyB0ZXh0IGJsb2NrIG5vZGVzLicpXG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgY2hhaW4oKVxuICAgIC8vIHRyeSB0byBjb252ZXJ0IG5vZGUgdG8gZGVmYXVsdCBub2RlIGlmIG5lZWRlZFxuICAgICAgLmNvbW1hbmQoKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICBjb25zdCBjYW5TZXRCbG9jayA9IHNldEJsb2NrVHlwZSh0eXBlLCBhdHRyaWJ1dGVzKShzdGF0ZSlcblxuICAgICAgICBpZiAoY2FuU2V0QmxvY2spIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKVxuICAgICAgfSlcbiAgICAgIC5jb21tYW5kKCh7IHN0YXRlOiB1cGRhdGVkU3RhdGUgfSkgPT4ge1xuICAgICAgICByZXR1cm4gc2V0QmxvY2tUeXBlKHR5cGUsIGF0dHJpYnV0ZXMpKHVwZGF0ZWRTdGF0ZSwgZGlzcGF0Y2gpXG4gICAgICB9KVxuICAgICAgLnJ1bigpXG4gIClcbn1cbiIsICJpbXBvcnQgeyBOb2RlU2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG1pbk1heCB9IGZyb20gJy4uL3V0aWxpdGllcy9taW5NYXguanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZXROb2RlU2VsZWN0aW9uOiB7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBOb2RlU2VsZWN0aW9uLlxuICAgICAgICovXG4gICAgICBzZXROb2RlU2VsZWN0aW9uOiAocG9zaXRpb246IG51bWJlcikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2V0Tm9kZVNlbGVjdGlvbjogUmF3Q29tbWFuZHNbJ3NldE5vZGVTZWxlY3Rpb24nXSA9IHBvc2l0aW9uID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHsgZG9jIH0gPSB0clxuICAgIGNvbnN0IGZyb20gPSBtaW5NYXgocG9zaXRpb24sIDAsIGRvYy5jb250ZW50LnNpemUpXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gTm9kZVNlbGVjdGlvbi5jcmVhdGUoZG9jLCBmcm9tKVxuXG4gICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbilcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IFJhbmdlLCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgbWluTWF4IH0gZnJvbSAnLi4vdXRpbGl0aWVzL21pbk1heC5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNldFRleHRTZWxlY3Rpb246IHtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIFRleHRTZWxlY3Rpb24uXG4gICAgICAgKi9cbiAgICAgIHNldFRleHRTZWxlY3Rpb246IChwb3NpdGlvbjogbnVtYmVyIHwgUmFuZ2UpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNldFRleHRTZWxlY3Rpb246IFJhd0NvbW1hbmRzWydzZXRUZXh0U2VsZWN0aW9uJ10gPSBwb3NpdGlvbiA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCB7IGRvYyB9ID0gdHJcbiAgICBjb25zdCB7IGZyb20sIHRvIH0gPSB0eXBlb2YgcG9zaXRpb24gPT09ICdudW1iZXInID8geyBmcm9tOiBwb3NpdGlvbiwgdG86IHBvc2l0aW9uIH0gOiBwb3NpdGlvblxuICAgIGNvbnN0IG1pblBvcyA9IFRleHRTZWxlY3Rpb24uYXRTdGFydChkb2MpLmZyb21cbiAgICBjb25zdCBtYXhQb3MgPSBUZXh0U2VsZWN0aW9uLmF0RW5kKGRvYykudG9cbiAgICBjb25zdCByZXNvbHZlZEZyb20gPSBtaW5NYXgoZnJvbSwgbWluUG9zLCBtYXhQb3MpXG4gICAgY29uc3QgcmVzb2x2ZWRFbmQgPSBtaW5NYXgodG8sIG1pblBvcywgbWF4UG9zKVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgcmVzb2x2ZWRGcm9tLCByZXNvbHZlZEVuZClcblxuICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IHNpbmtMaXN0SXRlbSBhcyBvcmlnaW5hbFNpbmtMaXN0SXRlbSB9IGZyb20gJ0B0aXB0YXAvcG0vc2NoZW1hLWxpc3QnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzaW5rTGlzdEl0ZW06IHtcbiAgICAgIC8qKlxuICAgICAgICogU2luayB0aGUgbGlzdCBpdGVtIGRvd24gaW50byBhbiBpbm5lciBsaXN0LlxuICAgICAgICovXG4gICAgICBzaW5rTGlzdEl0ZW06ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2lua0xpc3RJdGVtOiBSYXdDb21tYW5kc1snc2lua0xpc3RJdGVtJ10gPSB0eXBlT3JOYW1lID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgcmV0dXJuIG9yaWdpbmFsU2lua0xpc3RJdGVtKHR5cGUpKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBFZGl0b3JTdGF0ZSwgTm9kZVNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBjYW5TcGxpdCB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG5pbXBvcnQgeyBkZWZhdWx0QmxvY2tBdCB9IGZyb20gJy4uL2hlbHBlcnMvZGVmYXVsdEJsb2NrQXQuanMnXG5pbXBvcnQgeyBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMgfSBmcm9tICcuLi9oZWxwZXJzL2dldFNwbGl0dGVkQXR0cmlidXRlcy5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmZ1bmN0aW9uIGVuc3VyZU1hcmtzKHN0YXRlOiBFZGl0b3JTdGF0ZSwgc3BsaXR0YWJsZU1hcmtzPzogc3RyaW5nW10pIHtcbiAgY29uc3QgbWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcyB8fCAoc3RhdGUuc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpXG5cbiAgaWYgKG1hcmtzKSB7XG4gICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcz8uaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKVxuXG4gICAgc3RhdGUudHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcylcbiAgfVxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc3BsaXRCbG9jazoge1xuICAgICAgLyoqXG4gICAgICAgKiBGb3JrcyBhIG5ldyBub2RlIGZyb20gYW4gZXhpc3Rpbmcgbm9kZS5cbiAgICAgICAqL1xuICAgICAgc3BsaXRCbG9jazogKG9wdGlvbnM/OiB7IGtlZXBNYXJrcz86IGJvb2xlYW4gfSkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc3BsaXRCbG9jazogUmF3Q29tbWFuZHNbJ3NwbGl0QmxvY2snXSA9ICh7IGtlZXBNYXJrcyA9IHRydWUgfSA9IHt9KSA9PiAoe1xuICB0ciwgc3RhdGUsIGRpc3BhdGNoLCBlZGl0b3IsXG59KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHRyXG4gIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc2VsZWN0aW9uXG4gIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5hdHRyaWJ1dGVzXG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoXG4gICAgZXh0ZW5zaW9uQXR0cmlidXRlcyxcbiAgICAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLFxuICAgICRmcm9tLm5vZGUoKS5hdHRycyxcbiAgKVxuXG4gIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHNlbGVjdGlvbi5ub2RlLmlzQmxvY2spIHtcbiAgICBpZiAoISRmcm9tLnBhcmVudE9mZnNldCB8fCAhY2FuU3BsaXQoZG9jLCAkZnJvbS5wb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGlmIChrZWVwTWFya3MpIHtcbiAgICAgICAgZW5zdXJlTWFya3Moc3RhdGUsIGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLnNwbGl0dGFibGVNYXJrcylcbiAgICAgIH1cblxuICAgICAgdHIuc3BsaXQoJGZyb20ucG9zKS5zY3JvbGxJbnRvVmlldygpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmICghJGZyb20ucGFyZW50LmlzQmxvY2spIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IGF0RW5kID0gJHRvLnBhcmVudE9mZnNldCA9PT0gJHRvLnBhcmVudC5jb250ZW50LnNpemVcblxuICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICB0ci5kZWxldGVTZWxlY3Rpb24oKVxuICAgIH1cblxuICAgIGNvbnN0IGRlZmx0ID0gJGZyb20uZGVwdGggPT09IDBcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IGRlZmF1bHRCbG9ja0F0KCRmcm9tLm5vZGUoLTEpLmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4QWZ0ZXIoLTEpKSlcblxuICAgIGxldCB0eXBlcyA9IGF0RW5kICYmIGRlZmx0XG4gICAgICA/IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IGRlZmx0LFxuICAgICAgICAgIGF0dHJzOiBuZXdBdHRyaWJ1dGVzLFxuICAgICAgICB9LFxuICAgICAgXVxuICAgICAgOiB1bmRlZmluZWRcblxuICAgIGxldCBjYW4gPSBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKVxuXG4gICAgaWYgKFxuICAgICAgIXR5cGVzXG4gICAgICAgICYmICFjYW5cbiAgICAgICAgJiYgY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCBkZWZsdCA/IFt7IHR5cGU6IGRlZmx0IH1dIDogdW5kZWZpbmVkKVxuICAgICkge1xuICAgICAgY2FuID0gdHJ1ZVxuICAgICAgdHlwZXMgPSBkZWZsdFxuICAgICAgICA/IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBkZWZsdCxcbiAgICAgICAgICAgIGF0dHJzOiBuZXdBdHRyaWJ1dGVzLFxuICAgICAgICAgIH0sXG4gICAgICAgIF1cbiAgICAgICAgOiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAoY2FuKSB7XG4gICAgICB0ci5zcGxpdCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcylcblxuICAgICAgaWYgKGRlZmx0ICYmICFhdEVuZCAmJiAhJGZyb20ucGFyZW50T2Zmc2V0ICYmICRmcm9tLnBhcmVudC50eXBlICE9PSBkZWZsdCkge1xuICAgICAgICBjb25zdCBmaXJzdCA9IHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKVxuICAgICAgICBjb25zdCAkZmlyc3QgPSB0ci5kb2MucmVzb2x2ZShmaXJzdClcblxuICAgICAgICBpZiAoJGZyb20ubm9kZSgtMSkuY2FuUmVwbGFjZVdpdGgoJGZpcnN0LmluZGV4KCksICRmaXJzdC5pbmRleCgpICsgMSwgZGVmbHQpKSB7XG4gICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSksIGRlZmx0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtlZXBNYXJrcykge1xuICAgICAgZW5zdXJlTWFya3Moc3RhdGUsIGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLnNwbGl0dGFibGVNYXJrcylcbiAgICB9XG5cbiAgICB0ci5zY3JvbGxJbnRvVmlldygpXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7XG4gIEZyYWdtZW50LCBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgTm9kZVR5cGUsIFNsaWNlLFxufSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBjYW5TcGxpdCB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMgfSBmcm9tICcuLi9oZWxwZXJzL2dldFNwbGl0dGVkQXR0cmlidXRlcy5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzcGxpdExpc3RJdGVtOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNwbGl0cyBvbmUgbGlzdCBpdGVtIGludG8gdHdvIGxpc3QgaXRlbXMuXG4gICAgICAgKi9cbiAgICAgIHNwbGl0TGlzdEl0ZW06ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc3BsaXRMaXN0SXRlbTogUmF3Q29tbWFuZHNbJ3NwbGl0TGlzdEl0ZW0nXSA9IHR5cGVPck5hbWUgPT4gKHtcbiAgdHIsIHN0YXRlLCBkaXNwYXRjaCwgZWRpdG9yLFxufSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvblxuXG4gIC8vIEB0cy1pZ25vcmVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgY29uc3Qgbm9kZTogUHJvc2VNaXJyb3JOb2RlID0gc3RhdGUuc2VsZWN0aW9uLm5vZGVcblxuICBpZiAoKG5vZGUgJiYgbm9kZS5pc0Jsb2NrKSB8fCAkZnJvbS5kZXB0aCA8IDIgfHwgISRmcm9tLnNhbWVQYXJlbnQoJHRvKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgZ3JhbmRQYXJlbnQgPSAkZnJvbS5ub2RlKC0xKVxuXG4gIGlmIChncmFuZFBhcmVudC50eXBlICE9PSB0eXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuYXR0cmlidXRlc1xuXG4gIGlmICgkZnJvbS5wYXJlbnQuY29udGVudC5zaXplID09PSAwICYmICRmcm9tLm5vZGUoLTEpLmNoaWxkQ291bnQgPT09ICRmcm9tLmluZGV4QWZ0ZXIoLTEpKSB7XG4gICAgLy8gSW4gYW4gZW1wdHkgYmxvY2suIElmIHRoaXMgaXMgYSBuZXN0ZWQgbGlzdCwgdGhlIHdyYXBwaW5nXG4gICAgLy8gbGlzdCBpdGVtIHNob3VsZCBiZSBzcGxpdC4gT3RoZXJ3aXNlLCBiYWlsIG91dCBhbmQgbGV0IG5leHRcbiAgICAvLyBjb21tYW5kIGhhbmRsZSBsaWZ0aW5nLlxuICAgIGlmIChcbiAgICAgICRmcm9tLmRlcHRoID09PSAyXG4gICAgICAgIHx8ICRmcm9tLm5vZGUoLTMpLnR5cGUgIT09IHR5cGVcbiAgICAgICAgfHwgJGZyb20uaW5kZXgoLTIpICE9PSAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50IC0gMVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBsZXQgd3JhcCA9IEZyYWdtZW50LmVtcHR5XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgY29uc3QgZGVwdGhCZWZvcmUgPSAkZnJvbS5pbmRleCgtMSkgPyAxIDogJGZyb20uaW5kZXgoLTIpID8gMiA6IDNcblxuICAgICAgLy8gQnVpbGQgYSBmcmFnbWVudCBjb250YWluaW5nIGVtcHR5IHZlcnNpb25zIG9mIHRoZSBzdHJ1Y3R1cmVcbiAgICAgIC8vIGZyb20gdGhlIG91dGVyIGxpc3QgaXRlbSB0byB0aGUgcGFyZW50IG5vZGUgb2YgdGhlIGN1cnNvclxuICAgICAgZm9yIChsZXQgZCA9ICRmcm9tLmRlcHRoIC0gZGVwdGhCZWZvcmU7IGQgPj0gJGZyb20uZGVwdGggLSAzOyBkIC09IDEpIHtcbiAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KHdyYXApKVxuICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgY29uc3QgZGVwdGhBZnRlciA9ICRmcm9tLmluZGV4QWZ0ZXIoLTEpIDwgJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCA/IDEgOiAkZnJvbS5pbmRleEFmdGVyKC0yKSA8ICRmcm9tLm5vZGUoLTMpLmNoaWxkQ291bnQgPyAyIDogM1xuXG4gICAgICAvLyBBZGQgYSBzZWNvbmQgbGlzdCBpdGVtIHdpdGggYW4gZW1wdHkgZGVmYXVsdCBzdGFydCBub2RlXG4gICAgICBjb25zdCBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgPSBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoXG4gICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMsXG4gICAgICAgICRmcm9tLm5vZGUoKS50eXBlLm5hbWUsXG4gICAgICAgICRmcm9tLm5vZGUoKS5hdHRycyxcbiAgICAgIClcbiAgICAgIGNvbnN0IG5leHRUeXBlID0gdHlwZS5jb250ZW50TWF0Y2guZGVmYXVsdFR5cGU/LmNyZWF0ZUFuZEZpbGwobmV3TmV4dFR5cGVBdHRyaWJ1dGVzKSB8fCB1bmRlZmluZWRcblxuICAgICAgd3JhcCA9IHdyYXAuYXBwZW5kKEZyYWdtZW50LmZyb20odHlwZS5jcmVhdGVBbmRGaWxsKG51bGwsIG5leHRUeXBlKSB8fCB1bmRlZmluZWQpKVxuXG4gICAgICBjb25zdCBzdGFydCA9ICRmcm9tLmJlZm9yZSgkZnJvbS5kZXB0aCAtIChkZXB0aEJlZm9yZSAtIDEpKVxuXG4gICAgICB0ci5yZXBsYWNlKHN0YXJ0LCAkZnJvbS5hZnRlcigtZGVwdGhBZnRlciksIG5ldyBTbGljZSh3cmFwLCA0IC0gZGVwdGhCZWZvcmUsIDApKVxuXG4gICAgICBsZXQgc2VsID0gLTFcblxuICAgICAgdHIuZG9jLm5vZGVzQmV0d2VlbihzdGFydCwgdHIuZG9jLmNvbnRlbnQuc2l6ZSwgKG4sIHBvcykgPT4ge1xuICAgICAgICBpZiAoc2VsID4gLTEpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuLmlzVGV4dGJsb2NrICYmIG4uY29udGVudC5zaXplID09PSAwKSB7XG4gICAgICAgICAgc2VsID0gcG9zICsgMVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBpZiAoc2VsID4gLTEpIHtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShzZWwpKSlcbiAgICAgIH1cblxuICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBuZXh0VHlwZSA9ICR0by5wb3MgPT09ICRmcm9tLmVuZCgpID8gZ3JhbmRQYXJlbnQuY29udGVudE1hdGNoQXQoMCkuZGVmYXVsdFR5cGUgOiBudWxsXG5cbiAgY29uc3QgbmV3VHlwZUF0dHJpYnV0ZXMgPSBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoXG4gICAgZXh0ZW5zaW9uQXR0cmlidXRlcyxcbiAgICBncmFuZFBhcmVudC50eXBlLm5hbWUsXG4gICAgZ3JhbmRQYXJlbnQuYXR0cnMsXG4gIClcbiAgY29uc3QgbmV3TmV4dFR5cGVBdHRyaWJ1dGVzID0gZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKFxuICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMsXG4gICAgJGZyb20ubm9kZSgpLnR5cGUubmFtZSxcbiAgICAkZnJvbS5ub2RlKCkuYXR0cnMsXG4gIClcblxuICB0ci5kZWxldGUoJGZyb20ucG9zLCAkdG8ucG9zKVxuXG4gIGNvbnN0IHR5cGVzID0gbmV4dFR5cGVcbiAgICA/IFtcbiAgICAgIHsgdHlwZSwgYXR0cnM6IG5ld1R5cGVBdHRyaWJ1dGVzIH0sXG4gICAgICB7IHR5cGU6IG5leHRUeXBlLCBhdHRyczogbmV3TmV4dFR5cGVBdHRyaWJ1dGVzIH0sXG4gICAgXVxuICAgIDogW3sgdHlwZSwgYXR0cnM6IG5ld1R5cGVBdHRyaWJ1dGVzIH1dXG5cbiAgaWYgKCFjYW5TcGxpdCh0ci5kb2MsICRmcm9tLnBvcywgMikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGVcbiAgICBjb25zdCB7IHNwbGl0dGFibGVNYXJrcyB9ID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXJcbiAgICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSlcblxuICAgIHRyLnNwbGl0KCRmcm9tLnBvcywgMiwgdHlwZXMpLnNjcm9sbEludG9WaWV3KClcblxuICAgIGlmICghbWFya3MgfHwgIWRpc3BhdGNoKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKVxuXG4gICAgdHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcylcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgY2FuSm9pbiB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG5pbXBvcnQgeyBmaW5kUGFyZW50Tm9kZSB9IGZyb20gJy4uL2hlbHBlcnMvZmluZFBhcmVudE5vZGUuanMnXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBpc0xpc3QgfSBmcm9tICcuLi9oZWxwZXJzL2lzTGlzdC5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmNvbnN0IGpvaW5MaXN0QmFja3dhcmRzID0gKHRyOiBUcmFuc2FjdGlvbiwgbGlzdFR5cGU6IE5vZGVUeXBlKTogYm9vbGVhbiA9PiB7XG4gIGNvbnN0IGxpc3QgPSBmaW5kUGFyZW50Tm9kZShub2RlID0+IG5vZGUudHlwZSA9PT0gbGlzdFR5cGUpKHRyLnNlbGVjdGlvbilcblxuICBpZiAoIWxpc3QpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3QgYmVmb3JlID0gdHIuZG9jLnJlc29sdmUoTWF0aC5tYXgoMCwgbGlzdC5wb3MgLSAxKSkuYmVmb3JlKGxpc3QuZGVwdGgpXG5cbiAgaWYgKGJlZm9yZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNvbnN0IG5vZGVCZWZvcmUgPSB0ci5kb2Mubm9kZUF0KGJlZm9yZSlcbiAgY29uc3QgY2FuSm9pbkJhY2t3YXJkcyA9IGxpc3Qubm9kZS50eXBlID09PSBub2RlQmVmb3JlPy50eXBlICYmIGNhbkpvaW4odHIuZG9jLCBsaXN0LnBvcylcblxuICBpZiAoIWNhbkpvaW5CYWNrd2FyZHMpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgdHIuam9pbihsaXN0LnBvcylcblxuICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBqb2luTGlzdEZvcndhcmRzID0gKHRyOiBUcmFuc2FjdGlvbiwgbGlzdFR5cGU6IE5vZGVUeXBlKTogYm9vbGVhbiA9PiB7XG4gIGNvbnN0IGxpc3QgPSBmaW5kUGFyZW50Tm9kZShub2RlID0+IG5vZGUudHlwZSA9PT0gbGlzdFR5cGUpKHRyLnNlbGVjdGlvbilcblxuICBpZiAoIWxpc3QpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3QgYWZ0ZXIgPSB0ci5kb2MucmVzb2x2ZShsaXN0LnN0YXJ0KS5hZnRlcihsaXN0LmRlcHRoKVxuXG4gIGlmIChhZnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNvbnN0IG5vZGVBZnRlciA9IHRyLmRvYy5ub2RlQXQoYWZ0ZXIpXG4gIGNvbnN0IGNhbkpvaW5Gb3J3YXJkcyA9IGxpc3Qubm9kZS50eXBlID09PSBub2RlQWZ0ZXI/LnR5cGUgJiYgY2FuSm9pbih0ci5kb2MsIGFmdGVyKVxuXG4gIGlmICghY2FuSm9pbkZvcndhcmRzKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHRyLmpvaW4oYWZ0ZXIpXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHRvZ2dsZUxpc3Q6IHtcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGxpc3QgdHlwZXMuXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUxpc3Q6IChsaXN0VHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsIGl0ZW1UeXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwga2VlcE1hcmtzPzogYm9vbGVhbiwgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IFJldHVyblR5cGU7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVMaXN0OiBSYXdDb21tYW5kc1sndG9nZ2xlTGlzdCddID0gKGxpc3RUeXBlT3JOYW1lLCBpdGVtVHlwZU9yTmFtZSwga2VlcE1hcmtzLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7XG4gIGVkaXRvciwgdHIsIHN0YXRlLCBkaXNwYXRjaCwgY2hhaW4sIGNvbW1hbmRzLCBjYW4sXG59KSA9PiB7XG4gIGNvbnN0IHsgZXh0ZW5zaW9ucywgc3BsaXR0YWJsZU1hcmtzIH0gPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlclxuICBjb25zdCBsaXN0VHlwZSA9IGdldE5vZGVUeXBlKGxpc3RUeXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IGl0ZW1UeXBlID0gZ2V0Tm9kZVR5cGUoaXRlbVR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZVxuICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHNlbGVjdGlvblxuICBjb25zdCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKVxuXG4gIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKVxuXG4gIGlmICghcmFuZ2UpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IHBhcmVudExpc3QgPSBmaW5kUGFyZW50Tm9kZShub2RlID0+IGlzTGlzdChub2RlLnR5cGUubmFtZSwgZXh0ZW5zaW9ucykpKHNlbGVjdGlvbilcblxuICBpZiAocmFuZ2UuZGVwdGggPj0gMSAmJiBwYXJlbnRMaXN0ICYmIHJhbmdlLmRlcHRoIC0gcGFyZW50TGlzdC5kZXB0aCA8PSAxKSB7XG4gICAgLy8gcmVtb3ZlIGxpc3RcbiAgICBpZiAocGFyZW50TGlzdC5ub2RlLnR5cGUgPT09IGxpc3RUeXBlKSB7XG4gICAgICByZXR1cm4gY29tbWFuZHMubGlmdExpc3RJdGVtKGl0ZW1UeXBlKVxuICAgIH1cblxuICAgIC8vIGNoYW5nZSBsaXN0IHR5cGVcbiAgICBpZiAoXG4gICAgICBpc0xpc3QocGFyZW50TGlzdC5ub2RlLnR5cGUubmFtZSwgZXh0ZW5zaW9ucylcbiAgICAgICAgJiYgbGlzdFR5cGUudmFsaWRDb250ZW50KHBhcmVudExpc3Qubm9kZS5jb250ZW50KVxuICAgICAgICAmJiBkaXNwYXRjaFxuICAgICkge1xuICAgICAgcmV0dXJuIGNoYWluKClcbiAgICAgICAgLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocGFyZW50TGlzdC5wb3MsIGxpc3RUeXBlKVxuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSlcbiAgICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RCYWNrd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RGb3J3YXJkcyh0ciwgbGlzdFR5cGUpKVxuICAgICAgICAucnVuKClcbiAgICB9XG4gIH1cbiAgaWYgKCFrZWVwTWFya3MgfHwgIW1hcmtzIHx8ICFkaXNwYXRjaCkge1xuXG4gICAgcmV0dXJuIGNoYWluKClcbiAgICAgIC8vIHRyeSB0byBjb252ZXJ0IG5vZGUgdG8gZGVmYXVsdCBub2RlIGlmIG5lZWRlZFxuICAgICAgLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICBjb25zdCBjYW5XcmFwSW5MaXN0ID0gY2FuKCkud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcylcblxuICAgICAgICBpZiAoY2FuV3JhcEluTGlzdCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpXG4gICAgICB9KVxuICAgICAgLndyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJpYnV0ZXMpXG4gICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEJhY2t3YXJkcyh0ciwgbGlzdFR5cGUpKVxuICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RGb3J3YXJkcyh0ciwgbGlzdFR5cGUpKVxuICAgICAgLnJ1bigpXG4gIH1cblxuICByZXR1cm4gKFxuICAgIGNoYWluKClcbiAgICAvLyB0cnkgdG8gY29udmVydCBub2RlIHRvIGRlZmF1bHQgbm9kZSBpZiBuZWVkZWRcbiAgICAgIC5jb21tYW5kKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2FuV3JhcEluTGlzdCA9IGNhbigpLndyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgICAgICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpXG5cbiAgICAgICAgdHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcylcblxuICAgICAgICBpZiAoY2FuV3JhcEluTGlzdCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpXG4gICAgICB9KVxuICAgICAgLndyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJpYnV0ZXMpXG4gICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEJhY2t3YXJkcyh0ciwgbGlzdFR5cGUpKVxuICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RGb3J3YXJkcyh0ciwgbGlzdFR5cGUpKVxuICAgICAgLnJ1bigpXG4gIClcbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE1hcmtUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrVHlwZS5qcydcbmltcG9ydCB7IGlzTWFya0FjdGl2ZSB9IGZyb20gJy4uL2hlbHBlcnMvaXNNYXJrQWN0aXZlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHRvZ2dsZU1hcms6IHtcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGEgbWFyayBvbiBhbmQgb2ZmLlxuICAgICAgICovXG4gICAgICB0b2dnbGVNYXJrOiAoXG4gICAgICAgIHR5cGVPck5hbWU6IHN0cmluZyB8IE1hcmtUeXBlLFxuICAgICAgICBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PixcbiAgICAgICAgb3B0aW9ucz86IHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBSZW1vdmVzIHRoZSBtYXJrIGV2ZW4gYWNyb3NzIHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBleHRlbmRFbXB0eU1hcmtSYW5nZT86IGJvb2xlYW5cbiAgICAgICAgfSxcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdG9nZ2xlTWFyazogUmF3Q29tbWFuZHNbJ3RvZ2dsZU1hcmsnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30sIG9wdGlvbnMgPSB7fSkgPT4gKHsgc3RhdGUsIGNvbW1hbmRzIH0pID0+IHtcbiAgY29uc3QgeyBleHRlbmRFbXB0eU1hcmtSYW5nZSA9IGZhbHNlIH0gPSBvcHRpb25zXG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IGlzQWN0aXZlID0gaXNNYXJrQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKVxuXG4gIGlmIChpc0FjdGl2ZSkge1xuICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodHlwZSwgeyBleHRlbmRFbXB0eU1hcmtSYW5nZSB9KVxuICB9XG5cbiAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodHlwZSwgYXR0cmlidXRlcylcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGlzTm9kZUFjdGl2ZSB9IGZyb20gJy4uL2hlbHBlcnMvaXNOb2RlQWN0aXZlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHRvZ2dsZU5vZGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGEgbm9kZSB3aXRoIGFub3RoZXIgbm9kZS5cbiAgICAgICAqL1xuICAgICAgdG9nZ2xlTm9kZTogKFxuICAgICAgICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSxcbiAgICAgICAgdG9nZ2xlVHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsXG4gICAgICAgIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVOb2RlOiBSYXdDb21tYW5kc1sndG9nZ2xlTm9kZSddID0gKHR5cGVPck5hbWUsIHRvZ2dsZVR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGNvbW1hbmRzIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgdG9nZ2xlVHlwZSA9IGdldE5vZGVUeXBlKHRvZ2dsZVR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgaXNBY3RpdmUgPSBpc05vZGVBY3RpdmUoc3RhdGUsIHR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgaWYgKGlzQWN0aXZlKSB7XG4gICAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodG9nZ2xlVHlwZSlcbiAgfVxuXG4gIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHR5cGUsIGF0dHJpYnV0ZXMpXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBpc05vZGVBY3RpdmUgfSBmcm9tICcuLi9oZWxwZXJzL2lzTm9kZUFjdGl2ZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB0b2dnbGVXcmFwOiB7XG4gICAgICAvKipcbiAgICAgICAqIFdyYXBzIG5vZGVzIGluIGFub3RoZXIgbm9kZSwgb3IgcmVtb3ZlcyBhbiBleGlzdGluZyB3cmFwLlxuICAgICAgICovXG4gICAgICB0b2dnbGVXcmFwOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVXcmFwOiBSYXdDb21tYW5kc1sndG9nZ2xlV3JhcCddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGNvbW1hbmRzIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgaXNBY3RpdmUgPSBpc05vZGVBY3RpdmUoc3RhdGUsIHR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgaWYgKGlzQWN0aXZlKSB7XG4gICAgcmV0dXJuIGNvbW1hbmRzLmxpZnQodHlwZSlcbiAgfVxuXG4gIHJldHVybiBjb21tYW5kcy53cmFwSW4odHlwZSwgYXR0cmlidXRlcylcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdW5kb0lucHV0UnVsZToge1xuICAgICAgLyoqXG4gICAgICAgKiBVbmRvIGFuIGlucHV0IHJ1bGUuXG4gICAgICAgKi9cbiAgICAgIHVuZG9JbnB1dFJ1bGU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB1bmRvSW5wdXRSdWxlOiBSYXdDb21tYW5kc1sndW5kb0lucHV0UnVsZSddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgcGx1Z2lucyA9IHN0YXRlLnBsdWdpbnNcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBwbHVnaW4gPSBwbHVnaW5zW2ldXG4gICAgbGV0IHVuZG9hYmxlXG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgaWYgKHBsdWdpbi5zcGVjLmlzSW5wdXRSdWxlcyAmJiAodW5kb2FibGUgPSBwbHVnaW4uZ2V0U3RhdGUoc3RhdGUpKSkge1xuICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGNvbnN0IHRyID0gc3RhdGUudHJcbiAgICAgICAgY29uc3QgdG9VbmRvID0gdW5kb2FibGUudHJhbnNmb3JtXG5cbiAgICAgICAgZm9yIChsZXQgaiA9IHRvVW5kby5zdGVwcy5sZW5ndGggLSAxOyBqID49IDA7IGogLT0gMSkge1xuICAgICAgICAgIHRyLnN0ZXAodG9VbmRvLnN0ZXBzW2pdLmludmVydCh0b1VuZG8uZG9jc1tqXSkpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodW5kb2FibGUudGV4dCkge1xuICAgICAgICAgIGNvbnN0IG1hcmtzID0gdHIuZG9jLnJlc29sdmUodW5kb2FibGUuZnJvbSkubWFya3MoKVxuXG4gICAgICAgICAgdHIucmVwbGFjZVdpdGgodW5kb2FibGUuZnJvbSwgdW5kb2FibGUudG8sIHN0YXRlLnNjaGVtYS50ZXh0KHVuZG9hYmxlLnRleHQsIG1hcmtzKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ci5kZWxldGUodW5kb2FibGUuZnJvbSwgdW5kb2FibGUudG8pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdW5zZXRBbGxNYXJrczoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgYWxsIG1hcmtzIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgICAqL1xuICAgICAgdW5zZXRBbGxNYXJrczogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHVuc2V0QWxsTWFya3M6IFJhd0NvbW1hbmRzWyd1bnNldEFsbE1hcmtzJ10gPSAoKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHJcbiAgY29uc3QgeyBlbXB0eSwgcmFuZ2VzIH0gPSBzZWxlY3Rpb25cblxuICBpZiAoZW1wdHkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgcmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgdHIucmVtb3ZlTWFyayhyYW5nZS4kZnJvbS5wb3MsIHJhbmdlLiR0by5wb3MpXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXRNYXJrUmFuZ2UgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtSYW5nZS5qcydcbmltcG9ydCB7IGdldE1hcmtUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrVHlwZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB1bnNldE1hcms6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIGFsbCBtYXJrcyBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgKi9cbiAgICAgIHVuc2V0TWFyazogKFxuICAgICAgICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBNYXJrVHlwZSxcbiAgICAgICAgb3B0aW9ucz86IHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBSZW1vdmVzIHRoZSBtYXJrIGV2ZW4gYWNyb3NzIHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBleHRlbmRFbXB0eU1hcmtSYW5nZT86IGJvb2xlYW5cbiAgICAgICAgfSxcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdW5zZXRNYXJrOiBSYXdDb21tYW5kc1sndW5zZXRNYXJrJ10gPSAodHlwZU9yTmFtZSwgb3B0aW9ucyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBleHRlbmRFbXB0eU1hcmtSYW5nZSA9IGZhbHNlIH0gPSBvcHRpb25zXG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0clxuICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCB7ICRmcm9tLCBlbXB0eSwgcmFuZ2VzIH0gPSBzZWxlY3Rpb25cblxuICBpZiAoIWRpc3BhdGNoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChlbXB0eSAmJiBleHRlbmRFbXB0eU1hcmtSYW5nZSkge1xuICAgIGxldCB7IGZyb20sIHRvIH0gPSBzZWxlY3Rpb25cbiAgICBjb25zdCBhdHRycyA9ICRmcm9tLm1hcmtzKCkuZmluZChtYXJrID0+IG1hcmsudHlwZSA9PT0gdHlwZSk/LmF0dHJzXG4gICAgY29uc3QgcmFuZ2UgPSBnZXRNYXJrUmFuZ2UoJGZyb20sIHR5cGUsIGF0dHJzKVxuXG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICBmcm9tID0gcmFuZ2UuZnJvbVxuICAgICAgdG8gPSByYW5nZS50b1xuICAgIH1cblxuICAgIHRyLnJlbW92ZU1hcmsoZnJvbSwgdG8sIHR5cGUpXG4gIH0gZWxzZSB7XG4gICAgcmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgdHIucmVtb3ZlTWFyayhyYW5nZS4kZnJvbS5wb3MsIHJhbmdlLiR0by5wb3MsIHR5cGUpXG4gICAgfSlcbiAgfVxuXG4gIHRyLnJlbW92ZVN0b3JlZE1hcmsodHlwZSlcblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlLCBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE1hcmtUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrVHlwZS5qcydcbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lIH0gZnJvbSAnLi4vaGVscGVycy9nZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB1cGRhdGVBdHRyaWJ1dGVzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFVwZGF0ZSBhdHRyaWJ1dGVzIG9mIGEgbm9kZSBvciBtYXJrLlxuICAgICAgICovXG4gICAgICB1cGRhdGVBdHRyaWJ1dGVzOiAoXG4gICAgICAgIHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlIHwgTWFya1R5cGUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUF0dHJpYnV0ZXM6IFJhd0NvbW1hbmRzWyd1cGRhdGVBdHRyaWJ1dGVzJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgbGV0IG5vZGVUeXBlOiBOb2RlVHlwZSB8IG51bGwgPSBudWxsXG4gIGxldCBtYXJrVHlwZTogTWFya1R5cGUgfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShcbiAgICB0eXBlb2YgdHlwZU9yTmFtZSA9PT0gJ3N0cmluZycgPyB0eXBlT3JOYW1lIDogdHlwZU9yTmFtZS5uYW1lLFxuICAgIHN0YXRlLnNjaGVtYSxcbiAgKVxuXG4gIGlmICghc2NoZW1hVHlwZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09ICdub2RlJykge1xuICAgIG5vZGVUeXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSBhcyBOb2RlVHlwZSwgc3RhdGUuc2NoZW1hKVxuICB9XG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09ICdtYXJrJykge1xuICAgIG1hcmtUeXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSBhcyBNYXJrVHlwZSwgc3RhdGUuc2NoZW1hKVxuICB9XG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdHIuc2VsZWN0aW9uLnJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgIGNvbnN0IGZyb20gPSByYW5nZS4kZnJvbS5wb3NcbiAgICAgIGNvbnN0IHRvID0gcmFuZ2UuJHRvLnBvc1xuXG4gICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XG4gICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgLi4ubm9kZS5hdHRycyxcbiAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXJrVHlwZSAmJiBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgIG5vZGUubWFya3MuZm9yRWFjaChtYXJrID0+IHtcbiAgICAgICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRGcm9tID0gTWF0aC5tYXgocG9zLCBmcm9tKVxuICAgICAgICAgICAgICBjb25zdCB0cmltbWVkVG8gPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0bylcblxuICAgICAgICAgICAgICB0ci5hZGRNYXJrKFxuICAgICAgICAgICAgICAgIHRyaW1tZWRGcm9tLFxuICAgICAgICAgICAgICAgIHRyaW1tZWRUbyxcbiAgICAgICAgICAgICAgICBtYXJrVHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgLi4ubWFyay5hdHRycyxcbiAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IHdyYXBJbiBhcyBvcmlnaW5hbFdyYXBJbiB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5pbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB3cmFwSW46IHtcbiAgICAgIC8qKlxuICAgICAgICogV3JhcHMgbm9kZXMgaW4gYW5vdGhlciBub2RlLlxuICAgICAgICovXG4gICAgICB3cmFwSW46ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHdyYXBJbjogUmF3Q29tbWFuZHNbJ3dyYXBJbiddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcblxuICByZXR1cm4gb3JpZ2luYWxXcmFwSW4odHlwZSwgYXR0cmlidXRlcykoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IHdyYXBJbkxpc3QgYXMgb3JpZ2luYWxXcmFwSW5MaXN0IH0gZnJvbSAnQHRpcHRhcC9wbS9zY2hlbWEtbGlzdCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHdyYXBJbkxpc3Q6IHtcbiAgICAgIC8qKlxuICAgICAgICogV3JhcCBhIG5vZGUgaW4gYSBsaXN0LlxuICAgICAgICovXG4gICAgICB3cmFwSW5MaXN0OiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB3cmFwSW5MaXN0OiBSYXdDb21tYW5kc1snd3JhcEluTGlzdCddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcblxuICByZXR1cm4gb3JpZ2luYWxXcmFwSW5MaXN0KHR5cGUsIGF0dHJpYnV0ZXMpKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgKiBhcyBjb21tYW5kcyBmcm9tICcuLi9jb21tYW5kcy9pbmRleC5qcydcbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcblxuZXhwb3J0ICogZnJvbSAnLi4vY29tbWFuZHMvaW5kZXguanMnXG5cbmV4cG9ydCBjb25zdCBDb21tYW5kcyA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAnY29tbWFuZHMnLFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jb21tYW5kcyxcbiAgICB9XG4gIH0sXG59KVxuIiwgImltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnLi4vRXh0ZW5zaW9uLmpzJ1xuXG5leHBvcnQgY29uc3QgRWRpdGFibGUgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogJ2VkaXRhYmxlJyxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2VkaXRhYmxlJyksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgZWRpdGFibGU6ICgpID0+IHRoaXMuZWRpdG9yLm9wdGlvbnMuZWRpdGFibGUsXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnLi4vRXh0ZW5zaW9uLmpzJ1xuXG5leHBvcnQgY29uc3QgRm9jdXNFdmVudHMgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogJ2ZvY3VzRXZlbnRzJyxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXNcblxuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdmb2N1c0V2ZW50cycpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgZm9jdXM6ICh2aWV3LCBldmVudDogRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgZWRpdG9yLmlzRm9jdXNlZCA9IHRydWVcblxuICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGVkaXRvci5zdGF0ZS50clxuICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdmb2N1cycsIHsgZXZlbnQgfSlcbiAgICAgICAgICAgICAgICAuc2V0TWV0YSgnYWRkVG9IaXN0b3J5JywgZmFsc2UpXG5cbiAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbilcblxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibHVyOiAodmlldywgZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGVkaXRvci5pc0ZvY3VzZWQgPSBmYWxzZVxuXG4gICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZWRpdG9yLnN0YXRlLnRyXG4gICAgICAgICAgICAgICAgLnNldE1ldGEoJ2JsdXInLCB7IGV2ZW50IH0pXG4gICAgICAgICAgICAgICAgLnNldE1ldGEoJ2FkZFRvSGlzdG9yeScsIGZhbHNlKVxuXG4gICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHJhbnNhY3Rpb24pXG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5LCBTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBDb21tYW5kTWFuYWdlciB9IGZyb20gJy4uL0NvbW1hbmRNYW5hZ2VyLmpzJ1xuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnLi4vRXh0ZW5zaW9uLmpzJ1xuaW1wb3J0IHsgY3JlYXRlQ2hhaW5hYmxlU3RhdGUgfSBmcm9tICcuLi9oZWxwZXJzL2NyZWF0ZUNoYWluYWJsZVN0YXRlLmpzJ1xuaW1wb3J0IHsgaXNpT1MgfSBmcm9tICcuLi91dGlsaXRpZXMvaXNpT1MuanMnXG5pbXBvcnQgeyBpc01hY09TIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2lzTWFjT1MuanMnXG5cbmV4cG9ydCBjb25zdCBLZXltYXAgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogJ2tleW1hcCcsXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgY29uc3QgaGFuZGxlQmFja3NwYWNlID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZmlyc3QoKHsgY29tbWFuZHMgfSkgPT4gW1xuICAgICAgKCkgPT4gY29tbWFuZHMudW5kb0lucHV0UnVsZSgpLFxuXG4gICAgICAvLyBtYXliZSBjb252ZXJ0IGZpcnN0IHRleHQgYmxvY2sgbm9kZSB0byBkZWZhdWx0IG5vZGVcbiAgICAgICgpID0+IGNvbW1hbmRzLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgZG9jIH0gPSB0clxuICAgICAgICBjb25zdCB7IGVtcHR5LCAkYW5jaG9yIH0gPSBzZWxlY3Rpb25cbiAgICAgICAgY29uc3QgeyBwb3MsIHBhcmVudCB9ID0gJGFuY2hvclxuICAgICAgICBjb25zdCAkcGFyZW50UG9zID0gJGFuY2hvci5wYXJlbnQuaXNUZXh0YmxvY2sgPyB0ci5kb2MucmVzb2x2ZShwb3MgLSAxKSA6ICRhbmNob3JcbiAgICAgICAgY29uc3QgcGFyZW50SXNJc29sYXRpbmcgPSAkcGFyZW50UG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nXG5cbiAgICAgICAgY29uc3QgcGFyZW50UG9zID0gJGFuY2hvci5wb3MgLSAkYW5jaG9yLnBhcmVudE9mZnNldFxuXG4gICAgICAgIGNvbnN0IGlzQXRTdGFydCA9IChwYXJlbnRJc0lzb2xhdGluZyAmJiAkcGFyZW50UG9zLnBhcmVudC5jaGlsZENvdW50ID09PSAxKVxuICAgICAgICAgID8gcGFyZW50UG9zID09PSAkYW5jaG9yLnBvc1xuICAgICAgICAgIDogU2VsZWN0aW9uLmF0U3RhcnQoZG9jKS5mcm9tID09PSBwb3NcblxuICAgICAgICBpZiAoIWVtcHR5IHx8ICFpc0F0U3RhcnQgfHwgIXBhcmVudC50eXBlLmlzVGV4dGJsb2NrIHx8IHBhcmVudC50ZXh0Q29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKClcbiAgICAgIH0pLFxuXG4gICAgICAoKSA9PiBjb21tYW5kcy5kZWxldGVTZWxlY3Rpb24oKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLmpvaW5CYWNrd2FyZCgpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuc2VsZWN0Tm9kZUJhY2t3YXJkKCksXG4gICAgXSlcblxuICAgIGNvbnN0IGhhbmRsZURlbGV0ZSA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzIH0pID0+IFtcbiAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuZGVsZXRlQ3VycmVudE5vZGUoKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLmpvaW5Gb3J3YXJkKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5zZWxlY3ROb2RlRm9yd2FyZCgpLFxuICAgIF0pXG5cbiAgICBjb25zdCBoYW5kbGVFbnRlciA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzIH0pID0+IFtcbiAgICAgICgpID0+IGNvbW1hbmRzLm5ld2xpbmVJbkNvZGUoKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLmNyZWF0ZVBhcmFncmFwaE5lYXIoKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLmxpZnRFbXB0eUJsb2NrKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5zcGxpdEJsb2NrKCksXG4gICAgXSlcblxuICAgIGNvbnN0IGJhc2VLZXltYXAgPSB7XG4gICAgICBFbnRlcjogaGFuZGxlRW50ZXIsXG4gICAgICAnTW9kLUVudGVyJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZXhpdENvZGUoKSxcbiAgICAgIEJhY2tzcGFjZTogaGFuZGxlQmFja3NwYWNlLFxuICAgICAgJ01vZC1CYWNrc3BhY2UnOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAnU2hpZnQtQmFja3NwYWNlJzogaGFuZGxlQmFja3NwYWNlLFxuICAgICAgRGVsZXRlOiBoYW5kbGVEZWxldGUsXG4gICAgICAnTW9kLURlbGV0ZSc6IGhhbmRsZURlbGV0ZSxcbiAgICAgICdNb2QtYSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNlbGVjdEFsbCgpLFxuICAgIH1cblxuICAgIGNvbnN0IHBjS2V5bWFwID0ge1xuICAgICAgLi4uYmFzZUtleW1hcCxcbiAgICB9XG5cbiAgICBjb25zdCBtYWNLZXltYXAgPSB7XG4gICAgICAuLi5iYXNlS2V5bWFwLFxuICAgICAgJ0N0cmwtaCc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICdBbHQtQmFja3NwYWNlJzogaGFuZGxlQmFja3NwYWNlLFxuICAgICAgJ0N0cmwtZCc6IGhhbmRsZURlbGV0ZSxcbiAgICAgICdDdHJsLUFsdC1CYWNrc3BhY2UnOiBoYW5kbGVEZWxldGUsXG4gICAgICAnQWx0LURlbGV0ZSc6IGhhbmRsZURlbGV0ZSxcbiAgICAgICdBbHQtZCc6IGhhbmRsZURlbGV0ZSxcbiAgICAgICdDdHJsLWEnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZWxlY3RUZXh0YmxvY2tTdGFydCgpLFxuICAgICAgJ0N0cmwtZSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNlbGVjdFRleHRibG9ja0VuZCgpLFxuICAgIH1cblxuICAgIGlmIChpc2lPUygpIHx8IGlzTWFjT1MoKSkge1xuICAgICAgcmV0dXJuIG1hY0tleW1hcFxuICAgIH1cblxuICAgIHJldHVybiBwY0tleW1hcFxuICB9LFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLy8gV2l0aCB0aGlzIHBsdWdpbiB3ZSBjaGVjayBpZiB0aGUgd2hvbGUgZG9jdW1lbnQgd2FzIHNlbGVjdGVkIGFuZCBkZWxldGVkLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlIHdlIHdpbGwgYWRkaXRpb25hbGx5IGNhbGwgYGNsZWFyTm9kZXMoKWAgdG8gY29udmVydCBlLmcuIGEgaGVhZGluZ1xuICAgICAgLy8gdG8gYSBwYXJhZ3JhcGggaWYgbmVjZXNzYXJ5LlxuICAgICAgLy8gVGhpcyBpcyBhbiBhbHRlcm5hdGl2ZSB0byBQcm9zZU1pcnJvcidzIGBBbGxTZWxlY3Rpb25gLCB3aGljaCBkb2VzbuKAmXQgd29yayB3ZWxsXG4gICAgICAvLyB3aXRoIG1hbnkgb3RoZXIgY29tbWFuZHMuXG4gICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdjbGVhckRvY3VtZW50JyksXG4gICAgICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb25zLCBvbGRTdGF0ZSwgbmV3U3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCBkb2NDaGFuZ2VzID0gdHJhbnNhY3Rpb25zLnNvbWUodHJhbnNhY3Rpb24gPT4gdHJhbnNhY3Rpb24uZG9jQ2hhbmdlZClcbiAgICAgICAgICAgICYmICFvbGRTdGF0ZS5kb2MuZXEobmV3U3RhdGUuZG9jKVxuXG4gICAgICAgICAgaWYgKCFkb2NDaGFuZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7IGVtcHR5LCBmcm9tLCB0byB9ID0gb2xkU3RhdGUuc2VsZWN0aW9uXG4gICAgICAgICAgY29uc3QgYWxsRnJvbSA9IFNlbGVjdGlvbi5hdFN0YXJ0KG9sZFN0YXRlLmRvYykuZnJvbVxuICAgICAgICAgIGNvbnN0IGFsbEVuZCA9IFNlbGVjdGlvbi5hdEVuZChvbGRTdGF0ZS5kb2MpLnRvXG4gICAgICAgICAgY29uc3QgYWxsV2FzU2VsZWN0ZWQgPSBmcm9tID09PSBhbGxGcm9tICYmIHRvID09PSBhbGxFbmRcblxuICAgICAgICAgIGlmIChlbXB0eSB8fCAhYWxsV2FzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGlzRW1wdHkgPSBuZXdTdGF0ZS5kb2MudGV4dEJldHdlZW4oMCwgbmV3U3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSwgJyAnLCAnICcpLmxlbmd0aCA9PT0gMFxuXG4gICAgICAgICAgaWYgKCFpc0VtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB0ciA9IG5ld1N0YXRlLnRyXG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XG4gICAgICAgICAgICBzdGF0ZTogbmV3U3RhdGUsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgICAgICAgfSlcbiAgICAgICAgICBjb25zdCB7IGNvbW1hbmRzIH0gPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBjb21tYW5kcy5jbGVhck5vZGVzKClcblxuICAgICAgICAgIGlmICghdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5cbmV4cG9ydCBjb25zdCBUYWJpbmRleCA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAndGFiaW5kZXgnLFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgndGFiaW5kZXgnKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB0aGlzLmVkaXRvci5pc0VkaXRhYmxlID8geyB0YWJpbmRleDogJzAnIH0gOiB7fSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiZXhwb3J0IGNvbnN0IHN0eWxlID0gYC5Qcm9zZU1pcnJvciB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbn1cblxuLlByb3NlTWlycm9yIHtcbiAgd29yZC13cmFwOiBicmVhay13b3JkO1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG4gIHdoaXRlLXNwYWNlOiBicmVhay1zcGFjZXM7XG4gIC13ZWJraXQtZm9udC12YXJpYW50LWxpZ2F0dXJlczogbm9uZTtcbiAgZm9udC12YXJpYW50LWxpZ2F0dXJlczogbm9uZTtcbiAgZm9udC1mZWF0dXJlLXNldHRpbmdzOiBcImxpZ2FcIiAwOyAvKiB0aGUgYWJvdmUgZG9lc24ndCBzZWVtIHRvIHdvcmsgaW4gRWRnZSAqL1xufVxuXG4uUHJvc2VNaXJyb3IgW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdIHtcbiAgd2hpdGUtc3BhY2U6IG5vcm1hbDtcbn1cblxuLlByb3NlTWlycm9yIFtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXSBbY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiXSB7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbn1cblxuLlByb3NlTWlycm9yIHByZSB7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbn1cblxuaW1nLlByb3NlTWlycm9yLXNlcGFyYXRvciB7XG4gIGRpc3BsYXk6IGlubGluZSAhaW1wb3J0YW50O1xuICBib3JkZXI6IG5vbmUgIWltcG9ydGFudDtcbiAgbWFyZ2luOiAwICFpbXBvcnRhbnQ7XG4gIHdpZHRoOiAxcHggIWltcG9ydGFudDtcbiAgaGVpZ2h0OiAxcHggIWltcG9ydGFudDtcbn1cblxuLlByb3NlTWlycm9yLWdhcGN1cnNvciB7XG4gIGRpc3BsYXk6IG5vbmU7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIG1hcmdpbjogMDtcbn1cblxuLlByb3NlTWlycm9yLWdhcGN1cnNvcjphZnRlciB7XG4gIGNvbnRlbnQ6IFwiXCI7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogLTJweDtcbiAgd2lkdGg6IDIwcHg7XG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCBibGFjaztcbiAgYW5pbWF0aW9uOiBQcm9zZU1pcnJvci1jdXJzb3ItYmxpbmsgMS4xcyBzdGVwcygyLCBzdGFydCkgaW5maW5pdGU7XG59XG5cbkBrZXlmcmFtZXMgUHJvc2VNaXJyb3ItY3Vyc29yLWJsaW5rIHtcbiAgdG8ge1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgfVxufVxuXG4uUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvbiAqOjpzZWxlY3Rpb24ge1xuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbn1cblxuLlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb24gKjo6LW1vei1zZWxlY3Rpb24ge1xuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbn1cblxuLlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb24gKiB7XG4gIGNhcmV0LWNvbG9yOiB0cmFuc3BhcmVudDtcbn1cblxuLlByb3NlTWlycm9yLWZvY3VzZWQgLlByb3NlTWlycm9yLWdhcGN1cnNvciB7XG4gIGRpc3BsYXk6IGJsb2NrO1xufVxuXG4udGlwcHktYm94W2RhdGEtYW5pbWF0aW9uPWZhZGVdW2RhdGEtc3RhdGU9aGlkZGVuXSB7XG4gIG9wYWNpdHk6IDBcbn1gXG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlVGFnKHN0eWxlOiBzdHJpbmcsIG5vbmNlPzogc3RyaW5nLCBzdWZmaXg/OiBzdHJpbmcpOiBIVE1MU3R5bGVFbGVtZW50IHtcbiAgY29uc3QgdGlwdGFwU3R5bGVUYWcgPSAoPEhUTUxTdHlsZUVsZW1lbnQ+ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc3R5bGVbZGF0YS10aXB0YXAtc3R5bGUke3N1ZmZpeCA/IGAtJHtzdWZmaXh9YCA6ICcnfV1gKSlcblxuICBpZiAodGlwdGFwU3R5bGVUYWcgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdGlwdGFwU3R5bGVUYWdcbiAgfVxuXG4gIGNvbnN0IHN0eWxlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcblxuICBpZiAobm9uY2UpIHtcbiAgICBzdHlsZU5vZGUuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKVxuICB9XG5cbiAgc3R5bGVOb2RlLnNldEF0dHJpYnV0ZShgZGF0YS10aXB0YXAtc3R5bGUke3N1ZmZpeCA/IGAtJHtzdWZmaXh9YCA6ICcnfWAsICcnKVxuICBzdHlsZU5vZGUuaW5uZXJIVE1MID0gc3R5bGVcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzdHlsZU5vZGUpXG5cbiAgcmV0dXJuIHN0eWxlTm9kZVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlLCBOb2RlVHlwZSwgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7XG4gIEVkaXRvclN0YXRlLCBQbHVnaW4sIFBsdWdpbktleSwgVHJhbnNhY3Rpb24sXG59IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3J1xuXG5pbXBvcnQgeyBDb21tYW5kTWFuYWdlciB9IGZyb20gJy4vQ29tbWFuZE1hbmFnZXIuanMnXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuL0V2ZW50RW1pdHRlci5qcydcbmltcG9ydCB7IEV4dGVuc2lvbk1hbmFnZXIgfSBmcm9tICcuL0V4dGVuc2lvbk1hbmFnZXIuanMnXG5pbXBvcnQgKiBhcyBleHRlbnNpb25zIGZyb20gJy4vZXh0ZW5zaW9ucy9pbmRleC5qcydcbmltcG9ydCB7IGNyZWF0ZURvY3VtZW50IH0gZnJvbSAnLi9oZWxwZXJzL2NyZWF0ZURvY3VtZW50LmpzJ1xuaW1wb3J0IHsgZ2V0QXR0cmlidXRlcyB9IGZyb20gJy4vaGVscGVycy9nZXRBdHRyaWJ1dGVzLmpzJ1xuaW1wb3J0IHsgZ2V0SFRNTEZyb21GcmFnbWVudCB9IGZyb20gJy4vaGVscGVycy9nZXRIVE1MRnJvbUZyYWdtZW50LmpzJ1xuaW1wb3J0IHsgZ2V0VGV4dCB9IGZyb20gJy4vaGVscGVycy9nZXRUZXh0LmpzJ1xuaW1wb3J0IHsgZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSB9IGZyb20gJy4vaGVscGVycy9nZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hLmpzJ1xuaW1wb3J0IHsgaXNBY3RpdmUgfSBmcm9tICcuL2hlbHBlcnMvaXNBY3RpdmUuanMnXG5pbXBvcnQgeyBpc05vZGVFbXB0eSB9IGZyb20gJy4vaGVscGVycy9pc05vZGVFbXB0eS5qcydcbmltcG9ydCB7IHJlc29sdmVGb2N1c1Bvc2l0aW9uIH0gZnJvbSAnLi9oZWxwZXJzL3Jlc29sdmVGb2N1c1Bvc2l0aW9uLmpzJ1xuaW1wb3J0IHsgc3R5bGUgfSBmcm9tICcuL3N0eWxlLmpzJ1xuaW1wb3J0IHtcbiAgQ2FuQ29tbWFuZHMsXG4gIENoYWluZWRDb21tYW5kcyxcbiAgRWRpdG9yRXZlbnRzLFxuICBFZGl0b3JPcHRpb25zLFxuICBKU09OQ29udGVudCxcbiAgU2luZ2xlQ29tbWFuZHMsXG4gIFRleHRTZXJpYWxpemVyLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY3JlYXRlU3R5bGVUYWcgfSBmcm9tICcuL3V0aWxpdGllcy9jcmVhdGVTdHlsZVRhZy5qcydcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuL3V0aWxpdGllcy9pc0Z1bmN0aW9uLmpzJ1xuXG5leHBvcnQgeyBleHRlbnNpb25zIH1cblxuZXhwb3J0IGludGVyZmFjZSBIVE1MRWxlbWVudCB7XG4gIGVkaXRvcj86IEVkaXRvclxufVxuXG5leHBvcnQgY2xhc3MgRWRpdG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyPEVkaXRvckV2ZW50cz4ge1xuICBwcml2YXRlIGNvbW1hbmRNYW5hZ2VyITogQ29tbWFuZE1hbmFnZXJcblxuICBwdWJsaWMgZXh0ZW5zaW9uTWFuYWdlciE6IEV4dGVuc2lvbk1hbmFnZXJcblxuICBwcml2YXRlIGNzcyE6IEhUTUxTdHlsZUVsZW1lbnRcblxuICBwdWJsaWMgc2NoZW1hITogU2NoZW1hXG5cbiAgcHVibGljIHZpZXchOiBFZGl0b3JWaWV3XG5cbiAgcHVibGljIGlzRm9jdXNlZCA9IGZhbHNlXG5cbiAgcHVibGljIGV4dGVuc2lvblN0b3JhZ2U6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fVxuXG4gIHB1YmxpYyBvcHRpb25zOiBFZGl0b3JPcHRpb25zID0ge1xuICAgIGVsZW1lbnQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgIGNvbnRlbnQ6ICcnLFxuICAgIGluamVjdENTUzogdHJ1ZSxcbiAgICBpbmplY3ROb25jZTogdW5kZWZpbmVkLFxuICAgIGV4dGVuc2lvbnM6IFtdLFxuICAgIGF1dG9mb2N1czogZmFsc2UsXG4gICAgZWRpdGFibGU6IHRydWUsXG4gICAgZWRpdG9yUHJvcHM6IHt9LFxuICAgIHBhcnNlT3B0aW9uczoge30sXG4gICAgZW5hYmxlSW5wdXRSdWxlczogdHJ1ZSxcbiAgICBlbmFibGVQYXN0ZVJ1bGVzOiB0cnVlLFxuICAgIGVuYWJsZUNvcmVFeHRlbnNpb25zOiB0cnVlLFxuICAgIG9uQmVmb3JlQ3JlYXRlOiAoKSA9PiBudWxsLFxuICAgIG9uQ3JlYXRlOiAoKSA9PiBudWxsLFxuICAgIG9uVXBkYXRlOiAoKSA9PiBudWxsLFxuICAgIG9uU2VsZWN0aW9uVXBkYXRlOiAoKSA9PiBudWxsLFxuICAgIG9uVHJhbnNhY3Rpb246ICgpID0+IG51bGwsXG4gICAgb25Gb2N1czogKCkgPT4gbnVsbCxcbiAgICBvbkJsdXI6ICgpID0+IG51bGwsXG4gICAgb25EZXN0cm95OiAoKSA9PiBudWxsLFxuICB9XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogUGFydGlhbDxFZGl0b3JPcHRpb25zPiA9IHt9KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKVxuICAgIHRoaXMuY3JlYXRlRXh0ZW5zaW9uTWFuYWdlcigpXG4gICAgdGhpcy5jcmVhdGVDb21tYW5kTWFuYWdlcigpXG4gICAgdGhpcy5jcmVhdGVTY2hlbWEoKVxuICAgIHRoaXMub24oJ2JlZm9yZUNyZWF0ZScsIHRoaXMub3B0aW9ucy5vbkJlZm9yZUNyZWF0ZSlcbiAgICB0aGlzLmVtaXQoJ2JlZm9yZUNyZWF0ZScsIHsgZWRpdG9yOiB0aGlzIH0pXG4gICAgdGhpcy5jcmVhdGVWaWV3KClcbiAgICB0aGlzLmluamVjdENTUygpXG4gICAgdGhpcy5vbignY3JlYXRlJywgdGhpcy5vcHRpb25zLm9uQ3JlYXRlKVxuICAgIHRoaXMub24oJ3VwZGF0ZScsIHRoaXMub3B0aW9ucy5vblVwZGF0ZSlcbiAgICB0aGlzLm9uKCdzZWxlY3Rpb25VcGRhdGUnLCB0aGlzLm9wdGlvbnMub25TZWxlY3Rpb25VcGRhdGUpXG4gICAgdGhpcy5vbigndHJhbnNhY3Rpb24nLCB0aGlzLm9wdGlvbnMub25UcmFuc2FjdGlvbilcbiAgICB0aGlzLm9uKCdmb2N1cycsIHRoaXMub3B0aW9ucy5vbkZvY3VzKVxuICAgIHRoaXMub24oJ2JsdXInLCB0aGlzLm9wdGlvbnMub25CbHVyKVxuICAgIHRoaXMub24oJ2Rlc3Ryb3knLCB0aGlzLm9wdGlvbnMub25EZXN0cm95KVxuXG4gICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29tbWFuZHMuZm9jdXModGhpcy5vcHRpb25zLmF1dG9mb2N1cylcbiAgICAgIHRoaXMuZW1pdCgnY3JlYXRlJywgeyBlZGl0b3I6IHRoaXMgfSlcbiAgICB9LCAwKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVkaXRvciBzdG9yYWdlLlxuICAgKi9cbiAgcHVibGljIGdldCBzdG9yYWdlKCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgIHJldHVybiB0aGlzLmV4dGVuc2lvblN0b3JhZ2VcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBvYmplY3Qgb2YgYWxsIHJlZ2lzdGVyZWQgY29tbWFuZHMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGNvbW1hbmRzKCk6IFNpbmdsZUNvbW1hbmRzIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jb21tYW5kc1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNvbW1hbmQgY2hhaW4gdG8gY2FsbCBtdWx0aXBsZSBjb21tYW5kcyBhdCBvbmNlLlxuICAgKi9cbiAgcHVibGljIGNoYWluKCk6IENoYWluZWRDb21tYW5kcyB7XG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZE1hbmFnZXIuY2hhaW4oKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgY29tbWFuZCBvciBhIGNvbW1hbmQgY2hhaW4gY2FuIGJlIGV4ZWN1dGVkLiBXaXRob3V0IGV4ZWN1dGluZyBpdC5cbiAgICovXG4gIHB1YmxpYyBjYW4oKTogQ2FuQ29tbWFuZHMge1xuICAgIHJldHVybiB0aGlzLmNvbW1hbmRNYW5hZ2VyLmNhbigpXG4gIH1cblxuICAvKipcbiAgICogSW5qZWN0IENTUyBzdHlsZXMuXG4gICAqL1xuICBwcml2YXRlIGluamVjdENTUygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmluamVjdENTUyAmJiBkb2N1bWVudCkge1xuICAgICAgdGhpcy5jc3MgPSBjcmVhdGVTdHlsZVRhZyhzdHlsZSwgdGhpcy5vcHRpb25zLmluamVjdE5vbmNlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZWRpdG9yIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIEEgbGlzdCBvZiBvcHRpb25zXG4gICAqL1xuICBwdWJsaWMgc2V0T3B0aW9ucyhvcHRpb25zOiBQYXJ0aWFsPEVkaXRvck9wdGlvbnM+ID0ge30pOiB2b2lkIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH1cblxuICAgIGlmICghdGhpcy52aWV3IHx8ICF0aGlzLnN0YXRlIHx8IHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMpIHtcbiAgICAgIHRoaXMudmlldy5zZXRQcm9wcyh0aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMpXG4gICAgfVxuXG4gICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKHRoaXMuc3RhdGUpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGVkaXRhYmxlIHN0YXRlIG9mIHRoZSBlZGl0b3IuXG4gICAqL1xuICBwdWJsaWMgc2V0RWRpdGFibGUoZWRpdGFibGU6IGJvb2xlYW4sIGVtaXRVcGRhdGUgPSB0cnVlKTogdm9pZCB7XG4gICAgdGhpcy5zZXRPcHRpb25zKHsgZWRpdGFibGUgfSlcblxuICAgIGlmIChlbWl0VXBkYXRlKSB7XG4gICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHsgZWRpdG9yOiB0aGlzLCB0cmFuc2FjdGlvbjogdGhpcy5zdGF0ZS50ciB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVkaXRvciBpcyBlZGl0YWJsZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgaXNFZGl0YWJsZSgpOiBib29sZWFuIHtcbiAgICAvLyBzaW5jZSBwbHVnaW5zIGFyZSBhcHBsaWVkIGFmdGVyIGNyZWF0aW5nIHRoZSB2aWV3XG4gICAgLy8gYGVkaXRhYmxlYCBpcyBhbHdheXMgYHRydWVgIGZvciBvbmUgdGljay5cbiAgICAvLyB0aGF04oCZcyB3aHkgd2UgYWxzbyBoYXZlIHRvIGNoZWNrIGZvciBgb3B0aW9ucy5lZGl0YWJsZWBcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmVkaXRhYmxlICYmIHRoaXMudmlldyAmJiB0aGlzLnZpZXcuZWRpdGFibGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGl0b3Igc3RhdGUuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0YXRlKCk6IEVkaXRvclN0YXRlIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LnN0YXRlXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBQcm9zZU1pcnJvciBwbHVnaW4uXG4gICAqXG4gICAqIEBwYXJhbSBwbHVnaW4gQSBQcm9zZU1pcnJvciBwbHVnaW5cbiAgICogQHBhcmFtIGhhbmRsZVBsdWdpbnMgQ29udHJvbCBob3cgdG8gbWVyZ2UgdGhlIHBsdWdpbiBpbnRvIHRoZSBleGlzdGluZyBwbHVnaW5zLlxuICAgKi9cbiAgcHVibGljIHJlZ2lzdGVyUGx1Z2luKFxuICAgIHBsdWdpbjogUGx1Z2luLFxuICAgIGhhbmRsZVBsdWdpbnM/OiAobmV3UGx1Z2luOiBQbHVnaW4sIHBsdWdpbnM6IFBsdWdpbltdKSA9PiBQbHVnaW5bXSxcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgcGx1Z2lucyA9IGlzRnVuY3Rpb24oaGFuZGxlUGx1Z2lucylcbiAgICAgID8gaGFuZGxlUGx1Z2lucyhwbHVnaW4sIFsuLi50aGlzLnN0YXRlLnBsdWdpbnNdKVxuICAgICAgOiBbLi4udGhpcy5zdGF0ZS5wbHVnaW5zLCBwbHVnaW5dXG5cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUucmVjb25maWd1cmUoeyBwbHVnaW5zIH0pXG5cbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpXG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlciBhIFByb3NlTWlycm9yIHBsdWdpbi5cbiAgICpcbiAgICogQHBhcmFtIG5hbWVPclBsdWdpbktleSBUaGUgcGx1Z2lucyBuYW1lXG4gICAqL1xuICBwdWJsaWMgdW5yZWdpc3RlclBsdWdpbihuYW1lT3JQbHVnaW5LZXk6IHN0cmluZyB8IFBsdWdpbktleSk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgbmFtZSA9IHR5cGVvZiBuYW1lT3JQbHVnaW5LZXkgPT09ICdzdHJpbmcnID8gYCR7bmFtZU9yUGx1Z2luS2V5fSRgIDogbmFtZU9yUGx1Z2luS2V5LmtleVxuXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHBsdWdpbnM6IHRoaXMuc3RhdGUucGx1Z2lucy5maWx0ZXIocGx1Z2luID0+ICFwbHVnaW4ua2V5LnN0YXJ0c1dpdGgobmFtZSkpLFxuICAgIH0pXG5cbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBleHRlbnNpb24gbWFuYWdlci5cbiAgICovXG4gIHByaXZhdGUgY3JlYXRlRXh0ZW5zaW9uTWFuYWdlcigpOiB2b2lkIHtcbiAgICBjb25zdCBjb3JlRXh0ZW5zaW9ucyA9IHRoaXMub3B0aW9ucy5lbmFibGVDb3JlRXh0ZW5zaW9ucyA/IE9iamVjdC52YWx1ZXMoZXh0ZW5zaW9ucykgOiBbXVxuICAgIGNvbnN0IGFsbEV4dGVuc2lvbnMgPSBbLi4uY29yZUV4dGVuc2lvbnMsIC4uLnRoaXMub3B0aW9ucy5leHRlbnNpb25zXS5maWx0ZXIoZXh0ZW5zaW9uID0+IHtcbiAgICAgIHJldHVybiBbJ2V4dGVuc2lvbicsICdub2RlJywgJ21hcmsnXS5pbmNsdWRlcyhleHRlbnNpb24/LnR5cGUpXG4gICAgfSlcblxuICAgIHRoaXMuZXh0ZW5zaW9uTWFuYWdlciA9IG5ldyBFeHRlbnNpb25NYW5hZ2VyKGFsbEV4dGVuc2lvbnMsIHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBjb21tYW5kIG1hbmFnZXIuXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZUNvbW1hbmRNYW5hZ2VyKCk6IHZvaWQge1xuICAgIHRoaXMuY29tbWFuZE1hbmFnZXIgPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgICAgZWRpdG9yOiB0aGlzLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFByb3NlTWlycm9yIHNjaGVtYS5cbiAgICovXG4gIHByaXZhdGUgY3JlYXRlU2NoZW1hKCk6IHZvaWQge1xuICAgIHRoaXMuc2NoZW1hID0gdGhpcy5leHRlbnNpb25NYW5hZ2VyLnNjaGVtYVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQcm9zZU1pcnJvciB2aWV3LlxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVWaWV3KCk6IHZvaWQge1xuICAgIGNvbnN0IGRvYyA9IGNyZWF0ZURvY3VtZW50KHRoaXMub3B0aW9ucy5jb250ZW50LCB0aGlzLnNjaGVtYSwgdGhpcy5vcHRpb25zLnBhcnNlT3B0aW9ucylcbiAgICBjb25zdCBzZWxlY3Rpb24gPSByZXNvbHZlRm9jdXNQb3NpdGlvbihkb2MsIHRoaXMub3B0aW9ucy5hdXRvZm9jdXMpXG5cbiAgICB0aGlzLnZpZXcgPSBuZXcgRWRpdG9yVmlldyh0aGlzLm9wdGlvbnMuZWxlbWVudCwge1xuICAgICAgLi4udGhpcy5vcHRpb25zLmVkaXRvclByb3BzLFxuICAgICAgZGlzcGF0Y2hUcmFuc2FjdGlvbjogdGhpcy5kaXNwYXRjaFRyYW5zYWN0aW9uLmJpbmQodGhpcyksXG4gICAgICBzdGF0ZTogRWRpdG9yU3RhdGUuY3JlYXRlKHtcbiAgICAgICAgZG9jLFxuICAgICAgICBzZWxlY3Rpb246IHNlbGVjdGlvbiB8fCB1bmRlZmluZWQsXG4gICAgICB9KSxcbiAgICB9KVxuXG4gICAgLy8gYGVkaXRvci52aWV3YCBpcyBub3QgeWV0IGF2YWlsYWJsZSBhdCB0aGlzIHRpbWUuXG4gICAgLy8gVGhlcmVmb3JlIHdlIHdpbGwgYWRkIGFsbCBwbHVnaW5zIGFuZCBub2RlIHZpZXdzIGRpcmVjdGx5IGFmdGVyd2FyZHMuXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHtcbiAgICAgIHBsdWdpbnM6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5wbHVnaW5zLFxuICAgIH0pXG5cbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUobmV3U3RhdGUpXG5cbiAgICB0aGlzLmNyZWF0ZU5vZGVWaWV3cygpXG4gICAgdGhpcy5wcmVwZW5kQ2xhc3MoKVxuXG4gICAgLy8gTGV04oCZcyBzdG9yZSB0aGUgZWRpdG9yIGluc3RhbmNlIGluIHRoZSBET00gZWxlbWVudC5cbiAgICAvLyBTbyB3ZeKAmWxsIGhhdmUgYWNjZXNzIHRvIGl0IGZvciB0ZXN0cy5cbiAgICBjb25zdCBkb20gPSB0aGlzLnZpZXcuZG9tIGFzIEhUTUxFbGVtZW50XG5cbiAgICBkb20uZWRpdG9yID0gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYWxsIG5vZGUgdmlld3MuXG4gICAqL1xuICBwdWJsaWMgY3JlYXRlTm9kZVZpZXdzKCk6IHZvaWQge1xuICAgIHRoaXMudmlldy5zZXRQcm9wcyh7XG4gICAgICBub2RlVmlld3M6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5ub2RlVmlld3MsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwZW5kIGNsYXNzIG5hbWUgdG8gZWxlbWVudC5cbiAgICovXG4gIHB1YmxpYyBwcmVwZW5kQ2xhc3MoKTogdm9pZCB7XG4gICAgdGhpcy52aWV3LmRvbS5jbGFzc05hbWUgPSBgdGlwdGFwICR7dGhpcy52aWV3LmRvbS5jbGFzc05hbWV9YFxuICB9XG5cbiAgcHVibGljIGlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSBmYWxzZVxuXG4gIHByaXZhdGUgY2FwdHVyZWRUcmFuc2FjdGlvbjogVHJhbnNhY3Rpb24gfCBudWxsID0gbnVsbFxuXG4gIHB1YmxpYyBjYXB0dXJlVHJhbnNhY3Rpb24oZm46IEZ1bmN0aW9uKSB7XG4gICAgdGhpcy5pc0NhcHR1cmluZ1RyYW5zYWN0aW9uID0gdHJ1ZVxuICAgIGZuKClcbiAgICB0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSBmYWxzZVxuXG4gICAgY29uc3QgdHIgPSB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb25cblxuICAgIHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbiA9IG51bGxcblxuICAgIHJldHVybiB0clxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjYWxsYmFjayBvdmVyIHdoaWNoIHRvIHNlbmQgdHJhbnNhY3Rpb25zIChzdGF0ZSB1cGRhdGVzKSBwcm9kdWNlZCBieSB0aGUgdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uIEFuIGVkaXRvciBzdGF0ZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBkaXNwYXRjaFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbik6IHZvaWQge1xuICAgIC8vIGlmIHRoZSBlZGl0b3IgLyB0aGUgdmlldyBvZiB0aGUgZWRpdG9yIHdhcyBkZXN0cm95ZWRcbiAgICAvLyB0aGUgdHJhbnNhY3Rpb24gc2hvdWxkIG5vdCBiZSBkaXNwYXRjaGVkIGFzIHRoZXJlIGlzIG5vIHZpZXcgYW55bW9yZS5cbiAgICBpZiAodGhpcy52aWV3LmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0NhcHR1cmluZ1RyYW5zYWN0aW9uKSB7XG4gICAgICBpZiAoIXRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbikge1xuICAgICAgICB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvblxuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0cmFuc2FjdGlvbi5zdGVwcy5mb3JFYWNoKHN0ZXAgPT4gdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uPy5zdGVwKHN0ZXApKVxuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUuYXBwbHkodHJhbnNhY3Rpb24pXG4gICAgY29uc3Qgc2VsZWN0aW9uSGFzQ2hhbmdlZCA9ICF0aGlzLnN0YXRlLnNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pXG5cbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpXG4gICAgdGhpcy5lbWl0KCd0cmFuc2FjdGlvbicsIHtcbiAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgIH0pXG5cbiAgICBpZiAoc2VsZWN0aW9uSGFzQ2hhbmdlZCkge1xuICAgICAgdGhpcy5lbWl0KCdzZWxlY3Rpb25VcGRhdGUnLCB7XG4gICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IGZvY3VzID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgnZm9jdXMnKVxuICAgIGNvbnN0IGJsdXIgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCdibHVyJylcblxuICAgIGlmIChmb2N1cykge1xuICAgICAgdGhpcy5lbWl0KCdmb2N1cycsIHtcbiAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICBldmVudDogZm9jdXMuZXZlbnQsXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoYmx1cikge1xuICAgICAgdGhpcy5lbWl0KCdibHVyJywge1xuICAgICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICAgIGV2ZW50OiBibHVyLmV2ZW50LFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKCF0cmFuc2FjdGlvbi5kb2NDaGFuZ2VkIHx8IHRyYW5zYWN0aW9uLmdldE1ldGEoJ3ByZXZlbnRVcGRhdGUnKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB7XG4gICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhdHRyaWJ1dGVzIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZSBvciBtYXJrLlxuICAgKi9cbiAgcHVibGljIGdldEF0dHJpYnV0ZXMobmFtZU9yVHlwZTogc3RyaW5nIHwgTm9kZVR5cGUgfCBNYXJrVHlwZSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgIHJldHVybiBnZXRBdHRyaWJ1dGVzKHRoaXMuc3RhdGUsIG5hbWVPclR5cGUpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGUgb3IgbWFyayBpcyBhY3RpdmUuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIG5vZGUgb3IgbWFya1xuICAgKiBAcGFyYW0gYXR0cmlidXRlcyBBdHRyaWJ1dGVzIG9mIHRoZSBub2RlIG9yIG1hcmtcbiAgICovXG4gIHB1YmxpYyBpc0FjdGl2ZShuYW1lOiBzdHJpbmcsIGF0dHJpYnV0ZXM/OiB7fSk6IGJvb2xlYW5cbiAgcHVibGljIGlzQWN0aXZlKGF0dHJpYnV0ZXM6IHt9KTogYm9vbGVhblxuICBwdWJsaWMgaXNBY3RpdmUobmFtZU9yQXR0cmlidXRlczogc3RyaW5nLCBhdHRyaWJ1dGVzT3JVbmRlZmluZWQ/OiB7fSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbmFtZU9yQXR0cmlidXRlcyA9PT0gJ3N0cmluZycgPyBuYW1lT3JBdHRyaWJ1dGVzIDogbnVsbFxuXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHR5cGVvZiBuYW1lT3JBdHRyaWJ1dGVzID09PSAnc3RyaW5nJyA/IGF0dHJpYnV0ZXNPclVuZGVmaW5lZCA6IG5hbWVPckF0dHJpYnV0ZXNcblxuICAgIHJldHVybiBpc0FjdGl2ZSh0aGlzLnN0YXRlLCBuYW1lLCBhdHRyaWJ1dGVzKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyBnZXRKU09OKCk6IEpTT05Db250ZW50IHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5kb2MudG9KU09OKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRvY3VtZW50IGFzIEhUTUwuXG4gICAqL1xuICBwdWJsaWMgZ2V0SFRNTCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBnZXRIVE1MRnJvbUZyYWdtZW50KHRoaXMuc3RhdGUuZG9jLmNvbnRlbnQsIHRoaXMuc2NoZW1hKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgdGV4dC5cbiAgICovXG4gIHB1YmxpYyBnZXRUZXh0KG9wdGlvbnM/OiB7XG4gICAgYmxvY2tTZXBhcmF0b3I/OiBzdHJpbmdcbiAgICB0ZXh0U2VyaWFsaXplcnM/OiBSZWNvcmQ8c3RyaW5nLCBUZXh0U2VyaWFsaXplcj5cbiAgfSk6IHN0cmluZyB7XG4gICAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9ICdcXG5cXG4nLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgcmV0dXJuIGdldFRleHQodGhpcy5zdGF0ZS5kb2MsIHtcbiAgICAgIGJsb2NrU2VwYXJhdG9yLFxuICAgICAgdGV4dFNlcmlhbGl6ZXJzOiB7XG4gICAgICAgIC4uLmdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEodGhpcy5zY2hlbWEpLFxuICAgICAgICAuLi50ZXh0U2VyaWFsaXplcnMsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlcmUgaXMgbm8gY29udGVudC5cbiAgICovXG4gIHB1YmxpYyBnZXQgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNOb2RlRW1wdHkodGhpcy5zdGF0ZS5kb2MpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBmb3IgdGhlIGN1cnJlbnQgZG9jdW1lbnQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBwdWJsaWMgZ2V0Q2hhcmFjdGVyQ291bnQoKTogbnVtYmVyIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnW3RpcHRhcCB3YXJuXTogXCJlZGl0b3IuZ2V0Q2hhcmFjdGVyQ291bnQoKVwiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJlZGl0b3Iuc3RvcmFnZS5jaGFyYWN0ZXJDb3VudC5jaGFyYWN0ZXJzKClcIiBpbnN0ZWFkLicsXG4gICAgKVxuXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSAtIDJcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBlZGl0b3IuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knKVxuXG4gICAgaWYgKHRoaXMudmlldykge1xuICAgICAgdGhpcy52aWV3LmRlc3Ryb3koKVxuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZWRpdG9yIGlzIGFscmVhZHkgZGVzdHJveWVkLlxuICAgKi9cbiAgcHVibGljIGdldCBpc0Rlc3Ryb3llZCgpOiBib29sZWFuIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuICF0aGlzLnZpZXc/LmRvY1ZpZXdcbiAgfVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya3NCZXR3ZWVuIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrc0JldHdlZW4uanMnXG5pbXBvcnQgeyBJbnB1dFJ1bGUsIElucHV0UnVsZUZpbmRlciB9IGZyb20gJy4uL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIHRoYXQgYWRkcyBhIG1hcmsgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyB0eXBlZCBpbnRvIGl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFya0lucHV0UnVsZShjb25maWc6IHtcbiAgZmluZDogSW5wdXRSdWxlRmluZGVyXG4gIHR5cGU6IE1hcmtUeXBlXG4gIGdldEF0dHJpYnV0ZXM/OlxuICAgIHwgUmVjb3JkPHN0cmluZywgYW55PlxuICAgIHwgKChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5KSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgIHwgZmFsc2VcbiAgICB8IG51bGxcbn0pIHtcbiAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaClcblxuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGVcbiAgICAgIGNvbnN0IGNhcHR1cmVHcm91cCA9IG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdXG4gICAgICBjb25zdCBmdWxsTWF0Y2ggPSBtYXRjaFswXVxuXG4gICAgICBpZiAoY2FwdHVyZUdyb3VwKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0U3BhY2VzID0gZnVsbE1hdGNoLnNlYXJjaCgvXFxTLylcbiAgICAgICAgY29uc3QgdGV4dFN0YXJ0ID0gcmFuZ2UuZnJvbSArIGZ1bGxNYXRjaC5pbmRleE9mKGNhcHR1cmVHcm91cClcbiAgICAgICAgY29uc3QgdGV4dEVuZCA9IHRleHRTdGFydCArIGNhcHR1cmVHcm91cC5sZW5ndGhcblxuICAgICAgICBjb25zdCBleGNsdWRlZE1hcmtzID0gZ2V0TWFya3NCZXR3ZWVuKHJhbmdlLmZyb20sIHJhbmdlLnRvLCBzdGF0ZS5kb2MpXG4gICAgICAgICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gaXRlbS5tYXJrLnR5cGUuZXhjbHVkZWQgYXMgTWFya1R5cGVbXVxuXG4gICAgICAgICAgICByZXR1cm4gZXhjbHVkZWQuZmluZCh0eXBlID0+IHR5cGUgPT09IGNvbmZpZy50eXBlICYmIHR5cGUgIT09IGl0ZW0ubWFyay50eXBlKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0udG8gPiB0ZXh0U3RhcnQpXG5cbiAgICAgICAgaWYgKGV4Y2x1ZGVkTWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0RW5kIDwgcmFuZ2UudG8pIHtcbiAgICAgICAgICB0ci5kZWxldGUodGV4dEVuZCwgcmFuZ2UudG8pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dFN0YXJ0ID4gcmFuZ2UuZnJvbSkge1xuICAgICAgICAgIHRyLmRlbGV0ZShyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIHRleHRTdGFydClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1hcmtFbmQgPSByYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMgKyBjYXB0dXJlR3JvdXAubGVuZ3RoXG5cbiAgICAgICAgdHIuYWRkTWFyayhyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIG1hcmtFbmQsIGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzIHx8IHt9KSlcblxuICAgICAgICB0ci5yZW1vdmVTdG9yZWRNYXJrKGNvbmZpZy50eXBlKVxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBJbnB1dFJ1bGUsIElucHV0UnVsZUZpbmRlciB9IGZyb20gJy4uL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIHRoYXQgYWRkcyBhIG5vZGUgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyB0eXBlZCBpbnRvIGl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9kZUlucHV0UnVsZShjb25maWc6IHtcbiAgLyoqXG4gICAqIFRoZSByZWdleCB0byBtYXRjaC5cbiAgICovXG4gIGZpbmQ6IElucHV0UnVsZUZpbmRlclxuXG4gIC8qKlxuICAgKiBUaGUgbm9kZSB0eXBlIHRvIGFkZC5cbiAgICovXG4gIHR5cGU6IE5vZGVUeXBlXG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGUgbm9kZVxuICAgKiBjYW4gYWxzbyBiZSBhbiBvYmplY3Qgb2YgYXR0cmlidXRlc1xuICAgKi9cbiAgZ2V0QXR0cmlidXRlcz86XG4gICAgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICAgfCAoKG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkpID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgfCBmYWxzZVxuICAgIHwgbnVsbFxufSkge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKSB8fCB7fVxuICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGVcbiAgICAgIGNvbnN0IHN0YXJ0ID0gcmFuZ2UuZnJvbVxuICAgICAgbGV0IGVuZCA9IHJhbmdlLnRvXG5cbiAgICAgIGNvbnN0IG5ld05vZGUgPSBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcylcblxuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKVxuICAgICAgICBsZXQgbWF0Y2hTdGFydCA9IHN0YXJ0ICsgb2Zmc2V0XG5cbiAgICAgICAgaWYgKG1hdGNoU3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICBtYXRjaFN0YXJ0ID0gZW5kXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kID0gbWF0Y2hTdGFydCArIG1hdGNoWzFdLmxlbmd0aFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5zZXJ0IGxhc3QgdHlwZWQgY2hhcmFjdGVyXG4gICAgICAgIGNvbnN0IGxhc3RDaGFyID0gbWF0Y2hbMF1bbWF0Y2hbMF0ubGVuZ3RoIC0gMV1cblxuICAgICAgICB0ci5pbnNlcnRUZXh0KGxhc3RDaGFyLCBzdGFydCArIG1hdGNoWzBdLmxlbmd0aCAtIDEpXG5cbiAgICAgICAgLy8gaW5zZXJ0IG5vZGUgZnJvbSBpbnB1dCBydWxlXG4gICAgICAgIHRyLnJlcGxhY2VXaXRoKG1hdGNoU3RhcnQsIGVuZCwgbmV3Tm9kZSlcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0pIHtcbiAgICAgICAgdHIuaW5zZXJ0KHN0YXJ0IC0gMSwgY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMpKS5kZWxldGUoXG4gICAgICAgICAgdHIubWFwcGluZy5tYXAoc3RhcnQpLFxuICAgICAgICAgIHRyLm1hcHBpbmcubWFwKGVuZCksXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBJbnB1dFJ1bGUsIElucHV0UnVsZUZpbmRlciB9IGZyb20gJy4uL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIHRoYXQgY2hhbmdlcyB0aGUgdHlwZSBvZiBhIHRleHRibG9jayB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuIFdoZW4gdXNpbmcgYSByZWd1bGFyIGV4cHJlc2lvbiB5b3XigJlsbFxuICogcHJvYmFibHkgd2FudCB0aGUgcmVnZXhwIHRvIHN0YXJ0IHdpdGggYF5gLCBzbyB0aGF0IHRoZSBwYXR0ZXJuIGNhblxuICogb25seSBvY2N1ciBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKGNvbmZpZzoge1xuICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXJcbiAgdHlwZTogTm9kZVR5cGVcbiAgZ2V0QXR0cmlidXRlcz86XG4gICAgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICAgfCAoKG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkpID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgfCBmYWxzZVxuICAgIHwgbnVsbFxufSkge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBjb25zdCAkc3RhcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShyYW5nZS5mcm9tKVxuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCkgfHwge31cblxuICAgICAgaWYgKCEkc3RhcnQubm9kZSgtMSkuY2FuUmVwbGFjZVdpdGgoJHN0YXJ0LmluZGV4KC0xKSwgJHN0YXJ0LmluZGV4QWZ0ZXIoLTEpLCBjb25maWcudHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgc3RhdGUudHJcbiAgICAgICAgLmRlbGV0ZShyYW5nZS5mcm9tLCByYW5nZS50bylcbiAgICAgICAgLnNldEJsb2NrVHlwZShyYW5nZS5mcm9tLCByYW5nZS5mcm9tLCBjb25maWcudHlwZSwgYXR0cmlidXRlcylcbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7IElucHV0UnVsZSwgSW5wdXRSdWxlRmluZGVyIH0gZnJvbSAnLi4vSW5wdXRSdWxlLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCByZXBsYWNlcyB0ZXh0IHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHRJbnB1dFJ1bGUoY29uZmlnOiB7XG4gIGZpbmQ6IElucHV0UnVsZUZpbmRlcixcbiAgcmVwbGFjZTogc3RyaW5nLFxufSkge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBsZXQgaW5zZXJ0ID0gY29uZmlnLnJlcGxhY2VcbiAgICAgIGxldCBzdGFydCA9IHJhbmdlLmZyb21cbiAgICAgIGNvbnN0IGVuZCA9IHJhbmdlLnRvXG5cbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXRjaFswXS5sYXN0SW5kZXhPZihtYXRjaFsxXSlcblxuICAgICAgICBpbnNlcnQgKz0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0ICsgbWF0Y2hbMV0ubGVuZ3RoKVxuICAgICAgICBzdGFydCArPSBvZmZzZXRcblxuICAgICAgICBjb25zdCBjdXRPZmYgPSBzdGFydCAtIGVuZFxuXG4gICAgICAgIGlmIChjdXRPZmYgPiAwKSB7XG4gICAgICAgICAgaW5zZXJ0ID0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0IC0gY3V0T2ZmLCBvZmZzZXQpICsgaW5zZXJ0XG4gICAgICAgICAgc3RhcnQgPSBlbmRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGF0ZS50ci5pbnNlcnRUZXh0KGluc2VydCwgc3RhcnQsIGVuZClcbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLCBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBjYW5Kb2luLCBmaW5kV3JhcHBpbmcgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgSW5wdXRSdWxlLCBJbnB1dFJ1bGVGaW5kZXIgfSBmcm9tICcuLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgeyBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4uL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5cbi8qKlxuICogQnVpbGQgYW4gaW5wdXQgcnVsZSBmb3IgYXV0b21hdGljYWxseSB3cmFwcGluZyBhIHRleHRibG9jayB3aGVuIGFcbiAqIGdpdmVuIHN0cmluZyBpcyB0eXBlZC4gV2hlbiB1c2luZyBhIHJlZ3VsYXIgZXhwcmVzaW9uIHlvdeKAmWxsXG4gKiBwcm9iYWJseSB3YW50IHRoZSByZWdleHAgdG8gc3RhcnQgd2l0aCBgXmAsIHNvIHRoYXQgdGhlIHBhdHRlcm4gY2FuXG4gKiBvbmx5IG9jY3VyIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jay5cbiAqXG4gKiBgdHlwZWAgaXMgdGhlIHR5cGUgb2Ygbm9kZSB0byB3cmFwIGluLlxuICpcbiAqIEJ5IGRlZmF1bHQsIGlmIHRoZXJl4oCZcyBhIG5vZGUgd2l0aCB0aGUgc2FtZSB0eXBlIGFib3ZlIHRoZSBuZXdseVxuICogd3JhcHBlZCBub2RlLCB0aGUgcnVsZSB3aWxsIHRyeSB0byBqb2luIHRob3NlXG4gKiB0d28gbm9kZXMuIFlvdSBjYW4gcGFzcyBhIGpvaW4gcHJlZGljYXRlLCB3aGljaCB0YWtlcyBhIHJlZ3VsYXJcbiAqIGV4cHJlc3Npb24gbWF0Y2ggYW5kIHRoZSBub2RlIGJlZm9yZSB0aGUgd3JhcHBlZCBub2RlLCBhbmQgY2FuXG4gKiByZXR1cm4gYSBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgYSBqb2luIHNob3VsZCBoYXBwZW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwcGluZ0lucHV0UnVsZShjb25maWc6IHtcbiAgZmluZDogSW5wdXRSdWxlRmluZGVyLFxuICB0eXBlOiBOb2RlVHlwZSxcbiAga2VlcE1hcmtzPzogYm9vbGVhbixcbiAga2VlcEF0dHJpYnV0ZXM/OiBib29sZWFuLFxuICBlZGl0b3I/OiBFZGl0b3JcbiAgZ2V0QXR0cmlidXRlcz86XG4gIHwgUmVjb3JkPHN0cmluZywgYW55PlxuICB8ICgobWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgfCBmYWxzZVxuICB8IG51bGxcbiAgLFxuICBqb2luUHJlZGljYXRlPzogKG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXksIG5vZGU6IFByb3NlTWlycm9yTm9kZSkgPT4gYm9vbGVhbixcbn0pIHtcbiAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7XG4gICAgICBzdGF0ZSwgcmFuZ2UsIG1hdGNoLCBjaGFpbixcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKSB8fCB7fVxuICAgICAgY29uc3QgdHIgPSBzdGF0ZS50ci5kZWxldGUocmFuZ2UuZnJvbSwgcmFuZ2UudG8pXG4gICAgICBjb25zdCAkc3RhcnQgPSB0ci5kb2MucmVzb2x2ZShyYW5nZS5mcm9tKVxuICAgICAgY29uc3QgYmxvY2tSYW5nZSA9ICRzdGFydC5ibG9ja1JhbmdlKClcbiAgICAgIGNvbnN0IHdyYXBwaW5nID0gYmxvY2tSYW5nZSAmJiBmaW5kV3JhcHBpbmcoYmxvY2tSYW5nZSwgY29uZmlnLnR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgICAgIGlmICghd3JhcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgdHIud3JhcChibG9ja1JhbmdlLCB3cmFwcGluZylcblxuICAgICAgaWYgKGNvbmZpZy5rZWVwTWFya3MgJiYgY29uZmlnLmVkaXRvcikge1xuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlXG4gICAgICAgIGNvbnN0IHsgc3BsaXR0YWJsZU1hcmtzIH0gPSBjb25maWcuZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXJcbiAgICAgICAgY29uc3QgbWFya3MgPSBzdG9yZWRNYXJrcyB8fCAoc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpXG5cbiAgICAgICAgaWYgKG1hcmtzKSB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpXG5cbiAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnLmtlZXBBdHRyaWJ1dGVzKSB7XG4gICAgICAgIC8qKiBJZiB0aGUgbm9kZVR5cGUgaXMgYGJ1bGxldExpc3RgIG9yIGBvcmRlcmVkTGlzdGAgc2V0IHRoZSBgbm9kZVR5cGVgIGFzIGBsaXN0SXRlbWAgKi9cbiAgICAgICAgY29uc3Qgbm9kZVR5cGUgPSBjb25maWcudHlwZS5uYW1lID09PSAnYnVsbGV0TGlzdCcgfHwgY29uZmlnLnR5cGUubmFtZSA9PT0gJ29yZGVyZWRMaXN0JyA/ICdsaXN0SXRlbScgOiAndGFza0xpc3QnXG5cbiAgICAgICAgY2hhaW4oKS51cGRhdGVBdHRyaWJ1dGVzKG5vZGVUeXBlLCBhdHRyaWJ1dGVzKS5ydW4oKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBiZWZvcmUgPSB0ci5kb2MucmVzb2x2ZShyYW5nZS5mcm9tIC0gMSkubm9kZUJlZm9yZVxuXG4gICAgICBpZiAoXG4gICAgICAgIGJlZm9yZVxuICAgICAgICAmJiBiZWZvcmUudHlwZSA9PT0gY29uZmlnLnR5cGVcbiAgICAgICAgJiYgY2FuSm9pbih0ci5kb2MsIHJhbmdlLmZyb20gLSAxKVxuICAgICAgICAmJiAoIWNvbmZpZy5qb2luUHJlZGljYXRlIHx8IGNvbmZpZy5qb2luUHJlZGljYXRlKG1hdGNoLCBiZWZvcmUpKVxuICAgICAgKSB7XG4gICAgICAgIHRyLmpvaW4ocmFuZ2UuZnJvbSAtIDEpXG4gICAgICB9XG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQge1xuICBET01PdXRwdXRTcGVjLCBNYXJrIGFzIFByb3NlTWlycm9yTWFyaywgTWFya1NwZWMsIE1hcmtUeXBlLFxufSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgUGx1Z2luLCBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgZ2V0RXh0ZW5zaW9uRmllbGQgfSBmcm9tICcuL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBNYXJrQ29uZmlnIH0gZnJvbSAnLi9pbmRleC5qcydcbmltcG9ydCB7IElucHV0UnVsZSB9IGZyb20gJy4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4vTm9kZS5qcydcbmltcG9ydCB7IFBhc3RlUnVsZSB9IGZyb20gJy4vUGFzdGVSdWxlLmpzJ1xuaW1wb3J0IHtcbiAgQW55Q29uZmlnLFxuICBBdHRyaWJ1dGVzLFxuICBFeHRlbnNpb25zLFxuICBHbG9iYWxBdHRyaWJ1dGVzLFxuICBLZXlib2FyZFNob3J0Y3V0Q29tbWFuZCxcbiAgUGFyZW50Q29uZmlnLFxuICBSYXdDb21tYW5kcyxcbn0gZnJvbSAnLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcbmltcG9ydCB7IG1lcmdlRGVlcCB9IGZyb20gJy4vdXRpbGl0aWVzL21lcmdlRGVlcC5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBleHBvcnQgaW50ZXJmYWNlIE1hcmtDb25maWc8T3B0aW9ucyA9IGFueSwgU3RvcmFnZSA9IGFueT4ge1xuICAgIFtrZXk6IHN0cmluZ106IGFueVxuXG4gICAgLyoqXG4gICAgICogTmFtZVxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZ1xuXG4gICAgLyoqXG4gICAgICogUHJpb3JpdHlcbiAgICAgKi9cbiAgICBwcmlvcml0eT86IG51bWJlclxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBvcHRpb25zXG4gICAgICovXG4gICAgZGVmYXVsdE9wdGlvbnM/OiBPcHRpb25zXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IE9wdGlvbnNcbiAgICAgKi9cbiAgICBhZGRPcHRpb25zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgcGFyZW50OiBFeGNsdWRlPFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkT3B0aW9ucyddLCB1bmRlZmluZWQ+XG4gICAgfSkgPT4gT3B0aW9uc1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBTdG9yYWdlXG4gICAgICovXG4gICAgYWRkU3RvcmFnZT86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHBhcmVudDogRXhjbHVkZTxQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFN0b3JhZ2UnXSwgdW5kZWZpbmVkPlxuICAgIH0pID0+IFN0b3JhZ2VcblxuICAgIC8qKlxuICAgICAqIEdsb2JhbCBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgYWRkR2xvYmFsQXR0cmlidXRlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRHbG9iYWxBdHRyaWJ1dGVzJ11cbiAgICB9KSA9PiBHbG9iYWxBdHRyaWJ1dGVzIHwge31cblxuICAgIC8qKlxuICAgICAqIFJhd1xuICAgICAqL1xuICAgIGFkZENvbW1hbmRzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkQ29tbWFuZHMnXVxuICAgIH0pID0+IFBhcnRpYWw8UmF3Q29tbWFuZHM+XG5cbiAgICAvKipcbiAgICAgKiBLZXlib2FyZCBzaG9ydGN1dHNcbiAgICAgKi9cbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEtleWJvYXJkU2hvcnRjdXRzJ11cbiAgICB9KSA9PiB7XG4gICAgICBba2V5OiBzdHJpbmddOiBLZXlib2FyZFNob3J0Y3V0Q29tbWFuZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElucHV0IHJ1bGVzXG4gICAgICovXG4gICAgYWRkSW5wdXRSdWxlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZElucHV0UnVsZXMnXVxuICAgIH0pID0+IElucHV0UnVsZVtdXG5cbiAgICAvKipcbiAgICAgKiBQYXN0ZSBydWxlc1xuICAgICAqL1xuICAgIGFkZFBhc3RlUnVsZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRQYXN0ZVJ1bGVzJ11cbiAgICB9KSA9PiBQYXN0ZVJ1bGVbXVxuXG4gICAgLyoqXG4gICAgICogUHJvc2VNaXJyb3IgcGx1Z2luc1xuICAgICAqL1xuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFByb3NlTWlycm9yUGx1Z2lucyddXG4gICAgfSkgPT4gUGx1Z2luW11cblxuICAgIC8qKlxuICAgICAqIEV4dGVuc2lvbnNcbiAgICAgKi9cbiAgICBhZGRFeHRlbnNpb25zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEV4dGVuc2lvbnMnXVxuICAgIH0pID0+IEV4dGVuc2lvbnNcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBOb2RlIFNjaGVtYVxuICAgICAqL1xuICAgIGV4dGVuZE5vZGVTY2hlbWE/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4dGVuZE5vZGVTY2hlbWEnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXh0ZW5zaW9uOiBOb2RlLFxuICAgICAgICApID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBNYXJrIFNjaGVtYVxuICAgICAqL1xuICAgIGV4dGVuZE1hcmtTY2hlbWE/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4dGVuZE1hcmtTY2hlbWEnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXh0ZW5zaW9uOiBNYXJrLFxuICAgICAgICApID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgbm90IHJlYWR5IHlldC5cbiAgICAgKi9cbiAgICBvbkJlZm9yZUNyZWF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkJlZm9yZUNyZWF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgcmVhZHkuXG4gICAgICovXG4gICAgb25DcmVhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25DcmVhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGVudCBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblVwZGF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblVwZGF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3Rpb24gaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25TZWxlY3Rpb25VcGRhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25TZWxlY3Rpb25VcGRhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIHN0YXRlIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uVHJhbnNhY3Rpb24/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25UcmFuc2FjdGlvbiddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGZvY3VzZWQuXG4gICAgICovXG4gICAgb25Gb2N1cz86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkZvY3VzJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBldmVudDogRm9jdXNFdmVudFxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpc27igJl0IGZvY3VzZWQgYW55bW9yZS5cbiAgICAgKi9cbiAgICBvbkJsdXI/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25CbHVyJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBldmVudDogRm9jdXNFdmVudFxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgb25EZXN0cm95PzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uRGVzdHJveSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIEtlZXAgbWFyayBhZnRlciBzcGxpdCBub2RlXG4gICAgICovXG4gICAga2VlcE9uU3BsaXQ/OiBib29sZWFuIHwgKCgpID0+IGJvb2xlYW4pXG5cbiAgICAvKipcbiAgICAgKiBJbmNsdXNpdmVcbiAgICAgKi9cbiAgICBpbmNsdXNpdmU/OlxuICAgICAgfCBNYXJrU3BlY1snaW5jbHVzaXZlJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnaW5jbHVzaXZlJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTWFya1NwZWNbJ2luY2x1c2l2ZSddKVxuXG4gICAgLyoqXG4gICAgICogRXhjbHVkZXNcbiAgICAgKi9cbiAgICBleGNsdWRlcz86XG4gICAgICB8IE1hcmtTcGVjWydleGNsdWRlcyddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4Y2x1ZGVzJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTWFya1NwZWNbJ2V4Y2x1ZGVzJ10pXG5cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGlzIE1hcmsgYXMgZXhpdGFibGVcbiAgICAgKi9cbiAgICBleGl0YWJsZT86IGJvb2xlYW4gfCAoKCkgPT4gYm9vbGVhbilcblxuICAgIC8qKlxuICAgICAqIEdyb3VwXG4gICAgICovXG4gICAgZ3JvdXA/OlxuICAgICAgfCBNYXJrU3BlY1snZ3JvdXAnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wydncm91cCddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE1hcmtTcGVjWydncm91cCddKVxuXG4gICAgLyoqXG4gICAgICogU3Bhbm5pbmdcbiAgICAgKi9cbiAgICBzcGFubmluZz86XG4gICAgICB8IE1hcmtTcGVjWydzcGFubmluZyddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3NwYW5uaW5nJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTWFya1NwZWNbJ3NwYW5uaW5nJ10pXG5cbiAgICAvKipcbiAgICAgKiBDb2RlXG4gICAgICovXG4gICAgY29kZT86XG4gICAgICB8IGJvb2xlYW5cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnY29kZSddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IGJvb2xlYW4pXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBIVE1MXG4gICAgICovXG4gICAgcGFyc2VIVE1MPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3BhcnNlSFRNTCddXG4gICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICB9KSA9PiBNYXJrU3BlY1sncGFyc2VET00nXVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIEhUTUxcbiAgICAgKi9cbiAgICByZW5kZXJIVE1MPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydyZW5kZXJIVE1MJ11cbiAgICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIG1hcms6IFByb3NlTWlycm9yTWFya1xuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICAgICAgICB9LFxuICAgICAgICApID0+IERPTU91dHB1dFNwZWMpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBhZGRBdHRyaWJ1dGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEF0dHJpYnV0ZXMnXVxuICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgfSkgPT4gQXR0cmlidXRlcyB8IHt9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1hcms8T3B0aW9ucyA9IGFueSwgU3RvcmFnZSA9IGFueT4ge1xuICB0eXBlID0gJ21hcmsnXG5cbiAgbmFtZSA9ICdtYXJrJ1xuXG4gIHBhcmVudDogTWFyayB8IG51bGwgPSBudWxsXG5cbiAgY2hpbGQ6IE1hcmsgfCBudWxsID0gbnVsbFxuXG4gIG9wdGlvbnM6IE9wdGlvbnNcblxuICBzdG9yYWdlOiBTdG9yYWdlXG5cbiAgY29uZmlnOiBNYXJrQ29uZmlnID0ge1xuICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICBkZWZhdWx0T3B0aW9uczoge30sXG4gIH1cblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IFBhcnRpYWw8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj4gPSB7fSkge1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICAuLi5jb25maWcsXG4gICAgfVxuXG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25maWcubmFtZVxuXG4gICAgaWYgKGNvbmZpZy5kZWZhdWx0T3B0aW9ucykge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHt0aGlzLm5hbWV9XCIuYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgYGFkZE9wdGlvbnNgIGZhbGxiYWNrXG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5jb25maWcuZGVmYXVsdE9wdGlvbnNcblxuICAgIGlmICh0aGlzLmNvbmZpZy5hZGRPcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkT3B0aW9ucyddPih0aGlzLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIH0pLFxuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMuc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPih0aGlzLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApIHx8IHt9XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlPE8gPSBhbnksIFMgPSBhbnk+KGNvbmZpZzogUGFydGlhbDxNYXJrQ29uZmlnPE8sIFM+PiA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBNYXJrPE8sIFM+KGNvbmZpZylcbiAgfVxuXG4gIGNvbmZpZ3VyZShvcHRpb25zOiBQYXJ0aWFsPE9wdGlvbnM+ID0ge30pIHtcbiAgICAvLyByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugc28gd2UgY2FuIHVzZSB0aGUgc2FtZSBleHRlbnNpb25cbiAgICAvLyB3aXRoIGRpZmZlcmVudCBjYWxscyBvZiBgY29uZmlndXJlYFxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuZXh0ZW5kKClcblxuICAgIGV4dGVuc2lvbi5vcHRpb25zID0gbWVyZ2VEZWVwKHRoaXMub3B0aW9ucyBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBvcHRpb25zKSBhcyBPcHRpb25zXG5cbiAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPihleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICByZXR1cm4gZXh0ZW5zaW9uXG4gIH1cblxuICBleHRlbmQ8RXh0ZW5kZWRPcHRpb25zID0gT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlID0gU3RvcmFnZT4oXG4gICAgZXh0ZW5kZWRDb25maWc6IFBhcnRpYWw8TWFya0NvbmZpZzxFeHRlbmRlZE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZT4+ID0ge30sXG4gICkge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5ldyBNYXJrPEV4dGVuZGVkT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlPihleHRlbmRlZENvbmZpZylcblxuICAgIGV4dGVuc2lvbi5wYXJlbnQgPSB0aGlzXG5cbiAgICB0aGlzLmNoaWxkID0gZXh0ZW5zaW9uXG5cbiAgICBleHRlbnNpb24ubmFtZSA9IGV4dGVuZGVkQ29uZmlnLm5hbWUgPyBleHRlbmRlZENvbmZpZy5uYW1lIDogZXh0ZW5zaW9uLnBhcmVudC5uYW1lXG5cbiAgICBpZiAoZXh0ZW5kZWRDb25maWcuZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7ZXh0ZW5zaW9uLm5hbWV9XCIuYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICBleHRlbnNpb24ub3B0aW9ucyA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkT3B0aW9ucyddPihleHRlbnNpb24sICdhZGRPcHRpb25zJywge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIH0pLFxuICAgIClcblxuICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRTdG9yYWdlJ10+KGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIH0pLFxuICAgIClcblxuICAgIHJldHVybiBleHRlbnNpb25cbiAgfVxuXG4gIHN0YXRpYyBoYW5kbGVFeGl0KHsgZWRpdG9yLCBtYXJrIH06IHsgZWRpdG9yOiBFZGl0b3I7IG1hcms6IE1hcmsgfSkge1xuICAgIGNvbnN0IHsgdHIgfSA9IGVkaXRvci5zdGF0ZVxuICAgIGNvbnN0IGN1cnJlbnRQb3MgPSBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLiRmcm9tXG4gICAgY29uc3QgaXNBdEVuZCA9IGN1cnJlbnRQb3MucG9zID09PSBjdXJyZW50UG9zLmVuZCgpXG5cbiAgICBpZiAoaXNBdEVuZCkge1xuICAgICAgY29uc3QgY3VycmVudE1hcmtzID0gY3VycmVudFBvcy5tYXJrcygpXG4gICAgICBjb25zdCBpc0luTWFyayA9ICEhY3VycmVudE1hcmtzLmZpbmQobSA9PiBtPy50eXBlLm5hbWUgPT09IG1hcmsubmFtZSlcblxuICAgICAgaWYgKCFpc0luTWFyaykge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVtb3ZlTWFyayA9IGN1cnJlbnRNYXJrcy5maW5kKG0gPT4gbT8udHlwZS5uYW1lID09PSBtYXJrLm5hbWUpXG5cbiAgICAgIGlmIChyZW1vdmVNYXJrKSB7XG4gICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsocmVtb3ZlTWFyaylcbiAgICAgIH1cbiAgICAgIHRyLmluc2VydFRleHQoJyAnLCBjdXJyZW50UG9zLnBvcylcblxuICAgICAgZWRpdG9yLnZpZXcuZGlzcGF0Y2godHIpXG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBET01PdXRwdXRTcGVjLCBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgTm9kZVNwZWMsIE5vZGVUeXBlLFxufSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgUGx1Z2luLCBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgZ2V0RXh0ZW5zaW9uRmllbGQgfSBmcm9tICcuL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBOb2RlQ29uZmlnIH0gZnJvbSAnLi9pbmRleC5qcydcbmltcG9ydCB7IElucHV0UnVsZSB9IGZyb20gJy4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgUGFzdGVSdWxlIH0gZnJvbSAnLi9QYXN0ZVJ1bGUuanMnXG5pbXBvcnQge1xuICBBbnlDb25maWcsXG4gIEF0dHJpYnV0ZXMsXG4gIEV4dGVuc2lvbnMsXG4gIEdsb2JhbEF0dHJpYnV0ZXMsXG4gIEtleWJvYXJkU2hvcnRjdXRDb21tYW5kLFxuICBOb2RlVmlld1JlbmRlcmVyLFxuICBQYXJlbnRDb25maWcsXG4gIFJhd0NvbW1hbmRzLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuaW1wb3J0IHsgbWVyZ2VEZWVwIH0gZnJvbSAnLi91dGlsaXRpZXMvbWVyZ2VEZWVwLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBOb2RlQ29uZmlnPE9wdGlvbnMgPSBhbnksIFN0b3JhZ2UgPSBhbnk+IHtcbiAgICBba2V5OiBzdHJpbmddOiBhbnlcblxuICAgIC8qKlxuICAgICAqIE5hbWVcbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmdcblxuICAgIC8qKlxuICAgICAqIFByaW9yaXR5XG4gICAgICovXG4gICAgcHJpb3JpdHk/OiBudW1iZXJcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgb3B0aW9uc1xuICAgICAqL1xuICAgIGRlZmF1bHRPcHRpb25zPzogT3B0aW9uc1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBPcHRpb25zXG4gICAgICovXG4gICAgYWRkT3B0aW9ucz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIHBhcmVudDogRXhjbHVkZTxQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZE9wdGlvbnMnXSwgdW5kZWZpbmVkPlxuICAgIH0pID0+IE9wdGlvbnNcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgU3RvcmFnZVxuICAgICAqL1xuICAgIGFkZFN0b3JhZ2U/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBwYXJlbnQ6IEV4Y2x1ZGU8UGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRTdG9yYWdlJ10sIHVuZGVmaW5lZD5cbiAgICB9KSA9PiBTdG9yYWdlXG5cbiAgICAvKipcbiAgICAgKiBHbG9iYWwgYXR0cmlidXRlc1xuICAgICAqL1xuICAgIGFkZEdsb2JhbEF0dHJpYnV0ZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkR2xvYmFsQXR0cmlidXRlcyddXG4gICAgfSkgPT4gR2xvYmFsQXR0cmlidXRlcyB8IHt9XG5cbiAgICAvKipcbiAgICAgKiBSYXdcbiAgICAgKi9cbiAgICBhZGRDb21tYW5kcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZENvbW1hbmRzJ11cbiAgICB9KSA9PiBQYXJ0aWFsPFJhd0NvbW1hbmRzPlxuXG4gICAgLyoqXG4gICAgICogS2V5Ym9hcmQgc2hvcnRjdXRzXG4gICAgICovXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRLZXlib2FyZFNob3J0Y3V0cyddXG4gICAgfSkgPT4ge1xuICAgICAgW2tleTogc3RyaW5nXTogS2V5Ym9hcmRTaG9ydGN1dENvbW1hbmRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnB1dCBydWxlc1xuICAgICAqL1xuICAgIGFkZElucHV0UnVsZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRJbnB1dFJ1bGVzJ11cbiAgICB9KSA9PiBJbnB1dFJ1bGVbXVxuXG4gICAgLyoqXG4gICAgICogUGFzdGUgcnVsZXNcbiAgICAgKi9cbiAgICBhZGRQYXN0ZVJ1bGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkUGFzdGVSdWxlcyddXG4gICAgfSkgPT4gUGFzdGVSdWxlW11cblxuICAgIC8qKlxuICAgICAqIFByb3NlTWlycm9yIHBsdWdpbnNcbiAgICAgKi9cbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRQcm9zZU1pcnJvclBsdWdpbnMnXVxuICAgIH0pID0+IFBsdWdpbltdXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbnNpb25zXG4gICAgICovXG4gICAgYWRkRXh0ZW5zaW9ucz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRFeHRlbnNpb25zJ11cbiAgICB9KSA9PiBFeHRlbnNpb25zXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgTm9kZSBTY2hlbWFcbiAgICAgKi9cbiAgICBleHRlbmROb2RlU2NoZW1hPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydleHRlbmROb2RlU2NoZW1hJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4dGVuc2lvbjogTm9kZSxcbiAgICAgICAgKSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgTWFyayBTY2hlbWFcbiAgICAgKi9cbiAgICBleHRlbmRNYXJrU2NoZW1hPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydleHRlbmRNYXJrU2NoZW1hJ11cbiAgICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXh0ZW5zaW9uOiBOb2RlLFxuICAgICAgICApID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgbm90IHJlYWR5IHlldC5cbiAgICAgKi9cbiAgICBvbkJlZm9yZUNyZWF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkJlZm9yZUNyZWF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgcmVhZHkuXG4gICAgICovXG4gICAgb25DcmVhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25DcmVhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGVudCBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblVwZGF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblVwZGF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3Rpb24gaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25TZWxlY3Rpb25VcGRhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25TZWxlY3Rpb25VcGRhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIHN0YXRlIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uVHJhbnNhY3Rpb24/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25UcmFuc2FjdGlvbiddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGZvY3VzZWQuXG4gICAgICovXG4gICAgb25Gb2N1cz86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkZvY3VzJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBldmVudDogRm9jdXNFdmVudFxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpc27igJl0IGZvY3VzZWQgYW55bW9yZS5cbiAgICAgKi9cbiAgICBvbkJsdXI/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25CbHVyJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBldmVudDogRm9jdXNFdmVudFxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgb25EZXN0cm95PzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uRGVzdHJveSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIE5vZGUgVmlld1xuICAgICAqL1xuICAgIGFkZE5vZGVWaWV3PzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZE5vZGVWaWV3J11cbiAgICAgICAgfSkgPT4gTm9kZVZpZXdSZW5kZXJlcilcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVG9wTm9kZVxuICAgICAqL1xuICAgIHRvcE5vZGU/OiBib29sZWFuXG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50XG4gICAgICovXG4gICAgY29udGVudD86XG4gICAgICB8IE5vZGVTcGVjWydjb250ZW50J11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnY29udGVudCddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydjb250ZW50J10pXG5cbiAgICAvKipcbiAgICAgKiBNYXJrc1xuICAgICAqL1xuICAgIG1hcmtzPzpcbiAgICAgIHwgTm9kZVNwZWNbJ21hcmtzJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnbWFya3MnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snbWFya3MnXSlcblxuICAgIC8qKlxuICAgICAqIEdyb3VwXG4gICAgICovXG4gICAgZ3JvdXA/OlxuICAgICAgfCBOb2RlU3BlY1snZ3JvdXAnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wydncm91cCddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydncm91cCddKVxuXG4gICAgLyoqXG4gICAgICogSW5saW5lXG4gICAgICovXG4gICAgaW5saW5lPzpcbiAgICAgIHwgTm9kZVNwZWNbJ2lubGluZSddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2lubGluZSddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydpbmxpbmUnXSlcblxuICAgIC8qKlxuICAgICAqIEF0b21cbiAgICAgKi9cbiAgICBhdG9tPzpcbiAgICAgIHwgTm9kZVNwZWNbJ2F0b20nXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhdG9tJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2F0b20nXSlcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdGFibGVcbiAgICAgKi9cbiAgICBzZWxlY3RhYmxlPzpcbiAgICAgIHwgTm9kZVNwZWNbJ3NlbGVjdGFibGUnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydzZWxlY3RhYmxlJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ3NlbGVjdGFibGUnXSlcblxuICAgIC8qKlxuICAgICAqIERyYWdnYWJsZVxuICAgICAqL1xuICAgIGRyYWdnYWJsZT86XG4gICAgICB8IE5vZGVTcGVjWydkcmFnZ2FibGUnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydkcmFnZ2FibGUnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snZHJhZ2dhYmxlJ10pXG5cbiAgICAvKipcbiAgICAgKiBDb2RlXG4gICAgICovXG4gICAgY29kZT86XG4gICAgICB8IE5vZGVTcGVjWydjb2RlJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnY29kZSddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydjb2RlJ10pXG5cbiAgICAvKipcbiAgICAgKiBXaGl0ZXNwYWNlXG4gICAgICovXG4gICAgd2hpdGVzcGFjZT86XG4gICAgICB8IE5vZGVTcGVjWyd3aGl0ZXNwYWNlJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnd2hpdGVzcGFjZSddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWyd3aGl0ZXNwYWNlJ10pXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmluZ1xuICAgICAqL1xuICAgIGRlZmluaW5nPzpcbiAgICAgIHwgTm9kZVNwZWNbJ2RlZmluaW5nJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZGVmaW5pbmcnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snZGVmaW5pbmcnXSlcblxuICAgIC8qKlxuICAgICAqIElzb2xhdGluZ1xuICAgICAqL1xuICAgIGlzb2xhdGluZz86XG4gICAgICB8IE5vZGVTcGVjWydpc29sYXRpbmcnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wydpc29sYXRpbmcnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snaXNvbGF0aW5nJ10pXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBIVE1MXG4gICAgICovXG4gICAgcGFyc2VIVE1MPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3BhcnNlSFRNTCddXG4gICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICB9KSA9PiBOb2RlU3BlY1sncGFyc2VET00nXVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIEhUTUxcbiAgICAgKi9cbiAgICByZW5kZXJIVE1MPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydyZW5kZXJIVE1MJ11cbiAgICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIG5vZGU6IFByb3NlTWlycm9yTm9kZVxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICAgICAgICB9LFxuICAgICAgICApID0+IERPTU91dHB1dFNwZWMpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBUZXh0XG4gICAgICovXG4gICAgcmVuZGVyVGV4dD86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsncmVuZGVyVGV4dCddXG4gICAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBub2RlOiBQcm9zZU1pcnJvck5vZGVcbiAgICAgICAgICAgIHBvczogbnVtYmVyXG4gICAgICAgICAgICBwYXJlbnQ6IFByb3NlTWlycm9yTm9kZVxuICAgICAgICAgICAgaW5kZXg6IG51bWJlclxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gc3RyaW5nKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBBZGQgQXR0cmlidXRlc1xuICAgICAqL1xuICAgIGFkZEF0dHJpYnV0ZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkQXR0cmlidXRlcyddXG4gICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICB9KSA9PiBBdHRyaWJ1dGVzIHwge31cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTm9kZTxPcHRpb25zID0gYW55LCBTdG9yYWdlID0gYW55PiB7XG4gIHR5cGUgPSAnbm9kZSdcblxuICBuYW1lID0gJ25vZGUnXG5cbiAgcGFyZW50OiBOb2RlIHwgbnVsbCA9IG51bGxcblxuICBjaGlsZDogTm9kZSB8IG51bGwgPSBudWxsXG5cbiAgb3B0aW9uczogT3B0aW9uc1xuXG4gIHN0b3JhZ2U6IFN0b3JhZ2VcblxuICBjb25maWc6IE5vZGVDb25maWcgPSB7XG4gICAgbmFtZTogdGhpcy5uYW1lLFxuICAgIGRlZmF1bHRPcHRpb25zOiB7fSxcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogUGFydGlhbDxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PiA9IHt9KSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIC4uLmNvbmZpZyxcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lXG5cbiAgICBpZiAoY29uZmlnLmRlZmF1bHRPcHRpb25zKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke3RoaXMubmFtZX1cIi5gLFxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSBgYWRkT3B0aW9uc2AgZmFsbGJhY2tcbiAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0T3B0aW9uc1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmFkZE9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IGNhbGxPclJldHVybihcbiAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRPcHRpb25zJ10+KHRoaXMsICdhZGRPcHRpb25zJywge1xuICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgfSksXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRTdG9yYWdlJ10+KHRoaXMsICdhZGRTdG9yYWdlJywge1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIH0pLFxuICAgICkgfHwge31cbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGU8TyA9IGFueSwgUyA9IGFueT4oY29uZmlnOiBQYXJ0aWFsPE5vZGVDb25maWc8TywgUz4+ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IE5vZGU8TywgUz4oY29uZmlnKVxuICB9XG5cbiAgY29uZmlndXJlKG9wdGlvbnM6IFBhcnRpYWw8T3B0aW9ucz4gPSB7fSkge1xuICAgIC8vIHJldHVybiBhIG5ldyBpbnN0YW5jZSBzbyB3ZSBjYW4gdXNlIHRoZSBzYW1lIGV4dGVuc2lvblxuICAgIC8vIHdpdGggZGlmZmVyZW50IGNhbGxzIG9mIGBjb25maWd1cmVgXG4gICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5leHRlbmQoKVxuXG4gICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBtZXJnZURlZXAodGhpcy5vcHRpb25zIGFzIFJlY29yZDxzdHJpbmcsIGFueT4sIG9wdGlvbnMpIGFzIE9wdGlvbnNcblxuICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRTdG9yYWdlJ10+KGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIH0pLFxuICAgIClcblxuICAgIHJldHVybiBleHRlbnNpb25cbiAgfVxuXG4gIGV4dGVuZDxFeHRlbmRlZE9wdGlvbnMgPSBPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2UgPSBTdG9yYWdlPihcbiAgICBleHRlbmRlZENvbmZpZzogUGFydGlhbDxOb2RlQ29uZmlnPEV4dGVuZGVkT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlPj4gPSB7fSxcbiAgKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbmV3IE5vZGU8RXh0ZW5kZWRPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2U+KGV4dGVuZGVkQ29uZmlnKVxuXG4gICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXNcblxuICAgIHRoaXMuY2hpbGQgPSBleHRlbnNpb25cblxuICAgIGV4dGVuc2lvbi5uYW1lID0gZXh0ZW5kZWRDb25maWcubmFtZSA/IGV4dGVuZGVkQ29uZmlnLm5hbWUgOiBleHRlbnNpb24ucGFyZW50Lm5hbWVcblxuICAgIGlmIChleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucykge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHtleHRlbnNpb24ubmFtZX1cIi5gLFxuICAgICAgKVxuICAgIH1cblxuICAgIGV4dGVuc2lvbi5vcHRpb25zID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRPcHRpb25zJ10+KGV4dGVuc2lvbiwgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4oZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzQW5kcm9pZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIG5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gJ0FuZHJvaWQnIHx8IC9hbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IE5vZGVTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgTm9kZVZpZXcgYXMgUHJvc2VNaXJyb3JOb2RlVmlldyB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldydcblxuaW1wb3J0IHsgRWRpdG9yIGFzIENvcmVFZGl0b3IgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuL05vZGUuanMnXG5pbXBvcnQgeyBEZWNvcmF0aW9uV2l0aFR5cGUsIE5vZGVWaWV3UmVuZGVyZXJPcHRpb25zLCBOb2RlVmlld1JlbmRlcmVyUHJvcHMgfSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgaXNBbmRyb2lkIH0gZnJvbSAnLi91dGlsaXRpZXMvaXNBbmRyb2lkLmpzJ1xuaW1wb3J0IHsgaXNpT1MgfSBmcm9tICcuL3V0aWxpdGllcy9pc2lPUy5qcydcblxuZXhwb3J0IGNsYXNzIE5vZGVWaWV3PFxuICBDb21wb25lbnQsXG4gIE5vZGVFZGl0b3IgZXh0ZW5kcyBDb3JlRWRpdG9yID0gQ29yZUVkaXRvcixcbiAgT3B0aW9ucyBleHRlbmRzIE5vZGVWaWV3UmVuZGVyZXJPcHRpb25zID0gTm9kZVZpZXdSZW5kZXJlck9wdGlvbnMsXG4+IGltcGxlbWVudHMgUHJvc2VNaXJyb3JOb2RlVmlldyB7XG4gIGNvbXBvbmVudDogQ29tcG9uZW50XG5cbiAgZWRpdG9yOiBOb2RlRWRpdG9yXG5cbiAgb3B0aW9uczogT3B0aW9uc1xuXG4gIGV4dGVuc2lvbjogTm9kZVxuXG4gIG5vZGU6IFByb3NlTWlycm9yTm9kZVxuXG4gIGRlY29yYXRpb25zOiBEZWNvcmF0aW9uV2l0aFR5cGVbXVxuXG4gIGdldFBvczogYW55XG5cbiAgaXNEcmFnZ2luZyA9IGZhbHNlXG5cbiAgY29uc3RydWN0b3IoY29tcG9uZW50OiBDb21wb25lbnQsIHByb3BzOiBOb2RlVmlld1JlbmRlcmVyUHJvcHMsIG9wdGlvbnM/OiBQYXJ0aWFsPE9wdGlvbnM+KSB7XG4gICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnRcbiAgICB0aGlzLmVkaXRvciA9IHByb3BzLmVkaXRvciBhcyBOb2RlRWRpdG9yXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgc3RvcEV2ZW50OiBudWxsLFxuICAgICAgaWdub3JlTXV0YXRpb246IG51bGwsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0gYXMgT3B0aW9uc1xuICAgIHRoaXMuZXh0ZW5zaW9uID0gcHJvcHMuZXh0ZW5zaW9uXG4gICAgdGhpcy5ub2RlID0gcHJvcHMubm9kZVxuICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBwcm9wcy5kZWNvcmF0aW9ucyBhcyBEZWNvcmF0aW9uV2l0aFR5cGVbXVxuICAgIHRoaXMuZ2V0UG9zID0gcHJvcHMuZ2V0UG9zXG4gICAgdGhpcy5tb3VudCgpXG4gIH1cblxuICBtb3VudCgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICByZXR1cm5cbiAgfVxuXG4gIGdldCBkb20oKTogSFRNTEVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLmVkaXRvci52aWV3LmRvbSBhcyBIVE1MRWxlbWVudFxuICB9XG5cbiAgZ2V0IGNvbnRlbnRET00oKTogSFRNTEVsZW1lbnQgfCBudWxsIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgb25EcmFnU3RhcnQoZXZlbnQ6IERyYWdFdmVudCkge1xuICAgIGNvbnN0IHsgdmlldyB9ID0gdGhpcy5lZGl0b3JcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnRcblxuICAgIC8vIGdldCB0aGUgZHJhZyBoYW5kbGUgZWxlbWVudFxuICAgIC8vIGBjbG9zZXN0YCBpcyBub3QgYXZhaWxhYmxlIGZvciB0ZXh0IG5vZGVzIHNvIHdlIG1heSBoYXZlIHRvIHVzZSBpdHMgcGFyZW50XG4gICAgY29uc3QgZHJhZ0hhbmRsZSA9IHRhcmdldC5ub2RlVHlwZSA9PT0gM1xuICAgICAgPyB0YXJnZXQucGFyZW50RWxlbWVudD8uY2xvc2VzdCgnW2RhdGEtZHJhZy1oYW5kbGVdJylcbiAgICAgIDogdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWRyYWctaGFuZGxlXScpXG5cbiAgICBpZiAoIXRoaXMuZG9tIHx8IHRoaXMuY29udGVudERPTT8uY29udGFpbnModGFyZ2V0KSB8fCAhZHJhZ0hhbmRsZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHggPSAwXG4gICAgbGV0IHkgPSAwXG5cbiAgICAvLyBjYWxjdWxhdGUgb2Zmc2V0IGZvciBkcmFnIGVsZW1lbnQgaWYgd2UgdXNlIGEgZGlmZmVyZW50IGRyYWcgaGFuZGxlIGVsZW1lbnRcbiAgICBpZiAodGhpcy5kb20gIT09IGRyYWdIYW5kbGUpIHtcbiAgICAgIGNvbnN0IGRvbUJveCA9IHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICBjb25zdCBoYW5kbGVCb3ggPSBkcmFnSGFuZGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgICAgIC8vIEluIFJlYWN0LCB3ZSBoYXZlIHRvIGdvIHRocm91Z2ggbmF0aXZlRXZlbnQgdG8gcmVhY2ggb2Zmc2V0WC9vZmZzZXRZLlxuICAgICAgY29uc3Qgb2Zmc2V0WCA9IGV2ZW50Lm9mZnNldFggPz8gKGV2ZW50IGFzIGFueSkubmF0aXZlRXZlbnQ/Lm9mZnNldFhcbiAgICAgIGNvbnN0IG9mZnNldFkgPSBldmVudC5vZmZzZXRZID8/IChldmVudCBhcyBhbnkpLm5hdGl2ZUV2ZW50Py5vZmZzZXRZXG5cbiAgICAgIHggPSBoYW5kbGVCb3gueCAtIGRvbUJveC54ICsgb2Zmc2V0WFxuICAgICAgeSA9IGhhbmRsZUJveC55IC0gZG9tQm94LnkgKyBvZmZzZXRZXG4gICAgfVxuXG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyPy5zZXREcmFnSW1hZ2UodGhpcy5kb20sIHgsIHkpXG5cbiAgICAvLyB3ZSBuZWVkIHRvIHRlbGwgUHJvc2VNaXJyb3IgdGhhdCB3ZSB3YW50IHRvIG1vdmUgdGhlIHdob2xlIG5vZGVcbiAgICAvLyBzbyB3ZSBjcmVhdGUgYSBOb2RlU2VsZWN0aW9uXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIHRoaXMuZ2V0UG9zKCkpXG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pXG5cbiAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKVxuICB9XG5cbiAgc3RvcEV2ZW50KGV2ZW50OiBFdmVudCkge1xuICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnN0b3BFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zdG9wRXZlbnQoeyBldmVudCB9KVxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudFxuICAgIGNvbnN0IGlzSW5FbGVtZW50ID0gdGhpcy5kb20uY29udGFpbnModGFyZ2V0KSAmJiAhdGhpcy5jb250ZW50RE9NPy5jb250YWlucyh0YXJnZXQpXG5cbiAgICAvLyBhbnkgZXZlbnQgZnJvbSBjaGlsZCBub2RlcyBzaG91bGQgYmUgaGFuZGxlZCBieSBQcm9zZU1pcnJvclxuICAgIGlmICghaXNJbkVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGlzRHJhZ0V2ZW50ID0gZXZlbnQudHlwZS5zdGFydHNXaXRoKCdkcmFnJylcbiAgICBjb25zdCBpc0Ryb3BFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdkcm9wJ1xuICAgIGNvbnN0IGlzSW5wdXQgPSBbJ0lOUFVUJywgJ0JVVFRPTicsICdTRUxFQ1QnLCAnVEVYVEFSRUEnXS5pbmNsdWRlcyh0YXJnZXQudGFnTmFtZSkgfHwgdGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlXG5cbiAgICAvLyBhbnkgaW5wdXQgZXZlbnQgd2l0aGluIG5vZGUgdmlld3Mgc2hvdWxkIGJlIGlnbm9yZWQgYnkgUHJvc2VNaXJyb3JcbiAgICBpZiAoaXNJbnB1dCAmJiAhaXNEcm9wRXZlbnQgJiYgIWlzRHJhZ0V2ZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IHsgaXNFZGl0YWJsZSB9ID0gdGhpcy5lZGl0b3JcbiAgICBjb25zdCB7IGlzRHJhZ2dpbmcgfSA9IHRoaXNcbiAgICBjb25zdCBpc0RyYWdnYWJsZSA9ICEhdGhpcy5ub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGVcbiAgICBjb25zdCBpc1NlbGVjdGFibGUgPSBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZSh0aGlzLm5vZGUpXG4gICAgY29uc3QgaXNDb3B5RXZlbnQgPSBldmVudC50eXBlID09PSAnY29weSdcbiAgICBjb25zdCBpc1Bhc3RlRXZlbnQgPSBldmVudC50eXBlID09PSAncGFzdGUnXG4gICAgY29uc3QgaXNDdXRFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdjdXQnXG4gICAgY29uc3QgaXNDbGlja0V2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bidcblxuICAgIC8vIFByb3NlTWlycm9yIHRyaWVzIHRvIGRyYWcgc2VsZWN0YWJsZSBub2Rlc1xuICAgIC8vIGV2ZW4gaWYgYGRyYWdnYWJsZWAgaXMgc2V0IHRvIGBmYWxzZWBcbiAgICAvLyB0aGlzIGZpeCBwcmV2ZW50cyB0aGF0XG4gICAgaWYgKCFpc0RyYWdnYWJsZSAmJiBpc1NlbGVjdGFibGUgJiYgaXNEcmFnRXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICB9XG5cbiAgICBpZiAoaXNEcmFnZ2FibGUgJiYgaXNEcmFnRXZlbnQgJiYgIWlzRHJhZ2dpbmcpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIHdlIGhhdmUgdG8gc3RvcmUgdGhhdCBkcmFnZ2luZyBzdGFydGVkXG4gICAgaWYgKGlzRHJhZ2dhYmxlICYmIGlzRWRpdGFibGUgJiYgIWlzRHJhZ2dpbmcgJiYgaXNDbGlja0V2ZW50KSB7XG4gICAgICBjb25zdCBkcmFnSGFuZGxlID0gdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWRyYWctaGFuZGxlXScpXG4gICAgICBjb25zdCBpc1ZhbGlkRHJhZ0hhbmRsZSA9IGRyYWdIYW5kbGUgJiYgKHRoaXMuZG9tID09PSBkcmFnSGFuZGxlIHx8IHRoaXMuZG9tLmNvbnRhaW5zKGRyYWdIYW5kbGUpKVxuXG4gICAgICBpZiAoaXNWYWxpZERyYWdIYW5kbGUpIHtcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZVxuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgJ2RyYWdlbmQnLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IG9uY2U6IHRydWUgfSxcbiAgICAgICAgKVxuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgJ2Ryb3AnLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IG9uY2U6IHRydWUgfSxcbiAgICAgICAgKVxuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgJ21vdXNldXAnLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IG9uY2U6IHRydWUgfSxcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRoZXNlIGV2ZW50cyBhcmUgaGFuZGxlZCBieSBwcm9zZW1pcnJvclxuICAgIGlmIChcbiAgICAgIGlzRHJhZ2dpbmdcbiAgICAgIHx8IGlzRHJvcEV2ZW50XG4gICAgICB8fCBpc0NvcHlFdmVudFxuICAgICAgfHwgaXNQYXN0ZUV2ZW50XG4gICAgICB8fCBpc0N1dEV2ZW50XG4gICAgICB8fCAoaXNDbGlja0V2ZW50ICYmIGlzU2VsZWN0YWJsZSlcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbjogTXV0YXRpb25SZWNvcmQgfCB7IHR5cGU6ICdzZWxlY3Rpb24nOyB0YXJnZXQ6IEVsZW1lbnQgfSkge1xuICAgIGlmICghdGhpcy5kb20gfHwgIXRoaXMuY29udGVudERPTSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbih7IG11dGF0aW9uIH0pXG4gICAgfVxuXG4gICAgLy8gYSBsZWFmL2F0b20gbm9kZSBpcyBsaWtlIGEgYmxhY2sgYm94IGZvciBQcm9zZU1pcnJvclxuICAgIC8vIGFuZCBzaG91bGQgYmUgZnVsbHkgaGFuZGxlZCBieSB0aGUgbm9kZSB2aWV3XG4gICAgaWYgKHRoaXMubm9kZS5pc0xlYWYgfHwgdGhpcy5ub2RlLmlzQXRvbSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBQcm9zZU1pcnJvciBzaG91bGQgaGFuZGxlIGFueSBzZWxlY3Rpb25zXG4gICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdzZWxlY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyB0cnkgdG8gcHJldmVudCBhIGJ1ZyBvbiBpT1MgYW5kIEFuZHJvaWQgdGhhdCB3aWxsIGJyZWFrIG5vZGUgdmlld3Mgb24gZW50ZXJcbiAgICAvLyB0aGlzIGlzIGJlY2F1c2UgUHJvc2VNaXJyb3IgY2Fu4oCZdCBwcmV2ZW50RGlzcGF0Y2ggb24gZW50ZXJcbiAgICAvLyB0aGlzIHdpbGwgbGVhZCB0byBhIHJlLXJlbmRlciBvZiB0aGUgbm9kZSB2aWV3IG9uIGVudGVyXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzEyMTRcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMjUzNFxuICAgIGlmIChcbiAgICAgIHRoaXMuZG9tLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldClcbiAgICAgICYmIG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnXG4gICAgICAmJiAoaXNpT1MoKSB8fCBpc0FuZHJvaWQoKSlcbiAgICAgICYmIHRoaXMuZWRpdG9yLmlzRm9jdXNlZFxuICAgICkge1xuICAgICAgY29uc3QgY2hhbmdlZE5vZGVzID0gW1xuICAgICAgICAuLi5BcnJheS5mcm9tKG11dGF0aW9uLmFkZGVkTm9kZXMpLFxuICAgICAgICAuLi5BcnJheS5mcm9tKG11dGF0aW9uLnJlbW92ZWROb2RlcyksXG4gICAgICBdIGFzIEhUTUxFbGVtZW50W11cblxuICAgICAgLy8gd2XigJlsbCBjaGVjayBpZiBldmVyeSBjaGFuZ2VkIG5vZGUgaXMgY29udGVudEVkaXRhYmxlXG4gICAgICAvLyB0byBtYWtlIHN1cmUgaXTigJlzIHByb2JhYmx5IG11dGF0ZWQgYnkgUHJvc2VNaXJyb3JcbiAgICAgIGlmIChjaGFuZ2VkTm9kZXMuZXZlcnkobm9kZSA9PiBub2RlLmlzQ29udGVudEVkaXRhYmxlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3ZSB3aWxsIGFsbG93IG11dGF0aW9uIGNvbnRlbnRET00gd2l0aCBhdHRyaWJ1dGVzXG4gICAgLy8gc28gd2UgY2FuIGZvciBleGFtcGxlIGFkZGluZyBjbGFzc2VzIHdpdGhpbiBvdXIgbm9kZSB2aWV3XG4gICAgaWYgKHRoaXMuY29udGVudERPTSA9PT0gbXV0YXRpb24udGFyZ2V0ICYmIG11dGF0aW9uLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBQcm9zZU1pcnJvciBzaG91bGQgaGFuZGxlIGFueSBjaGFuZ2VzIHdpdGhpbiBjb250ZW50RE9NXG4gICAgaWYgKHRoaXMuY29udGVudERPTS5jb250YWlucyhtdXRhdGlvbi50YXJnZXQpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgdXBkYXRlQXR0cmlidXRlcyhhdHRyaWJ1dGVzOiB7fSkge1xuICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgY29uc3QgcG9zID0gdGhpcy5nZXRQb3MoKVxuXG4gICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdW5kZWZpbmVkLCB7XG4gICAgICAgIC4uLnRoaXMubm9kZS5hdHRycyxcbiAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSlcbiAgfVxuXG4gIGRlbGV0ZU5vZGUoKTogdm9pZCB7XG4gICAgY29uc3QgZnJvbSA9IHRoaXMuZ2V0UG9zKClcbiAgICBjb25zdCB0byA9IGZyb20gKyB0aGlzLm5vZGUubm9kZVNpemVcblxuICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmRlbGV0ZVJhbmdlKHsgZnJvbSwgdG8gfSlcbiAgfVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya3NCZXR3ZWVuIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrc0JldHdlZW4uanMnXG5pbXBvcnQgeyBQYXN0ZVJ1bGUsIFBhc3RlUnVsZUZpbmRlciB9IGZyb20gJy4uL1Bhc3RlUnVsZS5qcydcbmltcG9ydCB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBwYXN0ZSBydWxlIHRoYXQgYWRkcyBhIG1hcmsgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyBwYXN0ZWQgaW50byBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcmtQYXN0ZVJ1bGUoY29uZmlnOiB7XG4gIGZpbmQ6IFBhc3RlUnVsZUZpbmRlclxuICB0eXBlOiBNYXJrVHlwZVxuICBnZXRBdHRyaWJ1dGVzPzpcbiAgICB8IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICB8ICgobWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICB8IGZhbHNlXG4gICAgfCBudWxsXG59KSB7XG4gIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gpXG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzID09PSBmYWxzZSB8fCBhdHRyaWJ1dGVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlXG4gICAgICBjb25zdCBjYXB0dXJlR3JvdXAgPSBtYXRjaFttYXRjaC5sZW5ndGggLSAxXVxuICAgICAgY29uc3QgZnVsbE1hdGNoID0gbWF0Y2hbMF1cbiAgICAgIGxldCBtYXJrRW5kID0gcmFuZ2UudG9cblxuICAgICAgaWYgKGNhcHR1cmVHcm91cCkge1xuICAgICAgICBjb25zdCBzdGFydFNwYWNlcyA9IGZ1bGxNYXRjaC5zZWFyY2goL1xcUy8pXG4gICAgICAgIGNvbnN0IHRleHRTdGFydCA9IHJhbmdlLmZyb20gKyBmdWxsTWF0Y2guaW5kZXhPZihjYXB0dXJlR3JvdXApXG4gICAgICAgIGNvbnN0IHRleHRFbmQgPSB0ZXh0U3RhcnQgKyBjYXB0dXJlR3JvdXAubGVuZ3RoXG5cbiAgICAgICAgY29uc3QgZXhjbHVkZWRNYXJrcyA9IGdldE1hcmtzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgc3RhdGUuZG9jKVxuICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBleGNsdWRlZCA9IGl0ZW0ubWFyay50eXBlLmV4Y2x1ZGVkIGFzIE1hcmtUeXBlW11cblxuICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVkLmZpbmQodHlwZSA9PiB0eXBlID09PSBjb25maWcudHlwZSAmJiB0eXBlICE9PSBpdGVtLm1hcmsudHlwZSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnRvID4gdGV4dFN0YXJ0KVxuXG4gICAgICAgIGlmIChleGNsdWRlZE1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dEVuZCA8IHJhbmdlLnRvKSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHRleHRFbmQsIHJhbmdlLnRvKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRTdGFydCA+IHJhbmdlLmZyb20pIHtcbiAgICAgICAgICB0ci5kZWxldGUocmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzLCB0ZXh0U3RhcnQpXG4gICAgICAgIH1cblxuICAgICAgICBtYXJrRW5kID0gcmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzICsgY2FwdHVyZUdyb3VwLmxlbmd0aFxuXG4gICAgICAgIHRyLmFkZE1hcmsocmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzLCBtYXJrRW5kLCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcyB8fCB7fSkpXG5cbiAgICAgICAgdHIucmVtb3ZlU3RvcmVkTWFyayhjb25maWcudHlwZSlcbiAgICAgIH1cbiAgICB9LFxuICB9KVxufVxuIiwgIi8vIHNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzY5Njk0ODZcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVGb3JSZWdFeChzdHJpbmc6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBzdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJ1xufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgUGFzdGVSdWxlLCBQYXN0ZVJ1bGVGaW5kZXIgfSBmcm9tICcuLi9QYXN0ZVJ1bGUuanMnXG5pbXBvcnQgeyBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4uL3V0aWxpdGllcy9pbmRleC5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBwYXN0ZSBydWxlIHRoYXQgYWRkcyBhIG5vZGUgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyBwYXN0ZWQgaW50byBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vZGVQYXN0ZVJ1bGUoY29uZmlnOiB7XG4gIGZpbmQ6IFBhc3RlUnVsZUZpbmRlclxuICB0eXBlOiBOb2RlVHlwZVxuICBnZXRBdHRyaWJ1dGVzPzpcbiAgICB8IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICB8ICgobWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICB8IGZhbHNlXG4gICAgfCBudWxsXG59KSB7XG4gIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyKHsgbWF0Y2gsIGNoYWluLCByYW5nZSB9KSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKVxuXG4gICAgICBpZiAoYXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgYXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2guaW5wdXQpIHtcbiAgICAgICAgY2hhaW4oKS5kZWxldGVSYW5nZShyYW5nZSkuaW5zZXJ0Q29udGVudEF0KHJhbmdlLmZyb20sIHtcbiAgICAgICAgICB0eXBlOiBjb25maWcudHlwZS5uYW1lLFxuICAgICAgICAgIGF0dHJzOiBhdHRyaWJ1dGVzLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgUGFzdGVSdWxlLCBQYXN0ZVJ1bGVGaW5kZXIgfSBmcm9tICcuLi9QYXN0ZVJ1bGUuanMnXG5cbi8qKlxuICogQnVpbGQgYW4gcGFzdGUgcnVsZSB0aGF0IHJlcGxhY2VzIHRleHQgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyBwYXN0ZWQgaW50byBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHRQYXN0ZVJ1bGUoY29uZmlnOiB7XG4gIGZpbmQ6IFBhc3RlUnVsZUZpbmRlcixcbiAgcmVwbGFjZTogc3RyaW5nLFxufSkge1xuICByZXR1cm4gbmV3IFBhc3RlUnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBsZXQgaW5zZXJ0ID0gY29uZmlnLnJlcGxhY2VcbiAgICAgIGxldCBzdGFydCA9IHJhbmdlLmZyb21cbiAgICAgIGNvbnN0IGVuZCA9IHJhbmdlLnRvXG5cbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXRjaFswXS5sYXN0SW5kZXhPZihtYXRjaFsxXSlcblxuICAgICAgICBpbnNlcnQgKz0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0ICsgbWF0Y2hbMV0ubGVuZ3RoKVxuICAgICAgICBzdGFydCArPSBvZmZzZXRcblxuICAgICAgICBjb25zdCBjdXRPZmYgPSBzdGFydCAtIGVuZFxuXG4gICAgICAgIGlmIChjdXRPZmYgPiAwKSB7XG4gICAgICAgICAgaW5zZXJ0ID0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0IC0gY3V0T2ZmLCBvZmZzZXQpICsgaW5zZXJ0XG4gICAgICAgICAgc3RhcnQgPSBlbmRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGF0ZS50ci5pbnNlcnRUZXh0KGluc2VydCwgc3RhcnQsIGVuZClcbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuZXhwb3J0IGludGVyZmFjZSBUcmFja2VyUmVzdWx0IHtcbiAgcG9zaXRpb246IG51bWJlclxuICBkZWxldGVkOiBib29sZWFuXG59XG5cbmV4cG9ydCBjbGFzcyBUcmFja2VyIHtcbiAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uXG5cbiAgY3VycmVudFN0ZXA6IG51bWJlclxuXG4gIGNvbnN0cnVjdG9yKHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbikge1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvblxuICAgIHRoaXMuY3VycmVudFN0ZXAgPSB0aGlzLnRyYW5zYWN0aW9uLnN0ZXBzLmxlbmd0aFxuICB9XG5cbiAgbWFwKHBvc2l0aW9uOiBudW1iZXIpOiBUcmFja2VyUmVzdWx0IHtcbiAgICBsZXQgZGVsZXRlZCA9IGZhbHNlXG5cbiAgICBjb25zdCBtYXBwZWRQb3NpdGlvbiA9IHRoaXMudHJhbnNhY3Rpb24uc3RlcHNcbiAgICAgIC5zbGljZSh0aGlzLmN1cnJlbnRTdGVwKVxuICAgICAgLnJlZHVjZSgobmV3UG9zaXRpb24sIHN0ZXApID0+IHtcbiAgICAgICAgY29uc3QgbWFwUmVzdWx0ID0gc3RlcC5nZXRNYXAoKS5tYXBSZXN1bHQobmV3UG9zaXRpb24pXG5cbiAgICAgICAgaWYgKG1hcFJlc3VsdC5kZWxldGVkKSB7XG4gICAgICAgICAgZGVsZXRlZCA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXBSZXN1bHQucG9zXG4gICAgICB9LCBwb3NpdGlvbilcblxuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogbWFwcGVkUG9zaXRpb24sXG4gICAgICBkZWxldGVkLFxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IE5vZGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBjb25zdCBEb2N1bWVudCA9IE5vZGUuY3JlYXRlKHtcbiAgbmFtZTogJ2RvYycsXG4gIHRvcE5vZGU6IHRydWUsXG4gIGNvbnRlbnQ6ICdibG9jaysnLFxufSlcbiIsICJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhcmFjdGVyQ291bnRPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgc2hvdWxkIGJlIGFsbG93ZWQuIERlZmF1bHRzIHRvIGAwYC5cbiAgICovXG4gIGxpbWl0OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkXG4gIC8qKlxuICAgKiBUaGUgbW9kZSBieSB3aGljaCB0aGUgc2l6ZSBpcyBjYWxjdWxhdGVkLiBEZWZhdWx0cyB0byAndGV4dFNpemUnLlxuICAgKi9cbiAgbW9kZTogJ3RleHRTaXplJyB8ICdub2RlU2l6ZSdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGFyYWN0ZXJDb3VudFN0b3JhZ2Uge1xuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBmb3IgdGhlIGN1cnJlbnQgZG9jdW1lbnQuXG4gICAqL1xuICBjaGFyYWN0ZXJzOiAob3B0aW9ucz86IHsgbm9kZT86IFByb3NlTWlycm9yTm9kZTsgbW9kZT86ICd0ZXh0U2l6ZScgfCAnbm9kZVNpemUnIH0pID0+IG51bWJlclxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlciBvZiB3b3JkcyBmb3IgdGhlIGN1cnJlbnQgZG9jdW1lbnQuXG4gICAqL1xuICB3b3JkczogKG9wdGlvbnM/OiB7IG5vZGU/OiBQcm9zZU1pcnJvck5vZGUgfSkgPT4gbnVtYmVyXG59XG5cbmV4cG9ydCBjb25zdCBDaGFyYWN0ZXJDb3VudCA9IEV4dGVuc2lvbi5jcmVhdGU8Q2hhcmFjdGVyQ291bnRPcHRpb25zLCBDaGFyYWN0ZXJDb3VudFN0b3JhZ2U+KHtcbiAgbmFtZTogJ2NoYXJhY3RlckNvdW50JyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW1pdDogbnVsbCxcbiAgICAgIG1vZGU6ICd0ZXh0U2l6ZScsXG4gICAgfVxuICB9LFxuXG4gIGFkZFN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYXJhY3RlcnM6ICgpID0+IDAsXG4gICAgICB3b3JkczogKCkgPT4gMCxcbiAgICB9XG4gIH0sXG5cbiAgb25CZWZvcmVDcmVhdGUoKSB7XG4gICAgdGhpcy5zdG9yYWdlLmNoYXJhY3RlcnMgPSBvcHRpb25zID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSBvcHRpb25zPy5ub2RlIHx8IHRoaXMuZWRpdG9yLnN0YXRlLmRvY1xuICAgICAgY29uc3QgbW9kZSA9IG9wdGlvbnM/Lm1vZGUgfHwgdGhpcy5vcHRpb25zLm1vZGVcblxuICAgICAgaWYgKG1vZGUgPT09ICd0ZXh0U2l6ZScpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IG5vZGUudGV4dEJldHdlZW4oMCwgbm9kZS5jb250ZW50LnNpemUsIHVuZGVmaW5lZCwgJyAnKVxuXG4gICAgICAgIHJldHVybiB0ZXh0Lmxlbmd0aFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZS5ub2RlU2l6ZVxuICAgIH1cblxuICAgIHRoaXMuc3RvcmFnZS53b3JkcyA9IG9wdGlvbnMgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IG9wdGlvbnM/Lm5vZGUgfHwgdGhpcy5lZGl0b3Iuc3RhdGUuZG9jXG4gICAgICBjb25zdCB0ZXh0ID0gbm9kZS50ZXh0QmV0d2VlbigwLCBub2RlLmNvbnRlbnQuc2l6ZSwgJyAnLCAnICcpXG4gICAgICBjb25zdCB3b3JkcyA9IHRleHQuc3BsaXQoJyAnKS5maWx0ZXIod29yZCA9PiB3b3JkICE9PSAnJylcblxuICAgICAgcmV0dXJuIHdvcmRzLmxlbmd0aFxuICAgIH1cbiAgfSxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2NoYXJhY3RlckNvdW50JyksXG4gICAgICAgIGZpbHRlclRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb24sIHN0YXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgbGltaXQgPSB0aGlzLm9wdGlvbnMubGltaXRcblxuICAgICAgICAgIC8vIE5vdGhpbmcgaGFzIGNoYW5nZWQgb3Igbm8gbGltaXQgaXMgZGVmaW5lZC4gSWdub3JlIGl0LlxuICAgICAgICAgIGlmICghdHJhbnNhY3Rpb24uZG9jQ2hhbmdlZCB8fCBsaW1pdCA9PT0gMCB8fCBsaW1pdCA9PT0gbnVsbCB8fCBsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG9sZFNpemUgPSB0aGlzLnN0b3JhZ2UuY2hhcmFjdGVycyh7IG5vZGU6IHN0YXRlLmRvYyB9KVxuICAgICAgICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLnN0b3JhZ2UuY2hhcmFjdGVycyh7IG5vZGU6IHRyYW5zYWN0aW9uLmRvYyB9KVxuXG4gICAgICAgICAgLy8gRXZlcnl0aGluZyBpcyBpbiB0aGUgbGltaXQuIEdvb2QuXG4gICAgICAgICAgaWYgKG5ld1NpemUgPD0gbGltaXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVGhlIGxpbWl0IGhhcyBhbHJlYWR5IGJlZW4gZXhjZWVkZWQgYnV0IHdpbGwgYmUgcmVkdWNlZC5cbiAgICAgICAgICBpZiAob2xkU2l6ZSA+IGxpbWl0ICYmIG5ld1NpemUgPiBsaW1pdCAmJiBuZXdTaXplIDw9IG9sZFNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVGhlIGxpbWl0IGhhcyBhbHJlYWR5IGJlZW4gZXhjZWVkZWQgYW5kIHdpbGwgYmUgaW5jcmVhc2VkIGZ1cnRoZXIuXG4gICAgICAgICAgaWYgKG9sZFNpemUgPiBsaW1pdCAmJiBuZXdTaXplID4gbGltaXQgJiYgbmV3U2l6ZSA+IG9sZFNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGlzUGFzdGUgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCdwYXN0ZScpXG5cbiAgICAgICAgICAvLyBCbG9jayBhbGwgZXhjZWVkaW5nIHRyYW5zYWN0aW9ucyB0aGF0IHdlcmUgbm90IHBhc3RlZC5cbiAgICAgICAgICBpZiAoIWlzUGFzdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZvciBwYXN0ZWQgY29udGVudCwgd2UgdHJ5IHRvIHJlbW92ZSB0aGUgZXhjZWVkaW5nIGNvbnRlbnQuXG4gICAgICAgICAgY29uc3QgcG9zID0gdHJhbnNhY3Rpb24uc2VsZWN0aW9uLiRoZWFkLnBvc1xuICAgICAgICAgIGNvbnN0IG92ZXIgPSBuZXdTaXplIC0gbGltaXRcbiAgICAgICAgICBjb25zdCBmcm9tID0gcG9zIC0gb3ZlclxuICAgICAgICAgIGNvbnN0IHRvID0gcG9zXG5cbiAgICAgICAgICAvLyBJdOKAmXMgcHJvYmFibHkgYSBiYWQgaWRlYSB0byBtdXRhdGUgdHJhbnNhY3Rpb25zIHdpdGhpbiBgZmlsdGVyVHJhbnNhY3Rpb25gXG4gICAgICAgICAgLy8gYnV0IGZvciBub3cgdGhpcyBpcyB3b3JraW5nIGZpbmUuXG4gICAgICAgICAgdHJhbnNhY3Rpb24uZGVsZXRlUmFuZ2UoZnJvbSwgdG8pXG5cbiAgICAgICAgICAvLyBJbiBzb21lIHNpdHVhdGlvbnMsIHRoZSBsaW1pdCB3aWxsIGNvbnRpbnVlIHRvIGJlIGV4Y2VlZGVkIGFmdGVyIHRyaW1taW5nLlxuICAgICAgICAgIC8vIFRoaXMgaGFwcGVucyBlLmcuIHdoZW4gdHJ1bmNhdGluZyB3aXRoaW4gYSBjb21wbGV4IG5vZGUgKGUuZy4gdGFibGUpXG4gICAgICAgICAgLy8gYW5kIFByb3NlTWlycm9yIGhhcyB0byBjbG9zZSB0aGlzIG5vZGUgYWdhaW4uXG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgY2FzZSwgd2UgcHJldmVudCB0aGUgdHJhbnNhY3Rpb24gY29tcGxldGVseS5cbiAgICAgICAgICBjb25zdCB1cGRhdGVkU2l6ZSA9IHRoaXMuc3RvcmFnZS5jaGFyYWN0ZXJzKHsgbm9kZTogdHJhbnNhY3Rpb24uZG9jIH0pXG5cbiAgICAgICAgICBpZiAodXBkYXRlZFNpemUgPiBsaW1pdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCB3cmFwcGluZ0lucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBCbG9ja3F1b3RlT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgYmxvY2tRdW90ZToge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgYSBibG9ja3F1b3RlIG5vZGVcbiAgICAgICAqL1xuICAgICAgc2V0QmxvY2txdW90ZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGEgYmxvY2txdW90ZSBub2RlXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUJsb2NrcXVvdGU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGEgYmxvY2txdW90ZSBub2RlXG4gICAgICAgKi9cbiAgICAgIHVuc2V0QmxvY2txdW90ZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGlucHV0UmVnZXggPSAvXlxccyo+XFxzJC9cblxuZXhwb3J0IGNvbnN0IEJsb2NrcXVvdGUgPSBOb2RlLmNyZWF0ZTxCbG9ja3F1b3RlT3B0aW9ucz4oe1xuXG4gIG5hbWU6ICdibG9ja3F1b3RlJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIGNvbnRlbnQ6ICdibG9jaysnLFxuXG4gIGdyb3VwOiAnYmxvY2snLFxuXG4gIGRlZmluaW5nOiB0cnVlLFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB0YWc6ICdibG9ja3F1b3RlJyB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ2Jsb2NrcXVvdGUnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEJsb2NrcXVvdGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLndyYXBJbih0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdG9nZ2xlQmxvY2txdW90ZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlV3JhcCh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdW5zZXRCbG9ja3F1b3RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5saWZ0KHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLVNoaWZ0LWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCbG9ja3F1b3RlKCksXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHdyYXBwaW5nSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQge1xuICBNYXJrLFxuICBtYXJrSW5wdXRSdWxlLFxuICBtYXJrUGFzdGVSdWxlLFxuICBtZXJnZUF0dHJpYnV0ZXMsXG59IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBCb2xkT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgYm9sZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgYSBib2xkIG1hcmtcbiAgICAgICAqL1xuICAgICAgc2V0Qm9sZDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGEgYm9sZCBtYXJrXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUJvbGQ6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGEgYm9sZCBtYXJrXG4gICAgICAgKi9cbiAgICAgIHVuc2V0Qm9sZDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHN0YXJJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKSgoPzpcXCpcXCopKCg/OlteKl0rKSkoPzpcXCpcXCopKSQvXG5leHBvcnQgY29uc3Qgc3RhclBhc3RlUmVnZXggPSAvKD86XnxcXHMpKCg/OlxcKlxcKikoKD86W14qXSspKSg/OlxcKlxcKikpL2dcbmV4cG9ydCBjb25zdCB1bmRlcnNjb3JlSW5wdXRSZWdleCA9IC8oPzpefFxccykoKD86X18pKCg/OlteX19dKykpKD86X18pKSQvXG5leHBvcnQgY29uc3QgdW5kZXJzY29yZVBhc3RlUmVnZXggPSAvKD86XnxcXHMpKCg/Ol9fKSgoPzpbXl9fXSspKSg/Ol9fKSkvZ1xuXG5leHBvcnQgY29uc3QgQm9sZCA9IE1hcmsuY3JlYXRlPEJvbGRPcHRpb25zPih7XG4gIG5hbWU6ICdib2xkJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdzdHJvbmcnLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnYicsXG4gICAgICAgIGdldEF0dHJzOiBub2RlID0+IChub2RlIGFzIEhUTUxFbGVtZW50KS5zdHlsZS5mb250V2VpZ2h0ICE9PSAnbm9ybWFsJyAmJiBudWxsLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6ICdmb250LXdlaWdodCcsXG4gICAgICAgIGdldEF0dHJzOiB2YWx1ZSA9PiAvXihib2xkKGVyKT98WzUtOV1cXGR7Mix9KSQvLnRlc3QodmFsdWUgYXMgc3RyaW5nKSAmJiBudWxsLFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydzdHJvbmcnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEJvbGQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZUJvbGQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHVuc2V0Qm9sZDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCb2xkKCksXG4gICAgICAnTW9kLUInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCb2xkKCksXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBzdGFySW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogdW5kZXJzY29yZUlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcblxuICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogc3RhclBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6IHVuZGVyc2NvcmVQYXN0ZVJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBMaXN0SXRlbU9wdGlvbnMge1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PixcbiAgYnVsbGV0TGlzdFR5cGVOYW1lOiBzdHJpbmdcbiAgb3JkZXJlZExpc3RUeXBlTmFtZTogc3RyaW5nXG59XG5cbmV4cG9ydCBjb25zdCBMaXN0SXRlbSA9IE5vZGUuY3JlYXRlPExpc3RJdGVtT3B0aW9ucz4oe1xuICBuYW1lOiAnbGlzdEl0ZW0nLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgIGJ1bGxldExpc3RUeXBlTmFtZTogJ2J1bGxldExpc3QnLFxuICAgICAgb3JkZXJlZExpc3RUeXBlTmFtZTogJ29yZGVyZWRMaXN0JyxcbiAgICB9XG4gIH0sXG5cbiAgY29udGVudDogJ3BhcmFncmFwaCBibG9jayonLFxuXG4gIGRlZmluaW5nOiB0cnVlLFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdsaScsXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ2xpJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBFbnRlcjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc3BsaXRMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgICAgVGFiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zaW5rTGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgICdTaGlmdC1UYWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5saWZ0TGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICB9XG4gIH0sXG59KVxuIiwgImltcG9ydCB7XG4gIGdldE1hcmtBdHRyaWJ1dGVzLFxuICBNYXJrLFxuICBtZXJnZUF0dHJpYnV0ZXMsXG59IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBUZXh0U3R5bGVPcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIHNwYW5zIHdpdGhvdXQgaW5saW5lIHN0eWxlIGF0dHJpYnV0ZXMuXG4gICAgICAgKi9cbiAgICAgIHJlbW92ZUVtcHR5VGV4dFN0eWxlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgVGV4dFN0eWxlID0gTWFyay5jcmVhdGU8VGV4dFN0eWxlT3B0aW9ucz4oe1xuICBuYW1lOiAndGV4dFN0eWxlJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdzcGFuJyxcbiAgICAgICAgZ2V0QXR0cnM6IGVsZW1lbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IGhhc1N0eWxlcyA9IChlbGVtZW50IGFzIEhUTUxFbGVtZW50KS5oYXNBdHRyaWJ1dGUoJ3N0eWxlJylcblxuICAgICAgICAgIGlmICghaGFzU3R5bGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge31cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnc3BhbicsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlRW1wdHlUZXh0U3R5bGU6ICgpID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnZXRNYXJrQXR0cmlidXRlcyhzdGF0ZSwgdGhpcy50eXBlKVxuICAgICAgICBjb25zdCBoYXNTdHlsZXMgPSBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5zb21lKChbLCB2YWx1ZV0pID0+ICEhdmFsdWUpXG5cbiAgICAgICAgaWYgKGhhc1N0eWxlcykge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG59KVxuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSwgd3JhcHBpbmdJbnB1dFJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmltcG9ydCBMaXN0SXRlbSBmcm9tICcuLi8uLi9leHRlbnNpb24tbGlzdC1pdGVtL3NyYy9pbmRleC5qcydcbmltcG9ydCBUZXh0U3R5bGUgZnJvbSAnLi4vLi4vZXh0ZW5zaW9uLXRleHQtc3R5bGUvc3JjL2luZGV4LmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEJ1bGxldExpc3RPcHRpb25zIHtcbiAgaXRlbVR5cGVOYW1lOiBzdHJpbmcsXG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBrZWVwTWFya3M6IGJvb2xlYW4sXG4gIGtlZXBBdHRyaWJ1dGVzOiBib29sZWFuLFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgYnVsbGV0TGlzdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBidWxsZXQgbGlzdFxuICAgICAgICovXG4gICAgICB0b2dnbGVCdWxsZXRMaXN0OiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgaW5wdXRSZWdleCA9IC9eXFxzKihbLSsqXSlcXHMkL1xuXG5leHBvcnQgY29uc3QgQnVsbGV0TGlzdCA9IE5vZGUuY3JlYXRlPEJ1bGxldExpc3RPcHRpb25zPih7XG4gIG5hbWU6ICdidWxsZXRMaXN0JyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtVHlwZU5hbWU6ICdsaXN0SXRlbScsXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICBrZWVwTWFya3M6IGZhbHNlLFxuICAgICAga2VlcEF0dHJpYnV0ZXM6IGZhbHNlLFxuICAgIH1cbiAgfSxcblxuICBncm91cDogJ2Jsb2NrIGxpc3QnLFxuXG4gIGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWV9K2BcbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHsgdGFnOiAndWwnIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsndWwnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvZ2dsZUJ1bGxldExpc3Q6ICgpID0+ICh7IGNvbW1hbmRzLCBjaGFpbiB9KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICByZXR1cm4gY2hhaW4oKS50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcykudXBkYXRlQXR0cmlidXRlcyhMaXN0SXRlbS5uYW1lLCB0aGlzLmVkaXRvci5nZXRBdHRyaWJ1dGVzKFRleHRTdHlsZS5uYW1lKSkucnVuKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTGlzdCh0aGlzLm5hbWUsIHRoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWUsIHRoaXMub3B0aW9ucy5rZWVwTWFya3MpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC1TaGlmdC04JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQnVsbGV0TGlzdCgpLFxuICAgIH1cbiAgfSxcblxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIGxldCBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZSh7XG4gICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgIH0pXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBNYXJrcyB8fCB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgIGlucHV0UnVsZSA9IHdyYXBwaW5nSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBrZWVwTWFya3M6IHRoaXMub3B0aW9ucy5rZWVwTWFya3MsXG4gICAgICAgIGtlZXBBdHRyaWJ1dGVzOiB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6ICgpID0+IHsgcmV0dXJuIHRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlLm5hbWUpIH0sXG4gICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgaW5wdXRSdWxlLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHtcbiAgTWFyayxcbiAgbWFya0lucHV0UnVsZSxcbiAgbWFya1Bhc3RlUnVsZSxcbiAgbWVyZ2VBdHRyaWJ1dGVzLFxufSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZU9wdGlvbnMge1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGNvZGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgY29kZSBtYXJrXG4gICAgICAgKi9cbiAgICAgIHNldENvZGU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBpbmxpbmUgY29kZVxuICAgICAgICovXG4gICAgICB0b2dnbGVDb2RlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBVbnNldCBhIGNvZGUgbWFya1xuICAgICAgICovXG4gICAgICB1bnNldENvZGU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKSgoPzpgKSgoPzpbXmBdKykpKD86YCkpJC9cbmV4cG9ydCBjb25zdCBwYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKSgoPzpgKSgoPzpbXmBdKykpKD86YCkpL2dcblxuZXhwb3J0IGNvbnN0IENvZGUgPSBNYXJrLmNyZWF0ZTxDb2RlT3B0aW9ucz4oe1xuICBuYW1lOiAnY29kZScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBleGNsdWRlczogJ18nLFxuXG4gIGNvZGU6IHRydWUsXG5cbiAgZXhpdGFibGU6IHRydWUsXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7IHRhZzogJ2NvZGUnIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnY29kZScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0Q29kZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdG9nZ2xlQ29kZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdW5zZXRDb2RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtZSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUNvZGUoKSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcblxuICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogcGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUsIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSwgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZUJsb2NrT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBBZGRzIGEgcHJlZml4IHRvIGxhbmd1YWdlIGNsYXNzZXMgdGhhdCBhcmUgYXBwbGllZCB0byBjb2RlIHRhZ3MuXG4gICAqIERlZmF1bHRzIHRvIGAnbGFuZ3VhZ2UtJ2AuXG4gICAqL1xuICBsYW5ndWFnZUNsYXNzUHJlZml4OiBzdHJpbmdcbiAgLyoqXG4gICAqIERlZmluZSB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBleGl0ZWQgb24gdHJpcGxlIGVudGVyLlxuICAgKiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqL1xuICBleGl0T25UcmlwbGVFbnRlcjogYm9vbGVhblxuICAvKipcbiAgICogRGVmaW5lIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGV4aXRlZCBvbiBhcnJvdyBkb3duIGlmIHRoZXJlIGlzIG5vIG5vZGUgYWZ0ZXIgaXQuXG4gICAqIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICovXG4gIGV4aXRPbkFycm93RG93bjogYm9vbGVhblxuICAvKipcbiAgICogQ3VzdG9tIEhUTUwgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB0aGUgcmVuZGVyZWQgSFRNTCB0YWcuXG4gICAqL1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgY29kZUJsb2NrOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBhIGNvZGUgYmxvY2tcbiAgICAgICAqL1xuICAgICAgc2V0Q29kZUJsb2NrOiAoYXR0cmlidXRlcz86IHsgbGFuZ3VhZ2U6IHN0cmluZyB9KSA9PiBSZXR1cm5UeXBlXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIGNvZGUgYmxvY2tcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlQ29kZUJsb2NrOiAoYXR0cmlidXRlcz86IHsgbGFuZ3VhZ2U6IHN0cmluZyB9KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBiYWNrdGlja0lucHV0UmVnZXggPSAvXmBgYChbYS16XSspP1tcXHNcXG5dJC9cbmV4cG9ydCBjb25zdCB0aWxkZUlucHV0UmVnZXggPSAvXn5+fihbYS16XSspP1tcXHNcXG5dJC9cblxuZXhwb3J0IGNvbnN0IENvZGVCbG9jayA9IE5vZGUuY3JlYXRlPENvZGVCbG9ja09wdGlvbnM+KHtcbiAgbmFtZTogJ2NvZGVCbG9jaycsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGFuZ3VhZ2VDbGFzc1ByZWZpeDogJ2xhbmd1YWdlLScsXG4gICAgICBleGl0T25UcmlwbGVFbnRlcjogdHJ1ZSxcbiAgICAgIGV4aXRPbkFycm93RG93bjogdHJ1ZSxcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgY29udGVudDogJ3RleHQqJyxcblxuICBtYXJrczogJycsXG5cbiAgZ3JvdXA6ICdibG9jaycsXG5cbiAgY29kZTogdHJ1ZSxcblxuICBkZWZpbmluZzogdHJ1ZSxcblxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsYW5ndWFnZToge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgbGFuZ3VhZ2VDbGFzc1ByZWZpeCB9ID0gdGhpcy5vcHRpb25zXG4gICAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IFsuLi4oZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZD8uY2xhc3NMaXN0IHx8IFtdKV1cbiAgICAgICAgICBjb25zdCBsYW5ndWFnZXMgPSBjbGFzc05hbWVzXG4gICAgICAgICAgICAuZmlsdGVyKGNsYXNzTmFtZSA9PiBjbGFzc05hbWUuc3RhcnRzV2l0aChsYW5ndWFnZUNsYXNzUHJlZml4KSlcbiAgICAgICAgICAgIC5tYXAoY2xhc3NOYW1lID0+IGNsYXNzTmFtZS5yZXBsYWNlKGxhbmd1YWdlQ2xhc3NQcmVmaXgsICcnKSlcbiAgICAgICAgICBjb25zdCBsYW5ndWFnZSA9IGxhbmd1YWdlc1swXVxuXG4gICAgICAgICAgaWYgKCFsYW5ndWFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2VcbiAgICAgICAgfSxcbiAgICAgICAgcmVuZGVyZWQ6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ3ByZScsXG4gICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogJ2Z1bGwnLFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IG5vZGUsIEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ3ByZScsXG4gICAgICBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksXG4gICAgICBbXG4gICAgICAgICdjb2RlJyxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzOiBub2RlLmF0dHJzLmxhbmd1YWdlXG4gICAgICAgICAgICA/IHRoaXMub3B0aW9ucy5sYW5ndWFnZUNsYXNzUHJlZml4ICsgbm9kZS5hdHRycy5sYW5ndWFnZVxuICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICB9LFxuICAgICAgICAwLFxuICAgICAgXSxcbiAgICBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldENvZGVCbG9jazpcbiAgICAgICAgYXR0cmlidXRlcyA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodGhpcy5uYW1lLCBhdHRyaWJ1dGVzKVxuICAgICAgICB9LFxuICAgICAgdG9nZ2xlQ29kZUJsb2NrOlxuICAgICAgICBhdHRyaWJ1dGVzID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTm9kZSh0aGlzLm5hbWUsICdwYXJhZ3JhcGgnLCBhdHRyaWJ1dGVzKVxuICAgICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC1BbHQtYyc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUNvZGVCbG9jaygpLFxuXG4gICAgICAvLyByZW1vdmUgY29kZSBibG9jayB3aGVuIGF0IHN0YXJ0IG9mIGRvY3VtZW50IG9yIGNvZGUgYmxvY2sgaXMgZW1wdHlcbiAgICAgIEJhY2tzcGFjZTogKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGVtcHR5LCAkYW5jaG9yIH0gPSB0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb25cbiAgICAgICAgY29uc3QgaXNBdFN0YXJ0ID0gJGFuY2hvci5wb3MgPT09IDFcblxuICAgICAgICBpZiAoIWVtcHR5IHx8ICRhbmNob3IucGFyZW50LnR5cGUubmFtZSAhPT0gdGhpcy5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNBdFN0YXJ0IHx8ICEkYW5jaG9yLnBhcmVudC50ZXh0Q29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3IuY29tbWFuZHMuY2xlYXJOb2RlcygpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIC8vIGV4aXQgbm9kZSBvbiB0cmlwbGUgZW50ZXJcbiAgICAgIEVudGVyOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5leGl0T25UcmlwbGVFbnRlcikge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yXG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICAgICAgICBjb25zdCB7ICRmcm9tLCBlbXB0eSB9ID0gc2VsZWN0aW9uXG5cbiAgICAgICAgaWYgKCFlbXB0eSB8fCAkZnJvbS5wYXJlbnQudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc0F0RW5kID0gJGZyb20ucGFyZW50T2Zmc2V0ID09PSAkZnJvbS5wYXJlbnQubm9kZVNpemUgLSAyXG4gICAgICAgIGNvbnN0IGVuZHNXaXRoRG91YmxlTmV3bGluZSA9ICRmcm9tLnBhcmVudC50ZXh0Q29udGVudC5lbmRzV2l0aCgnXFxuXFxuJylcblxuICAgICAgICBpZiAoIWlzQXRFbmQgfHwgIWVuZHNXaXRoRG91YmxlTmV3bGluZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVkaXRvclxuICAgICAgICAgIC5jaGFpbigpXG4gICAgICAgICAgLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgICAgICAgdHIuZGVsZXRlKCRmcm9tLnBvcyAtIDIsICRmcm9tLnBvcylcblxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5leGl0Q29kZSgpXG4gICAgICAgICAgLnJ1bigpXG4gICAgICB9LFxuXG4gICAgICAvLyBleGl0IG5vZGUgb24gYXJyb3cgZG93blxuICAgICAgQXJyb3dEb3duOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5leGl0T25BcnJvd0Rvd24pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvclxuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgZG9jIH0gPSBzdGF0ZVxuICAgICAgICBjb25zdCB7ICRmcm9tLCBlbXB0eSB9ID0gc2VsZWN0aW9uXG5cbiAgICAgICAgaWYgKCFlbXB0eSB8fCAkZnJvbS5wYXJlbnQudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc0F0RW5kID0gJGZyb20ucGFyZW50T2Zmc2V0ID09PSAkZnJvbS5wYXJlbnQubm9kZVNpemUgLSAyXG5cbiAgICAgICAgaWYgKCFpc0F0RW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhZnRlciA9ICRmcm9tLmFmdGVyKClcblxuICAgICAgICBpZiAoYWZ0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgbm9kZUFmdGVyID0gZG9jLm5vZGVBdChhZnRlcilcblxuICAgICAgICBpZiAobm9kZUFmdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmV4aXRDb2RlKClcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBiYWNrdGlja0lucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4gKHtcbiAgICAgICAgICBsYW5ndWFnZTogbWF0Y2hbMV0sXG4gICAgICAgIH0pLFxuICAgICAgfSksXG4gICAgICB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogdGlsZGVJbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+ICh7XG4gICAgICAgICAgbGFuZ3VhZ2U6IG1hdGNoWzFdLFxuICAgICAgICB9KSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIHRoaXMgcGx1Z2luIGNyZWF0ZXMgYSBjb2RlIGJsb2NrIGZvciBwYXN0ZWQgY29udGVudCBmcm9tIFZTIENvZGVcbiAgICAgIC8vIHdlIGNhbiBhbHNvIGRldGVjdCB0aGUgY29waWVkIGNvZGUgbGFuZ3VhZ2VcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2NvZGVCbG9ja1ZTQ29kZUhhbmRsZXInKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBoYW5kbGVQYXN0ZTogKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LmNsaXBib2FyZERhdGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvbuKAmXQgY3JlYXRlIGEgbmV3IGNvZGUgYmxvY2sgd2l0aGluIGNvZGUgYmxvY2tzXG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0b3IuaXNBY3RpdmUodGhpcy50eXBlLm5hbWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJylcbiAgICAgICAgICAgIGNvbnN0IHZzY29kZSA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndnNjb2RlLWVkaXRvci1kYXRhJylcbiAgICAgICAgICAgIGNvbnN0IHZzY29kZURhdGEgPSB2c2NvZGUgPyBKU09OLnBhcnNlKHZzY29kZSkgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIGNvbnN0IGxhbmd1YWdlID0gdnNjb2RlRGF0YT8ubW9kZVxuXG4gICAgICAgICAgICBpZiAoIXRleHQgfHwgIWxhbmd1YWdlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB7IHRyIH0gPSB2aWV3LnN0YXRlXG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBjb2RlIGJsb2NrXG4gICAgICAgICAgICB0ci5yZXBsYWNlU2VsZWN0aW9uV2l0aCh0aGlzLnR5cGUuY3JlYXRlKHsgbGFuZ3VhZ2UgfSkpXG5cbiAgICAgICAgICAgIC8vIHB1dCBjdXJzb3IgaW5zaWRlIHRoZSBuZXdseSBjcmVhdGVkIGNvZGUgYmxvY2tcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoTWF0aC5tYXgoMCwgdHIuc2VsZWN0aW9uLmZyb20gLSAyKSkpKVxuXG4gICAgICAgICAgICAvLyBhZGQgdGV4dCB0byBjb2RlIGJsb2NrXG4gICAgICAgICAgICAvLyBzdHJpcCBjYXJyaWFnZSByZXR1cm4gY2hhcnMgZnJvbSB0ZXh0IHBhc3RlZCBhcyBjb2RlXG4gICAgICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9zZU1pcnJvci9wcm9zZW1pcnJvci12aWV3L2NvbW1pdC9hNTBhNmJjY2ViNGNlNTJhYzhmY2M2MTYyNDg4ZDg4NzU2MTNhYWNkXG4gICAgICAgICAgICB0ci5pbnNlcnRUZXh0KHRleHQucmVwbGFjZSgvXFxyXFxuPy9nLCAnXFxuJykpXG5cbiAgICAgICAgICAgIC8vIHN0b3JlIG1ldGEgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdXNlZnVsIGZvciBvdGhlciBwbHVnaW5zIHRoYXQgZGVwZW5kcyBvbiB0aGUgcGFzdGUgZXZlbnRcbiAgICAgICAgICAgIC8vIGxpa2UgdGhlIHBhc3RlIHJ1bGUgcGx1Z2luXG4gICAgICAgICAgICB0ci5zZXRNZXRhKCdwYXN0ZScsIHRydWUpXG5cbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpXG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgZHJvcFBvaW50IH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcblxuLyoqXG5DcmVhdGUgYSBwbHVnaW4gdGhhdCwgd2hlbiBhZGRlZCB0byBhIFByb3NlTWlycm9yIGluc3RhbmNlLFxuY2F1c2VzIGEgZGVjb3JhdGlvbiB0byBzaG93IHVwIGF0IHRoZSBkcm9wIHBvc2l0aW9uIHdoZW4gc29tZXRoaW5nXG5pcyBkcmFnZ2VkIG92ZXIgdGhlIGVkaXRvci5cblxuTm9kZXMgbWF5IGFkZCBhIGBkaXNhYmxlRHJvcEN1cnNvcmAgcHJvcGVydHkgdG8gdGhlaXIgc3BlYyB0b1xuY29udHJvbCB0aGUgc2hvd2luZyBvZiBhIGRyb3AgY3Vyc29yIGluc2lkZSB0aGVtLiBUaGlzIG1heSBiZSBhXG5ib29sZWFuIG9yIGEgZnVuY3Rpb24sIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggYSB2aWV3IGFuZCBhXG5wb3NpdGlvbiwgYW5kIHNob3VsZCByZXR1cm4gYSBib29sZWFuLlxuKi9cbmZ1bmN0aW9uIGRyb3BDdXJzb3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICB2aWV3KGVkaXRvclZpZXcpIHsgcmV0dXJuIG5ldyBEcm9wQ3Vyc29yVmlldyhlZGl0b3JWaWV3LCBvcHRpb25zKTsgfVxuICAgIH0pO1xufVxuY2xhc3MgRHJvcEN1cnNvclZpZXcge1xuICAgIGNvbnN0cnVjdG9yKGVkaXRvclZpZXcsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmVkaXRvclZpZXcgPSBlZGl0b3JWaWV3O1xuICAgICAgICB0aGlzLmN1cnNvclBvcyA9IG51bGw7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMudGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLndpZHRoID0gKF9hID0gb3B0aW9ucy53aWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdGlvbnMuY29sb3IgPT09IGZhbHNlID8gdW5kZWZpbmVkIDogKG9wdGlvbnMuY29sb3IgfHwgXCJibGFja1wiKTtcbiAgICAgICAgdGhpcy5jbGFzcyA9IG9wdGlvbnMuY2xhc3M7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXCJkcmFnb3ZlclwiLCBcImRyYWdlbmRcIiwgXCJkcm9wXCIsIFwiZHJhZ2xlYXZlXCJdLm1hcChuYW1lID0+IHtcbiAgICAgICAgICAgIGxldCBoYW5kbGVyID0gKGUpID0+IHsgdGhpc1tuYW1lXShlKTsgfTtcbiAgICAgICAgICAgIGVkaXRvclZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lLCBoYW5kbGVyIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzLmZvckVhY2goKHsgbmFtZSwgaGFuZGxlciB9KSA9PiB0aGlzLmVkaXRvclZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcikpO1xuICAgIH1cbiAgICB1cGRhdGUoZWRpdG9yVmlldywgcHJldlN0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvclBvcyAhPSBudWxsICYmIHByZXZTdGF0ZS5kb2MgIT0gZWRpdG9yVmlldy5zdGF0ZS5kb2MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnNvclBvcyA+IGVkaXRvclZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnNvcihudWxsKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU92ZXJsYXkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRDdXJzb3IocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPT0gdGhpcy5jdXJzb3JQb3MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gcG9zO1xuICAgICAgICBpZiAocG9zID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVPdmVybGF5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlT3ZlcmxheSgpIHtcbiAgICAgICAgbGV0ICRwb3MgPSB0aGlzLmVkaXRvclZpZXcuc3RhdGUuZG9jLnJlc29sdmUodGhpcy5jdXJzb3JQb3MpO1xuICAgICAgICBsZXQgaXNCbG9jayA9ICEkcG9zLnBhcmVudC5pbmxpbmVDb250ZW50LCByZWN0O1xuICAgICAgICBpZiAoaXNCbG9jaykge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZSwgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgICAgIGlmIChiZWZvcmUgfHwgYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZWRpdG9yVmlldy5ub2RlRE9NKHRoaXMuY3Vyc29yUG9zIC0gKGJlZm9yZSA/IGJlZm9yZS5ub2RlU2l6ZSA6IDApKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZVJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG9wID0gYmVmb3JlID8gbm9kZVJlY3QuYm90dG9tIDogbm9kZVJlY3QudG9wO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmVmb3JlICYmIGFmdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gKHRvcCArIHRoaXMuZWRpdG9yVmlldy5ub2RlRE9NKHRoaXMuY3Vyc29yUG9zKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogbm9kZVJlY3QubGVmdCwgcmlnaHQ6IG5vZGVSZWN0LnJpZ2h0LCB0b3A6IHRvcCAtIHRoaXMud2lkdGggLyAyLCBib3R0b206IHRvcCArIHRoaXMud2lkdGggLyAyIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVjdCkge1xuICAgICAgICAgICAgbGV0IGNvb3JkcyA9IHRoaXMuZWRpdG9yVmlldy5jb29yZHNBdFBvcyh0aGlzLmN1cnNvclBvcyk7XG4gICAgICAgICAgICByZWN0ID0geyBsZWZ0OiBjb29yZHMubGVmdCAtIHRoaXMud2lkdGggLyAyLCByaWdodDogY29vcmRzLmxlZnQgKyB0aGlzLndpZHRoIC8gMiwgdG9wOiBjb29yZHMudG9wLCBib3R0b206IGNvb3Jkcy5ib3R0b20gfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5lZGl0b3JWaWV3LmRvbS5vZmZzZXRQYXJlbnQ7XG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGFzcylcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5jbGFzcztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogYWJzb2x1dGU7IHotaW5kZXg6IDUwOyBwb2ludGVyLWV2ZW50czogbm9uZTtcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoXCJwcm9zZW1pcnJvci1kcm9wY3Vyc29yLWJsb2NrXCIsIGlzQmxvY2spO1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcInByb3NlbWlycm9yLWRyb3BjdXJzb3ItaW5saW5lXCIsICFpc0Jsb2NrKTtcbiAgICAgICAgbGV0IHBhcmVudExlZnQsIHBhcmVudFRvcDtcbiAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50ID09IGRvY3VtZW50LmJvZHkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpLnBvc2l0aW9uID09IFwic3RhdGljXCIpIHtcbiAgICAgICAgICAgIHBhcmVudExlZnQgPSAtcGFnZVhPZmZzZXQ7XG4gICAgICAgICAgICBwYXJlbnRUb3AgPSAtcGFnZVlPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHBhcmVudExlZnQgPSByZWN0LmxlZnQgLSBwYXJlbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIHBhcmVudFRvcCA9IHJlY3QudG9wIC0gcGFyZW50LnNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUubGVmdCA9IChyZWN0LmxlZnQgLSBwYXJlbnRMZWZ0KSArIFwicHhcIjtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnRvcCA9IChyZWN0LnRvcCAtIHBhcmVudFRvcCkgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9IChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSArIFwicHhcIjtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IChyZWN0LmJvdHRvbSAtIHJlY3QudG9wKSArIFwicHhcIjtcbiAgICB9XG4gICAgc2NoZWR1bGVSZW1vdmFsKHRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZXRDdXJzb3IobnVsbCksIHRpbWVvdXQpO1xuICAgIH1cbiAgICBkcmFnb3ZlcihldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuZWRpdG9yVmlldy5lZGl0YWJsZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuZWRpdG9yVmlldy5wb3NBdENvb3Jkcyh7IGxlZnQ6IGV2ZW50LmNsaWVudFgsIHRvcDogZXZlbnQuY2xpZW50WSB9KTtcbiAgICAgICAgbGV0IG5vZGUgPSBwb3MgJiYgcG9zLmluc2lkZSA+PSAwICYmIHRoaXMuZWRpdG9yVmlldy5zdGF0ZS5kb2Mubm9kZUF0KHBvcy5pbnNpZGUpO1xuICAgICAgICBsZXQgZGlzYWJsZURyb3BDdXJzb3IgPSBub2RlICYmIG5vZGUudHlwZS5zcGVjLmRpc2FibGVEcm9wQ3Vyc29yO1xuICAgICAgICBsZXQgZGlzYWJsZWQgPSB0eXBlb2YgZGlzYWJsZURyb3BDdXJzb3IgPT0gXCJmdW5jdGlvblwiID8gZGlzYWJsZURyb3BDdXJzb3IodGhpcy5lZGl0b3JWaWV3LCBwb3MsIGV2ZW50KSA6IGRpc2FibGVEcm9wQ3Vyc29yO1xuICAgICAgICBpZiAocG9zICYmICFkaXNhYmxlZCkge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHBvcy5wb3M7XG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0b3JWaWV3LmRyYWdnaW5nICYmIHRoaXMuZWRpdG9yVmlldy5kcmFnZ2luZy5zbGljZSkge1xuICAgICAgICAgICAgICAgIGxldCBwb2ludCA9IGRyb3BQb2ludCh0aGlzLmVkaXRvclZpZXcuc3RhdGUuZG9jLCB0YXJnZXQsIHRoaXMuZWRpdG9yVmlldy5kcmFnZ2luZy5zbGljZSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IodGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW1vdmFsKDUwMDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYWdlbmQoKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZW1vdmFsKDIwKTtcbiAgICB9XG4gICAgZHJvcCgpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbW92YWwoMjApO1xuICAgIH1cbiAgICBkcmFnbGVhdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PSB0aGlzLmVkaXRvclZpZXcuZG9tIHx8ICF0aGlzLmVkaXRvclZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IobnVsbCk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBkcm9wQ3Vyc29yIH07XG4iLCAiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHsgZHJvcEN1cnNvciB9IGZyb20gJ0B0aXB0YXAvcG0vZHJvcGN1cnNvcidcblxuZXhwb3J0IGludGVyZmFjZSBEcm9wY3Vyc29yT3B0aW9ucyB7XG4gIGNvbG9yOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIHdpZHRoOiBudW1iZXIgfCB1bmRlZmluZWQsXG4gIGNsYXNzOiBzdHJpbmcgfCB1bmRlZmluZWQsXG59XG5cbmV4cG9ydCBjb25zdCBEcm9wY3Vyc29yID0gRXh0ZW5zaW9uLmNyZWF0ZTxEcm9wY3Vyc29yT3B0aW9ucz4oe1xuICBuYW1lOiAnZHJvcEN1cnNvcicsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgICAgd2lkdGg6IDEsXG4gICAgICBjbGFzczogdW5kZWZpbmVkLFxuICAgIH1cbiAgfSxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGRyb3BDdXJzb3IodGhpcy5vcHRpb25zKSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IGtleWRvd25IYW5kbGVyIH0gZnJvbSAncHJvc2VtaXJyb3Ita2V5bWFwJztcbmltcG9ydCB7IFNlbGVjdGlvbiwgTm9kZVNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiwgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgU2xpY2UsIEZyYWdtZW50IH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgRGVjb3JhdGlvblNldCwgRGVjb3JhdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnO1xuXG4vKipcbkdhcCBjdXJzb3Igc2VsZWN0aW9ucyBhcmUgcmVwcmVzZW50ZWQgdXNpbmcgdGhpcyBjbGFzcy4gSXRzXG5gJGFuY2hvcmAgYW5kIGAkaGVhZGAgcHJvcGVydGllcyBib3RoIHBvaW50IGF0IHRoZSBjdXJzb3IgcG9zaXRpb24uXG4qL1xuY2xhc3MgR2FwQ3Vyc29yIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBnYXAgY3Vyc29yLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoJHBvcykge1xuICAgICAgICBzdXBlcigkcG9zLCAkcG9zKTtcbiAgICB9XG4gICAgbWFwKGRvYywgbWFwcGluZykge1xuICAgICAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICAgICAgICByZXR1cm4gR2FwQ3Vyc29yLnZhbGlkKCRwb3MpID8gbmV3IEdhcEN1cnNvcigkcG9zKSA6IFNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgIH1cbiAgICBjb250ZW50KCkgeyByZXR1cm4gU2xpY2UuZW1wdHk7IH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBHYXBDdXJzb3IgJiYgb3RoZXIuaGVhZCA9PSB0aGlzLmhlYWQ7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJnYXBjdXJzb3JcIiwgcG9zOiB0aGlzLmhlYWQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgR2FwQ3Vyc29yLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEdhcEN1cnNvcihkb2MucmVzb2x2ZShqc29uLnBvcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldEJvb2ttYXJrKCkgeyByZXR1cm4gbmV3IEdhcEJvb2ttYXJrKHRoaXMuYW5jaG9yKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHZhbGlkKCRwb3MpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICRwb3MucGFyZW50O1xuICAgICAgICBpZiAocGFyZW50LmlzVGV4dGJsb2NrIHx8ICFjbG9zZWRCZWZvcmUoJHBvcykgfHwgIWNsb3NlZEFmdGVyKCRwb3MpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgb3ZlcnJpZGUgPSBwYXJlbnQudHlwZS5zcGVjLmFsbG93R2FwQ3Vyc29yO1xuICAgICAgICBpZiAob3ZlcnJpZGUgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBvdmVycmlkZTtcbiAgICAgICAgbGV0IGRlZmx0ID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KCRwb3MuaW5kZXgoKSkuZGVmYXVsdFR5cGU7XG4gICAgICAgIHJldHVybiBkZWZsdCAmJiBkZWZsdC5pc1RleHRibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZEdhcEN1cnNvckZyb20oJHBvcywgZGlyLCBtdXN0TW92ZSA9IGZhbHNlKSB7XG4gICAgICAgIHNlYXJjaDogZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKCFtdXN0TW92ZSAmJiBHYXBDdXJzb3IudmFsaWQoJHBvcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3M7XG4gICAgICAgICAgICBsZXQgcG9zID0gJHBvcy5wb3MsIG5leHQgPSBudWxsO1xuICAgICAgICAgICAgLy8gU2NhbiB1cCBmcm9tIHRoaXMgcG9zaXRpb25cbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOzsgZC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9ICRwb3Mubm9kZShkKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMCA/ICRwb3MuaW5kZXhBZnRlcihkKSA8IHBhcmVudC5jaGlsZENvdW50IDogJHBvcy5pbmRleChkKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBhcmVudC5jaGlsZChkaXIgPiAwID8gJHBvcy5pbmRleEFmdGVyKGQpIDogJHBvcy5pbmRleChkKSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgKz0gZGlyO1xuICAgICAgICAgICAgICAgIGxldCAkY3VyID0gJHBvcy5kb2MucmVzb2x2ZShwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChHYXBDdXJzb3IudmFsaWQoJGN1cikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkY3VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQW5kIHRoZW4gZG93biBpbnRvIHRoZSBuZXh0IG5vZGVcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zaWRlID0gZGlyID4gMCA/IG5leHQuZmlyc3RDaGlsZCA6IG5leHQubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgIGlmICghaW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmlzQXRvbSAmJiAhbmV4dC5pc1RleHQgJiYgIU5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcG9zID0gJHBvcy5kb2MucmVzb2x2ZShwb3MgKyBuZXh0Lm5vZGVTaXplICogZGlyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11c3RNb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBzZWFyY2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQgPSBpbnNpZGU7XG4gICAgICAgICAgICAgICAgcG9zICs9IGRpcjtcbiAgICAgICAgICAgICAgICBsZXQgJGN1ciA9ICRwb3MuZG9jLnJlc29sdmUocG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoR2FwQ3Vyc29yLnZhbGlkKCRjdXIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGN1cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuR2FwQ3Vyc29yLnByb3RvdHlwZS52aXNpYmxlID0gZmFsc2U7XG5HYXBDdXJzb3IuZmluZEZyb20gPSBHYXBDdXJzb3IuZmluZEdhcEN1cnNvckZyb207XG5TZWxlY3Rpb24uanNvbklEKFwiZ2FwY3Vyc29yXCIsIEdhcEN1cnNvcik7XG5jbGFzcyBHYXBCb29rbWFyayB7XG4gICAgY29uc3RydWN0b3IocG9zKSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICByZXR1cm4gbmV3IEdhcEJvb2ttYXJrKG1hcHBpbmcubWFwKHRoaXMucG9zKSk7XG4gICAgfVxuICAgIHJlc29sdmUoZG9jKSB7XG4gICAgICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUodGhpcy5wb3MpO1xuICAgICAgICByZXR1cm4gR2FwQ3Vyc29yLnZhbGlkKCRwb3MpID8gbmV3IEdhcEN1cnNvcigkcG9zKSA6IFNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb3NlZEJlZm9yZSgkcG9zKSB7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXgoZCksIHBhcmVudCA9ICRwb3Mubm9kZShkKTtcbiAgICAgICAgLy8gQXQgdGhlIHN0YXJ0IG9mIHRoaXMgcGFyZW50LCBsb29rIGF0IG5leHQgb25lXG4gICAgICAgIGlmIChpbmRleCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWUgaWYgdGhlIG5vZGUgYmVmb3JlIChvciBpdHMgZmlyc3QgYW5jZXN0b3IpIGlzIGNsb3NlZFxuICAgICAgICBmb3IgKGxldCBiZWZvcmUgPSBwYXJlbnQuY2hpbGQoaW5kZXggLSAxKTs7IGJlZm9yZSA9IGJlZm9yZS5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGlmICgoYmVmb3JlLmNoaWxkQ291bnQgPT0gMCAmJiAhYmVmb3JlLmlubGluZUNvbnRlbnQpIHx8IGJlZm9yZS5pc0F0b20gfHwgYmVmb3JlLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoYmVmb3JlLmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhpdCBzdGFydCBvZiBkb2N1bWVudFxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2xvc2VkQWZ0ZXIoJHBvcykge1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoZCksIHBhcmVudCA9ICRwb3Mubm9kZShkKTtcbiAgICAgICAgaWYgKGluZGV4ID09IHBhcmVudC5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBhZnRlciA9IHBhcmVudC5jaGlsZChpbmRleCk7OyBhZnRlciA9IGFmdGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGlmICgoYWZ0ZXIuY2hpbGRDb3VudCA9PSAwICYmICFhZnRlci5pbmxpbmVDb250ZW50KSB8fCBhZnRlci5pc0F0b20gfHwgYWZ0ZXIudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChhZnRlci5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG5DcmVhdGUgYSBnYXAgY3Vyc29yIHBsdWdpbi4gV2hlbiBlbmFibGVkLCB0aGlzIHdpbGwgY2FwdHVyZSBjbGlja3Ncbm5lYXIgYW5kIGFycm93LWtleS1tb3Rpb24gcGFzdCBwbGFjZXMgdGhhdCBkb24ndCBoYXZlIGEgbm9ybWFsbHlcbnNlbGVjdGFibGUgcG9zaXRpb24gbmVhcmJ5LCBhbmQgY3JlYXRlIGEgZ2FwIGN1cnNvciBzZWxlY3Rpb24gZm9yXG50aGVtLiBUaGUgY3Vyc29yIGlzIGRyYXduIGFzIGFuIGVsZW1lbnQgd2l0aCBjbGFzc1xuYFByb3NlTWlycm9yLWdhcGN1cnNvcmAuIFlvdSBjYW4gZWl0aGVyIGluY2x1ZGVcbmBzdHlsZS9nYXBjdXJzb3IuY3NzYCBmcm9tIHRoZSBwYWNrYWdlJ3MgZGlyZWN0b3J5IG9yIGFkZCB5b3VyIG93blxuc3R5bGVzIHRvIG1ha2UgaXQgdmlzaWJsZS5cbiovXG5mdW5jdGlvbiBnYXBDdXJzb3IoKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZGVjb3JhdGlvbnM6IGRyYXdHYXBDdXJzb3IsXG4gICAgICAgICAgICBjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuKF92aWV3LCAkYW5jaG9yLCAkaGVhZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkYW5jaG9yLnBvcyA9PSAkaGVhZC5wb3MgJiYgR2FwQ3Vyc29yLnZhbGlkKCRoZWFkKSA/IG5ldyBHYXBDdXJzb3IoJGhlYWQpIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVDbGljayxcbiAgICAgICAgICAgIGhhbmRsZUtleURvd24sXG4gICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHsgYmVmb3JlaW5wdXQ6IGJlZm9yZWlucHV0IH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgaGFuZGxlS2V5RG93biA9IGtleWRvd25IYW5kbGVyKHtcbiAgICBcIkFycm93TGVmdFwiOiBhcnJvdyhcImhvcml6XCIsIC0xKSxcbiAgICBcIkFycm93UmlnaHRcIjogYXJyb3coXCJob3JpelwiLCAxKSxcbiAgICBcIkFycm93VXBcIjogYXJyb3coXCJ2ZXJ0XCIsIC0xKSxcbiAgICBcIkFycm93RG93blwiOiBhcnJvdyhcInZlcnRcIiwgMSlcbn0pO1xuZnVuY3Rpb24gYXJyb3coYXhpcywgZGlyKSB7XG4gICAgY29uc3QgZGlyU3RyID0gYXhpcyA9PSBcInZlcnRcIiA/IChkaXIgPiAwID8gXCJkb3duXCIgOiBcInVwXCIpIDogKGRpciA+IDAgPyBcInJpZ2h0XCIgOiBcImxlZnRcIik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgICAgICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0ICRzdGFydCA9IGRpciA+IDAgPyBzZWwuJHRvIDogc2VsLiRmcm9tLCBtdXN0TW92ZSA9IHNlbC5lbXB0eTtcbiAgICAgICAgaWYgKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICghdmlldy5lbmRPZlRleHRibG9jayhkaXJTdHIpIHx8ICRzdGFydC5kZXB0aCA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG11c3RNb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAkc3RhcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShkaXIgPiAwID8gJHN0YXJ0LmFmdGVyKCkgOiAkc3RhcnQuYmVmb3JlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCAkZm91bmQgPSBHYXBDdXJzb3IuZmluZEdhcEN1cnNvckZyb20oJHN0YXJ0LCBkaXIsIG11c3RNb3ZlKTtcbiAgICAgICAgaWYgKCEkZm91bmQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgR2FwQ3Vyc29yKCRmb3VuZCkpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNsaWNrKHZpZXcsIHBvcywgZXZlbnQpIHtcbiAgICBpZiAoIXZpZXcgfHwgIXZpZXcuZWRpdGFibGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoIUdhcEN1cnNvci52YWxpZCgkcG9zKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjbGlja1BvcyA9IHZpZXcucG9zQXRDb29yZHMoeyBsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFkgfSk7XG4gICAgaWYgKGNsaWNrUG9zICYmIGNsaWNrUG9zLmluc2lkZSA+IC0xICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKHZpZXcuc3RhdGUuZG9jLm5vZGVBdChjbGlja1Bvcy5pbnNpZGUpKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IEdhcEN1cnNvcigkcG9zKSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gVGhpcyBpcyBhIGhhY2sgdGhhdCwgd2hlbiBhIGNvbXBvc2l0aW9uIHN0YXJ0cyB3aGlsZSBhIGdhcCBjdXJzb3Jcbi8vIGlzIGFjdGl2ZSwgcXVpY2tseSBjcmVhdGVzIGFuIGlubGluZSBjb250ZXh0IGZvciB0aGUgY29tcG9zaXRpb24gdG9cbi8vIGhhcHBlbiBpbiwgdG8gYXZvaWQgaXQgYmVpbmcgYWJvcnRlZCBieSB0aGUgRE9NIHNlbGVjdGlvbiBiZWluZ1xuLy8gbW92ZWQgaW50byBhIHZhbGlkIHBvc2l0aW9uLlxuZnVuY3Rpb24gYmVmb3JlaW5wdXQodmlldywgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuaW5wdXRUeXBlICE9IFwiaW5zZXJ0Q29tcG9zaXRpb25UZXh0XCIgfHwgISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEdhcEN1cnNvcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyAkZnJvbSB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IGluc2VydCA9ICRmcm9tLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleCgpKS5maW5kV3JhcHBpbmcodmlldy5zdGF0ZS5zY2hlbWEubm9kZXMudGV4dCk7XG4gICAgaWYgKCFpbnNlcnQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZnJhZyA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGZvciAobGV0IGkgPSBpbnNlcnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGZyYWcgPSBGcmFnbWVudC5mcm9tKGluc2VydFtpXS5jcmVhdGVBbmRGaWxsKG51bGwsIGZyYWcpKTtcbiAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnJlcGxhY2UoJGZyb20ucG9zLCAkZnJvbS5wb3MsIG5ldyBTbGljZShmcmFnLCAwLCAwKSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZSgkZnJvbS5wb3MgKyAxKSkpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRyYXdHYXBDdXJzb3Ioc3RhdGUpIHtcbiAgICBpZiAoIShzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBHYXBDdXJzb3IpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgbm9kZS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLWdhcGN1cnNvclwiO1xuICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIFtEZWNvcmF0aW9uLndpZGdldChzdGF0ZS5zZWxlY3Rpb24uaGVhZCwgbm9kZSwgeyBrZXk6IFwiZ2FwY3Vyc29yXCIgfSldKTtcbn1cblxuZXhwb3J0IHsgR2FwQ3Vyc29yLCBnYXBDdXJzb3IgfTtcbiIsICJpbXBvcnQge1xuICBjYWxsT3JSZXR1cm4sXG4gIEV4dGVuc2lvbixcbiAgZ2V0RXh0ZW5zaW9uRmllbGQsXG4gIFBhcmVudENvbmZpZyxcbn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHsgZ2FwQ3Vyc29yIH0gZnJvbSAnQHRpcHRhcC9wbS9nYXBjdXJzb3InXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4ge1xuICAgIC8qKlxuICAgICAqIEFsbG93IGdhcCBjdXJzb3JcbiAgICAgKi9cbiAgICBhbGxvd0dhcEN1cnNvcj86XG4gICAgICB8IGJvb2xlYW5cbiAgICAgIHwgbnVsbFxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgbmFtZTogc3RyaW5nLFxuICAgICAgICBvcHRpb25zOiBPcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiBTdG9yYWdlLFxuICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnM+PlsnYWxsb3dHYXBDdXJzb3InXSxcbiAgICAgIH0pID0+IGJvb2xlYW4gfCBudWxsKSxcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgR2FwY3Vyc29yID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICdnYXBDdXJzb3InLFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgZ2FwQ3Vyc29yKCksXG4gICAgXVxuICB9LFxuXG4gIGV4dGVuZE5vZGVTY2hlbWEoZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWxsb3dHYXBDdXJzb3I6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhbGxvd0dhcEN1cnNvcicsIGNvbnRleHQpKSA/PyBudWxsLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEhhcmRCcmVha09wdGlvbnMge1xuICBrZWVwTWFya3M6IGJvb2xlYW4sXG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgaGFyZEJyZWFrOiB7XG4gICAgICAvKipcbiAgICAgICAqIEFkZCBhIGhhcmQgYnJlYWtcbiAgICAgICAqL1xuICAgICAgc2V0SGFyZEJyZWFrOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgSGFyZEJyZWFrID0gTm9kZS5jcmVhdGU8SGFyZEJyZWFrT3B0aW9ucz4oe1xuICBuYW1lOiAnaGFyZEJyZWFrJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZWVwTWFya3M6IHRydWUsXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIGlubGluZTogdHJ1ZSxcblxuICBncm91cDogJ2lubGluZScsXG5cbiAgc2VsZWN0YWJsZTogZmFsc2UsXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7IHRhZzogJ2JyJyB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ2JyJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpXVxuICB9LFxuXG4gIHJlbmRlclRleHQoKSB7XG4gICAgcmV0dXJuICdcXG4nXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEhhcmRCcmVhazogKCkgPT4gKHtcbiAgICAgICAgY29tbWFuZHMsXG4gICAgICAgIGNoYWluLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZWRpdG9yLFxuICAgICAgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuZmlyc3QoW1xuICAgICAgICAgICgpID0+IGNvbW1hbmRzLmV4aXRDb2RlKCksXG4gICAgICAgICAgKCkgPT4gY29tbWFuZHMuY29tbWFuZCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlXG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uJGZyb20ucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHsga2VlcE1hcmtzIH0gPSB0aGlzLm9wdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IHsgc3BsaXR0YWJsZU1hcmtzIH0gPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlclxuICAgICAgICAgICAgY29uc3QgbWFya3MgPSBzdG9yZWRNYXJrc1xuICAgICAgICAgICAgICB8fCAoc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpXG5cbiAgICAgICAgICAgIHJldHVybiBjaGFpbigpXG4gICAgICAgICAgICAgIC5pbnNlcnRDb250ZW50KHsgdHlwZTogdGhpcy5uYW1lIH0pXG4gICAgICAgICAgICAgIC5jb21tYW5kKCh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoICYmIG1hcmtzICYmIGtlZXBNYXJrcykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKVxuXG4gICAgICAgICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5ydW4oKVxuICAgICAgICAgIH0pLFxuICAgICAgICBdKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtRW50ZXInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRIYXJkQnJlYWsoKSxcbiAgICAgICdTaGlmdC1FbnRlcic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldEhhcmRCcmVhaygpLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgdHlwZSBMZXZlbCA9IDEgfCAyIHwgMyB8IDQgfCA1IHwgNlxuXG5leHBvcnQgaW50ZXJmYWNlIEhlYWRpbmdPcHRpb25zIHtcbiAgbGV2ZWxzOiBMZXZlbFtdLFxuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGhlYWRpbmc6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgaGVhZGluZyBub2RlXG4gICAgICAgKi9cbiAgICAgIHNldEhlYWRpbmc6IChhdHRyaWJ1dGVzOiB7IGxldmVsOiBMZXZlbCB9KSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBoZWFkaW5nIG5vZGVcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlSGVhZGluZzogKGF0dHJpYnV0ZXM6IHsgbGV2ZWw6IExldmVsIH0pID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBIZWFkaW5nID0gTm9kZS5jcmVhdGU8SGVhZGluZ09wdGlvbnM+KHtcbiAgbmFtZTogJ2hlYWRpbmcnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsczogWzEsIDIsIDMsIDQsIDUsIDZdLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBjb250ZW50OiAnaW5saW5lKicsXG5cbiAgZ3JvdXA6ICdibG9jaycsXG5cbiAgZGVmaW5pbmc6IHRydWUsXG5cbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWw6IHtcbiAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgcmVuZGVyZWQ6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGV2ZWxzXG4gICAgICAubWFwKChsZXZlbDogTGV2ZWwpID0+ICh7XG4gICAgICAgIHRhZzogYGgke2xldmVsfWAsXG4gICAgICAgIGF0dHJzOiB7IGxldmVsIH0sXG4gICAgICB9KSlcbiAgfSxcblxuICByZW5kZXJIVE1MKHsgbm9kZSwgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIGNvbnN0IGhhc0xldmVsID0gdGhpcy5vcHRpb25zLmxldmVscy5pbmNsdWRlcyhub2RlLmF0dHJzLmxldmVsKVxuICAgIGNvbnN0IGxldmVsID0gaGFzTGV2ZWxcbiAgICAgID8gbm9kZS5hdHRycy5sZXZlbFxuICAgICAgOiB0aGlzLm9wdGlvbnMubGV2ZWxzWzBdXG5cbiAgICByZXR1cm4gW2BoJHtsZXZlbH1gLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEhlYWRpbmc6IGF0dHJpYnV0ZXMgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5sZXZlbHMuaW5jbHVkZXMoYXR0cmlidXRlcy5sZXZlbCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRoaXMubmFtZSwgYXR0cmlidXRlcylcbiAgICAgIH0sXG4gICAgICB0b2dnbGVIZWFkaW5nOiBhdHRyaWJ1dGVzID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubGV2ZWxzLmluY2x1ZGVzKGF0dHJpYnV0ZXMubGV2ZWwpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTm9kZSh0aGlzLm5hbWUsICdwYXJhZ3JhcGgnLCBhdHRyaWJ1dGVzKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sZXZlbHMucmVkdWNlKChpdGVtcywgbGV2ZWwpID0+ICh7XG4gICAgICAuLi5pdGVtcyxcbiAgICAgIC4uLntcbiAgICAgICAgW2BNb2QtQWx0LSR7bGV2ZWx9YF06ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUhlYWRpbmcoeyBsZXZlbCB9KSxcbiAgICAgIH0sXG4gICAgfSksIHt9KVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sZXZlbHMubWFwKGxldmVsID0+IHtcbiAgICAgIHJldHVybiB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogbmV3IFJlZ0V4cChgXigjezEsJHtsZXZlbH19KVxcXFxzJGApLFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBsZXZlbCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcbn0pXG4iLCAidmFyIEdPT0RfTEVBRl9TSVpFID0gMjAwO1xuXG4vLyA6OiBjbGFzczxUPiBBIHJvcGUgc2VxdWVuY2UgaXMgYSBwZXJzaXN0ZW50IHNlcXVlbmNlIGRhdGEgc3RydWN0dXJlXG4vLyB0aGF0IHN1cHBvcnRzIGFwcGVuZGluZywgcHJlcGVuZGluZywgYW5kIHNsaWNpbmcgd2l0aG91dCBkb2luZyBhXG4vLyBmdWxsIGNvcHkuIEl0IGlzIHJlcHJlc2VudGVkIGFzIGEgbW9zdGx5LWJhbGFuY2VkIHRyZWUuXG52YXIgUm9wZVNlcXVlbmNlID0gZnVuY3Rpb24gUm9wZVNlcXVlbmNlICgpIHt9O1xuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCAob3RoZXIpIHtcbiAgaWYgKCFvdGhlci5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICBvdGhlciA9IFJvcGVTZXF1ZW5jZS5mcm9tKG90aGVyKTtcblxuICByZXR1cm4gKCF0aGlzLmxlbmd0aCAmJiBvdGhlcikgfHxcbiAgICAob3RoZXIubGVuZ3RoIDwgR09PRF9MRUFGX1NJWkUgJiYgdGhpcy5sZWFmQXBwZW5kKG90aGVyKSkgfHxcbiAgICAodGhpcy5sZW5ndGggPCBHT09EX0xFQUZfU0laRSAmJiBvdGhlci5sZWFmUHJlcGVuZCh0aGlzKSkgfHxcbiAgICB0aGlzLmFwcGVuZElubmVyKG90aGVyKVxufTtcblxuLy8gOjogKHVuaW9uPFtUXSwgUm9wZVNlcXVlbmNlPFQ+PikgXHUyMTkyIFJvcGVTZXF1ZW5jZTxUPlxuLy8gUHJlcGVuZCBhbiBhcnJheSBvciBvdGhlciByb3BlIHRvIHRoaXMgb25lLCByZXR1cm5pbmcgYSBuZXcgcm9wZS5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQgKG90aGVyKSB7XG4gIGlmICghb3RoZXIubGVuZ3RoKSB7IHJldHVybiB0aGlzIH1cbiAgcmV0dXJuIFJvcGVTZXF1ZW5jZS5mcm9tKG90aGVyKS5hcHBlbmQodGhpcylcbn07XG5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuYXBwZW5kSW5uZXIgPSBmdW5jdGlvbiBhcHBlbmRJbm5lciAob3RoZXIpIHtcbiAgcmV0dXJuIG5ldyBBcHBlbmQodGhpcywgb3RoZXIpXG59O1xuXG4vLyA6OiAoP251bWJlciwgP251bWJlcikgXHUyMTkyIFJvcGVTZXF1ZW5jZTxUPlxuLy8gQ3JlYXRlIGEgcm9wZSByZXBlc2VudGluZyBhIHN1Yi1zZXF1ZW5jZSBvZiB0aGlzIHJvcGUuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGZyb20sIHRvKSB7XG4gICAgaWYgKCBmcm9tID09PSB2b2lkIDAgKSBmcm9tID0gMDtcbiAgICBpZiAoIHRvID09PSB2b2lkIDAgKSB0byA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChmcm9tID49IHRvKSB7IHJldHVybiBSb3BlU2VxdWVuY2UuZW1wdHkgfVxuICByZXR1cm4gdGhpcy5zbGljZUlubmVyKE1hdGgubWF4KDAsIGZyb20pLCBNYXRoLm1pbih0aGlzLmxlbmd0aCwgdG8pKVxufTtcblxuLy8gOjogKG51bWJlcikgXHUyMTkyIFRcbi8vIFJldHJpZXZlIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBmcm9tIHRoaXMgcm9wZS5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IHRoaXMubGVuZ3RoKSB7IHJldHVybiB1bmRlZmluZWQgfVxuICByZXR1cm4gdGhpcy5nZXRJbm5lcihpKVxufTtcblxuLy8gOjogKChlbGVtZW50OiBULCBpbmRleDogbnVtYmVyKSBcdTIxOTIgP2Jvb2wsID9udW1iZXIsID9udW1iZXIpXG4vLyBDYWxsIHRoZSBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50IGJldHdlZW4gdGhlIGdpdmVuXG4vLyBpbmRpY2VzLiBUaGlzIHRlbmRzIHRvIGJlIG1vcmUgZWZmaWNpZW50IHRoYW4gbG9vcGluZyBvdmVyIHRoZVxuLy8gaW5kaWNlcyBhbmQgY2FsbGluZyBgZ2V0YCwgYmVjYXVzZSBpdCBkb2Vzbid0IGhhdmUgdG8gZGVzY2VuZCB0aGVcbi8vIHRyZWUgZm9yIGV2ZXJ5IGVsZW1lbnQuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoIChmLCBmcm9tLCB0bykge1xuICAgIGlmICggZnJvbSA9PT0gdm9pZCAwICkgZnJvbSA9IDA7XG4gICAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoZnJvbSA8PSB0bylcbiAgICB7IHRoaXMuZm9yRWFjaElubmVyKGYsIGZyb20sIHRvLCAwKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmZvckVhY2hJbnZlcnRlZElubmVyKGYsIGZyb20sIHRvLCAwKTsgfVxufTtcblxuLy8gOjogKChlbGVtZW50OiBULCBpbmRleDogbnVtYmVyKSBcdTIxOTIgVSwgP251bWJlciwgP251bWJlcikgXHUyMTkyIFtVXVxuLy8gTWFwIHRoZSBnaXZlbiBmdW5jdGlvbnMgb3ZlciB0aGUgZWxlbWVudHMgb2YgdGhlIHJvcGUsIHByb2R1Y2luZ1xuLy8gYSBmbGF0IGFycmF5LlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKGYsIGZyb20sIHRvKSB7XG4gICAgaWYgKCBmcm9tID09PSB2b2lkIDAgKSBmcm9tID0gMDtcbiAgICBpZiAoIHRvID09PSB2b2lkIDAgKSB0byA9IHRoaXMubGVuZ3RoO1xuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbHQsIGkpIHsgcmV0dXJuIHJlc3VsdC5wdXNoKGYoZWx0LCBpKSk7IH0sIGZyb20sIHRvKTtcbiAgcmV0dXJuIHJlc3VsdFxufTtcblxuLy8gOjogKD91bmlvbjxbVF0sIFJvcGVTZXF1ZW5jZTxUPj4pIFx1MjE5MiBSb3BlU2VxdWVuY2U8VD5cbi8vIENyZWF0ZSBhIHJvcGUgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBhcnJheSwgb3IgcmV0dXJuIHRoZSByb3BlXG4vLyBpdHNlbGYgaWYgYSByb3BlIHdhcyBnaXZlbi5cblJvcGVTZXF1ZW5jZS5mcm9tID0gZnVuY3Rpb24gZnJvbSAodmFsdWVzKSB7XG4gIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBSb3BlU2VxdWVuY2UpIHsgcmV0dXJuIHZhbHVlcyB9XG4gIHJldHVybiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCA/IG5ldyBMZWFmKHZhbHVlcykgOiBSb3BlU2VxdWVuY2UuZW1wdHlcbn07XG5cbnZhciBMZWFmID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUm9wZVNlcXVlbmNlKSB7XG4gIGZ1bmN0aW9uIExlYWYodmFsdWVzKSB7XG4gICAgUm9wZVNlcXVlbmNlLmNhbGwodGhpcyk7XG4gICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gIH1cblxuICBpZiAoIFJvcGVTZXF1ZW5jZSApIExlYWYuX19wcm90b19fID0gUm9wZVNlcXVlbmNlO1xuICBMZWFmLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFJvcGVTZXF1ZW5jZSAmJiBSb3BlU2VxdWVuY2UucHJvdG90eXBlICk7XG4gIExlYWYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGVhZjtcblxuICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBsZW5ndGg6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sZGVwdGg6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuICBMZWFmLnByb3RvdHlwZS5mbGF0dGVuID0gZnVuY3Rpb24gZmxhdHRlbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzXG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuc2xpY2VJbm5lciA9IGZ1bmN0aW9uIHNsaWNlSW5uZXIgKGZyb20sIHRvKSB7XG4gICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gICAgcmV0dXJuIG5ldyBMZWFmKHRoaXMudmFsdWVzLnNsaWNlKGZyb20sIHRvKSlcbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5nZXRJbm5lciA9IGZ1bmN0aW9uIGdldElubmVyIChpKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzW2ldXG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZm9yRWFjaElubmVyID0gZnVuY3Rpb24gZm9yRWFjaElubmVyIChmLCBmcm9tLCB0bywgc3RhcnQpIHtcbiAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8IHRvOyBpKyspXG4gICAgICB7IGlmIChmKHRoaXMudmFsdWVzW2ldLCBzdGFydCArIGkpID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZm9yRWFjaEludmVydGVkSW5uZXIgPSBmdW5jdGlvbiBmb3JFYWNoSW52ZXJ0ZWRJbm5lciAoZiwgZnJvbSwgdG8sIHN0YXJ0KSB7XG4gICAgZm9yICh2YXIgaSA9IGZyb20gLSAxOyBpID49IHRvOyBpLS0pXG4gICAgICB7IGlmIChmKHRoaXMudmFsdWVzW2ldLCBzdGFydCArIGkpID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUubGVhZkFwcGVuZCA9IGZ1bmN0aW9uIGxlYWZBcHBlbmQgKG90aGVyKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoICsgb3RoZXIubGVuZ3RoIDw9IEdPT0RfTEVBRl9TSVpFKVxuICAgICAgeyByZXR1cm4gbmV3IExlYWYodGhpcy52YWx1ZXMuY29uY2F0KG90aGVyLmZsYXR0ZW4oKSkpIH1cbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5sZWFmUHJlcGVuZCA9IGZ1bmN0aW9uIGxlYWZQcmVwZW5kIChvdGhlcikge1xuICAgIGlmICh0aGlzLmxlbmd0aCArIG90aGVyLmxlbmd0aCA8PSBHT09EX0xFQUZfU0laRSlcbiAgICAgIHsgcmV0dXJuIG5ldyBMZWFmKG90aGVyLmZsYXR0ZW4oKS5jb25jYXQodGhpcy52YWx1ZXMpKSB9XG4gIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmxlbmd0aC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnZhbHVlcy5sZW5ndGggfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMuZGVwdGguZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBMZWFmLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbiAgcmV0dXJuIExlYWY7XG59KFJvcGVTZXF1ZW5jZSkpO1xuXG4vLyA6OiBSb3BlU2VxdWVuY2Vcbi8vIFRoZSBlbXB0eSByb3BlIHNlcXVlbmNlLlxuUm9wZVNlcXVlbmNlLmVtcHR5ID0gbmV3IExlYWYoW10pO1xuXG52YXIgQXBwZW5kID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUm9wZVNlcXVlbmNlKSB7XG4gIGZ1bmN0aW9uIEFwcGVuZChsZWZ0LCByaWdodCkge1xuICAgIFJvcGVTZXF1ZW5jZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIHRoaXMubGVuZ3RoID0gbGVmdC5sZW5ndGggKyByaWdodC5sZW5ndGg7XG4gICAgdGhpcy5kZXB0aCA9IE1hdGgubWF4KGxlZnQuZGVwdGgsIHJpZ2h0LmRlcHRoKSArIDE7XG4gIH1cblxuICBpZiAoIFJvcGVTZXF1ZW5jZSApIEFwcGVuZC5fX3Byb3RvX18gPSBSb3BlU2VxdWVuY2U7XG4gIEFwcGVuZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSb3BlU2VxdWVuY2UgJiYgUm9wZVNlcXVlbmNlLnByb3RvdHlwZSApO1xuICBBcHBlbmQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXBwZW5kO1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uIGZsYXR0ZW4gKCkge1xuICAgIHJldHVybiB0aGlzLmxlZnQuZmxhdHRlbigpLmNvbmNhdCh0aGlzLnJpZ2h0LmZsYXR0ZW4oKSlcbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmdldElubmVyID0gZnVuY3Rpb24gZ2V0SW5uZXIgKGkpIHtcbiAgICByZXR1cm4gaSA8IHRoaXMubGVmdC5sZW5ndGggPyB0aGlzLmxlZnQuZ2V0KGkpIDogdGhpcy5yaWdodC5nZXQoaSAtIHRoaXMubGVmdC5sZW5ndGgpXG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5mb3JFYWNoSW5uZXIgPSBmdW5jdGlvbiBmb3JFYWNoSW5uZXIgKGYsIGZyb20sIHRvLCBzdGFydCkge1xuICAgIHZhciBsZWZ0TGVuID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICBpZiAoZnJvbSA8IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hJbm5lcihmLCBmcm9tLCBNYXRoLm1pbih0bywgbGVmdExlbiksIHN0YXJ0KSA9PT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHRvID4gbGVmdExlbiAmJlxuICAgICAgICB0aGlzLnJpZ2h0LmZvckVhY2hJbm5lcihmLCBNYXRoLm1heChmcm9tIC0gbGVmdExlbiwgMCksIE1hdGgubWluKHRoaXMubGVuZ3RoLCB0bykgLSBsZWZ0TGVuLCBzdGFydCArIGxlZnRMZW4pID09PSBmYWxzZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmZvckVhY2hJbnZlcnRlZElubmVyID0gZnVuY3Rpb24gZm9yRWFjaEludmVydGVkSW5uZXIgKGYsIGZyb20sIHRvLCBzdGFydCkge1xuICAgIHZhciBsZWZ0TGVuID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICBpZiAoZnJvbSA+IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoSW52ZXJ0ZWRJbm5lcihmLCBmcm9tIC0gbGVmdExlbiwgTWF0aC5tYXgodG8sIGxlZnRMZW4pIC0gbGVmdExlbiwgc3RhcnQgKyBsZWZ0TGVuKSA9PT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHRvIDwgbGVmdExlbiAmJlxuICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaEludmVydGVkSW5uZXIoZiwgTWF0aC5taW4oZnJvbSwgbGVmdExlbiksIHRvLCBzdGFydCkgPT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuc2xpY2VJbm5lciA9IGZ1bmN0aW9uIHNsaWNlSW5uZXIgKGZyb20sIHRvKSB7XG4gICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gICAgdmFyIGxlZnRMZW4gPSB0aGlzLmxlZnQubGVuZ3RoO1xuICAgIGlmICh0byA8PSBsZWZ0TGVuKSB7IHJldHVybiB0aGlzLmxlZnQuc2xpY2UoZnJvbSwgdG8pIH1cbiAgICBpZiAoZnJvbSA+PSBsZWZ0TGVuKSB7IHJldHVybiB0aGlzLnJpZ2h0LnNsaWNlKGZyb20gLSBsZWZ0TGVuLCB0byAtIGxlZnRMZW4pIH1cbiAgICByZXR1cm4gdGhpcy5sZWZ0LnNsaWNlKGZyb20sIGxlZnRMZW4pLmFwcGVuZCh0aGlzLnJpZ2h0LnNsaWNlKDAsIHRvIC0gbGVmdExlbikpXG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5sZWFmQXBwZW5kID0gZnVuY3Rpb24gbGVhZkFwcGVuZCAob3RoZXIpIHtcbiAgICB2YXIgaW5uZXIgPSB0aGlzLnJpZ2h0LmxlYWZBcHBlbmQob3RoZXIpO1xuICAgIGlmIChpbm5lcikgeyByZXR1cm4gbmV3IEFwcGVuZCh0aGlzLmxlZnQsIGlubmVyKSB9XG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5sZWFmUHJlcGVuZCA9IGZ1bmN0aW9uIGxlYWZQcmVwZW5kIChvdGhlcikge1xuICAgIHZhciBpbm5lciA9IHRoaXMubGVmdC5sZWFmUHJlcGVuZChvdGhlcik7XG4gICAgaWYgKGlubmVyKSB7IHJldHVybiBuZXcgQXBwZW5kKGlubmVyLCB0aGlzLnJpZ2h0KSB9XG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5hcHBlbmRJbm5lciA9IGZ1bmN0aW9uIGFwcGVuZElubmVyIChvdGhlcikge1xuICAgIGlmICh0aGlzLmxlZnQuZGVwdGggPj0gTWF0aC5tYXgodGhpcy5yaWdodC5kZXB0aCwgb3RoZXIuZGVwdGgpICsgMSlcbiAgICAgIHsgcmV0dXJuIG5ldyBBcHBlbmQodGhpcy5sZWZ0LCBuZXcgQXBwZW5kKHRoaXMucmlnaHQsIG90aGVyKSkgfVxuICAgIHJldHVybiBuZXcgQXBwZW5kKHRoaXMsIG90aGVyKVxuICB9O1xuXG4gIHJldHVybiBBcHBlbmQ7XG59KFJvcGVTZXF1ZW5jZSkpO1xuXG5leHBvcnQgZGVmYXVsdCBSb3BlU2VxdWVuY2U7XG4iLCAiaW1wb3J0IFJvcGVTZXF1ZW5jZSBmcm9tICdyb3BlLXNlcXVlbmNlJztcbmltcG9ydCB7IE1hcHBpbmcgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgUGx1Z2luS2V5LCBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5cbi8vIFByb3NlTWlycm9yJ3MgaGlzdG9yeSBpc24ndCBzaW1wbHkgYSB3YXkgdG8gcm9sbCBiYWNrIHRvIGEgcHJldmlvdXNcbi8vIHN0YXRlLCBiZWNhdXNlIFByb3NlTWlycm9yIHN1cHBvcnRzIGFwcGx5aW5nIGNoYW5nZXMgd2l0aG91dCBhZGRpbmdcbi8vIHRoZW0gdG8gdGhlIGhpc3RvcnkgKGZvciBleGFtcGxlIGR1cmluZyBjb2xsYWJvcmF0aW9uKS5cbi8vXG4vLyBUbyB0aGlzIGVuZCwgZWFjaCAnQnJhbmNoJyAob25lIGZvciB0aGUgdW5kbyBoaXN0b3J5IGFuZCBvbmUgZm9yXG4vLyB0aGUgcmVkbyBoaXN0b3J5KSBrZWVwcyBhbiBhcnJheSBvZiAnSXRlbXMnLCB3aGljaCBjYW4gb3B0aW9uYWxseVxuLy8gaG9sZCBhIHN0ZXAgKGFuIGFjdHVhbCB1bmRvYWJsZSBjaGFuZ2UpLCBhbmQgYWx3YXlzIGhvbGQgYSBwb3NpdGlvblxuLy8gbWFwICh3aGljaCBpcyBuZWVkZWQgdG8gbW92ZSBjaGFuZ2VzIGJlbG93IHRoZW0gdG8gYXBwbHkgdG8gdGhlXG4vLyBjdXJyZW50IGRvY3VtZW50KS5cbi8vXG4vLyBBbiBpdGVtIHRoYXQgaGFzIGJvdGggYSBzdGVwIGFuZCBhIHNlbGVjdGlvbiBib29rbWFyayBpcyB0aGUgc3RhcnRcbi8vIG9mIGFuICdldmVudCcgXHUyMDE0IGEgZ3JvdXAgb2YgY2hhbmdlcyB0aGF0IHdpbGwgYmUgdW5kb25lIG9yIHJlZG9uZSBhdFxuLy8gb25jZS4gKEl0IHN0b3JlcyBvbmx5IHRoZSBib29rbWFyaywgc2luY2UgdGhhdCB3YXkgd2UgZG9uJ3QgaGF2ZSB0b1xuLy8gcHJvdmlkZSBhIGRvY3VtZW50IHVudGlsIHRoZSBzZWxlY3Rpb24gaXMgYWN0dWFsbHkgYXBwbGllZCwgd2hpY2hcbi8vIGlzIHVzZWZ1bCB3aGVuIGNvbXByZXNzaW5nLilcbi8vIFVzZWQgdG8gc2NoZWR1bGUgaGlzdG9yeSBjb21wcmVzc2lvblxuY29uc3QgbWF4X2VtcHR5X2l0ZW1zID0gNTAwO1xuY2xhc3MgQnJhbmNoIHtcbiAgICBjb25zdHJ1Y3RvcihpdGVtcywgZXZlbnRDb3VudCkge1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgICAgIHRoaXMuZXZlbnRDb3VudCA9IGV2ZW50Q291bnQ7XG4gICAgfVxuICAgIC8vIFBvcCB0aGUgbGF0ZXN0IGV2ZW50IG9mZiB0aGUgYnJhbmNoJ3MgaGlzdG9yeSBhbmQgYXBwbHkgaXRcbiAgICAvLyB0byBhIGRvY3VtZW50IHRyYW5zZm9ybS5cbiAgICBwb3BFdmVudChzdGF0ZSwgcHJlc2VydmVJdGVtcykge1xuICAgICAgICBpZiAodGhpcy5ldmVudENvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICBmb3IgKDs7IGVuZC0tKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuaXRlbXMuZ2V0KGVuZCAtIDEpO1xuICAgICAgICAgICAgaWYgKG5leHQuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLS1lbmQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlbWFwLCBtYXBGcm9tO1xuICAgICAgICBpZiAocHJlc2VydmVJdGVtcykge1xuICAgICAgICAgICAgcmVtYXAgPSB0aGlzLnJlbWFwcGluZyhlbmQsIHRoaXMuaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgIG1hcEZyb20gPSByZW1hcC5tYXBzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHJhbnNmb3JtID0gc3RhdGUudHI7XG4gICAgICAgIGxldCBzZWxlY3Rpb24sIHJlbWFpbmluZztcbiAgICAgICAgbGV0IGFkZEFmdGVyID0gW10sIGFkZEJlZm9yZSA9IFtdO1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgIGlmICghaXRlbS5zdGVwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZW1hcCkge1xuICAgICAgICAgICAgICAgICAgICByZW1hcCA9IHRoaXMucmVtYXBwaW5nKGVuZCwgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBtYXBGcm9tID0gcmVtYXAubWFwcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcEZyb20tLTtcbiAgICAgICAgICAgICAgICBhZGRCZWZvcmUucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVtYXApIHtcbiAgICAgICAgICAgICAgICBhZGRCZWZvcmUucHVzaChuZXcgSXRlbShpdGVtLm1hcCkpO1xuICAgICAgICAgICAgICAgIGxldCBzdGVwID0gaXRlbS5zdGVwLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSksIG1hcDtcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCAmJiB0cmFuc2Zvcm0ubWF5YmVTdGVwKHN0ZXApLmRvYykge1xuICAgICAgICAgICAgICAgICAgICBtYXAgPSB0cmFuc2Zvcm0ubWFwcGluZy5tYXBzW3RyYW5zZm9ybS5tYXBwaW5nLm1hcHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGFkZEFmdGVyLnB1c2gobmV3IEl0ZW0obWFwLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYWRkQWZ0ZXIubGVuZ3RoICsgYWRkQmVmb3JlLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgICAgICAgaWYgKG1hcClcbiAgICAgICAgICAgICAgICAgICAgcmVtYXAuYXBwZW5kTWFwKG1hcCwgbWFwRnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0ubWF5YmVTdGVwKGl0ZW0uc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSByZW1hcCA/IGl0ZW0uc2VsZWN0aW9uLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSkgOiBpdGVtLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICByZW1haW5pbmcgPSBuZXcgQnJhbmNoKHRoaXMuaXRlbXMuc2xpY2UoMCwgZW5kKS5hcHBlbmQoYWRkQmVmb3JlLnJldmVyc2UoKS5jb25jYXQoYWRkQWZ0ZXIpKSwgdGhpcy5ldmVudENvdW50IC0gMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLml0ZW1zLmxlbmd0aCwgMCk7XG4gICAgICAgIHJldHVybiB7IHJlbWFpbmluZzogcmVtYWluaW5nLCB0cmFuc2Zvcm0sIHNlbGVjdGlvbjogc2VsZWN0aW9uIH07XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIG5ldyBicmFuY2ggd2l0aCB0aGUgZ2l2ZW4gdHJhbnNmb3JtIGFkZGVkLlxuICAgIGFkZFRyYW5zZm9ybSh0cmFuc2Zvcm0sIHNlbGVjdGlvbiwgaGlzdE9wdGlvbnMsIHByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgbGV0IG5ld0l0ZW1zID0gW10sIGV2ZW50Q291bnQgPSB0aGlzLmV2ZW50Q291bnQ7XG4gICAgICAgIGxldCBvbGRJdGVtcyA9IHRoaXMuaXRlbXMsIGxhc3RJdGVtID0gIXByZXNlcnZlSXRlbXMgJiYgb2xkSXRlbXMubGVuZ3RoID8gb2xkSXRlbXMuZ2V0KG9sZEl0ZW1zLmxlbmd0aCAtIDEpIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2Zvcm0uc3RlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGVwID0gdHJhbnNmb3JtLnN0ZXBzW2ldLmludmVydCh0cmFuc2Zvcm0uZG9jc1tpXSk7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IG5ldyBJdGVtKHRyYW5zZm9ybS5tYXBwaW5nLm1hcHNbaV0sIHN0ZXAsIHNlbGVjdGlvbiksIG1lcmdlZDtcbiAgICAgICAgICAgIGlmIChtZXJnZWQgPSBsYXN0SXRlbSAmJiBsYXN0SXRlbS5tZXJnZShpdGVtKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBtZXJnZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgICAgIG5ld0l0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2xkSXRlbXMgPSBvbGRJdGVtcy5zbGljZSgwLCBvbGRJdGVtcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0l0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRDb3VudCsrO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJlc2VydmVJdGVtcylcbiAgICAgICAgICAgICAgICBsYXN0SXRlbSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG92ZXJmbG93ID0gZXZlbnRDb3VudCAtIGhpc3RPcHRpb25zLmRlcHRoO1xuICAgICAgICBpZiAob3ZlcmZsb3cgPiBERVBUSF9PVkVSRkxPVykge1xuICAgICAgICAgICAgb2xkSXRlbXMgPSBjdXRPZmZFdmVudHMob2xkSXRlbXMsIG92ZXJmbG93KTtcbiAgICAgICAgICAgIGV2ZW50Q291bnQgLT0gb3ZlcmZsb3c7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCcmFuY2gob2xkSXRlbXMuYXBwZW5kKG5ld0l0ZW1zKSwgZXZlbnRDb3VudCk7XG4gICAgfVxuICAgIHJlbWFwcGluZyhmcm9tLCB0bykge1xuICAgICAgICBsZXQgbWFwcyA9IG5ldyBNYXBwaW5nO1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBtaXJyb3JQb3MgPSBpdGVtLm1pcnJvck9mZnNldCAhPSBudWxsICYmIGkgLSBpdGVtLm1pcnJvck9mZnNldCA+PSBmcm9tXG4gICAgICAgICAgICAgICAgPyBtYXBzLm1hcHMubGVuZ3RoIC0gaXRlbS5taXJyb3JPZmZzZXQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBtYXBzLmFwcGVuZE1hcChpdGVtLm1hcCwgbWlycm9yUG9zKTtcbiAgICAgICAgfSwgZnJvbSwgdG8pO1xuICAgICAgICByZXR1cm4gbWFwcztcbiAgICB9XG4gICAgYWRkTWFwcyhhcnJheSkge1xuICAgICAgICBpZiAodGhpcy5ldmVudENvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBCcmFuY2godGhpcy5pdGVtcy5hcHBlbmQoYXJyYXkubWFwKG1hcCA9PiBuZXcgSXRlbShtYXApKSksIHRoaXMuZXZlbnRDb3VudCk7XG4gICAgfVxuICAgIC8vIFdoZW4gdGhlIGNvbGxhYiBtb2R1bGUgcmVjZWl2ZXMgcmVtb3RlIGNoYW5nZXMsIHRoZSBoaXN0b3J5IGhhc1xuICAgIC8vIHRvIGtub3cgYWJvdXQgdGhvc2UsIHNvIHRoYXQgaXQgY2FuIGFkanVzdCB0aGUgc3RlcHMgdGhhdCB3ZXJlXG4gICAgLy8gcmViYXNlZCBvbiB0b3Agb2YgdGhlIHJlbW90ZSBjaGFuZ2VzLCBhbmQgaW5jbHVkZSB0aGUgcG9zaXRpb25cbiAgICAvLyBtYXBzIGZvciB0aGUgcmVtb3RlIGNoYW5nZXMgaW4gaXRzIGFycmF5IG9mIGl0ZW1zLlxuICAgIHJlYmFzZWQocmViYXNlZFRyYW5zZm9ybSwgcmViYXNlZENvdW50KSB7XG4gICAgICAgIGlmICghdGhpcy5ldmVudENvdW50KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCByZWJhc2VkSXRlbXMgPSBbXSwgc3RhcnQgPSBNYXRoLm1heCgwLCB0aGlzLml0ZW1zLmxlbmd0aCAtIHJlYmFzZWRDb3VudCk7XG4gICAgICAgIGxldCBtYXBwaW5nID0gcmViYXNlZFRyYW5zZm9ybS5tYXBwaW5nO1xuICAgICAgICBsZXQgbmV3VW50aWwgPSByZWJhc2VkVHJhbnNmb3JtLnN0ZXBzLmxlbmd0aDtcbiAgICAgICAgbGV0IGV2ZW50Q291bnQgPSB0aGlzLmV2ZW50Q291bnQ7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChpdGVtID0+IHsgaWYgKGl0ZW0uc2VsZWN0aW9uKVxuICAgICAgICAgICAgZXZlbnRDb3VudC0tOyB9LCBzdGFydCk7XG4gICAgICAgIGxldCBpUmViYXNlZCA9IHJlYmFzZWRDb3VudDtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcuZ2V0TWlycm9yKC0taVJlYmFzZWQpO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIG5ld1VudGlsID0gTWF0aC5taW4obmV3VW50aWwsIHBvcyk7XG4gICAgICAgICAgICBsZXQgbWFwID0gbWFwcGluZy5tYXBzW3Bvc107XG4gICAgICAgICAgICBpZiAoaXRlbS5zdGVwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSByZWJhc2VkVHJhbnNmb3JtLnN0ZXBzW3Bvc10uaW52ZXJ0KHJlYmFzZWRUcmFuc2Zvcm0uZG9jc1twb3NdKTtcbiAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gaXRlbS5zZWxlY3Rpb24gJiYgaXRlbS5zZWxlY3Rpb24ubWFwKG1hcHBpbmcuc2xpY2UoaVJlYmFzZWQgKyAxLCBwb3MpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBldmVudENvdW50Kys7XG4gICAgICAgICAgICAgICAgcmViYXNlZEl0ZW1zLnB1c2gobmV3IEl0ZW0obWFwLCBzdGVwLCBzZWxlY3Rpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlYmFzZWRJdGVtcy5wdXNoKG5ldyBJdGVtKG1hcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzdGFydCk7XG4gICAgICAgIGxldCBuZXdNYXBzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSByZWJhc2VkQ291bnQ7IGkgPCBuZXdVbnRpbDsgaSsrKVxuICAgICAgICAgICAgbmV3TWFwcy5wdXNoKG5ldyBJdGVtKG1hcHBpbmcubWFwc1tpXSkpO1xuICAgICAgICBsZXQgaXRlbXMgPSB0aGlzLml0ZW1zLnNsaWNlKDAsIHN0YXJ0KS5hcHBlbmQobmV3TWFwcykuYXBwZW5kKHJlYmFzZWRJdGVtcyk7XG4gICAgICAgIGxldCBicmFuY2ggPSBuZXcgQnJhbmNoKGl0ZW1zLCBldmVudENvdW50KTtcbiAgICAgICAgaWYgKGJyYW5jaC5lbXB0eUl0ZW1Db3VudCgpID4gbWF4X2VtcHR5X2l0ZW1zKVxuICAgICAgICAgICAgYnJhbmNoID0gYnJhbmNoLmNvbXByZXNzKHRoaXMuaXRlbXMubGVuZ3RoIC0gcmViYXNlZEl0ZW1zLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBicmFuY2g7XG4gICAgfVxuICAgIGVtcHR5SXRlbUNvdW50KCkge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7IGlmICghaXRlbS5zdGVwKVxuICAgICAgICAgICAgY291bnQrKzsgfSk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgLy8gQ29tcHJlc3NpbmcgYSBicmFuY2ggbWVhbnMgcmV3cml0aW5nIGl0IHRvIHB1c2ggdGhlIGFpciAobWFwLW9ubHlcbiAgICAvLyBpdGVtcykgb3V0LiBEdXJpbmcgY29sbGFib3JhdGlvbiwgdGhlc2UgbmF0dXJhbGx5IGFjY3VtdWxhdGVcbiAgICAvLyBiZWNhdXNlIGVhY2ggcmVtb3RlIGNoYW5nZSBhZGRzIG9uZS4gVGhlIGB1cHRvYCBhcmd1bWVudCBpcyB1c2VkXG4gICAgLy8gdG8gZW5zdXJlIHRoYXQgb25seSB0aGUgaXRlbXMgYmVsb3cgYSBnaXZlbiBsZXZlbCBhcmUgY29tcHJlc3NlZCxcbiAgICAvLyBiZWNhdXNlIGByZWJhc2VkYCByZWxpZXMgb24gYSBjbGVhbiwgdW50b3VjaGVkIHNldCBvZiBpdGVtcyBpblxuICAgIC8vIG9yZGVyIHRvIGFzc29jaWF0ZSBvbGQgaXRlbXMgd2l0aCByZWJhc2VkIHN0ZXBzLlxuICAgIGNvbXByZXNzKHVwdG8gPSB0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICBsZXQgcmVtYXAgPSB0aGlzLnJlbWFwcGluZygwLCB1cHRvKSwgbWFwRnJvbSA9IHJlbWFwLm1hcHMubGVuZ3RoO1xuICAgICAgICBsZXQgaXRlbXMgPSBbXSwgZXZlbnRzID0gMDtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoaSA+PSB1cHRvKSB7XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5zdGVwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSBpdGVtLnN0ZXAubWFwKHJlbWFwLnNsaWNlKG1hcEZyb20pKSwgbWFwID0gc3RlcCAmJiBzdGVwLmdldE1hcCgpO1xuICAgICAgICAgICAgICAgIG1hcEZyb20tLTtcbiAgICAgICAgICAgICAgICBpZiAobWFwKVxuICAgICAgICAgICAgICAgICAgICByZW1hcC5hcHBlbmRNYXAobWFwLCBtYXBGcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gaXRlbS5zZWxlY3Rpb24gJiYgaXRlbS5zZWxlY3Rpb24ubWFwKHJlbWFwLnNsaWNlKG1hcEZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cysrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3SXRlbSA9IG5ldyBJdGVtKG1hcC5pbnZlcnQoKSwgc3RlcCwgc2VsZWN0aW9uKSwgbWVyZ2VkLCBsYXN0ID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lcmdlZCA9IGl0ZW1zLmxlbmd0aCAmJiBpdGVtc1tsYXN0XS5tZXJnZShuZXdJdGVtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zW2xhc3RdID0gbWVyZ2VkO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKG5ld0l0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0ubWFwKSB7XG4gICAgICAgICAgICAgICAgbWFwRnJvbS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLml0ZW1zLmxlbmd0aCwgMCk7XG4gICAgICAgIHJldHVybiBuZXcgQnJhbmNoKFJvcGVTZXF1ZW5jZS5mcm9tKGl0ZW1zLnJldmVyc2UoKSksIGV2ZW50cyk7XG4gICAgfVxufVxuQnJhbmNoLmVtcHR5ID0gbmV3IEJyYW5jaChSb3BlU2VxdWVuY2UuZW1wdHksIDApO1xuZnVuY3Rpb24gY3V0T2ZmRXZlbnRzKGl0ZW1zLCBuKSB7XG4gICAgbGV0IGN1dFBvaW50O1xuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGl0ZW0uc2VsZWN0aW9uICYmIChuLS0gPT0gMCkpIHtcbiAgICAgICAgICAgIGN1dFBvaW50ID0gaTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpdGVtcy5zbGljZShjdXRQb2ludCk7XG59XG5jbGFzcyBJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgKGZvcndhcmQpIHN0ZXAgbWFwIGZvciB0aGlzIGl0ZW0uXG4gICAgbWFwLCBcbiAgICAvLyBUaGUgaW52ZXJ0ZWQgc3RlcFxuICAgIHN0ZXAsIFxuICAgIC8vIElmIHRoaXMgaXMgbm9uLW51bGwsIHRoaXMgaXRlbSBpcyB0aGUgc3RhcnQgb2YgYSBncm91cCwgYW5kXG4gICAgLy8gdGhpcyBzZWxlY3Rpb24gaXMgdGhlIHN0YXJ0aW5nIHNlbGVjdGlvbiBmb3IgdGhlIGdyb3VwICh0aGUgb25lXG4gICAgLy8gdGhhdCB3YXMgYWN0aXZlIGJlZm9yZSB0aGUgZmlyc3Qgc3RlcCB3YXMgYXBwbGllZClcbiAgICBzZWxlY3Rpb24sIFxuICAgIC8vIElmIHRoaXMgaXRlbSBpcyB0aGUgaW52ZXJzZSBvZiBhIHByZXZpb3VzIG1hcHBpbmcgb24gdGhlIHN0YWNrLFxuICAgIC8vIHRoaXMgcG9pbnRzIGF0IHRoZSBpbnZlcnNlJ3Mgb2Zmc2V0XG4gICAgbWlycm9yT2Zmc2V0KSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICB0aGlzLnN0ZXAgPSBzdGVwO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5taXJyb3JPZmZzZXQgPSBtaXJyb3JPZmZzZXQ7XG4gICAgfVxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN0ZXAgJiYgb3RoZXIuc3RlcCAmJiAhb3RoZXIuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgc3RlcCA9IG90aGVyLnN0ZXAubWVyZ2UodGhpcy5zdGVwKTtcbiAgICAgICAgICAgIGlmIChzdGVwKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSXRlbShzdGVwLmdldE1hcCgpLmludmVydCgpLCBzdGVwLCB0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBUaGUgdmFsdWUgb2YgdGhlIHN0YXRlIGZpZWxkIHRoYXQgdHJhY2tzIHVuZG8vcmVkbyBoaXN0b3J5IGZvciB0aGF0XG4vLyBzdGF0ZS4gV2lsbCBiZSBzdG9yZWQgaW4gdGhlIHBsdWdpbiBzdGF0ZSB3aGVuIHRoZSBoaXN0b3J5IHBsdWdpblxuLy8gaXMgYWN0aXZlLlxuY2xhc3MgSGlzdG9yeVN0YXRlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb25lLCB1bmRvbmUsIHByZXZSYW5nZXMsIHByZXZUaW1lLCBwcmV2Q29tcG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5kb25lID0gZG9uZTtcbiAgICAgICAgdGhpcy51bmRvbmUgPSB1bmRvbmU7XG4gICAgICAgIHRoaXMucHJldlJhbmdlcyA9IHByZXZSYW5nZXM7XG4gICAgICAgIHRoaXMucHJldlRpbWUgPSBwcmV2VGltZTtcbiAgICAgICAgdGhpcy5wcmV2Q29tcG9zaXRpb24gPSBwcmV2Q29tcG9zaXRpb247XG4gICAgfVxufVxuY29uc3QgREVQVEhfT1ZFUkZMT1cgPSAyMDtcbi8vIFJlY29yZCBhIHRyYW5zZm9ybWF0aW9uIGluIHVuZG8gaGlzdG9yeS5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNhY3Rpb24oaGlzdG9yeSwgc3RhdGUsIHRyLCBvcHRpb25zKSB7XG4gICAgbGV0IGhpc3RvcnlUciA9IHRyLmdldE1ldGEoaGlzdG9yeUtleSksIHJlYmFzZWQ7XG4gICAgaWYgKGhpc3RvcnlUcilcbiAgICAgICAgcmV0dXJuIGhpc3RvcnlUci5oaXN0b3J5U3RhdGU7XG4gICAgaWYgKHRyLmdldE1ldGEoY2xvc2VIaXN0b3J5S2V5KSlcbiAgICAgICAgaGlzdG9yeSA9IG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLCBoaXN0b3J5LnVuZG9uZSwgbnVsbCwgMCwgLTEpO1xuICAgIGxldCBhcHBlbmRlZCA9IHRyLmdldE1ldGEoXCJhcHBlbmRlZFRyYW5zYWN0aW9uXCIpO1xuICAgIGlmICh0ci5zdGVwcy5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm4gaGlzdG9yeTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXBwZW5kZWQgJiYgYXBwZW5kZWQuZ2V0TWV0YShoaXN0b3J5S2V5KSkge1xuICAgICAgICBpZiAoYXBwZW5kZWQuZ2V0TWV0YShoaXN0b3J5S2V5KS5yZWRvKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLmFkZFRyYW5zZm9ybSh0ciwgdW5kZWZpbmVkLCBvcHRpb25zLCBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkpLCBoaXN0b3J5LnVuZG9uZSwgcmFuZ2VzRm9yKHRyLm1hcHBpbmcubWFwc1t0ci5zdGVwcy5sZW5ndGggLSAxXSksIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLCBoaXN0b3J5LnVuZG9uZS5hZGRUcmFuc2Zvcm0odHIsIHVuZGVmaW5lZCwgb3B0aW9ucywgbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpKSwgbnVsbCwgaGlzdG9yeS5wcmV2VGltZSwgaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0ci5nZXRNZXRhKFwiYWRkVG9IaXN0b3J5XCIpICE9PSBmYWxzZSAmJiAhKGFwcGVuZGVkICYmIGFwcGVuZGVkLmdldE1ldGEoXCJhZGRUb0hpc3RvcnlcIikgPT09IGZhbHNlKSkge1xuICAgICAgICAvLyBHcm91cCB0cmFuc2Zvcm1zIHRoYXQgb2NjdXIgaW4gcXVpY2sgc3VjY2Vzc2lvbiBpbnRvIG9uZSBldmVudC5cbiAgICAgICAgbGV0IGNvbXBvc2l0aW9uID0gdHIuZ2V0TWV0YShcImNvbXBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgbmV3R3JvdXAgPSBoaXN0b3J5LnByZXZUaW1lID09IDAgfHxcbiAgICAgICAgICAgICghYXBwZW5kZWQgJiYgaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24gIT0gY29tcG9zaXRpb24gJiZcbiAgICAgICAgICAgICAgICAoaGlzdG9yeS5wcmV2VGltZSA8ICh0ci50aW1lIHx8IDApIC0gb3B0aW9ucy5uZXdHcm91cERlbGF5IHx8ICFpc0FkamFjZW50VG8odHIsIGhpc3RvcnkucHJldlJhbmdlcykpKTtcbiAgICAgICAgbGV0IHByZXZSYW5nZXMgPSBhcHBlbmRlZCA/IG1hcFJhbmdlcyhoaXN0b3J5LnByZXZSYW5nZXMsIHRyLm1hcHBpbmcpIDogcmFuZ2VzRm9yKHRyLm1hcHBpbmcubWFwc1t0ci5zdGVwcy5sZW5ndGggLSAxXSk7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRUcmFuc2Zvcm0odHIsIG5ld0dyb3VwID8gc3RhdGUuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCkgOiB1bmRlZmluZWQsIG9wdGlvbnMsIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSksIEJyYW5jaC5lbXB0eSwgcHJldlJhbmdlcywgdHIudGltZSwgY29tcG9zaXRpb24gPT0gbnVsbCA/IGhpc3RvcnkucHJldkNvbXBvc2l0aW9uIDogY29tcG9zaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWJhc2VkID0gdHIuZ2V0TWV0YShcInJlYmFzZWRcIikpIHtcbiAgICAgICAgLy8gVXNlZCBieSB0aGUgY29sbGFiIG1vZHVsZSB0byB0ZWxsIHRoZSBoaXN0b3J5IHRoYXQgc29tZSBvZiBpdHNcbiAgICAgICAgLy8gY29udGVudCBoYXMgYmVlbiByZWJhc2VkLlxuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUucmViYXNlZCh0ciwgcmViYXNlZCksIGhpc3RvcnkudW5kb25lLnJlYmFzZWQodHIsIHJlYmFzZWQpLCBtYXBSYW5nZXMoaGlzdG9yeS5wcmV2UmFuZ2VzLCB0ci5tYXBwaW5nKSwgaGlzdG9yeS5wcmV2VGltZSwgaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLmFkZE1hcHModHIubWFwcGluZy5tYXBzKSwgaGlzdG9yeS51bmRvbmUuYWRkTWFwcyh0ci5tYXBwaW5nLm1hcHMpLCBtYXBSYW5nZXMoaGlzdG9yeS5wcmV2UmFuZ2VzLCB0ci5tYXBwaW5nKSwgaGlzdG9yeS5wcmV2VGltZSwgaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQWRqYWNlbnRUbyh0cmFuc2Zvcm0sIHByZXZSYW5nZXMpIHtcbiAgICBpZiAoIXByZXZSYW5nZXMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXRyYW5zZm9ybS5kb2NDaGFuZ2VkKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgYWRqYWNlbnQgPSBmYWxzZTtcbiAgICB0cmFuc2Zvcm0ubWFwcGluZy5tYXBzWzBdLmZvckVhY2goKHN0YXJ0LCBlbmQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2UmFuZ2VzLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKHN0YXJ0IDw9IHByZXZSYW5nZXNbaSArIDFdICYmIGVuZCA+PSBwcmV2UmFuZ2VzW2ldKVxuICAgICAgICAgICAgICAgIGFkamFjZW50ID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWRqYWNlbnQ7XG59XG5mdW5jdGlvbiByYW5nZXNGb3IobWFwKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIG1hcC5mb3JFYWNoKChfZnJvbSwgX3RvLCBmcm9tLCB0bykgPT4gcmVzdWx0LnB1c2goZnJvbSwgdG8pKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWFwUmFuZ2VzKHJhbmdlcywgbWFwcGluZykge1xuICAgIGlmICghcmFuZ2VzKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcChyYW5nZXNbaV0sIDEpLCB0byA9IG1hcHBpbmcubWFwKHJhbmdlc1tpICsgMV0sIC0xKTtcbiAgICAgICAgaWYgKGZyb20gPD0gdG8pXG4gICAgICAgICAgICByZXN1bHQucHVzaChmcm9tLCB0byk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBBcHBseSB0aGUgbGF0ZXN0IGV2ZW50IGZyb20gb25lIGJyYW5jaCB0byB0aGUgZG9jdW1lbnQgYW5kIHNoaWZ0IHRoZSBldmVudFxuLy8gb250byB0aGUgb3RoZXIgYnJhbmNoLlxuZnVuY3Rpb24gaGlzdFRyYW5zYWN0aW9uKGhpc3RvcnksIHN0YXRlLCBkaXNwYXRjaCwgcmVkbykge1xuICAgIGxldCBwcmVzZXJ2ZUl0ZW1zID0gbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpO1xuICAgIGxldCBoaXN0T3B0aW9ucyA9IGhpc3RvcnlLZXkuZ2V0KHN0YXRlKS5zcGVjLmNvbmZpZztcbiAgICBsZXQgcG9wID0gKHJlZG8gPyBoaXN0b3J5LnVuZG9uZSA6IGhpc3RvcnkuZG9uZSkucG9wRXZlbnQoc3RhdGUsIHByZXNlcnZlSXRlbXMpO1xuICAgIGlmICghcG9wKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHNlbGVjdGlvbiA9IHBvcC5zZWxlY3Rpb24ucmVzb2x2ZShwb3AudHJhbnNmb3JtLmRvYyk7XG4gICAgbGV0IGFkZGVkID0gKHJlZG8gPyBoaXN0b3J5LmRvbmUgOiBoaXN0b3J5LnVuZG9uZSkuYWRkVHJhbnNmb3JtKHBvcC50cmFuc2Zvcm0sIHN0YXRlLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpLCBoaXN0T3B0aW9ucywgcHJlc2VydmVJdGVtcyk7XG4gICAgbGV0IG5ld0hpc3QgPSBuZXcgSGlzdG9yeVN0YXRlKHJlZG8gPyBhZGRlZCA6IHBvcC5yZW1haW5pbmcsIHJlZG8gPyBwb3AucmVtYWluaW5nIDogYWRkZWQsIG51bGwsIDAsIC0xKTtcbiAgICBkaXNwYXRjaChwb3AudHJhbnNmb3JtLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pLnNldE1ldGEoaGlzdG9yeUtleSwgeyByZWRvLCBoaXN0b3J5U3RhdGU6IG5ld0hpc3QgfSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG59XG5sZXQgY2FjaGVkUHJlc2VydmVJdGVtcyA9IGZhbHNlLCBjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyA9IG51bGw7XG4vLyBDaGVjayB3aGV0aGVyIGFueSBwbHVnaW4gaW4gdGhlIGdpdmVuIHN0YXRlIGhhcyBhXG4vLyBgaGlzdG9yeVByZXNlcnZlSXRlbXNgIHByb3BlcnR5IGluIGl0cyBzcGVjLCBpbiB3aGljaCBjYXNlIHdlIG11c3Rcbi8vIHByZXNlcnZlIHN0ZXBzIGV4YWN0bHkgYXMgdGhleSBjYW1lIGluLCBzbyB0aGF0IHRoZXkgY2FuIGJlXG4vLyByZWJhc2VkLlxuZnVuY3Rpb24gbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpIHtcbiAgICBsZXQgcGx1Z2lucyA9IHN0YXRlLnBsdWdpbnM7XG4gICAgaWYgKGNhY2hlZFByZXNlcnZlSXRlbXNQbHVnaW5zICE9IHBsdWdpbnMpIHtcbiAgICAgICAgY2FjaGVkUHJlc2VydmVJdGVtcyA9IGZhbHNlO1xuICAgICAgICBjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyA9IHBsdWdpbnM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChwbHVnaW5zW2ldLnNwZWMuaGlzdG9yeVByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjYWNoZWRQcmVzZXJ2ZUl0ZW1zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZFByZXNlcnZlSXRlbXM7XG59XG4vKipcblNldCBhIGZsYWcgb24gdGhlIGdpdmVuIHRyYW5zYWN0aW9uIHRoYXQgd2lsbCBwcmV2ZW50IGZ1cnRoZXIgc3RlcHNcbmZyb20gYmVpbmcgYXBwZW5kZWQgdG8gYW4gZXhpc3RpbmcgaGlzdG9yeSBldmVudCAoc28gdGhhdCB0aGV5XG5yZXF1aXJlIGEgc2VwYXJhdGUgdW5kbyBjb21tYW5kIHRvIHVuZG8pLlxuKi9cbmZ1bmN0aW9uIGNsb3NlSGlzdG9yeSh0cikge1xuICAgIHJldHVybiB0ci5zZXRNZXRhKGNsb3NlSGlzdG9yeUtleSwgdHJ1ZSk7XG59XG5jb25zdCBoaXN0b3J5S2V5ID0gbmV3IFBsdWdpbktleShcImhpc3RvcnlcIik7XG5jb25zdCBjbG9zZUhpc3RvcnlLZXkgPSBuZXcgUGx1Z2luS2V5KFwiY2xvc2VIaXN0b3J5XCIpO1xuLyoqXG5SZXR1cm5zIGEgcGx1Z2luIHRoYXQgZW5hYmxlcyB0aGUgdW5kbyBoaXN0b3J5IGZvciBhbiBlZGl0b3IuIFRoZVxucGx1Z2luIHdpbGwgdHJhY2sgdW5kbyBhbmQgcmVkbyBzdGFja3MsIHdoaWNoIGNhbiBiZSB1c2VkIHdpdGggdGhlXG5bYHVuZG9gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jaGlzdG9yeS51bmRvKSBhbmQgW2ByZWRvYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2hpc3RvcnkucmVkbykgY29tbWFuZHMuXG5cbllvdSBjYW4gc2V0IGFuIGBcImFkZFRvSGlzdG9yeVwiYCBbbWV0YWRhdGFcbnByb3BlcnR5XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc2V0TWV0YSkgb2YgYGZhbHNlYCBvbiBhIHRyYW5zYWN0aW9uXG50byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcm9sbGVkIGJhY2sgYnkgdW5kby5cbiovXG5mdW5jdGlvbiBoaXN0b3J5KGNvbmZpZyA9IHt9KSB7XG4gICAgY29uZmlnID0geyBkZXB0aDogY29uZmlnLmRlcHRoIHx8IDEwMCxcbiAgICAgICAgbmV3R3JvdXBEZWxheTogY29uZmlnLm5ld0dyb3VwRGVsYXkgfHwgNTAwIH07XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IGhpc3RvcnlLZXksXG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKEJyYW5jaC5lbXB0eSwgQnJhbmNoLmVtcHR5LCBudWxsLCAwLCAtMSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXBwbHkodHIsIGhpc3QsIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5VHJhbnNhY3Rpb24oaGlzdCwgc3RhdGUsIHRyLCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgICAgICBiZWZvcmVpbnB1dCh2aWV3LCBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnB1dFR5cGUgPSBlLmlucHV0VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbW1hbmQgPSBpbnB1dFR5cGUgPT0gXCJoaXN0b3J5VW5kb1wiID8gdW5kbyA6IGlucHV0VHlwZSA9PSBcImhpc3RvcnlSZWRvXCIgPyByZWRvIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21tYW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kKHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG5BIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB1bmRvZXMgdGhlIGxhc3QgY2hhbmdlLCBpZiBhbnkuXG4qL1xuY29uc3QgdW5kbyA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICAgIGlmICghaGlzdCB8fCBoaXN0LmRvbmUuZXZlbnRDb3VudCA9PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBoaXN0VHJhbnNhY3Rpb24oaGlzdCwgc3RhdGUsIGRpc3BhdGNoLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5BIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCByZWRvZXMgdGhlIGxhc3QgdW5kb25lIGNoYW5nZSwgaWYgYW55LlxuKi9cbmNvbnN0IHJlZG8gPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgICBpZiAoIWhpc3QgfHwgaGlzdC51bmRvbmUuZXZlbnRDb3VudCA9PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBoaXN0VHJhbnNhY3Rpb24oaGlzdCwgc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblRoZSBhbW91bnQgb2YgdW5kb2FibGUgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIHVuZG9EZXB0aChzdGF0ZSkge1xuICAgIGxldCBoaXN0ID0gaGlzdG9yeUtleS5nZXRTdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIGhpc3QgPyBoaXN0LmRvbmUuZXZlbnRDb3VudCA6IDA7XG59XG4vKipcblRoZSBhbW91bnQgb2YgcmVkb2FibGUgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIGVkaXRvciBzdGF0ZS5cbiovXG5mdW5jdGlvbiByZWRvRGVwdGgoc3RhdGUpIHtcbiAgICBsZXQgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiBoaXN0ID8gaGlzdC51bmRvbmUuZXZlbnRDb3VudCA6IDA7XG59XG5cbmV4cG9ydCB7IGNsb3NlSGlzdG9yeSwgaGlzdG9yeSwgcmVkbywgcmVkb0RlcHRoLCB1bmRvLCB1bmRvRGVwdGggfTtcbiIsICJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBoaXN0b3J5LCByZWRvLCB1bmRvIH0gZnJvbSAnQHRpcHRhcC9wbS9oaXN0b3J5J1xuXG5leHBvcnQgaW50ZXJmYWNlIEhpc3RvcnlPcHRpb25zIHtcbiAgZGVwdGg6IG51bWJlcixcbiAgbmV3R3JvdXBEZWxheTogbnVtYmVyLFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgaGlzdG9yeToge1xuICAgICAgLyoqXG4gICAgICAgKiBVbmRvIHJlY2VudCBjaGFuZ2VzXG4gICAgICAgKi9cbiAgICAgIHVuZG86ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFJlYXBwbHkgcmV2ZXJ0ZWQgY2hhbmdlc1xuICAgICAgICovXG4gICAgICByZWRvOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgSGlzdG9yeSA9IEV4dGVuc2lvbi5jcmVhdGU8SGlzdG9yeU9wdGlvbnM+KHtcbiAgbmFtZTogJ2hpc3RvcnknLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlcHRoOiAxMDAsXG4gICAgICBuZXdHcm91cERlbGF5OiA1MDAsXG4gICAgfVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB1bmRvOiAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICByZXR1cm4gdW5kbyhzdGF0ZSwgZGlzcGF0Y2gpXG4gICAgICB9LFxuICAgICAgcmVkbzogKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHJlZG8oc3RhdGUsIGRpc3BhdGNoKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBoaXN0b3J5KHRoaXMub3B0aW9ucyksXG4gICAgXVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLXonOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy51bmRvKCksXG4gICAgICAnTW9kLVonOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy51bmRvKCksXG4gICAgICAnTW9kLXknOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXG4gICAgICAnTW9kLVknOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXG4gICAgICAnU2hpZnQtTW9kLXonOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXG4gICAgICAnU2hpZnQtTW9kLVonOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXG5cbiAgICAgIC8vIFJ1c3NpYW4ga2V5Ym9hcmQgbGF5b3V0c1xuICAgICAgJ01vZC3Rjyc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnVuZG8oKSxcbiAgICAgICdTaGlmdC1Nb2Qt0Y8nOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXG4gICAgfVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUsIG5vZGVJbnB1dFJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uLCBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuZXhwb3J0IGludGVyZmFjZSBIb3Jpem9udGFsUnVsZU9wdGlvbnMge1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgaG9yaXpvbnRhbFJ1bGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogQWRkIGEgaG9yaXpvbnRhbCBydWxlXG4gICAgICAgKi9cbiAgICAgIHNldEhvcml6b250YWxSdWxlOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBIb3Jpem9udGFsUnVsZSA9IE5vZGUuY3JlYXRlPEhvcml6b250YWxSdWxlT3B0aW9ucz4oe1xuICBuYW1lOiAnaG9yaXpvbnRhbFJ1bGUnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgZ3JvdXA6ICdibG9jaycsXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbeyB0YWc6ICdocicgfV1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ2hyJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRIb3Jpem9udGFsUnVsZTpcbiAgICAgICAgKCkgPT4gKHsgY2hhaW4sIHN0YXRlIH0pID0+IHtcbiAgICAgICAgICBjb25zdCB7ICR0bzogJG9yaWdpblRvIH0gPSBzdGF0ZS5zZWxlY3Rpb25cblxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRDaGFpbiA9IGNoYWluKClcblxuICAgICAgICAgIGlmICgkb3JpZ2luVG8ucGFyZW50T2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICBjdXJyZW50Q2hhaW4uaW5zZXJ0Q29udGVudEF0KE1hdGgubWF4KCRvcmlnaW5Uby5wb3MgLSAyLCAwKSwgeyB0eXBlOiB0aGlzLm5hbWUgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudENoYWluLmluc2VydENvbnRlbnQoeyB0eXBlOiB0aGlzLm5hbWUgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY3VycmVudENoYWluXG4gICAgICAgICAgICAgIC8vIHNldCBjdXJzb3IgYWZ0ZXIgaG9yaXpvbnRhbCBydWxlXG4gICAgICAgICAgICAgIC5jb21tYW5kKCh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB7ICR0byB9ID0gdHIuc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICBjb25zdCBwb3NBZnRlciA9ICR0by5lbmQoKVxuXG4gICAgICAgICAgICAgICAgICBpZiAoJHRvLm5vZGVBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJHRvLm5vZGVBZnRlci5pc1RleHRibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsICR0by5wb3MgKyAxKSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkdG8ubm9kZUFmdGVyLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkdG8ucG9zKSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkdG8ucG9zKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIG5vZGUgYWZ0ZXIgaG9yaXpvbnRhbCBydWxlIGlmIGl04oCZcyB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gJHRvLnBhcmVudC50eXBlLmNvbnRlbnRNYXRjaC5kZWZhdWx0VHlwZT8uY3JlYXRlKClcblxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRyLmluc2VydChwb3NBZnRlciwgbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBwb3NBZnRlciArIDEpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHRyLnNjcm9sbEludG9WaWV3KClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAucnVuKClcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5vZGVJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiAvXig/Oi0tLXzigJQtfF9fX1xcc3xcXCpcXCpcXCpcXHMpJC8sXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHtcbiAgTWFyayxcbiAgbWFya0lucHV0UnVsZSxcbiAgbWFya1Bhc3RlUnVsZSxcbiAgbWVyZ2VBdHRyaWJ1dGVzLFxufSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgSXRhbGljT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgaXRhbGljOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBhbiBpdGFsaWMgbWFya1xuICAgICAgICovXG4gICAgICBzZXRJdGFsaWM6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhbiBpdGFsaWMgbWFya1xuICAgICAgICovXG4gICAgICB0b2dnbGVJdGFsaWM6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGFuIGl0YWxpYyBtYXJrXG4gICAgICAgKi9cbiAgICAgIHVuc2V0SXRhbGljOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc3RhcklucHV0UmVnZXggPSAvKD86XnxcXHMpKCg/OlxcKikoKD86W14qXSspKSg/OlxcKikpJC9cbmV4cG9ydCBjb25zdCBzdGFyUGFzdGVSZWdleCA9IC8oPzpefFxccykoKD86XFwqKSgoPzpbXipdKykpKD86XFwqKSkvZ1xuZXhwb3J0IGNvbnN0IHVuZGVyc2NvcmVJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKSgoPzpfKSgoPzpbXl9dKykpKD86XykpJC9cbmV4cG9ydCBjb25zdCB1bmRlcnNjb3JlUGFzdGVSZWdleCA9IC8oPzpefFxccykoKD86XykoKD86W15fXSspKSg/Ol8pKS9nXG5cbmV4cG9ydCBjb25zdCBJdGFsaWMgPSBNYXJrLmNyZWF0ZTxJdGFsaWNPcHRpb25zPih7XG4gIG5hbWU6ICdpdGFsaWMnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ2VtJyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRhZzogJ2knLFxuICAgICAgICBnZXRBdHRyczogbm9kZSA9PiAobm9kZSBhcyBIVE1MRWxlbWVudCkuc3R5bGUuZm9udFN0eWxlICE9PSAnbm9ybWFsJyAmJiBudWxsLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6ICdmb250LXN0eWxlPWl0YWxpYycsXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ2VtJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRJdGFsaWM6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZUl0YWxpYzogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdW5zZXRJdGFsaWM6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC1pJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlSXRhbGljKCksXG4gICAgICAnTW9kLUknOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVJdGFsaWMoKSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IHN0YXJJbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiB1bmRlcnNjb3JlSW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgXVxuICB9LFxuXG4gIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBzdGFyUGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogdW5kZXJzY29yZVBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIExpc3RJdGVtT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBidWxsZXRMaXN0VHlwZU5hbWU6IHN0cmluZ1xuICBvcmRlcmVkTGlzdFR5cGVOYW1lOiBzdHJpbmdcbn1cblxuZXhwb3J0IGNvbnN0IExpc3RJdGVtID0gTm9kZS5jcmVhdGU8TGlzdEl0ZW1PcHRpb25zPih7XG4gIG5hbWU6ICdsaXN0SXRlbScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgYnVsbGV0TGlzdFR5cGVOYW1lOiAnYnVsbGV0TGlzdCcsXG4gICAgICBvcmRlcmVkTGlzdFR5cGVOYW1lOiAnb3JkZXJlZExpc3QnLFxuICAgIH1cbiAgfSxcblxuICBjb250ZW50OiAncGFyYWdyYXBoIGJsb2NrKicsXG5cbiAgZGVmaW5pbmc6IHRydWUsXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ2xpJyxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnbGknLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEVudGVyOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zcGxpdExpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgICBUYWI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNpbmtMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgICAgJ1NoaWZ0LVRhYic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmxpZnRMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIExpc3RJdGVtT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBidWxsZXRMaXN0VHlwZU5hbWU6IHN0cmluZ1xuICBvcmRlcmVkTGlzdFR5cGVOYW1lOiBzdHJpbmdcbn1cblxuZXhwb3J0IGNvbnN0IExpc3RJdGVtID0gTm9kZS5jcmVhdGU8TGlzdEl0ZW1PcHRpb25zPih7XG4gIG5hbWU6ICdsaXN0SXRlbScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgYnVsbGV0TGlzdFR5cGVOYW1lOiAnYnVsbGV0TGlzdCcsXG4gICAgICBvcmRlcmVkTGlzdFR5cGVOYW1lOiAnb3JkZXJlZExpc3QnLFxuICAgIH1cbiAgfSxcblxuICBjb250ZW50OiAncGFyYWdyYXBoIGJsb2NrKicsXG5cbiAgZGVmaW5pbmc6IHRydWUsXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ2xpJyxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnbGknLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEVudGVyOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zcGxpdExpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgICBUYWI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNpbmtMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgICAgJ1NoaWZ0LVRhYic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmxpZnRMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHtcbiAgZ2V0TWFya0F0dHJpYnV0ZXMsXG4gIE1hcmssXG4gIG1lcmdlQXR0cmlidXRlcyxcbn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFRleHRTdHlsZU9wdGlvbnMge1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHRleHRTdHlsZToge1xuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgc3BhbnMgd2l0aG91dCBpbmxpbmUgc3R5bGUgYXR0cmlidXRlcy5cbiAgICAgICAqL1xuICAgICAgcmVtb3ZlRW1wdHlUZXh0U3R5bGU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBUZXh0U3R5bGUgPSBNYXJrLmNyZWF0ZTxUZXh0U3R5bGVPcHRpb25zPih7XG4gIG5hbWU6ICd0ZXh0U3R5bGUnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ3NwYW4nLFxuICAgICAgICBnZXRBdHRyczogZWxlbWVudCA9PiB7XG4gICAgICAgICAgY29uc3QgaGFzU3R5bGVzID0gKGVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLmhhc0F0dHJpYnV0ZSgnc3R5bGUnKVxuXG4gICAgICAgICAgaWYgKCFoYXNTdHlsZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7fVxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydzcGFuJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZW1vdmVFbXB0eVRleHRTdHlsZTogKCkgPT4gKHsgc3RhdGUsIGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0aGlzLnR5cGUpXG4gICAgICAgIGNvbnN0IGhhc1N0eWxlcyA9IE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpLnNvbWUoKFssIHZhbHVlXSkgPT4gISF2YWx1ZSlcblxuICAgICAgICBpZiAoaGFzU3R5bGVzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCB3cmFwcGluZ0lucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuaW1wb3J0IExpc3RJdGVtIGZyb20gJy4uLy4uL2V4dGVuc2lvbi1saXN0LWl0ZW0vc3JjL2luZGV4LmpzJ1xuaW1wb3J0IFRleHRTdHlsZSBmcm9tICcuLi8uLi9leHRlbnNpb24tdGV4dC1zdHlsZS9zcmMvaW5kZXguanMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgT3JkZXJlZExpc3RPcHRpb25zIHtcbiAgaXRlbVR5cGVOYW1lOiBzdHJpbmcsXG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBrZWVwTWFya3M6IGJvb2xlYW4sXG4gIGtlZXBBdHRyaWJ1dGVzOiBib29sZWFuLFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgb3JkZXJlZExpc3Q6IHtcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGFuIG9yZGVyZWQgbGlzdFxuICAgICAgICovXG4gICAgICB0b2dnbGVPcmRlcmVkTGlzdDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGlucHV0UmVnZXggPSAvXihcXGQrKVxcLlxccyQvXG5cbmV4cG9ydCBjb25zdCBPcmRlcmVkTGlzdCA9IE5vZGUuY3JlYXRlPE9yZGVyZWRMaXN0T3B0aW9ucz4oe1xuICBuYW1lOiAnb3JkZXJlZExpc3QnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1UeXBlTmFtZTogJ2xpc3RJdGVtJyxcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgIGtlZXBNYXJrczogZmFsc2UsXG4gICAgICBrZWVwQXR0cmlidXRlczogZmFsc2UsXG4gICAgfVxuICB9LFxuXG4gIGdyb3VwOiAnYmxvY2sgbGlzdCcsXG5cbiAgY29udGVudCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZX0rYFxuICB9LFxuXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiB7XG4gICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgIHBhcnNlSFRNTDogZWxlbWVudCA9PiB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdzdGFydCcpXG4gICAgICAgICAgICA/IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdGFydCcpIHx8ICcnLCAxMClcbiAgICAgICAgICAgIDogMVxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ29sJyxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgY29uc3QgeyBzdGFydCwgLi4uYXR0cmlidXRlc1dpdGhvdXRTdGFydCB9ID0gSFRNTEF0dHJpYnV0ZXNcblxuICAgIHJldHVybiBzdGFydCA9PT0gMVxuICAgICAgPyBbJ29sJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgYXR0cmlidXRlc1dpdGhvdXRTdGFydCksIDBdXG4gICAgICA6IFsnb2wnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvZ2dsZU9yZGVyZWRMaXN0OiAoKSA9PiAoeyBjb21tYW5kcywgY2hhaW4gfSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgcmV0dXJuIGNoYWluKCkudG9nZ2xlTGlzdCh0aGlzLm5hbWUsIHRoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWUsIHRoaXMub3B0aW9ucy5rZWVwTWFya3MpLnVwZGF0ZUF0dHJpYnV0ZXMoTGlzdEl0ZW0ubmFtZSwgdGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGUubmFtZSkpLnJ1bigpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtU2hpZnQtNyc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZU9yZGVyZWRMaXN0KCksXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgbGV0IGlucHV0UnVsZSA9IHdyYXBwaW5nSW5wdXRSdWxlKHtcbiAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICBnZXRBdHRyaWJ1dGVzOiBtYXRjaCA9PiAoeyBzdGFydDogK21hdGNoWzFdIH0pLFxuICAgICAgam9pblByZWRpY2F0ZTogKG1hdGNoLCBub2RlKSA9PiBub2RlLmNoaWxkQ291bnQgKyBub2RlLmF0dHJzLnN0YXJ0ID09PSArbWF0Y2hbMV0sXG4gICAgfSlcblxuICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcE1hcmtzIHx8IHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgaW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGtlZXBNYXJrczogdGhpcy5vcHRpb25zLmtlZXBNYXJrcyxcbiAgICAgICAga2VlcEF0dHJpYnV0ZXM6IHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcyxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4gKHsgc3RhcnQ6ICttYXRjaFsxXSwgLi4udGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGUubmFtZSkgfSksXG4gICAgICAgIGpvaW5QcmVkaWNhdGU6IChtYXRjaCwgbm9kZSkgPT4gbm9kZS5jaGlsZENvdW50ICsgbm9kZS5hdHRycy5zdGFydCA9PT0gK21hdGNoWzFdLFxuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIGlucHV0UnVsZSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBQYXJhZ3JhcGhPcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBwYXJhZ3JhcGg6IHtcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGEgcGFyYWdyYXBoXG4gICAgICAgKi9cbiAgICAgIHNldFBhcmFncmFwaDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFBhcmFncmFwaCA9IE5vZGUuY3JlYXRlPFBhcmFncmFwaE9wdGlvbnM+KHtcbiAgbmFtZTogJ3BhcmFncmFwaCcsXG5cbiAgcHJpb3JpdHk6IDEwMDAsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBncm91cDogJ2Jsb2NrJyxcblxuICBjb250ZW50OiAnaW5saW5lKicsXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7IHRhZzogJ3AnIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsncCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0UGFyYWdyYXBoOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLUFsdC0wJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0UGFyYWdyYXBoKCksXG4gICAgfVxuICB9LFxufSlcbiIsICJpbXBvcnQge1xuICBpc01hY09TLFxuICBNYXJrLFxuICBtYXJrSW5wdXRSdWxlLFxuICBtYXJrUGFzdGVSdWxlLFxuICBtZXJnZUF0dHJpYnV0ZXMsXG59IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBTdHJpa2VPcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzdHJpa2U6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgc3RyaWtlIG1hcmtcbiAgICAgICAqL1xuICAgICAgc2V0U3RyaWtlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBzdHJpa2UgbWFya1xuICAgICAgICovXG4gICAgICB0b2dnbGVTdHJpa2U6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGEgc3RyaWtlIG1hcmtcbiAgICAgICAqL1xuICAgICAgdW5zZXRTdHJpa2U6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKSgoPzp+fikoKD86W15+XSspKSg/On5+KSkkL1xuZXhwb3J0IGNvbnN0IHBhc3RlUmVnZXggPSAvKD86XnxcXHMpKCg/On5+KSgoPzpbXn5dKykpKD86fn4pKS9nXG5cbmV4cG9ydCBjb25zdCBTdHJpa2UgPSBNYXJrLmNyZWF0ZTxTdHJpa2VPcHRpb25zPih7XG4gIG5hbWU6ICdzdHJpa2UnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ3MnLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnZGVsJyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRhZzogJ3N0cmlrZScsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogJ3RleHQtZGVjb3JhdGlvbicsXG4gICAgICAgIGNvbnN1bWluZzogZmFsc2UsXG4gICAgICAgIGdldEF0dHJzOiBzdHlsZSA9PiAoKHN0eWxlIGFzIHN0cmluZykuaW5jbHVkZXMoJ2xpbmUtdGhyb3VnaCcpID8ge30gOiBmYWxzZSksXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ3MnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldFN0cmlrZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdG9nZ2xlU3RyaWtlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgICB1bnNldFN0cmlrZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIGNvbnN0IHNob3J0Y3V0czogUmVjb3JkPHN0cmluZywgKCkgPT4gYm9vbGVhbj4gPSB7fVxuXG4gICAgaWYgKGlzTWFjT1MoKSkge1xuICAgICAgc2hvcnRjdXRzWydNb2QtU2hpZnQtcyddID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlU3RyaWtlKClcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvcnRjdXRzWydDdHJsLVNoaWZ0LXMnXSA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVN0cmlrZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHNob3J0Y3V0c1xuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG5cbiAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6IHBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGNvbnN0IFRleHQgPSBOb2RlLmNyZWF0ZSh7XG4gIG5hbWU6ICd0ZXh0JyxcbiAgZ3JvdXA6ICdpbmxpbmUnLFxufSlcbiIsICJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBCbG9ja3F1b3RlLCBCbG9ja3F1b3RlT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWJsb2NrcXVvdGUnXG5pbXBvcnQgeyBCb2xkLCBCb2xkT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWJvbGQnXG5pbXBvcnQgeyBCdWxsZXRMaXN0LCBCdWxsZXRMaXN0T3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWJ1bGxldC1saXN0J1xuaW1wb3J0IHsgQ29kZSwgQ29kZU9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1jb2RlJ1xuaW1wb3J0IHsgQ29kZUJsb2NrLCBDb2RlQmxvY2tPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tY29kZS1ibG9jaydcbmltcG9ydCB7IERvY3VtZW50IH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tZG9jdW1lbnQnXG5pbXBvcnQgeyBEcm9wY3Vyc29yLCBEcm9wY3Vyc29yT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWRyb3BjdXJzb3InXG5pbXBvcnQgeyBHYXBjdXJzb3IgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1nYXBjdXJzb3InXG5pbXBvcnQgeyBIYXJkQnJlYWssIEhhcmRCcmVha09wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1oYXJkLWJyZWFrJ1xuaW1wb3J0IHsgSGVhZGluZywgSGVhZGluZ09wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1oZWFkaW5nJ1xuaW1wb3J0IHsgSGlzdG9yeSwgSGlzdG9yeU9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1oaXN0b3J5J1xuaW1wb3J0IHsgSG9yaXpvbnRhbFJ1bGUsIEhvcml6b250YWxSdWxlT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWhvcml6b250YWwtcnVsZSdcbmltcG9ydCB7IEl0YWxpYywgSXRhbGljT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWl0YWxpYydcbmltcG9ydCB7IExpc3RJdGVtLCBMaXN0SXRlbU9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1saXN0LWl0ZW0nXG5pbXBvcnQgeyBPcmRlcmVkTGlzdCwgT3JkZXJlZExpc3RPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tb3JkZXJlZC1saXN0J1xuaW1wb3J0IHsgUGFyYWdyYXBoLCBQYXJhZ3JhcGhPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoJ1xuaW1wb3J0IHsgU3RyaWtlLCBTdHJpa2VPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlJ1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLXRleHQnXG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhcnRlcktpdE9wdGlvbnMge1xuICBibG9ja3F1b3RlOiBQYXJ0aWFsPEJsb2NrcXVvdGVPcHRpb25zPiB8IGZhbHNlLFxuICBib2xkOiBQYXJ0aWFsPEJvbGRPcHRpb25zPiB8IGZhbHNlLFxuICBidWxsZXRMaXN0OiBQYXJ0aWFsPEJ1bGxldExpc3RPcHRpb25zPiB8IGZhbHNlLFxuICBjb2RlOiBQYXJ0aWFsPENvZGVPcHRpb25zPiB8IGZhbHNlLFxuICBjb2RlQmxvY2s6IFBhcnRpYWw8Q29kZUJsb2NrT3B0aW9ucz4gfCBmYWxzZSxcbiAgZG9jdW1lbnQ6IGZhbHNlLFxuICBkcm9wY3Vyc29yOiBQYXJ0aWFsPERyb3BjdXJzb3JPcHRpb25zPiB8IGZhbHNlLFxuICBnYXBjdXJzb3I6IGZhbHNlLFxuICBoYXJkQnJlYWs6IFBhcnRpYWw8SGFyZEJyZWFrT3B0aW9ucz4gfCBmYWxzZSxcbiAgaGVhZGluZzogUGFydGlhbDxIZWFkaW5nT3B0aW9ucz4gfCBmYWxzZSxcbiAgaGlzdG9yeTogUGFydGlhbDxIaXN0b3J5T3B0aW9ucz4gfCBmYWxzZSxcbiAgaG9yaXpvbnRhbFJ1bGU6IFBhcnRpYWw8SG9yaXpvbnRhbFJ1bGVPcHRpb25zPiB8IGZhbHNlLFxuICBpdGFsaWM6IFBhcnRpYWw8SXRhbGljT3B0aW9ucz4gfCBmYWxzZSxcbiAgbGlzdEl0ZW06IFBhcnRpYWw8TGlzdEl0ZW1PcHRpb25zPiB8IGZhbHNlLFxuICBvcmRlcmVkTGlzdDogUGFydGlhbDxPcmRlcmVkTGlzdE9wdGlvbnM+IHwgZmFsc2UsXG4gIHBhcmFncmFwaDogUGFydGlhbDxQYXJhZ3JhcGhPcHRpb25zPiB8IGZhbHNlLFxuICBzdHJpa2U6IFBhcnRpYWw8U3RyaWtlT3B0aW9ucz4gfCBmYWxzZSxcbiAgdGV4dDogZmFsc2UsXG59XG5cbmV4cG9ydCBjb25zdCBTdGFydGVyS2l0ID0gRXh0ZW5zaW9uLmNyZWF0ZTxTdGFydGVyS2l0T3B0aW9ucz4oe1xuICBuYW1lOiAnc3RhcnRlcktpdCcsXG5cbiAgYWRkRXh0ZW5zaW9ucygpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gW11cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYmxvY2txdW90ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChCbG9ja3F1b3RlLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LmJsb2NrcXVvdGUpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYm9sZCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChCb2xkLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LmJvbGQpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYnVsbGV0TGlzdCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChCdWxsZXRMaXN0LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LmJ1bGxldExpc3QpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29kZSAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChDb2RlLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LmNvZGUpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29kZUJsb2NrICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKENvZGVCbG9jay5jb25maWd1cmUodGhpcy5vcHRpb25zPy5jb2RlQmxvY2spKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZG9jdW1lbnQgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goRG9jdW1lbnQuY29uZmlndXJlKHRoaXMub3B0aW9ucz8uZG9jdW1lbnQpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZHJvcGN1cnNvciAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChEcm9wY3Vyc29yLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LmRyb3BjdXJzb3IpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZ2FwY3Vyc29yICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEdhcGN1cnNvci5jb25maWd1cmUodGhpcy5vcHRpb25zPy5nYXBjdXJzb3IpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGFyZEJyZWFrICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhhcmRCcmVhay5jb25maWd1cmUodGhpcy5vcHRpb25zPy5oYXJkQnJlYWspKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGVhZGluZyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChIZWFkaW5nLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LmhlYWRpbmcpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGlzdG9yeSAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChIaXN0b3J5LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/Lmhpc3RvcnkpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbFJ1bGUgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goSG9yaXpvbnRhbFJ1bGUuY29uZmlndXJlKHRoaXMub3B0aW9ucz8uaG9yaXpvbnRhbFJ1bGUpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaXRhbGljICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEl0YWxpYy5jb25maWd1cmUodGhpcy5vcHRpb25zPy5pdGFsaWMpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMubGlzdEl0ZW0gIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goTGlzdEl0ZW0uY29uZmlndXJlKHRoaXMub3B0aW9ucz8ubGlzdEl0ZW0pKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMub3JkZXJlZExpc3QgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goT3JkZXJlZExpc3QuY29uZmlndXJlKHRoaXMub3B0aW9ucz8ub3JkZXJlZExpc3QpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMucGFyYWdyYXBoICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKFBhcmFncmFwaC5jb25maWd1cmUodGhpcy5vcHRpb25zPy5wYXJhZ3JhcGgpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc3RyaWtlICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKFN0cmlrZS5jb25maWd1cmUodGhpcy5vcHRpb25zPy5zdHJpa2UpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudGV4dCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChUZXh0LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LnRleHQpKVxuICAgIH1cblxuICAgIHJldHVybiBleHRlbnNpb25zXG4gIH0sXG59KVxuIiwgImV4cG9ydCB2YXIgdG9wID0gJ3RvcCc7XG5leHBvcnQgdmFyIGJvdHRvbSA9ICdib3R0b20nO1xuZXhwb3J0IHZhciByaWdodCA9ICdyaWdodCc7XG5leHBvcnQgdmFyIGxlZnQgPSAnbGVmdCc7XG5leHBvcnQgdmFyIGF1dG8gPSAnYXV0byc7XG5leHBvcnQgdmFyIGJhc2VQbGFjZW1lbnRzID0gW3RvcCwgYm90dG9tLCByaWdodCwgbGVmdF07XG5leHBvcnQgdmFyIHN0YXJ0ID0gJ3N0YXJ0JztcbmV4cG9ydCB2YXIgZW5kID0gJ2VuZCc7XG5leHBvcnQgdmFyIGNsaXBwaW5nUGFyZW50cyA9ICdjbGlwcGluZ1BhcmVudHMnO1xuZXhwb3J0IHZhciB2aWV3cG9ydCA9ICd2aWV3cG9ydCc7XG5leHBvcnQgdmFyIHBvcHBlciA9ICdwb3BwZXInO1xuZXhwb3J0IHZhciByZWZlcmVuY2UgPSAncmVmZXJlbmNlJztcbmV4cG9ydCB2YXIgdmFyaWF0aW9uUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9iYXNlUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pO1xuZXhwb3J0IHZhciBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL1tdLmNvbmNhdChiYXNlUGxhY2VtZW50cywgW2F1dG9dKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQsIHBsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7IC8vIG1vZGlmaWVycyB0aGF0IG5lZWQgdG8gcmVhZCB0aGUgRE9NXG5cbmV4cG9ydCB2YXIgYmVmb3JlUmVhZCA9ICdiZWZvcmVSZWFkJztcbmV4cG9ydCB2YXIgcmVhZCA9ICdyZWFkJztcbmV4cG9ydCB2YXIgYWZ0ZXJSZWFkID0gJ2FmdGVyUmVhZCc7IC8vIHB1cmUtbG9naWMgbW9kaWZpZXJzXG5cbmV4cG9ydCB2YXIgYmVmb3JlTWFpbiA9ICdiZWZvcmVNYWluJztcbmV4cG9ydCB2YXIgbWFpbiA9ICdtYWluJztcbmV4cG9ydCB2YXIgYWZ0ZXJNYWluID0gJ2FmdGVyTWFpbic7IC8vIG1vZGlmaWVyIHdpdGggdGhlIHB1cnBvc2UgdG8gd3JpdGUgdG8gdGhlIERPTSAob3Igd3JpdGUgaW50byBhIGZyYW1ld29yayBzdGF0ZSlcblxuZXhwb3J0IHZhciBiZWZvcmVXcml0ZSA9ICdiZWZvcmVXcml0ZSc7XG5leHBvcnQgdmFyIHdyaXRlID0gJ3dyaXRlJztcbmV4cG9ydCB2YXIgYWZ0ZXJXcml0ZSA9ICdhZnRlcldyaXRlJztcbmV4cG9ydCB2YXIgbW9kaWZpZXJQaGFzZXMgPSBbYmVmb3JlUmVhZCwgcmVhZCwgYWZ0ZXJSZWFkLCBiZWZvcmVNYWluLCBtYWluLCBhZnRlck1haW4sIGJlZm9yZVdyaXRlLCB3cml0ZSwgYWZ0ZXJXcml0ZV07IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVOYW1lKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQgPyAoZWxlbWVudC5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKSA6IG51bGw7XG59IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgaWYgKG5vZGUudG9TdHJpbmcoKSAhPT0gJ1tvYmplY3QgV2luZG93XScpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93IDogd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59IiwgImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xuICAvLyBJRSAxMSBoYXMgbm8gU2hhZG93Um9vdFxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuU2hhZG93Um9vdDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuXG5leHBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9OyIsICJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiOyAvLyBUaGlzIG1vZGlmaWVyIHRha2VzIHRoZSBzdHlsZXMgcHJlcGFyZWQgYnkgdGhlIGBjb21wdXRlU3R5bGVzYCBtb2RpZmllclxuLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xuXG5mdW5jdGlvbiBhcHBseVN0eWxlcyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUuc3R5bGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG5cblxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuICB2YXIgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgbGVmdDogJzAnLFxuICAgICAgdG9wOiAnMCcsXG4gICAgICBtYXJnaW46ICcwJ1xuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSxcbiAgICByZWZlcmVuY2U6IHt9XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgICAgdmFyIHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHN0YXRlLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHN0YXRlLnN0eWxlc1tuYW1lXSA6IGluaXRpYWxTdHlsZXNbbmFtZV0pOyAvLyBTZXQgYWxsIHZhbHVlcyB0byBhbiBlbXB0eSBzdHJpbmcgdG8gdW5zZXQgdGhlbVxuXG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcbiAgICAgICAgc3R5bGVbcHJvcGVydHldID0gJyc7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogYXBwbHlTdHlsZXMsXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ11cbn07IiwgImltcG9ydCB7IGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn0iLCAiZXhwb3J0IHZhciBtYXggPSBNYXRoLm1heDtcbmV4cG9ydCB2YXIgbWluID0gTWF0aC5taW47XG5leHBvcnQgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDsiLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VUFTdHJpbmcoKSB7XG4gIHZhciB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcblxuICBpZiAodWFEYXRhICE9IG51bGwgJiYgdWFEYXRhLmJyYW5kcyAmJiBBcnJheS5pc0FycmF5KHVhRGF0YS5icmFuZHMpKSB7XG4gICAgcmV0dXJuIHVhRGF0YS5icmFuZHMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5icmFuZCArIFwiL1wiICsgaXRlbS52ZXJzaW9uO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xufSIsICJpbXBvcnQgZ2V0VUFTdHJpbmcgZnJvbSBcIi4uL3V0aWxzL3VzZXJBZ2VudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNMYXlvdXRWaWV3cG9ydCgpIHtcbiAgcmV0dXJuICEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xufSIsICJpbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGlzTGF5b3V0Vmlld3BvcnQgZnJvbSBcIi4vaXNMYXlvdXRWaWV3cG9ydC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGluY2x1ZGVTY2FsZSwgaXNGaXhlZFN0cmF0ZWd5KSB7XG4gIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xuICAgIGluY2x1ZGVTY2FsZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzRml4ZWRTdHJhdGVneSA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZFN0cmF0ZWd5ID0gZmFsc2U7XG4gIH1cblxuICB2YXIgY2xpZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSAxO1xuICB2YXIgc2NhbGVZID0gMTtcblxuICBpZiAoaW5jbHVkZVNjYWxlICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICBzY2FsZVggPSBlbGVtZW50Lm9mZnNldFdpZHRoID4gMCA/IHJvdW5kKGNsaWVudFJlY3Qud2lkdGgpIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxIDogMTtcbiAgICBzY2FsZVkgPSBlbGVtZW50Lm9mZnNldEhlaWdodCA+IDAgPyByb3VuZChjbGllbnRSZWN0LmhlaWdodCkgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxIDogMTtcbiAgfVxuXG4gIHZhciBfcmVmID0gaXNFbGVtZW50KGVsZW1lbnQpID8gZ2V0V2luZG93KGVsZW1lbnQpIDogd2luZG93LFxuICAgICAgdmlzdWFsVmlld3BvcnQgPSBfcmVmLnZpc3VhbFZpZXdwb3J0O1xuXG4gIHZhciBhZGRWaXN1YWxPZmZzZXRzID0gIWlzTGF5b3V0Vmlld3BvcnQoKSAmJiBpc0ZpeGVkU3RyYXRlZ3k7XG4gIHZhciB4ID0gKGNsaWVudFJlY3QubGVmdCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCA6IDApKSAvIHNjYWxlWDtcbiAgdmFyIHkgPSAoY2xpZW50UmVjdC50b3AgKyAoYWRkVmlzdWFsT2Zmc2V0cyAmJiB2aXN1YWxWaWV3cG9ydCA/IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcCA6IDApKSAvIHNjYWxlWTtcbiAgdmFyIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aCAvIHNjYWxlWDtcbiAgdmFyIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0IC8gc2NhbGVZO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB0b3A6IHksXG4gICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgbGVmdDogeCxcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn0iLCAiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjsgLy8gUmV0dXJucyB0aGUgbGF5b3V0IHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LiBMYXlvdXRcbi8vIG1lYW5zIGl0IGRvZXNuJ3QgdGFrZSBpbnRvIGFjY291bnQgdHJhbnNmb3Jtcy5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TGF5b3V0UmVjdChlbGVtZW50KSB7XG4gIHZhciBjbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpOyAvLyBVc2UgdGhlIGNsaWVudFJlY3Qgc2l6ZXMgaWYgaXQncyBub3QgYmVlbiB0cmFuc2Zvcm1lZC5cbiAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMjIzXG5cbiAgdmFyIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LndpZHRoIC0gd2lkdGgpIDw9IDEpIHtcbiAgICB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC5oZWlnaHQgLSBoZWlnaHQpIDw9IDEpIHtcbiAgICBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgIHk6IGVsZW1lbnQub2Zmc2V0VG9wLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufSIsICJpbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gIHZhciByb290Tm9kZSA9IGNoaWxkLmdldFJvb3ROb2RlICYmIGNoaWxkLmdldFJvb3ROb2RlKCk7IC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcblxuICBpZiAocGFyZW50LmNvbnRhaW5zKGNoaWxkKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIHRoZW4gZmFsbGJhY2sgdG8gY3VzdG9tIGltcGxlbWVudGF0aW9uIHdpdGggU2hhZG93IERPTSBzdXBwb3J0XG4gIGVsc2UgaWYgKHJvb3ROb2RlICYmIGlzU2hhZG93Um9vdChyb290Tm9kZSkpIHtcbiAgICAgIHZhciBuZXh0ID0gY2hpbGQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG5leHQgJiYgcGFyZW50LmlzU2FtZU5vZGUobmV4dCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ106IG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG5cblxuICAgICAgICBuZXh0ID0gbmV4dC5wYXJlbnROb2RlIHx8IG5leHQuaG9zdDtcbiAgICAgIH0gd2hpbGUgKG5leHQpO1xuICAgIH0gLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuXG5cbiAgcmV0dXJuIGZhbHNlO1xufSIsICJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn0iLCAiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5kZXhPZihnZXROb2RlTmFtZShlbGVtZW50KSkgPj0gMDtcbn0iLCAiaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIHtcbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICByZXR1cm4gKChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgZWxlbWVudC5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnQ7XG59IiwgImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZ2V0Tm9kZU5hbWUoZWxlbWVudCkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuICgvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICBlbGVtZW50LmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxuICAgIGVsZW1lbnQucGFyZW50Tm9kZSB8fCAoIC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgaXNTaGFkb3dSb290KGVsZW1lbnQpID8gZWxlbWVudC5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcbiAgICBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgLy8gZmFsbGJhY2tcblxuICApO1xufSIsICJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgaXNUYWJsZUVsZW1lbnQgZnJvbSBcIi4vaXNUYWJsZUVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBnZXRVQVN0cmluZyBmcm9tIFwiLi4vdXRpbHMvdXNlckFnZW50LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcbiAgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufSAvLyBgLm9mZnNldFBhcmVudGAgcmVwb3J0cyBgbnVsbGAgZm9yIGZpeGVkIGVsZW1lbnRzLCB3aGlsZSBhYnNvbHV0ZSBlbGVtZW50c1xuLy8gcmV0dXJuIHRoZSBjb250YWluaW5nIGJsb2NrXG5cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgdmFyIGlzRmlyZWZveCA9IC9maXJlZm94L2kudGVzdChnZXRVQVN0cmluZygpKTtcbiAgdmFyIGlzSUUgPSAvVHJpZGVudC9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG5cbiAgaWYgKGlzSUUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIC8vIEluIElFIDksIDEwIGFuZCAxMSBmaXhlZCBlbGVtZW50cyBjb250YWluaW5nIGJsb2NrIGlzIGFsd2F5cyBlc3RhYmxpc2hlZCBieSB0aGUgdmlld3BvcnRcbiAgICB2YXIgZWxlbWVudENzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgICBpZiAoZWxlbWVudENzcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcblxuICBpZiAoaXNTaGFkb3dSb290KGN1cnJlbnROb2RlKSkge1xuICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuaG9zdDtcbiAgfVxuXG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiBbJ2h0bWwnLCAnYm9keSddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoY3VycmVudE5vZGUpKSA8IDApIHtcbiAgICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7IC8vIFRoaXMgaXMgbm9uLWV4aGF1c3RpdmUgYnV0IGNvdmVycyB0aGUgbW9zdCBjb21tb24gQ1NTIHByb3BlcnRpZXMgdGhhdFxuICAgIC8vIGNyZWF0ZSBhIGNvbnRhaW5pbmcgYmxvY2suXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcblxuICAgIGlmIChjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgY3NzLmNvbnRhaW4gPT09ICdwYWludCcgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnXS5pbmRleE9mKGNzcy53aWxsQ2hhbmdlKSAhPT0gLTEgfHwgaXNGaXJlZm94ICYmIGNzcy53aWxsQ2hhbmdlID09PSAnZmlsdGVyJyB8fCBpc0ZpcmVmb3ggJiYgY3NzLmZpbHRlciAmJiBjc3MuZmlsdGVyICE9PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSAvLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuXG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgaWYgKG9mZnNldFBhcmVudCAmJiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2h0bWwnIHx8IGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG59IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xufSIsICJpbXBvcnQgeyBtYXggYXMgbWF0aE1heCwgbWluIGFzIG1hdGhNaW4gfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gd2l0aGluKG1pbiwgdmFsdWUsIG1heCkge1xuICByZXR1cm4gbWF0aE1heChtaW4sIG1hdGhNaW4odmFsdWUsIG1heCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbk1heENsYW1wKG1pbiwgdmFsdWUsIG1heCkge1xuICB2YXIgdiA9IHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpO1xuICByZXR1cm4gdiA+IG1heCA/IG1heCA6IHY7XG59IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEZyZXNoU2lkZU9iamVjdCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn0iLCAiaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChwYWRkaW5nT2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSwgcGFkZGluZ09iamVjdCk7XG59IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4cGFuZFRvSGFzaE1hcCh2YWx1ZSwga2V5cykge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc2hNYXAsIGtleSkge1xuICAgIGhhc2hNYXBba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBoYXNoTWFwO1xuICB9LCB7fSk7XG59IiwgImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBjb250YWlucyBmcm9tIFwiLi4vZG9tLXV0aWxzL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHdpdGhpbiB9IGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4uL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qc1wiO1xuaW1wb3J0IGV4cGFuZFRvSGFzaE1hcCBmcm9tIFwiLi4vdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzXCI7XG5pbXBvcnQgeyBsZWZ0LCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHRvcCwgYm90dG9tIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHRvUGFkZGluZ09iamVjdCA9IGZ1bmN0aW9uIHRvUGFkZGluZ09iamVjdChwYWRkaW5nLCBzdGF0ZSkge1xuICBwYWRkaW5nID0gdHlwZW9mIHBhZGRpbmcgPT09ICdmdW5jdGlvbicgPyBwYWRkaW5nKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogcGFkZGluZztcbiAgcmV0dXJuIG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG59O1xuXG5mdW5jdGlvbiBhcnJvdyhfcmVmKSB7XG4gIHZhciBfc3RhdGUkbW9kaWZpZXJzRGF0YSQ7XG5cbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBpc1ZlcnRpY2FsID0gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIGlmICghYXJyb3dFbGVtZW50IHx8ICFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhZGRpbmdPYmplY3QgPSB0b1BhZGRpbmdPYmplY3Qob3B0aW9ucy5wYWRkaW5nLCBzdGF0ZSk7XG4gIHZhciBhcnJvd1JlY3QgPSBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCk7XG4gIHZhciBtaW5Qcm9wID0gYXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgdmFyIG1heFByb3AgPSBheGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgdmFyIGVuZERpZmYgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbbGVuXSArIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5wb3BwZXJbbGVuXTtcbiAgdmFyIHN0YXJ0RGlmZiA9IHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gIHZhciBhcnJvd09mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChhcnJvd0VsZW1lbnQpO1xuICB2YXIgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwIDogMDtcbiAgdmFyIGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyOyAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIHBvcHBlciBpZiB0aGUgY2VudGVyIHBvaW50IGlzXG4gIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcblxuICB2YXIgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgdmFyIG1heCA9IGNsaWVudFNpemUgLSBhcnJvd1JlY3RbbGVuXSAtIHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XG4gIHZhciBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93UmVjdFtsZW5dIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICB2YXIgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpOyAvLyBQcmV2ZW50cyBicmVha2luZyBzeW50YXggaGlnaGxpZ2h0aW5nLi4uXG5cbiAgdmFyIGF4aXNQcm9wID0gYXhpcztcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IChfc3RhdGUkbW9kaWZpZXJzRGF0YSQgPSB7fSwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkW2F4aXNQcm9wXSA9IG9mZnNldCwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkLmNlbnRlck9mZnNldCA9IG9mZnNldCAtIGNlbnRlciwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkKTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRlbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50LFxuICAgICAgYXJyb3dFbGVtZW50ID0gX29wdGlvbnMkZWxlbWVudCA9PT0gdm9pZCAwID8gJ1tkYXRhLXBvcHBlci1hcnJvd10nIDogX29wdGlvbnMkZWxlbWVudDtcblxuICBpZiAoYXJyb3dFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gQ1NTIHNlbGVjdG9yXG5cblxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnRhaW5zKHN0YXRlLmVsZW1lbnRzLnBvcHBlciwgYXJyb3dFbGVtZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXRlLmVsZW1lbnRzLmFycm93ID0gYXJyb3dFbGVtZW50O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnYXJyb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogYXJyb3csXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J11cbn07IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xufSIsICJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIGVuZCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHVuc2V0U2lkZXMgPSB7XG4gIHRvcDogJ2F1dG8nLFxuICByaWdodDogJ2F1dG8nLFxuICBib3R0b206ICdhdXRvJyxcbiAgbGVmdDogJ2F1dG8nXG59OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuXG5mdW5jdGlvbiByb3VuZE9mZnNldHNCeURQUihfcmVmLCB3aW4pIHtcbiAgdmFyIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55O1xuICB2YXIgZHByID0gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgcmV0dXJuIHtcbiAgICB4OiByb3VuZCh4ICogZHByKSAvIGRwciB8fCAwLFxuICAgIHk6IHJvdW5kKHkgKiBkcHIpIC8gZHByIHx8IDBcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvU3R5bGVzKF9yZWYyKSB7XG4gIHZhciBfT2JqZWN0JGFzc2lnbjI7XG5cbiAgdmFyIHBvcHBlciA9IF9yZWYyLnBvcHBlcixcbiAgICAgIHBvcHBlclJlY3QgPSBfcmVmMi5wb3BwZXJSZWN0LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZjIucGxhY2VtZW50LFxuICAgICAgdmFyaWF0aW9uID0gX3JlZjIudmFyaWF0aW9uLFxuICAgICAgb2Zmc2V0cyA9IF9yZWYyLm9mZnNldHMsXG4gICAgICBwb3NpdGlvbiA9IF9yZWYyLnBvc2l0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX3JlZjIuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgYWRhcHRpdmUgPSBfcmVmMi5hZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9yZWYyLnJvdW5kT2Zmc2V0cyxcbiAgICAgIGlzRml4ZWQgPSBfcmVmMi5pc0ZpeGVkO1xuICB2YXIgX29mZnNldHMkeCA9IG9mZnNldHMueCxcbiAgICAgIHggPSBfb2Zmc2V0cyR4ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeCxcbiAgICAgIF9vZmZzZXRzJHkgPSBvZmZzZXRzLnksXG4gICAgICB5ID0gX29mZnNldHMkeSA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHk7XG5cbiAgdmFyIF9yZWYzID0gdHlwZW9mIHJvdW5kT2Zmc2V0cyA9PT0gJ2Z1bmN0aW9uJyA/IHJvdW5kT2Zmc2V0cyh7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0pIDoge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xuXG4gIHggPSBfcmVmMy54O1xuICB5ID0gX3JlZjMueTtcbiAgdmFyIGhhc1ggPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd4Jyk7XG4gIHZhciBoYXNZID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneScpO1xuICB2YXIgc2lkZVggPSBsZWZ0O1xuICB2YXIgc2lkZVkgPSB0b3A7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG5cbiAgaWYgKGFkYXB0aXZlKSB7XG4gICAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChwb3BwZXIpO1xuICAgIHZhciBoZWlnaHRQcm9wID0gJ2NsaWVudEhlaWdodCc7XG4gICAgdmFyIHdpZHRoUHJvcCA9ICdjbGllbnRXaWR0aCc7XG5cbiAgICBpZiAob2Zmc2V0UGFyZW50ID09PSBnZXRXaW5kb3cocG9wcGVyKSkge1xuICAgICAgb2Zmc2V0UGFyZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KHBvcHBlcik7XG5cbiAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gIT09ICdzdGF0aWMnICYmIHBvc2l0aW9uID09PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgIGhlaWdodFByb3AgPSAnc2Nyb2xsSGVpZ2h0JztcbiAgICAgICAgd2lkdGhQcm9wID0gJ3Njcm9sbFdpZHRoJztcbiAgICAgIH1cbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhc3RdOiBmb3JjZSB0eXBlIHJlZmluZW1lbnQsIHdlIGNvbXBhcmUgb2Zmc2V0UGFyZW50IHdpdGggd2luZG93IGFib3ZlLCBidXQgRmxvdyBkb2Vzbid0IGRldGVjdCBpdFxuXG5cbiAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQ7XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSB0b3AgfHwgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCBwbGFjZW1lbnQgPT09IHJpZ2h0KSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVkgPSBib3R0b207XG4gICAgICB2YXIgb2Zmc2V0WSA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LmhlaWdodCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgb2Zmc2V0UGFyZW50W2hlaWdodFByb3BdO1xuICAgICAgeSAtPSBvZmZzZXRZIC0gcG9wcGVyUmVjdC5oZWlnaHQ7XG4gICAgICB5ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSBsZWZ0IHx8IChwbGFjZW1lbnQgPT09IHRvcCB8fCBwbGFjZW1lbnQgPT09IGJvdHRvbSkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVYID0gcmlnaHQ7XG4gICAgICB2YXIgb2Zmc2V0WCA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LndpZHRoIDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbd2lkdGhQcm9wXTtcbiAgICAgIHggLT0gb2Zmc2V0WCAtIHBvcHBlclJlY3Qud2lkdGg7XG4gICAgICB4ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uXG4gIH0sIGFkYXB0aXZlICYmIHVuc2V0U2lkZXMpO1xuXG4gIHZhciBfcmVmNCA9IHJvdW5kT2Zmc2V0cyA9PT0gdHJ1ZSA/IHJvdW5kT2Zmc2V0c0J5RFBSKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSwgZ2V0V2luZG93KHBvcHBlcikpIDoge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xuXG4gIHggPSBfcmVmNC54O1xuICB5ID0gX3JlZjQueTtcblxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uKSB7XG4gICAgdmFyIF9PYmplY3QkYXNzaWduO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduID0ge30sIF9PYmplY3QkYXNzaWduW3NpZGVZXSA9IGhhc1kgPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ25bc2lkZVhdID0gaGFzWCA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbi50cmFuc2Zvcm0gPSAod2luLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPD0gMSA/IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCIgOiBcInRyYW5zbGF0ZTNkKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgsIDApXCIsIF9PYmplY3QkYXNzaWduKSk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24yID0ge30sIF9PYmplY3QkYXNzaWduMltzaWRlWV0gPSBoYXNZID8geSArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjJbc2lkZVhdID0gaGFzWCA/IHggKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yLnRyYW5zZm9ybSA9ICcnLCBfT2JqZWN0JGFzc2lnbjIpKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVN0eWxlcyhfcmVmNSkge1xuICB2YXIgc3RhdGUgPSBfcmVmNS5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmNS5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID0gb3B0aW9ucy5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRncHVBY2NlbGVyYXQsXG4gICAgICBfb3B0aW9ucyRhZGFwdGl2ZSA9IG9wdGlvbnMuYWRhcHRpdmUsXG4gICAgICBhZGFwdGl2ZSA9IF9vcHRpb25zJGFkYXB0aXZlID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWRhcHRpdmUsXG4gICAgICBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPSBvcHRpb25zLnJvdW5kT2Zmc2V0cyxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJvdW5kT2Zmc2V0cztcbiAgdmFyIGNvbW1vblN0eWxlcyA9IHtcbiAgICBwbGFjZW1lbnQ6IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KSxcbiAgICB2YXJpYXRpb246IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBncHVBY2NlbGVyYXRpb246IGdwdUFjY2VsZXJhdGlvbixcbiAgICBpc0ZpeGVkOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnXG4gIH07XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5wb3BwZXIsIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLFxuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBhZGFwdGl2ZTogYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLmFycm93LCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3csXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGFkYXB0aXZlOiBmYWxzZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcGxhY2VtZW50Jzogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICBmbjogY29tcHV0ZVN0eWxlcyxcbiAgZGF0YToge31cbn07IiwgImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRXaW5kb3cuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgcGFzc2l2ZSA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRzY3JvbGwgPSBvcHRpb25zLnNjcm9sbCxcbiAgICAgIHNjcm9sbCA9IF9vcHRpb25zJHNjcm9sbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHNjcm9sbCxcbiAgICAgIF9vcHRpb25zJHJlc2l6ZSA9IG9wdGlvbnMucmVzaXplLFxuICAgICAgcmVzaXplID0gX29wdGlvbnMkcmVzaXplID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcmVzaXplO1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KHN0YXRlLmVsZW1lbnRzLnBvcHBlcik7XG4gIHZhciBzY3JvbGxQYXJlbnRzID0gW10uY29uY2F0KHN0YXRlLnNjcm9sbFBhcmVudHMucmVmZXJlbmNlLCBzdGF0ZS5zY3JvbGxQYXJlbnRzLnBvcHBlcik7XG5cbiAgaWYgKHNjcm9sbCkge1xuICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICBzY3JvbGxQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgc2Nyb2xsUGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdldmVudExpc3RlbmVycycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogZnVuY3Rpb24gZm4oKSB7fSxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIGRhdGE6IHt9XG59OyIsICJ2YXIgaGFzaCA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn0iLCAidmFyIGhhc2ggPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsICJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKG5vZGUpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhub2RlKTtcbiAgdmFyIHNjcm9sbExlZnQgPSB3aW4ucGFnZVhPZmZzZXQ7XG4gIHZhciBzY3JvbGxUb3AgPSB3aW4ucGFnZVlPZmZzZXQ7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcFxuICB9O1xufSIsICJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcbiAgLy8gaXQncyBub3QgYW4gaXNzdWUuIEkgZG9uJ3QgdGhpbmsgYW55b25lIGV2ZXIgc3BlY2lmaWVzIHdpZHRoIG9uIDxodG1sPlxuICAvLyBhbnl3YXkuXG4gIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXG4gIC8vIHRoaXMgKGUuZy4gRWRnZSAyMDE5LCBJRTExLCBTYWZhcmkpXG4gIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59IiwgImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGlzTGF5b3V0Vmlld3BvcnQgZnJvbSBcIi4vaXNMYXlvdXRWaWV3cG9ydC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIHZhciB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG5cbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7XG4gICAgdmFyIGxheW91dFZpZXdwb3J0ID0gaXNMYXlvdXRWaWV3cG9ydCgpO1xuXG4gICAgaWYgKGxheW91dFZpZXdwb3J0IHx8ICFsYXlvdXRWaWV3cG9ydCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHggKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpLFxuICAgIHk6IHlcbiAgfTtcbn0iLCAiaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5pbXBvcnQgeyBtYXggfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiOyAvLyBHZXRzIHRoZSBlbnRpcmUgc2l6ZSBvZiB0aGUgc2Nyb2xsYWJsZSBkb2N1bWVudCBhcmVhLCBldmVuIGV4dGVuZGluZyBvdXRzaWRlXG4vLyBvZiB0aGUgYDxodG1sPmAgYW5kIGA8Ym9keT5gIHJlY3QgYm91bmRzIGlmIGhvcml6b250YWxseSBzY3JvbGxhYmxlXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB3aW5TY3JvbGwgPSBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCk7XG4gIHZhciBib2R5ID0gKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5O1xuICB2YXIgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApO1xuICB2YXIgaGVpZ2h0ID0gbWF4KGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgYm9keSA/IGJvZHkuc2Nyb2xsSGVpZ2h0IDogMCwgYm9keSA/IGJvZHkuY2xpZW50SGVpZ2h0IDogMCk7XG4gIHZhciB4ID0gLXdpblNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgdmFyIHkgPSAtd2luU2Nyb2xsLnNjcm9sbFRvcDtcblxuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShib2R5IHx8IGh0bWwpLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApIC0gd2lkdGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn0iLCAiaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufSIsICJpbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChub2RlKSB7XG4gIGlmIChbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmRleE9mKGdldE5vZGVOYW1lKG5vZGUpKSA+PSAwKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KG5vZGUpICYmIGlzU2Nyb2xsUGFyZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUobm9kZSkpO1xufSIsICJpbXBvcnQgZ2V0U2Nyb2xsUGFyZW50IGZyb20gXCIuL2dldFNjcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuLypcbmdpdmVuIGEgRE9NIGVsZW1lbnQsIHJldHVybiB0aGUgbGlzdCBvZiBhbGwgc2Nyb2xsIHBhcmVudHMsIHVwIHRoZSBsaXN0IG9mIGFuY2Vzb3JzXG51bnRpbCB3ZSBnZXQgdG8gdGhlIHRvcCB3aW5kb3cgb2JqZWN0LiBUaGlzIGxpc3QgaXMgd2hhdCB3ZSBhdHRhY2ggc2Nyb2xsIGxpc3RlbmVyc1xudG8sIGJlY2F1c2UgaWYgYW55IG9mIHRoZXNlIHBhcmVudCBlbGVtZW50cyBzY3JvbGwsIHdlJ2xsIG5lZWQgdG8gcmUtY2FsY3VsYXRlIHRoZVxucmVmZXJlbmNlIGVsZW1lbnQncyBwb3NpdGlvbi5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxpc3RTY3JvbGxQYXJlbnRzKGVsZW1lbnQsIGxpc3QpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgbGlzdCA9IFtdO1xuICB9XG5cbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChlbGVtZW50KTtcbiAgdmFyIGlzQm9keSA9IHNjcm9sbFBhcmVudCA9PT0gKChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keSk7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsUGFyZW50KTtcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IFt3aW5dLmNvbmNhdCh3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzU2Nyb2xsUGFyZW50KHNjcm9sbFBhcmVudCkgPyBzY3JvbGxQYXJlbnQgOiBbXSkgOiBzY3JvbGxQYXJlbnQ7XG4gIHZhciB1cGRhdGVkTGlzdCA9IGxpc3QuY29uY2F0KHRhcmdldCk7XG4gIHJldHVybiBpc0JvZHkgPyB1cGRhdGVkTGlzdCA6IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBpc0JvZHkgdGVsbHMgdXMgdGFyZ2V0IHdpbGwgYmUgYW4gSFRNTEVsZW1lbnQgaGVyZVxuICB1cGRhdGVkTGlzdC5jb25jYXQobGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZSh0YXJnZXQpKSk7XG59IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge1xuICAgIGxlZnQ6IHJlY3QueCxcbiAgICB0b3A6IHJlY3QueSxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH0pO1xufSIsICJpbXBvcnQgeyB2aWV3cG9ydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZpZXdwb3J0UmVjdCBmcm9tIFwiLi9nZXRWaWV3cG9ydFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudFJlY3QgZnJvbSBcIi4vZ2V0RG9jdW1lbnRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vbGlzdFNjcm9sbFBhcmVudHMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4vZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBjb250YWlucyBmcm9tIFwiLi9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgcmVjdFRvQ2xpZW50UmVjdCBmcm9tIFwiLi4vdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgbWF4LCBtaW4gfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBmYWxzZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuICByZWN0LnRvcCA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIHJlY3QubGVmdCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC53aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3QuaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QueCA9IHJlY3QubGVmdDtcbiAgcmVjdC55ID0gcmVjdC50b3A7XG4gIHJldHVybiByZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIHtcbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50ID09PSB2aWV3cG9ydCA/IHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSkgOiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpID8gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSA6IHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xufSAvLyBBIFwiY2xpcHBpbmcgcGFyZW50XCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXG4vLyBgaW5pdGlhbGBcblxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkge1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gbGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG4gIHZhciBjYW5Fc2NhcGVDbGlwcGluZyA9IFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24pID49IDA7XG4gIHZhciBjbGlwcGVyRWxlbWVudCA9IGNhbkVzY2FwZUNsaXBwaW5nICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gIGlmICghaXNFbGVtZW50KGNsaXBwZXJFbGVtZW50KSkge1xuICAgIHJldHVybiBbXTtcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMTQxNFxuXG5cbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50cy5maWx0ZXIoZnVuY3Rpb24gKGNsaXBwaW5nUGFyZW50KSB7XG4gICAgcmV0dXJuIGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgJiYgY29udGFpbnMoY2xpcHBpbmdQYXJlbnQsIGNsaXBwZXJFbGVtZW50KSAmJiBnZXROb2RlTmFtZShjbGlwcGluZ1BhcmVudCkgIT09ICdib2R5JztcbiAgfSk7XG59IC8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIHBhcmVudHNcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoZWxlbWVudCwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSwgc3RyYXRlZ3kpIHtcbiAgdmFyIG1haW5DbGlwcGluZ1BhcmVudHMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nUGFyZW50cycgPyBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gW10uY29uY2F0KG1haW5DbGlwcGluZ1BhcmVudHMsIFtyb290Qm91bmRhcnldKTtcbiAgdmFyIGZpcnN0Q2xpcHBpbmdQYXJlbnQgPSBjbGlwcGluZ1BhcmVudHNbMF07XG4gIHZhciBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ1BhcmVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2NSZWN0LCBjbGlwcGluZ1BhcmVudCkge1xuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBmaXJzdENsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkpO1xuICBjbGlwcGluZ1JlY3Qud2lkdGggPSBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LmhlaWdodCA9IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wO1xuICBjbGlwcGluZ1JlY3QueCA9IGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QueSA9IGNsaXBwaW5nUmVjdC50b3A7XG4gIHJldHVybiBjbGlwcGluZ1JlY3Q7XG59IiwgImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCBzdGFydCwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gIHZhciBvZmZzZXRzO1xuXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBib3R0b206XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBlbmQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufSIsICJpbXBvcnQgZ2V0Q2xpcHBpbmdSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4vY29tcHV0ZU9mZnNldHMuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuL3JlY3RUb0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCB7IGNsaXBwaW5nUGFyZW50cywgcmVmZXJlbmNlLCBwb3BwZXIsIGJvdHRvbSwgdG9wLCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4vbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuL2V4cGFuZFRvSGFzaE1hcC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMkcGxhY2VtZW50ID09PSB2b2lkIDAgPyBzdGF0ZS5wbGFjZW1lbnQgOiBfb3B0aW9ucyRwbGFjZW1lbnQsXG4gICAgICBfb3B0aW9ucyRzdHJhdGVneSA9IF9vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgc3RyYXRlZ3kgPSBfb3B0aW9ucyRzdHJhdGVneSA9PT0gdm9pZCAwID8gc3RhdGUuc3RyYXRlZ3kgOiBfb3B0aW9ucyRzdHJhdGVneSxcbiAgICAgIF9vcHRpb25zJGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zJGJvdW5kYXJ5ID09PSB2b2lkIDAgPyBjbGlwcGluZ1BhcmVudHMgOiBfb3B0aW9ucyRib3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9PT0gdm9pZCAwID8gdmlld3BvcnQgOiBfb3B0aW9ucyRyb290Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRlbGVtZW50Q29udGUgPSBfb3B0aW9ucy5lbGVtZW50Q29udGV4dCxcbiAgICAgIGVsZW1lbnRDb250ZXh0ID0gX29wdGlvbnMkZWxlbWVudENvbnRlID09PSB2b2lkIDAgPyBwb3BwZXIgOiBfb3B0aW9ucyRlbGVtZW50Q29udGUsXG4gICAgICBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9IF9vcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zJHBhZGRpbmcgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRwYWRkaW5nO1xuICB2YXIgcGFkZGluZ09iamVjdCA9IG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG4gIHZhciBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHJlZmVyZW5jZSA6IHBvcHBlcjtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICB2YXIgY2xpcHBpbmdDbGllbnRSZWN0ID0gZ2V0Q2xpcHBpbmdSZWN0KGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IGdldERvY3VtZW50RWxlbWVudChzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSk7XG4gIHZhciByZWZlcmVuY2VDbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICBlbGVtZW50OiBwb3BwZXJSZWN0LFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pO1xuICB2YXIgcG9wcGVyQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoT2JqZWN0LmFzc2lnbih7fSwgcG9wcGVyUmVjdCwgcG9wcGVyT2Zmc2V0cykpO1xuICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuXG4gIHZhciBvdmVyZmxvd09mZnNldHMgPSB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgfTtcbiAgdmFyIG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDsgLy8gT2Zmc2V0cyBjYW4gYmUgYXBwbGllZCBvbmx5IHRvIHRoZSBwb3BwZXIgZWxlbWVudFxuXG4gIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0RGF0YVtwbGFjZW1lbnRdO1xuICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICB2YXIgYXhpcyA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAneScgOiAneCc7XG4gICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvdmVyZmxvd09mZnNldHM7XG59IiwgImltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgeyB2YXJpYXRpb25QbGFjZW1lbnRzLCBiYXNlUGxhY2VtZW50cywgcGxhY2VtZW50cyBhcyBhbGxQbGFjZW1lbnRzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4vZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9IF9vcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9PT0gdm9pZCAwID8gYWxsUGxhY2VtZW50cyA6IF9vcHRpb25zJGFsbG93ZWRBdXRvUDtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpO1xuICB2YXIgcGxhY2VtZW50cyA9IHZhcmlhdGlvbiA/IGZsaXBWYXJpYXRpb25zID8gdmFyaWF0aW9uUGxhY2VtZW50cyA6IHZhcmlhdGlvblBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHZhcmlhdGlvbjtcbiAgfSkgOiBiYXNlUGxhY2VtZW50cztcbiAgdmFyIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhbGxvd2VkQXV0b1BsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpID49IDA7XG4gIH0pO1xuXG4gIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV06IEZsb3cgc2VlbXMgdG8gaGF2ZSBwcm9ibGVtcyB3aXRoIHR3byBhcnJheSB1bmlvbnMuLi5cblxuXG4gIHZhciBvdmVyZmxvd3MgPSBhbGxvd2VkUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KVtnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCldO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG92ZXJmbG93cykuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBvdmVyZmxvd3NbYV0gLSBvdmVyZmxvd3NbYl07XG4gIH0pO1xufSIsICJpbXBvcnQgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVBdXRvUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgYm90dG9tLCB0b3AsIHN0YXJ0LCByaWdodCwgbGVmdCwgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGlmIChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuXG5mdW5jdGlvbiBmbGlwKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzID0gb3B0aW9ucy5mYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPSBvcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRmbGlwVmFyaWF0aW8sXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBvcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cztcbiAgdmFyIHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9IGJhc2VQbGFjZW1lbnQgPT09IHByZWZlcnJlZFBsYWNlbWVudDtcbiAgdmFyIGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9ucyA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHByZWZlcnJlZFBsYWNlbWVudCkpO1xuICB2YXIgcGxhY2VtZW50cyA9IFtwcmVmZXJyZWRQbGFjZW1lbnRdLmNvbmNhdChmYWxsYmFja1BsYWNlbWVudHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8gPyBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9uczogZmxpcFZhcmlhdGlvbnMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IGFsbG93ZWRBdXRvUGxhY2VtZW50c1xuICAgIH0pIDogcGxhY2VtZW50KTtcbiAgfSwgW10pO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBjaGVja3NNYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBtYWtlRmFsbGJhY2tDaGVja3MgPSB0cnVlO1xuICB2YXIgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGxhY2VtZW50ID0gcGxhY2VtZW50c1tpXTtcblxuICAgIHZhciBfYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBpc1N0YXJ0VmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHN0YXJ0O1xuICAgIHZhciBpc1ZlcnRpY2FsID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKF9iYXNlUGxhY2VtZW50KSA+PSAwO1xuICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pO1xuICAgIHZhciBtYWluVmFyaWF0aW9uU2lkZSA9IGlzVmVydGljYWwgPyBpc1N0YXJ0VmFyaWF0aW9uID8gcmlnaHQgOiBsZWZ0IDogaXNTdGFydFZhcmlhdGlvbiA/IGJvdHRvbSA6IHRvcDtcblxuICAgIGlmIChyZWZlcmVuY2VSZWN0W2xlbl0gPiBwb3BwZXJSZWN0W2xlbl0pIHtcbiAgICAgIG1haW5WYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIH1cblxuICAgIHZhciBhbHRWYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIHZhciBjaGVja3MgPSBbXTtcblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tfYmFzZVBsYWNlbWVudF0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbbWFpblZhcmlhdGlvblNpZGVdIDw9IDAsIG92ZXJmbG93W2FsdFZhcmlhdGlvblNpZGVdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja3MuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICByZXR1cm4gY2hlY2s7XG4gICAgfSkpIHtcbiAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgIG1ha2VGYWxsYmFja0NoZWNrcyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XG4gIH1cblxuICBpZiAobWFrZUZhbGxiYWNrQ2hlY2tzKSB7XG4gICAgLy8gYDJgIG1heSBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMgXHUyMDEzIHJlc2VhcmNoIGxhdGVyXG4gICAgdmFyIG51bWJlck9mQ2hlY2tzID0gZmxpcFZhcmlhdGlvbnMgPyAzIDogMTtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XG4gICAgICB2YXIgZml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHMuZmluZChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICAgIHZhciBjaGVja3MgPSBjaGVja3NNYXAuZ2V0KHBsYWNlbWVudCk7XG5cbiAgICAgICAgaWYgKGNoZWNrcykge1xuICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgX2kpLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gZml0dGluZ1BsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2kgPSBudW1iZXJPZkNoZWNrczsgX2kgPiAwOyBfaS0tKSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKF9pKTtcblxuICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnBsYWNlbWVudCAhPT0gZmlyc3RGaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCA9IHRydWU7XG4gICAgc3RhdGUucGxhY2VtZW50ID0gZmlyc3RGaXR0aW5nUGxhY2VtZW50O1xuICAgIHN0YXRlLnJlc2V0ID0gdHJ1ZTtcbiAgfVxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZmxpcCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBmbGlwLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddLFxuICBkYXRhOiB7XG4gICAgX3NraXA6IGZhbHNlXG4gIH1cbn07IiwgImltcG9ydCB7IHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCwgcHJldmVudGVkT2Zmc2V0cykge1xuICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XG4gICAgcHJldmVudGVkT2Zmc2V0cyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCAtIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoICsgcHJldmVudGVkT2Zmc2V0cy54LFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQgKyBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGggLSBwcmV2ZW50ZWRPZmZzZXRzLnhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5zb21lKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93W3NpZGVdID49IDA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoaWRlKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHByZXZlbnRlZE9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdztcbiAgdmFyIHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgfSk7XG4gIHZhciBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgfSk7XG4gIHZhciByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhyZWZlcmVuY2VPdmVyZmxvdywgcmVmZXJlbmNlUmVjdCk7XG4gIHZhciBwb3BwZXJFc2NhcGVPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocG9wcGVyQWx0T3ZlcmZsb3csIHBvcHBlclJlY3QsIHByZXZlbnRlZE9mZnNldHMpO1xuICB2YXIgaXNSZWZlcmVuY2VIaWRkZW4gPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzKTtcbiAgdmFyIGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOiByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogcG9wcGVyRXNjYXBlT2Zmc2V0cyxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbjogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgaGFzUG9wcGVyRXNjYXBlZDogaGFzUG9wcGVyRXNjYXBlZFxuICB9O1xuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW4nOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICAnZGF0YS1wb3BwZXItZXNjYXBlZCc6IGhhc1BvcHBlckVzY2FwZWRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdoaWRlJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXSxcbiAgZm46IGhpZGVcbn07IiwgImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBwbGFjZW1lbnRzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgcmVjdHMsIG9mZnNldCkge1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIGludmVydERpc3RhbmNlID0gW2xlZnQsIHRvcF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8gLTEgOiAxO1xuXG4gIHZhciBfcmVmID0gdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IG9mZnNldChPYmplY3QuYXNzaWduKHt9LCByZWN0cywge1xuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pKSA6IG9mZnNldCxcbiAgICAgIHNraWRkaW5nID0gX3JlZlswXSxcbiAgICAgIGRpc3RhbmNlID0gX3JlZlsxXTtcblxuICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XG4gIGRpc3RhbmNlID0gKGRpc3RhbmNlIHx8IDApICogaW52ZXJ0RGlzdGFuY2U7XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IHtcbiAgICB4OiBkaXN0YW5jZSxcbiAgICB5OiBza2lkZGluZ1xuICB9IDoge1xuICAgIHg6IHNraWRkaW5nLFxuICAgIHk6IGRpc3RhbmNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9mZnNldChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYyLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRvZmZzZXQgPSBvcHRpb25zLm9mZnNldCxcbiAgICAgIG9mZnNldCA9IF9vcHRpb25zJG9mZnNldCA9PT0gdm9pZCAwID8gWzAsIDBdIDogX29wdGlvbnMkb2Zmc2V0O1xuICB2YXIgZGF0YSA9IHBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCBzdGF0ZS5yZWN0cywgb2Zmc2V0KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHZhciBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQgPSBkYXRhW3N0YXRlLnBsYWNlbWVudF0sXG4gICAgICB4ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50LngsXG4gICAgICB5ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50Lnk7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0geDtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSB5O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdvZmZzZXQnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIGZuOiBvZmZzZXRcbn07IiwgImltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZU9mZnNldHMuanNcIjtcblxuZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxuICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdyZWFkJyxcbiAgZm46IHBvcHBlck9mZnNldHMsXG4gIGRhdGE6IHt9XG59OyIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn0iLCAiaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCBzdGFydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEFsdEF4aXMgZnJvbSBcIi4uL3V0aWxzL2dldEFsdEF4aXMuanNcIjtcbmltcG9ydCB7IHdpdGhpbiwgd2l0aGluTWF4Q2xhbXAgfSBmcm9tIFwiLi4vdXRpbHMvd2l0aGluLmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi4vdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5pbXBvcnQgeyBtaW4gYXMgbWF0aE1pbiwgbWF4IGFzIG1hdGhNYXggfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXIgPSBvcHRpb25zLnRldGhlcixcbiAgICAgIHRldGhlciA9IF9vcHRpb25zJHRldGhlciA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHRldGhlcixcbiAgICAgIF9vcHRpb25zJHRldGhlck9mZnNldCA9IG9wdGlvbnMudGV0aGVyT2Zmc2V0LFxuICAgICAgdGV0aGVyT2Zmc2V0ID0gX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkdGV0aGVyT2Zmc2V0O1xuICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeVxuICB9KTtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9ICF2YXJpYXRpb247XG4gIHZhciBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGFsdEF4aXMgPSBnZXRBbHRBeGlzKG1haW5BeGlzKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IHRldGhlck9mZnNldChPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHRldGhlck9mZnNldDtcbiAgdmFyIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXRWYWx1ZSA9PT0gJ251bWJlcicgPyB7XG4gICAgbWFpbkF4aXM6IHRldGhlck9mZnNldFZhbHVlLFxuICAgIGFsdEF4aXM6IHRldGhlck9mZnNldFZhbHVlXG4gIH0gOiBPYmplY3QuYXNzaWduKHtcbiAgICBtYWluQXhpczogMCxcbiAgICBhbHRBeGlzOiAwXG4gIH0sIHRldGhlck9mZnNldFZhbHVlKTtcbiAgdmFyIG9mZnNldE1vZGlmaWVyU3RhdGUgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldCA/IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0W3N0YXRlLnBsYWNlbWVudF0gOiBudWxsO1xuICB2YXIgZGF0YSA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQ7XG5cbiAgICB2YXIgbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgICB2YXIgYWx0U2lkZSA9IG1haW5BeGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc107XG4gICAgdmFyIG1pbiA9IG9mZnNldCArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICB2YXIgbWF4ID0gb2Zmc2V0IC0gb3ZlcmZsb3dbYWx0U2lkZV07XG4gICAgdmFyIGFkZGl0aXZlID0gdGV0aGVyID8gLXBvcHBlclJlY3RbbGVuXSAvIDIgOiAwO1xuICAgIHZhciBtaW5MZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gcmVmZXJlbmNlUmVjdFtsZW5dIDogcG9wcGVyUmVjdFtsZW5dO1xuICAgIHZhciBtYXhMZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gLXBvcHBlclJlY3RbbGVuXSA6IC1yZWZlcmVuY2VSZWN0W2xlbl07IC8vIFdlIG5lZWQgdG8gaW5jbHVkZSB0aGUgYXJyb3cgaW4gdGhlIGNhbGN1bGF0aW9uIHNvIHRoZSBhcnJvdyBkb2Vzbid0IGdvXG4gICAgLy8gb3V0c2lkZSB0aGUgcmVmZXJlbmNlIGJvdW5kc1xuXG4gICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICAgIHZhciBhcnJvd1JlY3QgPSB0ZXRoZXIgJiYgYXJyb3dFbGVtZW50ID8gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpIDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIHZhciBhcnJvd1BhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10gPyBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10ucGFkZGluZyA6IGdldEZyZXNoU2lkZU9iamVjdCgpO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNYXggPSBhcnJvd1BhZGRpbmdPYmplY3RbYWx0U2lkZV07IC8vIElmIHRoZSByZWZlcmVuY2UgbGVuZ3RoIGlzIHNtYWxsZXIgdGhhbiB0aGUgYXJyb3cgbGVuZ3RoLCB3ZSBkb24ndCB3YW50XG4gICAgLy8gdG8gaW5jbHVkZSBpdHMgZnVsbCBzaXplIGluIHRoZSBjYWxjdWxhdGlvbi4gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbFxuICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXG4gICAgLy8gcmVmZXJlbmNlIGlzIG5vdCBvdmVyZmxvd2luZyBhcyB3ZWxsIChlLmcuIHZpcnR1YWwgZWxlbWVudHMgd2l0aCBub1xuICAgIC8vIHdpZHRoIG9yIGhlaWdodClcblxuICAgIHZhciBhcnJvd0xlbiA9IHdpdGhpbigwLCByZWZlcmVuY2VSZWN0W2xlbl0sIGFycm93UmVjdFtsZW5dKTtcbiAgICB2YXIgbWluT2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiAtIGFkZGl0aXZlIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtaW5MZW4gLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgKyBhZGRpdGl2ZSArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWF4TGVuICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3cgJiYgZ2V0T2Zmc2V0UGFyZW50KHN0YXRlLmVsZW1lbnRzLmFycm93KTtcbiAgICB2YXIgY2xpZW50T2Zmc2V0ID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBtYWluQXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50VG9wIHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRMZWZ0IHx8IDAgOiAwO1xuICAgIHZhciBvZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJCA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbbWFpbkF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkIDogMDtcbiAgICB2YXIgdGV0aGVyTWluID0gb2Zmc2V0ICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcbiAgICB2YXIgdGV0aGVyTWF4ID0gb2Zmc2V0ICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcbiAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IG1hdGhNaW4obWluLCB0ZXRoZXJNaW4pIDogbWluLCBvZmZzZXQsIHRldGhlciA/IG1hdGhNYXgobWF4LCB0ZXRoZXJNYXgpIDogbWF4KTtcbiAgICBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcbiAgfVxuXG4gIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkMjtcblxuICAgIHZhciBfbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gdG9wIDogbGVmdDtcblxuICAgIHZhciBfYWx0U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBib3R0b20gOiByaWdodDtcblxuICAgIHZhciBfb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1thbHRBeGlzXTtcblxuICAgIHZhciBfbGVuID0gYWx0QXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcblxuICAgIHZhciBfbWF4ID0gX29mZnNldCAtIG92ZXJmbG93W19hbHRTaWRlXTtcblxuICAgIHZhciBpc09yaWdpblNpZGUgPSBbdG9wLCBsZWZ0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVthbHRBeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJDIgOiAwO1xuXG4gICAgdmFyIF90ZXRoZXJNaW4gPSBpc09yaWdpblNpZGUgPyBfbWluIDogX29mZnNldCAtIHJlZmVyZW5jZVJlY3RbX2xlbl0gLSBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcztcblxuICAgIHZhciBfdGV0aGVyTWF4ID0gaXNPcmlnaW5TaWRlID8gX29mZnNldCArIHJlZmVyZW5jZVJlY3RbX2xlbl0gKyBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcyA6IF9tYXg7XG5cbiAgICB2YXIgX3ByZXZlbnRlZE9mZnNldCA9IHRldGhlciAmJiBpc09yaWdpblNpZGUgPyB3aXRoaW5NYXhDbGFtcChfdGV0aGVyTWluLCBfb2Zmc2V0LCBfdGV0aGVyTWF4KSA6IHdpdGhpbih0ZXRoZXIgPyBfdGV0aGVyTWluIDogX21pbiwgX29mZnNldCwgdGV0aGVyID8gX3RldGhlck1heCA6IF9tYXgpO1xuXG4gICAgcG9wcGVyT2Zmc2V0c1thbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogcHJldmVudE92ZXJmbG93LFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddXG59OyIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRIVE1MRWxlbWVudFNjcm9sbChlbGVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgfTtcbn0iLCAiaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEhUTUxFbGVtZW50U2Nyb2xsIGZyb20gXCIuL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlU2Nyb2xsKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IGdldFdpbmRvdyhub2RlKSB8fCAhaXNIVE1MRWxlbWVudChub2RlKSkge1xuICAgIHJldHVybiBnZXRXaW5kb3dTY3JvbGwobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50U2Nyb2xsKG5vZGUpO1xuICB9XG59IiwgImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZVNjcm9sbCBmcm9tIFwiLi9nZXROb2RlU2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudFNjYWxlZChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IHJvdW5kKHJlY3Qud2lkdGgpIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxO1xuICB2YXIgc2NhbGVZID0gcm91bmQocmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMTtcbiAgcmV0dXJuIHNjYWxlWCAhPT0gMSB8fCBzY2FsZVkgIT09IDE7XG59IC8vIFJldHVybnMgdGhlIGNvbXBvc2l0ZSByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC5cbi8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb21wb3NpdGVSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnQsIGlzRml4ZWQpIHtcbiAgaWYgKGlzRml4ZWQgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudElzU2NhbGVkID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzRWxlbWVudFNjYWxlZChvZmZzZXRQYXJlbnQpO1xuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnRJc1NjYWxlZCwgaXNGaXhlZCk7XG4gIHZhciBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgdmFyIG9mZnNldHMgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XG4gICAgaXNTY3JvbGxQYXJlbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIG9mZnNldHMgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlKTtcbiAgICAgIG9mZnNldHMueCArPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSArPSBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufSIsICJpbXBvcnQgeyBtb2RpZmllclBoYXNlcyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBzb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5ODc1MjU1XG5cbmZ1bmN0aW9uIG9yZGVyKG1vZGlmaWVycykge1xuICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBtYXAuc2V0KG1vZGlmaWVyLm5hbWUsIG1vZGlmaWVyKTtcbiAgfSk7IC8vIE9uIHZpc2l0aW5nIG9iamVjdCwgY2hlY2sgZm9yIGl0cyBkZXBlbmRlbmNpZXMgYW5kIHZpc2l0IHRoZW0gcmVjdXJzaXZlbHlcblxuICBmdW5jdGlvbiBzb3J0KG1vZGlmaWVyKSB7XG4gICAgdmlzaXRlZC5hZGQobW9kaWZpZXIubmFtZSk7XG4gICAgdmFyIHJlcXVpcmVzID0gW10uY29uY2F0KG1vZGlmaWVyLnJlcXVpcmVzIHx8IFtdLCBtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKTtcbiAgICByZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMoZGVwKSkge1xuICAgICAgICB2YXIgZGVwTW9kaWZpZXIgPSBtYXAuZ2V0KGRlcCk7XG5cbiAgICAgICAgaWYgKGRlcE1vZGlmaWVyKSB7XG4gICAgICAgICAgc29ydChkZXBNb2RpZmllcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN1bHQucHVzaChtb2RpZmllcik7XG4gIH1cblxuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAoIXZpc2l0ZWQuaGFzKG1vZGlmaWVyLm5hbWUpKSB7XG4gICAgICAvLyBjaGVjayBmb3IgdmlzaXRlZCBvYmplY3RcbiAgICAgIHNvcnQobW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9yZGVyTW9kaWZpZXJzKG1vZGlmaWVycykge1xuICAvLyBvcmRlciBiYXNlZCBvbiBkZXBlbmRlbmNpZXNcbiAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcihtb2RpZmllcnMpOyAvLyBvcmRlciBiYXNlZCBvbiBwaGFzZVxuXG4gIHJldHVybiBtb2RpZmllclBoYXNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGhhc2UpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgIHJldHVybiBtb2RpZmllci5waGFzZSA9PT0gcGhhc2U7XG4gICAgfSkpO1xuICB9LCBbXSk7XG59IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlYm91bmNlKGZuKSB7XG4gIHZhciBwZW5kaW5nO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBlbmRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVzb2x2ZShmbigpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGVuZGluZztcbiAgfTtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VCeU5hbWUobW9kaWZpZXJzKSB7XG4gIHZhciBtZXJnZWQgPSBtb2RpZmllcnMucmVkdWNlKGZ1bmN0aW9uIChtZXJnZWQsIGN1cnJlbnQpIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBtZXJnZWRbY3VycmVudC5uYW1lXTtcbiAgICBtZXJnZWRbY3VycmVudC5uYW1lXSA9IGV4aXN0aW5nID8gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcsIGN1cnJlbnQsIHtcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLm9wdGlvbnMsIGN1cnJlbnQub3B0aW9ucyksXG4gICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5kYXRhLCBjdXJyZW50LmRhdGEpXG4gICAgfSkgOiBjdXJyZW50O1xuICAgIHJldHVybiBtZXJnZWQ7XG4gIH0sIHt9KTsgLy8gSUUxMSBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC52YWx1ZXNcblxuICByZXR1cm4gT2JqZWN0LmtleXMobWVyZ2VkKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBtZXJnZWRba2V5XTtcbiAgfSk7XG59IiwgImltcG9ydCBnZXRDb21wb3NpdGVSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gXCIuL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgb3JkZXJNb2RpZmllcnMgZnJvbSBcIi4vdXRpbHMvb3JkZXJNb2RpZmllcnMuanNcIjtcbmltcG9ydCBkZWJvdW5jZSBmcm9tIFwiLi91dGlscy9kZWJvdW5jZS5qc1wiO1xuaW1wb3J0IG1lcmdlQnlOYW1lIGZyb20gXCIuL3V0aWxzL21lcmdlQnlOYW1lLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICBtb2RpZmllcnM6IFtdLFxuICBzdHJhdGVneTogJ2Fic29sdXRlJ1xufTtcblxuZnVuY3Rpb24gYXJlVmFsaWRFbGVtZW50cygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiAhYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuICEoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbicpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcHBlckdlbmVyYXRvcihnZW5lcmF0b3JPcHRpb25zKSB7XG4gIGlmIChnZW5lcmF0b3JPcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBnZW5lcmF0b3JPcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX2dlbmVyYXRvck9wdGlvbnMgPSBnZW5lcmF0b3JPcHRpb25zLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE1vZGlmaWVycyxcbiAgICAgIGRlZmF1bHRNb2RpZmllcnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPT09IHZvaWQgMCA/IFtdIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRPcHRpb25zLFxuICAgICAgZGVmYXVsdE9wdGlvbnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID09PSB2b2lkIDAgPyBERUZBVUxUX09QVElPTlMgOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgZGVmYXVsdE9wdGlvbnMpLFxuICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2U6IHJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyOiBwb3BwZXJcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9O1xuICAgIHZhciBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgdmFyIGlzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgdmFyIGluc3RhbmNlID0ge1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gc2V0T3B0aW9ucyhzZXRPcHRpb25zQWN0aW9uKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHNldE9wdGlvbnNBY3Rpb24gPT09ICdmdW5jdGlvbicgPyBzZXRPcHRpb25zQWN0aW9uKHN0YXRlLm9wdGlvbnMpIDogc2V0T3B0aW9uc0FjdGlvbjtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBzdGF0ZS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIHN0YXRlLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogaXNFbGVtZW50KHJlZmVyZW5jZSkgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UpIDogcmVmZXJlbmNlLmNvbnRleHRFbGVtZW50ID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogbGlzdFNjcm9sbFBhcmVudHMocG9wcGVyKVxuICAgICAgICB9OyAvLyBPcmRlcnMgdGhlIG1vZGlmaWVycyBiYXNlZCBvbiB0aGVpciBkZXBlbmRlbmNpZXMgYW5kIGBwaGFzZWBcbiAgICAgICAgLy8gcHJvcGVydGllc1xuXG4gICAgICAgIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJNb2RpZmllcnMobWVyZ2VCeU5hbWUoW10uY29uY2F0KGRlZmF1bHRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSkpOyAvLyBTdHJpcCBvdXQgZGlzYWJsZWQgbW9kaWZpZXJzXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG0uZW5hYmxlZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJ1bk1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9LFxuICAgICAgLy8gU3luYyB1cGRhdGUgXHUyMDEzIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcbiAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcbiAgICAgIC8vIGxvZ2ljLlxuICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xuICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxuICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICBpZiAoaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N0YXRlJGVsZW1lbnRzID0gc3RhdGUuZWxlbWVudHMsXG4gICAgICAgICAgICByZWZlcmVuY2UgPSBfc3RhdGUkZWxlbWVudHMucmVmZXJlbmNlLFxuICAgICAgICAgICAgcG9wcGVyID0gX3N0YXRlJGVsZW1lbnRzLnBvcHBlcjsgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXG4gICAgICAgIC8vIGFueW1vcmVcblxuICAgICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgYW5kIHBvcHBlciByZWN0cyB0byBiZSByZWFkIGJ5IG1vZGlmaWVyc1xuXG5cbiAgICAgICAgc3RhdGUucmVjdHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBnZXRDb21wb3NpdGVSZWN0KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KHBvcHBlciksIHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCcpLFxuICAgICAgICAgIHBvcHBlcjogZ2V0TGF5b3V0UmVjdChwb3BwZXIpXG4gICAgICAgIH07IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIHJlc2V0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZS4gVGhlXG4gICAgICAgIC8vIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRoZSBgZmxpcGAgbW9kaWZpZXIgY2hhbmdpbmcgdGhlXG4gICAgICAgIC8vIHBsYWNlbWVudCwgd2hpY2ggdGhlbiBuZWVkcyB0byByZS1ydW4gYWxsIHRoZSBtb2RpZmllcnMsIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIGxvZ2ljIHdhcyBwcmV2aW91c2x5IHJhbiBmb3IgdGhlIHByZXZpb3VzIHBsYWNlbWVudCBhbmQgaXMgdGhlcmVmb3JlXG4gICAgICAgIC8vIHN0YWxlL2luY29ycmVjdFxuXG4gICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50OyAvLyBPbiBlYWNoIHVwZGF0ZSBjeWNsZSwgdGhlIGBtb2RpZmllcnNEYXRhYCBwcm9wZXJ0eSBmb3IgZWFjaCBtb2RpZmllclxuICAgICAgICAvLyBpcyBmaWxsZWQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhIHNwZWNpZmllZCBieSB0aGUgbW9kaWZpZXIuIFRoaXMgbWVhbnNcbiAgICAgICAgLy8gaXQgZG9lc24ndCBwZXJzaXN0IGFuZCBpcyBmcmVzaCBvbiBlYWNoIHVwZGF0ZS5cbiAgICAgICAgLy8gVG8gZW5zdXJlIHBlcnNpc3RlbnQgZGF0YSwgdXNlIGAke25hbWV9I3BlcnNpc3RlbnRgXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5tb2RpZmllcnNEYXRhW21vZGlmaWVyLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgbW9kaWZpZXIuZGF0YSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGlmIChzdGF0ZS5yZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3N0YXRlJG9yZGVyZWRNb2RpZmllID0gc3RhdGUub3JkZXJlZE1vZGlmaWVyc1tpbmRleF0sXG4gICAgICAgICAgICAgIGZuID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLmZuLFxuICAgICAgICAgICAgICBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm9wdGlvbnMsXG4gICAgICAgICAgICAgIF9vcHRpb25zID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9PT0gdm9pZCAwID8ge30gOiBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyLFxuICAgICAgICAgICAgICBuYW1lID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm5hbWU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGZuKHtcbiAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICBvcHRpb25zOiBfb3B0aW9ucyxcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlXG4gICAgICAgICAgICB9KSB8fCBzdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBc3luYyBhbmQgb3B0aW1pc3RpY2FsbHkgb3B0aW1pemVkIHVwZGF0ZSBcdTIwMTMgaXQgd2lsbCBub3QgYmUgZXhlY3V0ZWQgaWZcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgKGRlYm91bmNlZCB0byBydW4gYXQgbW9zdCBvbmNlLXBlci10aWNrKVxuICAgICAgdXBkYXRlOiBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgcmVzb2x2ZShzdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIGlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucykudGhlbihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmICghaXNEZXN0cm95ZWQgJiYgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIG9wdGlvbnMub25GaXJzdFVwZGF0ZShzdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgYmVmb3JlIHRoZSBmaXJzdFxuICAgIC8vIHVwZGF0ZSBjeWNsZSBydW5zLiBUaGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHVwZGF0ZVxuICAgIC8vIGN5Y2xlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbW9kaWZpZXIgYWRkcyBzb21lIHBlcnNpc3RlbnQgZGF0YSB0aGF0XG4gICAgLy8gb3RoZXIgbW9kaWZpZXJzIG5lZWQgdG8gdXNlLCBidXQgdGhlIG1vZGlmaWVyIGlzIHJ1biBhZnRlciB0aGUgZGVwZW5kZW50XG4gICAgLy8gb25lLlxuXG4gICAgZnVuY3Rpb24gcnVuTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICAgICAgX3JlZiRvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9ucyA9IF9yZWYkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmJG9wdGlvbnMsXG4gICAgICAgICAgICBlZmZlY3QgPSBfcmVmLmVmZmVjdDtcblxuICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjbGVhbnVwRm4gPSBlZmZlY3Qoe1xuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBub29wRm4gPSBmdW5jdGlvbiBub29wRm4oKSB7fTtcblxuICAgICAgICAgIGVmZmVjdENsZWFudXBGbnMucHVzaChjbGVhbnVwRm4gfHwgbm9vcEZuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9KTtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59XG5leHBvcnQgdmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3IoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBkZXRlY3RPdmVyZmxvdyB9OyIsICJpbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7XG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tIFwiLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcIjtcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcIjtcbmltcG9ydCBvZmZzZXQgZnJvbSBcIi4vbW9kaWZpZXJzL29mZnNldC5qc1wiO1xuaW1wb3J0IGZsaXAgZnJvbSBcIi4vbW9kaWZpZXJzL2ZsaXAuanNcIjtcbmltcG9ydCBwcmV2ZW50T3ZlcmZsb3cgZnJvbSBcIi4vbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGFycm93IGZyb20gXCIuL21vZGlmaWVycy9hcnJvdy5qc1wiO1xuaW1wb3J0IGhpZGUgZnJvbSBcIi4vbW9kaWZpZXJzL2hpZGUuanNcIjtcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzLCBjb21wdXRlU3R5bGVzLCBhcHBseVN0eWxlcywgb2Zmc2V0LCBmbGlwLCBwcmV2ZW50T3ZlcmZsb3csIGFycm93LCBoaWRlXTtcbnZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVyc1xufSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyLCBwb3BwZXJHZW5lcmF0b3IsIGRlZmF1bHRNb2RpZmllcnMsIGRldGVjdE92ZXJmbG93IH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyIGFzIGNyZWF0ZVBvcHBlckxpdGUgfSBmcm9tIFwiLi9wb3BwZXItbGl0ZS5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCAqIGZyb20gXCIuL21vZGlmaWVycy9pbmRleC5qc1wiOyIsICJleHBvcnQgY29uc3QgUk9VTkRfQVJST1cgPVxuICAnPHN2ZyB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTAgNnMxLjc5Ni0uMDEzIDQuNjctMy42MTVDNS44NTEuOSA2LjkzLjAwNiA4IDBjMS4wNy0uMDA2IDIuMTQ4Ljg4NyAzLjM0MyAyLjM4NUMxNC4yMzMgNi4wMDUgMTYgNiAxNiA2SDB6XCI+PC9zdmc+JztcblxuZXhwb3J0IGNvbnN0IEJPWF9DTEFTUyA9IGBfX05BTUVTUEFDRV9QUkVGSVhfXy1ib3hgO1xuZXhwb3J0IGNvbnN0IENPTlRFTlRfQ0xBU1MgPSBgX19OQU1FU1BBQ0VfUFJFRklYX18tY29udGVudGA7XG5leHBvcnQgY29uc3QgQkFDS0RST1BfQ0xBU1MgPSBgX19OQU1FU1BBQ0VfUFJFRklYX18tYmFja2Ryb3BgO1xuZXhwb3J0IGNvbnN0IEFSUk9XX0NMQVNTID0gYF9fTkFNRVNQQUNFX1BSRUZJWF9fLWFycm93YDtcbmV4cG9ydCBjb25zdCBTVkdfQVJST1dfQ0xBU1MgPSBgX19OQU1FU1BBQ0VfUFJFRklYX18tc3ZnLWFycm93YDtcblxuZXhwb3J0IGNvbnN0IFRPVUNIX09QVElPTlMgPSB7cGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZX07XG5cbmV4cG9ydCBjb25zdCBUSVBQWV9ERUZBVUxUX0FQUEVORF9UTyA9ICgpID0+IGRvY3VtZW50LmJvZHk7XG4iLCAiaW1wb3J0IHtCYXNlUGxhY2VtZW50LCBQbGFjZW1lbnR9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaGFzT3duUHJvcGVydHkoXG4gIG9iajogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIGtleTogc3RyaW5nXG4pOiBib29sZWFuIHtcbiAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm48VD4oXG4gIHZhbHVlOiBUIHwgW1QgfCBudWxsLCBUIHwgbnVsbF0sXG4gIGluZGV4OiBudW1iZXIsXG4gIGRlZmF1bHRWYWx1ZTogVCB8IFtULCBUXVxuKTogVCB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IHYgPSB2YWx1ZVtpbmRleF07XG4gICAgcmV0dXJuIHYgPT0gbnVsbFxuICAgICAgPyBBcnJheS5pc0FycmF5KGRlZmF1bHRWYWx1ZSlcbiAgICAgICAgPyBkZWZhdWx0VmFsdWVbaW5kZXhdXG4gICAgICAgIDogZGVmYXVsdFZhbHVlXG4gICAgICA6IHY7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1R5cGUodmFsdWU6IGFueSwgdHlwZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IHN0ciA9IHt9LnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICByZXR1cm4gc3RyLmluZGV4T2YoJ1tvYmplY3QnKSA9PT0gMCAmJiBzdHIuaW5kZXhPZihgJHt0eXBlfV1gKSA+IC0xO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlV2l0aEFyZ3NPclJldHVybih2YWx1ZTogYW55LCBhcmdzOiBhbnlbXSk6IGFueSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZSguLi5hcmdzKSA6IHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2U8VD4oXG4gIGZuOiAoYXJnOiBUKSA9PiB2b2lkLFxuICBtczogbnVtYmVyXG4pOiAoYXJnOiBUKSA9PiB2b2lkIHtcbiAgLy8gQXZvaWQgd3JhcHBpbmcgaW4gYHNldFRpbWVvdXRgIGlmIG1zIGlzIDAgYW55d2F5XG4gIGlmIChtcyA9PT0gMCkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGxldCB0aW1lb3V0OiBhbnk7XG5cbiAgcmV0dXJuIChhcmcpOiB2b2lkID0+IHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZm4oYXJnKTtcbiAgICB9LCBtcyk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQcm9wZXJ0aWVzPFQ+KG9iajogVCwga2V5czogc3RyaW5nW10pOiBQYXJ0aWFsPFQ+IHtcbiAgY29uc3QgY2xvbmUgPSB7Li4ub2JqfTtcbiAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBkZWxldGUgKGNsb25lIGFzIGFueSlba2V5XTtcbiAgfSk7XG4gIHJldHVybiBjbG9uZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0QnlTcGFjZXModmFsdWU6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KC9cXHMrLykuZmlsdGVyKEJvb2xlYW4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheTxUPih2YWx1ZTogVCB8IFRbXSk6IFRbXSB7XG4gIHJldHVybiAoW10gYXMgVFtdKS5jb25jYXQodmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHVzaElmVW5pcXVlPFQ+KGFycjogVFtdLCB2YWx1ZTogVCk6IHZvaWQge1xuICBpZiAoYXJyLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgIGFyci5wdXNoKHZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kUHhJZk51bWJlcih2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyBgJHt2YWx1ZX1weGAgOiB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuaXF1ZTxUPihhcnI6IFRbXSk6IFRbXSB7XG4gIHJldHVybiBhcnIuZmlsdGVyKChpdGVtLCBpbmRleCkgPT4gYXJyLmluZGV4T2YoaXRlbSkgPT09IGluZGV4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE51bWJlcih2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyB2YWx1ZSA6IHBhcnNlRmxvYXQodmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQ6IFBsYWNlbWVudCk6IEJhc2VQbGFjZW1lbnQge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF0gYXMgQmFzZVBsYWNlbWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5RnJvbSh2YWx1ZTogQXJyYXlMaWtlPGFueT4pOiBhbnlbXSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVVuZGVmaW5lZFByb3BzKFxuICBvYmo6IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4pOiBQYXJ0aWFsPFJlY29yZDxzdHJpbmcsIHVua25vd24+PiB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBpZiAob2JqW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgKGFjYyBhcyBhbnkpW2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG4iLCAiaW1wb3J0IHtSZWZlcmVuY2VFbGVtZW50LCBUYXJnZXRzfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7UG9wcGVyVHJlZURhdGF9IGZyb20gJy4vdHlwZXMtaW50ZXJuYWwnO1xuaW1wb3J0IHthcnJheUZyb20sIGlzVHlwZSwgbm9ybWFsaXplVG9BcnJheSwgZ2V0QmFzZVBsYWNlbWVudH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXYoKTogSFRNTERpdkVsZW1lbnQge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBFbGVtZW50IHwgRG9jdW1lbnRGcmFnbWVudCB7XG4gIHJldHVybiBbJ0VsZW1lbnQnLCAnRnJhZ21lbnQnXS5zb21lKCh0eXBlKSA9PiBpc1R5cGUodmFsdWUsIHR5cGUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZUxpc3QodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBOb2RlTGlzdCB7XG4gIHJldHVybiBpc1R5cGUodmFsdWUsICdOb2RlTGlzdCcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNNb3VzZUV2ZW50KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgTW91c2VFdmVudCB7XG4gIHJldHVybiBpc1R5cGUodmFsdWUsICdNb3VzZUV2ZW50Jyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlZmVyZW5jZUVsZW1lbnQodmFsdWU6IGFueSk6IHZhbHVlIGlzIFJlZmVyZW5jZUVsZW1lbnQge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX3RpcHB5ICYmIHZhbHVlLl90aXBweS5yZWZlcmVuY2UgPT09IHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFycmF5T2ZFbGVtZW50cyh2YWx1ZTogVGFyZ2V0cyk6IEVsZW1lbnRbXSB7XG4gIGlmIChpc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgcmV0dXJuIFt2YWx1ZV07XG4gIH1cblxuICBpZiAoaXNOb2RlTGlzdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gYXJyYXlGcm9tKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBhcnJheUZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkR1cmF0aW9uKFxuICBlbHM6IChIVE1MRGl2RWxlbWVudCB8IG51bGwpW10sXG4gIHZhbHVlOiBudW1iZXJcbik6IHZvaWQge1xuICBlbHMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke3ZhbHVlfW1zYDtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0VmlzaWJpbGl0eVN0YXRlKFxuICBlbHM6IChIVE1MRGl2RWxlbWVudCB8IG51bGwpW10sXG4gIHN0YXRlOiAndmlzaWJsZScgfCAnaGlkZGVuJ1xuKTogdm9pZCB7XG4gIGVscy5mb3JFYWNoKChlbCkgPT4ge1xuICAgIGlmIChlbCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLXN0YXRlJywgc3RhdGUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPd25lckRvY3VtZW50KFxuICBlbGVtZW50T3JFbGVtZW50czogRWxlbWVudCB8IEVsZW1lbnRbXVxuKTogRG9jdW1lbnQge1xuICBjb25zdCBbZWxlbWVudF0gPSBub3JtYWxpemVUb0FycmF5KGVsZW1lbnRPckVsZW1lbnRzKTtcblxuICAvLyBFbGVtZW50cyBjcmVhdGVkIHZpYSBhIDx0ZW1wbGF0ZT4gaGF2ZSBhbiBvd25lckRvY3VtZW50IHdpdGggbm8gcmVmZXJlbmNlIHRvIHRoZSBib2R5XG4gIHJldHVybiBlbGVtZW50Py5vd25lckRvY3VtZW50Py5ib2R5ID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogZG9jdW1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0N1cnNvck91dHNpZGVJbnRlcmFjdGl2ZUJvcmRlcihcbiAgcG9wcGVyVHJlZURhdGE6IFBvcHBlclRyZWVEYXRhW10sXG4gIGV2ZW50OiBNb3VzZUV2ZW50XG4pOiBib29sZWFuIHtcbiAgY29uc3Qge2NsaWVudFgsIGNsaWVudFl9ID0gZXZlbnQ7XG5cbiAgcmV0dXJuIHBvcHBlclRyZWVEYXRhLmV2ZXJ5KCh7cG9wcGVyUmVjdCwgcG9wcGVyU3RhdGUsIHByb3BzfSkgPT4ge1xuICAgIGNvbnN0IHtpbnRlcmFjdGl2ZUJvcmRlcn0gPSBwcm9wcztcbiAgICBjb25zdCBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwb3BwZXJTdGF0ZS5wbGFjZW1lbnQpO1xuICAgIGNvbnN0IG9mZnNldERhdGEgPSBwb3BwZXJTdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDtcblxuICAgIGlmICghb2Zmc2V0RGF0YSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgdG9wRGlzdGFuY2UgPSBiYXNlUGxhY2VtZW50ID09PSAnYm90dG9tJyA/IG9mZnNldERhdGEudG9wIS55IDogMDtcbiAgICBjb25zdCBib3R0b21EaXN0YW5jZSA9IGJhc2VQbGFjZW1lbnQgPT09ICd0b3AnID8gb2Zmc2V0RGF0YS5ib3R0b20hLnkgOiAwO1xuICAgIGNvbnN0IGxlZnREaXN0YW5jZSA9IGJhc2VQbGFjZW1lbnQgPT09ICdyaWdodCcgPyBvZmZzZXREYXRhLmxlZnQhLnggOiAwO1xuICAgIGNvbnN0IHJpZ2h0RGlzdGFuY2UgPSBiYXNlUGxhY2VtZW50ID09PSAnbGVmdCcgPyBvZmZzZXREYXRhLnJpZ2h0IS54IDogMDtcblxuICAgIGNvbnN0IGV4Y2VlZHNUb3AgPVxuICAgICAgcG9wcGVyUmVjdC50b3AgLSBjbGllbnRZICsgdG9wRGlzdGFuY2UgPiBpbnRlcmFjdGl2ZUJvcmRlcjtcbiAgICBjb25zdCBleGNlZWRzQm90dG9tID1cbiAgICAgIGNsaWVudFkgLSBwb3BwZXJSZWN0LmJvdHRvbSAtIGJvdHRvbURpc3RhbmNlID4gaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgY29uc3QgZXhjZWVkc0xlZnQgPVxuICAgICAgcG9wcGVyUmVjdC5sZWZ0IC0gY2xpZW50WCArIGxlZnREaXN0YW5jZSA+IGludGVyYWN0aXZlQm9yZGVyO1xuICAgIGNvbnN0IGV4Y2VlZHNSaWdodCA9XG4gICAgICBjbGllbnRYIC0gcG9wcGVyUmVjdC5yaWdodCAtIHJpZ2h0RGlzdGFuY2UgPiBpbnRlcmFjdGl2ZUJvcmRlcjtcblxuICAgIHJldHVybiBleGNlZWRzVG9wIHx8IGV4Y2VlZHNCb3R0b20gfHwgZXhjZWVkc0xlZnQgfHwgZXhjZWVkc1JpZ2h0O1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcihcbiAgYm94OiBIVE1MRGl2RWxlbWVudCxcbiAgYWN0aW9uOiAnYWRkJyB8ICdyZW1vdmUnLFxuICBsaXN0ZW5lcjogKGV2ZW50OiBUcmFuc2l0aW9uRXZlbnQpID0+IHZvaWRcbik6IHZvaWQge1xuICBjb25zdCBtZXRob2QgPSBgJHthY3Rpb259RXZlbnRMaXN0ZW5lcmAgYXNcbiAgICB8ICdhZGRFdmVudExpc3RlbmVyJ1xuICAgIHwgJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuXG4gIC8vIHNvbWUgYnJvd3NlcnMgYXBwYXJlbnRseSBzdXBwb3J0IGB0cmFuc2l0aW9uYCAodW5wcmVmaXhlZCkgYnV0IG9ubHkgZmlyZVxuICAvLyBgd2Via2l0VHJhbnNpdGlvbkVuZGAuLi5cbiAgWyd0cmFuc2l0aW9uZW5kJywgJ3dlYmtpdFRyYW5zaXRpb25FbmQnXS5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgIGJveFttZXRob2RdKGV2ZW50LCBsaXN0ZW5lciBhcyBFdmVudExpc3RlbmVyKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29tcGFyZWQgdG8geHh4LmNvbnRhaW5zLCB0aGlzIGZ1bmN0aW9uIHdvcmtzIGZvciBkb20gc3RydWN0dXJlcyB3aXRoIHNoYWRvd1xuICogZG9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhY3R1YWxDb250YWlucyhwYXJlbnQ6IEVsZW1lbnQsIGNoaWxkOiBFbGVtZW50KTogYm9vbGVhbiB7XG4gIGxldCB0YXJnZXQgPSBjaGlsZDtcbiAgd2hpbGUgKHRhcmdldCkge1xuICAgIGlmIChwYXJlbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRhcmdldCA9ICh0YXJnZXQuZ2V0Um9vdE5vZGU/LigpIGFzIGFueSk/Lmhvc3Q7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwgImltcG9ydCB7VE9VQ0hfT1BUSU9OU30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtpc1JlZmVyZW5jZUVsZW1lbnR9IGZyb20gJy4vZG9tLXV0aWxzJztcblxuZXhwb3J0IGNvbnN0IGN1cnJlbnRJbnB1dCA9IHtpc1RvdWNoOiBmYWxzZX07XG5sZXQgbGFzdE1vdXNlTW92ZVRpbWUgPSAwO1xuXG4vKipcbiAqIFdoZW4gYSBgdG91Y2hzdGFydGAgZXZlbnQgaXMgZmlyZWQsIGl0J3MgYXNzdW1lZCB0aGUgdXNlciBpcyB1c2luZyB0b3VjaFxuICogaW5wdXQuIFdlJ2xsIGJpbmQgYSBgbW91c2Vtb3ZlYCBldmVudCBsaXN0ZW5lciB0byBsaXN0ZW4gZm9yIG1vdXNlIGlucHV0IGluXG4gKiB0aGUgZnV0dXJlLiBUaGlzIHdheSwgdGhlIGBpc1RvdWNoYCBwcm9wZXJ0eSBpcyBmdWxseSBkeW5hbWljIGFuZCB3aWxsIGhhbmRsZVxuICogaHlicmlkIGRldmljZXMgdGhhdCB1c2UgYSBtaXggb2YgdG91Y2ggKyBtb3VzZSBpbnB1dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uRG9jdW1lbnRUb3VjaFN0YXJ0KCk6IHZvaWQge1xuICBpZiAoY3VycmVudElucHV0LmlzVG91Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdXJyZW50SW5wdXQuaXNUb3VjaCA9IHRydWU7XG5cbiAgaWYgKHdpbmRvdy5wZXJmb3JtYW5jZSkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uRG9jdW1lbnRNb3VzZU1vdmUpO1xuICB9XG59XG5cbi8qKlxuICogV2hlbiB0d28gYG1vdXNlbW92ZWAgZXZlbnQgYXJlIGZpcmVkIGNvbnNlY3V0aXZlbHkgd2l0aGluIDIwbXMsIGl0J3MgYXNzdW1lZFxuICogdGhlIHVzZXIgaXMgdXNpbmcgbW91c2UgaW5wdXQgYWdhaW4uIGBtb3VzZW1vdmVgIGNhbiBmaXJlIG9uIHRvdWNoIGRldmljZXMgYXNcbiAqIHdlbGwsIGJ1dCB2ZXJ5IHJhcmVseSB0aGF0IHF1aWNrbHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbkRvY3VtZW50TW91c2VNb3ZlKCk6IHZvaWQge1xuICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICBpZiAobm93IC0gbGFzdE1vdXNlTW92ZVRpbWUgPCAyMCkge1xuICAgIGN1cnJlbnRJbnB1dC5pc1RvdWNoID0gZmFsc2U7XG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbkRvY3VtZW50TW91c2VNb3ZlKTtcbiAgfVxuXG4gIGxhc3RNb3VzZU1vdmVUaW1lID0gbm93O1xufVxuXG4vKipcbiAqIFdoZW4gYW4gZWxlbWVudCBpcyBpbiBmb2N1cyBhbmQgaGFzIGEgdGlwcHksIGxlYXZpbmcgdGhlIHRhYi93aW5kb3cgYW5kXG4gKiByZXR1cm5pbmcgY2F1c2VzIGl0IHRvIHNob3cgYWdhaW4uIEZvciBtb3VzZSB1c2VycyB0aGlzIGlzIHVuZXhwZWN0ZWQsIGJ1dFxuICogZm9yIGtleWJvYXJkIHVzZSBpdCBtYWtlcyBzZW5zZS5cbiAqIFRPRE86IGZpbmQgYSBiZXR0ZXIgdGVjaG5pcXVlIHRvIHNvbHZlIHRoaXMgcHJvYmxlbVxuICovXG5leHBvcnQgZnVuY3Rpb24gb25XaW5kb3dCbHVyKCk6IHZvaWQge1xuICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudCB8IG51bGw7XG5cbiAgaWYgKGlzUmVmZXJlbmNlRWxlbWVudChhY3RpdmVFbGVtZW50KSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gYWN0aXZlRWxlbWVudC5fdGlwcHkhO1xuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQuYmx1ciAmJiAhaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmluZEdsb2JhbEV2ZW50TGlzdGVuZXJzKCk6IHZvaWQge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Eb2N1bWVudFRvdWNoU3RhcnQsIFRPVUNIX09QVElPTlMpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIG9uV2luZG93Qmx1cik7XG59XG4iLCAiZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9XG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmV4cG9ydCBjb25zdCBpc0lFMTEgPSBpc0Jyb3dzZXJcbiAgPyAvLyBAdHMtaWdub3JlXG4gICAgISF3aW5kb3cubXNDcnlwdG9cbiAgOiBmYWxzZTtcbiIsICJpbXBvcnQge1RhcmdldHN9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcobWV0aG9kOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCB0eHQgPSBtZXRob2QgPT09ICdkZXN0cm95JyA/ICduIGFscmVhZHktJyA6ICcgJztcblxuICByZXR1cm4gW1xuICAgIGAke21ldGhvZH0oKSB3YXMgY2FsbGVkIG9uIGEke3R4dH1kZXN0cm95ZWQgaW5zdGFuY2UuIFRoaXMgaXMgYSBuby1vcCBidXRgLFxuICAgICdpbmRpY2F0ZXMgYSBwb3RlbnRpYWwgbWVtb3J5IGxlYWsuJyxcbiAgXS5qb2luKCcgJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbih2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3Qgc3BhY2VzQW5kVGFicyA9IC9bIFxcdF17Mix9L2c7XG4gIGNvbnN0IGxpbmVTdGFydFdpdGhTcGFjZXMgPSAvXlsgXFx0XSovZ207XG5cbiAgcmV0dXJuIHZhbHVlXG4gICAgLnJlcGxhY2Uoc3BhY2VzQW5kVGFicywgJyAnKVxuICAgIC5yZXBsYWNlKGxpbmVTdGFydFdpdGhTcGFjZXMsICcnKVxuICAgIC50cmltKCk7XG59XG5cbmZ1bmN0aW9uIGdldERldk1lc3NhZ2UobWVzc2FnZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGNsZWFuKGBcbiAgJWN0aXBweS5qc1xuXG4gICVjJHtjbGVhbihtZXNzYWdlKX1cblxuICAlY/CfkbfigI0gVGhpcyBpcyBhIGRldmVsb3BtZW50LW9ubHkgbWVzc2FnZS4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHByb2R1Y3Rpb24uXG4gIGApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9ybWF0dGVkTWVzc2FnZShtZXNzYWdlOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIHJldHVybiBbXG4gICAgZ2V0RGV2TWVzc2FnZShtZXNzYWdlKSxcbiAgICAvLyB0aXRsZVxuICAgICdjb2xvcjogIzAwQzU4NDsgZm9udC1zaXplOiAxLjNlbTsgZm9udC13ZWlnaHQ6IGJvbGQ7JyxcbiAgICAvLyBtZXNzYWdlXG4gICAgJ2xpbmUtaGVpZ2h0OiAxLjUnLFxuICAgIC8vIGZvb3RlclxuICAgICdjb2xvcjogI2E2YTA5NTsnLFxuICBdO1xufVxuXG4vLyBBc3N1bWUgd2FybmluZ3MgYW5kIGVycm9ycyBuZXZlciBoYXZlIHRoZSBzYW1lIG1lc3NhZ2VcbmxldCB2aXNpdGVkTWVzc2FnZXM6IFNldDxzdHJpbmc+O1xuaWYgKF9fREVWX18pIHtcbiAgcmVzZXRWaXNpdGVkTWVzc2FnZXMoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0VmlzaXRlZE1lc3NhZ2VzKCk6IHZvaWQge1xuICB2aXNpdGVkTWVzc2FnZXMgPSBuZXcgU2V0KCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YXJuV2hlbihjb25kaXRpb246IGJvb2xlYW4sIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoY29uZGl0aW9uICYmICF2aXNpdGVkTWVzc2FnZXMuaGFzKG1lc3NhZ2UpKSB7XG4gICAgdmlzaXRlZE1lc3NhZ2VzLmFkZChtZXNzYWdlKTtcbiAgICBjb25zb2xlLndhcm4oLi4uZ2V0Rm9ybWF0dGVkTWVzc2FnZShtZXNzYWdlKSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9yV2hlbihjb25kaXRpb246IGJvb2xlYW4sIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoY29uZGl0aW9uICYmICF2aXNpdGVkTWVzc2FnZXMuaGFzKG1lc3NhZ2UpKSB7XG4gICAgdmlzaXRlZE1lc3NhZ2VzLmFkZChtZXNzYWdlKTtcbiAgICBjb25zb2xlLmVycm9yKC4uLmdldEZvcm1hdHRlZE1lc3NhZ2UobWVzc2FnZSkpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVRhcmdldHModGFyZ2V0czogVGFyZ2V0cyk6IHZvaWQge1xuICBjb25zdCBkaWRQYXNzRmFsc3lWYWx1ZSA9ICF0YXJnZXRzO1xuICBjb25zdCBkaWRQYXNzUGxhaW5PYmplY3QgPVxuICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YXJnZXRzKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiZcbiAgICAhKHRhcmdldHMgYXMgYW55KS5hZGRFdmVudExpc3RlbmVyO1xuXG4gIGVycm9yV2hlbihcbiAgICBkaWRQYXNzRmFsc3lWYWx1ZSxcbiAgICBbXG4gICAgICAndGlwcHkoKSB3YXMgcGFzc2VkJyxcbiAgICAgICdgJyArIFN0cmluZyh0YXJnZXRzKSArICdgJyxcbiAgICAgICdhcyBpdHMgdGFyZ2V0cyAoZmlyc3QpIGFyZ3VtZW50LiBWYWxpZCB0eXBlcyBhcmU6IFN0cmluZywgRWxlbWVudCwnLFxuICAgICAgJ0VsZW1lbnRbXSwgb3IgTm9kZUxpc3QuJyxcbiAgICBdLmpvaW4oJyAnKVxuICApO1xuXG4gIGVycm9yV2hlbihcbiAgICBkaWRQYXNzUGxhaW5PYmplY3QsXG4gICAgW1xuICAgICAgJ3RpcHB5KCkgd2FzIHBhc3NlZCBhIHBsYWluIG9iamVjdCB3aGljaCBpcyBub3Qgc3VwcG9ydGVkIGFzIGFuIGFyZ3VtZW50JyxcbiAgICAgICdmb3IgdmlydHVhbCBwb3NpdGlvbmluZy4gVXNlIHByb3BzLmdldFJlZmVyZW5jZUNsaWVudFJlY3QgaW5zdGVhZC4nLFxuICAgIF0uam9pbignICcpXG4gICk7XG59XG4iLCAiaW1wb3J0IHtEZWZhdWx0UHJvcHMsIFBsdWdpbiwgUHJvcHMsIFJlZmVyZW5jZUVsZW1lbnQsIFRpcHB5fSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7XG4gIGhhc093blByb3BlcnR5LFxuICByZW1vdmVQcm9wZXJ0aWVzLFxuICBpbnZva2VXaXRoQXJnc09yUmV0dXJuLFxufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7d2FybldoZW59IGZyb20gJy4vdmFsaWRhdGlvbic7XG5pbXBvcnQge1RJUFBZX0RFRkFVTFRfQVBQRU5EX1RPfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmNvbnN0IHBsdWdpblByb3BzID0ge1xuICBhbmltYXRlRmlsbDogZmFsc2UsXG4gIGZvbGxvd0N1cnNvcjogZmFsc2UsXG4gIGlubGluZVBvc2l0aW9uaW5nOiBmYWxzZSxcbiAgc3RpY2t5OiBmYWxzZSxcbn07XG5cbmNvbnN0IHJlbmRlclByb3BzID0ge1xuICBhbGxvd0hUTUw6IGZhbHNlLFxuICBhbmltYXRpb246ICdmYWRlJyxcbiAgYXJyb3c6IHRydWUsXG4gIGNvbnRlbnQ6ICcnLFxuICBpbmVydGlhOiBmYWxzZSxcbiAgbWF4V2lkdGg6IDM1MCxcbiAgcm9sZTogJ3Rvb2x0aXAnLFxuICB0aGVtZTogJycsXG4gIHpJbmRleDogOTk5OSxcbn07XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0UHJvcHM6IERlZmF1bHRQcm9wcyA9IHtcbiAgYXBwZW5kVG86IFRJUFBZX0RFRkFVTFRfQVBQRU5EX1RPLFxuICBhcmlhOiB7XG4gICAgY29udGVudDogJ2F1dG8nLFxuICAgIGV4cGFuZGVkOiAnYXV0bycsXG4gIH0sXG4gIGRlbGF5OiAwLFxuICBkdXJhdGlvbjogWzMwMCwgMjUwXSxcbiAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogbnVsbCxcbiAgaGlkZU9uQ2xpY2s6IHRydWUsXG4gIGlnbm9yZUF0dHJpYnV0ZXM6IGZhbHNlLFxuICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gIGludGVyYWN0aXZlQm9yZGVyOiAyLFxuICBpbnRlcmFjdGl2ZURlYm91bmNlOiAwLFxuICBtb3ZlVHJhbnNpdGlvbjogJycsXG4gIG9mZnNldDogWzAsIDEwXSxcbiAgb25BZnRlclVwZGF0ZSgpIHt9LFxuICBvbkJlZm9yZVVwZGF0ZSgpIHt9LFxuICBvbkNyZWF0ZSgpIHt9LFxuICBvbkRlc3Ryb3koKSB7fSxcbiAgb25IaWRkZW4oKSB7fSxcbiAgb25IaWRlKCkge30sXG4gIG9uTW91bnQoKSB7fSxcbiAgb25TaG93KCkge30sXG4gIG9uU2hvd24oKSB7fSxcbiAgb25UcmlnZ2VyKCkge30sXG4gIG9uVW50cmlnZ2VyKCkge30sXG4gIG9uQ2xpY2tPdXRzaWRlKCkge30sXG4gIHBsYWNlbWVudDogJ3RvcCcsXG4gIHBsdWdpbnM6IFtdLFxuICBwb3BwZXJPcHRpb25zOiB7fSxcbiAgcmVuZGVyOiBudWxsLFxuICBzaG93T25DcmVhdGU6IGZhbHNlLFxuICB0b3VjaDogdHJ1ZSxcbiAgdHJpZ2dlcjogJ21vdXNlZW50ZXIgZm9jdXMnLFxuICB0cmlnZ2VyVGFyZ2V0OiBudWxsLFxuICAuLi5wbHVnaW5Qcm9wcyxcbiAgLi4ucmVuZGVyUHJvcHMsXG59O1xuXG5jb25zdCBkZWZhdWx0S2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRQcm9wcyk7XG5cbmV4cG9ydCBjb25zdCBzZXREZWZhdWx0UHJvcHM6IFRpcHB5WydzZXREZWZhdWx0UHJvcHMnXSA9IChwYXJ0aWFsUHJvcHMpID0+IHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKF9fREVWX18pIHtcbiAgICB2YWxpZGF0ZVByb3BzKHBhcnRpYWxQcm9wcywgW10pO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHBhcnRpYWxQcm9wcykgYXMgQXJyYXk8a2V5b2YgRGVmYXVsdFByb3BzPjtcbiAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAoZGVmYXVsdFByb3BzIGFzIGFueSlba2V5XSA9IHBhcnRpYWxQcm9wc1trZXldO1xuICB9KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFeHRlbmRlZFBhc3NlZFByb3BzKFxuICBwYXNzZWRQcm9wczogUGFydGlhbDxQcm9wcz4gJiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuKTogUGFydGlhbDxQcm9wcz4ge1xuICBjb25zdCBwbHVnaW5zID0gcGFzc2VkUHJvcHMucGx1Z2lucyB8fCBbXTtcbiAgY29uc3QgcGx1Z2luUHJvcHMgPSBwbHVnaW5zLnJlZHVjZTxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oKGFjYywgcGx1Z2luKSA9PiB7XG4gICAgY29uc3Qge25hbWUsIGRlZmF1bHRWYWx1ZX0gPSBwbHVnaW47XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgYWNjW25hbWVdID1cbiAgICAgICAgcGFzc2VkUHJvcHNbbmFtZV0gIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gcGFzc2VkUHJvcHNbbmFtZV1cbiAgICAgICAgICA6IChkZWZhdWx0UHJvcHMgYXMgYW55KVtuYW1lXSA/PyBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuXG4gIHJldHVybiB7XG4gICAgLi4ucGFzc2VkUHJvcHMsXG4gICAgLi4ucGx1Z2luUHJvcHMsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhQXR0cmlidXRlUHJvcHMoXG4gIHJlZmVyZW5jZTogUmVmZXJlbmNlRWxlbWVudCxcbiAgcGx1Z2luczogUGx1Z2luW11cbik6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgY29uc3QgcHJvcEtleXMgPSBwbHVnaW5zXG4gICAgPyBPYmplY3Qua2V5cyhnZXRFeHRlbmRlZFBhc3NlZFByb3BzKHsuLi5kZWZhdWx0UHJvcHMsIHBsdWdpbnN9KSlcbiAgICA6IGRlZmF1bHRLZXlzO1xuXG4gIGNvbnN0IHByb3BzID0gcHJvcEtleXMucmVkdWNlKFxuICAgIChhY2M6IFBhcnRpYWw8UHJvcHM+ICYgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIGtleSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWVBc1N0cmluZyA9IChcbiAgICAgICAgcmVmZXJlbmNlLmdldEF0dHJpYnV0ZShgZGF0YS10aXBweS0ke2tleX1gKSB8fCAnJ1xuICAgICAgKS50cmltKCk7XG5cbiAgICAgIGlmICghdmFsdWVBc1N0cmluZykge1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ID09PSAnY29udGVudCcpIHtcbiAgICAgICAgYWNjW2tleV0gPSB2YWx1ZUFzU3RyaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhY2Nba2V5XSA9IEpTT04ucGFyc2UodmFsdWVBc1N0cmluZyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlQXNTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LFxuICAgIHt9XG4gICk7XG5cbiAgcmV0dXJuIHByb3BzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZhbHVhdGVQcm9wcyhcbiAgcmVmZXJlbmNlOiBSZWZlcmVuY2VFbGVtZW50LFxuICBwcm9wczogUHJvcHNcbik6IFByb3BzIHtcbiAgY29uc3Qgb3V0ID0ge1xuICAgIC4uLnByb3BzLFxuICAgIGNvbnRlbnQ6IGludm9rZVdpdGhBcmdzT3JSZXR1cm4ocHJvcHMuY29udGVudCwgW3JlZmVyZW5jZV0pLFxuICAgIC4uLihwcm9wcy5pZ25vcmVBdHRyaWJ1dGVzXG4gICAgICA/IHt9XG4gICAgICA6IGdldERhdGFBdHRyaWJ1dGVQcm9wcyhyZWZlcmVuY2UsIHByb3BzLnBsdWdpbnMpKSxcbiAgfTtcblxuICBvdXQuYXJpYSA9IHtcbiAgICAuLi5kZWZhdWx0UHJvcHMuYXJpYSxcbiAgICAuLi5vdXQuYXJpYSxcbiAgfTtcblxuICBvdXQuYXJpYSA9IHtcbiAgICBleHBhbmRlZDpcbiAgICAgIG91dC5hcmlhLmV4cGFuZGVkID09PSAnYXV0bycgPyBwcm9wcy5pbnRlcmFjdGl2ZSA6IG91dC5hcmlhLmV4cGFuZGVkLFxuICAgIGNvbnRlbnQ6XG4gICAgICBvdXQuYXJpYS5jb250ZW50ID09PSAnYXV0bydcbiAgICAgICAgPyBwcm9wcy5pbnRlcmFjdGl2ZVxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogJ2Rlc2NyaWJlZGJ5J1xuICAgICAgICA6IG91dC5hcmlhLmNvbnRlbnQsXG4gIH07XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMoXG4gIHBhcnRpYWxQcm9wczogUGFydGlhbDxQcm9wcz4gPSB7fSxcbiAgcGx1Z2luczogUGx1Z2luW10gPSBbXVxuKTogdm9pZCB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwYXJ0aWFsUHJvcHMpIGFzIEFycmF5PGtleW9mIFByb3BzPjtcbiAga2V5cy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgY29uc3Qgbm9uUGx1Z2luUHJvcHMgPSByZW1vdmVQcm9wZXJ0aWVzKFxuICAgICAgZGVmYXVsdFByb3BzLFxuICAgICAgT2JqZWN0LmtleXMocGx1Z2luUHJvcHMpXG4gICAgKTtcblxuICAgIGxldCBkaWRQYXNzVW5rbm93blByb3AgPSAhaGFzT3duUHJvcGVydHkobm9uUGx1Z2luUHJvcHMsIHByb3ApO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHByb3AgZXhpc3RzIGluIGBwbHVnaW5zYFxuICAgIGlmIChkaWRQYXNzVW5rbm93blByb3ApIHtcbiAgICAgIGRpZFBhc3NVbmtub3duUHJvcCA9XG4gICAgICAgIHBsdWdpbnMuZmlsdGVyKChwbHVnaW4pID0+IHBsdWdpbi5uYW1lID09PSBwcm9wKS5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgd2FybldoZW4oXG4gICAgICBkaWRQYXNzVW5rbm93blByb3AsXG4gICAgICBbXG4gICAgICAgIGBcXGAke3Byb3B9XFxgYCxcbiAgICAgICAgXCJpcyBub3QgYSB2YWxpZCBwcm9wLiBZb3UgbWF5IGhhdmUgc3BlbGxlZCBpdCBpbmNvcnJlY3RseSwgb3IgaWYgaXQnc1wiLFxuICAgICAgICAnYSBwbHVnaW4sIGZvcmdvdCB0byBwYXNzIGl0IGluIGFuIGFycmF5IGFzIHByb3BzLnBsdWdpbnMuJyxcbiAgICAgICAgJ1xcblxcbicsXG4gICAgICAgICdBbGwgcHJvcHM6IGh0dHBzOi8vYXRvbWlrcy5naXRodWIuaW8vdGlwcHlqcy92Ni9hbGwtcHJvcHMvXFxuJyxcbiAgICAgICAgJ1BsdWdpbnM6IGh0dHBzOi8vYXRvbWlrcy5naXRodWIuaW8vdGlwcHlqcy92Ni9wbHVnaW5zLycsXG4gICAgICBdLmpvaW4oJyAnKVxuICAgICk7XG4gIH0pO1xufVxuIiwgImltcG9ydCB7XG4gIEFSUk9XX0NMQVNTLFxuICBCQUNLRFJPUF9DTEFTUyxcbiAgQk9YX0NMQVNTLFxuICBDT05URU5UX0NMQVNTLFxuICBTVkdfQVJST1dfQ0xBU1MsXG59IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7ZGl2LCBpc0VsZW1lbnR9IGZyb20gJy4vZG9tLXV0aWxzJztcbmltcG9ydCB7SW5zdGFuY2UsIFBvcHBlckVsZW1lbnQsIFByb3BzfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7UG9wcGVyQ2hpbGRyZW59IGZyb20gJy4vdHlwZXMtaW50ZXJuYWwnO1xuaW1wb3J0IHthcnJheUZyb219IGZyb20gJy4vdXRpbHMnO1xuXG4vLyBGaXJlZm94IGV4dGVuc2lvbnMgZG9uJ3QgYWxsb3cgLmlubmVySFRNTCA9IFwiLi4uXCIgcHJvcGVydHkuIFRoaXMgdHJpY2tzIGl0LlxuY29uc3QgaW5uZXJIVE1MID0gKCk6ICdpbm5lckhUTUwnID0+ICdpbm5lckhUTUwnO1xuXG5mdW5jdGlvbiBkYW5nZXJvdXNseVNldElubmVySFRNTChlbGVtZW50OiBFbGVtZW50LCBodG1sOiBzdHJpbmcpOiB2b2lkIHtcbiAgZWxlbWVudFtpbm5lckhUTUwoKV0gPSBodG1sO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcnJvd0VsZW1lbnQodmFsdWU6IFByb3BzWydhcnJvdyddKTogSFRNTERpdkVsZW1lbnQge1xuICBjb25zdCBhcnJvdyA9IGRpdigpO1xuXG4gIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgIGFycm93LmNsYXNzTmFtZSA9IEFSUk9XX0NMQVNTO1xuICB9IGVsc2Uge1xuICAgIGFycm93LmNsYXNzTmFtZSA9IFNWR19BUlJPV19DTEFTUztcblxuICAgIGlmIChpc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICBhcnJvdy5hcHBlbmRDaGlsZCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKGFycm93LCB2YWx1ZSBhcyBzdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcnJvdztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldENvbnRlbnQoY29udGVudDogSFRNTERpdkVsZW1lbnQsIHByb3BzOiBQcm9wcyk6IHZvaWQge1xuICBpZiAoaXNFbGVtZW50KHByb3BzLmNvbnRlbnQpKSB7XG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwoY29udGVudCwgJycpO1xuICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQocHJvcHMuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzLmNvbnRlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvcHMuYWxsb3dIVE1MKSB7XG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTChjb250ZW50LCBwcm9wcy5jb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudC50ZXh0Q29udGVudCA9IHByb3BzLmNvbnRlbnQ7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGlsZHJlbihwb3BwZXI6IFBvcHBlckVsZW1lbnQpOiBQb3BwZXJDaGlsZHJlbiB7XG4gIGNvbnN0IGJveCA9IHBvcHBlci5maXJzdEVsZW1lbnRDaGlsZCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgY29uc3QgYm94Q2hpbGRyZW4gPSBhcnJheUZyb20oYm94LmNoaWxkcmVuKTtcblxuICByZXR1cm4ge1xuICAgIGJveCxcbiAgICBjb250ZW50OiBib3hDaGlsZHJlbi5maW5kKChub2RlKSA9PiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhDT05URU5UX0NMQVNTKSksXG4gICAgYXJyb3c6IGJveENoaWxkcmVuLmZpbmQoXG4gICAgICAobm9kZSkgPT5cbiAgICAgICAgbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoQVJST1dfQ0xBU1MpIHx8XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKFNWR19BUlJPV19DTEFTUylcbiAgICApLFxuICAgIGJhY2tkcm9wOiBib3hDaGlsZHJlbi5maW5kKChub2RlKSA9PlxuICAgICAgbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoQkFDS0RST1BfQ0xBU1MpXG4gICAgKSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihcbiAgaW5zdGFuY2U6IEluc3RhbmNlXG4pOiB7XG4gIHBvcHBlcjogUG9wcGVyRWxlbWVudDtcbiAgb25VcGRhdGU/OiAocHJldlByb3BzOiBQcm9wcywgbmV4dFByb3BzOiBQcm9wcykgPT4gdm9pZDtcbn0ge1xuICBjb25zdCBwb3BwZXIgPSBkaXYoKTtcblxuICBjb25zdCBib3ggPSBkaXYoKTtcbiAgYm94LmNsYXNzTmFtZSA9IEJPWF9DTEFTUztcbiAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsICdoaWRkZW4nKTtcbiAgYm94LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcblxuICBjb25zdCBjb250ZW50ID0gZGl2KCk7XG4gIGNvbnRlbnQuY2xhc3NOYW1lID0gQ09OVEVOVF9DTEFTUztcbiAgY29udGVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhdGUnLCAnaGlkZGVuJyk7XG5cbiAgc2V0Q29udGVudChjb250ZW50LCBpbnN0YW5jZS5wcm9wcyk7XG5cbiAgcG9wcGVyLmFwcGVuZENoaWxkKGJveCk7XG4gIGJveC5hcHBlbmRDaGlsZChjb250ZW50KTtcblxuICBvblVwZGF0ZShpbnN0YW5jZS5wcm9wcywgaW5zdGFuY2UucHJvcHMpO1xuXG4gIGZ1bmN0aW9uIG9uVXBkYXRlKHByZXZQcm9wczogUHJvcHMsIG5leHRQcm9wczogUHJvcHMpOiB2b2lkIHtcbiAgICBjb25zdCB7Ym94LCBjb250ZW50LCBhcnJvd30gPSBnZXRDaGlsZHJlbihwb3BwZXIpO1xuXG4gICAgaWYgKG5leHRQcm9wcy50aGVtZSkge1xuICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS10aGVtZScsIG5leHRQcm9wcy50aGVtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJveC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtdGhlbWUnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5leHRQcm9wcy5hbmltYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBib3guc2V0QXR0cmlidXRlKCdkYXRhLWFuaW1hdGlvbicsIG5leHRQcm9wcy5hbmltYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3gucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWFuaW1hdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChuZXh0UHJvcHMuaW5lcnRpYSkge1xuICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1pbmVydGlhJywgJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3gucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWluZXJ0aWEnKTtcbiAgICB9XG5cbiAgICBib3guc3R5bGUubWF4V2lkdGggPVxuICAgICAgdHlwZW9mIG5leHRQcm9wcy5tYXhXaWR0aCA9PT0gJ251bWJlcidcbiAgICAgICAgPyBgJHtuZXh0UHJvcHMubWF4V2lkdGh9cHhgXG4gICAgICAgIDogbmV4dFByb3BzLm1heFdpZHRoO1xuXG4gICAgaWYgKG5leHRQcm9wcy5yb2xlKSB7XG4gICAgICBib3guc2V0QXR0cmlidXRlKCdyb2xlJywgbmV4dFByb3BzLnJvbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3gucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgcHJldlByb3BzLmNvbnRlbnQgIT09IG5leHRQcm9wcy5jb250ZW50IHx8XG4gICAgICBwcmV2UHJvcHMuYWxsb3dIVE1MICE9PSBuZXh0UHJvcHMuYWxsb3dIVE1MXG4gICAgKSB7XG4gICAgICBzZXRDb250ZW50KGNvbnRlbnQsIGluc3RhbmNlLnByb3BzKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dFByb3BzLmFycm93KSB7XG4gICAgICBpZiAoIWFycm93KSB7XG4gICAgICAgIGJveC5hcHBlbmRDaGlsZChjcmVhdGVBcnJvd0VsZW1lbnQobmV4dFByb3BzLmFycm93KSk7XG4gICAgICB9IGVsc2UgaWYgKHByZXZQcm9wcy5hcnJvdyAhPT0gbmV4dFByb3BzLmFycm93KSB7XG4gICAgICAgIGJveC5yZW1vdmVDaGlsZChhcnJvdyk7XG4gICAgICAgIGJveC5hcHBlbmRDaGlsZChjcmVhdGVBcnJvd0VsZW1lbnQobmV4dFByb3BzLmFycm93KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcnJvdykge1xuICAgICAgYm94LnJlbW92ZUNoaWxkKGFycm93ISk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3BwZXIsXG4gICAgb25VcGRhdGUsXG4gIH07XG59XG5cbi8vIFJ1bnRpbWUgY2hlY2sgdG8gaWRlbnRpZnkgaWYgdGhlIHJlbmRlciBmdW5jdGlvbiBpcyB0aGUgZGVmYXVsdCBvbmU7IHRoaXNcbi8vIHdheSB3ZSBjYW4gYXBwbHkgZGVmYXVsdCBDU1MgdHJhbnNpdGlvbnMgbG9naWMgYW5kIGl0IGNhbiBiZSB0cmVlLXNoYWtlbiBhd2F5XG5yZW5kZXIuJCR0aXBweSA9IHRydWU7XG4iLCAiaW1wb3J0IHtjcmVhdGVQb3BwZXIsIFN0cmljdE1vZGlmaWVycywgTW9kaWZpZXJ9IGZyb20gJ0Bwb3BwZXJqcy9jb3JlJztcbmltcG9ydCB7Y3VycmVudElucHV0fSBmcm9tICcuL2JpbmRHbG9iYWxFdmVudExpc3RlbmVycyc7XG5pbXBvcnQge2lzSUUxMX0gZnJvbSAnLi9icm93c2VyJztcbmltcG9ydCB7VElQUFlfREVGQVVMVF9BUFBFTkRfVE8sIFRPVUNIX09QVElPTlN9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7XG4gIGFjdHVhbENvbnRhaW5zLFxuICBkaXYsXG4gIGdldE93bmVyRG9jdW1lbnQsXG4gIGlzQ3Vyc29yT3V0c2lkZUludGVyYWN0aXZlQm9yZGVyLFxuICBpc01vdXNlRXZlbnQsXG4gIHNldFRyYW5zaXRpb25EdXJhdGlvbixcbiAgc2V0VmlzaWJpbGl0eVN0YXRlLFxuICB1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIsXG59IGZyb20gJy4vZG9tLXV0aWxzJztcbmltcG9ydCB7ZGVmYXVsdFByb3BzLCBldmFsdWF0ZVByb3BzLCBnZXRFeHRlbmRlZFBhc3NlZFByb3BzfSBmcm9tICcuL3Byb3BzJztcbmltcG9ydCB7Z2V0Q2hpbGRyZW59IGZyb20gJy4vdGVtcGxhdGUnO1xuaW1wb3J0IHtcbiAgQ29udGVudCxcbiAgSW5zdGFuY2UsXG4gIExpZmVjeWNsZUhvb2tzLFxuICBQb3BwZXJFbGVtZW50LFxuICBQcm9wcyxcbiAgUmVmZXJlbmNlRWxlbWVudCxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge0xpc3RlbmVyT2JqZWN0LCBQb3BwZXJUcmVlRGF0YSwgUG9wcGVyQ2hpbGRyZW59IGZyb20gJy4vdHlwZXMtaW50ZXJuYWwnO1xuaW1wb3J0IHtcbiAgYXJyYXlGcm9tLFxuICBkZWJvdW5jZSxcbiAgZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4sXG4gIGludm9rZVdpdGhBcmdzT3JSZXR1cm4sXG4gIG5vcm1hbGl6ZVRvQXJyYXksXG4gIHB1c2hJZlVuaXF1ZSxcbiAgc3BsaXRCeVNwYWNlcyxcbiAgdW5pcXVlLFxuICByZW1vdmVVbmRlZmluZWRQcm9wcyxcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge2NyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nLCBlcnJvcldoZW4sIHdhcm5XaGVufSBmcm9tICcuL3ZhbGlkYXRpb24nO1xuXG5sZXQgaWRDb3VudGVyID0gMTtcbmxldCBtb3VzZU1vdmVMaXN0ZW5lcnM6ICgoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHZvaWQpW10gPSBbXTtcblxuLy8gVXNlZCBieSBgaGlkZUFsbCgpYFxuZXhwb3J0IGxldCBtb3VudGVkSW5zdGFuY2VzOiBJbnN0YW5jZVtdID0gW107XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVRpcHB5KFxuICByZWZlcmVuY2U6IFJlZmVyZW5jZUVsZW1lbnQsXG4gIHBhc3NlZFByb3BzOiBQYXJ0aWFsPFByb3BzPlxuKTogSW5zdGFuY2Uge1xuICBjb25zdCBwcm9wcyA9IGV2YWx1YXRlUHJvcHMocmVmZXJlbmNlLCB7XG4gICAgLi4uZGVmYXVsdFByb3BzLFxuICAgIC4uLmdldEV4dGVuZGVkUGFzc2VkUHJvcHMocmVtb3ZlVW5kZWZpbmVkUHJvcHMocGFzc2VkUHJvcHMpKSxcbiAgfSk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIPCflJIgUHJpdmF0ZSBtZW1iZXJzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBsZXQgc2hvd1RpbWVvdXQ6IGFueTtcbiAgbGV0IGhpZGVUaW1lb3V0OiBhbnk7XG4gIGxldCBzY2hlZHVsZUhpZGVBbmltYXRpb25GcmFtZTogbnVtYmVyO1xuICBsZXQgaXNWaXNpYmxlRnJvbUNsaWNrID0gZmFsc2U7XG4gIGxldCBkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93biA9IGZhbHNlO1xuICBsZXQgZGlkVG91Y2hNb3ZlID0gZmFsc2U7XG4gIGxldCBpZ25vcmVPbkZpcnN0VXBkYXRlID0gZmFsc2U7XG4gIGxldCBsYXN0VHJpZ2dlckV2ZW50OiBFdmVudCB8IHVuZGVmaW5lZDtcbiAgbGV0IGN1cnJlbnRUcmFuc2l0aW9uRW5kTGlzdGVuZXI6IChldmVudDogVHJhbnNpdGlvbkV2ZW50KSA9PiB2b2lkO1xuICBsZXQgb25GaXJzdFVwZGF0ZTogKCkgPT4gdm9pZDtcbiAgbGV0IGxpc3RlbmVyczogTGlzdGVuZXJPYmplY3RbXSA9IFtdO1xuICBsZXQgZGVib3VuY2VkT25Nb3VzZU1vdmUgPSBkZWJvdW5jZShvbk1vdXNlTW92ZSwgcHJvcHMuaW50ZXJhY3RpdmVEZWJvdW5jZSk7XG4gIGxldCBjdXJyZW50VGFyZ2V0OiBFbGVtZW50O1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyDwn5SRIFB1YmxpYyBtZW1iZXJzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBjb25zdCBpZCA9IGlkQ291bnRlcisrO1xuICBjb25zdCBwb3BwZXJJbnN0YW5jZSA9IG51bGw7XG4gIGNvbnN0IHBsdWdpbnMgPSB1bmlxdWUocHJvcHMucGx1Z2lucyk7XG5cbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgLy8gSXMgdGhlIGluc3RhbmNlIGN1cnJlbnRseSBlbmFibGVkP1xuICAgIGlzRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyBJcyB0aGUgdGlwcHkgY3VycmVudGx5IHNob3dpbmcgYW5kIG5vdCB0cmFuc2l0aW9uaW5nIG91dD9cbiAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgIC8vIEhhcyB0aGUgaW5zdGFuY2UgYmVlbiBkZXN0cm95ZWQ/XG4gICAgaXNEZXN0cm95ZWQ6IGZhbHNlLFxuICAgIC8vIElzIHRoZSB0aXBweSBjdXJyZW50bHkgbW91bnRlZCB0byB0aGUgRE9NP1xuICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgLy8gSGFzIHRoZSB0aXBweSBmaW5pc2hlZCB0cmFuc2l0aW9uaW5nIGluP1xuICAgIGlzU2hvd246IGZhbHNlLFxuICB9O1xuXG4gIGNvbnN0IGluc3RhbmNlOiBJbnN0YW5jZSA9IHtcbiAgICAvLyBwcm9wZXJ0aWVzXG4gICAgaWQsXG4gICAgcmVmZXJlbmNlLFxuICAgIHBvcHBlcjogZGl2KCksXG4gICAgcG9wcGVySW5zdGFuY2UsXG4gICAgcHJvcHMsXG4gICAgc3RhdGUsXG4gICAgcGx1Z2lucyxcbiAgICAvLyBtZXRob2RzXG4gICAgY2xlYXJEZWxheVRpbWVvdXRzLFxuICAgIHNldFByb3BzLFxuICAgIHNldENvbnRlbnQsXG4gICAgc2hvdyxcbiAgICBoaWRlLFxuICAgIGhpZGVXaXRoSW50ZXJhY3Rpdml0eSxcbiAgICBlbmFibGUsXG4gICAgZGlzYWJsZSxcbiAgICB1bm1vdW50LFxuICAgIGRlc3Ryb3ksXG4gIH07XG5cbiAgLy8gVE9ETzogSW52ZXN0aWdhdGUgd2h5IHRoaXMgZWFybHkgcmV0dXJuIGNhdXNlcyBhIFREWiBlcnJvciBpbiB0aGUgdGVzdHMg4oCUXG4gIC8vIGl0IGRvZXNuJ3Qgc2VlbSB0byBoYXBwZW4gaW4gdGhlIGJyb3dzZXJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghcHJvcHMucmVuZGVyKSB7XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIGVycm9yV2hlbih0cnVlLCAncmVuZGVyKCkgZnVuY3Rpb24gaGFzIG5vdCBiZWVuIHN1cHBsaWVkLicpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBJbml0aWFsIG11dGF0aW9uc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgY29uc3Qge3BvcHBlciwgb25VcGRhdGV9ID0gcHJvcHMucmVuZGVyKGluc3RhbmNlKTtcblxuICBwb3BwZXIuc2V0QXR0cmlidXRlKCdkYXRhLV9fTkFNRVNQQUNFX1BSRUZJWF9fLXJvb3QnLCAnJyk7XG4gIHBvcHBlci5pZCA9IGBfX05BTUVTUEFDRV9QUkVGSVhfXy0ke2luc3RhbmNlLmlkfWA7XG5cbiAgaW5zdGFuY2UucG9wcGVyID0gcG9wcGVyO1xuICByZWZlcmVuY2UuX3RpcHB5ID0gaW5zdGFuY2U7XG4gIHBvcHBlci5fdGlwcHkgPSBpbnN0YW5jZTtcblxuICBjb25zdCBwbHVnaW5zSG9va3MgPSBwbHVnaW5zLm1hcCgocGx1Z2luKSA9PiBwbHVnaW4uZm4oaW5zdGFuY2UpKTtcbiAgY29uc3QgaGFzQXJpYUV4cGFuZGVkID0gcmVmZXJlbmNlLmhhc0F0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuXG4gIGFkZExpc3RlbmVycygpO1xuICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcbiAgaGFuZGxlU3R5bGVzKCk7XG5cbiAgaW52b2tlSG9vaygnb25DcmVhdGUnLCBbaW5zdGFuY2VdKTtcblxuICBpZiAocHJvcHMuc2hvd09uQ3JlYXRlKSB7XG4gICAgc2NoZWR1bGVTaG93KCk7XG4gIH1cblxuICAvLyBQcmV2ZW50IGEgdGlwcHkgd2l0aCBhIGRlbGF5IGZyb20gaGlkaW5nIGlmIHRoZSBjdXJzb3IgbGVmdCB0aGVuIHJldHVybmVkXG4gIC8vIGJlZm9yZSBpdCBzdGFydGVkIGhpZGluZ1xuICBwb3BwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsICgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHBvcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgKCkgPT4ge1xuICAgIGlmIChcbiAgICAgIGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmXG4gICAgICBpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ21vdXNlZW50ZXInKSA+PSAwXG4gICAgKSB7XG4gICAgICBnZXREb2N1bWVudCgpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGRlYm91bmNlZE9uTW91c2VNb3ZlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8g8J+UkiBQcml2YXRlIG1ldGhvZHNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRUb3VjaFNldHRpbmdzKCk6IFtzdHJpbmcgfCBib29sZWFuLCBudW1iZXJdIHtcbiAgICBjb25zdCB7dG91Y2h9ID0gaW5zdGFuY2UucHJvcHM7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodG91Y2gpID8gdG91Y2ggOiBbdG91Y2gsIDBdO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXNDdXN0b21Ub3VjaEJlaGF2aW9yKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBnZXROb3JtYWxpemVkVG91Y2hTZXR0aW5ncygpWzBdID09PSAnaG9sZCc7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJc0RlZmF1bHRSZW5kZXJGbigpOiBib29sZWFuIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuICEhaW5zdGFuY2UucHJvcHMucmVuZGVyPy4kJHRpcHB5O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudFRhcmdldCgpOiBFbGVtZW50IHtcbiAgICByZXR1cm4gY3VycmVudFRhcmdldCB8fCByZWZlcmVuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREb2N1bWVudCgpOiBEb2N1bWVudCB7XG4gICAgY29uc3QgcGFyZW50ID0gZ2V0Q3VycmVudFRhcmdldCgpLnBhcmVudE5vZGUgYXMgRWxlbWVudDtcbiAgICByZXR1cm4gcGFyZW50ID8gZ2V0T3duZXJEb2N1bWVudChwYXJlbnQpIDogZG9jdW1lbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpOiBQb3BwZXJDaGlsZHJlbiB7XG4gICAgcmV0dXJuIGdldENoaWxkcmVuKHBvcHBlcik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREZWxheShpc1Nob3c6IGJvb2xlYW4pOiBudW1iZXIge1xuICAgIC8vIEZvciB0b3VjaCBvciBrZXlib2FyZCBpbnB1dCwgZm9yY2UgYDBgIGRlbGF5IGZvciBVWCByZWFzb25zXG4gICAgLy8gQWxzbyBpZiB0aGUgaW5zdGFuY2UgaXMgbW91bnRlZCBidXQgbm90IHZpc2libGUgKHRyYW5zaXRpb25pbmcgb3V0KSxcbiAgICAvLyBpZ25vcmUgZGVsYXlcbiAgICBpZiAoXG4gICAgICAoaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkICYmICFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHx8XG4gICAgICBjdXJyZW50SW5wdXQuaXNUb3VjaCB8fFxuICAgICAgKGxhc3RUcmlnZ2VyRXZlbnQgJiYgbGFzdFRyaWdnZXJFdmVudC50eXBlID09PSAnZm9jdXMnKVxuICAgICkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldFZhbHVlQXRJbmRleE9yUmV0dXJuKFxuICAgICAgaW5zdGFuY2UucHJvcHMuZGVsYXksXG4gICAgICBpc1Nob3cgPyAwIDogMSxcbiAgICAgIGRlZmF1bHRQcm9wcy5kZWxheVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdHlsZXMoZnJvbUhpZGUgPSBmYWxzZSk6IHZvaWQge1xuICAgIHBvcHBlci5zdHlsZS5wb2ludGVyRXZlbnRzID1cbiAgICAgIGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmICFmcm9tSGlkZSA/ICcnIDogJ25vbmUnO1xuICAgIHBvcHBlci5zdHlsZS56SW5kZXggPSBgJHtpbnN0YW5jZS5wcm9wcy56SW5kZXh9YDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUhvb2soXG4gICAgaG9vazoga2V5b2YgTGlmZWN5Y2xlSG9va3MsXG4gICAgYXJnczogW0luc3RhbmNlLCBhbnk/XSxcbiAgICBzaG91bGRJbnZva2VQcm9wc0hvb2sgPSB0cnVlXG4gICk6IHZvaWQge1xuICAgIHBsdWdpbnNIb29rcy5mb3JFYWNoKChwbHVnaW5Ib29rcykgPT4ge1xuICAgICAgaWYgKHBsdWdpbkhvb2tzW2hvb2tdKSB7XG4gICAgICAgIHBsdWdpbkhvb2tzW2hvb2tdISguLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChzaG91bGRJbnZva2VQcm9wc0hvb2spIHtcbiAgICAgIGluc3RhbmNlLnByb3BzW2hvb2tdKC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUFyaWFDb250ZW50QXR0cmlidXRlKCk6IHZvaWQge1xuICAgIGNvbnN0IHthcmlhfSA9IGluc3RhbmNlLnByb3BzO1xuXG4gICAgaWYgKCFhcmlhLmNvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhdHRyID0gYGFyaWEtJHthcmlhLmNvbnRlbnR9YDtcbiAgICBjb25zdCBpZCA9IHBvcHBlci5pZDtcbiAgICBjb25zdCBub2RlcyA9IG5vcm1hbGl6ZVRvQXJyYXkoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCByZWZlcmVuY2UpO1xuXG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cik7XG5cbiAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgY3VycmVudFZhbHVlID8gYCR7Y3VycmVudFZhbHVlfSAke2lkfWAgOiBpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSBjdXJyZW50VmFsdWUgJiYgY3VycmVudFZhbHVlLnJlcGxhY2UoaWQsICcnKS50cmltKCk7XG5cbiAgICAgICAgaWYgKG5leHRWYWx1ZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIG5leHRWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpOiB2b2lkIHtcbiAgICBpZiAoaGFzQXJpYUV4cGFuZGVkIHx8ICFpbnN0YW5jZS5wcm9wcy5hcmlhLmV4cGFuZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZXMgPSBub3JtYWxpemVUb0FycmF5KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKTtcblxuICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAnYXJpYS1leHBhbmRlZCcsXG4gICAgICAgICAgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmIG5vZGUgPT09IGdldEN1cnJlbnRUYXJnZXQoKVxuICAgICAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgICAgIDogJ2ZhbHNlJ1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXBJbnRlcmFjdGl2ZU1vdXNlTGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIGdldERvY3VtZW50KCkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZGVib3VuY2VkT25Nb3VzZU1vdmUpO1xuICAgIG1vdXNlTW92ZUxpc3RlbmVycyA9IG1vdXNlTW92ZUxpc3RlbmVycy5maWx0ZXIoXG4gICAgICAobGlzdGVuZXIpID0+IGxpc3RlbmVyICE9PSBkZWJvdW5jZWRPbk1vdXNlTW92ZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkRvY3VtZW50UHJlc3MoZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KTogdm9pZCB7XG4gICAgLy8gTW92ZWQgZmluZ2VyIHRvIHNjcm9sbCBpbnN0ZWFkIG9mIGFuIGludGVudGlvbmFsIHRhcCBvdXRzaWRlXG4gICAgaWYgKGN1cnJlbnRJbnB1dC5pc1RvdWNoKSB7XG4gICAgICBpZiAoZGlkVG91Y2hNb3ZlIHx8IGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhY3R1YWxUYXJnZXQgPVxuICAgICAgKGV2ZW50LmNvbXBvc2VkUGF0aCAmJiBldmVudC5jb21wb3NlZFBhdGgoKVswXSkgfHwgZXZlbnQudGFyZ2V0O1xuXG4gICAgLy8gQ2xpY2tlZCBvbiBpbnRlcmFjdGl2ZSBwb3BwZXJcbiAgICBpZiAoXG4gICAgICBpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJlxuICAgICAgYWN0dWFsQ29udGFpbnMocG9wcGVyLCBhY3R1YWxUYXJnZXQgYXMgRWxlbWVudClcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDbGlja2VkIG9uIHRoZSBldmVudCBsaXN0ZW5lcnMgdGFyZ2V0XG4gICAgaWYgKFxuICAgICAgbm9ybWFsaXplVG9BcnJheShpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSkuc29tZSgoZWwpID0+XG4gICAgICAgIGFjdHVhbENvbnRhaW5zKGVsLCBhY3R1YWxUYXJnZXQgYXMgRWxlbWVudClcbiAgICAgIClcbiAgICApIHtcbiAgICAgIGlmIChjdXJyZW50SW5wdXQuaXNUb3VjaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmXG4gICAgICAgIGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignY2xpY2snKSA+PSAwXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbnZva2VIb29rKCdvbkNsaWNrT3V0c2lkZScsIFtpbnN0YW5jZSwgZXZlbnRdKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaGlkZU9uQ2xpY2sgPT09IHRydWUpIHtcbiAgICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuXG4gICAgICAvLyBgbW91c2Vkb3duYCBldmVudCBpcyBmaXJlZCByaWdodCBiZWZvcmUgYGZvY3VzYCBpZiBwcmVzc2luZyB0aGVcbiAgICAgIC8vIGN1cnJlbnRUYXJnZXQuIFRoaXMgbGV0cyBhIHRpcHB5IHdpdGggYGZvY3VzYCB0cmlnZ2VyIGtub3cgdGhhdCBpdFxuICAgICAgLy8gc2hvdWxkIG5vdCBzaG93XG4gICAgICBkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93biA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZGlkSGlkZUR1ZVRvRG9jdW1lbnRNb3VzZURvd24gPSBmYWxzZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUaGUgbGlzdGVuZXIgZ2V0cyBhZGRlZCBpbiBgc2NoZWR1bGVTaG93KClgLCBidXQgdGhpcyBtYXkgYmUgaGlkaW5nIGl0XG4gICAgICAvLyBiZWZvcmUgaXQgc2hvd3MsIGFuZCBoaWRlKCkncyBlYXJseSBiYWlsLW91dCBiZWhhdmlvciBjYW4gcHJldmVudCBpdFxuICAgICAgLy8gZnJvbSBiZWluZyBjbGVhbmVkIHVwXG4gICAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICByZW1vdmVEb2N1bWVudFByZXNzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Ub3VjaE1vdmUoKTogdm9pZCB7XG4gICAgZGlkVG91Y2hNb3ZlID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVG91Y2hTdGFydCgpOiB2b2lkIHtcbiAgICBkaWRUb3VjaE1vdmUgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZERvY3VtZW50UHJlc3MoKTogdm9pZCB7XG4gICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQoKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Eb2N1bWVudFByZXNzLCB0cnVlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvbkRvY3VtZW50UHJlc3MsIFRPVUNIX09QVElPTlMpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCBUT1VDSF9PUFRJT05TKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUsIFRPVUNIX09QVElPTlMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRG9jdW1lbnRQcmVzcygpOiB2b2lkIHtcbiAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudCgpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbkRvY3VtZW50UHJlc3MsIHRydWUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uRG9jdW1lbnRQcmVzcywgVE9VQ0hfT1BUSU9OUyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIFRPVUNIX09QVElPTlMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgVE9VQ0hfT1BUSU9OUyk7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zaXRpb25lZE91dChkdXJhdGlvbjogbnVtYmVyLCBjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIG9uVHJhbnNpdGlvbkVuZChkdXJhdGlvbiwgKCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAhaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmXG4gICAgICAgIHBvcHBlci5wYXJlbnROb2RlICYmXG4gICAgICAgIHBvcHBlci5wYXJlbnROb2RlLmNvbnRhaW5zKHBvcHBlcilcbiAgICAgICkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc2l0aW9uZWRJbihkdXJhdGlvbjogbnVtYmVyLCBjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIG9uVHJhbnNpdGlvbkVuZChkdXJhdGlvbiwgY2FsbGJhY2spO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc2l0aW9uRW5kKGR1cmF0aW9uOiBudW1iZXIsIGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgY29uc3QgYm94ID0gZ2V0RGVmYXVsdFRlbXBsYXRlQ2hpbGRyZW4oKS5ib3g7XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW5lcihldmVudDogVHJhbnNpdGlvbkV2ZW50KTogdm9pZCB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBib3gpIHtcbiAgICAgICAgdXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyKGJveCwgJ3JlbW92ZScsIGxpc3RlbmVyKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlIGNhbGxiYWNrIHN5bmNocm9ub3VzIGlmIGR1cmF0aW9uIGlzIDBcbiAgICAvLyBgdHJhbnNpdGlvbmVuZGAgd29uJ3QgZmlyZSBvdGhlcndpc2VcbiAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcihib3gsICdyZW1vdmUnLCBjdXJyZW50VHJhbnNpdGlvbkVuZExpc3RlbmVyKTtcbiAgICB1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIoYm94LCAnYWRkJywgbGlzdGVuZXIpO1xuXG4gICAgY3VycmVudFRyYW5zaXRpb25FbmRMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gb24oXG4gICAgZXZlbnRUeXBlOiBzdHJpbmcsXG4gICAgaGFuZGxlcjogRXZlbnRMaXN0ZW5lcixcbiAgICBvcHRpb25zOiBib29sZWFuIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSBmYWxzZVxuICApOiB2b2lkIHtcbiAgICBjb25zdCBub2RlcyA9IG5vcm1hbGl6ZVRvQXJyYXkoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCByZWZlcmVuY2UpO1xuICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgbGlzdGVuZXJzLnB1c2goe25vZGUsIGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9uc30pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIGlmIChnZXRJc0N1c3RvbVRvdWNoQmVoYXZpb3IoKSkge1xuICAgICAgb24oJ3RvdWNoc3RhcnQnLCBvblRyaWdnZXIsIHtwYXNzaXZlOiB0cnVlfSk7XG4gICAgICBvbigndG91Y2hlbmQnLCBvbk1vdXNlTGVhdmUgYXMgRXZlbnRMaXN0ZW5lciwge3Bhc3NpdmU6IHRydWV9KTtcbiAgICB9XG5cbiAgICBzcGxpdEJ5U3BhY2VzKGluc3RhbmNlLnByb3BzLnRyaWdnZXIpLmZvckVhY2goKGV2ZW50VHlwZSkgPT4ge1xuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ21hbnVhbCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvbihldmVudFR5cGUsIG9uVHJpZ2dlcik7XG5cbiAgICAgIHN3aXRjaCAoZXZlbnRUeXBlKSB7XG4gICAgICAgIGNhc2UgJ21vdXNlZW50ZXInOlxuICAgICAgICAgIG9uKCdtb3VzZWxlYXZlJywgb25Nb3VzZUxlYXZlIGFzIEV2ZW50TGlzdGVuZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgb24oaXNJRTExID8gJ2ZvY3Vzb3V0JyA6ICdibHVyJywgb25CbHVyT3JGb2N1c091dCBhcyBFdmVudExpc3RlbmVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZm9jdXNpbic6XG4gICAgICAgICAgb24oJ2ZvY3Vzb3V0Jywgb25CbHVyT3JGb2N1c091dCBhcyBFdmVudExpc3RlbmVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpOiB2b2lkIHtcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaCgoe25vZGUsIGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9uc306IExpc3RlbmVyT2JqZWN0KSA9PiB7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICBsaXN0ZW5lcnMgPSBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJpZ2dlcihldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICBsZXQgc2hvdWxkU2NoZWR1bGVDbGlja0hpZGUgPSBmYWxzZTtcblxuICAgIGlmIChcbiAgICAgICFpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQgfHxcbiAgICAgIGlzRXZlbnRMaXN0ZW5lclN0b3BwZWQoZXZlbnQpIHx8XG4gICAgICBkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93blxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHdhc0ZvY3VzZWQgPSBsYXN0VHJpZ2dlckV2ZW50Py50eXBlID09PSAnZm9jdXMnO1xuXG4gICAgbGFzdFRyaWdnZXJFdmVudCA9IGV2ZW50O1xuICAgIGN1cnJlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIEVsZW1lbnQ7XG5cbiAgICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcblxuICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmIGlzTW91c2VFdmVudChldmVudCkpIHtcbiAgICAgIC8vIElmIHNjcm9sbGluZywgYG1vdXNlZW50ZXJgIGV2ZW50cyBjYW4gYmUgZmlyZWQgaWYgdGhlIGN1cnNvciBsYW5kc1xuICAgICAgLy8gb3ZlciBhIG5ldyB0YXJnZXQsIGJ1dCBgbW91c2Vtb3ZlYCBldmVudHMgZG9uJ3QgZ2V0IGZpcmVkLiBUaGlzXG4gICAgICAvLyBjYXVzZXMgaW50ZXJhY3RpdmUgdG9vbHRpcHMgdG8gZ2V0IHN0dWNrIG9wZW4gdW50aWwgdGhlIGN1cnNvciBpc1xuICAgICAgLy8gbW92ZWRcbiAgICAgIG1vdXNlTW92ZUxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoZXZlbnQpKTtcbiAgICB9XG5cbiAgICAvLyBUb2dnbGUgc2hvdy9oaWRlIHdoZW4gY2xpY2tpbmcgY2xpY2stdHJpZ2dlcmVkIHRvb2x0aXBzXG4gICAgaWYgKFxuICAgICAgZXZlbnQudHlwZSA9PT0gJ2NsaWNrJyAmJlxuICAgICAgKGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignbW91c2VlbnRlcicpIDwgMCB8fFxuICAgICAgICBpc1Zpc2libGVGcm9tQ2xpY2spICYmXG4gICAgICBpbnN0YW5jZS5wcm9wcy5oaWRlT25DbGljayAhPT0gZmFsc2UgJiZcbiAgICAgIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZVxuICAgICkge1xuICAgICAgc2hvdWxkU2NoZWR1bGVDbGlja0hpZGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZVNob3coZXZlbnQpO1xuICAgIH1cblxuICAgIGlmIChldmVudC50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICBpc1Zpc2libGVGcm9tQ2xpY2sgPSAhc2hvdWxkU2NoZWR1bGVDbGlja0hpZGU7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFNjaGVkdWxlQ2xpY2tIaWRlICYmICF3YXNGb2N1c2VkKSB7XG4gICAgICBzY2hlZHVsZUhpZGUoZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIE5vZGU7XG4gICAgY29uc3QgaXNDdXJzb3JPdmVyUmVmZXJlbmNlT3JQb3BwZXIgPVxuICAgICAgZ2V0Q3VycmVudFRhcmdldCgpLmNvbnRhaW5zKHRhcmdldCkgfHwgcG9wcGVyLmNvbnRhaW5zKHRhcmdldCk7XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlbW92ZScgJiYgaXNDdXJzb3JPdmVyUmVmZXJlbmNlT3JQb3BwZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwb3BwZXJUcmVlRGF0YSA9IGdldE5lc3RlZFBvcHBlclRyZWUoKVxuICAgICAgLmNvbmNhdChwb3BwZXIpXG4gICAgICAubWFwKChwb3BwZXIpID0+IHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBwb3BwZXIuX3RpcHB5ITtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZT8uc3RhdGU7XG5cbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvcHBlclJlY3Q6IHBvcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIHBvcHBlclN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pIGFzIFBvcHBlclRyZWVEYXRhW107XG5cbiAgICBpZiAoaXNDdXJzb3JPdXRzaWRlSW50ZXJhY3RpdmVCb3JkZXIocG9wcGVyVHJlZURhdGEsIGV2ZW50KSkge1xuICAgICAgY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMoKTtcbiAgICAgIHNjaGVkdWxlSGlkZShldmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Nb3VzZUxlYXZlKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgY29uc3Qgc2hvdWxkQmFpbCA9XG4gICAgICBpc0V2ZW50TGlzdGVuZXJTdG9wcGVkKGV2ZW50KSB8fFxuICAgICAgKGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignY2xpY2snKSA+PSAwICYmIGlzVmlzaWJsZUZyb21DbGljayk7XG5cbiAgICBpZiAoc2hvdWxkQmFpbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgaW5zdGFuY2UuaGlkZVdpdGhJbnRlcmFjdGl2aXR5KGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlZHVsZUhpZGUoZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25CbHVyT3JGb2N1c091dChldmVudDogRm9jdXNFdmVudCk6IHZvaWQge1xuICAgIGlmIChcbiAgICAgIGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignZm9jdXNpbicpIDwgMCAmJlxuICAgICAgZXZlbnQudGFyZ2V0ICE9PSBnZXRDdXJyZW50VGFyZ2V0KClcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBmb2N1cyB3YXMgbW92ZWQgdG8gd2l0aGluIHRoZSBwb3BwZXJcbiAgICBpZiAoXG4gICAgICBpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJlxuICAgICAgZXZlbnQucmVsYXRlZFRhcmdldCAmJlxuICAgICAgcG9wcGVyLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQgYXMgRWxlbWVudClcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlZHVsZUhpZGUoZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFdmVudExpc3RlbmVyU3RvcHBlZChldmVudDogRXZlbnQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gY3VycmVudElucHV0LmlzVG91Y2hcbiAgICAgID8gZ2V0SXNDdXN0b21Ub3VjaEJlaGF2aW9yKCkgIT09IGV2ZW50LnR5cGUuaW5kZXhPZigndG91Y2gnKSA+PSAwXG4gICAgICA6IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUG9wcGVySW5zdGFuY2UoKTogdm9pZCB7XG4gICAgZGVzdHJveVBvcHBlckluc3RhbmNlKCk7XG5cbiAgICBjb25zdCB7XG4gICAgICBwb3BwZXJPcHRpb25zLFxuICAgICAgcGxhY2VtZW50LFxuICAgICAgb2Zmc2V0LFxuICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICAgIG1vdmVUcmFuc2l0aW9uLFxuICAgIH0gPSBpbnN0YW5jZS5wcm9wcztcblxuICAgIGNvbnN0IGFycm93ID0gZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSA/IGdldENoaWxkcmVuKHBvcHBlcikuYXJyb3cgOiBudWxsO1xuXG4gICAgY29uc3QgY29tcHV0ZWRSZWZlcmVuY2UgPSBnZXRSZWZlcmVuY2VDbGllbnRSZWN0XG4gICAgICA/IHtcbiAgICAgICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IGdldFJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgICAgICAgY29udGV4dEVsZW1lbnQ6XG4gICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0LmNvbnRleHRFbGVtZW50IHx8IGdldEN1cnJlbnRUYXJnZXQoKSxcbiAgICAgICAgfVxuICAgICAgOiByZWZlcmVuY2U7XG5cbiAgICBjb25zdCB0aXBweU1vZGlmaWVyOiBNb2RpZmllcjwnJCR0aXBweScsIFJlY29yZDxzdHJpbmcsIHVua25vd24+PiA9IHtcbiAgICAgIG5hbWU6ICckJHRpcHB5JyxcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBwaGFzZTogJ2JlZm9yZVdyaXRlJyxcbiAgICAgIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXSxcbiAgICAgIGZuKHtzdGF0ZX0pIHtcbiAgICAgICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgICAgICBjb25zdCB7Ym94fSA9IGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCk7XG5cbiAgICAgICAgICBbJ3BsYWNlbWVudCcsICdyZWZlcmVuY2UtaGlkZGVuJywgJ2VzY2FwZWQnXS5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICAgICAgICBpZiAoYXR0ciA9PT0gJ3BsYWNlbWVudCcpIHtcbiAgICAgICAgICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1wbGFjZW1lbnQnLCBzdGF0ZS5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyW2BkYXRhLXBvcHBlci0ke2F0dHJ9YF0pIHtcbiAgICAgICAgICAgICAgICBib3guc2V0QXR0cmlidXRlKGBkYXRhLSR7YXR0cn1gLCAnJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYm94LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS0ke2F0dHJ9YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0ge307XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHR5cGUgVGlwcHlNb2RpZmllciA9IE1vZGlmaWVyPCckJHRpcHB5JywgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+O1xuICAgIHR5cGUgRXh0ZW5kZWRNb2RpZmllcnMgPSBTdHJpY3RNb2RpZmllcnMgfCBQYXJ0aWFsPFRpcHB5TW9kaWZpZXI+O1xuXG4gICAgY29uc3QgbW9kaWZpZXJzOiBBcnJheTxFeHRlbmRlZE1vZGlmaWVycz4gPSBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgICB0b3A6IDIsXG4gICAgICAgICAgICBib3R0b206IDIsXG4gICAgICAgICAgICBsZWZ0OiA1LFxuICAgICAgICAgICAgcmlnaHQ6IDUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdmbGlwJyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHBhZGRpbmc6IDUsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBhZGFwdGl2ZTogIW1vdmVUcmFuc2l0aW9uLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHRpcHB5TW9kaWZpZXIsXG4gICAgXTtcblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpICYmIGFycm93KSB7XG4gICAgICBtb2RpZmllcnMucHVzaCh7XG4gICAgICAgIG5hbWU6ICdhcnJvdycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBlbGVtZW50OiBhcnJvdyxcbiAgICAgICAgICBwYWRkaW5nOiAzLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbW9kaWZpZXJzLnB1c2goLi4uKHBvcHBlck9wdGlvbnM/Lm1vZGlmaWVycyB8fCBbXSkpO1xuXG4gICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UgPSBjcmVhdGVQb3BwZXI8RXh0ZW5kZWRNb2RpZmllcnM+KFxuICAgICAgY29tcHV0ZWRSZWZlcmVuY2UsXG4gICAgICBwb3BwZXIsXG4gICAgICB7XG4gICAgICAgIC4uLnBvcHBlck9wdGlvbnMsXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgb25GaXJzdFVwZGF0ZSxcbiAgICAgICAgbW9kaWZpZXJzLFxuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95UG9wcGVySW5zdGFuY2UoKTogdm9pZCB7XG4gICAgaWYgKGluc3RhbmNlLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW91bnQoKTogdm9pZCB7XG4gICAgY29uc3Qge2FwcGVuZFRvfSA9IGluc3RhbmNlLnByb3BzO1xuXG4gICAgbGV0IHBhcmVudE5vZGU6IGFueTtcblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlJ2xsIGFwcGVuZCB0aGUgcG9wcGVyIHRvIHRoZSB0cmlnZ2VyVGFyZ2V0cydzIHBhcmVudE5vZGUgc29cbiAgICAvLyBpdCdzIGRpcmVjdGx5IGFmdGVyIHRoZSByZWZlcmVuY2UgZWxlbWVudCBzbyB0aGUgZWxlbWVudHMgaW5zaWRlIHRoZVxuICAgIC8vIHRpcHB5IGNhbiBiZSB0YWJiZWQgdG9cbiAgICAvLyBJZiB0aGVyZSBhcmUgY2xpcHBpbmcgaXNzdWVzLCB0aGUgdXNlciBjYW4gc3BlY2lmeSBhIGRpZmZlcmVudCBhcHBlbmRUb1xuICAgIC8vIGFuZCBlbnN1cmUgZm9jdXMgbWFuYWdlbWVudCBpcyBoYW5kbGVkIGNvcnJlY3RseSBtYW51YWxseVxuICAgIGNvbnN0IG5vZGUgPSBnZXRDdXJyZW50VGFyZ2V0KCk7XG5cbiAgICBpZiAoXG4gICAgICAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgYXBwZW5kVG8gPT09IFRJUFBZX0RFRkFVTFRfQVBQRU5EX1RPKSB8fFxuICAgICAgYXBwZW5kVG8gPT09ICdwYXJlbnQnXG4gICAgKSB7XG4gICAgICBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnROb2RlID0gaW52b2tlV2l0aEFyZ3NPclJldHVybihhcHBlbmRUbywgW25vZGVdKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgcG9wcGVyIGVsZW1lbnQgbmVlZHMgdG8gZXhpc3Qgb24gdGhlIERPTSBiZWZvcmUgaXRzIHBvc2l0aW9uIGNhbiBiZVxuICAgIC8vIHVwZGF0ZWQgYXMgUG9wcGVyIG5lZWRzIHRvIHJlYWQgaXRzIGRpbWVuc2lvbnNcbiAgICBpZiAoIXBhcmVudE5vZGUuY29udGFpbnMocG9wcGVyKSkge1xuICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChwb3BwZXIpO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCA9IHRydWU7XG5cbiAgICBjcmVhdGVQb3BwZXJJbnN0YW5jZSgpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgLy8gQWNjZXNzaWJpbGl0eSBjaGVja1xuICAgICAgd2FybldoZW4oXG4gICAgICAgIGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmXG4gICAgICAgICAgYXBwZW5kVG8gPT09IGRlZmF1bHRQcm9wcy5hcHBlbmRUbyAmJlxuICAgICAgICAgIG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nICE9PSBwb3BwZXIsXG4gICAgICAgIFtcbiAgICAgICAgICAnSW50ZXJhY3RpdmUgdGlwcHkgZWxlbWVudCBtYXkgbm90IGJlIGFjY2Vzc2libGUgdmlhIGtleWJvYXJkJyxcbiAgICAgICAgICAnbmF2aWdhdGlvbiBiZWNhdXNlIGl0IGlzIG5vdCBkaXJlY3RseSBhZnRlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQnLFxuICAgICAgICAgICdpbiB0aGUgRE9NIHNvdXJjZSBvcmRlci4nLFxuICAgICAgICAgICdcXG5cXG4nLFxuICAgICAgICAgICdVc2luZyBhIHdyYXBwZXIgPGRpdj4gb3IgPHNwYW4+IHRhZyBhcm91bmQgdGhlIHJlZmVyZW5jZSBlbGVtZW50JyxcbiAgICAgICAgICAnc29sdmVzIHRoaXMgYnkgY3JlYXRpbmcgYSBuZXcgcGFyZW50Tm9kZSBjb250ZXh0LicsXG4gICAgICAgICAgJ1xcblxcbicsXG4gICAgICAgICAgJ1NwZWNpZnlpbmcgYGFwcGVuZFRvOiBkb2N1bWVudC5ib2R5YCBzaWxlbmNlcyB0aGlzIHdhcm5pbmcsIGJ1dCBpdCcsXG4gICAgICAgICAgJ2Fzc3VtZXMgeW91IGFyZSB1c2luZyBhIGZvY3VzIG1hbmFnZW1lbnQgc29sdXRpb24gdG8gaGFuZGxlJyxcbiAgICAgICAgICAna2V5Ym9hcmQgbmF2aWdhdGlvbi4nLFxuICAgICAgICAgICdcXG5cXG4nLFxuICAgICAgICAgICdTZWU6IGh0dHBzOi8vYXRvbWlrcy5naXRodWIuaW8vdGlwcHlqcy92Ni9hY2Nlc3NpYmlsaXR5LyNpbnRlcmFjdGl2aXR5JyxcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TmVzdGVkUG9wcGVyVHJlZSgpOiBQb3BwZXJFbGVtZW50W10ge1xuICAgIHJldHVybiBhcnJheUZyb20oXG4gICAgICBwb3BwZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtX19OQU1FU1BBQ0VfUFJFRklYX18tcm9vdF0nKVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZVNob3coZXZlbnQ/OiBFdmVudCk6IHZvaWQge1xuICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBpbnZva2VIb29rKCdvblRyaWdnZXInLCBbaW5zdGFuY2UsIGV2ZW50XSk7XG4gICAgfVxuXG4gICAgYWRkRG9jdW1lbnRQcmVzcygpO1xuXG4gICAgbGV0IGRlbGF5ID0gZ2V0RGVsYXkodHJ1ZSk7XG4gICAgY29uc3QgW3RvdWNoVmFsdWUsIHRvdWNoRGVsYXldID0gZ2V0Tm9ybWFsaXplZFRvdWNoU2V0dGluZ3MoKTtcblxuICAgIGlmIChjdXJyZW50SW5wdXQuaXNUb3VjaCAmJiB0b3VjaFZhbHVlID09PSAnaG9sZCcgJiYgdG91Y2hEZWxheSkge1xuICAgICAgZGVsYXkgPSB0b3VjaERlbGF5O1xuICAgIH1cblxuICAgIGlmIChkZWxheSkge1xuICAgICAgc2hvd1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaW5zdGFuY2Uuc2hvdygpO1xuICAgICAgfSwgZGVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVIaWRlKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuXG4gICAgaW52b2tlSG9vaygnb25VbnRyaWdnZXInLCBbaW5zdGFuY2UsIGV2ZW50XSk7XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgcmVtb3ZlRG9jdW1lbnRQcmVzcygpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRm9yIGludGVyYWN0aXZlIHRpcHBpZXMsIHNjaGVkdWxlSGlkZSBpcyBhZGRlZCB0byBhIGRvY3VtZW50LmJvZHkgaGFuZGxlclxuICAgIC8vIGZyb20gb25Nb3VzZUxlYXZlIHNvIG11c3QgaW50ZXJjZXB0IHNjaGVkdWxlZCBoaWRlcyBmcm9tIG1vdXNlbW92ZS9sZWF2ZVxuICAgIC8vIGV2ZW50cyB3aGVuIHRyaWdnZXIgY29udGFpbnMgbW91c2VlbnRlciBhbmQgY2xpY2ssIGFuZCB0aGUgdGlwIGlzXG4gICAgLy8gY3VycmVudGx5IHNob3duIGFzIGEgcmVzdWx0IG9mIGEgY2xpY2suXG4gICAgaWYgKFxuICAgICAgaW5zdGFuY2UucHJvcHMudHJpZ2dlci5pbmRleE9mKCdtb3VzZWVudGVyJykgPj0gMCAmJlxuICAgICAgaW5zdGFuY2UucHJvcHMudHJpZ2dlci5pbmRleE9mKCdjbGljaycpID49IDAgJiZcbiAgICAgIFsnbW91c2VsZWF2ZScsICdtb3VzZW1vdmUnXS5pbmRleE9mKGV2ZW50LnR5cGUpID49IDAgJiZcbiAgICAgIGlzVmlzaWJsZUZyb21DbGlja1xuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRlbGF5ID0gZ2V0RGVsYXkoZmFsc2UpO1xuXG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBoaWRlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpeGVzIGEgYHRyYW5zaXRpb25lbmRgIHByb2JsZW0gd2hlbiBpdCBmaXJlcyAxIGZyYW1lIHRvb1xuICAgICAgLy8gbGF0ZSBzb21ldGltZXMsIHdlIGRvbid0IHdhbnQgaGlkZSgpIHRvIGJlIGNhbGxlZC5cbiAgICAgIHNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIPCflJEgUHVibGljIG1ldGhvZHNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIGVuYWJsZSgpOiB2b2lkIHtcbiAgICBpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlzYWJsZSgpOiB2b2lkIHtcbiAgICAvLyBEaXNhYmxpbmcgdGhlIGluc3RhbmNlIHNob3VsZCBhbHNvIGhpZGUgaXRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXRvbWlrcy90aXBweS5qcy1yZWFjdC9pc3N1ZXMvMTA2XG4gICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgIGluc3RhbmNlLnN0YXRlLmlzRW5hYmxlZCA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJEZWxheVRpbWVvdXRzKCk6IHZvaWQge1xuICAgIGNsZWFyVGltZW91dChzaG93VGltZW91dCk7XG4gICAgY2xlYXJUaW1lb3V0KGhpZGVUaW1lb3V0KTtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZShzY2hlZHVsZUhpZGVBbmltYXRpb25GcmFtZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRQcm9wcyhwYXJ0aWFsUHJvcHM6IFBhcnRpYWw8UHJvcHM+KTogdm9pZCB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdzZXRQcm9wcycpKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnZva2VIb29rKCdvbkJlZm9yZVVwZGF0ZScsIFtpbnN0YW5jZSwgcGFydGlhbFByb3BzXSk7XG5cbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcblxuICAgIGNvbnN0IHByZXZQcm9wcyA9IGluc3RhbmNlLnByb3BzO1xuICAgIGNvbnN0IG5leHRQcm9wcyA9IGV2YWx1YXRlUHJvcHMocmVmZXJlbmNlLCB7XG4gICAgICAuLi5wcmV2UHJvcHMsXG4gICAgICAuLi5yZW1vdmVVbmRlZmluZWRQcm9wcyhwYXJ0aWFsUHJvcHMpLFxuICAgICAgaWdub3JlQXR0cmlidXRlczogdHJ1ZSxcbiAgICB9KTtcblxuICAgIGluc3RhbmNlLnByb3BzID0gbmV4dFByb3BzO1xuXG4gICAgYWRkTGlzdGVuZXJzKCk7XG5cbiAgICBpZiAocHJldlByb3BzLmludGVyYWN0aXZlRGVib3VuY2UgIT09IG5leHRQcm9wcy5pbnRlcmFjdGl2ZURlYm91bmNlKSB7XG4gICAgICBjbGVhbnVwSW50ZXJhY3RpdmVNb3VzZUxpc3RlbmVycygpO1xuICAgICAgZGVib3VuY2VkT25Nb3VzZU1vdmUgPSBkZWJvdW5jZShcbiAgICAgICAgb25Nb3VzZU1vdmUsXG4gICAgICAgIG5leHRQcm9wcy5pbnRlcmFjdGl2ZURlYm91bmNlXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBzdGFsZSBhcmlhLWV4cGFuZGVkIGF0dHJpYnV0ZXMgYXJlIHJlbW92ZWRcbiAgICBpZiAocHJldlByb3BzLnRyaWdnZXJUYXJnZXQgJiYgIW5leHRQcm9wcy50cmlnZ2VyVGFyZ2V0KSB7XG4gICAgICBub3JtYWxpemVUb0FycmF5KHByZXZQcm9wcy50cmlnZ2VyVGFyZ2V0KS5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wcy50cmlnZ2VyVGFyZ2V0KSB7XG4gICAgICByZWZlcmVuY2UucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJyk7XG4gICAgfVxuXG4gICAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG4gICAgaGFuZGxlU3R5bGVzKCk7XG5cbiAgICBpZiAob25VcGRhdGUpIHtcbiAgICAgIG9uVXBkYXRlKHByZXZQcm9wcywgbmV4dFByb3BzKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgIGNyZWF0ZVBvcHBlckluc3RhbmNlKCk7XG5cbiAgICAgIC8vIEZpeGVzIGFuIGlzc3VlIHdpdGggbmVzdGVkIHRpcHBpZXMgaWYgdGhleSBhcmUgYWxsIGdldHRpbmcgcmUtcmVuZGVyZWQsXG4gICAgICAvLyBhbmQgdGhlIG5lc3RlZCBvbmVzIGdldCByZS1yZW5kZXJlZCBmaXJzdC5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hdG9taWtzL3RpcHB5anMtcmVhY3QvaXNzdWVzLzE3N1xuICAgICAgLy8gVE9ETzogZmluZCBhIGNsZWFuZXIgLyBtb3JlIGVmZmljaWVudCBzb2x1dGlvbighKVxuICAgICAgZ2V0TmVzdGVkUG9wcGVyVHJlZSgpLmZvckVhY2goKG5lc3RlZFBvcHBlcikgPT4ge1xuICAgICAgICAvLyBSZWFjdCAoYW5kIG90aGVyIFVJIGxpYnMgbGlrZWx5KSByZXF1aXJlcyBhIHJBRiB3cmFwcGVyIGFzIGl0IGZsdXNoZXNcbiAgICAgICAgLy8gaXRzIHdvcmsgaW4gb25lXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShuZXN0ZWRQb3BwZXIuX3RpcHB5IS5wb3BwZXJJbnN0YW5jZSEuZm9yY2VVcGRhdGUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25BZnRlclVwZGF0ZScsIFtpbnN0YW5jZSwgcGFydGlhbFByb3BzXSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDb250ZW50KGNvbnRlbnQ6IENvbnRlbnQpOiB2b2lkIHtcbiAgICBpbnN0YW5jZS5zZXRQcm9wcyh7Y29udGVudH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdygpOiB2b2lkIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCwgY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcoJ3Nob3cnKSk7XG4gICAgfVxuXG4gICAgLy8gRWFybHkgYmFpbC1vdXRcbiAgICBjb25zdCBpc0FscmVhZHlWaXNpYmxlID0gaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlO1xuICAgIGNvbnN0IGlzRGVzdHJveWVkID0gaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQ7XG4gICAgY29uc3QgaXNEaXNhYmxlZCA9ICFpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQ7XG4gICAgY29uc3QgaXNUb3VjaEFuZFRvdWNoRGlzYWJsZWQgPVxuICAgICAgY3VycmVudElucHV0LmlzVG91Y2ggJiYgIWluc3RhbmNlLnByb3BzLnRvdWNoO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4oXG4gICAgICBpbnN0YW5jZS5wcm9wcy5kdXJhdGlvbixcbiAgICAgIDAsXG4gICAgICBkZWZhdWx0UHJvcHMuZHVyYXRpb25cbiAgICApO1xuXG4gICAgaWYgKFxuICAgICAgaXNBbHJlYWR5VmlzaWJsZSB8fFxuICAgICAgaXNEZXN0cm95ZWQgfHxcbiAgICAgIGlzRGlzYWJsZWQgfHxcbiAgICAgIGlzVG91Y2hBbmRUb3VjaERpc2FibGVkXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsaXplIGBkaXNhYmxlZGAgYmVoYXZpb3IgYWNyb3NzIGJyb3dzZXJzLlxuICAgIC8vIEZpcmVmb3ggYWxsb3dzIGV2ZW50cyBvbiBkaXNhYmxlZCBlbGVtZW50cywgYnV0IENocm9tZSBkb2Vzbid0LlxuICAgIC8vIFVzaW5nIGEgd3JhcHBlciBlbGVtZW50IChpLmUuIDxzcGFuPikgaXMgcmVjb21tZW5kZWQuXG4gICAgaWYgKGdldEN1cnJlbnRUYXJnZXQoKS5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnZva2VIb29rKCdvblNob3cnLCBbaW5zdGFuY2VdLCBmYWxzZSk7XG4gICAgaWYgKGluc3RhbmNlLnByb3BzLm9uU2hvdyhpbnN0YW5jZSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlID0gdHJ1ZTtcblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICBwb3BwZXIuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICB9XG5cbiAgICBoYW5kbGVTdHlsZXMoKTtcbiAgICBhZGREb2N1bWVudFByZXNzKCk7XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgcG9wcGVyLnN0eWxlLnRyYW5zaXRpb24gPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgLy8gSWYgZmxpcHBpbmcgdG8gdGhlIG9wcG9zaXRlIHNpZGUgYWZ0ZXIgaGlkaW5nIGF0IGxlYXN0IG9uY2UsIHRoZVxuICAgIC8vIGFuaW1hdGlvbiB3aWxsIHVzZSB0aGUgd3JvbmcgcGxhY2VtZW50IHdpdGhvdXQgcmVzZXR0aW5nIHRoZSBkdXJhdGlvblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICBjb25zdCB7Ym94LCBjb250ZW50fSA9IGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCk7XG4gICAgICBzZXRUcmFuc2l0aW9uRHVyYXRpb24oW2JveCwgY29udGVudF0sIDApO1xuICAgIH1cblxuICAgIG9uRmlyc3RVcGRhdGUgPSAoKTogdm9pZCA9PiB7XG4gICAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSB8fCBpZ25vcmVPbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWdub3JlT25GaXJzdFVwZGF0ZSA9IHRydWU7XG5cbiAgICAgIC8vIHJlZmxvd1xuICAgICAgdm9pZCBwb3BwZXIub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICBwb3BwZXIuc3R5bGUudHJhbnNpdGlvbiA9IGluc3RhbmNlLnByb3BzLm1vdmVUcmFuc2l0aW9uO1xuXG4gICAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSAmJiBpbnN0YW5jZS5wcm9wcy5hbmltYXRpb24pIHtcbiAgICAgICAgY29uc3Qge2JveCwgY29udGVudH0gPSBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpO1xuICAgICAgICBzZXRUcmFuc2l0aW9uRHVyYXRpb24oW2JveCwgY29udGVudF0sIGR1cmF0aW9uKTtcbiAgICAgICAgc2V0VmlzaWJpbGl0eVN0YXRlKFtib3gsIGNvbnRlbnRdLCAndmlzaWJsZScpO1xuICAgICAgfVxuXG4gICAgICBoYW5kbGVBcmlhQ29udGVudEF0dHJpYnV0ZSgpO1xuICAgICAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG5cbiAgICAgIHB1c2hJZlVuaXF1ZShtb3VudGVkSW5zdGFuY2VzLCBpbnN0YW5jZSk7XG5cbiAgICAgIC8vIGNlcnRhaW4gbW9kaWZpZXJzIChlLmcuIGBtYXhTaXplYCkgcmVxdWlyZSBhIHNlY29uZCB1cGRhdGUgYWZ0ZXIgdGhlXG4gICAgICAvLyBwb3BwZXIgaGFzIGJlZW4gcG9zaXRpb25lZCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlPy5mb3JjZVVwZGF0ZSgpO1xuXG4gICAgICBpbnZva2VIb29rKCdvbk1vdW50JywgW2luc3RhbmNlXSk7XG5cbiAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5hbmltYXRpb24gJiYgZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgICBvblRyYW5zaXRpb25lZEluKGR1cmF0aW9uLCAoKSA9PiB7XG4gICAgICAgICAgaW5zdGFuY2Uuc3RhdGUuaXNTaG93biA9IHRydWU7XG4gICAgICAgICAgaW52b2tlSG9vaygnb25TaG93bicsIFtpbnN0YW5jZV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbW91bnQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZGUoKTogdm9pZCB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdoaWRlJykpO1xuICAgIH1cblxuICAgIC8vIEVhcmx5IGJhaWwtb3V0XG4gICAgY29uc3QgaXNBbHJlYWR5SGlkZGVuID0gIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZTtcbiAgICBjb25zdCBpc0Rlc3Ryb3llZCA9IGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkO1xuICAgIGNvbnN0IGlzRGlzYWJsZWQgPSAhaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4oXG4gICAgICBpbnN0YW5jZS5wcm9wcy5kdXJhdGlvbixcbiAgICAgIDEsXG4gICAgICBkZWZhdWx0UHJvcHMuZHVyYXRpb25cbiAgICApO1xuXG4gICAgaWYgKGlzQWxyZWFkeUhpZGRlbiB8fCBpc0Rlc3Ryb3llZCB8fCBpc0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25IaWRlJywgW2luc3RhbmNlXSwgZmFsc2UpO1xuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5vbkhpZGUoaW5zdGFuY2UpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgIGluc3RhbmNlLnN0YXRlLmlzU2hvd24gPSBmYWxzZTtcbiAgICBpZ25vcmVPbkZpcnN0VXBkYXRlID0gZmFsc2U7XG4gICAgaXNWaXNpYmxlRnJvbUNsaWNrID0gZmFsc2U7XG5cbiAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgcG9wcGVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICB9XG5cbiAgICBjbGVhbnVwSW50ZXJhY3RpdmVNb3VzZUxpc3RlbmVycygpO1xuICAgIHJlbW92ZURvY3VtZW50UHJlc3MoKTtcbiAgICBoYW5kbGVTdHlsZXModHJ1ZSk7XG5cbiAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgY29uc3Qge2JveCwgY29udGVudH0gPSBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpO1xuXG4gICAgICBpZiAoaW5zdGFuY2UucHJvcHMuYW5pbWF0aW9uKSB7XG4gICAgICAgIHNldFRyYW5zaXRpb25EdXJhdGlvbihbYm94LCBjb250ZW50XSwgZHVyYXRpb24pO1xuICAgICAgICBzZXRWaXNpYmlsaXR5U3RhdGUoW2JveCwgY29udGVudF0sICdoaWRkZW4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVBcmlhQ29udGVudEF0dHJpYnV0ZSgpO1xuICAgIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmFuaW1hdGlvbikge1xuICAgICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgICAgb25UcmFuc2l0aW9uZWRPdXQoZHVyYXRpb24sIGluc3RhbmNlLnVubW91bnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS51bm1vdW50KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGlkZVdpdGhJbnRlcmFjdGl2aXR5KGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgd2FybldoZW4oXG4gICAgICAgIGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLFxuICAgICAgICBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnaGlkZVdpdGhJbnRlcmFjdGl2aXR5JylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0RG9jdW1lbnQoKS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBkZWJvdW5jZWRPbk1vdXNlTW92ZSk7XG4gICAgcHVzaElmVW5pcXVlKG1vdXNlTW92ZUxpc3RlbmVycywgZGVib3VuY2VkT25Nb3VzZU1vdmUpO1xuICAgIGRlYm91bmNlZE9uTW91c2VNb3ZlKGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVubW91bnQoKTogdm9pZCB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCd1bm1vdW50JykpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIGluc3RhbmNlLmhpZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRlc3Ryb3lQb3BwZXJJbnN0YW5jZSgpO1xuXG4gICAgLy8gSWYgYSBwb3BwZXIgaXMgbm90IGludGVyYWN0aXZlLCBpdCB3aWxsIGJlIGFwcGVuZGVkIG91dHNpZGUgdGhlIHBvcHBlclxuICAgIC8vIHRyZWUgYnkgZGVmYXVsdC4gVGhpcyBzZWVtcyBtYWlubHkgZm9yIGludGVyYWN0aXZlIHRpcHBpZXMsIGJ1dCB3ZSBzaG91bGRcbiAgICAvLyBmaW5kIGEgd29ya2Fyb3VuZCBpZiBwb3NzaWJsZVxuICAgIGdldE5lc3RlZFBvcHBlclRyZWUoKS5mb3JFYWNoKChuZXN0ZWRQb3BwZXIpID0+IHtcbiAgICAgIG5lc3RlZFBvcHBlci5fdGlwcHkhLnVubW91bnQoKTtcbiAgICB9KTtcblxuICAgIGlmIChwb3BwZXIucGFyZW50Tm9kZSkge1xuICAgICAgcG9wcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocG9wcGVyKTtcbiAgICB9XG5cbiAgICBtb3VudGVkSW5zdGFuY2VzID0gbW91bnRlZEluc3RhbmNlcy5maWx0ZXIoKGkpID0+IGkgIT09IGluc3RhbmNlKTtcblxuICAgIGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCA9IGZhbHNlO1xuICAgIGludm9rZUhvb2soJ29uSGlkZGVuJywgW2luc3RhbmNlXSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCk6IHZvaWQge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnZGVzdHJveScpKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcbiAgICBpbnN0YW5jZS51bm1vdW50KCk7XG5cbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcblxuICAgIGRlbGV0ZSByZWZlcmVuY2UuX3RpcHB5O1xuXG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQgPSB0cnVlO1xuXG4gICAgaW52b2tlSG9vaygnb25EZXN0cm95JywgW2luc3RhbmNlXSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgYmluZEdsb2JhbEV2ZW50TGlzdGVuZXJzLCB7XG4gIGN1cnJlbnRJbnB1dCxcbn0gZnJvbSAnLi9iaW5kR2xvYmFsRXZlbnRMaXN0ZW5lcnMnO1xuaW1wb3J0IGNyZWF0ZVRpcHB5LCB7bW91bnRlZEluc3RhbmNlc30gZnJvbSAnLi9jcmVhdGVUaXBweSc7XG5pbXBvcnQge2dldEFycmF5T2ZFbGVtZW50cywgaXNFbGVtZW50LCBpc1JlZmVyZW5jZUVsZW1lbnR9IGZyb20gJy4vZG9tLXV0aWxzJztcbmltcG9ydCB7ZGVmYXVsdFByb3BzLCBzZXREZWZhdWx0UHJvcHMsIHZhbGlkYXRlUHJvcHN9IGZyb20gJy4vcHJvcHMnO1xuaW1wb3J0IHtIaWRlQWxsLCBIaWRlQWxsT3B0aW9ucywgSW5zdGFuY2UsIFByb3BzLCBUYXJnZXRzfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7dmFsaWRhdGVUYXJnZXRzLCB3YXJuV2hlbn0gZnJvbSAnLi92YWxpZGF0aW9uJztcblxuZnVuY3Rpb24gdGlwcHkoXG4gIHRhcmdldHM6IFRhcmdldHMsXG4gIG9wdGlvbmFsUHJvcHM6IFBhcnRpYWw8UHJvcHM+ID0ge31cbik6IEluc3RhbmNlIHwgSW5zdGFuY2VbXSB7XG4gIGNvbnN0IHBsdWdpbnMgPSBkZWZhdWx0UHJvcHMucGx1Z2lucy5jb25jYXQob3B0aW9uYWxQcm9wcy5wbHVnaW5zIHx8IFtdKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoX19ERVZfXykge1xuICAgIHZhbGlkYXRlVGFyZ2V0cyh0YXJnZXRzKTtcbiAgICB2YWxpZGF0ZVByb3BzKG9wdGlvbmFsUHJvcHMsIHBsdWdpbnMpO1xuICB9XG5cbiAgYmluZEdsb2JhbEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgY29uc3QgcGFzc2VkUHJvcHM6IFBhcnRpYWw8UHJvcHM+ID0gey4uLm9wdGlvbmFsUHJvcHMsIHBsdWdpbnN9O1xuXG4gIGNvbnN0IGVsZW1lbnRzID0gZ2V0QXJyYXlPZkVsZW1lbnRzKHRhcmdldHMpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgY29uc3QgaXNTaW5nbGVDb250ZW50RWxlbWVudCA9IGlzRWxlbWVudChwYXNzZWRQcm9wcy5jb250ZW50KTtcbiAgICBjb25zdCBpc01vcmVUaGFuT25lUmVmZXJlbmNlRWxlbWVudCA9IGVsZW1lbnRzLmxlbmd0aCA+IDE7XG4gICAgd2FybldoZW4oXG4gICAgICBpc1NpbmdsZUNvbnRlbnRFbGVtZW50ICYmIGlzTW9yZVRoYW5PbmVSZWZlcmVuY2VFbGVtZW50LFxuICAgICAgW1xuICAgICAgICAndGlwcHkoKSB3YXMgcGFzc2VkIGFuIEVsZW1lbnQgYXMgdGhlIGBjb250ZW50YCBwcm9wLCBidXQgbW9yZSB0aGFuJyxcbiAgICAgICAgJ29uZSB0aXBweSBpbnN0YW5jZSB3YXMgY3JlYXRlZCBieSB0aGlzIGludm9jYXRpb24uIFRoaXMgbWVhbnMgdGhlJyxcbiAgICAgICAgJ2NvbnRlbnQgZWxlbWVudCB3aWxsIG9ubHkgYmUgYXBwZW5kZWQgdG8gdGhlIGxhc3QgdGlwcHkgaW5zdGFuY2UuJyxcbiAgICAgICAgJ1xcblxcbicsXG4gICAgICAgICdJbnN0ZWFkLCBwYXNzIHRoZSAuaW5uZXJIVE1MIG9mIHRoZSBlbGVtZW50LCBvciB1c2UgYSBmdW5jdGlvbiB0aGF0JyxcbiAgICAgICAgJ3JldHVybnMgYSBjbG9uZWQgdmVyc2lvbiBvZiB0aGUgZWxlbWVudCBpbnN0ZWFkLicsXG4gICAgICAgICdcXG5cXG4nLFxuICAgICAgICAnMSkgY29udGVudDogZWxlbWVudC5pbm5lckhUTUxcXG4nLFxuICAgICAgICAnMikgY29udGVudDogKCkgPT4gZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSknLFxuICAgICAgXS5qb2luKCcgJylcbiAgICApO1xuICB9XG5cbiAgY29uc3QgaW5zdGFuY2VzID0gZWxlbWVudHMucmVkdWNlPEluc3RhbmNlW10+KFxuICAgIChhY2MsIHJlZmVyZW5jZSk6IEluc3RhbmNlW10gPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSByZWZlcmVuY2UgJiYgY3JlYXRlVGlwcHkocmVmZXJlbmNlLCBwYXNzZWRQcm9wcyk7XG5cbiAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICBhY2MucHVzaChpbnN0YW5jZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSxcbiAgICBbXVxuICApO1xuXG4gIHJldHVybiBpc0VsZW1lbnQodGFyZ2V0cykgPyBpbnN0YW5jZXNbMF0gOiBpbnN0YW5jZXM7XG59XG5cbnRpcHB5LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbnRpcHB5LnNldERlZmF1bHRQcm9wcyA9IHNldERlZmF1bHRQcm9wcztcbnRpcHB5LmN1cnJlbnRJbnB1dCA9IGN1cnJlbnRJbnB1dDtcblxuZXhwb3J0IGRlZmF1bHQgdGlwcHk7XG5cbmV4cG9ydCBjb25zdCBoaWRlQWxsOiBIaWRlQWxsID0gKHtcbiAgZXhjbHVkZTogZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlLFxuICBkdXJhdGlvbixcbn06IEhpZGVBbGxPcHRpb25zID0ge30pID0+IHtcbiAgbW91bnRlZEluc3RhbmNlcy5mb3JFYWNoKChpbnN0YW5jZSkgPT4ge1xuICAgIGxldCBpc0V4Y2x1ZGVkID0gZmFsc2U7XG5cbiAgICBpZiAoZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlKSB7XG4gICAgICBpc0V4Y2x1ZGVkID0gaXNSZWZlcmVuY2VFbGVtZW50KGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSlcbiAgICAgICAgPyBpbnN0YW5jZS5yZWZlcmVuY2UgPT09IGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZVxuICAgICAgICA6IGluc3RhbmNlLnBvcHBlciA9PT0gKGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSBhcyBJbnN0YW5jZSkucG9wcGVyO1xuICAgIH1cblxuICAgIGlmICghaXNFeGNsdWRlZCkge1xuICAgICAgY29uc3Qgb3JpZ2luYWxEdXJhdGlvbiA9IGluc3RhbmNlLnByb3BzLmR1cmF0aW9uO1xuXG4gICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7ZHVyYXRpb259KTtcbiAgICAgIGluc3RhbmNlLmhpZGUoKTtcblxuICAgICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7ZHVyYXRpb246IG9yaWdpbmFsRHVyYXRpb259KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcbiIsICJpbXBvcnQgdGlwcHkgZnJvbSAnLi4nO1xuaW1wb3J0IHtkaXZ9IGZyb20gJy4uL2RvbS11dGlscyc7XG5pbXBvcnQge1xuICBDcmVhdGVTaW5nbGV0b24sXG4gIFBsdWdpbixcbiAgQ3JlYXRlU2luZ2xldG9uUHJvcHMsXG4gIFJlZmVyZW5jZUVsZW1lbnQsXG4gIENyZWF0ZVNpbmdsZXRvbkluc3RhbmNlLFxuICBJbnN0YW5jZSxcbiAgUHJvcHMsXG59IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7bm9ybWFsaXplVG9BcnJheSwgcmVtb3ZlUHJvcGVydGllc30gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHtlcnJvcldoZW59IGZyb20gJy4uL3ZhbGlkYXRpb24nO1xuaW1wb3J0IHthcHBseVN0eWxlcywgTW9kaWZpZXJ9IGZyb20gJ0Bwb3BwZXJqcy9jb3JlJztcblxuLy8gVGhlIGRlZmF1bHQgYGFwcGx5U3R5bGVzYCBtb2RpZmllciBoYXMgYSBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWRcbi8vIGV2ZXJ5IHRpbWUgdGhlIHBvcHBlciBpcyBkZXN0cm95ZWQgKGkuZS4gYSBuZXcgdGFyZ2V0KSwgcmVtb3ZpbmcgdGhlIHN0eWxlc1xuLy8gYW5kIGNhdXNpbmcgdHJhbnNpdGlvbnMgdG8gYnJlYWsgZm9yIHNpbmdsZXRvbnMgd2hlbiB0aGUgY29uc29sZSBpcyBvcGVuLCBidXRcbi8vIG1vc3Qgbm90YWJseSBmb3Igbm9uLXRyYW5zZm9ybSBzdHlsZXMgYmVpbmcgdXNlZCwgYGdwdUFjY2VsZXJhdGlvbjogZmFsc2VgLlxuY29uc3QgYXBwbHlTdHlsZXNNb2RpZmllcjogTW9kaWZpZXI8J2FwcGx5U3R5bGVzJywgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+ID0ge1xuICAuLi5hcHBseVN0eWxlcyxcbiAgZWZmZWN0KHtzdGF0ZX0pIHtcbiAgICBjb25zdCBpbml0aWFsU3R5bGVzID0ge1xuICAgICAgcG9wcGVyOiB7XG4gICAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgICBsZWZ0OiAnMCcsXG4gICAgICAgIHRvcDogJzAnLFxuICAgICAgICBtYXJnaW46ICcwJyxcbiAgICAgIH0sXG4gICAgICBhcnJvdzoge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIH0sXG4gICAgICByZWZlcmVuY2U6IHt9LFxuICAgIH07XG5cbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgaW5pdGlhbFN0eWxlcy5wb3BwZXIpO1xuICAgIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGluaXRpYWxTdHlsZXMuYXJyb3cpO1xuICAgIH1cblxuICAgIC8vIGludGVudGlvbmFsbHkgcmV0dXJuIG5vIGNsZWFudXAgZnVuY3Rpb25cbiAgICAvLyByZXR1cm4gKCkgPT4geyAuLi4gfVxuICB9LFxufTtcblxuY29uc3QgY3JlYXRlU2luZ2xldG9uOiBDcmVhdGVTaW5nbGV0b24gPSAoXG4gIHRpcHB5SW5zdGFuY2VzLFxuICBvcHRpb25hbFByb3BzID0ge31cbikgPT4ge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoX19ERVZfXykge1xuICAgIGVycm9yV2hlbihcbiAgICAgICFBcnJheS5pc0FycmF5KHRpcHB5SW5zdGFuY2VzKSxcbiAgICAgIFtcbiAgICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gY3JlYXRlU2luZ2xldG9uKCkgbXVzdCBiZSBhbiBhcnJheSBvZicsXG4gICAgICAgICd0aXBweSBpbnN0YW5jZXMuIFRoZSBwYXNzZWQgdmFsdWUgd2FzJyxcbiAgICAgICAgU3RyaW5nKHRpcHB5SW5zdGFuY2VzKSxcbiAgICAgIF0uam9pbignICcpXG4gICAgKTtcbiAgfVxuXG4gIGxldCBpbmRpdmlkdWFsSW5zdGFuY2VzID0gdGlwcHlJbnN0YW5jZXM7XG4gIGxldCByZWZlcmVuY2VzOiBBcnJheTxSZWZlcmVuY2VFbGVtZW50PiA9IFtdO1xuICBsZXQgdHJpZ2dlclRhcmdldHM6IEFycmF5PEVsZW1lbnQ+ID0gW107XG4gIGxldCBjdXJyZW50VGFyZ2V0OiBFbGVtZW50IHwgbnVsbDtcbiAgbGV0IG92ZXJyaWRlcyA9IG9wdGlvbmFsUHJvcHMub3ZlcnJpZGVzO1xuICBsZXQgaW50ZXJjZXB0U2V0UHJvcHNDbGVhbnVwczogQXJyYXk8KCkgPT4gdm9pZD4gPSBbXTtcbiAgbGV0IHNob3duT25DcmVhdGUgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBzZXRUcmlnZ2VyVGFyZ2V0cygpOiB2b2lkIHtcbiAgICB0cmlnZ2VyVGFyZ2V0cyA9IGluZGl2aWR1YWxJbnN0YW5jZXNcbiAgICAgIC5tYXAoKGluc3RhbmNlKSA9PlxuICAgICAgICBub3JtYWxpemVUb0FycmF5KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgaW5zdGFuY2UucmVmZXJlbmNlKVxuICAgICAgKVxuICAgICAgLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiBhY2MuY29uY2F0KGl0ZW0pLCBbXSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRSZWZlcmVuY2VzKCk6IHZvaWQge1xuICAgIHJlZmVyZW5jZXMgPSBpbmRpdmlkdWFsSW5zdGFuY2VzLm1hcCgoaW5zdGFuY2UpID0+IGluc3RhbmNlLnJlZmVyZW5jZSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmFibGVJbnN0YW5jZXMoaXNFbmFibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgaW5kaXZpZHVhbEluc3RhbmNlcy5mb3JFYWNoKChpbnN0YW5jZSkgPT4ge1xuICAgICAgaWYgKGlzRW5hYmxlZCkge1xuICAgICAgICBpbnN0YW5jZS5lbmFibGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLmRpc2FibGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVyY2VwdFNldFByb3BzKHNpbmdsZXRvbjogSW5zdGFuY2UpOiBBcnJheTwoKSA9PiB2b2lkPiB7XG4gICAgcmV0dXJuIGluZGl2aWR1YWxJbnN0YW5jZXMubWFwKChpbnN0YW5jZSkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxTZXRQcm9wcyA9IGluc3RhbmNlLnNldFByb3BzO1xuXG4gICAgICBpbnN0YW5jZS5zZXRQcm9wcyA9IChwcm9wcyk6IHZvaWQgPT4ge1xuICAgICAgICBvcmlnaW5hbFNldFByb3BzKHByb3BzKTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UucmVmZXJlbmNlID09PSBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgc2luZ2xldG9uLnNldFByb3BzKHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuICgpOiB2b2lkID0+IHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMgPSBvcmlnaW5hbFNldFByb3BzO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGhhdmUgdG8gcGFzcyBzaW5nbGV0b24sIGFzIGl0IG1heWJlIHVuZGVmaW5lZCBvbiBmaXJzdCBjYWxsXG4gIGZ1bmN0aW9uIHByZXBhcmVJbnN0YW5jZShcbiAgICBzaW5nbGV0b246IEluc3RhbmNlLFxuICAgIHRhcmdldDogUmVmZXJlbmNlRWxlbWVudFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBpbmRleCA9IHRyaWdnZXJUYXJnZXRzLmluZGV4T2YodGFyZ2V0KTtcblxuICAgIC8vIGJhaWwtb3V0XG4gICAgaWYgKHRhcmdldCA9PT0gY3VycmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN1cnJlbnRUYXJnZXQgPSB0YXJnZXQ7XG5cbiAgICBjb25zdCBvdmVycmlkZVByb3BzOiBQYXJ0aWFsPFByb3BzPiA9IChvdmVycmlkZXMgfHwgW10pXG4gICAgICAuY29uY2F0KCdjb250ZW50JylcbiAgICAgIC5yZWR1Y2UoKGFjYywgcHJvcCkgPT4ge1xuICAgICAgICAoYWNjIGFzIGFueSlbcHJvcF0gPSBpbmRpdmlkdWFsSW5zdGFuY2VzW2luZGV4XS5wcm9wc1twcm9wXTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9KTtcblxuICAgIHNpbmdsZXRvbi5zZXRQcm9wcyh7XG4gICAgICAuLi5vdmVycmlkZVByb3BzLFxuICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDpcbiAgICAgICAgdHlwZW9mIG92ZXJyaWRlUHJvcHMuZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gb3ZlcnJpZGVQcm9wcy5nZXRSZWZlcmVuY2VDbGllbnRSZWN0XG4gICAgICAgICAgOiAoKTogQ2xpZW50UmVjdCA9PiByZWZlcmVuY2VzW2luZGV4XT8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgfSk7XG4gIH1cblxuICBlbmFibGVJbnN0YW5jZXMoZmFsc2UpO1xuICBzZXRSZWZlcmVuY2VzKCk7XG4gIHNldFRyaWdnZXJUYXJnZXRzKCk7XG5cbiAgY29uc3QgcGx1Z2luOiBQbHVnaW4gPSB7XG4gICAgZm4oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgICAgZW5hYmxlSW5zdGFuY2VzKHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBvbkhpZGRlbigpOiB2b2lkIHtcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgb25DbGlja091dHNpZGUoaW5zdGFuY2UpOiB2b2lkIHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMuc2hvd09uQ3JlYXRlICYmICFzaG93bk9uQ3JlYXRlKSB7XG4gICAgICAgICAgICBzaG93bk9uQ3JlYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25TaG93KGluc3RhbmNlKTogdm9pZCB7XG4gICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzLnNob3dPbkNyZWF0ZSAmJiAhc2hvd25PbkNyZWF0ZSkge1xuICAgICAgICAgICAgc2hvd25PbkNyZWF0ZSA9IHRydWU7XG4gICAgICAgICAgICBwcmVwYXJlSW5zdGFuY2UoaW5zdGFuY2UsIHJlZmVyZW5jZXNbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25UcmlnZ2VyKGluc3RhbmNlLCBldmVudCk6IHZvaWQge1xuICAgICAgICAgIHByZXBhcmVJbnN0YW5jZShpbnN0YW5jZSwgZXZlbnQuY3VycmVudFRhcmdldCBhcyBFbGVtZW50KTtcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSxcbiAgfTtcblxuICBjb25zdCBzaW5nbGV0b24gPSB0aXBweShkaXYoKSwge1xuICAgIC4uLnJlbW92ZVByb3BlcnRpZXMob3B0aW9uYWxQcm9wcywgWydvdmVycmlkZXMnXSksXG4gICAgcGx1Z2luczogW3BsdWdpbiwgLi4uKG9wdGlvbmFsUHJvcHMucGx1Z2lucyB8fCBbXSldLFxuICAgIHRyaWdnZXJUYXJnZXQ6IHRyaWdnZXJUYXJnZXRzLFxuICAgIHBvcHBlck9wdGlvbnM6IHtcbiAgICAgIC4uLm9wdGlvbmFsUHJvcHMucG9wcGVyT3B0aW9ucyxcbiAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICAuLi4ob3B0aW9uYWxQcm9wcy5wb3BwZXJPcHRpb25zPy5tb2RpZmllcnMgfHwgW10pLFxuICAgICAgICBhcHBseVN0eWxlc01vZGlmaWVyLFxuICAgICAgXSxcbiAgICB9LFxuICB9KSBhcyBDcmVhdGVTaW5nbGV0b25JbnN0YW5jZTxDcmVhdGVTaW5nbGV0b25Qcm9wcz47XG5cbiAgY29uc3Qgb3JpZ2luYWxTaG93ID0gc2luZ2xldG9uLnNob3c7XG5cbiAgc2luZ2xldG9uLnNob3cgPSAodGFyZ2V0PzogUmVmZXJlbmNlRWxlbWVudCB8IEluc3RhbmNlIHwgbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgb3JpZ2luYWxTaG93KCk7XG5cbiAgICAvLyBmaXJzdCB0aW1lLCBzaG93T25DcmVhdGUgb3IgcHJvZ3JhbW1hdGljIGNhbGwgd2l0aCBubyBwYXJhbXNcbiAgICAvLyBkZWZhdWx0IHRvIHNob3dpbmcgZmlyc3QgaW5zdGFuY2VcbiAgICBpZiAoIWN1cnJlbnRUYXJnZXQgJiYgdGFyZ2V0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBwcmVwYXJlSW5zdGFuY2Uoc2luZ2xldG9uLCByZWZlcmVuY2VzWzBdKTtcbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyZWQgZnJvbSBldmVudCAoZG8gbm90aGluZyBhcyBwcmVwYXJlSW5zdGFuY2UgYWxyZWFkeSBjYWxsZWQgYnkgb25UcmlnZ2VyKVxuICAgIC8vIHByb2dyYW1tYXRpYyBjYWxsIHdpdGggbm8gcGFyYW1zIHdoZW4gYWxyZWFkeSB2aXNpYmxlIChkbyBub3RoaW5nIGFnYWluKVxuICAgIGlmIChjdXJyZW50VGFyZ2V0ICYmIHRhcmdldCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdGFyZ2V0IGlzIGluZGV4IG9mIGluc3RhbmNlXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICByZWZlcmVuY2VzW3RhcmdldF0gJiYgcHJlcGFyZUluc3RhbmNlKHNpbmdsZXRvbiwgcmVmZXJlbmNlc1t0YXJnZXRdKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyB0YXJnZXQgaXMgYSBjaGlsZCB0aXBweSBpbnN0YW5jZVxuICAgIGlmIChpbmRpdmlkdWFsSW5zdGFuY2VzLmluZGV4T2YodGFyZ2V0IGFzIEluc3RhbmNlKSA+PSAwKSB7XG4gICAgICBjb25zdCByZWYgPSAodGFyZ2V0IGFzIEluc3RhbmNlKS5yZWZlcmVuY2U7XG4gICAgICByZXR1cm4gcHJlcGFyZUluc3RhbmNlKHNpbmdsZXRvbiwgcmVmKTtcbiAgICB9XG5cbiAgICAvLyB0YXJnZXQgaXMgYSBSZWZlcmVuY2VFbGVtZW50XG4gICAgaWYgKHJlZmVyZW5jZXMuaW5kZXhPZih0YXJnZXQgYXMgUmVmZXJlbmNlRWxlbWVudCkgPj0gMCkge1xuICAgICAgcmV0dXJuIHByZXBhcmVJbnN0YW5jZShzaW5nbGV0b24sIHRhcmdldCBhcyBSZWZlcmVuY2VFbGVtZW50KTtcbiAgICB9XG4gIH07XG5cbiAgc2luZ2xldG9uLnNob3dOZXh0ID0gKCk6IHZvaWQgPT4ge1xuICAgIGNvbnN0IGZpcnN0ID0gcmVmZXJlbmNlc1swXTtcbiAgICBpZiAoIWN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybiBzaW5nbGV0b24uc2hvdygwKTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSByZWZlcmVuY2VzLmluZGV4T2YoY3VycmVudFRhcmdldCk7XG4gICAgc2luZ2xldG9uLnNob3cocmVmZXJlbmNlc1tpbmRleCArIDFdIHx8IGZpcnN0KTtcbiAgfTtcblxuICBzaW5nbGV0b24uc2hvd1ByZXZpb3VzID0gKCk6IHZvaWQgPT4ge1xuICAgIGNvbnN0IGxhc3QgPSByZWZlcmVuY2VzW3JlZmVyZW5jZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKCFjdXJyZW50VGFyZ2V0KSB7XG4gICAgICByZXR1cm4gc2luZ2xldG9uLnNob3cobGFzdCk7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gcmVmZXJlbmNlcy5pbmRleE9mKGN1cnJlbnRUYXJnZXQpO1xuICAgIGNvbnN0IHRhcmdldCA9IHJlZmVyZW5jZXNbaW5kZXggLSAxXSB8fCBsYXN0O1xuICAgIHNpbmdsZXRvbi5zaG93KHRhcmdldCk7XG4gIH07XG5cbiAgY29uc3Qgb3JpZ2luYWxTZXRQcm9wcyA9IHNpbmdsZXRvbi5zZXRQcm9wcztcblxuICBzaW5nbGV0b24uc2V0UHJvcHMgPSAocHJvcHMpOiB2b2lkID0+IHtcbiAgICBvdmVycmlkZXMgPSBwcm9wcy5vdmVycmlkZXMgfHwgb3ZlcnJpZGVzO1xuICAgIG9yaWdpbmFsU2V0UHJvcHMocHJvcHMpO1xuICB9O1xuXG4gIHNpbmdsZXRvbi5zZXRJbnN0YW5jZXMgPSAobmV4dEluc3RhbmNlcyk6IHZvaWQgPT4ge1xuICAgIGVuYWJsZUluc3RhbmNlcyh0cnVlKTtcbiAgICBpbnRlcmNlcHRTZXRQcm9wc0NsZWFudXBzLmZvckVhY2goKGZuKSA9PiBmbigpKTtcblxuICAgIGluZGl2aWR1YWxJbnN0YW5jZXMgPSBuZXh0SW5zdGFuY2VzO1xuXG4gICAgZW5hYmxlSW5zdGFuY2VzKGZhbHNlKTtcbiAgICBzZXRSZWZlcmVuY2VzKCk7XG4gICAgc2V0VHJpZ2dlclRhcmdldHMoKTtcbiAgICBpbnRlcmNlcHRTZXRQcm9wc0NsZWFudXBzID0gaW50ZXJjZXB0U2V0UHJvcHMoc2luZ2xldG9uKTtcblxuICAgIHNpbmdsZXRvbi5zZXRQcm9wcyh7dHJpZ2dlclRhcmdldDogdHJpZ2dlclRhcmdldHN9KTtcbiAgfTtcblxuICBpbnRlcmNlcHRTZXRQcm9wc0NsZWFudXBzID0gaW50ZXJjZXB0U2V0UHJvcHMoc2luZ2xldG9uKTtcblxuICByZXR1cm4gc2luZ2xldG9uO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlU2luZ2xldG9uO1xuIiwgImltcG9ydCB0aXBweSBmcm9tICcuLic7XG5pbXBvcnQge1RPVUNIX09QVElPTlN9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQge2RlZmF1bHRQcm9wc30gZnJvbSAnLi4vcHJvcHMnO1xuaW1wb3J0IHtJbnN0YW5jZSwgUHJvcHMsIFRhcmdldHN9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7TGlzdGVuZXJPYmplY3R9IGZyb20gJy4uL3R5cGVzLWludGVybmFsJztcbmltcG9ydCB7bm9ybWFsaXplVG9BcnJheSwgcmVtb3ZlUHJvcGVydGllc30gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHtlcnJvcldoZW59IGZyb20gJy4uL3ZhbGlkYXRpb24nO1xuXG5jb25zdCBCVUJCTElOR19FVkVOVFNfTUFQID0ge1xuICBtb3VzZW92ZXI6ICdtb3VzZWVudGVyJyxcbiAgZm9jdXNpbjogJ2ZvY3VzJyxcbiAgY2xpY2s6ICdjbGljaycsXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWxlZ2F0ZSBpbnN0YW5jZSB0aGF0IGNvbnRyb2xzIHRoZSBjcmVhdGlvbiBvZiB0aXBweSBpbnN0YW5jZXNcbiAqIGZvciBjaGlsZCBlbGVtZW50cyAoYHRhcmdldGAgQ1NTIHNlbGVjdG9yKS5cbiAqL1xuZnVuY3Rpb24gZGVsZWdhdGUoXG4gIHRhcmdldHM6IFRhcmdldHMsXG4gIHByb3BzOiBQYXJ0aWFsPFByb3BzPiAmIHt0YXJnZXQ6IHN0cmluZ31cbik6IEluc3RhbmNlIHwgSW5zdGFuY2VbXSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgZXJyb3JXaGVuKFxuICAgICAgIShwcm9wcyAmJiBwcm9wcy50YXJnZXQpLFxuICAgICAgW1xuICAgICAgICAnWW91IG11c3Qgc3BlY2l0eSBhIGB0YXJnZXRgIHByb3AgaW5kaWNhdGluZyBhIENTUyBzZWxlY3RvciBzdHJpbmcgbWF0Y2hpbmcnLFxuICAgICAgICAndGhlIHRhcmdldCBlbGVtZW50cyB0aGF0IHNob3VsZCByZWNlaXZlIGEgdGlwcHkuJyxcbiAgICAgIF0uam9pbignICcpXG4gICAgKTtcbiAgfVxuXG4gIGxldCBsaXN0ZW5lcnM6IExpc3RlbmVyT2JqZWN0W10gPSBbXTtcbiAgbGV0IGNoaWxkVGlwcHlJbnN0YW5jZXM6IEluc3RhbmNlW10gPSBbXTtcbiAgbGV0IGRpc2FibGVkID0gZmFsc2U7XG5cbiAgY29uc3Qge3RhcmdldH0gPSBwcm9wcztcblxuICBjb25zdCBuYXRpdmVQcm9wcyA9IHJlbW92ZVByb3BlcnRpZXMocHJvcHMsIFsndGFyZ2V0J10pO1xuICBjb25zdCBwYXJlbnRQcm9wcyA9IHsuLi5uYXRpdmVQcm9wcywgdHJpZ2dlcjogJ21hbnVhbCcsIHRvdWNoOiBmYWxzZX07XG4gIGNvbnN0IGNoaWxkUHJvcHMgPSB7XG4gICAgdG91Y2g6IGRlZmF1bHRQcm9wcy50b3VjaCxcbiAgICAuLi5uYXRpdmVQcm9wcyxcbiAgICBzaG93T25DcmVhdGU6IHRydWUsXG4gIH07XG5cbiAgY29uc3QgcmV0dXJuVmFsdWUgPSB0aXBweSh0YXJnZXRzLCBwYXJlbnRQcm9wcyk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRSZXR1cm5WYWx1ZSA9IG5vcm1hbGl6ZVRvQXJyYXkocmV0dXJuVmFsdWUpO1xuXG4gIGZ1bmN0aW9uIG9uVHJpZ2dlcihldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICBpZiAoIWV2ZW50LnRhcmdldCB8fCBkaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldE5vZGUgPSAoZXZlbnQudGFyZ2V0IGFzIEVsZW1lbnQpLmNsb3Nlc3QodGFyZ2V0KTtcblxuICAgIGlmICghdGFyZ2V0Tm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEdldCByZWxldmFudCB0cmlnZ2VyIHdpdGggZmFsbGJhY2tzOlxuICAgIC8vIDEuIENoZWNrIGBkYXRhLXRpcHB5LXRyaWdnZXJgIGF0dHJpYnV0ZSBvbiB0YXJnZXQgbm9kZVxuICAgIC8vIDIuIEZhbGxiYWNrIHRvIGB0cmlnZ2VyYCBwYXNzZWQgdG8gYGRlbGVnYXRlKClgXG4gICAgLy8gMy4gRmFsbGJhY2sgdG8gYGRlZmF1bHRQcm9wcy50cmlnZ2VyYFxuICAgIGNvbnN0IHRyaWdnZXIgPVxuICAgICAgdGFyZ2V0Tm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGlwcHktdHJpZ2dlcicpIHx8XG4gICAgICBwcm9wcy50cmlnZ2VyIHx8XG4gICAgICBkZWZhdWx0UHJvcHMudHJpZ2dlcjtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAodGFyZ2V0Tm9kZS5fdGlwcHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnICYmIHR5cGVvZiBjaGlsZFByb3BzLnRvdWNoID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBldmVudC50eXBlICE9PSAndG91Y2hzdGFydCcgJiZcbiAgICAgIHRyaWdnZXIuaW5kZXhPZigoQlVCQkxJTkdfRVZFTlRTX01BUCBhcyBhbnkpW2V2ZW50LnR5cGVdKSA8IDBcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpbnN0YW5jZSA9IHRpcHB5KHRhcmdldE5vZGUsIGNoaWxkUHJvcHMpO1xuXG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzID0gY2hpbGRUaXBweUluc3RhbmNlcy5jb25jYXQoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uKFxuICAgIG5vZGU6IEVsZW1lbnQsXG4gICAgZXZlbnRUeXBlOiBzdHJpbmcsXG4gICAgaGFuZGxlcjogRXZlbnRMaXN0ZW5lcixcbiAgICBvcHRpb25zOiBib29sZWFuIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSBmYWxzZVxuICApOiB2b2lkIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICBsaXN0ZW5lcnMucHVzaCh7bm9kZSwgZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyhpbnN0YW5jZTogSW5zdGFuY2UpOiB2b2lkIHtcbiAgICBjb25zdCB7cmVmZXJlbmNlfSA9IGluc3RhbmNlO1xuXG4gICAgb24ocmVmZXJlbmNlLCAndG91Y2hzdGFydCcsIG9uVHJpZ2dlciwgVE9VQ0hfT1BUSU9OUyk7XG4gICAgb24ocmVmZXJlbmNlLCAnbW91c2VvdmVyJywgb25UcmlnZ2VyKTtcbiAgICBvbihyZWZlcmVuY2UsICdmb2N1c2luJywgb25UcmlnZ2VyKTtcbiAgICBvbihyZWZlcmVuY2UsICdjbGljaycsIG9uVHJpZ2dlcik7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycygpOiB2b2lkIHtcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaCgoe25vZGUsIGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9uc306IExpc3RlbmVyT2JqZWN0KSA9PiB7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICBsaXN0ZW5lcnMgPSBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5TXV0YXRpb25zKGluc3RhbmNlOiBJbnN0YW5jZSk6IHZvaWQge1xuICAgIGNvbnN0IG9yaWdpbmFsRGVzdHJveSA9IGluc3RhbmNlLmRlc3Ryb3k7XG4gICAgY29uc3Qgb3JpZ2luYWxFbmFibGUgPSBpbnN0YW5jZS5lbmFibGU7XG4gICAgY29uc3Qgb3JpZ2luYWxEaXNhYmxlID0gaW5zdGFuY2UuZGlzYWJsZTtcblxuICAgIGluc3RhbmNlLmRlc3Ryb3kgPSAoc2hvdWxkRGVzdHJveUNoaWxkSW5zdGFuY2VzID0gdHJ1ZSk6IHZvaWQgPT4ge1xuICAgICAgaWYgKHNob3VsZERlc3Ryb3lDaGlsZEluc3RhbmNlcykge1xuICAgICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzLmZvckVhY2goKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgaW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY2hpbGRUaXBweUluc3RhbmNlcyA9IFtdO1xuXG4gICAgICByZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgICAgb3JpZ2luYWxEZXN0cm95KCk7XG4gICAgfTtcblxuICAgIGluc3RhbmNlLmVuYWJsZSA9ICgpOiB2b2lkID0+IHtcbiAgICAgIG9yaWdpbmFsRW5hYmxlKCk7XG4gICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzLmZvckVhY2goKGluc3RhbmNlKSA9PiBpbnN0YW5jZS5lbmFibGUoKSk7XG4gICAgICBkaXNhYmxlZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBpbnN0YW5jZS5kaXNhYmxlID0gKCk6IHZvaWQgPT4ge1xuICAgICAgb3JpZ2luYWxEaXNhYmxlKCk7XG4gICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzLmZvckVhY2goKGluc3RhbmNlKSA9PiBpbnN0YW5jZS5kaXNhYmxlKCkpO1xuICAgICAgZGlzYWJsZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICBhZGRFdmVudExpc3RlbmVycyhpbnN0YW5jZSk7XG4gIH1cblxuICBub3JtYWxpemVkUmV0dXJuVmFsdWUuZm9yRWFjaChhcHBseU11dGF0aW9ucyk7XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBkZWxlZ2F0ZTtcbiIsICJpbXBvcnQge0JBQ0tEUk9QX0NMQVNTfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHtkaXYsIHNldFZpc2liaWxpdHlTdGF0ZX0gZnJvbSAnLi4vZG9tLXV0aWxzJztcbmltcG9ydCB7Z2V0Q2hpbGRyZW59IGZyb20gJy4uL3RlbXBsYXRlJztcbmltcG9ydCB7QW5pbWF0ZUZpbGx9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7ZXJyb3JXaGVufSBmcm9tICcuLi92YWxpZGF0aW9uJztcblxuY29uc3QgYW5pbWF0ZUZpbGw6IEFuaW1hdGVGaWxsID0ge1xuICBuYW1lOiAnYW5pbWF0ZUZpbGwnLFxuICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICBmbihpbnN0YW5jZSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoIWluc3RhbmNlLnByb3BzLnJlbmRlcj8uJCR0aXBweSkge1xuICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgZXJyb3JXaGVuKFxuICAgICAgICAgIGluc3RhbmNlLnByb3BzLmFuaW1hdGVGaWxsLFxuICAgICAgICAgICdUaGUgYGFuaW1hdGVGaWxsYCBwbHVnaW4gcmVxdWlyZXMgdGhlIGRlZmF1bHQgcmVuZGVyIGZ1bmN0aW9uLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGNvbnN0IHtib3gsIGNvbnRlbnR9ID0gZ2V0Q2hpbGRyZW4oaW5zdGFuY2UucG9wcGVyKTtcblxuICAgIGNvbnN0IGJhY2tkcm9wID0gaW5zdGFuY2UucHJvcHMuYW5pbWF0ZUZpbGxcbiAgICAgID8gY3JlYXRlQmFja2Ryb3BFbGVtZW50KClcbiAgICAgIDogbnVsbDtcblxuICAgIHJldHVybiB7XG4gICAgICBvbkNyZWF0ZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgYm94Lmluc2VydEJlZm9yZShiYWNrZHJvcCwgYm94LmZpcnN0RWxlbWVudENoaWxkISk7XG4gICAgICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRlZmlsbCcsICcnKTtcbiAgICAgICAgICBib3guc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICAgICAgICAgIGluc3RhbmNlLnNldFByb3BzKHthcnJvdzogZmFsc2UsIGFuaW1hdGlvbjogJ3NoaWZ0LWF3YXknfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbk1vdW50KCk6IHZvaWQge1xuICAgICAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgICAgICBjb25zdCB7dHJhbnNpdGlvbkR1cmF0aW9ufSA9IGJveC5zdHlsZTtcbiAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IE51bWJlcih0cmFuc2l0aW9uRHVyYXRpb24ucmVwbGFjZSgnbXMnLCAnJykpO1xuXG4gICAgICAgICAgLy8gVGhlIGNvbnRlbnQgc2hvdWxkIGZhZGUgaW4gYWZ0ZXIgdGhlIGJhY2tkcm9wIGhhcyBtb3N0bHkgZmlsbGVkIHRoZVxuICAgICAgICAgIC8vIHRvb2x0aXAgZWxlbWVudC4gYGNsaXAtcGF0aGAgaXMgdGhlIG90aGVyIGFsdGVybmF0aXZlIGJ1dCBpcyBub3RcbiAgICAgICAgICAvLyB3ZWxsLXN1cHBvcnRlZCBhbmQgaXMgYnVnZ3kgb24gc29tZSBkZXZpY2VzLlxuICAgICAgICAgIGNvbnRlbnQuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gYCR7TWF0aC5yb3VuZChkdXJhdGlvbiAvIDEwKX1tc2A7XG5cbiAgICAgICAgICBiYWNrZHJvcC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb247XG4gICAgICAgICAgc2V0VmlzaWJpbGl0eVN0YXRlKFtiYWNrZHJvcF0sICd2aXNpYmxlJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblNob3coKTogdm9pZCB7XG4gICAgICAgIGlmIChiYWNrZHJvcCkge1xuICAgICAgICAgIGJhY2tkcm9wLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwbXMnO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25IaWRlKCk6IHZvaWQge1xuICAgICAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgICAgICBzZXRWaXNpYmlsaXR5U3RhdGUoW2JhY2tkcm9wXSwgJ2hpZGRlbicpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH07XG4gIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBhbmltYXRlRmlsbDtcblxuZnVuY3Rpb24gY3JlYXRlQmFja2Ryb3BFbGVtZW50KCk6IEhUTUxEaXZFbGVtZW50IHtcbiAgY29uc3QgYmFja2Ryb3AgPSBkaXYoKTtcbiAgYmFja2Ryb3AuY2xhc3NOYW1lID0gQkFDS0RST1BfQ0xBU1M7XG4gIHNldFZpc2liaWxpdHlTdGF0ZShbYmFja2Ryb3BdLCAnaGlkZGVuJyk7XG4gIHJldHVybiBiYWNrZHJvcDtcbn1cbiIsICJpbXBvcnQge2dldE93bmVyRG9jdW1lbnQsIGlzTW91c2VFdmVudH0gZnJvbSAnLi4vZG9tLXV0aWxzJztcbmltcG9ydCB7Rm9sbG93Q3Vyc29yLCBJbnN0YW5jZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5sZXQgbW91c2VDb29yZHMgPSB7Y2xpZW50WDogMCwgY2xpZW50WTogMH07XG5sZXQgYWN0aXZlSW5zdGFuY2VzOiBBcnJheTx7aW5zdGFuY2U6IEluc3RhbmNlOyBkb2M6IERvY3VtZW50fT4gPSBbXTtcblxuZnVuY3Rpb24gc3RvcmVNb3VzZUNvb3Jkcyh7Y2xpZW50WCwgY2xpZW50WX06IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgbW91c2VDb29yZHMgPSB7Y2xpZW50WCwgY2xpZW50WX07XG59XG5cbmZ1bmN0aW9uIGFkZE1vdXNlQ29vcmRzTGlzdGVuZXIoZG9jOiBEb2N1bWVudCk6IHZvaWQge1xuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc3RvcmVNb3VzZUNvb3Jkcyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU1vdXNlQ29vcmRzTGlzdGVuZXIoZG9jOiBEb2N1bWVudCk6IHZvaWQge1xuICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc3RvcmVNb3VzZUNvb3Jkcyk7XG59XG5cbmNvbnN0IGZvbGxvd0N1cnNvcjogRm9sbG93Q3Vyc29yID0ge1xuICBuYW1lOiAnZm9sbG93Q3Vyc29yJyxcbiAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgZm4oaW5zdGFuY2UpIHtcbiAgICBjb25zdCByZWZlcmVuY2UgPSBpbnN0YW5jZS5yZWZlcmVuY2U7XG4gICAgY29uc3QgZG9jID0gZ2V0T3duZXJEb2N1bWVudChpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSk7XG5cbiAgICBsZXQgaXNJbnRlcm5hbFVwZGF0ZSA9IGZhbHNlO1xuICAgIGxldCB3YXNGb2N1c0V2ZW50ID0gZmFsc2U7XG4gICAgbGV0IGlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICBsZXQgcHJldlByb3BzID0gaW5zdGFuY2UucHJvcHM7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0luaXRpYWxCZWhhdmlvcigpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvciA9PT0gJ2luaXRpYWwnICYmIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRMaXN0ZW5lcigpOiB2b2lkIHtcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoKTogdm9pZCB7XG4gICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuc2V0R2V0UmVmZXJlbmNlQ2xpZW50UmVjdCgpOiB2b2lkIHtcbiAgICAgIGlzSW50ZXJuYWxVcGRhdGUgPSB0cnVlO1xuICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe2dldFJlZmVyZW5jZUNsaWVudFJlY3Q6IG51bGx9KTtcbiAgICAgIGlzSW50ZXJuYWxVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgLy8gSWYgdGhlIGluc3RhbmNlIGlzIGludGVyYWN0aXZlLCBhdm9pZCB1cGRhdGluZyB0aGUgcG9zaXRpb24gdW5sZXNzIGl0J3NcbiAgICAgIC8vIG92ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAgICBjb25zdCBpc0N1cnNvck92ZXJSZWZlcmVuY2UgPSBldmVudC50YXJnZXRcbiAgICAgICAgPyByZWZlcmVuY2UuY29udGFpbnMoZXZlbnQudGFyZ2V0IGFzIE5vZGUpXG4gICAgICAgIDogdHJ1ZTtcbiAgICAgIGNvbnN0IHtmb2xsb3dDdXJzb3J9ID0gaW5zdGFuY2UucHJvcHM7XG4gICAgICBjb25zdCB7Y2xpZW50WCwgY2xpZW50WX0gPSBldmVudDtcblxuICAgICAgY29uc3QgcmVjdCA9IHJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHJlbGF0aXZlWCA9IGNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgICBjb25zdCByZWxhdGl2ZVkgPSBjbGllbnRZIC0gcmVjdC50b3A7XG5cbiAgICAgIGlmIChpc0N1cnNvck92ZXJSZWZlcmVuY2UgfHwgIWluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gdW5uZWVkZWQgRE9NUmVjdCBwcm9wZXJ0aWVzXG4gICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSByZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgIGxldCB4ID0gY2xpZW50WDtcbiAgICAgICAgICAgIGxldCB5ID0gY2xpZW50WTtcblxuICAgICAgICAgICAgaWYgKGZvbGxvd0N1cnNvciA9PT0gJ2luaXRpYWwnKSB7XG4gICAgICAgICAgICAgIHggPSByZWN0LmxlZnQgKyByZWxhdGl2ZVg7XG4gICAgICAgICAgICAgIHkgPSByZWN0LnRvcCArIHJlbGF0aXZlWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdG9wID0gZm9sbG93Q3Vyc29yID09PSAnaG9yaXpvbnRhbCcgPyByZWN0LnRvcCA6IHk7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGZvbGxvd0N1cnNvciA9PT0gJ3ZlcnRpY2FsJyA/IHJlY3QucmlnaHQgOiB4O1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gZm9sbG93Q3Vyc29yID09PSAnaG9yaXpvbnRhbCcgPyByZWN0LmJvdHRvbSA6IHk7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gZm9sbG93Q3Vyc29yID09PSAndmVydGljYWwnID8gcmVjdC5sZWZ0IDogeDtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBib3R0b20gLSB0b3AsXG4gICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlKCk6IHZvaWQge1xuICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvcikge1xuICAgICAgICBhY3RpdmVJbnN0YW5jZXMucHVzaCh7aW5zdGFuY2UsIGRvY30pO1xuICAgICAgICBhZGRNb3VzZUNvb3Jkc0xpc3RlbmVyKGRvYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVzdHJveSgpOiB2b2lkIHtcbiAgICAgIGFjdGl2ZUluc3RhbmNlcyA9IGFjdGl2ZUluc3RhbmNlcy5maWx0ZXIoXG4gICAgICAgIChkYXRhKSA9PiBkYXRhLmluc3RhbmNlICE9PSBpbnN0YW5jZVxuICAgICAgKTtcblxuICAgICAgaWYgKGFjdGl2ZUluc3RhbmNlcy5maWx0ZXIoKGRhdGEpID0+IGRhdGEuZG9jID09PSBkb2MpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZW1vdmVNb3VzZUNvb3Jkc0xpc3RlbmVyKGRvYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ3JlYXRlOiBjcmVhdGUsXG4gICAgICBvbkRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgICBvbkJlZm9yZVVwZGF0ZSgpOiB2b2lkIHtcbiAgICAgICAgcHJldlByb3BzID0gaW5zdGFuY2UucHJvcHM7XG4gICAgICB9LFxuICAgICAgb25BZnRlclVwZGF0ZShfLCB7Zm9sbG93Q3Vyc29yfSk6IHZvaWQge1xuICAgICAgICBpZiAoaXNJbnRlcm5hbFVwZGF0ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBmb2xsb3dDdXJzb3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgIHByZXZQcm9wcy5mb2xsb3dDdXJzb3IgIT09IGZvbGxvd0N1cnNvclxuICAgICAgICApIHtcbiAgICAgICAgICBkZXN0cm95KCk7XG5cbiAgICAgICAgICBpZiAoZm9sbG93Q3Vyc29yKSB7XG4gICAgICAgICAgICBjcmVhdGUoKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQgJiZcbiAgICAgICAgICAgICAgIXdhc0ZvY3VzRXZlbnQgJiZcbiAgICAgICAgICAgICAgIWdldElzSW5pdGlhbEJlaGF2aW9yKClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBhZGRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgdW5zZXRHZXRSZWZlcmVuY2VDbGllbnRSZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Nb3VudCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvciAmJiAhd2FzRm9jdXNFdmVudCkge1xuICAgICAgICAgIGlmIChpc1VubW91bnRlZCkge1xuICAgICAgICAgICAgb25Nb3VzZU1vdmUobW91c2VDb29yZHMgYXMgTW91c2VFdmVudCk7XG4gICAgICAgICAgICBpc1VubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZ2V0SXNJbml0aWFsQmVoYXZpb3IoKSkge1xuICAgICAgICAgICAgYWRkTGlzdGVuZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblRyaWdnZXIoXywgZXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKGlzTW91c2VFdmVudChldmVudCkpIHtcbiAgICAgICAgICBtb3VzZUNvb3JkcyA9IHtjbGllbnRYOiBldmVudC5jbGllbnRYLCBjbGllbnRZOiBldmVudC5jbGllbnRZfTtcbiAgICAgICAgfVxuICAgICAgICB3YXNGb2N1c0V2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ2ZvY3VzJztcbiAgICAgIH0sXG4gICAgICBvbkhpZGRlbigpOiB2b2lkIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvcikge1xuICAgICAgICAgIHVuc2V0R2V0UmVmZXJlbmNlQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgaXNVbm1vdW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH07XG4gIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmb2xsb3dDdXJzb3I7XG4iLCAiaW1wb3J0IHtNb2RpZmllciwgUGxhY2VtZW50fSBmcm9tICdAcG9wcGVyanMvY29yZSc7XG5pbXBvcnQge2lzTW91c2VFdmVudH0gZnJvbSAnLi4vZG9tLXV0aWxzJztcbmltcG9ydCB7QmFzZVBsYWNlbWVudCwgSW5saW5lUG9zaXRpb25pbmcsIFByb3BzfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge2FycmF5RnJvbSwgZ2V0QmFzZVBsYWNlbWVudH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5mdW5jdGlvbiBnZXRQcm9wcyhwcm9wczogUHJvcHMsIG1vZGlmaWVyOiBNb2RpZmllcjxhbnksIGFueT4pOiBQYXJ0aWFsPFByb3BzPiB7XG4gIHJldHVybiB7XG4gICAgcG9wcGVyT3B0aW9uczoge1xuICAgICAgLi4ucHJvcHMucG9wcGVyT3B0aW9ucyxcbiAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICAuLi4ocHJvcHMucG9wcGVyT3B0aW9ucz8ubW9kaWZpZXJzIHx8IFtdKS5maWx0ZXIoXG4gICAgICAgICAgKHtuYW1lfSkgPT4gbmFtZSAhPT0gbW9kaWZpZXIubmFtZVxuICAgICAgICApLFxuICAgICAgICBtb2RpZmllcixcbiAgICAgIF0sXG4gICAgfSxcbiAgfTtcbn1cblxuY29uc3QgaW5saW5lUG9zaXRpb25pbmc6IElubGluZVBvc2l0aW9uaW5nID0ge1xuICBuYW1lOiAnaW5saW5lUG9zaXRpb25pbmcnLFxuICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICBmbihpbnN0YW5jZSkge1xuICAgIGNvbnN0IHtyZWZlcmVuY2V9ID0gaW5zdGFuY2U7XG5cbiAgICBmdW5jdGlvbiBpc0VuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gISFpbnN0YW5jZS5wcm9wcy5pbmxpbmVQb3NpdGlvbmluZztcbiAgICB9XG5cbiAgICBsZXQgcGxhY2VtZW50OiBQbGFjZW1lbnQ7XG4gICAgbGV0IGN1cnNvclJlY3RJbmRleCA9IC0xO1xuICAgIGxldCBpc0ludGVybmFsVXBkYXRlID0gZmFsc2U7XG4gICAgbGV0IHRyaWVkUGxhY2VtZW50czogQXJyYXk8c3RyaW5nPiA9IFtdO1xuXG4gICAgY29uc3QgbW9kaWZpZXI6IE1vZGlmaWVyPFxuICAgICAgJ3RpcHB5SW5saW5lUG9zaXRpb25pbmcnLFxuICAgICAgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgICA+ID0ge1xuICAgICAgbmFtZTogJ3RpcHB5SW5saW5lUG9zaXRpb25pbmcnLFxuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIHBoYXNlOiAnYWZ0ZXJXcml0ZScsXG4gICAgICBmbih7c3RhdGV9KSB7XG4gICAgICAgIGlmIChpc0VuYWJsZWQoKSkge1xuICAgICAgICAgIGlmICh0cmllZFBsYWNlbWVudHMuaW5kZXhPZihzdGF0ZS5wbGFjZW1lbnQpICE9PSAtMSkge1xuICAgICAgICAgICAgdHJpZWRQbGFjZW1lbnRzID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcGxhY2VtZW50ICE9PSBzdGF0ZS5wbGFjZW1lbnQgJiZcbiAgICAgICAgICAgIHRyaWVkUGxhY2VtZW50cy5pbmRleE9mKHN0YXRlLnBsYWNlbWVudCkgPT09IC0xXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0cmllZFBsYWNlbWVudHMucHVzaChzdGF0ZS5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe1xuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gdW5uZWVkZWQgRE9NUmVjdCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6ICgpID0+XG4gICAgICAgICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGxhY2VtZW50ID0gc3RhdGUucGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRSZWZlcmVuY2VDbGllbnRSZWN0KHBsYWNlbWVudDogUGxhY2VtZW50KTogUGFydGlhbDxET01SZWN0PiB7XG4gICAgICByZXR1cm4gZ2V0SW5saW5lQm91bmRpbmdDbGllbnRSZWN0KFxuICAgICAgICBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCksXG4gICAgICAgIHJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgYXJyYXlGcm9tKHJlZmVyZW5jZS5nZXRDbGllbnRSZWN0cygpKSxcbiAgICAgICAgY3Vyc29yUmVjdEluZGV4XG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEludGVybmFsUHJvcHMocGFydGlhbFByb3BzOiBQYXJ0aWFsPFByb3BzPik6IHZvaWQge1xuICAgICAgaXNJbnRlcm5hbFVwZGF0ZSA9IHRydWU7XG4gICAgICBpbnN0YW5jZS5zZXRQcm9wcyhwYXJ0aWFsUHJvcHMpO1xuICAgICAgaXNJbnRlcm5hbFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZE1vZGlmaWVyKCk6IHZvaWQge1xuICAgICAgaWYgKCFpc0ludGVybmFsVXBkYXRlKSB7XG4gICAgICAgIHNldEludGVybmFsUHJvcHMoZ2V0UHJvcHMoaW5zdGFuY2UucHJvcHMsIG1vZGlmaWVyKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ3JlYXRlOiBhZGRNb2RpZmllcixcbiAgICAgIG9uQWZ0ZXJVcGRhdGU6IGFkZE1vZGlmaWVyLFxuICAgICAgb25UcmlnZ2VyKF8sIGV2ZW50KTogdm9pZCB7XG4gICAgICAgIGlmIChpc01vdXNlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgY29uc3QgcmVjdHMgPSBhcnJheUZyb20oaW5zdGFuY2UucmVmZXJlbmNlLmdldENsaWVudFJlY3RzKCkpO1xuICAgICAgICAgIGNvbnN0IGN1cnNvclJlY3QgPSByZWN0cy5maW5kKFxuICAgICAgICAgICAgKHJlY3QpID0+XG4gICAgICAgICAgICAgIHJlY3QubGVmdCAtIDIgPD0gZXZlbnQuY2xpZW50WCAmJlxuICAgICAgICAgICAgICByZWN0LnJpZ2h0ICsgMiA+PSBldmVudC5jbGllbnRYICYmXG4gICAgICAgICAgICAgIHJlY3QudG9wIC0gMiA8PSBldmVudC5jbGllbnRZICYmXG4gICAgICAgICAgICAgIHJlY3QuYm90dG9tICsgMiA+PSBldmVudC5jbGllbnRZXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHJlY3RzLmluZGV4T2YoY3Vyc29yUmVjdCk7XG4gICAgICAgICAgY3Vyc29yUmVjdEluZGV4ID0gaW5kZXggPiAtMSA/IGluZGV4IDogY3Vyc29yUmVjdEluZGV4O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25IaWRkZW4oKTogdm9pZCB7XG4gICAgICAgIGN1cnNvclJlY3RJbmRleCA9IC0xO1xuICAgICAgfSxcbiAgICB9O1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgaW5saW5lUG9zaXRpb25pbmc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmxpbmVCb3VuZGluZ0NsaWVudFJlY3QoXG4gIGN1cnJlbnRCYXNlUGxhY2VtZW50OiBCYXNlUGxhY2VtZW50IHwgbnVsbCxcbiAgYm91bmRpbmdSZWN0OiBET01SZWN0LFxuICBjbGllbnRSZWN0czogRE9NUmVjdFtdLFxuICBjdXJzb3JSZWN0SW5kZXg6IG51bWJlclxuKToge1xuICB0b3A6IG51bWJlcjtcbiAgYm90dG9tOiBudW1iZXI7XG4gIGxlZnQ6IG51bWJlcjtcbiAgcmlnaHQ6IG51bWJlcjtcbiAgd2lkdGg6IG51bWJlcjtcbiAgaGVpZ2h0OiBudW1iZXI7XG59IHtcbiAgLy8gTm90IGFuIGlubGluZSBlbGVtZW50LCBvciBwbGFjZW1lbnQgaXMgbm90IHlldCBrbm93blxuICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoIDwgMiB8fCBjdXJyZW50QmFzZVBsYWNlbWVudCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBib3VuZGluZ1JlY3Q7XG4gIH1cblxuICAvLyBUaGVyZSBhcmUgdHdvIHJlY3RzIGFuZCB0aGV5IGFyZSBkaXNqb2luZWRcbiAgaWYgKFxuICAgIGNsaWVudFJlY3RzLmxlbmd0aCA9PT0gMiAmJlxuICAgIGN1cnNvclJlY3RJbmRleCA+PSAwICYmXG4gICAgY2xpZW50UmVjdHNbMF0ubGVmdCA+IGNsaWVudFJlY3RzWzFdLnJpZ2h0XG4gICkge1xuICAgIHJldHVybiBjbGllbnRSZWN0c1tjdXJzb3JSZWN0SW5kZXhdIHx8IGJvdW5kaW5nUmVjdDtcbiAgfVxuXG4gIHN3aXRjaCAoY3VycmVudEJhc2VQbGFjZW1lbnQpIHtcbiAgICBjYXNlICd0b3AnOlxuICAgIGNhc2UgJ2JvdHRvbSc6IHtcbiAgICAgIGNvbnN0IGZpcnN0UmVjdCA9IGNsaWVudFJlY3RzWzBdO1xuICAgICAgY29uc3QgbGFzdFJlY3QgPSBjbGllbnRSZWN0c1tjbGllbnRSZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGlzVG9wID0gY3VycmVudEJhc2VQbGFjZW1lbnQgPT09ICd0b3AnO1xuXG4gICAgICBjb25zdCB0b3AgPSBmaXJzdFJlY3QudG9wO1xuICAgICAgY29uc3QgYm90dG9tID0gbGFzdFJlY3QuYm90dG9tO1xuICAgICAgY29uc3QgbGVmdCA9IGlzVG9wID8gZmlyc3RSZWN0LmxlZnQgOiBsYXN0UmVjdC5sZWZ0O1xuICAgICAgY29uc3QgcmlnaHQgPSBpc1RvcCA/IGZpcnN0UmVjdC5yaWdodCA6IGxhc3RSZWN0LnJpZ2h0O1xuICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG5cbiAgICAgIHJldHVybiB7dG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0LCB3aWR0aCwgaGVpZ2h0fTtcbiAgICB9XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgY2FzZSAncmlnaHQnOiB7XG4gICAgICBjb25zdCBtaW5MZWZ0ID0gTWF0aC5taW4oLi4uY2xpZW50UmVjdHMubWFwKChyZWN0cykgPT4gcmVjdHMubGVmdCkpO1xuICAgICAgY29uc3QgbWF4UmlnaHQgPSBNYXRoLm1heCguLi5jbGllbnRSZWN0cy5tYXAoKHJlY3RzKSA9PiByZWN0cy5yaWdodCkpO1xuICAgICAgY29uc3QgbWVhc3VyZVJlY3RzID0gY2xpZW50UmVjdHMuZmlsdGVyKChyZWN0KSA9PlxuICAgICAgICBjdXJyZW50QmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnXG4gICAgICAgICAgPyByZWN0LmxlZnQgPT09IG1pbkxlZnRcbiAgICAgICAgICA6IHJlY3QucmlnaHQgPT09IG1heFJpZ2h0XG4gICAgICApO1xuXG4gICAgICBjb25zdCB0b3AgPSBtZWFzdXJlUmVjdHNbMF0udG9wO1xuICAgICAgY29uc3QgYm90dG9tID0gbWVhc3VyZVJlY3RzW21lYXN1cmVSZWN0cy5sZW5ndGggLSAxXS5ib3R0b207XG4gICAgICBjb25zdCBsZWZ0ID0gbWluTGVmdDtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gbWF4UmlnaHQ7XG4gICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcblxuICAgICAgcmV0dXJuIHt0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQsIHdpZHRoLCBoZWlnaHR9O1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gYm91bmRpbmdSZWN0O1xuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7VmlydHVhbEVsZW1lbnR9IGZyb20gJ0Bwb3BwZXJqcy9jb3JlJztcbmltcG9ydCB7UmVmZXJlbmNlRWxlbWVudCwgU3RpY2t5fSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IHN0aWNreTogU3RpY2t5ID0ge1xuICBuYW1lOiAnc3RpY2t5JyxcbiAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgZm4oaW5zdGFuY2UpIHtcbiAgICBjb25zdCB7cmVmZXJlbmNlLCBwb3BwZXJ9ID0gaW5zdGFuY2U7XG5cbiAgICBmdW5jdGlvbiBnZXRSZWZlcmVuY2UoKTogUmVmZXJlbmNlRWxlbWVudCB8IFZpcnR1YWxFbGVtZW50IHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZVxuICAgICAgICA/IGluc3RhbmNlLnBvcHBlckluc3RhbmNlLnN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZVxuICAgICAgICA6IHJlZmVyZW5jZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG91bGRDaGVjayh2YWx1ZTogJ3JlZmVyZW5jZScgfCAncG9wcGVyJyk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnByb3BzLnN0aWNreSA9PT0gdHJ1ZSB8fCBpbnN0YW5jZS5wcm9wcy5zdGlja3kgPT09IHZhbHVlO1xuICAgIH1cblxuICAgIGxldCBwcmV2UmVmUmVjdDogQ2xpZW50UmVjdCB8IG51bGwgPSBudWxsO1xuICAgIGxldCBwcmV2UG9wUmVjdDogQ2xpZW50UmVjdCB8IG51bGwgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24oKTogdm9pZCB7XG4gICAgICBjb25zdCBjdXJyZW50UmVmUmVjdCA9IHNob3VsZENoZWNrKCdyZWZlcmVuY2UnKVxuICAgICAgICA/IGdldFJlZmVyZW5jZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIDogbnVsbDtcbiAgICAgIGNvbnN0IGN1cnJlbnRQb3BSZWN0ID0gc2hvdWxkQ2hlY2soJ3BvcHBlcicpXG4gICAgICAgID8gcG9wcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIDogbnVsbDtcblxuICAgICAgaWYgKFxuICAgICAgICAoY3VycmVudFJlZlJlY3QgJiYgYXJlUmVjdHNEaWZmZXJlbnQocHJldlJlZlJlY3QsIGN1cnJlbnRSZWZSZWN0KSkgfHxcbiAgICAgICAgKGN1cnJlbnRQb3BSZWN0ICYmIGFyZVJlY3RzRGlmZmVyZW50KHByZXZQb3BSZWN0LCBjdXJyZW50UG9wUmVjdCkpXG4gICAgICApIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJldlJlZlJlY3QgPSBjdXJyZW50UmVmUmVjdDtcbiAgICAgIHByZXZQb3BSZWN0ID0gY3VycmVudFBvcFJlY3Q7XG5cbiAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZVBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb25Nb3VudCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzLnN0aWNreSkge1xuICAgICAgICAgIHVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHN0aWNreTtcblxuZnVuY3Rpb24gYXJlUmVjdHNEaWZmZXJlbnQoXG4gIHJlY3RBOiBDbGllbnRSZWN0IHwgbnVsbCxcbiAgcmVjdEI6IENsaWVudFJlY3QgfCBudWxsXG4pOiBib29sZWFuIHtcbiAgaWYgKHJlY3RBICYmIHJlY3RCKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHJlY3RBLnRvcCAhPT0gcmVjdEIudG9wIHx8XG4gICAgICByZWN0QS5yaWdodCAhPT0gcmVjdEIucmlnaHQgfHxcbiAgICAgIHJlY3RBLmJvdHRvbSAhPT0gcmVjdEIuYm90dG9tIHx8XG4gICAgICByZWN0QS5sZWZ0ICE9PSByZWN0Qi5sZWZ0XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuIiwgImltcG9ydCB0aXBweSBmcm9tICcuLi9zcmMnO1xuaW1wb3J0IHtyZW5kZXJ9IGZyb20gJy4uL3NyYy90ZW1wbGF0ZSc7XG5cbnRpcHB5LnNldERlZmF1bHRQcm9wcyh7cmVuZGVyfSk7XG5cbmV4cG9ydCB7ZGVmYXVsdCwgaGlkZUFsbH0gZnJvbSAnLi4vc3JjJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjcmVhdGVTaW5nbGV0b259IGZyb20gJy4uL3NyYy9hZGRvbnMvY3JlYXRlU2luZ2xldG9uJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBkZWxlZ2F0ZX0gZnJvbSAnLi4vc3JjL2FkZG9ucy9kZWxlZ2F0ZSc7XG5leHBvcnQge2RlZmF1bHQgYXMgYW5pbWF0ZUZpbGx9IGZyb20gJy4uL3NyYy9wbHVnaW5zL2FuaW1hdGVGaWxsJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBmb2xsb3dDdXJzb3J9IGZyb20gJy4uL3NyYy9wbHVnaW5zL2ZvbGxvd0N1cnNvcic7XG5leHBvcnQge2RlZmF1bHQgYXMgaW5saW5lUG9zaXRpb25pbmd9IGZyb20gJy4uL3NyYy9wbHVnaW5zL2lubGluZVBvc2l0aW9uaW5nJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGlja3l9IGZyb20gJy4uL3NyYy9wbHVnaW5zL3N0aWNreSc7XG5leHBvcnQge1JPVU5EX0FSUk9XIGFzIHJvdW5kQXJyb3d9IGZyb20gJy4uL3NyYy9jb25zdGFudHMnO1xuIiwgImltcG9ydCB7XG4gIEVkaXRvciwgaXNOb2RlU2VsZWN0aW9uLCBpc1RleHRTZWxlY3Rpb24sIHBvc1RvRE9NUmVjdCxcbn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUsIFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnXG5pbXBvcnQgdGlwcHksIHsgSW5zdGFuY2UsIFByb3BzIH0gZnJvbSAndGlwcHkuanMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQnViYmxlTWVudVBsdWdpblByb3BzIHtcbiAgcGx1Z2luS2V5OiBQbHVnaW5LZXkgfCBzdHJpbmdcbiAgZWRpdG9yOiBFZGl0b3JcbiAgZWxlbWVudDogSFRNTEVsZW1lbnRcbiAgdGlwcHlPcHRpb25zPzogUGFydGlhbDxQcm9wcz5cbiAgdXBkYXRlRGVsYXk/OiBudW1iZXJcbiAgc2hvdWxkU2hvdz86XG4gICAgfCAoKHByb3BzOiB7XG4gICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgIHZpZXc6IEVkaXRvclZpZXdcbiAgICAgICAgc3RhdGU6IEVkaXRvclN0YXRlXG4gICAgICAgIG9sZFN0YXRlPzogRWRpdG9yU3RhdGVcbiAgICAgICAgZnJvbTogbnVtYmVyXG4gICAgICAgIHRvOiBudW1iZXJcbiAgICAgIH0pID0+IGJvb2xlYW4pXG4gICAgfCBudWxsXG59XG5cbmV4cG9ydCB0eXBlIEJ1YmJsZU1lbnVWaWV3UHJvcHMgPSBCdWJibGVNZW51UGx1Z2luUHJvcHMgJiB7XG4gIHZpZXc6IEVkaXRvclZpZXdcbn1cblxuZXhwb3J0IGNsYXNzIEJ1YmJsZU1lbnVWaWV3IHtcbiAgcHVibGljIGVkaXRvcjogRWRpdG9yXG5cbiAgcHVibGljIGVsZW1lbnQ6IEhUTUxFbGVtZW50XG5cbiAgcHVibGljIHZpZXc6IEVkaXRvclZpZXdcblxuICBwdWJsaWMgcHJldmVudEhpZGUgPSBmYWxzZVxuXG4gIHB1YmxpYyB0aXBweTogSW5zdGFuY2UgfCB1bmRlZmluZWRcblxuICBwdWJsaWMgdGlwcHlPcHRpb25zPzogUGFydGlhbDxQcm9wcz5cblxuICBwdWJsaWMgdXBkYXRlRGVsYXk6IG51bWJlclxuXG4gIHByaXZhdGUgdXBkYXRlRGVib3VuY2VUaW1lcjogbnVtYmVyIHwgdW5kZWZpbmVkXG5cbiAgcHVibGljIHNob3VsZFNob3c6IEV4Y2x1ZGU8QnViYmxlTWVudVBsdWdpblByb3BzWydzaG91bGRTaG93J10sIG51bGw+ID0gKHtcbiAgICB2aWV3LFxuICAgIHN0YXRlLFxuICAgIGZyb20sXG4gICAgdG8sXG4gIH0pID0+IHtcbiAgICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICAgIGNvbnN0IHsgZW1wdHkgfSA9IHNlbGVjdGlvblxuXG4gICAgLy8gU29tZXRpbWUgY2hlY2sgZm9yIGBlbXB0eWAgaXMgbm90IGVub3VnaC5cbiAgICAvLyBEb3VibGVjbGljayBhbiBlbXB0eSBwYXJhZ3JhcGggcmV0dXJucyBhIG5vZGUgc2l6ZSBvZiAyLlxuICAgIC8vIFNvIHdlIGNoZWNrIGFsc28gZm9yIGFuIGVtcHR5IHRleHQgc2l6ZS5cbiAgICBjb25zdCBpc0VtcHR5VGV4dEJsb2NrID0gIWRvYy50ZXh0QmV0d2Vlbihmcm9tLCB0bykubGVuZ3RoICYmIGlzVGV4dFNlbGVjdGlvbihzdGF0ZS5zZWxlY3Rpb24pXG5cbiAgICAvLyBXaGVuIGNsaWNraW5nIG9uIGEgZWxlbWVudCBpbnNpZGUgdGhlIGJ1YmJsZSBtZW51IHRoZSBlZGl0b3IgXCJibHVyXCIgZXZlbnRcbiAgICAvLyBpcyBjYWxsZWQgYW5kIHRoZSBidWJibGUgbWVudSBpdGVtIGlzIGZvY3Vzc2VkLiBJbiB0aGlzIGNhc2Ugd2Ugc2hvdWxkXG4gICAgLy8gY29uc2lkZXIgdGhlIG1lbnUgYXMgcGFydCBvZiB0aGUgZWRpdG9yIGFuZCBrZWVwIHNob3dpbmcgdGhlIG1lbnVcbiAgICBjb25zdCBpc0NoaWxkT2ZNZW51ID0gdGhpcy5lbGVtZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpXG5cbiAgICBjb25zdCBoYXNFZGl0b3JGb2N1cyA9IHZpZXcuaGFzRm9jdXMoKSB8fCBpc0NoaWxkT2ZNZW51XG5cbiAgICBpZiAoIWhhc0VkaXRvckZvY3VzIHx8IGVtcHR5IHx8IGlzRW1wdHlUZXh0QmxvY2sgfHwgIXRoaXMuZWRpdG9yLmlzRWRpdGFibGUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgZWRpdG9yLFxuICAgIGVsZW1lbnQsXG4gICAgdmlldyxcbiAgICB0aXBweU9wdGlvbnMgPSB7fSxcbiAgICB1cGRhdGVEZWxheSA9IDI1MCxcbiAgICBzaG91bGRTaG93LFxuICB9OiBCdWJibGVNZW51Vmlld1Byb3BzKSB7XG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50XG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMudXBkYXRlRGVsYXkgPSB1cGRhdGVEZWxheVxuXG4gICAgaWYgKHNob3VsZFNob3cpIHtcbiAgICAgIHRoaXMuc2hvdWxkU2hvdyA9IHNob3VsZFNob3dcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZWRvd25IYW5kbGVyLCB7IGNhcHR1cmU6IHRydWUgfSlcbiAgICB0aGlzLnZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuZHJhZ3N0YXJ0SGFuZGxlcilcbiAgICB0aGlzLmVkaXRvci5vbignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcilcbiAgICB0aGlzLmVkaXRvci5vbignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXIpXG4gICAgdGhpcy50aXBweU9wdGlvbnMgPSB0aXBweU9wdGlvbnNcbiAgICAvLyBEZXRhY2hlcyBtZW51IGNvbnRlbnQgZnJvbSBpdHMgY3VycmVudCBwYXJlbnRcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlKClcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJ1xuICB9XG5cbiAgbW91c2Vkb3duSGFuZGxlciA9ICgpID0+IHtcbiAgICB0aGlzLnByZXZlbnRIaWRlID0gdHJ1ZVxuICB9XG5cbiAgZHJhZ3N0YXJ0SGFuZGxlciA9ICgpID0+IHtcbiAgICB0aGlzLmhpZGUoKVxuICB9XG5cbiAgZm9jdXNIYW5kbGVyID0gKCkgPT4ge1xuICAgIC8vIHdlIHVzZSBgc2V0VGltZW91dGAgdG8gbWFrZSBzdXJlIGBzZWxlY3Rpb25gIGlzIGFscmVhZHkgdXBkYXRlZFxuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy51cGRhdGUodGhpcy5lZGl0b3IudmlldykpXG4gIH1cblxuICBibHVySGFuZGxlciA9ICh7IGV2ZW50IH06IHsgZXZlbnQ6IEZvY3VzRXZlbnQgfSkgPT4ge1xuICAgIGlmICh0aGlzLnByZXZlbnRIaWRlKSB7XG4gICAgICB0aGlzLnByZXZlbnRIaWRlID0gZmFsc2VcblxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGV2ZW50Py5yZWxhdGVkVGFyZ2V0ICYmIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlPy5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0IGFzIE5vZGUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmhpZGUoKVxuICB9XG5cbiAgdGlwcHlCbHVySGFuZGxlciA9IChldmVudDogRm9jdXNFdmVudCkgPT4ge1xuICAgIHRoaXMuYmx1ckhhbmRsZXIoeyBldmVudCB9KVxuICB9XG5cbiAgY3JlYXRlVG9vbHRpcCgpIHtcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGVkaXRvckVsZW1lbnQgfSA9IHRoaXMuZWRpdG9yLm9wdGlvbnNcbiAgICBjb25zdCBlZGl0b3JJc0F0dGFjaGVkID0gISFlZGl0b3JFbGVtZW50LnBhcmVudEVsZW1lbnRcblxuICAgIGlmICh0aGlzLnRpcHB5IHx8ICFlZGl0b3JJc0F0dGFjaGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnRpcHB5ID0gdGlwcHkoZWRpdG9yRWxlbWVudCwge1xuICAgICAgZHVyYXRpb246IDAsXG4gICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiBudWxsLFxuICAgICAgY29udGVudDogdGhpcy5lbGVtZW50LFxuICAgICAgaW50ZXJhY3RpdmU6IHRydWUsXG4gICAgICB0cmlnZ2VyOiAnbWFudWFsJyxcbiAgICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgICBoaWRlT25DbGljazogJ3RvZ2dsZScsXG4gICAgICAuLi50aGlzLnRpcHB5T3B0aW9ucyxcbiAgICB9KVxuXG4gICAgLy8gbWF5YmUgd2UgaGF2ZSB0byBoaWRlIHRpcHB5IG9uIGl0cyBvd24gYmx1ciBldmVudCBhcyB3ZWxsXG4gICAgaWYgKHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICh0aGlzLnRpcHB5LnBvcHBlci5maXJzdENoaWxkIGFzIEhUTUxFbGVtZW50KS5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy50aXBweUJsdXJIYW5kbGVyKVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZSh2aWV3OiBFZGl0b3JWaWV3LCBvbGRTdGF0ZT86IEVkaXRvclN0YXRlKSB7XG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gdmlld1xuICAgIGNvbnN0IGhhc1ZhbGlkU2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBvcyAhPT0gc3RhdGUuc2VsZWN0aW9uLiR0by5wb3NcblxuICAgIGlmICh0aGlzLnVwZGF0ZURlbGF5ID4gMCAmJiBoYXNWYWxpZFNlbGVjdGlvbikge1xuICAgICAgdGhpcy5oYW5kbGVEZWJvdW5jZWRVcGRhdGUodmlldywgb2xkU3RhdGUpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3Rpb25DaGFuZ2VkID0gIW9sZFN0YXRlPy5zZWxlY3Rpb24uZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pXG4gICAgY29uc3QgZG9jQ2hhbmdlZCA9ICFvbGRTdGF0ZT8uZG9jLmVxKHZpZXcuc3RhdGUuZG9jKVxuXG4gICAgdGhpcy51cGRhdGVIYW5kbGVyKHZpZXcsIHNlbGVjdGlvbkNoYW5nZWQsIGRvY0NoYW5nZWQsIG9sZFN0YXRlKVxuICB9XG5cbiAgaGFuZGxlRGVib3VuY2VkVXBkYXRlID0gKHZpZXc6IEVkaXRvclZpZXcsIG9sZFN0YXRlPzogRWRpdG9yU3RhdGUpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb25DaGFuZ2VkID0gIW9sZFN0YXRlPy5zZWxlY3Rpb24uZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pXG4gICAgY29uc3QgZG9jQ2hhbmdlZCA9ICFvbGRTdGF0ZT8uZG9jLmVxKHZpZXcuc3RhdGUuZG9jKVxuXG4gICAgaWYgKCFzZWxlY3Rpb25DaGFuZ2VkICYmICFkb2NDaGFuZ2VkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy51cGRhdGVEZWJvdW5jZVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy51cGRhdGVEZWJvdW5jZVRpbWVyKVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlRGVib3VuY2VUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlSGFuZGxlcih2aWV3LCBzZWxlY3Rpb25DaGFuZ2VkLCBkb2NDaGFuZ2VkLCBvbGRTdGF0ZSlcbiAgICB9LCB0aGlzLnVwZGF0ZURlbGF5KVxuICB9XG5cbiAgdXBkYXRlSGFuZGxlciA9ICh2aWV3OiBFZGl0b3JWaWV3LCBzZWxlY3Rpb25DaGFuZ2VkOiBib29sZWFuLCBkb2NDaGFuZ2VkOiBib29sZWFuLCBvbGRTdGF0ZT86IEVkaXRvclN0YXRlKSA9PiB7XG4gICAgY29uc3QgeyBzdGF0ZSwgY29tcG9zaW5nIH0gPSB2aWV3XG4gICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlXG5cbiAgICBjb25zdCBpc1NhbWUgPSAhc2VsZWN0aW9uQ2hhbmdlZCAmJiAhZG9jQ2hhbmdlZFxuXG4gICAgaWYgKGNvbXBvc2luZyB8fCBpc1NhbWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY3JlYXRlVG9vbHRpcCgpXG5cbiAgICAvLyBzdXBwb3J0IGZvciBDZWxsU2VsZWN0aW9uc1xuICAgIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb25cbiAgICBjb25zdCBmcm9tID0gTWF0aC5taW4oLi4ucmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS4kZnJvbS5wb3MpKVxuICAgIGNvbnN0IHRvID0gTWF0aC5tYXgoLi4ucmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS4kdG8ucG9zKSlcblxuICAgIGNvbnN0IHNob3VsZFNob3cgPSB0aGlzLnNob3VsZFNob3c/Lih7XG4gICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgdmlldyxcbiAgICAgIHN0YXRlLFxuICAgICAgb2xkU3RhdGUsXG4gICAgICBmcm9tLFxuICAgICAgdG8sXG4gICAgfSlcblxuICAgIGlmICghc2hvdWxkU2hvdykge1xuICAgICAgdGhpcy5oaWRlKClcblxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy50aXBweT8uc2V0UHJvcHMoe1xuICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDpcbiAgICAgICAgdGhpcy50aXBweU9wdGlvbnM/LmdldFJlZmVyZW5jZUNsaWVudFJlY3RcbiAgICAgICAgfHwgKCgpID0+IHtcbiAgICAgICAgICBpZiAoaXNOb2RlU2VsZWN0aW9uKHN0YXRlLnNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gdmlldy5ub2RlRE9NKGZyb20pIGFzIEhUTUxFbGVtZW50XG5cbiAgICAgICAgICAgIGNvbnN0IG5vZGVWaWV3V3JhcHBlciA9IG5vZGUuZGF0YXNldC5ub2RlVmlld1dyYXBwZXIgPyBub2RlIDogbm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1ub2RlLXZpZXctd3JhcHBlcl0nKVxuXG4gICAgICAgICAgICBpZiAobm9kZVZpZXdXcmFwcGVyKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBub2RlVmlld1dyYXBwZXIuZmlyc3RDaGlsZCBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBwb3NUb0RPTVJlY3QodmlldywgZnJvbSwgdG8pXG4gICAgICAgIH0pLFxuICAgIH0pXG5cbiAgICB0aGlzLnNob3coKVxuICB9XG5cbiAgc2hvdygpIHtcbiAgICB0aGlzLnRpcHB5Py5zaG93KClcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgdGhpcy50aXBweT8uaGlkZSgpXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnRpcHB5Py5wb3BwZXIuZmlyc3RDaGlsZCkge1xuICAgICAgKHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQgYXMgSFRNTEVsZW1lbnQpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICdibHVyJyxcbiAgICAgICAgdGhpcy50aXBweUJsdXJIYW5kbGVyLFxuICAgICAgKVxuICAgIH1cbiAgICB0aGlzLnRpcHB5Py5kZXN0cm95KClcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZWRvd25IYW5kbGVyLCB7IGNhcHR1cmU6IHRydWUgfSlcbiAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuZHJhZ3N0YXJ0SGFuZGxlcilcbiAgICB0aGlzLmVkaXRvci5vZmYoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXIpXG4gICAgdGhpcy5lZGl0b3Iub2ZmKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQnViYmxlTWVudVBsdWdpbiA9IChvcHRpb25zOiBCdWJibGVNZW51UGx1Z2luUHJvcHMpID0+IHtcbiAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgIGtleTpcbiAgICAgIHR5cGVvZiBvcHRpb25zLnBsdWdpbktleSA9PT0gJ3N0cmluZycgPyBuZXcgUGx1Z2luS2V5KG9wdGlvbnMucGx1Z2luS2V5KSA6IG9wdGlvbnMucGx1Z2luS2V5LFxuICAgIHZpZXc6IHZpZXcgPT4gbmV3IEJ1YmJsZU1lbnVWaWV3KHsgdmlldywgLi4ub3B0aW9ucyB9KSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmltcG9ydCB7IEJ1YmJsZU1lbnVQbHVnaW4sIEJ1YmJsZU1lbnVQbHVnaW5Qcm9wcyB9IGZyb20gJy4vYnViYmxlLW1lbnUtcGx1Z2luLmpzJ1xuXG5leHBvcnQgdHlwZSBCdWJibGVNZW51T3B0aW9ucyA9IE9taXQ8QnViYmxlTWVudVBsdWdpblByb3BzLCAnZWRpdG9yJyB8ICdlbGVtZW50Jz4gJiB7XG4gIGVsZW1lbnQ6IEhUTUxFbGVtZW50IHwgbnVsbCxcbn1cblxuZXhwb3J0IGNvbnN0IEJ1YmJsZU1lbnUgPSBFeHRlbnNpb24uY3JlYXRlPEJ1YmJsZU1lbnVPcHRpb25zPih7XG4gIG5hbWU6ICdidWJibGVNZW51JyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50OiBudWxsLFxuICAgICAgdGlwcHlPcHRpb25zOiB7fSxcbiAgICAgIHBsdWdpbktleTogJ2J1YmJsZU1lbnUnLFxuICAgICAgdXBkYXRlRGVsYXk6IHVuZGVmaW5lZCxcbiAgICAgIHNob3VsZFNob3c6IG51bGwsXG4gICAgfVxuICB9LFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5lbGVtZW50KSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgQnViYmxlTWVudVBsdWdpbih7XG4gICAgICAgIHBsdWdpbktleTogdGhpcy5vcHRpb25zLnBsdWdpbktleSxcbiAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgZWxlbWVudDogdGhpcy5vcHRpb25zLmVsZW1lbnQsXG4gICAgICAgIHRpcHB5T3B0aW9uczogdGhpcy5vcHRpb25zLnRpcHB5T3B0aW9ucyxcbiAgICAgICAgdXBkYXRlRGVsYXk6IHRoaXMub3B0aW9ucy51cGRhdGVEZWxheSxcbiAgICAgICAgc2hvdWxkU2hvdzogdGhpcy5vcHRpb25zLnNob3VsZFNob3csXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IEVkaXRvciB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCBEb2N1bWVudCBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tZG9jdW1lbnRcIjtcbmltcG9ydCBDaGFyYWN0ZXJDb3VudCBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tY2hhcmFjdGVyLWNvdW50XCI7XG5pbXBvcnQgU3RhcnRlcktpdCBmcm9tIFwiQHRpcHRhcC9zdGFydGVyLWtpdFwiO1xuaW1wb3J0IEJ1YmJsZU1lbnUgZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWJ1YmJsZS1tZW51XCI7XG5cbmNvbnN0IGNvbmZpZyA9IHtcbiAgICBkb2N1bWVudDogRG9jdW1lbnQuZXh0ZW5kKHtcbiAgICAgICAgY29udGVudDogXCJoZWFkaW5nIGJsb2NrKlwiLFxuICAgIH0pLFxuICAgIGVkaXRvclByb3BzOiB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIGNsYXNzOlxuICAgICAgICAgICAgICAgIFwicHJvc2UgcHJvc2Utc20gc206cHJvc2UgbGc6cHJvc2UtbGcgeGw6cHJvc2UtbGcgZm9jdXM6b3V0bGluZS1ub25lXCIsXG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJhbHBpbmU6aW5pdFwiLCAoKSA9PiB7XG4gICAgQWxwaW5lLmRhdGEoXCJ0YWxsdGFwXCIsIChjb250ZW50LCBidWJibGVNZW51QWN0aXZlVHJpZ2dlcikgPT4ge1xuICAgICAgICBjb25zdCByZWYgPSBcInRhbGxFZGl0b3JcIjtcbiAgICAgICAgaWYgKCF3aW5kb3cudGFsbHRhcCkge1xuICAgICAgICAgICAgd2luZG93LnRhbGx0YXAgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZWRpdG9yID0gd2luZG93LnRhbGx0YXBbcmVmXTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXBkYXRlZEF0OiBEYXRlLm5vdygpLCAvLyBmb3JjZSBBbHBpbmUgdG8gcmVyZW5kZXIgb24gc2VsZWN0aW9uIGNoYW5nZVxuICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGF0YToge30sXG4gICAgICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgICAgIGlmIChlZGl0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWRpdG9yID0gbmV3IEVkaXRvcih7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuJHJlZnMudGlwdGFwLFxuICAgICAgICAgICAgICAgICAgICBlZGl0b3JQcm9wczogY29uZmlnLmVkaXRvclByb3BzLFxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZG9jdW1lbnQsIC4uLndpbmRvdy50YWxsdGFwUmVnaXN0cnkuZ2V0RXh0ZW5zaW9ucygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgU3RhcnRlcktpdC5jb25maWd1cmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVCbG9jazogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BjdXJzb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwic2t5Ymx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgQnViYmxlTWVudS5jb25maWd1cmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbktleTogXCJ0YWxsdGFwLWJ1YmJsZS1tZW51XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidWJibGVNZW51JyksLy90aGlzLiRyZWZzLmJ1YmJsZU1lbnUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkU2hvdzogKHsgZWRpdG9yIH0pID0+IGJ1YmJsZU1lbnVBY3RpdmVUcmlnZ2VyLnNvbWUodHJpZ2dlciA9PiBlZGl0b3IuaXNBY3RpdmUodHJpZ2dlcikgfHwgKHRyaWdnZXIgPT09ICcqJyAmJiAhZWRpdG9yLnZpZXcuc3RhdGUuc2VsZWN0aW9uLmVtcHR5KSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIENoYXJhY3RlckNvdW50XG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIG9uQ3JlYXRlKHsgZWRpdG9yIH0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jcmVhdGVFeHRlcm5hbERhdGEoZWRpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRkaXNwYXRjaChcInVwZGF0ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25VcGRhdGUoeyBlZGl0b3IgfSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZUV4dGVybmFsRGF0YShlZGl0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGRpc3BhdGNoKFwidXBkYXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvblNlbGVjdGlvblVwZGF0ZSh7IGVkaXRvciB9KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGRpc3BhdGNoKFwidXBkYXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHdpbmRvdy50YWxsdGFwW3JlZl0gPSBlZGl0b3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWRpdG9yKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlRXh0ZXJuYWxEYXRhKGVkaXRvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5jaGFyYWN0ZXJDb3VudCA9IGVkaXRvci5zdG9yYWdlLmNoYXJhY3RlckNvdW50LmNoYXJhY3RlcnMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVFeHRlcm5hbERhdGEoZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLmNoYXJhY3RlckNvdW50ID0gZWRpdG9yLnN0b3JhZ2UuY2hhcmFjdGVyQ291bnQuY2hhcmFjdGVycygpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudCA9IGVkaXRvci5nZXRIVE1MKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJvdW5jZU91dHB1dCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYm91bmNlT3V0cHV0KCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSBBbHBpbmUuZGVib3VuY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kd2lyZS5zZXQoXCJ2YWx1ZVwiLCB0aGlzLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjb250ZW50LXVwZGF0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICA1MDAsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0FjdGl2ZSh0eXBlLCBvcHRzID0ge30pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWRpdG9yLmlzQWN0aXZlKHR5cGUsIG9wdHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn0pO1xuIl0sCiAgIm1hcHBpbmdzIjogIjs7QUFFQSxXQUFTLFdBQVcsU0FBUztBQUMzQixTQUFLLFVBQVU7QUFBQSxFQUNqQjtBQUVBLGFBQVcsWUFBWTtBQUFBLElBQ3JCLGFBQWE7QUFBQSxJQUViLE1BQU0sU0FBUyxLQUFLO0FBQ2xCLGVBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLFFBQVEsS0FBSztBQUM1QyxZQUFJLEtBQUssUUFBUSxDQUFDLE1BQU07QUFBSyxpQkFBTztBQUN0QyxhQUFPO0FBQUEsSUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBLElBS0EsS0FBSyxTQUFTLEtBQUs7QUFDakIsVUFBSUEsU0FBUSxLQUFLLEtBQUssR0FBRztBQUN6QixhQUFPQSxVQUFTLEtBQUssU0FBWSxLQUFLLFFBQVFBLFNBQVEsQ0FBQztBQUFBLElBQ3pEO0FB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SUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLEVBQ1A7QUFFTyxNQUFJLFFBQVE7QUFBQSxJQUNqQixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJ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Zm91bmQiLCAicm91bmQiLCAib2Zmc2V0IiwgInNsaWNlIiwgIm1haW4iLCAiZG9jIiwgImJhc2UiLCAiaSIsICJtaW4iLCAibWF4IiwgInR5cGUiLCAibmZhIiwgImVkZ2UiLCAiZXhwciIsICJub2RlIiwgInN0YXRlcyIsICJtYXJrIiwgInN0eWxlIiwgIndyYXAiLCAidG9wIiwgInNwYWNlIiwgIm9mZnNldCIsICJzdGFydCIsICJlbmQiLCAiZGVsIiwgImZyb20iLCAibWFwIiwgImRvYyIsICJzbGljZSIsICJwYXJlbnQiLCAiZm91bmQiLCAic3R5bGUiLCAiYmFzZSIsICJpbmRleCIsICJqb2luYWJsZSIsICJmaXJzdCIsICJ3cmFwIiwgIm1hdGNoZXMiLCAidG9wIiwgIm1hdGNoIiwgInR5cGUiLCAiY2xvc2UiLCAiVHJhbnNmb3JtRXJyb3IiLCAiZnJvbSIsICJmb3VuZCIsICJkb2MiLCAibWFwIiwgImVuZCIsICJzbGljZSIsICJjb25maWciLCAiZnJvbSIsICJvZmZzZXQiLCAiZG9jIiwgInRvcCIsICJsZWZ0IiwgImZpcnN0IiwgImVuZCIsICJlbnRlciIsICJiYXNlIiwgIndyYXAiLCAiY29weSIsICJzdGFydCIsICJmb3VuZCIsICJwcmVNYXRjaCIsICJtYXRjaGVzIiwgImVtcHR5IiwgInNsaWNlIiwgImRvbSIsICJldmVudCIsICJoYW5kbGVycyIsICJjdXQiLCAiTm9kZVR5cGUiLCAiaSIsICJvbGRPZmZzZXQiLCAicmVhZCIsICJhbmNob3IiLCAidHIiLCAic2VsIiwgImZyb20iLCAicHJvcCIsICJvZmZzZXQiLCAibWFjIiwgImllIiwgIm1hYyIsICJzaGlmdCIsICJtYXAiLCAiY29weSIsICJlbXB0eSIsICJsaWZ0IiwgImZpcnN0IiwgImVuZCIsICJ3cmFwIiwgInNldEJsb2NrVHlwZSIsICJmcm9tIiwgImNvbW1hbmRzIiwgIm1hYyIsICJ3cmFwIiwgImZvdW5kIiwgImZpcnN0IiwgImVuZCIsICJzdGFydCIsICJzbGljZSIsICJjb25maWciLCAiZG9jIiwgImNvbW1hbmQiLCAicnVuIiwgImZuIiwgImV4dGVuc2lvbnMiLCAiX2EiLCAiZnJvbSIsICJjb21tYW5kcyIsICJtYXRjaGVzIiwgImhhbmRsZXJzIiwgInN0YXJ0IiwgImVuZCIsICJvbkNyZWF0ZSIsICJvbkRlc3Ryb3kiLCAiTWFyayIsICJyYW5nZSIsICJjcmVhdGVQYXJhZ3JhcGhOZWFyIiwgIm9yaWdpbmFsQ3JlYXRlUGFyYWdyYXBoTmVhciIsICJkZWxldGVSYW5nZSIsICJkZWxldGVTZWxlY3Rpb24iLCAib3JpZ2luYWxEZWxldGVTZWxlY3Rpb24iLCAiZXhpdENvZGUiLCAib3JpZ2luYWxFeGl0Q29kZSIsICJrZXlzIiwgIm1pbiIsICJtYXgiLCAic2VsZWN0aW9uVG9JbnNlcnRpb25FbmQiLCAibWFwIiwgImpvaW5VcCIsICJvcmlnaW5hbEpvaW5VcCIsICJqb2luRG93biIsICJvcmlnaW5hbEpvaW5Eb3duIiwgImpvaW5CYWNrd2FyZCIsICJvcmlnaW5hbEpvaW5CYWNrd2FyZCIsICJqb2luRm9yd2FyZCIsICJvcmlnaW5hbEpvaW5Gb3J3YXJkIiwgIm5vcm1hbGl6ZUtleU5hbWUiLCAic2hpZnQiLCAiZW1wdHkiLCAibGlmdCIsICJpc0FjdGl2ZSIsICJvcmlnaW5hbExpZnQiLCAibGlmdEVtcHR5QmxvY2siLCAib3JpZ2luYWxMaWZ0RW1wdHlCbG9jayIsICJsaWZ0TGlzdEl0ZW0iLCAib3JpZ2luYWxMaWZ0TGlzdEl0ZW0iLCAibmV3bGluZUluQ29kZSIsICJvcmlnaW5hbE5ld2xpbmVJbkNvZGUiLCAic2VsZWN0QWxsIiwgInNlbGVjdE5vZGVCYWNrd2FyZCIsICJvcmlnaW5hbFNlbGVjdE5vZGVCYWNrd2FyZCIsICJzZWxlY3ROb2RlRm9yd2FyZCIsICJvcmlnaW5hbFNlbGVjdE5vZGVGb3J3YXJkIiwgInNlbGVjdFBhcmVudE5vZGUiLCAib3JpZ2luYWxTZWxlY3RQYXJlbnROb2RlIiwgInNlbGVjdFRleHRibG9ja0VuZCIsICJvcmlnaW5hbFNlbGVjdFRleHRibG9ja0VuZCIsICJzZWxlY3RUZXh0YmxvY2tTdGFydCIsICJvcmlnaW5hbFNlbGVjdFRleHRibG9ja1N0YXJ0IiwgImRvY3VtZW50IiwgImRlZmF1bHRCbG9ja0F0IiwgImZyb20iLCAibm9kZSIsICJmcm9tIiwgImRvYyIsICJlbXB0eSIsICJmcm9tIiwgInJhbmdlIiwgImV4dGVuc2lvbnMiLCAiZnJvbSIsICJzdGFydCIsICJlbmQiLCAidG9wIiwgImJvdHRvbSIsICJsZWZ0IiwgInJpZ2h0IiwgImVtcHR5IiwgImNvbW1hbmRzIiwgInNldEJsb2NrVHlwZSIsICJkb2MiLCAic2lua0xpc3RJdGVtIiwgIm9yaWdpbmFsU2lua0xpc3RJdGVtIiwgInNwbGl0QmxvY2siLCAiZGVmYXVsdEJsb2NrQXQiLCAiZmlyc3QiLCAid3JhcCIsICJuZXdOZXh0VHlwZUF0dHJpYnV0ZXMiLCAibmV4dFR5cGUiLCAiaXNBY3RpdmUiLCAid3JhcEluIiwgIm9yaWdpbmFsV3JhcEluIiwgIndyYXBJbkxpc3QiLCAib3JpZ2luYWxXcmFwSW5MaXN0IiwgInN0eWxlIiwgImZuIiwgImZvY3VzIiwgImJsdXIiLCAiY29uZmlnIiwgIm9mZnNldCIsICJjb25maWciLCAiTWFyayIsICJyZW1vdmVNYXJrIiwgIk5vZGUiLCAiY29uZmlnIiwgIk5vZGUiLCAiZnJvbSIsICJOb2RlIiwgImNvbW1hbmRzIiwgIk1hcmsiLCAiY29tbWFuZHMiLCAiTm9kZSIsICJNYXJrIiwgImNvbW1hbmRzIiwgImlucHV0UmVnZXgiLCAiaW5wdXRSZWdleCIsICJNYXJrIiwgImNvbW1hbmRzIiwgIk5vZGUiLCAiY29tbWFuZHMiLCAiZW1wdHkiLCAiZG9jIiwgInRvcCIsICJyZWN0IiwgImRvYyIsICJOb2RlIiwgImNvbW1hbmRzIiwgIk5vZGUiLCAiY29tbWFuZHMiLCAiUm9wZVNlcXVlbmNlIiwgImZyb20iLCAiZm9yRWFjaCIsICJMZWFmIiwgInN0YXJ0IiwgIkFwcGVuZCIsICJsZWZ0IiwgInJpZ2h0IiwgImFwcGVuZElubmVyIiwgImRpc3RfZGVmYXVsdCIsICJlbmQiLCAibWFwIiwgImZyb20iLCAic3RhcnQiLCAiZGlzdF9kZWZhdWx0IiwgImhpc3RvcnkiLCAicmVkbyIsICJjb25maWciLCAiY29tbWFuZCIsICJOb2RlIiwgInN0YXJJbnB1dFJlZ2V4IiwgInN0YXJQYXN0ZVJlZ2V4IiwgInVuZGVyc2NvcmVJbnB1dFJlZ2V4IiwgInVuZGVyc2NvcmVQYXN0ZVJlZ2V4IiwgIk1hcmsiLCAiY29tbWFuZHMiLCAiTGlzdEl0ZW0iLCAiTm9kZSIsICJMaXN0SXRlbSIsICJOb2RlIiwgIlRleHRTdHlsZSIsICJNYXJrIiwgImNvbW1hbmRzIiwgImlucHV0UmVnZXgiLCAic3RhcnQiLCAiTm9kZSIsICJjb21tYW5kcyIsICJpbnB1dFJlZ2V4IiwgInBhc3RlUmVnZXgiLCAiTWFyayIsICJzdHlsZSIsICJjb21tYW5kcyIsICJOb2RlIiwgImV4dGVuc2lvbnMiLCAiTGlzdEl0ZW0iLCAic3R5bGUiLCAibmFtZSIsICJjbGllbnRSZWN0IiwgImNsaWVudFJlY3QiLCAiZ2V0Q29tcHV0ZWRTdHlsZSIsICJnZXRDb21wdXRlZFN0eWxlIiwgIndpbmRvdyIsICJtaW4iLCAibWF4IiwgImtleXMiLCAidG9QYWRkaW5nT2JqZWN0IiwgImFycm93IiwgInBvcHBlck9mZnNldHMiLCAibWluIiwgIm1heCIsICJvZmZzZXQiLCAiZWZmZWN0IiwgInBvcHBlciIsICJnZXRDb21wdXRlZFN0eWxlIiwgImVmZmVjdCIsICJ3aW5kb3ciLCAiaGFzaCIsICJnZXRDb21wdXRlZFN0eWxlIiwgImdldENvbXB1dGVkU3R5bGUiLCAiY2xpcHBpbmdQYXJlbnRzIiwgImdldENvbXB1dGVkU3R5bGUiLCAicmVmZXJlbmNlIiwgInBvcHBlck9mZnNldHMiLCAib2Zmc2V0IiwgInBsYWNlbWVudHMiLCAicGxhY2VtZW50IiwgInBsYWNlbWVudHMiLCAicGxhY2VtZW50IiwgIl9sb29wIiwgIl9pIiwgImNoZWNrcyIsICJvZmZzZXQiLCAicG9wcGVyT2Zmc2V0cyIsICJvZmZzZXQiLCAibWluIiwgIm1heCIsICJtb2RpZmllcnMiLCAibWFwIiwgImZuIiwgIm1vZGlmaWVycyIsICJtZXJnZWQiLCAiZGVmYXVsdE1vZGlmaWVycyIsICJjcmVhdGVQb3BwZXIiLCAicmVmZXJlbmNlIiwgInBvcHBlciIsICJvcHRpb25zIiwgImZuIiwgInN0YXRlIiwgImVmZmVjdCIsICJub29wRm4iLCAiQk9YX0NMQVNTIiwgIkNPTlRFTlRfQ0xBU1MiLCAiQkFDS0RST1BfQ0xBU1MiLCAiQVJST1dfQ0xBU1MiLCAiU1ZHX0FSUk9XX0NMQVNTIiwgIlRPVUNIX09QVElPTlMiLCAicGFzc2l2ZSIsICJjYXB0dXJlIiwgIlRJUFBZX0RFRkFVTFRfQVBQRU5EX1RPIiwgImRvY3VtZW50IiwgImJvZHkiLCAiaGFzT3duUHJvcGVydHkiLCAib2JqIiwgImtleSIsICJjYWxsIiwgImdldFZhbHVlQXRJbmRleE9yUmV0dXJuIiwgInZhbHVlIiwgImluZGV4IiwgImRlZmF1bHRWYWx1ZSIsICJBcnJheSIsICJpc0FycmF5IiwgInYiLCAiaXNUeXBlIiwgInR5cGUiLCAic3RyIiwgInRvU3RyaW5nIiwgImluZGV4T2YiLCAiaW52b2tlV2l0aEFyZ3NPclJldHVybiIsICJhcmdzIiwgImRlYm91bmNlIiwgImZuIiwgIm1zIiwgInRpbWVvdXQiLCAiYXJnIiwgImNsZWFyVGltZW91dCIsICJzZXRUaW1lb3V0IiwgInJlbW92ZVByb3BlcnRpZXMiLCAia2V5cyIsICJjbG9uZSIsICJmb3JFYWNoIiwgInNwbGl0QnlTcGFjZXMiLCAic3BsaXQiLCAiZmlsdGVyIiwgIkJvb2xlYW4iLCAibm9ybWFsaXplVG9BcnJheSIsICJjb25jYXQiLCAicHVzaElmVW5pcXVlIiwgImFyciIsICJwdXNoIiwgInVuaXF1ZSIsICJpdGVtIiwgImdldEJhc2VQbGFjZW1lbnQiLCAicGxhY2VtZW50IiwgImFycmF5RnJvbSIsICJzbGljZSIsICJyZW1vdmVVbmRlZmluZWRQcm9wcyIsICJPYmplY3QiLCAicmVkdWNlIiwgImFjYyIsICJ1bmRlZmluZWQiLCAiZGl2IiwgImNyZWF0ZUVsZW1lbnQiLCAiaXNFbGVtZW50IiwgInNvbWUiLCAiaXNOb2RlTGlzdCIsICJpc01vdXNlRXZlbnQiLCAiaXNSZWZlcmVuY2VFbGVtZW50IiwgIl90aXBweSIsICJyZWZlcmVuY2UiLCAiZ2V0QXJyYXlPZkVsZW1lbnRzIiwgInF1ZXJ5U2VsZWN0b3JBbGwiLCAic2V0VHJhbnNpdGlvbkR1cmF0aW9uIiwgImVscyIsICJlbCIsICJzdHlsZSIsICJ0cmFuc2l0aW9uRHVyYXRpb24iLCAic2V0VmlzaWJpbGl0eVN0YXRlIiwgInN0YXRlIiwgInNldEF0dHJpYnV0ZSIsICJnZXRPd25lckRvY3VtZW50IiwgImVsZW1lbnRPckVsZW1lbnRzIiwgImVsZW1lbnQiLCAib3duZXJEb2N1bWVudCIsICJpc0N1cnNvck91dHNpZGVJbnRlcmFjdGl2ZUJvcmRlciIsICJwb3BwZXJUcmVlRGF0YSIsICJldmVudCIsICJjbGllbnRYIiwgImNsaWVudFkiLCAiZXZlcnkiLCAicG9wcGVyUmVjdCIsICJwb3BwZXJTdGF0ZSIsICJwcm9wcyIsICJpbnRlcmFjdGl2ZUJvcmRlciIsICJiYXNlUGxhY2VtZW50IiwgIm9mZnNldERhdGEiLCAibW9kaWZpZXJzRGF0YSIsICJvZmZzZXQiLCAidG9wRGlzdGFuY2UiLCAidG9wIiwgInkiLCAiYm90dG9tRGlzdGFuY2UiLCAiYm90dG9tIiwgImxlZnREaXN0YW5jZSIsICJsZWZ0IiwgIngiLCAicmlnaHREaXN0YW5jZSIsICJyaWdodCIsICJleGNlZWRzVG9wIiwgImV4Y2VlZHNCb3R0b20iLCAiZXhjZWVkc0xlZnQiLCAiZXhjZWVkc1JpZ2h0IiwgInVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lciIsICJib3giLCAiYWN0aW9uIiwgImxpc3RlbmVyIiwgIm1ldGhvZCIsICJhY3R1YWxDb250YWlucyIsICJwYXJlbnQiLCAiY2hpbGQiLCAidGFyZ2V0IiwgImNvbnRhaW5zIiwgImdldFJvb3ROb2RlIiwgImhvc3QiLCAiY3VycmVudElucHV0IiwgImlzVG91Y2giLCAibGFzdE1vdXNlTW92ZVRpbWUiLCAib25Eb2N1bWVudFRvdWNoU3RhcnQiLCAid2luZG93IiwgInBlcmZvcm1hbmNlIiwgImFkZEV2ZW50TGlzdGVuZXIiLCAib25Eb2N1bWVudE1vdXNlTW92ZSIsICJub3ciLCAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsICJvbldpbmRvd0JsdXIiLCAiYWN0aXZlRWxlbWVudCIsICJpbnN0YW5jZSIsICJibHVyIiwgImlzVmlzaWJsZSIsICJiaW5kR2xvYmFsRXZlbnRMaXN0ZW5lcnMiLCAiaXNCcm93c2VyIiwgImlzSUUxMSIsICJtc0NyeXB0byIsICJjcmVhdGVNZW1vcnlMZWFrV2FybmluZyIsICJ0eHQiLCAiam9pbiIsICJjbGVhbiIsICJzcGFjZXNBbmRUYWJzIiwgImxpbmVTdGFydFdpdGhTcGFjZXMiLCAicmVwbGFjZSIsICJ0cmltIiwgImdldERldk1lc3NhZ2UiLCAibWVzc2FnZSIsICJnZXRGb3JtYXR0ZWRNZXNzYWdlIiwgInZpc2l0ZWRNZXNzYWdlcyIsICJyZXNldFZpc2l0ZWRNZXNzYWdlcyIsICJTZXQiLCAid2FybldoZW4iLCAiY29uZGl0aW9uIiwgImhhcyIsICJhZGQiLCAiY29uc29sZSIsICJ3YXJuIiwgImVycm9yV2hlbiIsICJlcnJvciIsICJ2YWxpZGF0ZVRhcmdldHMiLCAidGFyZ2V0cyIsICJkaWRQYXNzRmFsc3lWYWx1ZSIsICJkaWRQYXNzUGxhaW5PYmplY3QiLCAicHJvdG90eXBlIiwgIlN0cmluZyIsICJwbHVnaW5Qcm9wcyIsICJhbmltYXRlRmlsbCIsICJmb2xsb3dDdXJzb3IiLCAiaW5saW5lUG9zaXRpb25pbmciLCAic3RpY2t5IiwgInJlbmRlclByb3BzIiwgImFsbG93SFRNTCIsICJhbmltYXRpb24iLCAiYXJyb3ciLCAiY29udGVudCIsICJpbmVydGlhIiwgIm1heFdpZHRoIiwgInJvbGUiLCAidGhlbWUiLCAiekluZGV4IiwgImRlZmF1bHRQcm9wcyIsICJhcHBlbmRUbyIsICJhcmlhIiwgImV4cGFuZGVkIiwgImRlbGF5IiwgImR1cmF0aW9uIiwgImdldFJlZmVyZW5jZUNsaWVudFJlY3QiLCAiaGlkZU9uQ2xpY2siLCAiaWdub3JlQXR0cmlidXRlcyIsICJpbnRlcmFjdGl2ZSIsICJpbnRlcmFjdGl2ZURlYm91bmNlIiwgIm1vdmVUcmFuc2l0aW9uIiwgIm9uQWZ0ZXJVcGRhdGUiLCAib25CZWZvcmVVcGRhdGUiLCAib25DcmVhdGUiLCAib25EZXN0cm95IiwgIm9uSGlkZGVuIiwgIm9uSGlkZSIsICJvbk1vdW50IiwgIm9uU2hvdyIsICJvblNob3duIiwgIm9uVHJpZ2dlciIsICJvblVudHJpZ2dlciIsICJvbkNsaWNrT3V0c2lkZSIsICJwbHVnaW5zIiwgInBvcHBlck9wdGlvbnMiLCAicmVuZGVyIiwgInNob3dPbkNyZWF0ZSIsICJ0b3VjaCIsICJ0cmlnZ2VyIiwgInRyaWdnZXJUYXJnZXQiLCAiZGVmYXVsdEtleXMiLCAic2V0RGVmYXVsdFByb3BzIiwgInBhcnRpYWxQcm9wcyIsICJ2YWxpZGF0ZVByb3BzIiwgImdldEV4dGVuZGVkUGFzc2VkUHJvcHMiLCAicGFzc2VkUHJvcHMiLCAicGx1Z2luIiwgIm5hbWUiLCAiZ2V0RGF0YUF0dHJpYnV0ZVByb3BzIiwgInByb3BLZXlzIiwgInZhbHVlQXNTdHJpbmciLCAiZ2V0QXR0cmlidXRlIiwgIkpTT04iLCAicGFyc2UiLCAiZSIsICJldmFsdWF0ZVByb3BzIiwgIm91dCIsICJwcm9wIiwgIm5vblBsdWdpblByb3BzIiwgImRpZFBhc3NVbmtub3duUHJvcCIsICJsZW5ndGgiLCAiaW5uZXJIVE1MIiwgImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwgImh0bWwiLCAiY3JlYXRlQXJyb3dFbGVtZW50IiwgImNsYXNzTmFtZSIsICJhcHBlbmRDaGlsZCIsICJzZXRDb250ZW50IiwgInRleHRDb250ZW50IiwgImdldENoaWxkcmVuIiwgInBvcHBlciIsICJmaXJzdEVsZW1lbnRDaGlsZCIsICJib3hDaGlsZHJlbiIsICJjaGlsZHJlbiIsICJmaW5kIiwgIm5vZGUiLCAiY2xhc3NMaXN0IiwgImJhY2tkcm9wIiwgIm9uVXBkYXRlIiwgInByZXZQcm9wcyIsICJuZXh0UHJvcHMiLCAicmVtb3ZlQXR0cmlidXRlIiwgInJlbW92ZUNoaWxkIiwgIiQkdGlwcHkiLCAiaWRDb3VudGVyIiwgIm1vdXNlTW92ZUxpc3RlbmVycyIsICJtb3VudGVkSW5zdGFuY2VzIiwgImNyZWF0ZVRpcHB5IiwgInNob3dUaW1lb3V0IiwgImhpZGVUaW1lb3V0IiwgInNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lIiwgImlzVmlzaWJsZUZyb21DbGljayIsICJkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93biIsICJkaWRUb3VjaE1vdmUiLCAiaWdub3JlT25GaXJzdFVwZGF0ZSIsICJsYXN0VHJpZ2dlckV2ZW50IiwgImN1cnJlbnRUcmFuc2l0aW9uRW5kTGlzdGVuZXIiLCAib25GaXJzdFVwZGF0ZSIsICJsaXN0ZW5lcnMiLCAiZGVib3VuY2VkT25Nb3VzZU1vdmUiLCAib25Nb3VzZU1vdmUiLCAiY3VycmVudFRhcmdldCIsICJpZCIsICJwb3BwZXJJbnN0YW5jZSIsICJpc0VuYWJsZWQiLCAiaXNEZXN0cm95ZWQiLCAiaXNNb3VudGVkIiwgImlzU2hvd24iLCAiY2xlYXJEZWxheVRpbWVvdXRzIiwgInNldFByb3BzIiwgInNob3ciLCAiaGlkZSIsICJoaWRlV2l0aEludGVyYWN0aXZpdHkiLCAiZW5hYmxlIiwgImRpc2FibGUiLCAidW5tb3VudCIsICJkZXN0cm95IiwgInBsdWdpbnNIb29rcyIsICJtYXAiLCAiaGFzQXJpYUV4cGFuZGVkIiwgImhhc0F0dHJpYnV0ZSIsICJhZGRMaXN0ZW5lcnMiLCAiaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlIiwgImhhbmRsZVN0eWxlcyIsICJpbnZva2VIb29rIiwgInNjaGVkdWxlU2hvdyIsICJnZXREb2N1bWVudCIsICJnZXROb3JtYWxpemVkVG91Y2hTZXR0aW5ncyIsICJnZXRJc0N1c3RvbVRvdWNoQmVoYXZpb3IiLCAiZ2V0SXNEZWZhdWx0UmVuZGVyRm4iLCAiZ2V0Q3VycmVudFRhcmdldCIsICJwYXJlbnROb2RlIiwgImdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuIiwgImdldERlbGF5IiwgImlzU2hvdyIsICJmcm9tSGlkZSIsICJwb2ludGVyRXZlbnRzIiwgImhvb2siLCAic2hvdWxkSW52b2tlUHJvcHNIb29rIiwgInBsdWdpbkhvb2tzIiwgImhhbmRsZUFyaWFDb250ZW50QXR0cmlidXRlIiwgImF0dHIiLCAibm9kZXMiLCAiY3VycmVudFZhbHVlIiwgIm5leHRWYWx1ZSIsICJjbGVhbnVwSW50ZXJhY3RpdmVNb3VzZUxpc3RlbmVycyIsICJvbkRvY3VtZW50UHJlc3MiLCAiYWN0dWFsVGFyZ2V0IiwgImNvbXBvc2VkUGF0aCIsICJyZW1vdmVEb2N1bWVudFByZXNzIiwgIm9uVG91Y2hNb3ZlIiwgIm9uVG91Y2hTdGFydCIsICJhZGREb2N1bWVudFByZXNzIiwgImRvYyIsICJvblRyYW5zaXRpb25lZE91dCIsICJjYWxsYmFjayIsICJvblRyYW5zaXRpb25FbmQiLCAib25UcmFuc2l0aW9uZWRJbiIsICJvbiIsICJldmVudFR5cGUiLCAiaGFuZGxlciIsICJvcHRpb25zIiwgIm9uTW91c2VMZWF2ZSIsICJvbkJsdXJPckZvY3VzT3V0IiwgInJlbW92ZUxpc3RlbmVycyIsICJzaG91bGRTY2hlZHVsZUNsaWNrSGlkZSIsICJpc0V2ZW50TGlzdGVuZXJTdG9wcGVkIiwgIndhc0ZvY3VzZWQiLCAic2NoZWR1bGVIaWRlIiwgImlzQ3Vyc29yT3ZlclJlZmVyZW5jZU9yUG9wcGVyIiwgImdldE5lc3RlZFBvcHBlclRyZWUiLCAiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwgInNob3VsZEJhaWwiLCAicmVsYXRlZFRhcmdldCIsICJjcmVhdGVQb3BwZXJJbnN0YW5jZSIsICJkZXN0cm95UG9wcGVySW5zdGFuY2UiLCAiY29tcHV0ZWRSZWZlcmVuY2UiLCAiY29udGV4dEVsZW1lbnQiLCAidGlwcHlNb2RpZmllciIsICJlbmFibGVkIiwgInBoYXNlIiwgInJlcXVpcmVzIiwgImF0dHJpYnV0ZXMiLCAibW9kaWZpZXJzIiwgInBhZGRpbmciLCAiYWRhcHRpdmUiLCAiY3JlYXRlUG9wcGVyIiwgIm1vdW50IiwgIm5leHRFbGVtZW50U2libGluZyIsICJ0b3VjaFZhbHVlIiwgInRvdWNoRGVsYXkiLCAicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwgImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwgIm5lc3RlZFBvcHBlciIsICJmb3JjZVVwZGF0ZSIsICJpc0FscmVhZHlWaXNpYmxlIiwgImlzRGlzYWJsZWQiLCAiaXNUb3VjaEFuZFRvdWNoRGlzYWJsZWQiLCAidmlzaWJpbGl0eSIsICJ0cmFuc2l0aW9uIiwgIm9mZnNldEhlaWdodCIsICJpc0FscmVhZHlIaWRkZW4iLCAiaSIsICJ0aXBweSIsICJvcHRpb25hbFByb3BzIiwgImVsZW1lbnRzIiwgImlzU2luZ2xlQ29udGVudEVsZW1lbnQiLCAiaXNNb3JlVGhhbk9uZVJlZmVyZW5jZUVsZW1lbnQiLCAiaW5zdGFuY2VzIiwgImFwcGx5U3R5bGVzTW9kaWZpZXIiLCAiYXBwbHlTdHlsZXMiLCAiZWZmZWN0IiwgInN0YXRlIiwgImluaXRpYWxTdHlsZXMiLCAicG9wcGVyIiwgInBvc2l0aW9uIiwgIm9wdGlvbnMiLCAic3RyYXRlZ3kiLCAibGVmdCIsICJ0b3AiLCAibWFyZ2luIiwgImFycm93IiwgInJlZmVyZW5jZSIsICJPYmplY3QiLCAiYXNzaWduIiwgImVsZW1lbnRzIiwgInN0eWxlIiwgInN0eWxlcyIsICJ0aXBweSIsICJzZXREZWZhdWx0UHJvcHMiLCAicmVuZGVyIiwgInZpZXciLCAiZnJvbSIsICJkb2MiLCAiZW1wdHkiLCAic2hvdWxkU2hvdyIsICJlZGl0b3IiXQp9Cg==
