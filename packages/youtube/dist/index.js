(() => {
  // packages/support/resources/js/utils.js
  function registerExtension(id, callback) {
    if (id === void 0) {
      throw new Error("id can't be undefined when registering an extension");
    }
    if (callback === void 0) {
      throw new Error(
        "callback can't be undefined when registering an extension"
      );
    }
    document.addEventListener("alpine:init", () => {
      window.talltapRegistry.register(id, callback);
    });
  }

  // node_modules/prosemirror-model/dist/index.js
  function findDiffStart(a, b, pos) {
    for (let i = 0; ; i++) {
      if (i == a.childCount || i == b.childCount)
        return a.childCount == b.childCount ? null : pos;
      let childA = a.child(i),
        childB = b.child(i);
      if (childA == childB) {
        pos += childA.nodeSize;
        continue;
      }
      if (!childA.sameMarkup(childB)) return pos;
      if (childA.isText && childA.text != childB.text) {
        for (let j = 0; childA.text[j] == childB.text[j]; j++) pos++;
        return pos;
      }
      if (childA.content.size || childB.content.size) {
        let inner = findDiffStart(childA.content, childB.content, pos + 1);
        if (inner != null) return inner;
      }
      pos += childA.nodeSize;
    }
  }
  function findDiffEnd(a, b, posA, posB) {
    for (let iA = a.childCount, iB = b.childCount; ; ) {
      if (iA == 0 || iB == 0) return iA == iB ? null : { a: posA, b: posB };
      let childA = a.child(--iA),
        childB = b.child(--iB),
        size = childA.nodeSize;
      if (childA == childB) {
        posA -= size;
        posB -= size;
        continue;
      }
      if (!childA.sameMarkup(childB)) return { a: posA, b: posB };
      if (childA.isText && childA.text != childB.text) {
        let same = 0,
          minSize = Math.min(childA.text.length, childB.text.length);
        while (
          same < minSize &&
          childA.text[childA.text.length - same - 1] ==
            childB.text[childB.text.length - same - 1]
        ) {
          same++;
          posA--;
          posB--;
        }
        return { a: posA, b: posB };
      }
      if (childA.content.size || childB.content.size) {
        let inner = findDiffEnd(
          childA.content,
          childB.content,
          posA - 1,
          posB - 1
        );
        if (inner) return inner;
      }
      posA -= size;
      posB -= size;
    }
  }
  var Fragment = class _Fragment {
    /**
    @internal
    */
    constructor(content, size) {
      this.content = content;
      this.size = size || 0;
      if (size == null)
        for (let i = 0; i < content.length; i++)
          this.size += content[i].nodeSize;
    }
    /**
    Invoke a callback for all descendant nodes between the given two
    positions (relative to start of this fragment). Doesn't descend
    into a node when the callback returns `false`.
    */
    nodesBetween(from, to, f, nodeStart = 0, parent) {
      for (let i = 0, pos = 0; pos < to; i++) {
        let child = this.content[i],
          end = pos + child.nodeSize;
        if (
          end > from &&
          f(child, nodeStart + pos, parent || null, i) !== false &&
          child.content.size
        ) {
          let start = pos + 1;
          child.nodesBetween(
            Math.max(0, from - start),
            Math.min(child.content.size, to - start),
            f,
            nodeStart + start
          );
        }
        pos = end;
      }
    }
    /**
    Call the given callback for every descendant node. `pos` will be
    relative to the start of the fragment. The callback may return
    `false` to prevent traversal of a given node's children.
    */
    descendants(f) {
      this.nodesBetween(0, this.size, f);
    }
    /**
    Extract the text between `from` and `to`. See the same method on
    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
    */
    textBetween(from, to, blockSeparator, leafText) {
      let text = "",
        separated = true;
      this.nodesBetween(
        from,
        to,
        (node, pos) => {
          if (node.isText) {
            text += node.text.slice(Math.max(from, pos) - pos, to - pos);
            separated = !blockSeparator;
          } else if (node.isLeaf) {
            if (leafText) {
              text +=
                typeof leafText === "function" ? leafText(node) : leafText;
            } else if (node.type.spec.leafText) {
              text += node.type.spec.leafText(node);
            }
            separated = !blockSeparator;
          } else if (!separated && node.isBlock) {
            text += blockSeparator;
            separated = true;
          }
        },
        0
      );
      return text;
    }
    /**
    Create a new fragment containing the combined content of this
    fragment and the other.
    */
    append(other) {
      if (!other.size) return this;
      if (!this.size) return other;
      let last = this.lastChild,
        first2 = other.firstChild,
        content = this.content.slice(),
        i = 0;
      if (last.isText && last.sameMarkup(first2)) {
        content[content.length - 1] = last.withText(last.text + first2.text);
        i = 1;
      }
      for (; i < other.content.length; i++) content.push(other.content[i]);
      return new _Fragment(content, this.size + other.size);
    }
    /**
    Cut out the sub-fragment between the two given positions.
    */
    cut(from, to = this.size) {
      if (from == 0 && to == this.size) return this;
      let result = [],
        size = 0;
      if (to > from)
        for (let i = 0, pos = 0; pos < to; i++) {
          let child = this.content[i],
            end = pos + child.nodeSize;
          if (end > from) {
            if (pos < from || end > to) {
              if (child.isText)
                child = child.cut(
                  Math.max(0, from - pos),
                  Math.min(child.text.length, to - pos)
                );
              else
                child = child.cut(
                  Math.max(0, from - pos - 1),
                  Math.min(child.content.size, to - pos - 1)
                );
            }
            result.push(child);
            size += child.nodeSize;
          }
          pos = end;
        }
      return new _Fragment(result, size);
    }
    /**
    @internal
    */
    cutByIndex(from, to) {
      if (from == to) return _Fragment.empty;
      if (from == 0 && to == this.content.length) return this;
      return new _Fragment(this.content.slice(from, to));
    }
    /**
    Create a new fragment in which the node at the given index is
    replaced by the given node.
    */
    replaceChild(index, node) {
      let current = this.content[index];
      if (current == node) return this;
      let copy2 = this.content.slice();
      let size = this.size + node.nodeSize - current.nodeSize;
      copy2[index] = node;
      return new _Fragment(copy2, size);
    }
    /**
    Create a new fragment by prepending the given node to this
    fragment.
    */
    addToStart(node) {
      return new _Fragment(
        [node].concat(this.content),
        this.size + node.nodeSize
      );
    }
    /**
    Create a new fragment by appending the given node to this
    fragment.
    */
    addToEnd(node) {
      return new _Fragment(
        this.content.concat(node),
        this.size + node.nodeSize
      );
    }
    /**
    Compare this fragment to another one.
    */
    eq(other) {
      if (this.content.length != other.content.length) return false;
      for (let i = 0; i < this.content.length; i++)
        if (!this.content[i].eq(other.content[i])) return false;
      return true;
    }
    /**
    The first child of the fragment, or `null` if it is empty.
    */
    get firstChild() {
      return this.content.length ? this.content[0] : null;
    }
    /**
    The last child of the fragment, or `null` if it is empty.
    */
    get lastChild() {
      return this.content.length ? this.content[this.content.length - 1] : null;
    }
    /**
    The number of child nodes in this fragment.
    */
    get childCount() {
      return this.content.length;
    }
    /**
    Get the child node at the given index. Raise an error when the
    index is out of range.
    */
    child(index) {
      let found2 = this.content[index];
      if (!found2)
        throw new RangeError("Index " + index + " out of range for " + this);
      return found2;
    }
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(index) {
      return this.content[index] || null;
    }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(f) {
      for (let i = 0, p = 0; i < this.content.length; i++) {
        let child = this.content[i];
        f(child, p, i);
        p += child.nodeSize;
      }
    }
    /**
    Find the first position at which this fragment and another
    fragment differ, or `null` if they are the same.
    */
    findDiffStart(other, pos = 0) {
      return findDiffStart(this, other, pos);
    }
    /**
    Find the first position, searching from the end, at which this
    fragment and the given fragment differ, or `null` if they are
    the same. Since this position will not be the same in both
    nodes, an object with two separate positions is returned.
    */
    findDiffEnd(other, pos = this.size, otherPos = other.size) {
      return findDiffEnd(this, other, pos, otherPos);
    }
    /**
    Find the index and inner offset corresponding to a given relative
    position in this fragment. The result object will be reused
    (overwritten) the next time the function is called. (Not public.)
    */
    findIndex(pos, round = -1) {
      if (pos == 0) return retIndex(0, pos);
      if (pos == this.size) return retIndex(this.content.length, pos);
      if (pos > this.size || pos < 0)
        throw new RangeError(`Position ${pos} outside of fragment (${this})`);
      for (let i = 0, curPos = 0; ; i++) {
        let cur = this.child(i),
          end = curPos + cur.nodeSize;
        if (end >= pos) {
          if (end == pos || round > 0) return retIndex(i + 1, end);
          return retIndex(i, curPos);
        }
        curPos = end;
      }
    }
    /**
    Return a debugging string that describes this fragment.
    */
    toString() {
      return "<" + this.toStringInner() + ">";
    }
    /**
    @internal
    */
    toStringInner() {
      return this.content.join(", ");
    }
    /**
    Create a JSON-serializeable representation of this fragment.
    */
    toJSON() {
      return this.content.length ? this.content.map((n) => n.toJSON()) : null;
    }
    /**
    Deserialize a fragment from its JSON representation.
    */
    static fromJSON(schema, value) {
      if (!value) return _Fragment.empty;
      if (!Array.isArray(value))
        throw new RangeError("Invalid input for Fragment.fromJSON");
      return new _Fragment(value.map(schema.nodeFromJSON));
    }
    /**
    Build a fragment from an array of nodes. Ensures that adjacent
    text nodes with the same marks are joined together.
    */
    static fromArray(array) {
      if (!array.length) return _Fragment.empty;
      let joined,
        size = 0;
      for (let i = 0; i < array.length; i++) {
        let node = array[i];
        size += node.nodeSize;
        if (i && node.isText && array[i - 1].sameMarkup(node)) {
          if (!joined) joined = array.slice(0, i);
          joined[joined.length - 1] = node.withText(
            joined[joined.length - 1].text + node.text
          );
        } else if (joined) {
          joined.push(node);
        }
      }
      return new _Fragment(joined || array, size);
    }
    /**
    Create a fragment from something that can be interpreted as a
    set of nodes. For `null`, it returns the empty fragment. For a
    fragment, the fragment itself. For a node or array of nodes, a
    fragment containing those nodes.
    */
    static from(nodes) {
      if (!nodes) return _Fragment.empty;
      if (nodes instanceof _Fragment) return nodes;
      if (Array.isArray(nodes)) return this.fromArray(nodes);
      if (nodes.attrs) return new _Fragment([nodes], nodes.nodeSize);
      throw new RangeError(
        "Can not convert " +
          nodes +
          " to a Fragment" +
          (nodes.nodesBetween
            ? " (looks like multiple versions of prosemirror-model were loaded)"
            : "")
      );
    }
  };
  Fragment.empty = new Fragment([], 0);
  var found = { index: 0, offset: 0 };
  function retIndex(index, offset) {
    found.index = index;
    found.offset = offset;
    return found;
  }
  function compareDeep(a, b) {
    if (a === b) return true;
    if (!(a && typeof a == "object") || !(b && typeof b == "object"))
      return false;
    let array = Array.isArray(a);
    if (Array.isArray(b) != array) return false;
    if (array) {
      if (a.length != b.length) return false;
      for (let i = 0; i < a.length; i++)
        if (!compareDeep(a[i], b[i])) return false;
    } else {
      for (let p in a) if (!(p in b) || !compareDeep(a[p], b[p])) return false;
      for (let p in b) if (!(p in a)) return false;
    }
    return true;
  }
  var Mark = class _Mark {
    /**
    @internal
    */
    constructor(type, attrs) {
      this.type = type;
      this.attrs = attrs;
    }
    /**
    Given a set of marks, create a new set which contains this one as
    well, in the right position. If this mark is already in the set,
    the set itself is returned. If any marks that are set to be
    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
    those are replaced by this one.
    */
    addToSet(set) {
      let copy2,
        placed = false;
      for (let i = 0; i < set.length; i++) {
        let other = set[i];
        if (this.eq(other)) return set;
        if (this.type.excludes(other.type)) {
          if (!copy2) copy2 = set.slice(0, i);
        } else if (other.type.excludes(this.type)) {
          return set;
        } else {
          if (!placed && other.type.rank > this.type.rank) {
            if (!copy2) copy2 = set.slice(0, i);
            copy2.push(this);
            placed = true;
          }
          if (copy2) copy2.push(other);
        }
      }
      if (!copy2) copy2 = set.slice();
      if (!placed) copy2.push(this);
      return copy2;
    }
    /**
    Remove this mark from the given set, returning a new set. If this
    mark is not in the set, the set itself is returned.
    */
    removeFromSet(set) {
      for (let i = 0; i < set.length; i++)
        if (this.eq(set[i])) return set.slice(0, i).concat(set.slice(i + 1));
      return set;
    }
    /**
    Test whether this mark is in the given set of marks.
    */
    isInSet(set) {
      for (let i = 0; i < set.length; i++) if (this.eq(set[i])) return true;
      return false;
    }
    /**
    Test whether this mark has the same type and attributes as
    another mark.
    */
    eq(other) {
      return (
        this == other ||
        (this.type == other.type && compareDeep(this.attrs, other.attrs))
      );
    }
    /**
    Convert this mark to a JSON-serializeable representation.
    */
    toJSON() {
      let obj = { type: this.type.name };
      for (let _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      return obj;
    }
    /**
    Deserialize a mark from JSON.
    */
    static fromJSON(schema, json) {
      if (!json) throw new RangeError("Invalid input for Mark.fromJSON");
      let type = schema.marks[json.type];
      if (!type)
        throw new RangeError(
          `There is no mark type ${json.type} in this schema`
        );
      return type.create(json.attrs);
    }
    /**
    Test whether two sets of marks are identical.
    */
    static sameSet(a, b) {
      if (a == b) return true;
      if (a.length != b.length) return false;
      for (let i = 0; i < a.length; i++) if (!a[i].eq(b[i])) return false;
      return true;
    }
    /**
    Create a properly sorted mark set from null, a single mark, or an
    unsorted array of marks.
    */
    static setFrom(marks) {
      if (!marks || (Array.isArray(marks) && marks.length == 0))
        return _Mark.none;
      if (marks instanceof _Mark) return [marks];
      let copy2 = marks.slice();
      copy2.sort((a, b) => a.type.rank - b.type.rank);
      return copy2;
    }
  };
  Mark.none = [];
  var ReplaceError = class extends Error {};
  var Slice = class _Slice {
    /**
    Create a slice. When specifying a non-zero open depth, you must
    make sure that there are nodes of at least that depth at the
    appropriate side of the fragment—i.e. if the fragment is an
    empty paragraph node, `openStart` and `openEnd` can't be greater
    than 1.
    
    It is not necessary for the content of open nodes to conform to
    the schema's content constraints, though it should be a valid
    start/end/middle for such a node, depending on which sides are
    open.
    */
    constructor(content, openStart, openEnd) {
      this.content = content;
      this.openStart = openStart;
      this.openEnd = openEnd;
    }
    /**
    The size this slice would add when inserted into a document.
    */
    get size() {
      return this.content.size - this.openStart - this.openEnd;
    }
    /**
    @internal
    */
    insertAt(pos, fragment) {
      let content = insertInto(this.content, pos + this.openStart, fragment);
      return content && new _Slice(content, this.openStart, this.openEnd);
    }
    /**
    @internal
    */
    removeBetween(from, to) {
      return new _Slice(
        removeRange(this.content, from + this.openStart, to + this.openStart),
        this.openStart,
        this.openEnd
      );
    }
    /**
    Tests whether this slice is equal to another slice.
    */
    eq(other) {
      return (
        this.content.eq(other.content) &&
        this.openStart == other.openStart &&
        this.openEnd == other.openEnd
      );
    }
    /**
    @internal
    */
    toString() {
      return this.content + "(" + this.openStart + "," + this.openEnd + ")";
    }
    /**
    Convert a slice to a JSON-serializable representation.
    */
    toJSON() {
      if (!this.content.size) return null;
      let json = { content: this.content.toJSON() };
      if (this.openStart > 0) json.openStart = this.openStart;
      if (this.openEnd > 0) json.openEnd = this.openEnd;
      return json;
    }
    /**
    Deserialize a slice from its JSON representation.
    */
    static fromJSON(schema, json) {
      if (!json) return _Slice.empty;
      let openStart = json.openStart || 0,
        openEnd = json.openEnd || 0;
      if (typeof openStart != "number" || typeof openEnd != "number")
        throw new RangeError("Invalid input for Slice.fromJSON");
      return new _Slice(
        Fragment.fromJSON(schema, json.content),
        openStart,
        openEnd
      );
    }
    /**
    Create a slice from a fragment by taking the maximum possible
    open value on both side of the fragment.
    */
    static maxOpen(fragment, openIsolating = true) {
      let openStart = 0,
        openEnd = 0;
      for (
        let n = fragment.firstChild;
        n && !n.isLeaf && (openIsolating || !n.type.spec.isolating);
        n = n.firstChild
      )
        openStart++;
      for (
        let n = fragment.lastChild;
        n && !n.isLeaf && (openIsolating || !n.type.spec.isolating);
        n = n.lastChild
      )
        openEnd++;
      return new _Slice(fragment, openStart, openEnd);
    }
  };
  Slice.empty = new Slice(Fragment.empty, 0, 0);
  function removeRange(content, from, to) {
    let { index, offset } = content.findIndex(from),
      child = content.maybeChild(index);
    let { index: indexTo, offset: offsetTo } = content.findIndex(to);
    if (offset == from || child.isText) {
      if (offsetTo != to && !content.child(indexTo).isText)
        throw new RangeError("Removing non-flat range");
      return content.cut(0, from).append(content.cut(to));
    }
    if (index != indexTo) throw new RangeError("Removing non-flat range");
    return content.replaceChild(
      index,
      child.copy(removeRange(child.content, from - offset - 1, to - offset - 1))
    );
  }
  function insertInto(content, dist, insert, parent) {
    let { index, offset } = content.findIndex(dist),
      child = content.maybeChild(index);
    if (offset == dist || child.isText) {
      if (parent && !parent.canReplace(index, index, insert)) return null;
      return content.cut(0, dist).append(insert).append(content.cut(dist));
    }
    let inner = insertInto(child.content, dist - offset - 1, insert);
    return inner && content.replaceChild(index, child.copy(inner));
  }
  function replace($from, $to, slice) {
    if (slice.openStart > $from.depth)
      throw new ReplaceError("Inserted content deeper than insertion position");
    if ($from.depth - slice.openStart != $to.depth - slice.openEnd)
      throw new ReplaceError("Inconsistent open depths");
    return replaceOuter($from, $to, slice, 0);
  }
  function replaceOuter($from, $to, slice, depth) {
    let index = $from.index(depth),
      node = $from.node(depth);
    if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
      let inner = replaceOuter($from, $to, slice, depth + 1);
      return node.copy(node.content.replaceChild(index, inner));
    } else if (!slice.content.size) {
      return close(node, replaceTwoWay($from, $to, depth));
    } else if (
      !slice.openStart &&
      !slice.openEnd &&
      $from.depth == depth &&
      $to.depth == depth
    ) {
      let parent = $from.parent,
        content = parent.content;
      return close(
        parent,
        content
          .cut(0, $from.parentOffset)
          .append(slice.content)
          .append(content.cut($to.parentOffset))
      );
    } else {
      let { start, end } = prepareSliceForReplace(slice, $from);
      return close(node, replaceThreeWay($from, start, end, $to, depth));
    }
  }
  function checkJoin(main, sub) {
    if (!sub.type.compatibleContent(main.type))
      throw new ReplaceError(
        "Cannot join " + sub.type.name + " onto " + main.type.name
      );
  }
  function joinable($before, $after, depth) {
    let node = $before.node(depth);
    checkJoin(node, $after.node(depth));
    return node;
  }
  function addNode(child, target) {
    let last = target.length - 1;
    if (last >= 0 && child.isText && child.sameMarkup(target[last]))
      target[last] = child.withText(target[last].text + child.text);
    else target.push(child);
  }
  function addRange($start, $end, depth, target) {
    let node = ($end || $start).node(depth);
    let startIndex = 0,
      endIndex = $end ? $end.index(depth) : node.childCount;
    if ($start) {
      startIndex = $start.index(depth);
      if ($start.depth > depth) {
        startIndex++;
      } else if ($start.textOffset) {
        addNode($start.nodeAfter, target);
        startIndex++;
      }
    }
    for (let i = startIndex; i < endIndex; i++) addNode(node.child(i), target);
    if ($end && $end.depth == depth && $end.textOffset)
      addNode($end.nodeBefore, target);
  }
  function close(node, content) {
    node.type.checkContent(content);
    return node.copy(content);
  }
  function replaceThreeWay($from, $start, $end, $to, depth) {
    let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
    let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
    let content = [];
    addRange(null, $from, depth, content);
    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
      checkJoin(openStart, openEnd);
      addNode(
        close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)),
        content
      );
    } else {
      if (openStart)
        addNode(
          close(openStart, replaceTwoWay($from, $start, depth + 1)),
          content
        );
      addRange($start, $end, depth, content);
      if (openEnd)
        addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
    }
    addRange($to, null, depth, content);
    return new Fragment(content);
  }
  function replaceTwoWay($from, $to, depth) {
    let content = [];
    addRange(null, $from, depth, content);
    if ($from.depth > depth) {
      let type = joinable($from, $to, depth + 1);
      addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
    }
    addRange($to, null, depth, content);
    return new Fragment(content);
  }
  function prepareSliceForReplace(slice, $along) {
    let extra = $along.depth - slice.openStart,
      parent = $along.node(extra);
    let node = parent.copy(slice.content);
    for (let i = extra - 1; i >= 0; i--)
      node = $along.node(i).copy(Fragment.from(node));
    return {
      start: node.resolveNoCache(slice.openStart + extra),
      end: node.resolveNoCache(node.content.size - slice.openEnd - extra),
    };
  }
  var ResolvedPos = class _ResolvedPos {
    /**
    @internal
    */
    constructor(pos, path, parentOffset) {
      this.pos = pos;
      this.path = path;
      this.parentOffset = parentOffset;
      this.depth = path.length / 3 - 1;
    }
    /**
    @internal
    */
    resolveDepth(val) {
      if (val == null) return this.depth;
      if (val < 0) return this.depth + val;
      return val;
    }
    /**
    The parent node that the position points into. Note that even if
    a position points into a text node, that node is not considered
    the parent—text nodes are ‘flat’ in this model, and have no content.
    */
    get parent() {
      return this.node(this.depth);
    }
    /**
    The root node in which the position was resolved.
    */
    get doc() {
      return this.node(0);
    }
    /**
    The ancestor node at the given level. `p.node(p.depth)` is the
    same as `p.parent`.
    */
    node(depth) {
      return this.path[this.resolveDepth(depth) * 3];
    }
    /**
    The index into the ancestor at the given level. If this points
    at the 3rd node in the 2nd paragraph on the top level, for
    example, `p.index(0)` is 1 and `p.index(1)` is 2.
    */
    index(depth) {
      return this.path[this.resolveDepth(depth) * 3 + 1];
    }
    /**
    The index pointing after this position into the ancestor at the
    given level.
    */
    indexAfter(depth) {
      depth = this.resolveDepth(depth);
      return (
        this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)
      );
    }
    /**
    The (absolute) position at the start of the node at the given
    level.
    */
    start(depth) {
      depth = this.resolveDepth(depth);
      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    }
    /**
    The (absolute) position at the end of the node at the given
    level.
    */
    end(depth) {
      depth = this.resolveDepth(depth);
      return this.start(depth) + this.node(depth).content.size;
    }
    /**
    The (absolute) position directly before the wrapping node at the
    given level, or, when `depth` is `this.depth + 1`, the original
    position.
    */
    before(depth) {
      depth = this.resolveDepth(depth);
      if (!depth)
        throw new RangeError("There is no position before the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
    }
    /**
    The (absolute) position directly after the wrapping node at the
    given level, or the original position when `depth` is `this.depth + 1`.
    */
    after(depth) {
      depth = this.resolveDepth(depth);
      if (!depth)
        throw new RangeError("There is no position after the top-level node");
      return depth == this.depth + 1
        ? this.pos
        : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
    }
    /**
    When this position points into a text node, this returns the
    distance between the position and the start of the text node.
    Will be zero for positions that point between nodes.
    */
    get textOffset() {
      return this.pos - this.path[this.path.length - 1];
    }
    /**
    Get the node directly after the position, if any. If the position
    points into a text node, only the part of that node after the
    position is returned.
    */
    get nodeAfter() {
      let parent = this.parent,
        index = this.index(this.depth);
      if (index == parent.childCount) return null;
      let dOff = this.pos - this.path[this.path.length - 1],
        child = parent.child(index);
      return dOff ? parent.child(index).cut(dOff) : child;
    }
    /**
    Get the node directly before the position, if any. If the
    position points into a text node, only the part of that node
    before the position is returned.
    */
    get nodeBefore() {
      let index = this.index(this.depth);
      let dOff = this.pos - this.path[this.path.length - 1];
      if (dOff) return this.parent.child(index).cut(0, dOff);
      return index == 0 ? null : this.parent.child(index - 1);
    }
    /**
    Get the position at the given index in the parent node at the
    given depth (which defaults to `this.depth`).
    */
    posAtIndex(index, depth) {
      depth = this.resolveDepth(depth);
      let node = this.path[depth * 3],
        pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
      for (let i = 0; i < index; i++) pos += node.child(i).nodeSize;
      return pos;
    }
    /**
    Get the marks at this position, factoring in the surrounding
    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
    position is at the start of a non-empty node, the marks of the
    node after it (if any) are returned.
    */
    marks() {
      let parent = this.parent,
        index = this.index();
      if (parent.content.size == 0) return Mark.none;
      if (this.textOffset) return parent.child(index).marks;
      let main = parent.maybeChild(index - 1),
        other = parent.maybeChild(index);
      if (!main) {
        let tmp = main;
        main = other;
        other = tmp;
      }
      let marks = main.marks;
      for (var i = 0; i < marks.length; i++)
        if (
          marks[i].type.spec.inclusive === false &&
          (!other || !marks[i].isInSet(other.marks))
        )
          marks = marks[i--].removeFromSet(marks);
      return marks;
    }
    /**
    Get the marks after the current position, if any, except those
    that are non-inclusive and not present at position `$end`. This
    is mostly useful for getting the set of marks to preserve after a
    deletion. Will return `null` if this position is at the end of
    its parent node or its parent node isn't a textblock (in which
    case no marks should be preserved).
    */
    marksAcross($end) {
      let after = this.parent.maybeChild(this.index());
      if (!after || !after.isInline) return null;
      let marks = after.marks,
        next = $end.parent.maybeChild($end.index());
      for (var i = 0; i < marks.length; i++)
        if (
          marks[i].type.spec.inclusive === false &&
          (!next || !marks[i].isInSet(next.marks))
        )
          marks = marks[i--].removeFromSet(marks);
      return marks;
    }
    /**
    The depth up to which this position and the given (non-resolved)
    position share the same parent nodes.
    */
    sharedDepth(pos) {
      for (let depth = this.depth; depth > 0; depth--)
        if (this.start(depth) <= pos && this.end(depth) >= pos) return depth;
      return 0;
    }
    /**
    Returns a range based on the place where this position and the
    given position diverge around block content. If both point into
    the same textblock, for example, a range around that textblock
    will be returned. If they point into different blocks, the range
    around those blocks in their shared ancestor is returned. You can
    pass in an optional predicate that will be called with a parent
    node to see if a range into that parent is acceptable.
    */
    blockRange(other = this, pred) {
      if (other.pos < this.pos) return other.blockRange(this);
      for (
        let d =
          this.depth -
          (this.parent.inlineContent || this.pos == other.pos ? 1 : 0);
        d >= 0;
        d--
      )
        if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
          return new NodeRange(this, other, d);
      return null;
    }
    /**
    Query whether the given position shares the same parent node.
    */
    sameParent(other) {
      return this.pos - this.parentOffset == other.pos - other.parentOffset;
    }
    /**
    Return the greater of this and the given position.
    */
    max(other) {
      return other.pos > this.pos ? other : this;
    }
    /**
    Return the smaller of this and the given position.
    */
    min(other) {
      return other.pos < this.pos ? other : this;
    }
    /**
    @internal
    */
    toString() {
      let str = "";
      for (let i = 1; i <= this.depth; i++)
        str +=
          (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
      return str + ":" + this.parentOffset;
    }
    /**
    @internal
    */
    static resolve(doc, pos) {
      if (!(pos >= 0 && pos <= doc.content.size))
        throw new RangeError("Position " + pos + " out of range");
      let path = [];
      let start = 0,
        parentOffset = pos;
      for (let node = doc; ; ) {
        let { index, offset } = node.content.findIndex(parentOffset);
        let rem = parentOffset - offset;
        path.push(node, index, start + offset);
        if (!rem) break;
        node = node.child(index);
        if (node.isText) break;
        parentOffset = rem - 1;
        start += offset + 1;
      }
      return new _ResolvedPos(pos, path, parentOffset);
    }
    /**
    @internal
    */
    static resolveCached(doc, pos) {
      for (let i = 0; i < resolveCache.length; i++) {
        let cached = resolveCache[i];
        if (cached.pos == pos && cached.doc == doc) return cached;
      }
      let result = (resolveCache[resolveCachePos] = _ResolvedPos.resolve(
        doc,
        pos
      ));
      resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
      return result;
    }
  };
  var resolveCache = [];
  var resolveCachePos = 0;
  var resolveCacheSize = 12;
  var NodeRange = class {
    /**
    Construct a node range. `$from` and `$to` should point into the
    same node until at least the given `depth`, since a node range
    denotes an adjacent set of nodes in a single parent node.
    */
    constructor($from, $to, depth) {
      this.$from = $from;
      this.$to = $to;
      this.depth = depth;
    }
    /**
    The position at the start of the range.
    */
    get start() {
      return this.$from.before(this.depth + 1);
    }
    /**
    The position at the end of the range.
    */
    get end() {
      return this.$to.after(this.depth + 1);
    }
    /**
    The parent node that the range points into.
    */
    get parent() {
      return this.$from.node(this.depth);
    }
    /**
    The start index of the range in the parent node.
    */
    get startIndex() {
      return this.$from.index(this.depth);
    }
    /**
    The end index of the range in the parent node.
    */
    get endIndex() {
      return this.$to.indexAfter(this.depth);
    }
  };
  var emptyAttrs = /* @__PURE__ */ Object.create(null);
  var Node = class _Node {
    /**
    @internal
    */
    constructor(type, attrs, content, marks = Mark.none) {
      this.type = type;
      this.attrs = attrs;
      this.marks = marks;
      this.content = content || Fragment.empty;
    }
    /**
    The size of this node, as defined by the integer-based [indexing
    scheme](/docs/guide/#doc.indexing). For text nodes, this is the
    amount of characters. For other leaf nodes, it is one. For
    non-leaf nodes, it is the size of the content plus two (the
    start and end token).
    */
    get nodeSize() {
      return this.isLeaf ? 1 : 2 + this.content.size;
    }
    /**
    The number of children that the node has.
    */
    get childCount() {
      return this.content.childCount;
    }
    /**
    Get the child node at the given index. Raises an error when the
    index is out of range.
    */
    child(index) {
      return this.content.child(index);
    }
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(index) {
      return this.content.maybeChild(index);
    }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(f) {
      this.content.forEach(f);
    }
    /**
    Invoke a callback for all descendant nodes recursively between
    the given two positions that are relative to start of this
    node's content. The callback is invoked with the node, its
    position relative to the original node (method receiver),
    its parent node, and its child index. When the callback returns
    false for a given node, that node's children will not be
    recursed over. The last parameter can be used to specify a
    starting position to count from.
    */
    nodesBetween(from, to, f, startPos = 0) {
      this.content.nodesBetween(from, to, f, startPos, this);
    }
    /**
    Call the given callback for every descendant node. Doesn't
    descend into a node when the callback returns `false`.
    */
    descendants(f) {
      this.nodesBetween(0, this.content.size, f);
    }
    /**
    Concatenates all the text nodes found in this fragment and its
    children.
    */
    get textContent() {
      return this.isLeaf && this.type.spec.leafText
        ? this.type.spec.leafText(this)
        : this.textBetween(0, this.content.size, "");
    }
    /**
    Get all text between positions `from` and `to`. When
    `blockSeparator` is given, it will be inserted to separate text
    from different block nodes. If `leafText` is given, it'll be
    inserted for every non-text leaf node encountered, otherwise
    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
    */
    textBetween(from, to, blockSeparator, leafText) {
      return this.content.textBetween(from, to, blockSeparator, leafText);
    }
    /**
    Returns this node's first child, or `null` if there are no
    children.
    */
    get firstChild() {
      return this.content.firstChild;
    }
    /**
    Returns this node's last child, or `null` if there are no
    children.
    */
    get lastChild() {
      return this.content.lastChild;
    }
    /**
    Test whether two nodes represent the same piece of document.
    */
    eq(other) {
      return (
        this == other ||
        (this.sameMarkup(other) && this.content.eq(other.content))
      );
    }
    /**
    Compare the markup (type, attributes, and marks) of this node to
    those of another. Returns `true` if both have the same markup.
    */
    sameMarkup(other) {
      return this.hasMarkup(other.type, other.attrs, other.marks);
    }
    /**
    Check whether this node's markup correspond to the given type,
    attributes, and marks.
    */
    hasMarkup(type, attrs, marks) {
      return (
        this.type == type &&
        compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&
        Mark.sameSet(this.marks, marks || Mark.none)
      );
    }
    /**
    Create a new node with the same markup as this node, containing
    the given content (or empty, if no content is given).
    */
    copy(content = null) {
      if (content == this.content) return this;
      return new _Node(this.type, this.attrs, content, this.marks);
    }
    /**
    Create a copy of this node, with the given set of marks instead
    of the node's own marks.
    */
    mark(marks) {
      return marks == this.marks
        ? this
        : new _Node(this.type, this.attrs, this.content, marks);
    }
    /**
    Create a copy of this node with only the content between the
    given positions. If `to` is not given, it defaults to the end of
    the node.
    */
    cut(from, to = this.content.size) {
      if (from == 0 && to == this.content.size) return this;
      return this.copy(this.content.cut(from, to));
    }
    /**
    Cut out the part of the document between the given positions, and
    return it as a `Slice` object.
    */
    slice(from, to = this.content.size, includeParents = false) {
      if (from == to) return Slice.empty;
      let $from = this.resolve(from),
        $to = this.resolve(to);
      let depth = includeParents ? 0 : $from.sharedDepth(to);
      let start = $from.start(depth),
        node = $from.node(depth);
      let content = node.content.cut($from.pos - start, $to.pos - start);
      return new Slice(content, $from.depth - depth, $to.depth - depth);
    }
    /**
    Replace the part of the document between the given positions with
    the given slice. The slice must 'fit', meaning its open sides
    must be able to connect to the surrounding content, and its
    content nodes must be valid children for the node they are placed
    into. If any of this is violated, an error of type
    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
    */
    replace(from, to, slice) {
      return replace(this.resolve(from), this.resolve(to), slice);
    }
    /**
    Find the node directly after the given position.
    */
    nodeAt(pos) {
      for (let node = this; ; ) {
        let { index, offset } = node.content.findIndex(pos);
        node = node.maybeChild(index);
        if (!node) return null;
        if (offset == pos || node.isText) return node;
        pos -= offset + 1;
      }
    }
    /**
    Find the (direct) child node after the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childAfter(pos) {
      let { index, offset } = this.content.findIndex(pos);
      return { node: this.content.maybeChild(index), index, offset };
    }
    /**
    Find the (direct) child node before the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childBefore(pos) {
      if (pos == 0) return { node: null, index: 0, offset: 0 };
      let { index, offset } = this.content.findIndex(pos);
      if (offset < pos)
        return { node: this.content.child(index), index, offset };
      let node = this.content.child(index - 1);
      return { node, index: index - 1, offset: offset - node.nodeSize };
    }
    /**
    Resolve the given position in the document, returning an
    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
    */
    resolve(pos) {
      return ResolvedPos.resolveCached(this, pos);
    }
    /**
    @internal
    */
    resolveNoCache(pos) {
      return ResolvedPos.resolve(this, pos);
    }
    /**
    Test whether a given mark or mark type occurs in this document
    between the two given positions.
    */
    rangeHasMark(from, to, type) {
      let found2 = false;
      if (to > from)
        this.nodesBetween(from, to, (node) => {
          if (type.isInSet(node.marks)) found2 = true;
          return !found2;
        });
      return found2;
    }
    /**
    True when this is a block (non-inline node)
    */
    get isBlock() {
      return this.type.isBlock;
    }
    /**
    True when this is a textblock node, a block node with inline
    content.
    */
    get isTextblock() {
      return this.type.isTextblock;
    }
    /**
    True when this node allows inline content.
    */
    get inlineContent() {
      return this.type.inlineContent;
    }
    /**
    True when this is an inline node (a text node or a node that can
    appear among text).
    */
    get isInline() {
      return this.type.isInline;
    }
    /**
    True when this is a text node.
    */
    get isText() {
      return this.type.isText;
    }
    /**
    True when this is a leaf node.
    */
    get isLeaf() {
      return this.type.isLeaf;
    }
    /**
    True when this is an atom, i.e. when it does not have directly
    editable content. This is usually the same as `isLeaf`, but can
    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
    on a node's spec (typically used when the node is displayed as
    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
    */
    get isAtom() {
      return this.type.isAtom;
    }
    /**
    Return a string representation of this node for debugging
    purposes.
    */
    toString() {
      if (this.type.spec.toDebugString)
        return this.type.spec.toDebugString(this);
      let name = this.type.name;
      if (this.content.size) name += "(" + this.content.toStringInner() + ")";
      return wrapMarks(this.marks, name);
    }
    /**
    Get the content match in this node at the given index.
    */
    contentMatchAt(index) {
      let match = this.type.contentMatch.matchFragment(this.content, 0, index);
      if (!match)
        throw new Error("Called contentMatchAt on a node with invalid content");
      return match;
    }
    /**
    Test whether replacing the range between `from` and `to` (by
    child index) with the given replacement fragment (which defaults
    to the empty fragment) would leave the node's content valid. You
    can optionally pass `start` and `end` indices into the
    replacement fragment.
    */
    canReplace(
      from,
      to,
      replacement = Fragment.empty,
      start = 0,
      end = replacement.childCount
    ) {
      let one = this.contentMatchAt(from).matchFragment(
        replacement,
        start,
        end
      );
      let two = one && one.matchFragment(this.content, to);
      if (!two || !two.validEnd) return false;
      for (let i = start; i < end; i++)
        if (!this.type.allowsMarks(replacement.child(i).marks)) return false;
      return true;
    }
    /**
    Test whether replacing the range `from` to `to` (by index) with
    a node of the given type would leave the node's content valid.
    */
    canReplaceWith(from, to, type, marks) {
      if (marks && !this.type.allowsMarks(marks)) return false;
      let start = this.contentMatchAt(from).matchType(type);
      let end = start && start.matchFragment(this.content, to);
      return end ? end.validEnd : false;
    }
    /**
    Test whether the given node's content could be appended to this
    node. If that node is empty, this will only return true if there
    is at least one node type that can appear in both nodes (to avoid
    merging completely incompatible nodes).
    */
    canAppend(other) {
      if (other.content.size)
        return this.canReplace(this.childCount, this.childCount, other.content);
      else return this.type.compatibleContent(other.type);
    }
    /**
    Check whether this node and its descendants conform to the
    schema, and raise error when they do not.
    */
    check() {
      this.type.checkContent(this.content);
      let copy2 = Mark.none;
      for (let i = 0; i < this.marks.length; i++)
        copy2 = this.marks[i].addToSet(copy2);
      if (!Mark.sameSet(copy2, this.marks))
        throw new RangeError(
          `Invalid collection of marks for node ${
            this.type.name
          }: ${this.marks.map((m) => m.type.name)}`
        );
      this.content.forEach((node) => node.check());
    }
    /**
    Return a JSON-serializeable representation of this node.
    */
    toJSON() {
      let obj = { type: this.type.name };
      for (let _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      if (this.content.size) obj.content = this.content.toJSON();
      if (this.marks.length) obj.marks = this.marks.map((n) => n.toJSON());
      return obj;
    }
    /**
    Deserialize a node from its JSON representation.
    */
    static fromJSON(schema, json) {
      if (!json) throw new RangeError("Invalid input for Node.fromJSON");
      let marks = null;
      if (json.marks) {
        if (!Array.isArray(json.marks))
          throw new RangeError("Invalid mark data for Node.fromJSON");
        marks = json.marks.map(schema.markFromJSON);
      }
      if (json.type == "text") {
        if (typeof json.text != "string")
          throw new RangeError("Invalid text node in JSON");
        return schema.text(json.text, marks);
      }
      let content = Fragment.fromJSON(schema, json.content);
      return schema.nodeType(json.type).create(json.attrs, content, marks);
    }
  };
  Node.prototype.text = void 0;
  function wrapMarks(marks, str) {
    for (let i = marks.length - 1; i >= 0; i--)
      str = marks[i].type.name + "(" + str + ")";
    return str;
  }
  var ContentMatch = class _ContentMatch {
    /**
    @internal
    */
    constructor(validEnd) {
      this.validEnd = validEnd;
      this.next = [];
      this.wrapCache = [];
    }
    /**
    @internal
    */
    static parse(string, nodeTypes) {
      let stream = new TokenStream(string, nodeTypes);
      if (stream.next == null) return _ContentMatch.empty;
      let expr = parseExpr(stream);
      if (stream.next) stream.err("Unexpected trailing text");
      let match = dfa(nfa(expr));
      checkForDeadEnds(match, stream);
      return match;
    }
    /**
    Match a node type, returning a match after that node if
    successful.
    */
    matchType(type) {
      for (let i = 0; i < this.next.length; i++)
        if (this.next[i].type == type) return this.next[i].next;
      return null;
    }
    /**
    Try to match a fragment. Returns the resulting match when
    successful.
    */
    matchFragment(frag, start = 0, end = frag.childCount) {
      let cur = this;
      for (let i = start; cur && i < end; i++)
        cur = cur.matchType(frag.child(i).type);
      return cur;
    }
    /**
    @internal
    */
    get inlineContent() {
      return this.next.length != 0 && this.next[0].type.isInline;
    }
    /**
    Get the first matching node type at this match position that can
    be generated.
    */
    get defaultType() {
      for (let i = 0; i < this.next.length; i++) {
        let { type } = this.next[i];
        if (!(type.isText || type.hasRequiredAttrs())) return type;
      }
      return null;
    }
    /**
    @internal
    */
    compatible(other) {
      for (let i = 0; i < this.next.length; i++)
        for (let j = 0; j < other.next.length; j++)
          if (this.next[i].type == other.next[j].type) return true;
      return false;
    }
    /**
    Try to match the given fragment, and if that fails, see if it can
    be made to match by inserting nodes in front of it. When
    successful, return a fragment of inserted nodes (which may be
    empty if nothing had to be inserted). When `toEnd` is true, only
    return a fragment if the resulting match goes to the end of the
    content expression.
    */
    fillBefore(after, toEnd = false, startIndex = 0) {
      let seen = [this];
      function search(match, types) {
        let finished = match.matchFragment(after, startIndex);
        if (finished && (!toEnd || finished.validEnd))
          return Fragment.from(types.map((tp) => tp.createAndFill()));
        for (let i = 0; i < match.next.length; i++) {
          let { type, next } = match.next[i];
          if (
            !(type.isText || type.hasRequiredAttrs()) &&
            seen.indexOf(next) == -1
          ) {
            seen.push(next);
            let found2 = search(next, types.concat(type));
            if (found2) return found2;
          }
        }
        return null;
      }
      return search(this, []);
    }
    /**
    Find a set of wrapping node types that would allow a node of the
    given type to appear at this position. The result may be empty
    (when it fits directly) and will be null when no such wrapping
    exists.
    */
    findWrapping(target) {
      for (let i = 0; i < this.wrapCache.length; i += 2)
        if (this.wrapCache[i] == target) return this.wrapCache[i + 1];
      let computed = this.computeWrapping(target);
      this.wrapCache.push(target, computed);
      return computed;
    }
    /**
    @internal
    */
    computeWrapping(target) {
      let seen = /* @__PURE__ */ Object.create(null),
        active = [{ match: this, type: null, via: null }];
      while (active.length) {
        let current = active.shift(),
          match = current.match;
        if (match.matchType(target)) {
          let result = [];
          for (let obj = current; obj.type; obj = obj.via)
            result.push(obj.type);
          return result.reverse();
        }
        for (let i = 0; i < match.next.length; i++) {
          let { type, next } = match.next[i];
          if (
            !type.isLeaf &&
            !type.hasRequiredAttrs() &&
            !(type.name in seen) &&
            (!current.type || next.validEnd)
          ) {
            active.push({ match: type.contentMatch, type, via: current });
            seen[type.name] = true;
          }
        }
      }
      return null;
    }
    /**
    The number of outgoing edges this node has in the finite
    automaton that describes the content expression.
    */
    get edgeCount() {
      return this.next.length;
    }
    /**
    Get the _n_​th outgoing edge from this node in the finite
    automaton that describes the content expression.
    */
    edge(n) {
      if (n >= this.next.length)
        throw new RangeError(`There's no ${n}th edge in this content match`);
      return this.next[n];
    }
    /**
    @internal
    */
    toString() {
      let seen = [];
      function scan(m) {
        seen.push(m);
        for (let i = 0; i < m.next.length; i++)
          if (seen.indexOf(m.next[i].next) == -1) scan(m.next[i].next);
      }
      scan(this);
      return seen
        .map((m, i) => {
          let out = i + (m.validEnd ? "*" : " ") + " ";
          for (let i2 = 0; i2 < m.next.length; i2++)
            out +=
              (i2 ? ", " : "") +
              m.next[i2].type.name +
              "->" +
              seen.indexOf(m.next[i2].next);
          return out;
        })
        .join("\n");
    }
  };
  ContentMatch.empty = new ContentMatch(true);
  var TokenStream = class {
    constructor(string, nodeTypes) {
      this.string = string;
      this.nodeTypes = nodeTypes;
      this.inline = null;
      this.pos = 0;
      this.tokens = string.split(/\s*(?=\b|\W|$)/);
      if (this.tokens[this.tokens.length - 1] == "") this.tokens.pop();
      if (this.tokens[0] == "") this.tokens.shift();
    }
    get next() {
      return this.tokens[this.pos];
    }
    eat(tok) {
      return this.next == tok && (this.pos++ || true);
    }
    err(str) {
      throw new SyntaxError(
        str + " (in content expression '" + this.string + "')"
      );
    }
  };
  function parseExpr(stream) {
    let exprs = [];
    do {
      exprs.push(parseExprSeq(stream));
    } while (stream.eat("|"));
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  }
  function parseExprSeq(stream) {
    let exprs = [];
    do {
      exprs.push(parseExprSubscript(stream));
    } while (stream.next && stream.next != ")" && stream.next != "|");
    return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
  }
  function parseExprSubscript(stream) {
    let expr = parseExprAtom(stream);
    for (;;) {
      if (stream.eat("+")) expr = { type: "plus", expr };
      else if (stream.eat("*")) expr = { type: "star", expr };
      else if (stream.eat("?")) expr = { type: "opt", expr };
      else if (stream.eat("{")) expr = parseExprRange(stream, expr);
      else break;
    }
    return expr;
  }
  function parseNum(stream) {
    if (/\D/.test(stream.next))
      stream.err("Expected number, got '" + stream.next + "'");
    let result = Number(stream.next);
    stream.pos++;
    return result;
  }
  function parseExprRange(stream, expr) {
    let min = parseNum(stream),
      max = min;
    if (stream.eat(",")) {
      if (stream.next != "}") max = parseNum(stream);
      else max = -1;
    }
    if (!stream.eat("}")) stream.err("Unclosed braced range");
    return { type: "range", min, max, expr };
  }
  function resolveName(stream, name) {
    let types = stream.nodeTypes,
      type = types[name];
    if (type) return [type];
    let result = [];
    for (let typeName in types) {
      let type2 = types[typeName];
      if (type2.groups.indexOf(name) > -1) result.push(type2);
    }
    if (result.length == 0)
      stream.err("No node type or group '" + name + "' found");
    return result;
  }
  function parseExprAtom(stream) {
    if (stream.eat("(")) {
      let expr = parseExpr(stream);
      if (!stream.eat(")")) stream.err("Missing closing paren");
      return expr;
    } else if (!/\W/.test(stream.next)) {
      let exprs = resolveName(stream, stream.next).map((type) => {
        if (stream.inline == null) stream.inline = type.isInline;
        else if (stream.inline != type.isInline)
          stream.err("Mixing inline and block content");
        return { type: "name", value: type };
      });
      stream.pos++;
      return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
    } else {
      stream.err("Unexpected token '" + stream.next + "'");
    }
  }
  function nfa(expr) {
    let nfa2 = [[]];
    connect(compile(expr, 0), node());
    return nfa2;
    function node() {
      return nfa2.push([]) - 1;
    }
    function edge(from, to, term) {
      let edge2 = { term, to };
      nfa2[from].push(edge2);
      return edge2;
    }
    function connect(edges, to) {
      edges.forEach((edge2) => (edge2.to = to));
    }
    function compile(expr2, from) {
      if (expr2.type == "choice") {
        return expr2.exprs.reduce(
          (out, expr3) => out.concat(compile(expr3, from)),
          []
        );
      } else if (expr2.type == "seq") {
        for (let i = 0; ; i++) {
          let next = compile(expr2.exprs[i], from);
          if (i == expr2.exprs.length - 1) return next;
          connect(next, (from = node()));
        }
      } else if (expr2.type == "star") {
        let loop = node();
        edge(from, loop);
        connect(compile(expr2.expr, loop), loop);
        return [edge(loop)];
      } else if (expr2.type == "plus") {
        let loop = node();
        connect(compile(expr2.expr, from), loop);
        connect(compile(expr2.expr, loop), loop);
        return [edge(loop)];
      } else if (expr2.type == "opt") {
        return [edge(from)].concat(compile(expr2.expr, from));
      } else if (expr2.type == "range") {
        let cur = from;
        for (let i = 0; i < expr2.min; i++) {
          let next = node();
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
        if (expr2.max == -1) {
          connect(compile(expr2.expr, cur), cur);
        } else {
          for (let i = expr2.min; i < expr2.max; i++) {
            let next = node();
            edge(cur, next);
            connect(compile(expr2.expr, cur), next);
            cur = next;
          }
        }
        return [edge(cur)];
      } else if (expr2.type == "name") {
        return [edge(from, void 0, expr2.value)];
      } else {
        throw new Error("Unknown expr type");
      }
    }
  }
  function cmp(a, b) {
    return b - a;
  }
  function nullFrom(nfa2, node) {
    let result = [];
    scan(node);
    return result.sort(cmp);
    function scan(node2) {
      let edges = nfa2[node2];
      if (edges.length == 1 && !edges[0].term) return scan(edges[0].to);
      result.push(node2);
      for (let i = 0; i < edges.length; i++) {
        let { term, to } = edges[i];
        if (!term && result.indexOf(to) == -1) scan(to);
      }
    }
  }
  function dfa(nfa2) {
    let labeled = /* @__PURE__ */ Object.create(null);
    return explore(nullFrom(nfa2, 0));
    function explore(states) {
      let out = [];
      states.forEach((node) => {
        nfa2[node].forEach(({ term, to }) => {
          if (!term) return;
          let set;
          for (let i = 0; i < out.length; i++)
            if (out[i][0] == term) set = out[i][1];
          nullFrom(nfa2, to).forEach((node2) => {
            if (!set) out.push([term, (set = [])]);
            if (set.indexOf(node2) == -1) set.push(node2);
          });
        });
      });
      let state = (labeled[states.join(",")] = new ContentMatch(
        states.indexOf(nfa2.length - 1) > -1
      ));
      for (let i = 0; i < out.length; i++) {
        let states2 = out[i][1].sort(cmp);
        state.next.push({
          type: out[i][0],
          next: labeled[states2.join(",")] || explore(states2),
        });
      }
      return state;
    }
  }
  function checkForDeadEnds(match, stream) {
    for (let i = 0, work = [match]; i < work.length; i++) {
      let state = work[i],
        dead = !state.validEnd,
        nodes = [];
      for (let j = 0; j < state.next.length; j++) {
        let { type, next } = state.next[j];
        nodes.push(type.name);
        if (dead && !(type.isText || type.hasRequiredAttrs())) dead = false;
        if (work.indexOf(next) == -1) work.push(next);
      }
      if (dead)
        stream.err(
          "Only non-generatable nodes (" +
            nodes.join(", ") +
            ") in a required position (see https://prosemirror.net/docs/guide/#generatable)"
        );
    }
  }
  var DOMParser = class _DOMParser {
    /**
    Create a parser that targets the given schema, using the given
    parsing rules.
    */
    constructor(schema, rules) {
      this.schema = schema;
      this.rules = rules;
      this.tags = [];
      this.styles = [];
      rules.forEach((rule) => {
        if (rule.tag) this.tags.push(rule);
        else if (rule.style) this.styles.push(rule);
      });
      this.normalizeLists = !this.tags.some((r) => {
        if (!/^(ul|ol)\b/.test(r.tag) || !r.node) return false;
        let node = schema.nodes[r.node];
        return node.contentMatch.matchType(node);
      });
    }
    /**
    Parse a document from the content of a DOM node.
    */
    parse(dom, options = {}) {
      let context = new ParseContext(this, options, false);
      context.addAll(dom, options.from, options.to);
      return context.finish();
    }
    /**
    Parses the content of the given DOM node, like
    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
    options. But unlike that method, which produces a whole node,
    this one returns a slice that is open at the sides, meaning that
    the schema constraints aren't applied to the start of nodes to
    the left of the input and the end of nodes at the end.
    */
    parseSlice(dom, options = {}) {
      let context = new ParseContext(this, options, true);
      context.addAll(dom, options.from, options.to);
      return Slice.maxOpen(context.finish());
    }
    /**
    @internal
    */
    matchTag(dom, context, after) {
      for (
        let i = after ? this.tags.indexOf(after) + 1 : 0;
        i < this.tags.length;
        i++
      ) {
        let rule = this.tags[i];
        if (
          matches(dom, rule.tag) &&
          (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) &&
          (!rule.context || context.matchesContext(rule.context))
        ) {
          if (rule.getAttrs) {
            let result = rule.getAttrs(dom);
            if (result === false) continue;
            rule.attrs = result || void 0;
          }
          return rule;
        }
      }
    }
    /**
    @internal
    */
    matchStyle(prop, value, context, after) {
      for (
        let i = after ? this.styles.indexOf(after) + 1 : 0;
        i < this.styles.length;
        i++
      ) {
        let rule = this.styles[i],
          style = rule.style;
        if (
          style.indexOf(prop) != 0 ||
          (rule.context && !context.matchesContext(rule.context)) || // Test that the style string either precisely matches the prop,
          // or has an '=' sign after the prop, followed by the given
          // value.
          (style.length > prop.length &&
            (style.charCodeAt(prop.length) != 61 ||
              style.slice(prop.length + 1) != value))
        )
          continue;
        if (rule.getAttrs) {
          let result = rule.getAttrs(value);
          if (result === false) continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
    /**
    @internal
    */
    static schemaRules(schema) {
      let result = [];
      function insert(rule) {
        let priority = rule.priority == null ? 50 : rule.priority,
          i = 0;
        for (; i < result.length; i++) {
          let next = result[i],
            nextPriority = next.priority == null ? 50 : next.priority;
          if (nextPriority < priority) break;
        }
        result.splice(i, 0, rule);
      }
      for (let name in schema.marks) {
        let rules = schema.marks[name].spec.parseDOM;
        if (rules)
          rules.forEach((rule) => {
            insert((rule = copy(rule)));
            if (!(rule.mark || rule.ignore || rule.clearMark)) rule.mark = name;
          });
      }
      for (let name in schema.nodes) {
        let rules = schema.nodes[name].spec.parseDOM;
        if (rules)
          rules.forEach((rule) => {
            insert((rule = copy(rule)));
            if (!(rule.node || rule.ignore || rule.mark)) rule.node = name;
          });
      }
      return result;
    }
    /**
    Construct a DOM parser using the parsing rules listed in a
    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
    [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
    */
    static fromSchema(schema) {
      return (
        schema.cached.domParser ||
        (schema.cached.domParser = new _DOMParser(
          schema,
          _DOMParser.schemaRules(schema)
        ))
      );
    }
  };
  var blockTags = {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    canvas: true,
    dd: true,
    div: true,
    dl: true,
    fieldset: true,
    figcaption: true,
    figure: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    li: true,
    noscript: true,
    ol: true,
    output: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    tfoot: true,
    ul: true,
  };
  var ignoreTags = {
    head: true,
    noscript: true,
    object: true,
    script: true,
    style: true,
    title: true,
  };
  var listTags = { ol: true, ul: true };
  var OPT_PRESERVE_WS = 1;
  var OPT_PRESERVE_WS_FULL = 2;
  var OPT_OPEN_LEFT = 4;
  function wsOptionsFor(type, preserveWhitespace, base) {
    if (preserveWhitespace != null)
      return (
        (preserveWhitespace ? OPT_PRESERVE_WS : 0) |
        (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0)
      );
    return type && type.whitespace == "pre"
      ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL
      : base & ~OPT_OPEN_LEFT;
  }
  var NodeContext = class {
    constructor(type, attrs, marks, pendingMarks, solid, match, options) {
      this.type = type;
      this.attrs = attrs;
      this.marks = marks;
      this.pendingMarks = pendingMarks;
      this.solid = solid;
      this.options = options;
      this.content = [];
      this.activeMarks = Mark.none;
      this.stashMarks = [];
      this.match =
        match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
    }
    findWrapping(node) {
      if (!this.match) {
        if (!this.type) return [];
        let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
        if (fill) {
          this.match = this.type.contentMatch.matchFragment(fill);
        } else {
          let start = this.type.contentMatch,
            wrap;
          if ((wrap = start.findWrapping(node.type))) {
            this.match = start;
            return wrap;
          } else {
            return null;
          }
        }
      }
      return this.match.findWrapping(node.type);
    }
    finish(openEnd) {
      if (!(this.options & OPT_PRESERVE_WS)) {
        let last = this.content[this.content.length - 1],
          m;
        if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
          let text = last;
          if (last.text.length == m[0].length) this.content.pop();
          else
            this.content[this.content.length - 1] = text.withText(
              text.text.slice(0, text.text.length - m[0].length)
            );
        }
      }
      let content = Fragment.from(this.content);
      if (!openEnd && this.match)
        content = content.append(this.match.fillBefore(Fragment.empty, true));
      return this.type
        ? this.type.create(this.attrs, content, this.marks)
        : content;
    }
    popFromStashMark(mark) {
      for (let i = this.stashMarks.length - 1; i >= 0; i--)
        if (mark.eq(this.stashMarks[i])) return this.stashMarks.splice(i, 1)[0];
    }
    applyPending(nextType) {
      for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {
        let mark = pending[i];
        if (
          (this.type
            ? this.type.allowsMarkType(mark.type)
            : markMayApply(mark.type, nextType)) &&
          !mark.isInSet(this.activeMarks)
        ) {
          this.activeMarks = mark.addToSet(this.activeMarks);
          this.pendingMarks = mark.removeFromSet(this.pendingMarks);
        }
      }
    }
    inlineContext(node) {
      if (this.type) return this.type.inlineContent;
      if (this.content.length) return this.content[0].isInline;
      return (
        node.parentNode &&
        !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase())
      );
    }
  };
  var ParseContext = class {
    constructor(parser, options, isOpen) {
      this.parser = parser;
      this.options = options;
      this.isOpen = isOpen;
      this.open = 0;
      let topNode = options.topNode,
        topContext;
      let topOptions =
        wsOptionsFor(null, options.preserveWhitespace, 0) |
        (isOpen ? OPT_OPEN_LEFT : 0);
      if (topNode)
        topContext = new NodeContext(
          topNode.type,
          topNode.attrs,
          Mark.none,
          Mark.none,
          true,
          options.topMatch || topNode.type.contentMatch,
          topOptions
        );
      else if (isOpen)
        topContext = new NodeContext(
          null,
          null,
          Mark.none,
          Mark.none,
          true,
          null,
          topOptions
        );
      else
        topContext = new NodeContext(
          parser.schema.topNodeType,
          null,
          Mark.none,
          Mark.none,
          true,
          null,
          topOptions
        );
      this.nodes = [topContext];
      this.find = options.findPositions;
      this.needsBlock = false;
    }
    get top() {
      return this.nodes[this.open];
    }
    // Add a DOM node to the content. Text is inserted as text node,
    // otherwise, the node is passed to `addElement` or, if it has a
    // `style` attribute, `addElementWithStyles`.
    addDOM(dom) {
      if (dom.nodeType == 3) this.addTextNode(dom);
      else if (dom.nodeType == 1) this.addElement(dom);
    }
    withStyleRules(dom, f) {
      let style = dom.getAttribute("style");
      if (!style) return f();
      let marks = this.readStyles(parseStyles(style));
      if (!marks) return;
      let [addMarks, removeMarks] = marks,
        top = this.top;
      for (let i = 0; i < removeMarks.length; i++)
        this.removePendingMark(removeMarks[i], top);
      for (let i = 0; i < addMarks.length; i++)
        this.addPendingMark(addMarks[i]);
      f();
      for (let i = 0; i < addMarks.length; i++)
        this.removePendingMark(addMarks[i], top);
      for (let i = 0; i < removeMarks.length; i++)
        this.addPendingMark(removeMarks[i]);
    }
    addTextNode(dom) {
      let value = dom.nodeValue;
      let top = this.top;
      if (
        top.options & OPT_PRESERVE_WS_FULL ||
        top.inlineContext(dom) ||
        /[^ \t\r\n\u000c]/.test(value)
      ) {
        if (!(top.options & OPT_PRESERVE_WS)) {
          value = value.replace(/[ \t\r\n\u000c]+/g, " ");
          if (
            /^[ \t\r\n\u000c]/.test(value) &&
            this.open == this.nodes.length - 1
          ) {
            let nodeBefore = top.content[top.content.length - 1];
            let domNodeBefore = dom.previousSibling;
            if (
              !nodeBefore ||
              (domNodeBefore && domNodeBefore.nodeName == "BR") ||
              (nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            )
              value = value.slice(1);
          }
        } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
          value = value.replace(/\r?\n|\r/g, " ");
        } else {
          value = value.replace(/\r\n?/g, "\n");
        }
        if (value) this.insertNode(this.parser.schema.text(value));
        this.findInText(dom);
      } else {
        this.findInside(dom);
      }
    }
    // Try to find a handler for the given tag and use that to parse. If
    // none is found, the element's content nodes are added directly.
    addElement(dom, matchAfter) {
      let name = dom.nodeName.toLowerCase(),
        ruleID;
      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
        normalizeList(dom);
      let rule =
        (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||
        (ruleID = this.parser.matchTag(dom, this, matchAfter));
      if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
        this.findInside(dom);
        this.ignoreFallback(dom);
      } else if (!rule || rule.skip || rule.closeParent) {
        if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1);
        else if (rule && rule.skip.nodeType) dom = rule.skip;
        let sync,
          top = this.top,
          oldNeedsBlock = this.needsBlock;
        if (blockTags.hasOwnProperty(name)) {
          if (top.content.length && top.content[0].isInline && this.open) {
            this.open--;
            top = this.top;
          }
          sync = true;
          if (!top.type) this.needsBlock = true;
        } else if (!dom.firstChild) {
          this.leafFallback(dom);
          return;
        }
        if (rule && rule.skip) this.addAll(dom);
        else this.withStyleRules(dom, () => this.addAll(dom));
        if (sync) this.sync(top);
        this.needsBlock = oldNeedsBlock;
      } else {
        this.withStyleRules(dom, () => {
          this.addElementByRule(
            dom,
            rule,
            rule.consuming === false ? ruleID : void 0
          );
        });
      }
    }
    // Called for leaf DOM nodes that would otherwise be ignored
    leafFallback(dom) {
      if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
        this.addTextNode(dom.ownerDocument.createTextNode("\n"));
    }
    // Called for ignored nodes
    ignoreFallback(dom) {
      if (
        dom.nodeName == "BR" &&
        (!this.top.type || !this.top.type.inlineContent)
      )
        this.findPlace(this.parser.schema.text("-"));
    }
    // Run any style parser associated with the node's styles. Either
    // return an array of marks, or null to indicate some of the styles
    // had a rule with `ignore` set.
    readStyles(styles) {
      let add = Mark.none,
        remove = Mark.none;
      for (let i = 0; i < styles.length; i += 2) {
        for (let after = void 0; ; ) {
          let rule = this.parser.matchStyle(
            styles[i],
            styles[i + 1],
            this,
            after
          );
          if (!rule) break;
          if (rule.ignore) return null;
          if (rule.clearMark) {
            this.top.pendingMarks.concat(this.top.activeMarks).forEach((m) => {
              if (rule.clearMark(m)) remove = m.addToSet(remove);
            });
          } else {
            add = this.parser.schema.marks[rule.mark]
              .create(rule.attrs)
              .addToSet(add);
          }
          if (rule.consuming === false) after = rule;
          else break;
        }
      }
      return [add, remove];
    }
    // Look up a handler for the given node. If none are found, return
    // false. Otherwise, apply it, use its return value to drive the way
    // the node's content is wrapped, and return true.
    addElementByRule(dom, rule, continueAfter) {
      let sync, nodeType, mark;
      if (rule.node) {
        nodeType = this.parser.schema.nodes[rule.node];
        if (!nodeType.isLeaf) {
          sync = this.enter(
            nodeType,
            rule.attrs || null,
            rule.preserveWhitespace
          );
        } else if (!this.insertNode(nodeType.create(rule.attrs))) {
          this.leafFallback(dom);
        }
      } else {
        let markType = this.parser.schema.marks[rule.mark];
        mark = markType.create(rule.attrs);
        this.addPendingMark(mark);
      }
      let startIn = this.top;
      if (nodeType && nodeType.isLeaf) {
        this.findInside(dom);
      } else if (continueAfter) {
        this.addElement(dom, continueAfter);
      } else if (rule.getContent) {
        this.findInside(dom);
        rule
          .getContent(dom, this.parser.schema)
          .forEach((node) => this.insertNode(node));
      } else {
        let contentDOM = dom;
        if (typeof rule.contentElement == "string")
          contentDOM = dom.querySelector(rule.contentElement);
        else if (typeof rule.contentElement == "function")
          contentDOM = rule.contentElement(dom);
        else if (rule.contentElement) contentDOM = rule.contentElement;
        this.findAround(dom, contentDOM, true);
        this.addAll(contentDOM);
      }
      if (sync && this.sync(startIn)) this.open--;
      if (mark) this.removePendingMark(mark, startIn);
    }
    // Add all child nodes between `startIndex` and `endIndex` (or the
    // whole node, if not given). If `sync` is passed, use it to
    // synchronize after every block element.
    addAll(parent, startIndex, endIndex) {
      let index = startIndex || 0;
      for (
        let dom = startIndex
            ? parent.childNodes[startIndex]
            : parent.firstChild,
          end = endIndex == null ? null : parent.childNodes[endIndex];
        dom != end;
        dom = dom.nextSibling, ++index
      ) {
        this.findAtPoint(parent, index);
        this.addDOM(dom);
      }
      this.findAtPoint(parent, index);
    }
    // Try to find a way to fit the given node type into the current
    // context. May add intermediate wrappers and/or leave non-solid
    // nodes that we're in.
    findPlace(node) {
      let route, sync;
      for (let depth = this.open; depth >= 0; depth--) {
        let cx = this.nodes[depth];
        let found2 = cx.findWrapping(node);
        if (found2 && (!route || route.length > found2.length)) {
          route = found2;
          sync = cx;
          if (!found2.length) break;
        }
        if (cx.solid) break;
      }
      if (!route) return false;
      this.sync(sync);
      for (let i = 0; i < route.length; i++)
        this.enterInner(route[i], null, false);
      return true;
    }
    // Try to insert the given node, adjusting the context when needed.
    insertNode(node) {
      if (node.isInline && this.needsBlock && !this.top.type) {
        let block = this.textblockFromContext();
        if (block) this.enterInner(block);
      }
      if (this.findPlace(node)) {
        this.closeExtra();
        let top = this.top;
        top.applyPending(node.type);
        if (top.match) top.match = top.match.matchType(node.type);
        let marks = top.activeMarks;
        for (let i = 0; i < node.marks.length; i++)
          if (!top.type || top.type.allowsMarkType(node.marks[i].type))
            marks = node.marks[i].addToSet(marks);
        top.content.push(node.mark(marks));
        return true;
      }
      return false;
    }
    // Try to start a node of the given type, adjusting the context when
    // necessary.
    enter(type, attrs, preserveWS) {
      let ok = this.findPlace(type.create(attrs));
      if (ok) this.enterInner(type, attrs, true, preserveWS);
      return ok;
    }
    // Open a node of the given type
    enterInner(type, attrs = null, solid = false, preserveWS) {
      this.closeExtra();
      let top = this.top;
      top.applyPending(type);
      top.match = top.match && top.match.matchType(type);
      let options = wsOptionsFor(type, preserveWS, top.options);
      if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
        options |= OPT_OPEN_LEFT;
      this.nodes.push(
        new NodeContext(
          type,
          attrs,
          top.activeMarks,
          top.pendingMarks,
          solid,
          null,
          options
        )
      );
      this.open++;
    }
    // Make sure all nodes above this.open are finished and added to
    // their parents
    closeExtra(openEnd = false) {
      let i = this.nodes.length - 1;
      if (i > this.open) {
        for (; i > this.open; i--)
          this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
        this.nodes.length = this.open + 1;
      }
    }
    finish() {
      this.open = 0;
      this.closeExtra(this.isOpen);
      return this.nodes[0].finish(this.isOpen || this.options.topOpen);
    }
    sync(to) {
      for (let i = this.open; i >= 0; i--)
        if (this.nodes[i] == to) {
          this.open = i;
          return true;
        }
      return false;
    }
    get currentPos() {
      this.closeExtra();
      let pos = 0;
      for (let i = this.open; i >= 0; i--) {
        let content = this.nodes[i].content;
        for (let j = content.length - 1; j >= 0; j--)
          pos += content[j].nodeSize;
        if (i) pos++;
      }
      return pos;
    }
    findAtPoint(parent, offset) {
      if (this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (this.find[i].node == parent && this.find[i].offset == offset)
            this.find[i].pos = this.currentPos;
        }
    }
    findInside(parent) {
      if (this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (
            this.find[i].pos == null &&
            parent.nodeType == 1 &&
            parent.contains(this.find[i].node)
          )
            this.find[i].pos = this.currentPos;
        }
    }
    findAround(parent, content, before) {
      if (parent != content && this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (
            this.find[i].pos == null &&
            parent.nodeType == 1 &&
            parent.contains(this.find[i].node)
          ) {
            let pos = content.compareDocumentPosition(this.find[i].node);
            if (pos & (before ? 2 : 4)) this.find[i].pos = this.currentPos;
          }
        }
    }
    findInText(textNode) {
      if (this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (this.find[i].node == textNode)
            this.find[i].pos =
              this.currentPos -
              (textNode.nodeValue.length - this.find[i].offset);
        }
    }
    // Determines whether the given context string matches this context.
    matchesContext(context) {
      if (context.indexOf("|") > -1)
        return context.split(/\s*\|\s*/).some(this.matchesContext, this);
      let parts = context.split("/");
      let option = this.options.context;
      let useRoot =
        !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
      let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
      let match = (i, depth) => {
        for (; i >= 0; i--) {
          let part = parts[i];
          if (part == "") {
            if (i == parts.length - 1 || i == 0) continue;
            for (; depth >= minDepth; depth--)
              if (match(i - 1, depth)) return true;
            return false;
          } else {
            let next =
              depth > 0 || (depth == 0 && useRoot)
                ? this.nodes[depth].type
                : option && depth >= minDepth
                ? option.node(depth - minDepth).type
                : null;
            if (!next || (next.name != part && next.groups.indexOf(part) == -1))
              return false;
            depth--;
          }
        }
        return true;
      };
      return match(parts.length - 1, this.open);
    }
    textblockFromContext() {
      let $context = this.options.context;
      if ($context)
        for (let d = $context.depth; d >= 0; d--) {
          let deflt = $context
            .node(d)
            .contentMatchAt($context.indexAfter(d)).defaultType;
          if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt;
        }
      for (let name in this.parser.schema.nodes) {
        let type = this.parser.schema.nodes[name];
        if (type.isTextblock && type.defaultAttrs) return type;
      }
    }
    addPendingMark(mark) {
      let found2 = findSameMarkInSet(mark, this.top.pendingMarks);
      if (found2) this.top.stashMarks.push(found2);
      this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
    }
    removePendingMark(mark, upto) {
      for (let depth = this.open; depth >= 0; depth--) {
        let level = this.nodes[depth];
        let found2 = level.pendingMarks.lastIndexOf(mark);
        if (found2 > -1) {
          level.pendingMarks = mark.removeFromSet(level.pendingMarks);
        } else {
          level.activeMarks = mark.removeFromSet(level.activeMarks);
          let stashMark = level.popFromStashMark(mark);
          if (
            stashMark &&
            level.type &&
            level.type.allowsMarkType(stashMark.type)
          )
            level.activeMarks = stashMark.addToSet(level.activeMarks);
        }
        if (level == upto) break;
      }
    }
  };
  function normalizeList(dom) {
    for (
      let child = dom.firstChild, prevItem = null;
      child;
      child = child.nextSibling
    ) {
      let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
      if (name && listTags.hasOwnProperty(name) && prevItem) {
        prevItem.appendChild(child);
        child = prevItem;
      } else if (name == "li") {
        prevItem = child;
      } else if (name) {
        prevItem = null;
      }
    }
  }
  function matches(dom, selector) {
    return (
      dom.matches ||
      dom.msMatchesSelector ||
      dom.webkitMatchesSelector ||
      dom.mozMatchesSelector
    ).call(dom, selector);
  }
  function parseStyles(style) {
    let re = /\s*([\w-]+)\s*:\s*([^;]+)/g,
      m,
      result = [];
    while ((m = re.exec(style))) result.push(m[1], m[2].trim());
    return result;
  }
  function copy(obj) {
    let copy2 = {};
    for (let prop in obj) copy2[prop] = obj[prop];
    return copy2;
  }
  function markMayApply(markType, nodeType) {
    let nodes = nodeType.schema.nodes;
    for (let name in nodes) {
      let parent = nodes[name];
      if (!parent.allowsMarkType(markType)) continue;
      let seen = [],
        scan = (match) => {
          seen.push(match);
          for (let i = 0; i < match.edgeCount; i++) {
            let { type, next } = match.edge(i);
            if (type == nodeType) return true;
            if (seen.indexOf(next) < 0 && scan(next)) return true;
          }
        };
      if (scan(parent.contentMatch)) return true;
    }
  }
  function findSameMarkInSet(mark, set) {
    for (let i = 0; i < set.length; i++) {
      if (mark.eq(set[i])) return set[i];
    }
  }

  // node_modules/prosemirror-transform/dist/index.js
  var lower16 = 65535;
  var factor16 = Math.pow(2, 16);
  function makeRecover(index, offset) {
    return index + offset * factor16;
  }
  function recoverIndex(value) {
    return value & lower16;
  }
  function recoverOffset(value) {
    return (value - (value & lower16)) / factor16;
  }
  var DEL_BEFORE = 1;
  var DEL_AFTER = 2;
  var DEL_ACROSS = 4;
  var DEL_SIDE = 8;
  var MapResult = class {
    /**
    @internal
    */
    constructor(pos, delInfo, recover) {
      this.pos = pos;
      this.delInfo = delInfo;
      this.recover = recover;
    }
    /**
    Tells you whether the position was deleted, that is, whether the
    step removed the token on the side queried (via the `assoc`)
    argument from the document.
    */
    get deleted() {
      return (this.delInfo & DEL_SIDE) > 0;
    }
    /**
    Tells you whether the token before the mapped position was deleted.
    */
    get deletedBefore() {
      return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
    }
    /**
    True when the token after the mapped position was deleted.
    */
    get deletedAfter() {
      return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
    }
    /**
    Tells whether any of the steps mapped through deletes across the
    position (including both the token before and after the
    position).
    */
    get deletedAcross() {
      return (this.delInfo & DEL_ACROSS) > 0;
    }
  };
  var StepMap = class _StepMap {
    /**
    Create a position map. The modifications to the document are
    represented as an array of numbers, in which each group of three
    represents a modified chunk as `[start, oldSize, newSize]`.
    */
    constructor(ranges, inverted = false) {
      this.ranges = ranges;
      this.inverted = inverted;
      if (!ranges.length && _StepMap.empty) return _StepMap.empty;
    }
    /**
    @internal
    */
    recover(value) {
      let diff = 0,
        index = recoverIndex(value);
      if (!this.inverted)
        for (let i = 0; i < index; i++)
          diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
      return this.ranges[index * 3] + diff + recoverOffset(value);
    }
    mapResult(pos, assoc = 1) {
      return this._map(pos, assoc, false);
    }
    map(pos, assoc = 1) {
      return this._map(pos, assoc, true);
    }
    /**
    @internal
    */
    _map(pos, assoc, simple) {
      let diff = 0,
        oldIndex = this.inverted ? 2 : 1,
        newIndex = this.inverted ? 1 : 2;
      for (let i = 0; i < this.ranges.length; i += 3) {
        let start = this.ranges[i] - (this.inverted ? diff : 0);
        if (start > pos) break;
        let oldSize = this.ranges[i + oldIndex],
          newSize = this.ranges[i + newIndex],
          end = start + oldSize;
        if (pos <= end) {
          let side = !oldSize
            ? assoc
            : pos == start
            ? -1
            : pos == end
            ? 1
            : assoc;
          let result = start + diff + (side < 0 ? 0 : newSize);
          if (simple) return result;
          let recover =
            pos == (assoc < 0 ? start : end)
              ? null
              : makeRecover(i / 3, pos - start);
          let del2 =
            pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
          if (assoc < 0 ? pos != start : pos != end) del2 |= DEL_SIDE;
          return new MapResult(result, del2, recover);
        }
        diff += newSize - oldSize;
      }
      return simple ? pos + diff : new MapResult(pos + diff, 0, null);
    }
    /**
    @internal
    */
    touches(pos, recover) {
      let diff = 0,
        index = recoverIndex(recover);
      let oldIndex = this.inverted ? 2 : 1,
        newIndex = this.inverted ? 1 : 2;
      for (let i = 0; i < this.ranges.length; i += 3) {
        let start = this.ranges[i] - (this.inverted ? diff : 0);
        if (start > pos) break;
        let oldSize = this.ranges[i + oldIndex],
          end = start + oldSize;
        if (pos <= end && i == index * 3) return true;
        diff += this.ranges[i + newIndex] - oldSize;
      }
      return false;
    }
    /**
    Calls the given function on each of the changed ranges included in
    this map.
    */
    forEach(f) {
      let oldIndex = this.inverted ? 2 : 1,
        newIndex = this.inverted ? 1 : 2;
      for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
        let start = this.ranges[i],
          oldStart = start - (this.inverted ? diff : 0),
          newStart = start + (this.inverted ? 0 : diff);
        let oldSize = this.ranges[i + oldIndex],
          newSize = this.ranges[i + newIndex];
        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
        diff += newSize - oldSize;
      }
    }
    /**
    Create an inverted version of this map. The result can be used to
    map positions in the post-step document to the pre-step document.
    */
    invert() {
      return new _StepMap(this.ranges, !this.inverted);
    }
    /**
    @internal
    */
    toString() {
      return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
    }
    /**
    Create a map that moves all positions by offset `n` (which may be
    negative). This can be useful when applying steps meant for a
    sub-document to a larger document, or vice-versa.
    */
    static offset(n) {
      return n == 0
        ? _StepMap.empty
        : new _StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
    }
  };
  StepMap.empty = new StepMap([]);
  var stepsByID = /* @__PURE__ */ Object.create(null);
  var Step = class {
    /**
    Get the step map that represents the changes made by this step,
    and which can be used to transform between positions in the old
    and the new document.
    */
    getMap() {
      return StepMap.empty;
    }
    /**
    Try to merge this step with another one, to be applied directly
    after it. Returns the merged step when possible, null if the
    steps can't be merged.
    */
    merge(other) {
      return null;
    }
    /**
    Deserialize a step from its JSON representation. Will call
    through to the step class' own implementation of this method.
    */
    static fromJSON(schema, json) {
      if (!json || !json.stepType)
        throw new RangeError("Invalid input for Step.fromJSON");
      let type = stepsByID[json.stepType];
      if (!type) throw new RangeError(`No step type ${json.stepType} defined`);
      return type.fromJSON(schema, json);
    }
    /**
    To be able to serialize steps to JSON, each step needs a string
    ID to attach to its JSON representation. Use this method to
    register an ID for your step classes. Try to pick something
    that's unlikely to clash with steps from other modules.
    */
    static jsonID(id, stepClass) {
      if (id in stepsByID)
        throw new RangeError("Duplicate use of step JSON ID " + id);
      stepsByID[id] = stepClass;
      stepClass.prototype.jsonID = id;
      return stepClass;
    }
  };
  var StepResult = class _StepResult {
    /**
    @internal
    */
    constructor(doc, failed) {
      this.doc = doc;
      this.failed = failed;
    }
    /**
    Create a successful step result.
    */
    static ok(doc) {
      return new _StepResult(doc, null);
    }
    /**
    Create a failed step result.
    */
    static fail(message) {
      return new _StepResult(null, message);
    }
    /**
    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
    arguments. Create a successful result if it succeeds, and a
    failed one if it throws a `ReplaceError`.
    */
    static fromReplace(doc, from, to, slice) {
      try {
        return _StepResult.ok(doc.replace(from, to, slice));
      } catch (e) {
        if (e instanceof ReplaceError) return _StepResult.fail(e.message);
        throw e;
      }
    }
  };
  function mapFragment(fragment, f, parent) {
    let mapped = [];
    for (let i = 0; i < fragment.childCount; i++) {
      let child = fragment.child(i);
      if (child.content.size)
        child = child.copy(mapFragment(child.content, f, child));
      if (child.isInline) child = f(child, parent, i);
      mapped.push(child);
    }
    return Fragment.fromArray(mapped);
  }
  var AddMarkStep = class _AddMarkStep extends Step {
    /**
    Create a mark step.
    */
    constructor(from, to, mark) {
      super();
      this.from = from;
      this.to = to;
      this.mark = mark;
    }
    apply(doc) {
      let oldSlice = doc.slice(this.from, this.to),
        $from = doc.resolve(this.from);
      let parent = $from.node($from.sharedDepth(this.to));
      let slice = new Slice(
        mapFragment(
          oldSlice.content,
          (node, parent2) => {
            if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
              return node;
            return node.mark(this.mark.addToSet(node.marks));
          },
          parent
        ),
        oldSlice.openStart,
        oldSlice.openEnd
      );
      return StepResult.fromReplace(doc, this.from, this.to, slice);
    }
    invert() {
      return new RemoveMarkStep(this.from, this.to, this.mark);
    }
    map(mapping) {
      let from = mapping.mapResult(this.from, 1),
        to = mapping.mapResult(this.to, -1);
      if ((from.deleted && to.deleted) || from.pos >= to.pos) return null;
      return new _AddMarkStep(from.pos, to.pos, this.mark);
    }
    merge(other) {
      if (
        other instanceof _AddMarkStep &&
        other.mark.eq(this.mark) &&
        this.from <= other.to &&
        this.to >= other.from
      )
        return new _AddMarkStep(
          Math.min(this.from, other.from),
          Math.max(this.to, other.to),
          this.mark
        );
      return null;
    }
    toJSON() {
      return {
        stepType: "addMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to,
      };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for AddMarkStep.fromJSON");
      return new _AddMarkStep(
        json.from,
        json.to,
        schema.markFromJSON(json.mark)
      );
    }
  };
  Step.jsonID("addMark", AddMarkStep);
  var RemoveMarkStep = class _RemoveMarkStep extends Step {
    /**
    Create a mark-removing step.
    */
    constructor(from, to, mark) {
      super();
      this.from = from;
      this.to = to;
      this.mark = mark;
    }
    apply(doc) {
      let oldSlice = doc.slice(this.from, this.to);
      let slice = new Slice(
        mapFragment(
          oldSlice.content,
          (node) => {
            return node.mark(this.mark.removeFromSet(node.marks));
          },
          doc
        ),
        oldSlice.openStart,
        oldSlice.openEnd
      );
      return StepResult.fromReplace(doc, this.from, this.to, slice);
    }
    invert() {
      return new AddMarkStep(this.from, this.to, this.mark);
    }
    map(mapping) {
      let from = mapping.mapResult(this.from, 1),
        to = mapping.mapResult(this.to, -1);
      if ((from.deleted && to.deleted) || from.pos >= to.pos) return null;
      return new _RemoveMarkStep(from.pos, to.pos, this.mark);
    }
    merge(other) {
      if (
        other instanceof _RemoveMarkStep &&
        other.mark.eq(this.mark) &&
        this.from <= other.to &&
        this.to >= other.from
      )
        return new _RemoveMarkStep(
          Math.min(this.from, other.from),
          Math.max(this.to, other.to),
          this.mark
        );
      return null;
    }
    toJSON() {
      return {
        stepType: "removeMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to,
      };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
      return new _RemoveMarkStep(
        json.from,
        json.to,
        schema.markFromJSON(json.mark)
      );
    }
  };
  Step.jsonID("removeMark", RemoveMarkStep);
  var AddNodeMarkStep = class _AddNodeMarkStep extends Step {
    /**
    Create a node mark step.
    */
    constructor(pos, mark) {
      super();
      this.pos = pos;
      this.mark = mark;
    }
    apply(doc) {
      let node = doc.nodeAt(this.pos);
      if (!node) return StepResult.fail("No node at mark step's position");
      let updated = node.type.create(
        node.attrs,
        null,
        this.mark.addToSet(node.marks)
      );
      return StepResult.fromReplace(
        doc,
        this.pos,
        this.pos + 1,
        new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1)
      );
    }
    invert(doc) {
      let node = doc.nodeAt(this.pos);
      if (node) {
        let newSet = this.mark.addToSet(node.marks);
        if (newSet.length == node.marks.length) {
          for (let i = 0; i < node.marks.length; i++)
            if (!node.marks[i].isInSet(newSet))
              return new _AddNodeMarkStep(this.pos, node.marks[i]);
          return new _AddNodeMarkStep(this.pos, this.mark);
        }
      }
      return new RemoveNodeMarkStep(this.pos, this.mark);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);
    }
    toJSON() {
      return {
        stepType: "addNodeMark",
        pos: this.pos,
        mark: this.mark.toJSON(),
      };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.pos != "number")
        throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
      return new _AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
    }
  };
  Step.jsonID("addNodeMark", AddNodeMarkStep);
  var RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {
    /**
    Create a mark-removing step.
    */
    constructor(pos, mark) {
      super();
      this.pos = pos;
      this.mark = mark;
    }
    apply(doc) {
      let node = doc.nodeAt(this.pos);
      if (!node) return StepResult.fail("No node at mark step's position");
      let updated = node.type.create(
        node.attrs,
        null,
        this.mark.removeFromSet(node.marks)
      );
      return StepResult.fromReplace(
        doc,
        this.pos,
        this.pos + 1,
        new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1)
      );
    }
    invert(doc) {
      let node = doc.nodeAt(this.pos);
      if (!node || !this.mark.isInSet(node.marks)) return this;
      return new AddNodeMarkStep(this.pos, this.mark);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter
        ? null
        : new _RemoveNodeMarkStep(pos.pos, this.mark);
    }
    toJSON() {
      return {
        stepType: "removeNodeMark",
        pos: this.pos,
        mark: this.mark.toJSON(),
      };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.pos != "number")
        throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
      return new _RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
    }
  };
  Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
  var ReplaceStep = class _ReplaceStep extends Step {
    /**
    The given `slice` should fit the 'gap' between `from` and
    `to`—the depths must line up, and the surrounding nodes must be
    able to be joined with the open sides of the slice. When
    `structure` is true, the step will fail if the content between
    from and to is not just a sequence of closing and then opening
    tokens (this is to guard against rebased replace steps
    overwriting something they weren't supposed to).
    */
    constructor(from, to, slice, structure = false) {
      super();
      this.from = from;
      this.to = to;
      this.slice = slice;
      this.structure = structure;
    }
    apply(doc) {
      if (this.structure && contentBetween(doc, this.from, this.to))
        return StepResult.fail("Structure replace would overwrite content");
      return StepResult.fromReplace(doc, this.from, this.to, this.slice);
    }
    getMap() {
      return new StepMap([this.from, this.to - this.from, this.slice.size]);
    }
    invert(doc) {
      return new _ReplaceStep(
        this.from,
        this.from + this.slice.size,
        doc.slice(this.from, this.to)
      );
    }
    map(mapping) {
      let from = mapping.mapResult(this.from, 1),
        to = mapping.mapResult(this.to, -1);
      if (from.deletedAcross && to.deletedAcross) return null;
      return new _ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);
    }
    merge(other) {
      if (!(other instanceof _ReplaceStep) || other.structure || this.structure)
        return null;
      if (
        this.from + this.slice.size == other.from &&
        !this.slice.openEnd &&
        !other.slice.openStart
      ) {
        let slice =
          this.slice.size + other.slice.size == 0
            ? Slice.empty
            : new Slice(
                this.slice.content.append(other.slice.content),
                this.slice.openStart,
                other.slice.openEnd
              );
        return new _ReplaceStep(
          this.from,
          this.to + (other.to - other.from),
          slice,
          this.structure
        );
      } else if (
        other.to == this.from &&
        !this.slice.openStart &&
        !other.slice.openEnd
      ) {
        let slice =
          this.slice.size + other.slice.size == 0
            ? Slice.empty
            : new Slice(
                other.slice.content.append(this.slice.content),
                other.slice.openStart,
                this.slice.openEnd
              );
        return new _ReplaceStep(other.from, this.to, slice, this.structure);
      } else {
        return null;
      }
    }
    toJSON() {
      let json = { stepType: "replace", from: this.from, to: this.to };
      if (this.slice.size) json.slice = this.slice.toJSON();
      if (this.structure) json.structure = true;
      return json;
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for ReplaceStep.fromJSON");
      return new _ReplaceStep(
        json.from,
        json.to,
        Slice.fromJSON(schema, json.slice),
        !!json.structure
      );
    }
  };
  Step.jsonID("replace", ReplaceStep);
  var ReplaceAroundStep = class _ReplaceAroundStep extends Step {
    /**
    Create a replace-around step with the given range and gap.
    `insert` should be the point in the slice into which the content
    of the gap should be moved. `structure` has the same meaning as
    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
    */
    constructor(from, to, gapFrom, gapTo, slice, insert, structure = false) {
      super();
      this.from = from;
      this.to = to;
      this.gapFrom = gapFrom;
      this.gapTo = gapTo;
      this.slice = slice;
      this.insert = insert;
      this.structure = structure;
    }
    apply(doc) {
      if (
        this.structure &&
        (contentBetween(doc, this.from, this.gapFrom) ||
          contentBetween(doc, this.gapTo, this.to))
      )
        return StepResult.fail("Structure gap-replace would overwrite content");
      let gap = doc.slice(this.gapFrom, this.gapTo);
      if (gap.openStart || gap.openEnd)
        return StepResult.fail("Gap is not a flat range");
      let inserted = this.slice.insertAt(this.insert, gap.content);
      if (!inserted) return StepResult.fail("Content does not fit in gap");
      return StepResult.fromReplace(doc, this.from, this.to, inserted);
    }
    getMap() {
      return new StepMap([
        this.from,
        this.gapFrom - this.from,
        this.insert,
        this.gapTo,
        this.to - this.gapTo,
        this.slice.size - this.insert,
      ]);
    }
    invert(doc) {
      let gap = this.gapTo - this.gapFrom;
      return new _ReplaceAroundStep(
        this.from,
        this.from + this.slice.size + gap,
        this.from + this.insert,
        this.from + this.insert + gap,
        doc
          .slice(this.from, this.to)
          .removeBetween(this.gapFrom - this.from, this.gapTo - this.from),
        this.gapFrom - this.from,
        this.structure
      );
    }
    map(mapping) {
      let from = mapping.mapResult(this.from, 1),
        to = mapping.mapResult(this.to, -1);
      let gapFrom = mapping.map(this.gapFrom, -1),
        gapTo = mapping.map(this.gapTo, 1);
      if (
        (from.deletedAcross && to.deletedAcross) ||
        gapFrom < from.pos ||
        gapTo > to.pos
      )
        return null;
      return new _ReplaceAroundStep(
        from.pos,
        to.pos,
        gapFrom,
        gapTo,
        this.slice,
        this.insert,
        this.structure
      );
    }
    toJSON() {
      let json = {
        stepType: "replaceAround",
        from: this.from,
        to: this.to,
        gapFrom: this.gapFrom,
        gapTo: this.gapTo,
        insert: this.insert,
      };
      if (this.slice.size) json.slice = this.slice.toJSON();
      if (this.structure) json.structure = true;
      return json;
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (
        typeof json.from != "number" ||
        typeof json.to != "number" ||
        typeof json.gapFrom != "number" ||
        typeof json.gapTo != "number" ||
        typeof json.insert != "number"
      )
        throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
      return new _ReplaceAroundStep(
        json.from,
        json.to,
        json.gapFrom,
        json.gapTo,
        Slice.fromJSON(schema, json.slice),
        json.insert,
        !!json.structure
      );
    }
  };
  Step.jsonID("replaceAround", ReplaceAroundStep);
  function contentBetween(doc, from, to) {
    let $from = doc.resolve(from),
      dist = to - from,
      depth = $from.depth;
    while (
      dist > 0 &&
      depth > 0 &&
      $from.indexAfter(depth) == $from.node(depth).childCount
    ) {
      depth--;
      dist--;
    }
    if (dist > 0) {
      let next = $from.node(depth).maybeChild($from.indexAfter(depth));
      while (dist > 0) {
        if (!next || next.isLeaf) return true;
        next = next.firstChild;
        dist--;
      }
    }
    return false;
  }
  function canCut(node, start, end) {
    return (
      (start == 0 || node.canReplace(start, node.childCount)) &&
      (end == node.childCount || node.canReplace(0, end))
    );
  }
  function liftTarget(range) {
    let parent = range.parent;
    let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
    for (let depth = range.depth; ; --depth) {
      let node = range.$from.node(depth);
      let index = range.$from.index(depth),
        endIndex = range.$to.indexAfter(depth);
      if (depth < range.depth && node.canReplace(index, endIndex, content))
        return depth;
      if (
        depth == 0 ||
        node.type.spec.isolating ||
        !canCut(node, index, endIndex)
      )
        break;
    }
    return null;
  }
  function findWrapping(range, nodeType, attrs = null, innerRange = range) {
    let around = findWrappingOutside(range, nodeType);
    let inner = around && findWrappingInside(innerRange, nodeType);
    if (!inner) return null;
    return around
      .map(withAttrs)
      .concat({ type: nodeType, attrs })
      .concat(inner.map(withAttrs));
  }
  function withAttrs(type) {
    return { type, attrs: null };
  }
  function findWrappingOutside(range, type) {
    let { parent, startIndex, endIndex } = range;
    let around = parent.contentMatchAt(startIndex).findWrapping(type);
    if (!around) return null;
    let outer = around.length ? around[0] : type;
    return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
  }
  function findWrappingInside(range, type) {
    let { parent, startIndex, endIndex } = range;
    let inner = parent.child(startIndex);
    let inside = type.contentMatch.findWrapping(inner.type);
    if (!inside) return null;
    let lastType = inside.length ? inside[inside.length - 1] : type;
    let innerMatch = lastType.contentMatch;
    for (let i = startIndex; innerMatch && i < endIndex; i++)
      innerMatch = innerMatch.matchType(parent.child(i).type);
    if (!innerMatch || !innerMatch.validEnd) return null;
    return inside;
  }
  function canSplit(doc, pos, depth = 1, typesAfter) {
    let $pos = doc.resolve(pos),
      base = $pos.depth - depth;
    let innerType =
      (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent;
    if (
      base < 0 ||
      $pos.parent.type.spec.isolating ||
      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||
      !innerType.type.validContent(
        $pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)
      )
    )
      return false;
    for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {
      let node = $pos.node(d),
        index2 = $pos.index(d);
      if (node.type.spec.isolating) return false;
      let rest = node.content.cutByIndex(index2, node.childCount);
      let overrideChild = typesAfter && typesAfter[i + 1];
      if (overrideChild)
        rest = rest.replaceChild(
          0,
          overrideChild.type.create(overrideChild.attrs)
        );
      let after = (typesAfter && typesAfter[i]) || node;
      if (
        !node.canReplace(index2 + 1, node.childCount) ||
        !after.type.validContent(rest)
      )
        return false;
    }
    let index = $pos.indexAfter(base);
    let baseType = typesAfter && typesAfter[0];
    return $pos
      .node(base)
      .canReplaceWith(
        index,
        index,
        baseType ? baseType.type : $pos.node(base + 1).type
      );
  }
  function canJoin(doc, pos) {
    let $pos = doc.resolve(pos),
      index = $pos.index();
    return (
      joinable2($pos.nodeBefore, $pos.nodeAfter) &&
      $pos.parent.canReplace(index, index + 1)
    );
  }
  function joinable2(a, b) {
    return !!(a && b && !a.isLeaf && a.canAppend(b));
  }
  function joinPoint(doc, pos, dir = -1) {
    let $pos = doc.resolve(pos);
    for (let d = $pos.depth; ; d--) {
      let before,
        after,
        index = $pos.index(d);
      if (d == $pos.depth) {
        before = $pos.nodeBefore;
        after = $pos.nodeAfter;
      } else if (dir > 0) {
        before = $pos.node(d + 1);
        index++;
        after = $pos.node(d).maybeChild(index);
      } else {
        before = $pos.node(d).maybeChild(index - 1);
        after = $pos.node(d + 1);
      }
      if (
        before &&
        !before.isTextblock &&
        joinable2(before, after) &&
        $pos.node(d).canReplace(index, index + 1)
      )
        return pos;
      if (d == 0) break;
      pos = dir < 0 ? $pos.before(d) : $pos.after(d);
    }
  }
  function replaceStep(doc, from, to = from, slice = Slice.empty) {
    if (from == to && !slice.size) return null;
    let $from = doc.resolve(from),
      $to = doc.resolve(to);
    if (fitsTrivially($from, $to, slice))
      return new ReplaceStep(from, to, slice);
    return new Fitter($from, $to, slice).fit();
  }
  function fitsTrivially($from, $to, slice) {
    return (
      !slice.openStart &&
      !slice.openEnd &&
      $from.start() == $to.start() &&
      $from.parent.canReplace($from.index(), $to.index(), slice.content)
    );
  }
  var Fitter = class {
    constructor($from, $to, unplaced) {
      this.$from = $from;
      this.$to = $to;
      this.unplaced = unplaced;
      this.frontier = [];
      this.placed = Fragment.empty;
      for (let i = 0; i <= $from.depth; i++) {
        let node = $from.node(i);
        this.frontier.push({
          type: node.type,
          match: node.contentMatchAt($from.indexAfter(i)),
        });
      }
      for (let i = $from.depth; i > 0; i--)
        this.placed = Fragment.from($from.node(i).copy(this.placed));
    }
    get depth() {
      return this.frontier.length - 1;
    }
    fit() {
      while (this.unplaced.size) {
        let fit = this.findFittable();
        if (fit) this.placeNodes(fit);
        else this.openMore() || this.dropNode();
      }
      let moveInline = this.mustMoveInline(),
        placedSize = this.placed.size - this.depth - this.$from.depth;
      let $from = this.$from,
        $to = this.close(
          moveInline < 0 ? this.$to : $from.doc.resolve(moveInline)
        );
      if (!$to) return null;
      let content = this.placed,
        openStart = $from.depth,
        openEnd = $to.depth;
      while (openStart && openEnd && content.childCount == 1) {
        content = content.firstChild.content;
        openStart--;
        openEnd--;
      }
      let slice = new Slice(content, openStart, openEnd);
      if (moveInline > -1)
        return new ReplaceAroundStep(
          $from.pos,
          moveInline,
          this.$to.pos,
          this.$to.end(),
          slice,
          placedSize
        );
      if (slice.size || $from.pos != this.$to.pos)
        return new ReplaceStep($from.pos, $to.pos, slice);
      return null;
    }
    // Find a position on the start spine of `this.unplaced` that has
    // content that can be moved somewhere on the frontier. Returns two
    // depths, one for the slice and one for the frontier.
    findFittable() {
      let startDepth = this.unplaced.openStart;
      for (
        let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd;
        d < startDepth;
        d++
      ) {
        let node = cur.firstChild;
        if (cur.childCount > 1) openEnd = 0;
        if (node.type.spec.isolating && openEnd <= d) {
          startDepth = d;
          break;
        }
        cur = node.content;
      }
      for (let pass = 1; pass <= 2; pass++) {
        for (
          let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart;
          sliceDepth >= 0;
          sliceDepth--
        ) {
          let fragment,
            parent = null;
          if (sliceDepth) {
            parent = contentAt(
              this.unplaced.content,
              sliceDepth - 1
            ).firstChild;
            fragment = parent.content;
          } else {
            fragment = this.unplaced.content;
          }
          let first2 = fragment.firstChild;
          for (
            let frontierDepth = this.depth;
            frontierDepth >= 0;
            frontierDepth--
          ) {
            let { type, match } = this.frontier[frontierDepth],
              wrap,
              inject = null;
            if (
              pass == 1 &&
              (first2
                ? match.matchType(first2.type) ||
                  (inject = match.fillBefore(Fragment.from(first2), false))
                : parent && type.compatibleContent(parent.type))
            )
              return { sliceDepth, frontierDepth, parent, inject };
            else if (
              pass == 2 &&
              first2 &&
              (wrap = match.findWrapping(first2.type))
            )
              return { sliceDepth, frontierDepth, parent, wrap };
            if (parent && match.matchType(parent.type)) break;
          }
        }
      }
    }
    openMore() {
      let { content, openStart, openEnd } = this.unplaced;
      let inner = contentAt(content, openStart);
      if (!inner.childCount || inner.firstChild.isLeaf) return false;
      this.unplaced = new Slice(
        content,
        openStart + 1,
        Math.max(
          openEnd,
          inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0
        )
      );
      return true;
    }
    dropNode() {
      let { content, openStart, openEnd } = this.unplaced;
      let inner = contentAt(content, openStart);
      if (inner.childCount <= 1 && openStart > 0) {
        let openAtEnd = content.size - openStart <= openStart + inner.size;
        this.unplaced = new Slice(
          dropFromFragment(content, openStart - 1, 1),
          openStart - 1,
          openAtEnd ? openStart - 1 : openEnd
        );
      } else {
        this.unplaced = new Slice(
          dropFromFragment(content, openStart, 1),
          openStart,
          openEnd
        );
      }
    }
    // Move content from the unplaced slice at `sliceDepth` to the
    // frontier node at `frontierDepth`. Close that frontier node when
    // applicable.
    placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap }) {
      while (this.depth > frontierDepth) this.closeFrontierNode();
      if (wrap)
        for (let i = 0; i < wrap.length; i++) this.openFrontierNode(wrap[i]);
      let slice = this.unplaced,
        fragment = parent ? parent.content : slice.content;
      let openStart = slice.openStart - sliceDepth;
      let taken = 0,
        add = [];
      let { match, type } = this.frontier[frontierDepth];
      if (inject) {
        for (let i = 0; i < inject.childCount; i++) add.push(inject.child(i));
        match = match.matchFragment(inject);
      }
      let openEndCount =
        fragment.size + sliceDepth - (slice.content.size - slice.openEnd);
      while (taken < fragment.childCount) {
        let next = fragment.child(taken),
          matches2 = match.matchType(next.type);
        if (!matches2) break;
        taken++;
        if (taken > 1 || openStart == 0 || next.content.size) {
          match = matches2;
          add.push(
            closeNodeStart(
              next.mark(type.allowedMarks(next.marks)),
              taken == 1 ? openStart : 0,
              taken == fragment.childCount ? openEndCount : -1
            )
          );
        }
      }
      let toEnd = taken == fragment.childCount;
      if (!toEnd) openEndCount = -1;
      this.placed = addToFragment(
        this.placed,
        frontierDepth,
        Fragment.from(add)
      );
      this.frontier[frontierDepth].match = match;
      if (
        toEnd &&
        openEndCount < 0 &&
        parent &&
        parent.type == this.frontier[this.depth].type &&
        this.frontier.length > 1
      )
        this.closeFrontierNode();
      for (let i = 0, cur = fragment; i < openEndCount; i++) {
        let node = cur.lastChild;
        this.frontier.push({
          type: node.type,
          match: node.contentMatchAt(node.childCount),
        });
        cur = node.content;
      }
      this.unplaced = !toEnd
        ? new Slice(
            dropFromFragment(slice.content, sliceDepth, taken),
            slice.openStart,
            slice.openEnd
          )
        : sliceDepth == 0
        ? Slice.empty
        : new Slice(
            dropFromFragment(slice.content, sliceDepth - 1, 1),
            sliceDepth - 1,
            openEndCount < 0 ? slice.openEnd : sliceDepth - 1
          );
    }
    mustMoveInline() {
      if (!this.$to.parent.isTextblock) return -1;
      let top = this.frontier[this.depth],
        level;
      if (
        !top.type.isTextblock ||
        !contentAfterFits(
          this.$to,
          this.$to.depth,
          top.type,
          top.match,
          false
        ) ||
        (this.$to.depth == this.depth &&
          (level = this.findCloseLevel(this.$to)) &&
          level.depth == this.depth)
      )
        return -1;
      let { depth } = this.$to,
        after = this.$to.after(depth);
      while (depth > 1 && after == this.$to.end(--depth)) ++after;
      return after;
    }
    findCloseLevel($to) {
      scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
        let { match, type } = this.frontier[i];
        let dropInner =
          i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
        let fit = contentAfterFits($to, i, type, match, dropInner);
        if (!fit) continue;
        for (let d = i - 1; d >= 0; d--) {
          let { match: match2, type: type2 } = this.frontier[d];
          let matches2 = contentAfterFits($to, d, type2, match2, true);
          if (!matches2 || matches2.childCount) continue scan;
        }
        return {
          depth: i,
          fit,
          move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to,
        };
      }
    }
    close($to) {
      let close2 = this.findCloseLevel($to);
      if (!close2) return null;
      while (this.depth > close2.depth) this.closeFrontierNode();
      if (close2.fit.childCount)
        this.placed = addToFragment(this.placed, close2.depth, close2.fit);
      $to = close2.move;
      for (let d = close2.depth + 1; d <= $to.depth; d++) {
        let node = $to.node(d),
          add = node.type.contentMatch.fillBefore(
            node.content,
            true,
            $to.index(d)
          );
        this.openFrontierNode(node.type, node.attrs, add);
      }
      return $to;
    }
    openFrontierNode(type, attrs = null, content) {
      let top = this.frontier[this.depth];
      top.match = top.match.matchType(type);
      this.placed = addToFragment(
        this.placed,
        this.depth,
        Fragment.from(type.create(attrs, content))
      );
      this.frontier.push({ type, match: type.contentMatch });
    }
    closeFrontierNode() {
      let open = this.frontier.pop();
      let add = open.match.fillBefore(Fragment.empty, true);
      if (add.childCount)
        this.placed = addToFragment(this.placed, this.frontier.length, add);
    }
  };
  function dropFromFragment(fragment, depth, count) {
    if (depth == 0) return fragment.cutByIndex(count, fragment.childCount);
    return fragment.replaceChild(
      0,
      fragment.firstChild.copy(
        dropFromFragment(fragment.firstChild.content, depth - 1, count)
      )
    );
  }
  function addToFragment(fragment, depth, content) {
    if (depth == 0) return fragment.append(content);
    return fragment.replaceChild(
      fragment.childCount - 1,
      fragment.lastChild.copy(
        addToFragment(fragment.lastChild.content, depth - 1, content)
      )
    );
  }
  function contentAt(fragment, depth) {
    for (let i = 0; i < depth; i++) fragment = fragment.firstChild.content;
    return fragment;
  }
  function closeNodeStart(node, openStart, openEnd) {
    if (openStart <= 0) return node;
    let frag = node.content;
    if (openStart > 1)
      frag = frag.replaceChild(
        0,
        closeNodeStart(
          frag.firstChild,
          openStart - 1,
          frag.childCount == 1 ? openEnd - 1 : 0
        )
      );
    if (openStart > 0) {
      frag = node.type.contentMatch.fillBefore(frag).append(frag);
      if (openEnd <= 0)
        frag = frag.append(
          node.type.contentMatch
            .matchFragment(frag)
            .fillBefore(Fragment.empty, true)
        );
    }
    return node.copy(frag);
  }
  function contentAfterFits($to, depth, type, match, open) {
    let node = $to.node(depth),
      index = open ? $to.indexAfter(depth) : $to.index(depth);
    if (index == node.childCount && !type.compatibleContent(node.type))
      return null;
    let fit = match.fillBefore(node.content, true, index);
    return fit && !invalidMarks(type, node.content, index) ? fit : null;
  }
  function invalidMarks(type, fragment, start) {
    for (let i = start; i < fragment.childCount; i++)
      if (!type.allowsMarks(fragment.child(i).marks)) return true;
    return false;
  }
  var AttrStep = class _AttrStep extends Step {
    /**
    Construct an attribute step.
    */
    constructor(pos, attr, value) {
      super();
      this.pos = pos;
      this.attr = attr;
      this.value = value;
    }
    apply(doc) {
      let node = doc.nodeAt(this.pos);
      if (!node) return StepResult.fail("No node at attribute step's position");
      let attrs = /* @__PURE__ */ Object.create(null);
      for (let name in node.attrs) attrs[name] = node.attrs[name];
      attrs[this.attr] = this.value;
      let updated = node.type.create(attrs, null, node.marks);
      return StepResult.fromReplace(
        doc,
        this.pos,
        this.pos + 1,
        new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1)
      );
    }
    getMap() {
      return StepMap.empty;
    }
    invert(doc) {
      return new _AttrStep(
        this.pos,
        this.attr,
        doc.nodeAt(this.pos).attrs[this.attr]
      );
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter
        ? null
        : new _AttrStep(pos.pos, this.attr, this.value);
    }
    toJSON() {
      return {
        stepType: "attr",
        pos: this.pos,
        attr: this.attr,
        value: this.value,
      };
    }
    static fromJSON(schema, json) {
      if (typeof json.pos != "number" || typeof json.attr != "string")
        throw new RangeError("Invalid input for AttrStep.fromJSON");
      return new _AttrStep(json.pos, json.attr, json.value);
    }
  };
  Step.jsonID("attr", AttrStep);
  var DocAttrStep = class _DocAttrStep extends Step {
    /**
    Construct an attribute step.
    */
    constructor(attr, value) {
      super();
      this.attr = attr;
      this.value = value;
    }
    apply(doc) {
      let attrs = /* @__PURE__ */ Object.create(null);
      for (let name in doc.attrs) attrs[name] = doc.attrs[name];
      attrs[this.attr] = this.value;
      let updated = doc.type.create(attrs, doc.content, doc.marks);
      return StepResult.ok(updated);
    }
    getMap() {
      return StepMap.empty;
    }
    invert(doc) {
      return new _DocAttrStep(this.attr, doc.attrs[this.attr]);
    }
    map(mapping) {
      return this;
    }
    toJSON() {
      return { stepType: "docAttr", attr: this.attr, value: this.value };
    }
    static fromJSON(schema, json) {
      if (typeof json.attr != "string")
        throw new RangeError("Invalid input for DocAttrStep.fromJSON");
      return new _DocAttrStep(json.attr, json.value);
    }
  };
  Step.jsonID("docAttr", DocAttrStep);
  var TransformError = class extends Error {};
  TransformError = function TransformError2(message) {
    let err = Error.call(this, message);
    err.__proto__ = TransformError2.prototype;
    return err;
  };
  TransformError.prototype = Object.create(Error.prototype);
  TransformError.prototype.constructor = TransformError;
  TransformError.prototype.name = "TransformError";

  // node_modules/prosemirror-state/dist/index.js
  var classesById = /* @__PURE__ */ Object.create(null);
  var Selection = class {
    /**
    Initialize a selection with the head and anchor and ranges. If no
    ranges are given, constructs a single range across `$anchor` and
    `$head`.
    */
    constructor($anchor, $head, ranges) {
      this.$anchor = $anchor;
      this.$head = $head;
      this.ranges = ranges || [
        new SelectionRange($anchor.min($head), $anchor.max($head)),
      ];
    }
    /**
    The selection's anchor, as an unresolved position.
    */
    get anchor() {
      return this.$anchor.pos;
    }
    /**
    The selection's head.
    */
    get head() {
      return this.$head.pos;
    }
    /**
    The lower bound of the selection's main range.
    */
    get from() {
      return this.$from.pos;
    }
    /**
    The upper bound of the selection's main range.
    */
    get to() {
      return this.$to.pos;
    }
    /**
    The resolved lower  bound of the selection's main range.
    */
    get $from() {
      return this.ranges[0].$from;
    }
    /**
    The resolved upper bound of the selection's main range.
    */
    get $to() {
      return this.ranges[0].$to;
    }
    /**
    Indicates whether the selection contains any content.
    */
    get empty() {
      let ranges = this.ranges;
      for (let i = 0; i < ranges.length; i++)
        if (ranges[i].$from.pos != ranges[i].$to.pos) return false;
      return true;
    }
    /**
    Get the content of this selection as a slice.
    */
    content() {
      return this.$from.doc.slice(this.from, this.to, true);
    }
    /**
    Replace the selection with a slice or, if no slice is given,
    delete the selection. Will append to the given transaction.
    */
    replace(tr, content = Slice.empty) {
      let lastNode = content.content.lastChild,
        lastParent = null;
      for (let i = 0; i < content.openEnd; i++) {
        lastParent = lastNode;
        lastNode = lastNode.lastChild;
      }
      let mapFrom = tr.steps.length,
        ranges = this.ranges;
      for (let i = 0; i < ranges.length; i++) {
        let { $from, $to } = ranges[i],
          mapping = tr.mapping.slice(mapFrom);
        tr.replaceRange(
          mapping.map($from.pos),
          mapping.map($to.pos),
          i ? Slice.empty : content
        );
        if (i == 0)
          selectionToInsertionEnd(
            tr,
            mapFrom,
            (
              lastNode
                ? lastNode.isInline
                : lastParent && lastParent.isTextblock
            )
              ? -1
              : 1
          );
      }
    }
    /**
    Replace the selection with the given node, appending the changes
    to the given transaction.
    */
    replaceWith(tr, node) {
      let mapFrom = tr.steps.length,
        ranges = this.ranges;
      for (let i = 0; i < ranges.length; i++) {
        let { $from, $to } = ranges[i],
          mapping = tr.mapping.slice(mapFrom);
        let from = mapping.map($from.pos),
          to = mapping.map($to.pos);
        if (i) {
          tr.deleteRange(from, to);
        } else {
          tr.replaceRangeWith(from, to, node);
          selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
        }
      }
    }
    /**
    Find a valid cursor or leaf node selection starting at the given
    position and searching back if `dir` is negative, and forward if
    positive. When `textOnly` is true, only consider cursor
    selections. Will return null when no valid selection position is
    found.
    */
    static findFrom($pos, dir, textOnly = false) {
      let inner = $pos.parent.inlineContent
        ? new TextSelection($pos)
        : findSelectionIn(
            $pos.node(0),
            $pos.parent,
            $pos.pos,
            $pos.index(),
            dir,
            textOnly
          );
      if (inner) return inner;
      for (let depth = $pos.depth - 1; depth >= 0; depth--) {
        let found2 =
          dir < 0
            ? findSelectionIn(
                $pos.node(0),
                $pos.node(depth),
                $pos.before(depth + 1),
                $pos.index(depth),
                dir,
                textOnly
              )
            : findSelectionIn(
                $pos.node(0),
                $pos.node(depth),
                $pos.after(depth + 1),
                $pos.index(depth) + 1,
                dir,
                textOnly
              );
        if (found2) return found2;
      }
      return null;
    }
    /**
    Find a valid cursor or leaf node selection near the given
    position. Searches forward first by default, but if `bias` is
    negative, it will search backwards first.
    */
    static near($pos, bias = 1) {
      return (
        this.findFrom($pos, bias) ||
        this.findFrom($pos, -bias) ||
        new AllSelection($pos.node(0))
      );
    }
    /**
    Find the cursor or leaf node selection closest to the start of
    the given document. Will return an
    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
    exists.
    */
    static atStart(doc) {
      return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);
    }
    /**
    Find the cursor or leaf node selection closest to the end of the
    given document.
    */
    static atEnd(doc) {
      return (
        findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) ||
        new AllSelection(doc)
      );
    }
    /**
    Deserialize the JSON representation of a selection. Must be
    implemented for custom classes (as a static class method).
    */
    static fromJSON(doc, json) {
      if (!json || !json.type)
        throw new RangeError("Invalid input for Selection.fromJSON");
      let cls = classesById[json.type];
      if (!cls) throw new RangeError(`No selection type ${json.type} defined`);
      return cls.fromJSON(doc, json);
    }
    /**
    To be able to deserialize selections from JSON, custom selection
    classes must register themselves with an ID string, so that they
    can be disambiguated. Try to pick something that's unlikely to
    clash with classes from other modules.
    */
    static jsonID(id, selectionClass) {
      if (id in classesById)
        throw new RangeError("Duplicate use of selection JSON ID " + id);
      classesById[id] = selectionClass;
      selectionClass.prototype.jsonID = id;
      return selectionClass;
    }
    /**
    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
    which is a value that can be mapped without having access to a
    current document, and later resolved to a real selection for a
    given document again. (This is used mostly by the history to
    track and restore old selections.) The default implementation of
    this method just converts the selection to a text selection and
    returns the bookmark for that.
    */
    getBookmark() {
      return TextSelection.between(this.$anchor, this.$head).getBookmark();
    }
  };
  Selection.prototype.visible = true;
  var SelectionRange = class {
    /**
    Create a range.
    */
    constructor($from, $to) {
      this.$from = $from;
      this.$to = $to;
    }
  };
  var warnedAboutTextSelection = false;
  function checkTextSelection($pos) {
    if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
      warnedAboutTextSelection = true;
      console["warn"](
        "TextSelection endpoint not pointing into a node with inline content (" +
          $pos.parent.type.name +
          ")"
      );
    }
  }
  var TextSelection = class _TextSelection extends Selection {
    /**
    Construct a text selection between the given points.
    */
    constructor($anchor, $head = $anchor) {
      checkTextSelection($anchor);
      checkTextSelection($head);
      super($anchor, $head);
    }
    /**
    Returns a resolved position if this is a cursor selection (an
    empty text selection), and null otherwise.
    */
    get $cursor() {
      return this.$anchor.pos == this.$head.pos ? this.$head : null;
    }
    map(doc, mapping) {
      let $head = doc.resolve(mapping.map(this.head));
      if (!$head.parent.inlineContent) return Selection.near($head);
      let $anchor = doc.resolve(mapping.map(this.anchor));
      return new _TextSelection(
        $anchor.parent.inlineContent ? $anchor : $head,
        $head
      );
    }
    replace(tr, content = Slice.empty) {
      super.replace(tr, content);
      if (content == Slice.empty) {
        let marks = this.$from.marksAcross(this.$to);
        if (marks) tr.ensureMarks(marks);
      }
    }
    eq(other) {
      return (
        other instanceof _TextSelection &&
        other.anchor == this.anchor &&
        other.head == this.head
      );
    }
    getBookmark() {
      return new TextBookmark(this.anchor, this.head);
    }
    toJSON() {
      return { type: "text", anchor: this.anchor, head: this.head };
    }
    /**
    @internal
    */
    static fromJSON(doc, json) {
      if (typeof json.anchor != "number" || typeof json.head != "number")
        throw new RangeError("Invalid input for TextSelection.fromJSON");
      return new _TextSelection(
        doc.resolve(json.anchor),
        doc.resolve(json.head)
      );
    }
    /**
    Create a text selection from non-resolved positions.
    */
    static create(doc, anchor, head = anchor) {
      let $anchor = doc.resolve(anchor);
      return new this($anchor, head == anchor ? $anchor : doc.resolve(head));
    }
    /**
    Return a text selection that spans the given positions or, if
    they aren't text positions, find a text selection near them.
    `bias` determines whether the method searches forward (default)
    or backwards (negative number) first. Will fall back to calling
    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
    doesn't contain a valid text position.
    */
    static between($anchor, $head, bias) {
      let dPos = $anchor.pos - $head.pos;
      if (!bias || dPos) bias = dPos >= 0 ? 1 : -1;
      if (!$head.parent.inlineContent) {
        let found2 =
          Selection.findFrom($head, bias, true) ||
          Selection.findFrom($head, -bias, true);
        if (found2) $head = found2.$head;
        else return Selection.near($head, bias);
      }
      if (!$anchor.parent.inlineContent) {
        if (dPos == 0) {
          $anchor = $head;
        } else {
          $anchor = (
            Selection.findFrom($anchor, -bias, true) ||
            Selection.findFrom($anchor, bias, true)
          ).$anchor;
          if ($anchor.pos < $head.pos != dPos < 0) $anchor = $head;
        }
      }
      return new _TextSelection($anchor, $head);
    }
  };
  Selection.jsonID("text", TextSelection);
  var TextBookmark = class _TextBookmark {
    constructor(anchor, head) {
      this.anchor = anchor;
      this.head = head;
    }
    map(mapping) {
      return new _TextBookmark(
        mapping.map(this.anchor),
        mapping.map(this.head)
      );
    }
    resolve(doc) {
      return TextSelection.between(
        doc.resolve(this.anchor),
        doc.resolve(this.head)
      );
    }
  };
  var NodeSelection = class _NodeSelection extends Selection {
    /**
    Create a node selection. Does not verify the validity of its
    argument.
    */
    constructor($pos) {
      let node = $pos.nodeAfter;
      let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
      super($pos, $end);
      this.node = node;
    }
    map(doc, mapping) {
      let { deleted, pos } = mapping.mapResult(this.anchor);
      let $pos = doc.resolve(pos);
      if (deleted) return Selection.near($pos);
      return new _NodeSelection($pos);
    }
    content() {
      return new Slice(Fragment.from(this.node), 0, 0);
    }
    eq(other) {
      return other instanceof _NodeSelection && other.anchor == this.anchor;
    }
    toJSON() {
      return { type: "node", anchor: this.anchor };
    }
    getBookmark() {
      return new NodeBookmark(this.anchor);
    }
    /**
    @internal
    */
    static fromJSON(doc, json) {
      if (typeof json.anchor != "number")
        throw new RangeError("Invalid input for NodeSelection.fromJSON");
      return new _NodeSelection(doc.resolve(json.anchor));
    }
    /**
    Create a node selection from non-resolved positions.
    */
    static create(doc, from) {
      return new _NodeSelection(doc.resolve(from));
    }
    /**
    Determines whether the given node may be selected as a node
    selection.
    */
    static isSelectable(node) {
      return !node.isText && node.type.spec.selectable !== false;
    }
  };
  NodeSelection.prototype.visible = false;
  Selection.jsonID("node", NodeSelection);
  var NodeBookmark = class _NodeBookmark {
    constructor(anchor) {
      this.anchor = anchor;
    }
    map(mapping) {
      let { deleted, pos } = mapping.mapResult(this.anchor);
      return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);
    }
    resolve(doc) {
      let $pos = doc.resolve(this.anchor),
        node = $pos.nodeAfter;
      if (node && NodeSelection.isSelectable(node))
        return new NodeSelection($pos);
      return Selection.near($pos);
    }
  };
  var AllSelection = class _AllSelection extends Selection {
    /**
    Create an all-selection over the given document.
    */
    constructor(doc) {
      super(doc.resolve(0), doc.resolve(doc.content.size));
    }
    replace(tr, content = Slice.empty) {
      if (content == Slice.empty) {
        tr.delete(0, tr.doc.content.size);
        let sel = Selection.atStart(tr.doc);
        if (!sel.eq(tr.selection)) tr.setSelection(sel);
      } else {
        super.replace(tr, content);
      }
    }
    toJSON() {
      return { type: "all" };
    }
    /**
    @internal
    */
    static fromJSON(doc) {
      return new _AllSelection(doc);
    }
    map(doc) {
      return new _AllSelection(doc);
    }
    eq(other) {
      return other instanceof _AllSelection;
    }
    getBookmark() {
      return AllBookmark;
    }
  };
  Selection.jsonID("all", AllSelection);
  var AllBookmark = {
    map() {
      return this;
    },
    resolve(doc) {
      return new AllSelection(doc);
    },
  };
  function findSelectionIn(doc, node, pos, index, dir, text = false) {
    if (node.inlineContent) return TextSelection.create(doc, pos);
    for (
      let i = index - (dir > 0 ? 0 : 1);
      dir > 0 ? i < node.childCount : i >= 0;
      i += dir
    ) {
      let child = node.child(i);
      if (!child.isAtom) {
        let inner = findSelectionIn(
          doc,
          child,
          pos + dir,
          dir < 0 ? child.childCount : 0,
          dir,
          text
        );
        if (inner) return inner;
      } else if (!text && NodeSelection.isSelectable(child)) {
        return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));
      }
      pos += child.nodeSize * dir;
    }
    return null;
  }
  function selectionToInsertionEnd(tr, startLen, bias) {
    let last = tr.steps.length - 1;
    if (last < startLen) return;
    let step = tr.steps[last];
    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
      return;
    let map = tr.mapping.maps[last],
      end;
    map.forEach((_from, _to, _newFrom, newTo) => {
      if (end == null) end = newTo;
    });
    tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
  }
  function bind(f, self) {
    return !self || !f ? f : f.bind(self);
  }
  var FieldDesc = class {
    constructor(name, desc, self) {
      this.name = name;
      this.init = bind(desc.init, self);
      this.apply = bind(desc.apply, self);
    }
  };
  var baseFields = [
    new FieldDesc("doc", {
      init(config) {
        return config.doc || config.schema.topNodeType.createAndFill();
      },
      apply(tr) {
        return tr.doc;
      },
    }),
    new FieldDesc("selection", {
      init(config, instance) {
        return config.selection || Selection.atStart(instance.doc);
      },
      apply(tr) {
        return tr.selection;
      },
    }),
    new FieldDesc("storedMarks", {
      init(config) {
        return config.storedMarks || null;
      },
      apply(tr, _marks, _old, state) {
        return state.selection.$cursor ? tr.storedMarks : null;
      },
    }),
    new FieldDesc("scrollToSelection", {
      init() {
        return 0;
      },
      apply(tr, prev) {
        return tr.scrolledIntoView ? prev + 1 : prev;
      },
    }),
  ];
  function bindProps(obj, self, target) {
    for (let prop in obj) {
      let val = obj[prop];
      if (val instanceof Function) val = val.bind(self);
      else if (prop == "handleDOMEvents") val = bindProps(val, self, {});
      target[prop] = val;
    }
    return target;
  }
  var Plugin = class {
    /**
    Create a plugin.
    */
    constructor(spec) {
      this.spec = spec;
      this.props = {};
      if (spec.props) bindProps(spec.props, this, this.props);
      this.key = spec.key ? spec.key.key : createKey("plugin");
    }
    /**
    Extract the plugin's state field from an editor state.
    */
    getState(state) {
      return state[this.key];
    }
  };
  var keys = /* @__PURE__ */ Object.create(null);
  function createKey(name) {
    if (name in keys) return name + "$" + ++keys[name];
    keys[name] = 0;
    return name + "$";
  }
  var PluginKey = class {
    /**
    Create a plugin key.
    */
    constructor(name = "key") {
      this.key = createKey(name);
    }
    /**
    Get the active plugin with this key, if any, from an editor
    state.
    */
    get(state) {
      return state.config.pluginsByKey[this.key];
    }
    /**
    Get the plugin's state from an editor state.
    */
    getState(state) {
      return state[this.key];
    }
  };

  // node_modules/prosemirror-commands/dist/index.js
  var deleteSelection = (state, dispatch) => {
    if (state.selection.empty) return false;
    if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView());
    return true;
  };
  function atBlockStart(state, view) {
    let { $cursor } = state.selection;
    if (
      !$cursor ||
      (view
        ? !view.endOfTextblock("backward", state)
        : $cursor.parentOffset > 0)
    )
      return null;
    return $cursor;
  }
  var joinBackward = (state, dispatch, view) => {
    let $cursor = atBlockStart(state, view);
    if (!$cursor) return false;
    let $cut = findCutBefore($cursor);
    if (!$cut) {
      let range = $cursor.blockRange(),
        target = range && liftTarget(range);
      if (target == null) return false;
      if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    }
    let before = $cut.nodeBefore;
    if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))
      return true;
    if (
      $cursor.parent.content.size == 0 &&
      (textblockAt(before, "end") || NodeSelection.isSelectable(before))
    ) {
      let delStep = replaceStep(
        state.doc,
        $cursor.before(),
        $cursor.after(),
        Slice.empty
      );
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          let tr = state.tr.step(delStep);
          tr.setSelection(
            textblockAt(before, "end")
              ? Selection.findFrom(
                  tr.doc.resolve(tr.mapping.map($cut.pos, -1)),
                  -1
                )
              : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize)
          );
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
    }
    if (before.isAtom && $cut.depth == $cursor.depth - 1) {
      if (dispatch)
        dispatch(
          state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView()
        );
      return true;
    }
    return false;
  };
  function textblockAt(node, side, only = false) {
    for (
      let scan = node;
      scan;
      scan = side == "start" ? scan.firstChild : scan.lastChild
    ) {
      if (scan.isTextblock) return true;
      if (only && scan.childCount != 1) return false;
    }
    return false;
  }
  var selectNodeBackward = (state, dispatch, view) => {
    let { $head, empty } = state.selection,
      $cut = $head;
    if (!empty) return false;
    if ($head.parent.isTextblock) {
      if (
        view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0
      )
        return false;
      $cut = findCutBefore($head);
    }
    let node = $cut && $cut.nodeBefore;
    if (!node || !NodeSelection.isSelectable(node)) return false;
    if (dispatch)
      dispatch(
        state.tr
          .setSelection(
            NodeSelection.create(state.doc, $cut.pos - node.nodeSize)
          )
          .scrollIntoView()
      );
    return true;
  };
  function findCutBefore($pos) {
    if (!$pos.parent.type.spec.isolating)
      for (let i = $pos.depth - 1; i >= 0; i--) {
        if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1));
        if ($pos.node(i).type.spec.isolating) break;
      }
    return null;
  }
  function atBlockEnd(state, view) {
    let { $cursor } = state.selection;
    if (
      !$cursor ||
      (view
        ? !view.endOfTextblock("forward", state)
        : $cursor.parentOffset < $cursor.parent.content.size)
    )
      return null;
    return $cursor;
  }
  var joinForward = (state, dispatch, view) => {
    let $cursor = atBlockEnd(state, view);
    if (!$cursor) return false;
    let $cut = findCutAfter($cursor);
    if (!$cut) return false;
    let after = $cut.nodeAfter;
    if (deleteBarrier(state, $cut, dispatch)) return true;
    if (
      $cursor.parent.content.size == 0 &&
      (textblockAt(after, "start") || NodeSelection.isSelectable(after))
    ) {
      let delStep = replaceStep(
        state.doc,
        $cursor.before(),
        $cursor.after(),
        Slice.empty
      );
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          let tr = state.tr.step(delStep);
          tr.setSelection(
            textblockAt(after, "start")
              ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)
              : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos))
          );
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
    }
    if (after.isAtom && $cut.depth == $cursor.depth - 1) {
      if (dispatch)
        dispatch(
          state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView()
        );
      return true;
    }
    return false;
  };
  var selectNodeForward = (state, dispatch, view) => {
    let { $head, empty } = state.selection,
      $cut = $head;
    if (!empty) return false;
    if ($head.parent.isTextblock) {
      if (
        view
          ? !view.endOfTextblock("forward", state)
          : $head.parentOffset < $head.parent.content.size
      )
        return false;
      $cut = findCutAfter($head);
    }
    let node = $cut && $cut.nodeAfter;
    if (!node || !NodeSelection.isSelectable(node)) return false;
    if (dispatch)
      dispatch(
        state.tr
          .setSelection(NodeSelection.create(state.doc, $cut.pos))
          .scrollIntoView()
      );
    return true;
  };
  function findCutAfter($pos) {
    if (!$pos.parent.type.spec.isolating)
      for (let i = $pos.depth - 1; i >= 0; i--) {
        let parent = $pos.node(i);
        if ($pos.index(i) + 1 < parent.childCount)
          return $pos.doc.resolve($pos.after(i + 1));
        if (parent.type.spec.isolating) break;
      }
    return null;
  }
  var joinUp = (state, dispatch) => {
    let sel = state.selection,
      nodeSel = sel instanceof NodeSelection,
      point;
    if (nodeSel) {
      if (sel.node.isTextblock || !canJoin(state.doc, sel.from)) return false;
      point = sel.from;
    } else {
      point = joinPoint(state.doc, sel.from, -1);
      if (point == null) return false;
    }
    if (dispatch) {
      let tr = state.tr.join(point);
      if (nodeSel)
        tr.setSelection(
          NodeSelection.create(
            tr.doc,
            point - state.doc.resolve(point).nodeBefore.nodeSize
          )
        );
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
  var joinDown = (state, dispatch) => {
    let sel = state.selection,
      point;
    if (sel instanceof NodeSelection) {
      if (sel.node.isTextblock || !canJoin(state.doc, sel.to)) return false;
      point = sel.to;
    } else {
      point = joinPoint(state.doc, sel.to, 1);
      if (point == null) return false;
    }
    if (dispatch) dispatch(state.tr.join(point).scrollIntoView());
    return true;
  };
  var lift = (state, dispatch) => {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to),
      target = range && liftTarget(range);
    if (target == null) return false;
    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  };
  var newlineInCode = (state, dispatch) => {
    let { $head, $anchor } = state.selection;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
      return false;
    if (dispatch) dispatch(state.tr.insertText("\n").scrollIntoView());
    return true;
  };
  function defaultBlockAt(match) {
    for (let i = 0; i < match.edgeCount; i++) {
      let { type } = match.edge(i);
      if (type.isTextblock && !type.hasRequiredAttrs()) return type;
    }
    return null;
  }
  var exitCode = (state, dispatch) => {
    let { $head, $anchor } = state.selection;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
      return false;
    let above = $head.node(-1),
      after = $head.indexAfter(-1),
      type = defaultBlockAt(above.contentMatchAt(after));
    if (!type || !above.canReplaceWith(after, after, type)) return false;
    if (dispatch) {
      let pos = $head.after(),
        tr = state.tr.replaceWith(pos, pos, type.createAndFill());
      tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
  var createParagraphNear = (state, dispatch) => {
    let sel = state.selection,
      { $from, $to } = sel;
    if (
      sel instanceof AllSelection ||
      $from.parent.inlineContent ||
      $to.parent.inlineContent
    )
      return false;
    let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
    if (!type || !type.isTextblock) return false;
    if (dispatch) {
      let side = (
        !$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to
      ).pos;
      let tr = state.tr.insert(side, type.createAndFill());
      tr.setSelection(TextSelection.create(tr.doc, side + 1));
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
  var liftEmptyBlock = (state, dispatch) => {
    let { $cursor } = state.selection;
    if (!$cursor || $cursor.parent.content.size) return false;
    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
      let before = $cursor.before();
      if (canSplit(state.doc, before)) {
        if (dispatch) dispatch(state.tr.split(before).scrollIntoView());
        return true;
      }
    }
    let range = $cursor.blockRange(),
      target = range && liftTarget(range);
    if (target == null) return false;
    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  };
  function splitBlockAs(splitNode) {
    return (state, dispatch) => {
      let { $from, $to } = state.selection;
      if (
        state.selection instanceof NodeSelection &&
        state.selection.node.isBlock
      ) {
        if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
          return false;
        if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView());
        return true;
      }
      if (!$from.parent.isBlock) return false;
      if (dispatch) {
        let atEnd = $to.parentOffset == $to.parent.content.size;
        let tr = state.tr;
        if (
          state.selection instanceof TextSelection ||
          state.selection instanceof AllSelection
        )
          tr.deleteSelection();
        let deflt =
          $from.depth == 0
            ? null
            : defaultBlockAt(
                $from.node(-1).contentMatchAt($from.indexAfter(-1))
              );
        let splitType = splitNode && splitNode($to.parent, atEnd);
        let types = splitType
          ? [splitType]
          : atEnd && deflt
          ? [{ type: deflt }]
          : void 0;
        let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
        if (
          !types &&
          !can &&
          canSplit(
            tr.doc,
            tr.mapping.map($from.pos),
            1,
            deflt ? [{ type: deflt }] : void 0
          )
        ) {
          if (deflt) types = [{ type: deflt }];
          can = true;
        }
        if (can) {
          tr.split(tr.mapping.map($from.pos), 1, types);
          if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {
            let first2 = tr.mapping.map($from.before()),
              $first = tr.doc.resolve(first2);
            if (
              deflt &&
              $from
                .node(-1)
                .canReplaceWith($first.index(), $first.index() + 1, deflt)
            )
              tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
          }
        }
        dispatch(tr.scrollIntoView());
      }
      return true;
    };
  }
  var splitBlock = splitBlockAs();
  var selectParentNode = (state, dispatch) => {
    let { $from, to } = state.selection,
      pos;
    let same = $from.sharedDepth(to);
    if (same == 0) return false;
    pos = $from.before(same);
    if (dispatch)
      dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
    return true;
  };
  var selectAll = (state, dispatch) => {
    if (dispatch) dispatch(state.tr.setSelection(new AllSelection(state.doc)));
    return true;
  };
  function joinMaybeClear(state, $pos, dispatch) {
    let before = $pos.nodeBefore,
      after = $pos.nodeAfter,
      index = $pos.index();
    if (!before || !after || !before.type.compatibleContent(after.type))
      return false;
    if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
      if (dispatch)
        dispatch(
          state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView()
        );
      return true;
    }
    if (
      !$pos.parent.canReplace(index, index + 1) ||
      !(after.isTextblock || canJoin(state.doc, $pos.pos))
    )
      return false;
    if (dispatch)
      dispatch(
        state.tr
          .clearIncompatible(
            $pos.pos,
            before.type,
            before.contentMatchAt(before.childCount)
          )
          .join($pos.pos)
          .scrollIntoView()
      );
    return true;
  }
  function deleteBarrier(state, $cut, dispatch) {
    let before = $cut.nodeBefore,
      after = $cut.nodeAfter,
      conn,
      match;
    if (before.type.spec.isolating || after.type.spec.isolating) return false;
    if (joinMaybeClear(state, $cut, dispatch)) return true;
    let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
    if (
      canDelAfter &&
      (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(
        after.type
      )) &&
      match.matchType(conn[0] || after.type).validEnd
    ) {
      if (dispatch) {
        let end = $cut.pos + after.nodeSize,
          wrap = Fragment.empty;
        for (let i = conn.length - 1; i >= 0; i--)
          wrap = Fragment.from(conn[i].create(null, wrap));
        wrap = Fragment.from(before.copy(wrap));
        let tr = state.tr.step(
          new ReplaceAroundStep(
            $cut.pos - 1,
            end,
            $cut.pos,
            end,
            new Slice(wrap, 1, 0),
            conn.length,
            true
          )
        );
        let joinAt = end + 2 * conn.length;
        if (canJoin(tr.doc, joinAt)) tr.join(joinAt);
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
    let selAfter = Selection.findFrom($cut, 1);
    let range = selAfter && selAfter.$from.blockRange(selAfter.$to),
      target = range && liftTarget(range);
    if (target != null && target >= $cut.depth) {
      if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    }
    if (
      canDelAfter &&
      textblockAt(after, "start", true) &&
      textblockAt(before, "end")
    ) {
      let at = before,
        wrap = [];
      for (;;) {
        wrap.push(at);
        if (at.isTextblock) break;
        at = at.lastChild;
      }
      let afterText = after,
        afterDepth = 1;
      for (; !afterText.isTextblock; afterText = afterText.firstChild)
        afterDepth++;
      if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
        if (dispatch) {
          let end = Fragment.empty;
          for (let i = wrap.length - 1; i >= 0; i--)
            end = Fragment.from(wrap[i].copy(end));
          let tr = state.tr.step(
            new ReplaceAroundStep(
              $cut.pos - wrap.length,
              $cut.pos + after.nodeSize,
              $cut.pos + afterDepth,
              $cut.pos + after.nodeSize - afterDepth,
              new Slice(end, wrap.length, 0),
              0,
              true
            )
          );
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
    }
    return false;
  }
  function selectTextblockSide(side) {
    return function (state, dispatch) {
      let sel = state.selection,
        $pos = side < 0 ? sel.$from : sel.$to;
      let depth = $pos.depth;
      while ($pos.node(depth).isInline) {
        if (!depth) return false;
        depth--;
      }
      if (!$pos.node(depth).isTextblock) return false;
      if (dispatch)
        dispatch(
          state.tr.setSelection(
            TextSelection.create(
              state.doc,
              side < 0 ? $pos.start(depth) : $pos.end(depth)
            )
          )
        );
      return true;
    };
  }
  var selectTextblockStart = selectTextblockSide(-1);
  var selectTextblockEnd = selectTextblockSide(1);
  function wrapIn(nodeType, attrs = null) {
    return function (state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to),
        wrapping = range && findWrapping(range, nodeType, attrs);
      if (!wrapping) return false;
      if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
      return true;
    };
  }
  function setBlockType(nodeType, attrs = null) {
    return function (state, dispatch) {
      let applicable = false;
      for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {
        let {
          $from: { pos: from },
          $to: { pos: to },
        } = state.selection.ranges[i];
        state.doc.nodesBetween(from, to, (node, pos) => {
          if (applicable) return false;
          if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return;
          if (node.type == nodeType) {
            applicable = true;
          } else {
            let $pos = state.doc.resolve(pos),
              index = $pos.index();
            applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
          }
        });
      }
      if (!applicable) return false;
      if (dispatch) {
        let tr = state.tr;
        for (let i = 0; i < state.selection.ranges.length; i++) {
          let {
            $from: { pos: from },
            $to: { pos: to },
          } = state.selection.ranges[i];
          tr.setBlockType(from, to, nodeType, attrs);
        }
        dispatch(tr.scrollIntoView());
      }
      return true;
    };
  }
  function chainCommands(...commands2) {
    return function (state, dispatch, view) {
      for (let i = 0; i < commands2.length; i++)
        if (commands2[i](state, dispatch, view)) return true;
      return false;
    };
  }
  var backspace = chainCommands(
    deleteSelection,
    joinBackward,
    selectNodeBackward
  );
  var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
  var pcBaseKeymap = {
    Enter: chainCommands(
      newlineInCode,
      createParagraphNear,
      liftEmptyBlock,
      splitBlock
    ),
    "Mod-Enter": exitCode,
    Backspace: backspace,
    "Mod-Backspace": backspace,
    "Shift-Backspace": backspace,
    Delete: del,
    "Mod-Delete": del,
    "Mod-a": selectAll,
  };
  var macBaseKeymap = {
    "Ctrl-h": pcBaseKeymap["Backspace"],
    "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
    "Ctrl-d": pcBaseKeymap["Delete"],
    "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
    "Alt-Delete": pcBaseKeymap["Mod-Delete"],
    "Alt-d": pcBaseKeymap["Mod-Delete"],
    "Ctrl-a": selectTextblockStart,
    "Ctrl-e": selectTextblockEnd,
  };
  for (let key in pcBaseKeymap) macBaseKeymap[key] = pcBaseKeymap[key];
  var mac =
    typeof navigator != "undefined"
      ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
      : typeof os != "undefined" && os.platform
      ? os.platform() == "darwin"
      : false;

  // node_modules/prosemirror-schema-list/dist/index.js
  function wrapInList(listType, attrs = null) {
    return function (state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to),
        doJoin = false,
        outerRange = range;
      if (!range) return false;
      if (
        range.depth >= 2 &&
        $from.node(range.depth - 1).type.compatibleContent(listType) &&
        range.startIndex == 0
      ) {
        if ($from.index(range.depth - 1) == 0) return false;
        let $insert = state.doc.resolve(range.start - 2);
        outerRange = new NodeRange($insert, $insert, range.depth);
        if (range.endIndex < range.parent.childCount)
          range = new NodeRange(
            $from,
            state.doc.resolve($to.end(range.depth)),
            range.depth
          );
        doJoin = true;
      }
      let wrap = findWrapping(outerRange, listType, attrs, range);
      if (!wrap) return false;
      if (dispatch)
        dispatch(
          doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView()
        );
      return true;
    };
  }
  function doWrapInList(tr, range, wrappers, joinBefore, listType) {
    let content = Fragment.empty;
    for (let i = wrappers.length - 1; i >= 0; i--)
      content = Fragment.from(
        wrappers[i].type.create(wrappers[i].attrs, content)
      );
    tr.step(
      new ReplaceAroundStep(
        range.start - (joinBefore ? 2 : 0),
        range.end,
        range.start,
        range.end,
        new Slice(content, 0, 0),
        wrappers.length,
        true
      )
    );
    let found2 = 0;
    for (let i = 0; i < wrappers.length; i++)
      if (wrappers[i].type == listType) found2 = i + 1;
    let splitDepth = wrappers.length - found2;
    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0),
      parent = range.parent;
    for (
      let i = range.startIndex, e = range.endIndex, first2 = true;
      i < e;
      i++, first2 = false
    ) {
      if (!first2 && canSplit(tr.doc, splitPos, splitDepth)) {
        tr.split(splitPos, splitDepth);
        splitPos += 2 * splitDepth;
      }
      splitPos += parent.child(i).nodeSize;
    }
    return tr;
  }
  function liftListItem(itemType) {
    return function (state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange(
        $to,
        (node) => node.childCount > 0 && node.firstChild.type == itemType
      );
      if (!range) return false;
      if (!dispatch) return true;
      if ($from.node(range.depth - 1).type == itemType)
        return liftToOuterList(state, dispatch, itemType, range);
      else return liftOutOfList(state, dispatch, range);
    };
  }
  function liftToOuterList(state, dispatch, itemType, range) {
    let tr = state.tr,
      end = range.end,
      endOfList = range.$to.end(range.depth);
    if (end < endOfList) {
      tr.step(
        new ReplaceAroundStep(
          end - 1,
          endOfList,
          end,
          endOfList,
          new Slice(
            Fragment.from(itemType.create(null, range.parent.copy())),
            1,
            0
          ),
          1,
          true
        )
      );
      range = new NodeRange(
        tr.doc.resolve(range.$from.pos),
        tr.doc.resolve(endOfList),
        range.depth
      );
    }
    const target = liftTarget(range);
    if (target == null) return false;
    tr.lift(range, target);
    let after = tr.mapping.map(end, -1) - 1;
    if (canJoin(tr.doc, after)) tr.join(after);
    dispatch(tr.scrollIntoView());
    return true;
  }
  function liftOutOfList(state, dispatch, range) {
    let tr = state.tr,
      list = range.parent;
    for (
      let pos = range.end, i = range.endIndex - 1, e = range.startIndex;
      i > e;
      i--
    ) {
      pos -= list.child(i).nodeSize;
      tr.delete(pos - 1, pos + 1);
    }
    let $start = tr.doc.resolve(range.start),
      item = $start.nodeAfter;
    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
      return false;
    let atStart = range.startIndex == 0,
      atEnd = range.endIndex == list.childCount;
    let parent = $start.node(-1),
      indexBefore = $start.index(-1);
    if (
      !parent.canReplace(
        indexBefore + (atStart ? 0 : 1),
        indexBefore + 1,
        item.content.append(atEnd ? Fragment.empty : Fragment.from(list))
      )
    )
      return false;
    let start = $start.pos,
      end = start + item.nodeSize;
    tr.step(
      new ReplaceAroundStep(
        start - (atStart ? 1 : 0),
        end + (atEnd ? 1 : 0),
        start + 1,
        end - 1,
        new Slice(
          (atStart
            ? Fragment.empty
            : Fragment.from(list.copy(Fragment.empty))
          ).append(
            atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))
          ),
          atStart ? 0 : 1,
          atEnd ? 0 : 1
        ),
        atStart ? 0 : 1
      )
    );
    dispatch(tr.scrollIntoView());
    return true;
  }
  function sinkListItem(itemType) {
    return function (state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange(
        $to,
        (node) => node.childCount > 0 && node.firstChild.type == itemType
      );
      if (!range) return false;
      let startIndex = range.startIndex;
      if (startIndex == 0) return false;
      let parent = range.parent,
        nodeBefore = parent.child(startIndex - 1);
      if (nodeBefore.type != itemType) return false;
      if (dispatch) {
        let nestedBefore =
          nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
        let inner = Fragment.from(nestedBefore ? itemType.create() : null);
        let slice = new Slice(
          Fragment.from(
            itemType.create(
              null,
              Fragment.from(parent.type.create(null, inner))
            )
          ),
          nestedBefore ? 3 : 1,
          0
        );
        let before = range.start,
          after = range.end;
        dispatch(
          state.tr
            .step(
              new ReplaceAroundStep(
                before - (nestedBefore ? 3 : 1),
                after,
                before,
                after,
                slice,
                1,
                true
              )
            )
            .scrollIntoView()
        );
      }
      return true;
    };
  }

  // node_modules/@tiptap/core/dist/index.js
  function createChainableState(config) {
    const { state, transaction } = config;
    let { selection } = transaction;
    let { doc } = transaction;
    let { storedMarks } = transaction;
    return {
      ...state,
      apply: state.apply.bind(state),
      applyTransaction: state.applyTransaction.bind(state),
      filterTransaction: state.filterTransaction,
      plugins: state.plugins,
      schema: state.schema,
      reconfigure: state.reconfigure.bind(state),
      toJSON: state.toJSON.bind(state),
      get storedMarks() {
        return storedMarks;
      },
      get selection() {
        return selection;
      },
      get doc() {
        return doc;
      },
      get tr() {
        selection = transaction.selection;
        doc = transaction.doc;
        storedMarks = transaction.storedMarks;
        return transaction;
      },
    };
  }
  var CommandManager = class {
    constructor(props) {
      this.editor = props.editor;
      this.rawCommands = this.editor.extensionManager.commands;
      this.customState = props.state;
    }
    get hasCustomState() {
      return !!this.customState;
    }
    get state() {
      return this.customState || this.editor.state;
    }
    get commands() {
      const { rawCommands, editor, state } = this;
      const { view } = editor;
      const { tr } = state;
      const props = this.buildProps(tr);
      return Object.fromEntries(
        Object.entries(rawCommands).map(([name, command2]) => {
          const method = (...args) => {
            const callback = command2(...args)(props);
            if (!tr.getMeta("preventDispatch") && !this.hasCustomState) {
              view.dispatch(tr);
            }
            return callback;
          };
          return [name, method];
        })
      );
    }
    get chain() {
      return () => this.createChain();
    }
    get can() {
      return () => this.createCan();
    }
    createChain(startTr, shouldDispatch = true) {
      const { rawCommands, editor, state } = this;
      const { view } = editor;
      const callbacks = [];
      const hasStartTransaction = !!startTr;
      const tr = startTr || state.tr;
      const run = () => {
        if (
          !hasStartTransaction &&
          shouldDispatch &&
          !tr.getMeta("preventDispatch") &&
          !this.hasCustomState
        ) {
          view.dispatch(tr);
        }
        return callbacks.every((callback) => callback === true);
      };
      const chain = {
        ...Object.fromEntries(
          Object.entries(rawCommands).map(([name, command2]) => {
            const chainedCommand = (...args) => {
              const props = this.buildProps(tr, shouldDispatch);
              const callback = command2(...args)(props);
              callbacks.push(callback);
              return chain;
            };
            return [name, chainedCommand];
          })
        ),
        run,
      };
      return chain;
    }
    createCan(startTr) {
      const { rawCommands, state } = this;
      const dispatch = false;
      const tr = startTr || state.tr;
      const props = this.buildProps(tr, dispatch);
      const formattedCommands = Object.fromEntries(
        Object.entries(rawCommands).map(([name, command2]) => {
          return [
            name,
            (...args) => command2(...args)({ ...props, dispatch: void 0 }),
          ];
        })
      );
      return {
        ...formattedCommands,
        chain: () => this.createChain(tr, dispatch),
      };
    }
    buildProps(tr, shouldDispatch = true) {
      const { rawCommands, editor, state } = this;
      const { view } = editor;
      const props = {
        tr,
        editor,
        view,
        state: createChainableState({
          state,
          transaction: tr,
        }),
        dispatch: shouldDispatch ? () => void 0 : void 0,
        chain: () => this.createChain(tr, shouldDispatch),
        can: () => this.createCan(tr),
        get commands() {
          return Object.fromEntries(
            Object.entries(rawCommands).map(([name, command2]) => {
              return [name, (...args) => command2(...args)(props)];
            })
          );
        },
      };
      return props;
    }
  };
  function getExtensionField(extension, field, context) {
    if (extension.config[field] === void 0 && extension.parent) {
      return getExtensionField(extension.parent, field, context);
    }
    if (typeof extension.config[field] === "function") {
      const value = extension.config[field].bind({
        ...context,
        parent: extension.parent
          ? getExtensionField(extension.parent, field, context)
          : null,
      });
      return value;
    }
    return extension.config[field];
  }
  function splitExtensions(extensions) {
    const baseExtensions = extensions.filter(
      (extension) => extension.type === "extension"
    );
    const nodeExtensions = extensions.filter(
      (extension) => extension.type === "node"
    );
    const markExtensions = extensions.filter(
      (extension) => extension.type === "mark"
    );
    return {
      baseExtensions,
      nodeExtensions,
      markExtensions,
    };
  }
  function getNodeType(nameOrType, schema) {
    if (typeof nameOrType === "string") {
      if (!schema.nodes[nameOrType]) {
        throw Error(
          `There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`
        );
      }
      return schema.nodes[nameOrType];
    }
    return nameOrType;
  }
  function mergeAttributes(...objects) {
    return objects
      .filter((item) => !!item)
      .reduce((items, item) => {
        const mergedAttributes = { ...items };
        Object.entries(item).forEach(([key, value]) => {
          const exists = mergedAttributes[key];
          if (!exists) {
            mergedAttributes[key] = value;
            return;
          }
          if (key === "class") {
            const valueClasses = value ? value.split(" ") : [];
            const existingClasses = mergedAttributes[key]
              ? mergedAttributes[key].split(" ")
              : [];
            const insertClasses = valueClasses.filter(
              (valueClass) => !existingClasses.includes(valueClass)
            );
            mergedAttributes[key] = [...existingClasses, ...insertClasses].join(
              " "
            );
          } else if (key === "style") {
            mergedAttributes[key] = [mergedAttributes[key], value].join("; ");
          } else {
            mergedAttributes[key] = value;
          }
        });
        return mergedAttributes;
      }, {});
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function callOrReturn(value, context = void 0, ...props) {
    if (isFunction(value)) {
      if (context) {
        return value.bind(context)(...props);
      }
      return value(...props);
    }
    return value;
  }
  function isRegExp(value) {
    return Object.prototype.toString.call(value) === "[object RegExp]";
  }
  var PasteRule = class {
    constructor(config) {
      this.find = config.find;
      this.handler = config.handler;
    }
  };
  function getType(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
  }
  function isPlainObject(value) {
    if (getType(value) !== "Object") {
      return false;
    }
    return (
      value.constructor === Object &&
      Object.getPrototypeOf(value) === Object.prototype
    );
  }
  function mergeDeep(target, source) {
    const output = { ...target };
    if (isPlainObject(target) && isPlainObject(source)) {
      Object.keys(source).forEach((key) => {
        if (isPlainObject(source[key])) {
          if (!(key in target)) {
            Object.assign(output, { [key]: source[key] });
          } else {
            output[key] = mergeDeep(target[key], source[key]);
          }
        } else {
          Object.assign(output, { [key]: source[key] });
        }
      });
    }
    return output;
  }
  var Extension = class _Extension {
    constructor(config = {}) {
      this.type = "extension";
      this.name = "extension";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {},
      };
      this.config = {
        ...this.config,
        ...config,
      };
      this.name = this.config.name;
      if (config.defaultOptions) {
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
        );
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(
          getExtensionField(this, "addOptions", {
            name: this.name,
          })
        );
      }
      this.storage =
        callOrReturn(
          getExtensionField(this, "addStorage", {
            name: this.name,
            options: this.options,
          })
        ) || {};
    }
    static create(config = {}) {
      return new _Extension(config);
    }
    configure(options = {}) {
      const extension = this.extend();
      extension.options = mergeDeep(this.options, options);
      extension.storage = callOrReturn(
        getExtensionField(extension, "addStorage", {
          name: extension.name,
          options: extension.options,
        })
      );
      return extension;
    }
    extend(extendedConfig = {}) {
      const extension = new _Extension(extendedConfig);
      extension.parent = this;
      this.child = extension;
      extension.name = extendedConfig.name
        ? extendedConfig.name
        : extension.parent.name;
      if (extendedConfig.defaultOptions) {
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`
        );
      }
      extension.options = callOrReturn(
        getExtensionField(extension, "addOptions", {
          name: extension.name,
        })
      );
      extension.storage = callOrReturn(
        getExtensionField(extension, "addStorage", {
          name: extension.name,
          options: extension.options,
        })
      );
      return extension;
    }
  };
  function getTextBetween(startNode, range, options) {
    const { from, to } = range;
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    let text = "";
    let separated = true;
    startNode.nodesBetween(from, to, (node, pos, parent, index) => {
      var _a;
      const textSerializer =
        textSerializers === null || textSerializers === void 0
          ? void 0
          : textSerializers[node.type.name];
      if (textSerializer) {
        if (node.isBlock && !separated) {
          text += blockSeparator;
          separated = true;
        }
        if (parent) {
          text += textSerializer({
            node,
            pos,
            parent,
            index,
            range,
          });
        }
      } else if (node.isText) {
        text +=
          (_a = node === null || node === void 0 ? void 0 : node.text) ===
            null || _a === void 0
            ? void 0
            : _a.slice(Math.max(from, pos) - pos, to - pos);
        separated = false;
      } else if (node.isBlock && !separated) {
        text += blockSeparator;
        separated = true;
      }
    });
    return text;
  }
  function getTextSerializersFromSchema(schema) {
    return Object.fromEntries(
      Object.entries(schema.nodes)
        .filter(([, node]) => node.spec.toText)
        .map(([name, node]) => [name, node.spec.toText])
    );
  }
  var ClipboardTextSerializer = Extension.create({
    name: "clipboardTextSerializer",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("clipboardTextSerializer"),
          props: {
            clipboardTextSerializer: () => {
              const { editor } = this;
              const { state, schema } = editor;
              const { doc, selection } = state;
              const { ranges } = selection;
              const from = Math.min(
                ...ranges.map((range2) => range2.$from.pos)
              );
              const to = Math.max(...ranges.map((range2) => range2.$to.pos));
              const textSerializers = getTextSerializersFromSchema(schema);
              const range = { from, to };
              return getTextBetween(doc, range, {
                textSerializers,
              });
            },
          },
        }),
      ];
    },
  });
  var blur =
    () =>
    ({ editor, view }) => {
      requestAnimationFrame(() => {
        var _a;
        if (!editor.isDestroyed) {
          view.dom.blur();
          (_a =
            window === null || window === void 0
              ? void 0
              : window.getSelection()) === null || _a === void 0
            ? void 0
            : _a.removeAllRanges();
        }
      });
      return true;
    };
  var clearContent =
    (emitUpdate = false) =>
    ({ commands: commands2 }) => {
      return commands2.setContent("", emitUpdate);
    };
  var clearNodes =
    () =>
    ({ state, tr, dispatch }) => {
      const { selection } = tr;
      const { ranges } = selection;
      if (!dispatch) {
        return true;
      }
      ranges.forEach(({ $from, $to }) => {
        state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
          if (node.type.isText) {
            return;
          }
          const { doc, mapping } = tr;
          const $mappedFrom = doc.resolve(mapping.map(pos));
          const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));
          const nodeRange = $mappedFrom.blockRange($mappedTo);
          if (!nodeRange) {
            return;
          }
          const targetLiftDepth = liftTarget(nodeRange);
          if (node.type.isTextblock) {
            const { defaultType } = $mappedFrom.parent.contentMatchAt(
              $mappedFrom.index()
            );
            tr.setNodeMarkup(nodeRange.start, defaultType);
          }
          if (targetLiftDepth || targetLiftDepth === 0) {
            tr.lift(nodeRange, targetLiftDepth);
          }
        });
      });
      return true;
    };
  var command = (fn) => (props) => {
    return fn(props);
  };
  var createParagraphNear2 =
    () =>
    ({ state, dispatch }) => {
      return createParagraphNear(state, dispatch);
    };
  var cut =
    (originRange, targetPos) =>
    ({ editor, tr }) => {
      const { state } = editor;
      const contentSlice = state.doc.slice(originRange.from, originRange.to);
      tr.deleteRange(originRange.from, originRange.to);
      const newPos = tr.mapping.map(targetPos);
      tr.insert(newPos, contentSlice.content);
      tr.setSelection(new TextSelection(tr.doc.resolve(newPos - 1)));
      return true;
    };
  var deleteCurrentNode =
    () =>
    ({ tr, dispatch }) => {
      const { selection } = tr;
      const currentNode = selection.$anchor.node();
      if (currentNode.content.size > 0) {
        return false;
      }
      const $pos = tr.selection.$anchor;
      for (let depth = $pos.depth; depth > 0; depth -= 1) {
        const node = $pos.node(depth);
        if (node.type === currentNode.type) {
          if (dispatch) {
            const from = $pos.before(depth);
            const to = $pos.after(depth);
            tr.delete(from, to).scrollIntoView();
          }
          return true;
        }
      }
      return false;
    };
  var deleteNode =
    (typeOrName) =>
    ({ tr, state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      const $pos = tr.selection.$anchor;
      for (let depth = $pos.depth; depth > 0; depth -= 1) {
        const node = $pos.node(depth);
        if (node.type === type) {
          if (dispatch) {
            const from = $pos.before(depth);
            const to = $pos.after(depth);
            tr.delete(from, to).scrollIntoView();
          }
          return true;
        }
      }
      return false;
    };
  var deleteRange =
    (range) =>
    ({ tr, dispatch }) => {
      const { from, to } = range;
      if (dispatch) {
        tr.delete(from, to);
      }
      return true;
    };
  var deleteSelection2 =
    () =>
    ({ state, dispatch }) => {
      return deleteSelection(state, dispatch);
    };
  var enter =
    () =>
    ({ commands: commands2 }) => {
      return commands2.keyboardShortcut("Enter");
    };
  var exitCode2 =
    () =>
    ({ state, dispatch }) => {
      return exitCode(state, dispatch);
    };
  function objectIncludes(object1, object2, options = { strict: true }) {
    const keys2 = Object.keys(object2);
    if (!keys2.length) {
      return true;
    }
    return keys2.every((key) => {
      if (options.strict) {
        return object2[key] === object1[key];
      }
      if (isRegExp(object2[key])) {
        return object2[key].test(object1[key]);
      }
      return object2[key] === object1[key];
    });
  }
  function findMarkInSet(marks, type, attributes = {}) {
    return marks.find((item) => {
      return item.type === type && objectIncludes(item.attrs, attributes);
    });
  }
  function isMarkInSet(marks, type, attributes = {}) {
    return !!findMarkInSet(marks, type, attributes);
  }
  function getMarkRange($pos, type, attributes = {}) {
    if (!$pos || !type) {
      return;
    }
    let start = $pos.parent.childAfter($pos.parentOffset);
    if ($pos.parentOffset === start.offset && start.offset !== 0) {
      start = $pos.parent.childBefore($pos.parentOffset);
    }
    if (!start.node) {
      return;
    }
    const mark = findMarkInSet([...start.node.marks], type, attributes);
    if (!mark) {
      return;
    }
    let startIndex = start.index;
    let startPos = $pos.start() + start.offset;
    let endIndex = startIndex + 1;
    let endPos = startPos + start.node.nodeSize;
    findMarkInSet([...start.node.marks], type, attributes);
    while (
      startIndex > 0 &&
      mark.isInSet($pos.parent.child(startIndex - 1).marks)
    ) {
      startIndex -= 1;
      startPos -= $pos.parent.child(startIndex).nodeSize;
    }
    while (
      endIndex < $pos.parent.childCount &&
      isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)
    ) {
      endPos += $pos.parent.child(endIndex).nodeSize;
      endIndex += 1;
    }
    return {
      from: startPos,
      to: endPos,
    };
  }
  function getMarkType(nameOrType, schema) {
    if (typeof nameOrType === "string") {
      if (!schema.marks[nameOrType]) {
        throw Error(
          `There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`
        );
      }
      return schema.marks[nameOrType];
    }
    return nameOrType;
  }
  var extendMarkRange =
    (typeOrName, attributes = {}) =>
    ({ tr, state, dispatch }) => {
      const type = getMarkType(typeOrName, state.schema);
      const { doc, selection } = tr;
      const { $from, from, to } = selection;
      if (dispatch) {
        const range = getMarkRange($from, type, attributes);
        if (range && range.from <= from && range.to >= to) {
          const newSelection = TextSelection.create(doc, range.from, range.to);
          tr.setSelection(newSelection);
        }
      }
      return true;
    };
  var first = (commands2) => (props) => {
    const items =
      typeof commands2 === "function" ? commands2(props) : commands2;
    for (let i = 0; i < items.length; i += 1) {
      if (items[i](props)) {
        return true;
      }
    }
    return false;
  };
  function isTextSelection(value) {
    return value instanceof TextSelection;
  }
  function minMax(value = 0, min = 0, max = 0) {
    return Math.min(Math.max(value, min), max);
  }
  function resolveFocusPosition(doc, position = null) {
    if (!position) {
      return null;
    }
    const selectionAtStart = Selection.atStart(doc);
    const selectionAtEnd = Selection.atEnd(doc);
    if (position === "start" || position === true) {
      return selectionAtStart;
    }
    if (position === "end") {
      return selectionAtEnd;
    }
    const minPos = selectionAtStart.from;
    const maxPos = selectionAtEnd.to;
    if (position === "all") {
      return TextSelection.create(
        doc,
        minMax(0, minPos, maxPos),
        minMax(doc.content.size, minPos, maxPos)
      );
    }
    return TextSelection.create(
      doc,
      minMax(position, minPos, maxPos),
      minMax(position, minPos, maxPos)
    );
  }
  function isiOS() {
    return (
      [
        "iPad Simulator",
        "iPhone Simulator",
        "iPod Simulator",
        "iPad",
        "iPhone",
        "iPod",
      ].includes(navigator.platform) ||
      (navigator.userAgent.includes("Mac") && "ontouchend" in document)
    );
  }
  var focus =
    (position = null, options = {}) =>
    ({ editor, view, tr, dispatch }) => {
      options = {
        scrollIntoView: true,
        ...options,
      };
      const delayedFocus = () => {
        if (isiOS()) {
          view.dom.focus();
        }
        requestAnimationFrame(() => {
          if (!editor.isDestroyed) {
            view.focus();
            if (
              options === null || options === void 0
                ? void 0
                : options.scrollIntoView
            ) {
              editor.commands.scrollIntoView();
            }
          }
        });
      };
      if ((view.hasFocus() && position === null) || position === false) {
        return true;
      }
      if (
        dispatch &&
        position === null &&
        !isTextSelection(editor.state.selection)
      ) {
        delayedFocus();
        return true;
      }
      const selection =
        resolveFocusPosition(tr.doc, position) || editor.state.selection;
      const isSameSelection = editor.state.selection.eq(selection);
      if (dispatch) {
        if (!isSameSelection) {
          tr.setSelection(selection);
        }
        if (isSameSelection && tr.storedMarks) {
          tr.setStoredMarks(tr.storedMarks);
        }
        delayedFocus();
      }
      return true;
    };
  var forEach = (items, fn) => (props) => {
    return items.every((item, index) => fn(item, { ...props, index }));
  };
  var insertContent =
    (value, options) =>
    ({ tr, commands: commands2 }) => {
      return commands2.insertContentAt(
        { from: tr.selection.from, to: tr.selection.to },
        value,
        options
      );
    };
  function elementFromString(value) {
    const wrappedValue = `<body>${value}</body>`;
    return new window.DOMParser().parseFromString(wrappedValue, "text/html")
      .body;
  }
  function createNodeFromContent(content, schema, options) {
    options = {
      slice: true,
      parseOptions: {},
      ...options,
    };
    if (typeof content === "object" && content !== null) {
      try {
        if (Array.isArray(content) && content.length > 0) {
          return Fragment.fromArray(
            content.map((item) => schema.nodeFromJSON(item))
          );
        }
        return schema.nodeFromJSON(content);
      } catch (error) {
        console.warn(
          "[tiptap warn]: Invalid content.",
          "Passed value:",
          content,
          "Error:",
          error
        );
        return createNodeFromContent("", schema, options);
      }
    }
    if (typeof content === "string") {
      const parser = DOMParser.fromSchema(schema);
      return options.slice
        ? parser.parseSlice(elementFromString(content), options.parseOptions)
            .content
        : parser.parse(elementFromString(content), options.parseOptions);
    }
    return createNodeFromContent("", schema, options);
  }
  function selectionToInsertionEnd2(tr, startLen, bias) {
    const last = tr.steps.length - 1;
    if (last < startLen) {
      return;
    }
    const step = tr.steps[last];
    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
      return;
    }
    const map = tr.mapping.maps[last];
    let end = 0;
    map.forEach((_from, _to, _newFrom, newTo) => {
      if (end === 0) {
        end = newTo;
      }
    });
    tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
  }
  var isFragment = (nodeOrFragment) => {
    return nodeOrFragment.toString().startsWith("<");
  };
  var insertContentAt =
    (position, value, options) =>
    ({ tr, dispatch, editor }) => {
      if (dispatch) {
        options = {
          parseOptions: {},
          updateSelection: true,
          ...options,
        };
        const content = createNodeFromContent(value, editor.schema, {
          parseOptions: {
            preserveWhitespace: "full",
            ...options.parseOptions,
          },
        });
        if (content.toString() === "<>") {
          return true;
        }
        let { from, to } =
          typeof position === "number"
            ? { from: position, to: position }
            : { from: position.from, to: position.to };
        let isOnlyTextContent = true;
        let isOnlyBlockContent = true;
        const nodes = isFragment(content) ? content : [content];
        nodes.forEach((node) => {
          node.check();
          isOnlyTextContent = isOnlyTextContent
            ? node.isText && node.marks.length === 0
            : false;
          isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
        });
        if (from === to && isOnlyBlockContent) {
          const { parent } = tr.doc.resolve(from);
          const isEmptyTextBlock =
            parent.isTextblock && !parent.type.spec.code && !parent.childCount;
          if (isEmptyTextBlock) {
            from -= 1;
            to += 1;
          }
        }
        if (isOnlyTextContent) {
          if (Array.isArray(value)) {
            tr.insertText(value.map((v) => v.text || "").join(""), from, to);
          } else if (typeof value === "object" && !!value && !!value.text) {
            tr.insertText(value.text, from, to);
          } else {
            tr.insertText(value, from, to);
          }
        } else {
          tr.replaceWith(from, to, content);
        }
        if (options.updateSelection) {
          selectionToInsertionEnd2(tr, tr.steps.length - 1, -1);
        }
      }
      return true;
    };
  var joinUp2 =
    () =>
    ({ state, dispatch }) => {
      return joinUp(state, dispatch);
    };
  var joinDown2 =
    () =>
    ({ state, dispatch }) => {
      return joinDown(state, dispatch);
    };
  var joinBackward2 =
    () =>
    ({ state, dispatch }) => {
      return joinBackward(state, dispatch);
    };
  var joinForward2 =
    () =>
    ({ state, dispatch }) => {
      return joinForward(state, dispatch);
    };
  var joinItemBackward =
    () =>
    ({ tr, state, dispatch }) => {
      try {
        const point = joinPoint(state.doc, state.selection.$from.pos, -1);
        if (point === null || point === void 0) {
          return false;
        }
        tr.join(point, 2);
        if (dispatch) {
          dispatch(tr);
        }
        return true;
      } catch {
        return false;
      }
    };
  var joinItemForward =
    () =>
    ({ state, dispatch, tr }) => {
      try {
        const point = joinPoint(state.doc, state.selection.$from.pos, 1);
        if (point === null || point === void 0) {
          return false;
        }
        tr.join(point, 2);
        if (dispatch) {
          dispatch(tr);
        }
        return true;
      } catch (e) {
        return false;
      }
    };
  function isMacOS() {
    return typeof navigator !== "undefined"
      ? /Mac/.test(navigator.platform)
      : false;
  }
  function normalizeKeyName(name) {
    const parts = name.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result === "Space") {
      result = " ";
    }
    let alt;
    let ctrl;
    let shift;
    let meta;
    for (let i = 0; i < parts.length - 1; i += 1) {
      const mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) {
        meta = true;
      } else if (/^a(lt)?$/i.test(mod)) {
        alt = true;
      } else if (/^(c|ctrl|control)$/i.test(mod)) {
        ctrl = true;
      } else if (/^s(hift)?$/i.test(mod)) {
        shift = true;
      } else if (/^mod$/i.test(mod)) {
        if (isiOS() || isMacOS()) {
          meta = true;
        } else {
          ctrl = true;
        }
      } else {
        throw new Error(`Unrecognized modifier name: ${mod}`);
      }
    }
    if (alt) {
      result = `Alt-${result}`;
    }
    if (ctrl) {
      result = `Ctrl-${result}`;
    }
    if (meta) {
      result = `Meta-${result}`;
    }
    if (shift) {
      result = `Shift-${result}`;
    }
    return result;
  }
  var keyboardShortcut =
    (name) =>
    ({ editor, view, tr, dispatch }) => {
      const keys2 = normalizeKeyName(name).split(/-(?!$)/);
      const key = keys2.find(
        (item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item)
      );
      const event = new KeyboardEvent("keydown", {
        key: key === "Space" ? " " : key,
        altKey: keys2.includes("Alt"),
        ctrlKey: keys2.includes("Ctrl"),
        metaKey: keys2.includes("Meta"),
        shiftKey: keys2.includes("Shift"),
        bubbles: true,
        cancelable: true,
      });
      const capturedTransaction = editor.captureTransaction(() => {
        view.someProp("handleKeyDown", (f) => f(view, event));
      });
      capturedTransaction === null || capturedTransaction === void 0
        ? void 0
        : capturedTransaction.steps.forEach((step) => {
            const newStep = step.map(tr.mapping);
            if (newStep && dispatch) {
              tr.maybeStep(newStep);
            }
          });
      return true;
    };
  function isNodeActive(state, typeOrName, attributes = {}) {
    const { from, to, empty } = state.selection;
    const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
    const nodeRanges = [];
    state.doc.nodesBetween(from, to, (node, pos) => {
      if (node.isText) {
        return;
      }
      const relativeFrom = Math.max(from, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      nodeRanges.push({
        node,
        from: relativeFrom,
        to: relativeTo,
      });
    });
    const selectionRange = to - from;
    const matchedNodeRanges = nodeRanges
      .filter((nodeRange) => {
        if (!type) {
          return true;
        }
        return type.name === nodeRange.node.type.name;
      })
      .filter((nodeRange) =>
        objectIncludes(nodeRange.node.attrs, attributes, { strict: false })
      );
    if (empty) {
      return !!matchedNodeRanges.length;
    }
    const range = matchedNodeRanges.reduce(
      (sum, nodeRange) => sum + nodeRange.to - nodeRange.from,
      0
    );
    return range >= selectionRange;
  }
  var lift2 =
    (typeOrName, attributes = {}) =>
    ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      const isActive = isNodeActive(state, type, attributes);
      if (!isActive) {
        return false;
      }
      return lift(state, dispatch);
    };
  var liftEmptyBlock2 =
    () =>
    ({ state, dispatch }) => {
      return liftEmptyBlock(state, dispatch);
    };
  var liftListItem2 =
    (typeOrName) =>
    ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return liftListItem(type)(state, dispatch);
    };
  var newlineInCode2 =
    () =>
    ({ state, dispatch }) => {
      return newlineInCode(state, dispatch);
    };
  function getSchemaTypeNameByName(name, schema) {
    if (schema.nodes[name]) {
      return "node";
    }
    if (schema.marks[name]) {
      return "mark";
    }
    return null;
  }
  function deleteProps(obj, propOrProps) {
    const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
    return Object.keys(obj).reduce((newObj, prop) => {
      if (!props.includes(prop)) {
        newObj[prop] = obj[prop];
      }
      return newObj;
    }, {});
  }
  var resetAttributes =
    (typeOrName, attributes) =>
    ({ tr, state, dispatch }) => {
      let nodeType = null;
      let markType = null;
      const schemaType = getSchemaTypeNameByName(
        typeof typeOrName === "string" ? typeOrName : typeOrName.name,
        state.schema
      );
      if (!schemaType) {
        return false;
      }
      if (schemaType === "node") {
        nodeType = getNodeType(typeOrName, state.schema);
      }
      if (schemaType === "mark") {
        markType = getMarkType(typeOrName, state.schema);
      }
      if (dispatch) {
        tr.selection.ranges.forEach((range) => {
          state.doc.nodesBetween(
            range.$from.pos,
            range.$to.pos,
            (node, pos) => {
              if (nodeType && nodeType === node.type) {
                tr.setNodeMarkup(
                  pos,
                  void 0,
                  deleteProps(node.attrs, attributes)
                );
              }
              if (markType && node.marks.length) {
                node.marks.forEach((mark) => {
                  if (markType === mark.type) {
                    tr.addMark(
                      pos,
                      pos + node.nodeSize,
                      markType.create(deleteProps(mark.attrs, attributes))
                    );
                  }
                });
              }
            }
          );
        });
      }
      return true;
    };
  var scrollIntoView =
    () =>
    ({ tr, dispatch }) => {
      if (dispatch) {
        tr.scrollIntoView();
      }
      return true;
    };
  var selectAll2 =
    () =>
    ({ tr, commands: commands2 }) => {
      return commands2.setTextSelection({
        from: 0,
        to: tr.doc.content.size,
      });
    };
  var selectNodeBackward2 =
    () =>
    ({ state, dispatch }) => {
      return selectNodeBackward(state, dispatch);
    };
  var selectNodeForward2 =
    () =>
    ({ state, dispatch }) => {
      return selectNodeForward(state, dispatch);
    };
  var selectParentNode2 =
    () =>
    ({ state, dispatch }) => {
      return selectParentNode(state, dispatch);
    };
  var selectTextblockEnd2 =
    () =>
    ({ state, dispatch }) => {
      return selectTextblockEnd(state, dispatch);
    };
  var selectTextblockStart2 =
    () =>
    ({ state, dispatch }) => {
      return selectTextblockStart(state, dispatch);
    };
  function createDocument(content, schema, parseOptions = {}) {
    return createNodeFromContent(content, schema, {
      slice: false,
      parseOptions,
    });
  }
  var setContent =
    (content, emitUpdate = false, parseOptions = {}) =>
    ({ tr, editor, dispatch }) => {
      const { doc } = tr;
      const document2 = createDocument(content, editor.schema, parseOptions);
      if (dispatch) {
        tr.replaceWith(0, doc.content.size, document2).setMeta(
          "preventUpdate",
          !emitUpdate
        );
      }
      return true;
    };
  function getMarkAttributes(state, typeOrName) {
    const type = getMarkType(typeOrName, state.schema);
    const { from, to, empty } = state.selection;
    const marks = [];
    if (empty) {
      if (state.storedMarks) {
        marks.push(...state.storedMarks);
      }
      marks.push(...state.selection.$head.marks());
    } else {
      state.doc.nodesBetween(from, to, (node) => {
        marks.push(...node.marks);
      });
    }
    const mark = marks.find((markItem) => markItem.type.name === type.name);
    if (!mark) {
      return {};
    }
    return { ...mark.attrs };
  }
  function defaultBlockAt2(match) {
    for (let i = 0; i < match.edgeCount; i += 1) {
      const { type } = match.edge(i);
      if (type.isTextblock && !type.hasRequiredAttrs()) {
        return type;
      }
    }
    return null;
  }
  function findParentNodeClosestToPos($pos, predicate) {
    for (let i = $pos.depth; i > 0; i -= 1) {
      const node = $pos.node(i);
      if (predicate(node)) {
        return {
          pos: i > 0 ? $pos.before(i) : 0,
          start: $pos.start(i),
          depth: i,
          node,
        };
      }
    }
  }
  function findParentNode(predicate) {
    return (selection) =>
      findParentNodeClosestToPos(selection.$from, predicate);
  }
  function getSplittedAttributes(extensionAttributes, typeName, attributes) {
    return Object.fromEntries(
      Object.entries(attributes).filter(([name]) => {
        const extensionAttribute = extensionAttributes.find((item) => {
          return item.type === typeName && item.name === name;
        });
        if (!extensionAttribute) {
          return false;
        }
        return extensionAttribute.attribute.keepOnSplit;
      })
    );
  }
  function isMarkActive(state, typeOrName, attributes = {}) {
    const { empty, ranges } = state.selection;
    const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
    if (empty) {
      return !!(state.storedMarks || state.selection.$from.marks())
        .filter((mark) => {
          if (!type) {
            return true;
          }
          return type.name === mark.type.name;
        })
        .find((mark) =>
          objectIncludes(mark.attrs, attributes, { strict: false })
        );
    }
    let selectionRange = 0;
    const markRanges = [];
    ranges.forEach(({ $from, $to }) => {
      const from = $from.pos;
      const to = $to.pos;
      state.doc.nodesBetween(from, to, (node, pos) => {
        if (!node.isText && !node.marks.length) {
          return;
        }
        const relativeFrom = Math.max(from, pos);
        const relativeTo = Math.min(to, pos + node.nodeSize);
        const range2 = relativeTo - relativeFrom;
        selectionRange += range2;
        markRanges.push(
          ...node.marks.map((mark) => ({
            mark,
            from: relativeFrom,
            to: relativeTo,
          }))
        );
      });
    });
    if (selectionRange === 0) {
      return false;
    }
    const matchedRange = markRanges
      .filter((markRange) => {
        if (!type) {
          return true;
        }
        return type.name === markRange.mark.type.name;
      })
      .filter((markRange) =>
        objectIncludes(markRange.mark.attrs, attributes, { strict: false })
      )
      .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
    const excludedRange = markRanges
      .filter((markRange) => {
        if (!type) {
          return true;
        }
        return (
          markRange.mark.type !== type && markRange.mark.type.excludes(type)
        );
      })
      .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
    const range =
      matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
    return range >= selectionRange;
  }
  function isList(name, extensions) {
    const { nodeExtensions } = splitExtensions(extensions);
    const extension = nodeExtensions.find((item) => item.name === name);
    if (!extension) {
      return false;
    }
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
    };
    const group = callOrReturn(getExtensionField(extension, "group", context));
    if (typeof group !== "string") {
      return false;
    }
    return group.split(" ").includes("list");
  }
  function canSetMark(state, tr, newMarkType) {
    var _a;
    const { selection } = tr;
    let cursor = null;
    if (isTextSelection(selection)) {
      cursor = selection.$cursor;
    }
    if (cursor) {
      const currentMarks =
        (_a = state.storedMarks) !== null && _a !== void 0
          ? _a
          : cursor.marks();
      return (
        !!newMarkType.isInSet(currentMarks) ||
        !currentMarks.some((mark) => mark.type.excludes(newMarkType))
      );
    }
    const { ranges } = selection;
    return ranges.some(({ $from, $to }) => {
      let someNodeSupportsMark =
        $from.depth === 0
          ? state.doc.inlineContent &&
            state.doc.type.allowsMarkType(newMarkType)
          : false;
      state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
        if (someNodeSupportsMark) {
          return false;
        }
        if (node.isInline) {
          const parentAllowsMarkType =
            !parent || parent.type.allowsMarkType(newMarkType);
          const currentMarksAllowMarkType =
            !!newMarkType.isInSet(node.marks) ||
            !node.marks.some((otherMark) =>
              otherMark.type.excludes(newMarkType)
            );
          someNodeSupportsMark =
            parentAllowsMarkType && currentMarksAllowMarkType;
        }
        return !someNodeSupportsMark;
      });
      return someNodeSupportsMark;
    });
  }
  var setMark =
    (typeOrName, attributes = {}) =>
    ({ tr, state, dispatch }) => {
      const { selection } = tr;
      const { empty, ranges } = selection;
      const type = getMarkType(typeOrName, state.schema);
      if (dispatch) {
        if (empty) {
          const oldAttributes = getMarkAttributes(state, type);
          tr.addStoredMark(
            type.create({
              ...oldAttributes,
              ...attributes,
            })
          );
        } else {
          ranges.forEach((range) => {
            const from = range.$from.pos;
            const to = range.$to.pos;
            state.doc.nodesBetween(from, to, (node, pos) => {
              const trimmedFrom = Math.max(pos, from);
              const trimmedTo = Math.min(pos + node.nodeSize, to);
              const someHasMark = node.marks.find((mark) => mark.type === type);
              if (someHasMark) {
                node.marks.forEach((mark) => {
                  if (type === mark.type) {
                    tr.addMark(
                      trimmedFrom,
                      trimmedTo,
                      type.create({
                        ...mark.attrs,
                        ...attributes,
                      })
                    );
                  }
                });
              } else {
                tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
              }
            });
          });
        }
      }
      return canSetMark(state, tr, type);
    };
  var setMeta =
    (key, value) =>
    ({ tr }) => {
      tr.setMeta(key, value);
      return true;
    };
  var setNode =
    (typeOrName, attributes = {}) =>
    ({ state, dispatch, chain }) => {
      const type = getNodeType(typeOrName, state.schema);
      if (!type.isTextblock) {
        console.warn(
          '[tiptap warn]: Currently "setNode()" only supports text block nodes.'
        );
        return false;
      }
      return chain()
        .command(({ commands: commands2 }) => {
          const canSetBlock = setBlockType(type, attributes)(state);
          if (canSetBlock) {
            return true;
          }
          return commands2.clearNodes();
        })
        .command(({ state: updatedState }) => {
          return setBlockType(type, attributes)(updatedState, dispatch);
        })
        .run();
    };
  var setNodeSelection =
    (position) =>
    ({ tr, dispatch }) => {
      if (dispatch) {
        const { doc } = tr;
        const from = minMax(position, 0, doc.content.size);
        const selection = NodeSelection.create(doc, from);
        tr.setSelection(selection);
      }
      return true;
    };
  var setTextSelection =
    (position) =>
    ({ tr, dispatch }) => {
      if (dispatch) {
        const { doc } = tr;
        const { from, to } =
          typeof position === "number"
            ? { from: position, to: position }
            : position;
        const minPos = TextSelection.atStart(doc).from;
        const maxPos = TextSelection.atEnd(doc).to;
        const resolvedFrom = minMax(from, minPos, maxPos);
        const resolvedEnd = minMax(to, minPos, maxPos);
        const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd);
        tr.setSelection(selection);
      }
      return true;
    };
  var sinkListItem2 =
    (typeOrName) =>
    ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return sinkListItem(type)(state, dispatch);
    };
  function ensureMarks(state, splittableMarks) {
    const marks =
      state.storedMarks ||
      (state.selection.$to.parentOffset && state.selection.$from.marks());
    if (marks) {
      const filteredMarks = marks.filter((mark) =>
        splittableMarks === null || splittableMarks === void 0
          ? void 0
          : splittableMarks.includes(mark.type.name)
      );
      state.tr.ensureMarks(filteredMarks);
    }
  }
  var splitBlock2 =
    ({ keepMarks = true } = {}) =>
    ({ tr, state, dispatch, editor }) => {
      const { selection, doc } = tr;
      const { $from, $to } = selection;
      const extensionAttributes = editor.extensionManager.attributes;
      const newAttributes = getSplittedAttributes(
        extensionAttributes,
        $from.node().type.name,
        $from.node().attrs
      );
      if (selection instanceof NodeSelection && selection.node.isBlock) {
        if (!$from.parentOffset || !canSplit(doc, $from.pos)) {
          return false;
        }
        if (dispatch) {
          if (keepMarks) {
            ensureMarks(state, editor.extensionManager.splittableMarks);
          }
          tr.split($from.pos).scrollIntoView();
        }
        return true;
      }
      if (!$from.parent.isBlock) {
        return false;
      }
      if (dispatch) {
        const atEnd = $to.parentOffset === $to.parent.content.size;
        if (selection instanceof TextSelection) {
          tr.deleteSelection();
        }
        const deflt =
          $from.depth === 0
            ? void 0
            : defaultBlockAt2(
                $from.node(-1).contentMatchAt($from.indexAfter(-1))
              );
        let types =
          atEnd && deflt
            ? [
                {
                  type: deflt,
                  attrs: newAttributes,
                },
              ]
            : void 0;
        let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
        if (
          !types &&
          !can &&
          canSplit(
            tr.doc,
            tr.mapping.map($from.pos),
            1,
            deflt ? [{ type: deflt }] : void 0
          )
        ) {
          can = true;
          types = deflt
            ? [
                {
                  type: deflt,
                  attrs: newAttributes,
                },
              ]
            : void 0;
        }
        if (can) {
          tr.split(tr.mapping.map($from.pos), 1, types);
          if (
            deflt &&
            !atEnd &&
            !$from.parentOffset &&
            $from.parent.type !== deflt
          ) {
            const first2 = tr.mapping.map($from.before());
            const $first = tr.doc.resolve(first2);
            if (
              $from
                .node(-1)
                .canReplaceWith($first.index(), $first.index() + 1, deflt)
            ) {
              tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
            }
          }
        }
        if (keepMarks) {
          ensureMarks(state, editor.extensionManager.splittableMarks);
        }
        tr.scrollIntoView();
      }
      return true;
    };
  var splitListItem =
    (typeOrName) =>
    ({ tr, state, dispatch, editor }) => {
      var _a;
      const type = getNodeType(typeOrName, state.schema);
      const { $from, $to } = state.selection;
      const node = state.selection.node;
      if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {
        return false;
      }
      const grandParent = $from.node(-1);
      if (grandParent.type !== type) {
        return false;
      }
      const extensionAttributes = editor.extensionManager.attributes;
      if (
        $from.parent.content.size === 0 &&
        $from.node(-1).childCount === $from.indexAfter(-1)
      ) {
        if (
          $from.depth === 2 ||
          $from.node(-3).type !== type ||
          $from.index(-2) !== $from.node(-2).childCount - 1
        ) {
          return false;
        }
        if (dispatch) {
          let wrap = Fragment.empty;
          const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
          for (
            let d = $from.depth - depthBefore;
            d >= $from.depth - 3;
            d -= 1
          ) {
            wrap = Fragment.from($from.node(d).copy(wrap));
          }
          const depthAfter =
            $from.indexAfter(-1) < $from.node(-2).childCount
              ? 1
              : $from.indexAfter(-2) < $from.node(-3).childCount
              ? 2
              : 3;
          const newNextTypeAttributes2 = getSplittedAttributes(
            extensionAttributes,
            $from.node().type.name,
            $from.node().attrs
          );
          const nextType2 =
            ((_a = type.contentMatch.defaultType) === null || _a === void 0
              ? void 0
              : _a.createAndFill(newNextTypeAttributes2)) || void 0;
          wrap = wrap.append(
            Fragment.from(type.createAndFill(null, nextType2) || void 0)
          );
          const start = $from.before($from.depth - (depthBefore - 1));
          tr.replace(
            start,
            $from.after(-depthAfter),
            new Slice(wrap, 4 - depthBefore, 0)
          );
          let sel = -1;
          tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {
            if (sel > -1) {
              return false;
            }
            if (n.isTextblock && n.content.size === 0) {
              sel = pos + 1;
            }
          });
          if (sel > -1) {
            tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));
          }
          tr.scrollIntoView();
        }
        return true;
      }
      const nextType =
        $to.pos === $from.end()
          ? grandParent.contentMatchAt(0).defaultType
          : null;
      const newTypeAttributes = getSplittedAttributes(
        extensionAttributes,
        grandParent.type.name,
        grandParent.attrs
      );
      const newNextTypeAttributes = getSplittedAttributes(
        extensionAttributes,
        $from.node().type.name,
        $from.node().attrs
      );
      tr.delete($from.pos, $to.pos);
      const types = nextType
        ? [
            { type, attrs: newTypeAttributes },
            { type: nextType, attrs: newNextTypeAttributes },
          ]
        : [{ type, attrs: newTypeAttributes }];
      if (!canSplit(tr.doc, $from.pos, 2)) {
        return false;
      }
      if (dispatch) {
        const { selection, storedMarks } = state;
        const { splittableMarks } = editor.extensionManager;
        const marks =
          storedMarks ||
          (selection.$to.parentOffset && selection.$from.marks());
        tr.split($from.pos, 2, types).scrollIntoView();
        if (!marks || !dispatch) {
          return true;
        }
        const filteredMarks = marks.filter((mark) =>
          splittableMarks.includes(mark.type.name)
        );
        tr.ensureMarks(filteredMarks);
      }
      return true;
    };
  var joinListBackwards = (tr, listType) => {
    const list = findParentNode((node) => node.type === listType)(tr.selection);
    if (!list) {
      return true;
    }
    const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
    if (before === void 0) {
      return true;
    }
    const nodeBefore = tr.doc.nodeAt(before);
    const canJoinBackwards =
      list.node.type ===
        (nodeBefore === null || nodeBefore === void 0
          ? void 0
          : nodeBefore.type) && canJoin(tr.doc, list.pos);
    if (!canJoinBackwards) {
      return true;
    }
    tr.join(list.pos);
    return true;
  };
  var joinListForwards = (tr, listType) => {
    const list = findParentNode((node) => node.type === listType)(tr.selection);
    if (!list) {
      return true;
    }
    const after = tr.doc.resolve(list.start).after(list.depth);
    if (after === void 0) {
      return true;
    }
    const nodeAfter = tr.doc.nodeAt(after);
    const canJoinForwards =
      list.node.type ===
        (nodeAfter === null || nodeAfter === void 0
          ? void 0
          : nodeAfter.type) && canJoin(tr.doc, after);
    if (!canJoinForwards) {
      return true;
    }
    tr.join(after);
    return true;
  };
  var toggleList =
    (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) =>
    ({ editor, tr, state, dispatch, chain, commands: commands2, can }) => {
      const { extensions, splittableMarks } = editor.extensionManager;
      const listType = getNodeType(listTypeOrName, state.schema);
      const itemType = getNodeType(itemTypeOrName, state.schema);
      const { selection, storedMarks } = state;
      const { $from, $to } = selection;
      const range = $from.blockRange($to);
      const marks =
        storedMarks || (selection.$to.parentOffset && selection.$from.marks());
      if (!range) {
        return false;
      }
      const parentList = findParentNode((node) =>
        isList(node.type.name, extensions)
      )(selection);
      if (
        range.depth >= 1 &&
        parentList &&
        range.depth - parentList.depth <= 1
      ) {
        if (parentList.node.type === listType) {
          return commands2.liftListItem(itemType);
        }
        if (
          isList(parentList.node.type.name, extensions) &&
          listType.validContent(parentList.node.content) &&
          dispatch
        ) {
          return chain()
            .command(() => {
              tr.setNodeMarkup(parentList.pos, listType);
              return true;
            })
            .command(() => joinListBackwards(tr, listType))
            .command(() => joinListForwards(tr, listType))
            .run();
        }
      }
      if (!keepMarks || !marks || !dispatch) {
        return chain()
          .command(() => {
            const canWrapInList = can().wrapInList(listType, attributes);
            if (canWrapInList) {
              return true;
            }
            return commands2.clearNodes();
          })
          .wrapInList(listType, attributes)
          .command(() => joinListBackwards(tr, listType))
          .command(() => joinListForwards(tr, listType))
          .run();
      }
      return chain()
        .command(() => {
          const canWrapInList = can().wrapInList(listType, attributes);
          const filteredMarks = marks.filter((mark) =>
            splittableMarks.includes(mark.type.name)
          );
          tr.ensureMarks(filteredMarks);
          if (canWrapInList) {
            return true;
          }
          return commands2.clearNodes();
        })
        .wrapInList(listType, attributes)
        .command(() => joinListBackwards(tr, listType))
        .command(() => joinListForwards(tr, listType))
        .run();
    };
  var toggleMark =
    (typeOrName, attributes = {}, options = {}) =>
    ({ state, commands: commands2 }) => {
      const { extendEmptyMarkRange = false } = options;
      const type = getMarkType(typeOrName, state.schema);
      const isActive = isMarkActive(state, type, attributes);
      if (isActive) {
        return commands2.unsetMark(type, { extendEmptyMarkRange });
      }
      return commands2.setMark(type, attributes);
    };
  var toggleNode =
    (typeOrName, toggleTypeOrName, attributes = {}) =>
    ({ state, commands: commands2 }) => {
      const type = getNodeType(typeOrName, state.schema);
      const toggleType = getNodeType(toggleTypeOrName, state.schema);
      const isActive = isNodeActive(state, type, attributes);
      if (isActive) {
        return commands2.setNode(toggleType);
      }
      return commands2.setNode(type, attributes);
    };
  var toggleWrap =
    (typeOrName, attributes = {}) =>
    ({ state, commands: commands2 }) => {
      const type = getNodeType(typeOrName, state.schema);
      const isActive = isNodeActive(state, type, attributes);
      if (isActive) {
        return commands2.lift(type);
      }
      return commands2.wrapIn(type, attributes);
    };
  var undoInputRule =
    () =>
    ({ state, dispatch }) => {
      const plugins = state.plugins;
      for (let i = 0; i < plugins.length; i += 1) {
        const plugin = plugins[i];
        let undoable;
        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
          if (dispatch) {
            const tr = state.tr;
            const toUndo = undoable.transform;
            for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
              tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
            }
            if (undoable.text) {
              const marks = tr.doc.resolve(undoable.from).marks();
              tr.replaceWith(
                undoable.from,
                undoable.to,
                state.schema.text(undoable.text, marks)
              );
            } else {
              tr.delete(undoable.from, undoable.to);
            }
          }
          return true;
        }
      }
      return false;
    };
  var unsetAllMarks =
    () =>
    ({ tr, dispatch }) => {
      const { selection } = tr;
      const { empty, ranges } = selection;
      if (empty) {
        return true;
      }
      if (dispatch) {
        ranges.forEach((range) => {
          tr.removeMark(range.$from.pos, range.$to.pos);
        });
      }
      return true;
    };
  var unsetMark =
    (typeOrName, options = {}) =>
    ({ tr, state, dispatch }) => {
      var _a;
      const { extendEmptyMarkRange = false } = options;
      const { selection } = tr;
      const type = getMarkType(typeOrName, state.schema);
      const { $from, empty, ranges } = selection;
      if (!dispatch) {
        return true;
      }
      if (empty && extendEmptyMarkRange) {
        let { from, to } = selection;
        const attrs =
          (_a = $from.marks().find((mark) => mark.type === type)) === null ||
          _a === void 0
            ? void 0
            : _a.attrs;
        const range = getMarkRange($from, type, attrs);
        if (range) {
          from = range.from;
          to = range.to;
        }
        tr.removeMark(from, to, type);
      } else {
        ranges.forEach((range) => {
          tr.removeMark(range.$from.pos, range.$to.pos, type);
        });
      }
      tr.removeStoredMark(type);
      return true;
    };
  var updateAttributes =
    (typeOrName, attributes = {}) =>
    ({ tr, state, dispatch }) => {
      let nodeType = null;
      let markType = null;
      const schemaType = getSchemaTypeNameByName(
        typeof typeOrName === "string" ? typeOrName : typeOrName.name,
        state.schema
      );
      if (!schemaType) {
        return false;
      }
      if (schemaType === "node") {
        nodeType = getNodeType(typeOrName, state.schema);
      }
      if (schemaType === "mark") {
        markType = getMarkType(typeOrName, state.schema);
      }
      if (dispatch) {
        tr.selection.ranges.forEach((range) => {
          const from = range.$from.pos;
          const to = range.$to.pos;
          state.doc.nodesBetween(from, to, (node, pos) => {
            if (nodeType && nodeType === node.type) {
              tr.setNodeMarkup(pos, void 0, {
                ...node.attrs,
                ...attributes,
              });
            }
            if (markType && node.marks.length) {
              node.marks.forEach((mark) => {
                if (markType === mark.type) {
                  const trimmedFrom = Math.max(pos, from);
                  const trimmedTo = Math.min(pos + node.nodeSize, to);
                  tr.addMark(
                    trimmedFrom,
                    trimmedTo,
                    markType.create({
                      ...mark.attrs,
                      ...attributes,
                    })
                  );
                }
              });
            }
          });
        });
      }
      return true;
    };
  var wrapIn2 =
    (typeOrName, attributes = {}) =>
    ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return wrapIn(type, attributes)(state, dispatch);
    };
  var wrapInList2 =
    (typeOrName, attributes = {}) =>
    ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return wrapInList(type, attributes)(state, dispatch);
    };
  var commands = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    blur,
    clearContent,
    clearNodes,
    command,
    createParagraphNear: createParagraphNear2,
    cut,
    deleteCurrentNode,
    deleteNode,
    deleteRange,
    deleteSelection: deleteSelection2,
    enter,
    exitCode: exitCode2,
    extendMarkRange,
    first,
    focus,
    forEach,
    insertContent,
    insertContentAt,
    joinUp: joinUp2,
    joinDown: joinDown2,
    joinBackward: joinBackward2,
    joinForward: joinForward2,
    joinItemBackward,
    joinItemForward,
    keyboardShortcut,
    lift: lift2,
    liftEmptyBlock: liftEmptyBlock2,
    liftListItem: liftListItem2,
    newlineInCode: newlineInCode2,
    resetAttributes,
    scrollIntoView,
    selectAll: selectAll2,
    selectNodeBackward: selectNodeBackward2,
    selectNodeForward: selectNodeForward2,
    selectParentNode: selectParentNode2,
    selectTextblockEnd: selectTextblockEnd2,
    selectTextblockStart: selectTextblockStart2,
    setContent,
    setMark,
    setMeta,
    setNode,
    setNodeSelection,
    setTextSelection,
    sinkListItem: sinkListItem2,
    splitBlock: splitBlock2,
    splitListItem,
    toggleList,
    toggleMark,
    toggleNode,
    toggleWrap,
    undoInputRule,
    unsetAllMarks,
    unsetMark,
    updateAttributes,
    wrapIn: wrapIn2,
    wrapInList: wrapInList2,
  });
  var Commands = Extension.create({
    name: "commands",
    addCommands() {
      return {
        ...commands,
      };
    },
  });
  var Editable = Extension.create({
    name: "editable",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("editable"),
          props: {
            editable: () => this.editor.options.editable,
          },
        }),
      ];
    },
  });
  var FocusEvents = Extension.create({
    name: "focusEvents",
    addProseMirrorPlugins() {
      const { editor } = this;
      return [
        new Plugin({
          key: new PluginKey("focusEvents"),
          props: {
            handleDOMEvents: {
              focus: (view, event) => {
                editor.isFocused = true;
                const transaction = editor.state.tr
                  .setMeta("focus", { event })
                  .setMeta("addToHistory", false);
                view.dispatch(transaction);
                return false;
              },
              blur: (view, event) => {
                editor.isFocused = false;
                const transaction = editor.state.tr
                  .setMeta("blur", { event })
                  .setMeta("addToHistory", false);
                view.dispatch(transaction);
                return false;
              },
            },
          },
        }),
      ];
    },
  });
  var Keymap = Extension.create({
    name: "keymap",
    addKeyboardShortcuts() {
      const handleBackspace = () =>
        this.editor.commands.first(({ commands: commands2 }) => [
          () => commands2.undoInputRule(),
          // maybe convert first text block node to default node
          () =>
            commands2.command(({ tr }) => {
              const { selection, doc } = tr;
              const { empty, $anchor } = selection;
              const { pos, parent } = $anchor;
              const $parentPos = $anchor.parent.isTextblock
                ? tr.doc.resolve(pos - 1)
                : $anchor;
              const parentIsIsolating = $parentPos.parent.type.spec.isolating;
              const parentPos = $anchor.pos - $anchor.parentOffset;
              const isAtStart =
                parentIsIsolating && $parentPos.parent.childCount === 1
                  ? parentPos === $anchor.pos
                  : Selection.atStart(doc).from === pos;
              if (
                !empty ||
                !isAtStart ||
                !parent.type.isTextblock ||
                parent.textContent.length
              ) {
                return false;
              }
              return commands2.clearNodes();
            }),
          () => commands2.deleteSelection(),
          () => commands2.joinBackward(),
          () => commands2.selectNodeBackward(),
        ]);
      const handleDelete = () =>
        this.editor.commands.first(({ commands: commands2 }) => [
          () => commands2.deleteSelection(),
          () => commands2.deleteCurrentNode(),
          () => commands2.joinForward(),
          () => commands2.selectNodeForward(),
        ]);
      const handleEnter = () =>
        this.editor.commands.first(({ commands: commands2 }) => [
          () => commands2.newlineInCode(),
          () => commands2.createParagraphNear(),
          () => commands2.liftEmptyBlock(),
          () => commands2.splitBlock(),
        ]);
      const baseKeymap = {
        Enter: handleEnter,
        "Mod-Enter": () => this.editor.commands.exitCode(),
        Backspace: handleBackspace,
        "Mod-Backspace": handleBackspace,
        "Shift-Backspace": handleBackspace,
        Delete: handleDelete,
        "Mod-Delete": handleDelete,
        "Mod-a": () => this.editor.commands.selectAll(),
      };
      const pcKeymap = {
        ...baseKeymap,
      };
      const macKeymap = {
        ...baseKeymap,
        "Ctrl-h": handleBackspace,
        "Alt-Backspace": handleBackspace,
        "Ctrl-d": handleDelete,
        "Ctrl-Alt-Backspace": handleDelete,
        "Alt-Delete": handleDelete,
        "Alt-d": handleDelete,
        "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
        "Ctrl-e": () => this.editor.commands.selectTextblockEnd(),
      };
      if (isiOS() || isMacOS()) {
        return macKeymap;
      }
      return pcKeymap;
    },
    addProseMirrorPlugins() {
      return [
        // With this plugin we check if the whole document was selected and deleted.
        // In this case we will additionally call `clearNodes()` to convert e.g. a heading
        // to a paragraph if necessary.
        // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
        // with many other commands.
        new Plugin({
          key: new PluginKey("clearDocument"),
          appendTransaction: (transactions, oldState, newState) => {
            const docChanges =
              transactions.some((transaction) => transaction.docChanged) &&
              !oldState.doc.eq(newState.doc);
            if (!docChanges) {
              return;
            }
            const { empty, from, to } = oldState.selection;
            const allFrom = Selection.atStart(oldState.doc).from;
            const allEnd = Selection.atEnd(oldState.doc).to;
            const allWasSelected = from === allFrom && to === allEnd;
            if (empty || !allWasSelected) {
              return;
            }
            const isEmpty =
              newState.doc.textBetween(0, newState.doc.content.size, " ", " ")
                .length === 0;
            if (!isEmpty) {
              return;
            }
            const tr = newState.tr;
            const state = createChainableState({
              state: newState,
              transaction: tr,
            });
            const { commands: commands2 } = new CommandManager({
              editor: this.editor,
              state,
            });
            commands2.clearNodes();
            if (!tr.steps.length) {
              return;
            }
            return tr;
          },
        }),
      ];
    },
  });
  var Tabindex = Extension.create({
    name: "tabindex",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("tabindex"),
          props: {
            attributes: this.editor.isEditable ? { tabindex: "0" } : {},
          },
        }),
      ];
    },
  });
  var Node2 = class _Node {
    constructor(config = {}) {
      this.type = "node";
      this.name = "node";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {},
      };
      this.config = {
        ...this.config,
        ...config,
      };
      this.name = this.config.name;
      if (config.defaultOptions) {
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
        );
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(
          getExtensionField(this, "addOptions", {
            name: this.name,
          })
        );
      }
      this.storage =
        callOrReturn(
          getExtensionField(this, "addStorage", {
            name: this.name,
            options: this.options,
          })
        ) || {};
    }
    static create(config = {}) {
      return new _Node(config);
    }
    configure(options = {}) {
      const extension = this.extend();
      extension.options = mergeDeep(this.options, options);
      extension.storage = callOrReturn(
        getExtensionField(extension, "addStorage", {
          name: extension.name,
          options: extension.options,
        })
      );
      return extension;
    }
    extend(extendedConfig = {}) {
      const extension = new _Node(extendedConfig);
      extension.parent = this;
      this.child = extension;
      extension.name = extendedConfig.name
        ? extendedConfig.name
        : extension.parent.name;
      if (extendedConfig.defaultOptions) {
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`
        );
      }
      extension.options = callOrReturn(
        getExtensionField(extension, "addOptions", {
          name: extension.name,
        })
      );
      extension.storage = callOrReturn(
        getExtensionField(extension, "addStorage", {
          name: extension.name,
          options: extension.options,
        })
      );
      return extension;
    }
  };
  function nodePasteRule(config) {
    return new PasteRule({
      find: config.find,
      handler({ match, chain, range, pasteEvent }) {
        const attributes = callOrReturn(
          config.getAttributes,
          void 0,
          match,
          pasteEvent
        );
        if (attributes === false || attributes === null) {
          return null;
        }
        if (match.input) {
          chain().deleteRange(range).insertContentAt(range.from, {
            type: config.type.name,
            attrs: attributes,
          });
        }
      },
    });
  }

  // node_modules/@tiptap/extension-youtube/dist/index.js
  var YOUTUBE_REGEX =
    /^(https?:\/\/)?(www\.|music\.)?(youtube\.com|youtu\.be)(?!.*\/channel\/)(?!\/@)(.+)?$/;
  var YOUTUBE_REGEX_GLOBAL =
    /^(https?:\/\/)?(www\.|music\.)?(youtube\.com|youtu\.be)(?!.*\/channel\/)(?!\/@)(.+)?$/g;
  var isValidYoutubeUrl = (url) => {
    return url.match(YOUTUBE_REGEX);
  };
  var getYoutubeEmbedUrl = (nocookie) => {
    return nocookie
      ? "https://www.youtube-nocookie.com/embed/"
      : "https://www.youtube.com/embed/";
  };
  var getEmbedUrlFromYoutubeUrl = (options) => {
    const {
      url,
      allowFullscreen,
      autoplay,
      ccLanguage,
      ccLoadPolicy,
      controls,
      disableKBcontrols,
      enableIFrameApi,
      endTime,
      interfaceLanguage,
      ivLoadPolicy,
      loop,
      modestBranding,
      nocookie,
      origin,
      playlist,
      progressBarColor,
      startAt,
    } = options;
    if (url.includes("/embed/")) {
      return url;
    }
    if (url.includes("youtu.be")) {
      const id = url.split("/").pop();
      if (!id) {
        return null;
      }
      return `${getYoutubeEmbedUrl(nocookie)}${id}`;
    }
    const videoIdRegex = /v=([-\w]+)/gm;
    const matches2 = videoIdRegex.exec(url);
    if (!matches2 || !matches2[1]) {
      return null;
    }
    let outputUrl = `${getYoutubeEmbedUrl(nocookie)}${matches2[1]}`;
    const params = [];
    if (allowFullscreen === false) {
      params.push("fs=0");
    }
    if (autoplay) {
      params.push("autoplay=1");
    }
    if (ccLanguage) {
      params.push(`cc_lang_pref=${ccLanguage}`);
    }
    if (ccLoadPolicy) {
      params.push("cc_load_policy=1");
    }
    if (!controls) {
      params.push("controls=0");
    }
    if (disableKBcontrols) {
      params.push("disablekb=1");
    }
    if (enableIFrameApi) {
      params.push("enablejsapi=1");
    }
    if (endTime) {
      params.push(`end=${endTime}`);
    }
    if (interfaceLanguage) {
      params.push(`hl=${interfaceLanguage}`);
    }
    if (ivLoadPolicy) {
      params.push(`iv_load_policy=${ivLoadPolicy}`);
    }
    if (loop) {
      params.push("loop=1");
    }
    if (modestBranding) {
      params.push("modestbranding=1");
    }
    if (origin) {
      params.push(`origin=${origin}`);
    }
    if (playlist) {
      params.push(`playlist=${playlist}`);
    }
    if (startAt) {
      params.push(`start=${startAt}`);
    }
    if (progressBarColor) {
      params.push(`color=${progressBarColor}`);
    }
    if (params.length) {
      outputUrl += `?${params.join("&")}`;
    }
    return outputUrl;
  };
  var Youtube = Node2.create({
    name: "youtube",
    addOptions() {
      return {
        addPasteHandler: true,
        allowFullscreen: true,
        autoplay: false,
        ccLanguage: void 0,
        ccLoadPolicy: void 0,
        controls: true,
        disableKBcontrols: false,
        enableIFrameApi: false,
        endTime: 0,
        height: 480,
        interfaceLanguage: void 0,
        ivLoadPolicy: 0,
        loop: false,
        modestBranding: false,
        HTMLAttributes: {},
        inline: false,
        nocookie: false,
        origin: "",
        playlist: "",
        progressBarColor: void 0,
        width: 640,
      };
    },
    inline() {
      return this.options.inline;
    },
    group() {
      return this.options.inline ? "inline" : "block";
    },
    draggable: true,
    addAttributes() {
      return {
        src: {
          default: null,
        },
        start: {
          default: 0,
        },
        width: {
          default: this.options.width,
        },
        height: {
          default: this.options.height,
        },
      };
    },
    parseHTML() {
      return [
        {
          tag: "div[data-youtube-video] iframe",
        },
      ];
    },
    addCommands() {
      return {
        setYoutubeVideo:
          (options) =>
          ({ commands: commands2 }) => {
            if (!isValidYoutubeUrl(options.src)) {
              return false;
            }
            return commands2.insertContent({
              type: this.name,
              attrs: options,
            });
          },
      };
    },
    addPasteRules() {
      if (!this.options.addPasteHandler) {
        return [];
      }
      return [
        nodePasteRule({
          find: YOUTUBE_REGEX_GLOBAL,
          type: this.type,
          getAttributes: (match) => {
            return { src: match.input };
          },
        }),
      ];
    },
    renderHTML({ HTMLAttributes }) {
      const embedUrl = getEmbedUrlFromYoutubeUrl({
        url: HTMLAttributes.src,
        allowFullscreen: this.options.allowFullscreen,
        autoplay: this.options.autoplay,
        ccLanguage: this.options.ccLanguage,
        ccLoadPolicy: this.options.ccLoadPolicy,
        controls: this.options.controls,
        disableKBcontrols: this.options.disableKBcontrols,
        enableIFrameApi: this.options.enableIFrameApi,
        endTime: this.options.endTime,
        interfaceLanguage: this.options.interfaceLanguage,
        ivLoadPolicy: this.options.ivLoadPolicy,
        loop: this.options.loop,
        modestBranding: this.options.modestBranding,
        nocookie: this.options.nocookie,
        origin: this.options.origin,
        playlist: this.options.playlist,
        progressBarColor: this.options.progressBarColor,
        startAt: HTMLAttributes.start || 0,
      });
      HTMLAttributes.src = embedUrl;
      return [
        "div",
        { "data-youtube-video": "" },
        [
          "iframe",
          mergeAttributes(
            this.options.HTMLAttributes,
            {
              width: this.options.width,
              height: this.options.height,
              allowfullscreen: this.options.allowFullscreen,
              autoplay: this.options.autoplay,
              ccLanguage: this.options.ccLanguage,
              ccLoadPolicy: this.options.ccLoadPolicy,
              disableKBcontrols: this.options.disableKBcontrols,
              enableIFrameApi: this.options.enableIFrameApi,
              endTime: this.options.endTime,
              interfaceLanguage: this.options.interfaceLanguage,
              ivLoadPolicy: this.options.ivLoadPolicy,
              loop: this.options.loop,
              modestBranding: this.options.modestBranding,
              origin: this.options.origin,
              playlist: this.options.playlist,
              progressBarColor: this.options.progressBarColor,
            },
            HTMLAttributes
          ),
        ],
      ];
    },
  });

  // packages/youtube/resources/js/index.js
  registerExtension("youtube", () => [Youtube]);
})();
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vc3VwcG9ydC9yZXNvdXJjZXMvanMvdXRpbHMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLW1vZGVsL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXRyYW5zZm9ybS9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1zdGF0ZS9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1jb21tYW5kcy9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1zY2hlbWEtbGlzdC9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY3JlYXRlQ2hhaW5hYmxlU3RhdGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvQ29tbWFuZE1hbmFnZXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvRXZlbnRFbWl0dGVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9zcGxpdEV4dGVuc2lvbnMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXROb2RlVHlwZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvbWVyZ2VBdHRyaWJ1dGVzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc0Z1bmN0aW9uLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzRW1wdHlPYmplY3QudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2Zyb21TdHJpbmcudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFNjaGVtYVR5cGVCeU5hbWUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0V4dGVuc2lvblJ1bGVzRW5hYmxlZC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFRleHRDb250ZW50RnJvbU5vZGVzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc1JlZ0V4cC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9JbnB1dFJ1bGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzTnVtYmVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL1Bhc3RlUnVsZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvZmluZER1cGxpY2F0ZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvRXh0ZW5zaW9uTWFuYWdlci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvaXNQbGFpbk9iamVjdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvbWVyZ2VEZWVwLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL0V4dGVuc2lvbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFRleHRCZXR3ZWVuLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2NsaXBib2FyZFRleHRTZXJpYWxpemVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2JsdXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvY2xlYXJDb250ZW50LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2NsZWFyTm9kZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvY29tbWFuZC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9jcmVhdGVQYXJhZ3JhcGhOZWFyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2N1dC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9kZWxldGVDdXJyZW50Tm9kZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9kZWxldGVOb2RlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2RlbGV0ZVJhbmdlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2RlbGV0ZVNlbGVjdGlvbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9lbnRlci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9leGl0Q29kZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvb2JqZWN0SW5jbHVkZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRNYXJrUmFuZ2UudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRNYXJrVHlwZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9leHRlbmRNYXJrUmFuZ2UudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvZmlyc3QudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc1RleHRTZWxlY3Rpb24udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL21pbk1heC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL3Jlc29sdmVGb2N1c1Bvc2l0aW9uLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc2lPUy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9mb2N1cy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9mb3JFYWNoLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2luc2VydENvbnRlbnQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2VsZW1lbnRGcm9tU3RyaW5nLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY3JlYXRlTm9kZUZyb21Db250ZW50LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvaW5zZXJ0Q29udGVudEF0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2pvaW4udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvam9pbkl0ZW1CYWNrd2FyZC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9qb2luSXRlbUZvcndhcmQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzTWFjT1MudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMva2V5Ym9hcmRTaG9ydGN1dC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzTm9kZUFjdGl2ZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9saWZ0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2xpZnRFbXB0eUJsb2NrLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2xpZnRMaXN0SXRlbS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9uZXdsaW5lSW5Db2RlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2RlbGV0ZVByb3BzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3Jlc2V0QXR0cmlidXRlcy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zY3JvbGxJbnRvVmlldy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZWxlY3RBbGwudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2VsZWN0Tm9kZUJhY2t3YXJkLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdE5vZGVGb3J3YXJkLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdFBhcmVudE5vZGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2VsZWN0VGV4dGJsb2NrRW5kLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdFRleHRibG9ja1N0YXJ0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY3JlYXRlRG9jdW1lbnQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2V0Q29udGVudC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldE1hcmtBdHRyaWJ1dGVzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY29tYmluZVRyYW5zYWN0aW9uU3RlcHMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9kZWZhdWx0QmxvY2tBdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2ZpbmRDaGlsZHJlbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2ZpbmRDaGlsZHJlbkluUmFuZ2UudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9maW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1Bvcy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2ZpbmRQYXJlbnROb2RlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0SFRNTEZyb21GcmFnbWVudC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFNjaGVtYS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dlbmVyYXRlSFRNTC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dlbmVyYXRlSlNPTi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFRleHQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZW5lcmF0ZVRleHQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXROb2RlQXR0cmlidXRlcy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldEF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL3JlbW92ZUR1cGxpY2F0ZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRDaGFuZ2VkUmFuZ2VzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0RGVidWdKU09OLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0TWFya3NCZXR3ZWVuLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0Tm9kZUF0UG9zaXRpb24udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRTcGxpdHRlZEF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc01hcmtBY3RpdmUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0FjdGl2ZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzQXRFbmRPZk5vZGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0F0U3RhcnRPZk5vZGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0xpc3QudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc05vZGVFbXB0eS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzTm9kZVNlbGVjdGlvbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL3Bvc1RvRE9NUmVjdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZXRNYXJrLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NldE1ldGEudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2V0Tm9kZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZXROb2RlU2VsZWN0aW9uLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NldFRleHRTZWxlY3Rpb24udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2lua0xpc3RJdGVtLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NwbGl0QmxvY2sudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc3BsaXRMaXN0SXRlbS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy90b2dnbGVMaXN0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3RvZ2dsZU1hcmsudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdG9nZ2xlTm9kZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy90b2dnbGVXcmFwLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3VuZG9JbnB1dFJ1bGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdW5zZXRBbGxNYXJrcy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy91bnNldE1hcmsudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdXBkYXRlQXR0cmlidXRlcy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy93cmFwSW4udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvd3JhcEluTGlzdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2NvbW1hbmRzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2V4dGVuc2lvbnMvZWRpdGFibGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvZXh0ZW5zaW9ucy9mb2N1c0V2ZW50cy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2tleW1hcC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL3RhYmluZGV4LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3N0eWxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9jcmVhdGVTdHlsZVRhZy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9FZGl0b3IudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaW5wdXRSdWxlcy9tYXJrSW5wdXRSdWxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2lucHV0UnVsZXMvbm9kZUlucHV0UnVsZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9pbnB1dFJ1bGVzL3RleHRibG9ja1R5cGVJbnB1dFJ1bGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaW5wdXRSdWxlcy90ZXh0SW5wdXRSdWxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2lucHV0UnVsZXMvd3JhcHBpbmdJbnB1dFJ1bGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvTWFyay50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9Ob2RlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc0FuZHJvaWQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvTm9kZVZpZXcudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvcGFzdGVSdWxlcy9tYXJrUGFzdGVSdWxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9lc2NhcGVGb3JSZWdFeC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvaXNTdHJpbmcudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvcGFzdGVSdWxlcy9ub2RlUGFzdGVSdWxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3Bhc3RlUnVsZXMvdGV4dFBhc3RlUnVsZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9UcmFja2VyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi15b3V0dWJlL3NyYy91dGlscy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24teW91dHViZS9zcmMveW91dHViZS50cyIsICIuLi9yZXNvdXJjZXMvanMvaW5kZXguanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckV4dGVuc2lvbihpZCwgY2FsbGJhY2spIHtcbiAgaWYgKGlkID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpZCBjYW4ndCBiZSB1bmRlZmluZWQgd2hlbiByZWdpc3RlcmluZyBhbiBleHRlbnNpb25cIik7XG4gIH1cbiAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcImNhbGxiYWNrIGNhbid0IGJlIHVuZGVmaW5lZCB3aGVuIHJlZ2lzdGVyaW5nIGFuIGV4dGVuc2lvblwiXG4gICAgKTtcbiAgfVxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiYWxwaW5lOmluaXRcIiwgKCkgPT4ge1xuICAgIHdpbmRvdy50YWxsdGFwUmVnaXN0cnkucmVnaXN0ZXIoaWQsIGNhbGxiYWNrKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWJibGVNZW51UmVmKGRpc3BsYXlDb25kaXRpb24gPSB1bmRlZmluZWQpIHtcbiAgcmV0dXJuIHtcbiAgICBlZGl0b3JSZWY6IHVuZGVmaW5lZCxcbiAgICBzaG93OiAhZGlzcGxheUNvbmRpdGlvbixcbiAgICBpbml0VGFsbHRhcCgpIHtcbiAgICAgIHRoaXMuZWRpdG9yUmVmID0gdGhpcy4kZWwucGFyZW50RWxlbWVudC5kYXRhc2V0LmVkaXRvcjtcbiAgICAgIHRoaXMuZXZhbHVhdGVJZlNob3dpbmcoKTtcbiAgICB9LFxuICAgIGV2YWx1YXRlSWZTaG93aW5nKCkge1xuICAgICAgaWYgKCFkaXNwbGF5Q29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2hvdyA9IHRoaXMuZ2V0RWRpdG9yKCkuaXNBY3RpdmUoZGlzcGxheUNvbmRpdGlvbik7XG4gICAgfSxcbiAgICBlZGl0b3IoKSB7XG4gICAgICB0aGlzLmV2YWx1YXRlSWZTaG93aW5nKCk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRFZGl0b3IoKTtcbiAgICB9LFxuICAgIGdldEVkaXRvcigpIHtcbiAgICAgIHJldHVybiB3aW5kb3cudGFsbHRhcFt0aGlzLmVkaXRvclJlZl07XG4gICAgfSxcbiAgICBidWJibGVNZW51UmVmOiB7XG4gICAgICBbXCJ4LWluaXRcIl0oKSB7XG4gICAgICAgIHRoaXMuaW5pdFRhbGx0YXAoKTtcbiAgICAgIH0sXG4gICAgICBbXCJ4LXNob3dcIl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3c7XG4gICAgICB9LFxuICAgICAgW1wieC1vbjp1cGRhdGUud2luZG93XCJdKCkge1xuICAgICAgICB0aGlzLmV2YWx1YXRlSWZTaG93aW5nKCk7XG4gICAgICB9LFxuICAgIH0sXG4gIH07XG59XG4iLCAiaW1wb3J0IE9yZGVyZWRNYXAgZnJvbSAnb3JkZXJlZG1hcCc7XG5cbmZ1bmN0aW9uIGZpbmREaWZmU3RhcnQoYSwgYiwgcG9zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgaWYgKGkgPT0gYS5jaGlsZENvdW50IHx8IGkgPT0gYi5jaGlsZENvdW50KVxuICAgICAgICAgICAgcmV0dXJuIGEuY2hpbGRDb3VudCA9PSBiLmNoaWxkQ291bnQgPyBudWxsIDogcG9zO1xuICAgICAgICBsZXQgY2hpbGRBID0gYS5jaGlsZChpKSwgY2hpbGRCID0gYi5jaGlsZChpKTtcbiAgICAgICAgaWYgKGNoaWxkQSA9PSBjaGlsZEIpIHtcbiAgICAgICAgICAgIHBvcyArPSBjaGlsZEEubm9kZVNpemU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoaWxkQS5zYW1lTWFya3VwKGNoaWxkQikpXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICBpZiAoY2hpbGRBLmlzVGV4dCAmJiBjaGlsZEEudGV4dCAhPSBjaGlsZEIudGV4dCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGNoaWxkQS50ZXh0W2pdID09IGNoaWxkQi50ZXh0W2pdOyBqKyspXG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEEuY29udGVudC5zaXplIHx8IGNoaWxkQi5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGZpbmREaWZmU3RhcnQoY2hpbGRBLmNvbnRlbnQsIGNoaWxkQi5jb250ZW50LCBwb3MgKyAxKTtcbiAgICAgICAgICAgIGlmIChpbm5lciAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gY2hpbGRBLm5vZGVTaXplO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmREaWZmRW5kKGEsIGIsIHBvc0EsIHBvc0IpIHtcbiAgICBmb3IgKGxldCBpQSA9IGEuY2hpbGRDb3VudCwgaUIgPSBiLmNoaWxkQ291bnQ7Oykge1xuICAgICAgICBpZiAoaUEgPT0gMCB8fCBpQiA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGlBID09IGlCID8gbnVsbCA6IHsgYTogcG9zQSwgYjogcG9zQiB9O1xuICAgICAgICBsZXQgY2hpbGRBID0gYS5jaGlsZCgtLWlBKSwgY2hpbGRCID0gYi5jaGlsZCgtLWlCKSwgc2l6ZSA9IGNoaWxkQS5ub2RlU2l6ZTtcbiAgICAgICAgaWYgKGNoaWxkQSA9PSBjaGlsZEIpIHtcbiAgICAgICAgICAgIHBvc0EgLT0gc2l6ZTtcbiAgICAgICAgICAgIHBvc0IgLT0gc2l6ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hpbGRBLnNhbWVNYXJrdXAoY2hpbGRCKSlcbiAgICAgICAgICAgIHJldHVybiB7IGE6IHBvc0EsIGI6IHBvc0IgfTtcbiAgICAgICAgaWYgKGNoaWxkQS5pc1RleHQgJiYgY2hpbGRBLnRleHQgIT0gY2hpbGRCLnRleHQpIHtcbiAgICAgICAgICAgIGxldCBzYW1lID0gMCwgbWluU2l6ZSA9IE1hdGgubWluKGNoaWxkQS50ZXh0Lmxlbmd0aCwgY2hpbGRCLnRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIHdoaWxlIChzYW1lIDwgbWluU2l6ZSAmJiBjaGlsZEEudGV4dFtjaGlsZEEudGV4dC5sZW5ndGggLSBzYW1lIC0gMV0gPT0gY2hpbGRCLnRleHRbY2hpbGRCLnRleHQubGVuZ3RoIC0gc2FtZSAtIDFdKSB7XG4gICAgICAgICAgICAgICAgc2FtZSsrO1xuICAgICAgICAgICAgICAgIHBvc0EtLTtcbiAgICAgICAgICAgICAgICBwb3NCLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBhOiBwb3NBLCBiOiBwb3NCIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkQS5jb250ZW50LnNpemUgfHwgY2hpbGRCLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gZmluZERpZmZFbmQoY2hpbGRBLmNvbnRlbnQsIGNoaWxkQi5jb250ZW50LCBwb3NBIC0gMSwgcG9zQiAtIDEpO1xuICAgICAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgfVxuICAgICAgICBwb3NBIC09IHNpemU7XG4gICAgICAgIHBvc0IgLT0gc2l6ZTtcbiAgICB9XG59XG5cbi8qKlxuQSBmcmFnbWVudCByZXByZXNlbnRzIGEgbm9kZSdzIGNvbGxlY3Rpb24gb2YgY2hpbGQgbm9kZXMuXG5cbkxpa2Ugbm9kZXMsIGZyYWdtZW50cyBhcmUgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZXMsIGFuZCB5b3VcbnNob3VsZCBub3QgbXV0YXRlIHRoZW0gb3IgdGhlaXIgY29udGVudC4gUmF0aGVyLCB5b3UgY3JlYXRlIG5ld1xuaW5zdGFuY2VzIHdoZW5ldmVyIG5lZWRlZC4gVGhlIEFQSSB0cmllcyB0byBtYWtlIHRoaXMgZWFzeS5cbiovXG5jbGFzcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnRlbnQsIHNpemUpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZSB8fCAwO1xuICAgICAgICBpZiAoc2l6ZSA9PSBudWxsKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSArPSBjb250ZW50W2ldLm5vZGVTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBJbnZva2UgYSBjYWxsYmFjayBmb3IgYWxsIGRlc2NlbmRhbnQgbm9kZXMgYmV0d2VlbiB0aGUgZ2l2ZW4gdHdvXG4gICAgcG9zaXRpb25zIChyZWxhdGl2ZSB0byBzdGFydCBvZiB0aGlzIGZyYWdtZW50KS4gRG9lc24ndCBkZXNjZW5kXG4gICAgaW50byBhIG5vZGUgd2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLlxuICAgICovXG4gICAgbm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmLCBub2RlU3RhcnQgPSAwLCBwYXJlbnQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IHBvcyA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY29udGVudFtpXSwgZW5kID0gcG9zICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoZW5kID4gZnJvbSAmJiBmKGNoaWxkLCBub2RlU3RhcnQgKyBwb3MsIHBhcmVudCB8fCBudWxsLCBpKSAhPT0gZmFsc2UgJiYgY2hpbGQuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgICBjaGlsZC5ub2Rlc0JldHdlZW4oTWF0aC5tYXgoMCwgZnJvbSAtIHN0YXJ0KSwgTWF0aC5taW4oY2hpbGQuY29udGVudC5zaXplLCB0byAtIHN0YXJ0KSwgZiwgbm9kZVN0YXJ0ICsgc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBldmVyeSBkZXNjZW5kYW50IG5vZGUuIGBwb3NgIHdpbGwgYmVcbiAgICByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50LiBUaGUgY2FsbGJhY2sgbWF5IHJldHVyblxuICAgIGBmYWxzZWAgdG8gcHJldmVudCB0cmF2ZXJzYWwgb2YgYSBnaXZlbiBub2RlJ3MgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBkZXNjZW5kYW50cyhmKSB7XG4gICAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKDAsIHRoaXMuc2l6ZSwgZik7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4dHJhY3QgdGhlIHRleHQgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AuIFNlZSB0aGUgc2FtZSBtZXRob2Qgb25cbiAgICBbYE5vZGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS50ZXh0QmV0d2VlbikuXG4gICAgKi9cbiAgICB0ZXh0QmV0d2Vlbihmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KSB7XG4gICAgICAgIGxldCB0ZXh0ID0gXCJcIiwgc2VwYXJhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gbm9kZS50ZXh0LnNsaWNlKE1hdGgubWF4KGZyb20sIHBvcykgLSBwb3MsIHRvIC0gcG9zKTtcbiAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgPSAhYmxvY2tTZXBhcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLmlzTGVhZikge1xuICAgICAgICAgICAgICAgIGlmIChsZWFmVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IHR5cGVvZiBsZWFmVGV4dCA9PT0gXCJmdW5jdGlvblwiID8gbGVhZlRleHQobm9kZSkgOiBsZWFmVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlLnNwZWMubGVhZlRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBub2RlLnR5cGUuc3BlYy5sZWFmVGV4dChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VwYXJhdGVkID0gIWJsb2NrU2VwYXJhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXNlcGFyYXRlZCAmJiBub2RlLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IGJsb2NrU2VwYXJhdG9yO1xuICAgICAgICAgICAgICAgIHNlcGFyYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGNvbnRhaW5pbmcgdGhlIGNvbWJpbmVkIGNvbnRlbnQgb2YgdGhpc1xuICAgIGZyYWdtZW50IGFuZCB0aGUgb3RoZXIuXG4gICAgKi9cbiAgICBhcHBlbmQob3RoZXIpIHtcbiAgICAgICAgaWYgKCFvdGhlci5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubGFzdENoaWxkLCBmaXJzdCA9IG90aGVyLmZpcnN0Q2hpbGQsIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKSwgaSA9IDA7XG4gICAgICAgIGlmIChsYXN0LmlzVGV4dCAmJiBsYXN0LnNhbWVNYXJrdXAoZmlyc3QpKSB7XG4gICAgICAgICAgICBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gPSBsYXN0LndpdGhUZXh0KGxhc3QudGV4dCArIGZpcnN0LnRleHQpO1xuICAgICAgICAgICAgaSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCBvdGhlci5jb250ZW50Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgY29udGVudC5wdXNoKG90aGVyLmNvbnRlbnRbaV0pO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvbnRlbnQsIHRoaXMuc2l6ZSArIG90aGVyLnNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDdXQgb3V0IHRoZSBzdWItZnJhZ21lbnQgYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIGN1dChmcm9tLCB0byA9IHRoaXMuc2l6ZSkge1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIHNpemUgPSAwO1xuICAgICAgICBpZiAodG8gPiBmcm9tKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IHBvcyA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV0sIGVuZCA9IHBvcyArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tIHx8IGVuZCA+IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaXNUZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY3V0KE1hdGgubWF4KDAsIGZyb20gLSBwb3MpLCBNYXRoLm1pbihjaGlsZC50ZXh0Lmxlbmd0aCwgdG8gLSBwb3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmN1dChNYXRoLm1heCgwLCBmcm9tIC0gcG9zIC0gMSksIE1hdGgubWluKGNoaWxkLmNvbnRlbnQuc2l6ZSwgdG8gLSBwb3MgLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBzaXplICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQocmVzdWx0LCBzaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjdXRCeUluZGV4KGZyb20sIHRvKSB7XG4gICAgICAgIGlmIChmcm9tID09IHRvKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmNvbnRlbnQuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGluIHdoaWNoIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBpbmRleCBpc1xuICAgIHJlcGxhY2VkIGJ5IHRoZSBnaXZlbiBub2RlLlxuICAgICovXG4gICAgcmVwbGFjZUNoaWxkKGluZGV4LCBub2RlKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5jb250ZW50W2luZGV4XTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT0gbm9kZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgY29weSA9IHRoaXMuY29udGVudC5zbGljZSgpO1xuICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUgLSBjdXJyZW50Lm5vZGVTaXplO1xuICAgICAgICBjb3B5W2luZGV4XSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29weSwgc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBieSBwcmVwZW5kaW5nIHRoZSBnaXZlbiBub2RlIHRvIHRoaXNcbiAgICBmcmFnbWVudC5cbiAgICAqL1xuICAgIGFkZFRvU3RhcnQobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KFtub2RlXS5jb25jYXQodGhpcy5jb250ZW50KSwgdGhpcy5zaXplICsgbm9kZS5ub2RlU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBieSBhcHBlbmRpbmcgdGhlIGdpdmVuIG5vZGUgdG8gdGhpc1xuICAgIGZyYWdtZW50LlxuICAgICovXG4gICAgYWRkVG9FbmQobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHRoaXMuY29udGVudC5jb25jYXQobm9kZSksIHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgZnJhZ21lbnQgdG8gYW5vdGhlciBvbmUuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCAhPSBvdGhlci5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udGVudFtpXS5lcShvdGhlci5jb250ZW50W2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZmlyc3QgY2hpbGQgb2YgdGhlIGZyYWdtZW50LCBvciBgbnVsbGAgaWYgaXQgaXMgZW1wdHkuXG4gICAgKi9cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnRbMF0gOiBudWxsOyB9XG4gICAgLyoqXG4gICAgVGhlIGxhc3QgY2hpbGQgb2YgdGhlIGZyYWdtZW50LCBvciBgbnVsbGAgaWYgaXQgaXMgZW1wdHkuXG4gICAgKi9cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gOiBudWxsOyB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiBjaGlsZCBub2RlcyBpbiB0aGlzIGZyYWdtZW50LlxuICAgICovXG4gICAgZ2V0IGNoaWxkQ291bnQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC4gUmFpc2UgYW4gZXJyb3Igd2hlbiB0aGVcbiAgICBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgKi9cbiAgICBjaGlsZChpbmRleCkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLmNvbnRlbnRbaW5kZXhdO1xuICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBcIiArIGluZGV4ICsgXCIgb3V0IG9mIHJhbmdlIGZvciBcIiArIHRoaXMpO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIGl0IGV4aXN0cy5cbiAgICAqL1xuICAgIG1heWJlQ2hpbGQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFtpbmRleF0gfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbCBgZmAgZm9yIGV2ZXJ5IGNoaWxkIG5vZGUsIHBhc3NpbmcgdGhlIG5vZGUsIGl0cyBvZmZzZXRcbiAgICBpbnRvIHRoaXMgcGFyZW50IG5vZGUsIGFuZCBpdHMgaW5kZXguXG4gICAgKi9cbiAgICBmb3JFYWNoKGYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHAgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV07XG4gICAgICAgICAgICBmKGNoaWxkLCBwLCBpKTtcbiAgICAgICAgICAgIHAgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZmlyc3QgcG9zaXRpb24gYXQgd2hpY2ggdGhpcyBmcmFnbWVudCBhbmQgYW5vdGhlclxuICAgIGZyYWdtZW50IGRpZmZlciwgb3IgYG51bGxgIGlmIHRoZXkgYXJlIHRoZSBzYW1lLlxuICAgICovXG4gICAgZmluZERpZmZTdGFydChvdGhlciwgcG9zID0gMCkge1xuICAgICAgICByZXR1cm4gZmluZERpZmZTdGFydCh0aGlzLCBvdGhlciwgcG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZmlyc3QgcG9zaXRpb24sIHNlYXJjaGluZyBmcm9tIHRoZSBlbmQsIGF0IHdoaWNoIHRoaXNcbiAgICBmcmFnbWVudCBhbmQgdGhlIGdpdmVuIGZyYWdtZW50IGRpZmZlciwgb3IgYG51bGxgIGlmIHRoZXkgYXJlXG4gICAgdGhlIHNhbWUuIFNpbmNlIHRoaXMgcG9zaXRpb24gd2lsbCBub3QgYmUgdGhlIHNhbWUgaW4gYm90aFxuICAgIG5vZGVzLCBhbiBvYmplY3Qgd2l0aCB0d28gc2VwYXJhdGUgcG9zaXRpb25zIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgZmluZERpZmZFbmQob3RoZXIsIHBvcyA9IHRoaXMuc2l6ZSwgb3RoZXJQb3MgPSBvdGhlci5zaXplKSB7XG4gICAgICAgIHJldHVybiBmaW5kRGlmZkVuZCh0aGlzLCBvdGhlciwgcG9zLCBvdGhlclBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGluZGV4IGFuZCBpbm5lciBvZmZzZXQgY29ycmVzcG9uZGluZyB0byBhIGdpdmVuIHJlbGF0aXZlXG4gICAgcG9zaXRpb24gaW4gdGhpcyBmcmFnbWVudC4gVGhlIHJlc3VsdCBvYmplY3Qgd2lsbCBiZSByZXVzZWRcbiAgICAob3ZlcndyaXR0ZW4pIHRoZSBuZXh0IHRpbWUgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZC4gKE5vdCBwdWJsaWMuKVxuICAgICovXG4gICAgZmluZEluZGV4KHBvcywgcm91bmQgPSAtMSkge1xuICAgICAgICBpZiAocG9zID09IDApXG4gICAgICAgICAgICByZXR1cm4gcmV0SW5kZXgoMCwgcG9zKTtcbiAgICAgICAgaWYgKHBvcyA9PSB0aGlzLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gcmV0SW5kZXgodGhpcy5jb250ZW50Lmxlbmd0aCwgcG9zKTtcbiAgICAgICAgaWYgKHBvcyA+IHRoaXMuc2l6ZSB8fCBwb3MgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBvc2l0aW9uICR7cG9zfSBvdXRzaWRlIG9mIGZyYWdtZW50ICgke3RoaXN9KWApO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgY3VyUG9zID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHRoaXMuY2hpbGQoaSksIGVuZCA9IGN1clBvcyArIGN1ci5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA9PSBwb3MgfHwgcm91bmQgPiAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0SW5kZXgoaSArIDEsIGVuZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KGksIGN1clBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJQb3MgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgZGVidWdnaW5nIHN0cmluZyB0aGF0IGRlc2NyaWJlcyB0aGlzIGZyYWdtZW50LlxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBcIjxcIiArIHRoaXMudG9TdHJpbmdJbm5lcigpICsgXCI+XCI7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nSW5uZXIoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuam9pbihcIiwgXCIpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgSlNPTi1zZXJpYWxpemVhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZnJhZ21lbnQuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50Lm1hcChuID0+IG4udG9KU09OKCkpIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBmcmFnbWVudCBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgRnJhZ21lbnQuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQodmFsdWUubWFwKHNjaGVtYS5ub2RlRnJvbUpTT04pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSBmcmFnbWVudCBmcm9tIGFuIGFycmF5IG9mIG5vZGVzLiBFbnN1cmVzIHRoYXQgYWRqYWNlbnRcbiAgICB0ZXh0IG5vZGVzIHdpdGggdGhlIHNhbWUgbWFya3MgYXJlIGpvaW5lZCB0b2dldGhlci5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgaWYgKCFhcnJheS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGxldCBqb2luZWQsIHNpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGFycmF5W2ldO1xuICAgICAgICAgICAgc2l6ZSArPSBub2RlLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGkgJiYgbm9kZS5pc1RleHQgJiYgYXJyYXlbaSAtIDFdLnNhbWVNYXJrdXAobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWpvaW5lZClcbiAgICAgICAgICAgICAgICAgICAgam9pbmVkID0gYXJyYXkuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgam9pbmVkW2pvaW5lZC5sZW5ndGggLSAxXSA9IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgLndpdGhUZXh0KGpvaW5lZFtqb2luZWQubGVuZ3RoIC0gMV0udGV4dCArIG5vZGUudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChqb2luZWQpIHtcbiAgICAgICAgICAgICAgICBqb2luZWQucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGpvaW5lZCB8fCBhcnJheSwgc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGZyYWdtZW50IGZyb20gc29tZXRoaW5nIHRoYXQgY2FuIGJlIGludGVycHJldGVkIGFzIGFcbiAgICBzZXQgb2Ygbm9kZXMuIEZvciBgbnVsbGAsIGl0IHJldHVybnMgdGhlIGVtcHR5IGZyYWdtZW50LiBGb3IgYVxuICAgIGZyYWdtZW50LCB0aGUgZnJhZ21lbnQgaXRzZWxmLiBGb3IgYSBub2RlIG9yIGFycmF5IG9mIG5vZGVzLCBhXG4gICAgZnJhZ21lbnQgY29udGFpbmluZyB0aG9zZSBub2Rlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG5vZGVzKSB7XG4gICAgICAgIGlmICghbm9kZXMpXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGlmIChub2RlcyBpbnN0YW5jZW9mIEZyYWdtZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tQXJyYXkobm9kZXMpO1xuICAgICAgICBpZiAobm9kZXMuYXR0cnMpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KFtub2Rlc10sIG5vZGVzLm5vZGVTaXplKTtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4gbm90IGNvbnZlcnQgXCIgKyBub2RlcyArIFwiIHRvIGEgRnJhZ21lbnRcIiArXG4gICAgICAgICAgICAobm9kZXMubm9kZXNCZXR3ZWVuID8gXCIgKGxvb2tzIGxpa2UgbXVsdGlwbGUgdmVyc2lvbnMgb2YgcHJvc2VtaXJyb3ItbW9kZWwgd2VyZSBsb2FkZWQpXCIgOiBcIlwiKSk7XG4gICAgfVxufVxuLyoqXG5BbiBlbXB0eSBmcmFnbWVudC4gSW50ZW5kZWQgdG8gYmUgcmV1c2VkIHdoZW5ldmVyIGEgbm9kZSBkb2Vzbid0XG5jb250YWluIGFueXRoaW5nIChyYXRoZXIgdGhhbiBhbGxvY2F0aW5nIGEgbmV3IGVtcHR5IGZyYWdtZW50IGZvclxuZWFjaCBsZWFmIG5vZGUpLlxuKi9cbkZyYWdtZW50LmVtcHR5ID0gbmV3IEZyYWdtZW50KFtdLCAwKTtcbmNvbnN0IGZvdW5kID0geyBpbmRleDogMCwgb2Zmc2V0OiAwIH07XG5mdW5jdGlvbiByZXRJbmRleChpbmRleCwgb2Zmc2V0KSB7XG4gICAgZm91bmQuaW5kZXggPSBpbmRleDtcbiAgICBmb3VuZC5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlRGVlcChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghKGEgJiYgdHlwZW9mIGEgPT0gXCJvYmplY3RcIikgfHxcbiAgICAgICAgIShiICYmIHR5cGVvZiBiID09IFwib2JqZWN0XCIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGFycmF5ID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShiKSAhPSBhcnJheSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChhcnJheSkge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghY29tcGFyZURlZXAoYVtpXSwgYltpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgcCBpbiBhKVxuICAgICAgICAgICAgaWYgKCEocCBpbiBiKSB8fCAhY29tcGFyZURlZXAoYVtwXSwgYltwXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBwIGluIGIpXG4gICAgICAgICAgICBpZiAoIShwIGluIGEpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuQSBtYXJrIGlzIGEgcGllY2Ugb2YgaW5mb3JtYXRpb24gdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSBub2RlLFxuc3VjaCBhcyBpdCBiZWluZyBlbXBoYXNpemVkLCBpbiBjb2RlIGZvbnQsIG9yIGEgbGluay4gSXQgaGFzIGFcbnR5cGUgYW5kIG9wdGlvbmFsbHkgYSBzZXQgb2YgYXR0cmlidXRlcyB0aGF0IHByb3ZpZGUgZnVydGhlclxuaW5mb3JtYXRpb24gKHN1Y2ggYXMgdGhlIHRhcmdldCBvZiB0aGUgbGluaykuIE1hcmtzIGFyZSBjcmVhdGVkXG50aHJvdWdoIGEgYFNjaGVtYWAsIHdoaWNoIGNvbnRyb2xzIHdoaWNoIHR5cGVzIGV4aXN0IGFuZCB3aGljaFxuYXR0cmlidXRlcyB0aGV5IGhhdmUuXG4qL1xuY2xhc3MgTWFyayB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiB0aGlzIG1hcmsuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGUgYXR0cmlidXRlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtYXJrLlxuICAgICovXG4gICAgYXR0cnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgIH1cbiAgICAvKipcbiAgICBHaXZlbiBhIHNldCBvZiBtYXJrcywgY3JlYXRlIGEgbmV3IHNldCB3aGljaCBjb250YWlucyB0aGlzIG9uZSBhc1xuICAgIHdlbGwsIGluIHRoZSByaWdodCBwb3NpdGlvbi4gSWYgdGhpcyBtYXJrIGlzIGFscmVhZHkgaW4gdGhlIHNldCxcbiAgICB0aGUgc2V0IGl0c2VsZiBpcyByZXR1cm5lZC4gSWYgYW55IG1hcmtzIHRoYXQgYXJlIHNldCB0byBiZVxuICAgIFtleGNsdXNpdmVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrU3BlYy5leGNsdWRlcykgd2l0aCB0aGlzIG1hcmsgYXJlIHByZXNlbnQsXG4gICAgdGhvc2UgYXJlIHJlcGxhY2VkIGJ5IHRoaXMgb25lLlxuICAgICovXG4gICAgYWRkVG9TZXQoc2V0KSB7XG4gICAgICAgIGxldCBjb3B5LCBwbGFjZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBvdGhlciA9IHNldFtpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKG90aGVyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZS5leGNsdWRlcyhvdGhlci50eXBlKSkge1xuICAgICAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IHNldC5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG90aGVyLnR5cGUuZXhjbHVkZXModGhpcy50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBsYWNlZCAmJiBvdGhlci50eXBlLnJhbmsgPiB0aGlzLnR5cGUucmFuaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gc2V0LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5LnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb3B5KVxuICAgICAgICAgICAgICAgICAgICBjb3B5LnB1c2gob3RoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgIGNvcHkgPSBzZXQuc2xpY2UoKTtcbiAgICAgICAgaWYgKCFwbGFjZWQpXG4gICAgICAgICAgICBjb3B5LnB1c2godGhpcyk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgdGhpcyBtYXJrIGZyb20gdGhlIGdpdmVuIHNldCwgcmV0dXJuaW5nIGEgbmV3IHNldC4gSWYgdGhpc1xuICAgIG1hcmsgaXMgbm90IGluIHRoZSBzZXQsIHRoZSBzZXQgaXRzZWxmIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgcmVtb3ZlRnJvbVNldChzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5lcShzZXRbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXQuc2xpY2UoMCwgaSkuY29uY2F0KHNldC5zbGljZShpICsgMSkpO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhpcyBtYXJrIGlzIGluIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MuXG4gICAgKi9cbiAgICBpc0luU2V0KHNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKHNldFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoaXMgbWFyayBoYXMgdGhlIHNhbWUgdHlwZSBhbmQgYXR0cmlidXRlcyBhc1xuICAgIGFub3RoZXIgbWFyay5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAodGhpcy50eXBlID09IG90aGVyLnR5cGUgJiYgY29tcGFyZURlZXAodGhpcy5hdHRycywgb3RoZXIuYXR0cnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCB0aGlzIG1hcmsgdG8gYSBKU09OLXNlcmlhbGl6ZWFibGUgcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBvYmogPSB7IHR5cGU6IHRoaXMudHlwZS5uYW1lIH07XG4gICAgICAgIGZvciAobGV0IF8gaW4gdGhpcy5hdHRycykge1xuICAgICAgICAgICAgb2JqLmF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgbWFyayBmcm9tIEpTT04uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgTWFyay5mcm9tSlNPTlwiKTtcbiAgICAgICAgbGV0IHR5cGUgPSBzY2hlbWEubWFya3NbanNvbi50eXBlXTtcbiAgICAgICAgaWYgKCF0eXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFRoZXJlIGlzIG5vIG1hcmsgdHlwZSAke2pzb24udHlwZX0gaW4gdGhpcyBzY2hlbWFgKTtcbiAgICAgICAgcmV0dXJuIHR5cGUuY3JlYXRlKGpzb24uYXR0cnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdHdvIHNldHMgb2YgbWFya3MgYXJlIGlkZW50aWNhbC5cbiAgICAqL1xuICAgIHN0YXRpYyBzYW1lU2V0KGEsIGIpIHtcbiAgICAgICAgaWYgKGEgPT0gYilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghYVtpXS5lcShiW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBwcm9wZXJseSBzb3J0ZWQgbWFyayBzZXQgZnJvbSBudWxsLCBhIHNpbmdsZSBtYXJrLCBvciBhblxuICAgIHVuc29ydGVkIGFycmF5IG9mIG1hcmtzLlxuICAgICovXG4gICAgc3RhdGljIHNldEZyb20obWFya3MpIHtcbiAgICAgICAgaWYgKCFtYXJrcyB8fCBBcnJheS5pc0FycmF5KG1hcmtzKSAmJiBtYXJrcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBNYXJrLm5vbmU7XG4gICAgICAgIGlmIChtYXJrcyBpbnN0YW5jZW9mIE1hcmspXG4gICAgICAgICAgICByZXR1cm4gW21hcmtzXTtcbiAgICAgICAgbGV0IGNvcHkgPSBtYXJrcy5zbGljZSgpO1xuICAgICAgICBjb3B5LnNvcnQoKGEsIGIpID0+IGEudHlwZS5yYW5rIC0gYi50eXBlLnJhbmspO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG59XG4vKipcblRoZSBlbXB0eSBzZXQgb2YgbWFya3MuXG4qL1xuTWFyay5ub25lID0gW107XG5cbi8qKlxuRXJyb3IgdHlwZSByYWlzZWQgYnkgW2BOb2RlLnJlcGxhY2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS5yZXBsYWNlKSB3aGVuXG5naXZlbiBhbiBpbnZhbGlkIHJlcGxhY2VtZW50LlxuKi9cbmNsYXNzIFJlcGxhY2VFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbi8qXG5SZXBsYWNlRXJyb3IgPSBmdW5jdGlvbih0aGlzOiBhbnksIG1lc3NhZ2U6IHN0cmluZykge1xuICBsZXQgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKVxuICA7KGVyciBhcyBhbnkpLl9fcHJvdG9fXyA9IFJlcGxhY2VFcnJvci5wcm90b3R5cGVcbiAgcmV0dXJuIGVyclxufSBhcyBhbnlcblxuUmVwbGFjZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKVxuUmVwbGFjZUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlcGxhY2VFcnJvclxuUmVwbGFjZUVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJSZXBsYWNlRXJyb3JcIlxuKi9cbi8qKlxuQSBzbGljZSByZXByZXNlbnRzIGEgcGllY2UgY3V0IG91dCBvZiBhIGxhcmdlciBkb2N1bWVudC4gSXRcbnN0b3JlcyBub3Qgb25seSBhIGZyYWdtZW50LCBidXQgYWxzbyB0aGUgZGVwdGggdXAgdG8gd2hpY2ggbm9kZXMgb25cbmJvdGggc2lkZSBhcmUgXHUyMDE4b3Blblx1MjAxOSAoY3V0IHRocm91Z2gpLlxuKi9cbmNsYXNzIFNsaWNlIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBzbGljZS4gV2hlbiBzcGVjaWZ5aW5nIGEgbm9uLXplcm8gb3BlbiBkZXB0aCwgeW91IG11c3RcbiAgICBtYWtlIHN1cmUgdGhhdCB0aGVyZSBhcmUgbm9kZXMgb2YgYXQgbGVhc3QgdGhhdCBkZXB0aCBhdCB0aGVcbiAgICBhcHByb3ByaWF0ZSBzaWRlIG9mIHRoZSBmcmFnbWVudFx1MjAxNGkuZS4gaWYgdGhlIGZyYWdtZW50IGlzIGFuXG4gICAgZW1wdHkgcGFyYWdyYXBoIG5vZGUsIGBvcGVuU3RhcnRgIGFuZCBgb3BlbkVuZGAgY2FuJ3QgYmUgZ3JlYXRlclxuICAgIHRoYW4gMS5cbiAgICBcbiAgICBJdCBpcyBub3QgbmVjZXNzYXJ5IGZvciB0aGUgY29udGVudCBvZiBvcGVuIG5vZGVzIHRvIGNvbmZvcm0gdG9cbiAgICB0aGUgc2NoZW1hJ3MgY29udGVudCBjb25zdHJhaW50cywgdGhvdWdoIGl0IHNob3VsZCBiZSBhIHZhbGlkXG4gICAgc3RhcnQvZW5kL21pZGRsZSBmb3Igc3VjaCBhIG5vZGUsIGRlcGVuZGluZyBvbiB3aGljaCBzaWRlcyBhcmVcbiAgICBvcGVuLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHNsaWNlJ3MgY29udGVudC5cbiAgICAqL1xuICAgIGNvbnRlbnQsIFxuICAgIC8qKlxuICAgIFRoZSBvcGVuIGRlcHRoIGF0IHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBvcGVuU3RhcnQsIFxuICAgIC8qKlxuICAgIFRoZSBvcGVuIGRlcHRoIGF0IHRoZSBlbmQuXG4gICAgKi9cbiAgICBvcGVuRW5kKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMub3BlblN0YXJ0ID0gb3BlblN0YXJ0O1xuICAgICAgICB0aGlzLm9wZW5FbmQgPSBvcGVuRW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2l6ZSB0aGlzIHNsaWNlIHdvdWxkIGFkZCB3aGVuIGluc2VydGVkIGludG8gYSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LnNpemUgLSB0aGlzLm9wZW5TdGFydCAtIHRoaXMub3BlbkVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpbnNlcnRBdChwb3MsIGZyYWdtZW50KSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gaW5zZXJ0SW50byh0aGlzLmNvbnRlbnQsIHBvcyArIHRoaXMub3BlblN0YXJ0LCBmcmFnbWVudCk7XG4gICAgICAgIHJldHVybiBjb250ZW50ICYmIG5ldyBTbGljZShjb250ZW50LCB0aGlzLm9wZW5TdGFydCwgdGhpcy5vcGVuRW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZW1vdmVCZXR3ZWVuKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UocmVtb3ZlUmFuZ2UodGhpcy5jb250ZW50LCBmcm9tICsgdGhpcy5vcGVuU3RhcnQsIHRvICsgdGhpcy5vcGVuU3RhcnQpLCB0aGlzLm9wZW5TdGFydCwgdGhpcy5vcGVuRW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdHMgd2hldGhlciB0aGlzIHNsaWNlIGlzIGVxdWFsIHRvIGFub3RoZXIgc2xpY2UuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LmVxKG90aGVyLmNvbnRlbnQpICYmIHRoaXMub3BlblN0YXJ0ID09IG90aGVyLm9wZW5TdGFydCAmJiB0aGlzLm9wZW5FbmQgPT0gb3RoZXIub3BlbkVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudCArIFwiKFwiICsgdGhpcy5vcGVuU3RhcnQgKyBcIixcIiArIHRoaXMub3BlbkVuZCArIFwiKVwiO1xuICAgIH1cbiAgICAvKipcbiAgICBDb252ZXJ0IGEgc2xpY2UgdG8gYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQganNvbiA9IHsgY29udGVudDogdGhpcy5jb250ZW50LnRvSlNPTigpIH07XG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA+IDApXG4gICAgICAgICAgICBqc29uLm9wZW5TdGFydCA9IHRoaXMub3BlblN0YXJ0O1xuICAgICAgICBpZiAodGhpcy5vcGVuRW5kID4gMClcbiAgICAgICAgICAgIGpzb24ub3BlbkVuZCA9IHRoaXMub3BlbkVuZDtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgc2xpY2UgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uKVxuICAgICAgICAgICAgcmV0dXJuIFNsaWNlLmVtcHR5O1xuICAgICAgICBsZXQgb3BlblN0YXJ0ID0ganNvbi5vcGVuU3RhcnQgfHwgMCwgb3BlbkVuZCA9IGpzb24ub3BlbkVuZCB8fCAwO1xuICAgICAgICBpZiAodHlwZW9mIG9wZW5TdGFydCAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBvcGVuRW5kICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFNsaWNlLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKEZyYWdtZW50LmZyb21KU09OKHNjaGVtYSwganNvbi5jb250ZW50KSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2xpY2UgZnJvbSBhIGZyYWdtZW50IGJ5IHRha2luZyB0aGUgbWF4aW11bSBwb3NzaWJsZVxuICAgIG9wZW4gdmFsdWUgb24gYm90aCBzaWRlIG9mIHRoZSBmcmFnbWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXhPcGVuKGZyYWdtZW50LCBvcGVuSXNvbGF0aW5nID0gdHJ1ZSkge1xuICAgICAgICBsZXQgb3BlblN0YXJ0ID0gMCwgb3BlbkVuZCA9IDA7XG4gICAgICAgIGZvciAobGV0IG4gPSBmcmFnbWVudC5maXJzdENoaWxkOyBuICYmICFuLmlzTGVhZiAmJiAob3Blbklzb2xhdGluZyB8fCAhbi50eXBlLnNwZWMuaXNvbGF0aW5nKTsgbiA9IG4uZmlyc3RDaGlsZClcbiAgICAgICAgICAgIG9wZW5TdGFydCsrO1xuICAgICAgICBmb3IgKGxldCBuID0gZnJhZ21lbnQubGFzdENoaWxkOyBuICYmICFuLmlzTGVhZiAmJiAob3Blbklzb2xhdGluZyB8fCAhbi50eXBlLnNwZWMuaXNvbGF0aW5nKTsgbiA9IG4ubGFzdENoaWxkKVxuICAgICAgICAgICAgb3BlbkVuZCsrO1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKGZyYWdtZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgIH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNsaWNlLlxuKi9cblNsaWNlLmVtcHR5ID0gbmV3IFNsaWNlKEZyYWdtZW50LmVtcHR5LCAwLCAwKTtcbmZ1bmN0aW9uIHJlbW92ZVJhbmdlKGNvbnRlbnQsIGZyb20sIHRvKSB7XG4gICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gY29udGVudC5maW5kSW5kZXgoZnJvbSksIGNoaWxkID0gY29udGVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICBsZXQgeyBpbmRleDogaW5kZXhUbywgb2Zmc2V0OiBvZmZzZXRUbyB9ID0gY29udGVudC5maW5kSW5kZXgodG8pO1xuICAgIGlmIChvZmZzZXQgPT0gZnJvbSB8fCBjaGlsZC5pc1RleHQpIHtcbiAgICAgICAgaWYgKG9mZnNldFRvICE9IHRvICYmICFjb250ZW50LmNoaWxkKGluZGV4VG8pLmlzVGV4dClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVtb3Zpbmcgbm9uLWZsYXQgcmFuZ2VcIik7XG4gICAgICAgIHJldHVybiBjb250ZW50LmN1dCgwLCBmcm9tKS5hcHBlbmQoY29udGVudC5jdXQodG8pKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9IGluZGV4VG8pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVtb3Zpbmcgbm9uLWZsYXQgcmFuZ2VcIik7XG4gICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBjaGlsZC5jb3B5KHJlbW92ZVJhbmdlKGNoaWxkLmNvbnRlbnQsIGZyb20gLSBvZmZzZXQgLSAxLCB0byAtIG9mZnNldCAtIDEpKSk7XG59XG5mdW5jdGlvbiBpbnNlcnRJbnRvKGNvbnRlbnQsIGRpc3QsIGluc2VydCwgcGFyZW50KSB7XG4gICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gY29udGVudC5maW5kSW5kZXgoZGlzdCksIGNoaWxkID0gY29udGVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICBpZiAob2Zmc2V0ID09IGRpc3QgfHwgY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCwgaW5zZXJ0KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gY29udGVudC5jdXQoMCwgZGlzdCkuYXBwZW5kKGluc2VydCkuYXBwZW5kKGNvbnRlbnQuY3V0KGRpc3QpKTtcbiAgICB9XG4gICAgbGV0IGlubmVyID0gaW5zZXJ0SW50byhjaGlsZC5jb250ZW50LCBkaXN0IC0gb2Zmc2V0IC0gMSwgaW5zZXJ0KTtcbiAgICByZXR1cm4gaW5uZXIgJiYgY29udGVudC5yZXBsYWNlQ2hpbGQoaW5kZXgsIGNoaWxkLmNvcHkoaW5uZXIpKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2UoJGZyb20sICR0bywgc2xpY2UpIHtcbiAgICBpZiAoc2xpY2Uub3BlblN0YXJ0ID4gJGZyb20uZGVwdGgpXG4gICAgICAgIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbnNlcnRlZCBjb250ZW50IGRlZXBlciB0aGFuIGluc2VydGlvbiBwb3NpdGlvblwiKTtcbiAgICBpZiAoJGZyb20uZGVwdGggLSBzbGljZS5vcGVuU3RhcnQgIT0gJHRvLmRlcHRoIC0gc2xpY2Uub3BlbkVuZClcbiAgICAgICAgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkluY29uc2lzdGVudCBvcGVuIGRlcHRoc1wiKTtcbiAgICByZXR1cm4gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCAwKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VPdXRlcigkZnJvbSwgJHRvLCBzbGljZSwgZGVwdGgpIHtcbiAgICBsZXQgaW5kZXggPSAkZnJvbS5pbmRleChkZXB0aCksIG5vZGUgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICBpZiAoaW5kZXggPT0gJHRvLmluZGV4KGRlcHRoKSAmJiBkZXB0aCA8ICRmcm9tLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0KSB7XG4gICAgICAgIGxldCBpbm5lciA9IHJlcGxhY2VPdXRlcigkZnJvbSwgJHRvLCBzbGljZSwgZGVwdGggKyAxKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuY29weShub2RlLmNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBpbm5lcikpO1xuICAgIH1cbiAgICBlbHNlIGlmICghc2xpY2UuY29udGVudC5zaXplKSB7XG4gICAgICAgIHJldHVybiBjbG9zZShub2RlLCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFzbGljZS5vcGVuU3RhcnQgJiYgIXNsaWNlLm9wZW5FbmQgJiYgJGZyb20uZGVwdGggPT0gZGVwdGggJiYgJHRvLmRlcHRoID09IGRlcHRoKSB7IC8vIFNpbXBsZSwgZmxhdCBjYXNlXG4gICAgICAgIGxldCBwYXJlbnQgPSAkZnJvbS5wYXJlbnQsIGNvbnRlbnQgPSBwYXJlbnQuY29udGVudDtcbiAgICAgICAgcmV0dXJuIGNsb3NlKHBhcmVudCwgY29udGVudC5jdXQoMCwgJGZyb20ucGFyZW50T2Zmc2V0KS5hcHBlbmQoc2xpY2UuY29udGVudCkuYXBwZW5kKGNvbnRlbnQuY3V0KCR0by5wYXJlbnRPZmZzZXQpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBwcmVwYXJlU2xpY2VGb3JSZXBsYWNlKHNsaWNlLCAkZnJvbSk7XG4gICAgICAgIHJldHVybiBjbG9zZShub2RlLCByZXBsYWNlVGhyZWVXYXkoJGZyb20sIHN0YXJ0LCBlbmQsICR0bywgZGVwdGgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0pvaW4obWFpbiwgc3ViKSB7XG4gICAgaWYgKCFzdWIudHlwZS5jb21wYXRpYmxlQ29udGVudChtYWluLnR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiQ2Fubm90IGpvaW4gXCIgKyBzdWIudHlwZS5uYW1lICsgXCIgb250byBcIiArIG1haW4udHlwZS5uYW1lKTtcbn1cbmZ1bmN0aW9uIGpvaW5hYmxlKCRiZWZvcmUsICRhZnRlciwgZGVwdGgpIHtcbiAgICBsZXQgbm9kZSA9ICRiZWZvcmUubm9kZShkZXB0aCk7XG4gICAgY2hlY2tKb2luKG5vZGUsICRhZnRlci5ub2RlKGRlcHRoKSk7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBhZGROb2RlKGNoaWxkLCB0YXJnZXQpIHtcbiAgICBsZXQgbGFzdCA9IHRhcmdldC5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0ID49IDAgJiYgY2hpbGQuaXNUZXh0ICYmIGNoaWxkLnNhbWVNYXJrdXAodGFyZ2V0W2xhc3RdKSlcbiAgICAgICAgdGFyZ2V0W2xhc3RdID0gY2hpbGQud2l0aFRleHQodGFyZ2V0W2xhc3RdLnRleHQgKyBjaGlsZC50ZXh0KTtcbiAgICBlbHNlXG4gICAgICAgIHRhcmdldC5wdXNoKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGFkZFJhbmdlKCRzdGFydCwgJGVuZCwgZGVwdGgsIHRhcmdldCkge1xuICAgIGxldCBub2RlID0gKCRlbmQgfHwgJHN0YXJ0KS5ub2RlKGRlcHRoKTtcbiAgICBsZXQgc3RhcnRJbmRleCA9IDAsIGVuZEluZGV4ID0gJGVuZCA/ICRlbmQuaW5kZXgoZGVwdGgpIDogbm9kZS5jaGlsZENvdW50O1xuICAgIGlmICgkc3RhcnQpIHtcbiAgICAgICAgc3RhcnRJbmRleCA9ICRzdGFydC5pbmRleChkZXB0aCk7XG4gICAgICAgIGlmICgkc3RhcnQuZGVwdGggPiBkZXB0aCkge1xuICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCRzdGFydC50ZXh0T2Zmc2V0KSB7XG4gICAgICAgICAgICBhZGROb2RlKCRzdGFydC5ub2RlQWZ0ZXIsIHRhcmdldCk7XG4gICAgICAgICAgICBzdGFydEluZGV4Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKVxuICAgICAgICBhZGROb2RlKG5vZGUuY2hpbGQoaSksIHRhcmdldCk7XG4gICAgaWYgKCRlbmQgJiYgJGVuZC5kZXB0aCA9PSBkZXB0aCAmJiAkZW5kLnRleHRPZmZzZXQpXG4gICAgICAgIGFkZE5vZGUoJGVuZC5ub2RlQmVmb3JlLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gY2xvc2Uobm9kZSwgY29udGVudCkge1xuICAgIG5vZGUudHlwZS5jaGVja0NvbnRlbnQoY29udGVudCk7XG4gICAgcmV0dXJuIG5vZGUuY29weShjb250ZW50KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VUaHJlZVdheSgkZnJvbSwgJHN0YXJ0LCAkZW5kLCAkdG8sIGRlcHRoKSB7XG4gICAgbGV0IG9wZW5TdGFydCA9ICRmcm9tLmRlcHRoID4gZGVwdGggJiYgam9pbmFibGUoJGZyb20sICRzdGFydCwgZGVwdGggKyAxKTtcbiAgICBsZXQgb3BlbkVuZCA9ICR0by5kZXB0aCA+IGRlcHRoICYmIGpvaW5hYmxlKCRlbmQsICR0bywgZGVwdGggKyAxKTtcbiAgICBsZXQgY29udGVudCA9IFtdO1xuICAgIGFkZFJhbmdlKG51bGwsICRmcm9tLCBkZXB0aCwgY29udGVudCk7XG4gICAgaWYgKG9wZW5TdGFydCAmJiBvcGVuRW5kICYmICRzdGFydC5pbmRleChkZXB0aCkgPT0gJGVuZC5pbmRleChkZXB0aCkpIHtcbiAgICAgICAgY2hlY2tKb2luKG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIGFkZE5vZGUoY2xvc2Uob3BlblN0YXJ0LCByZXBsYWNlVGhyZWVXYXkoJGZyb20sICRzdGFydCwgJGVuZCwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAob3BlblN0YXJ0KVxuICAgICAgICAgICAgYWRkTm9kZShjbG9zZShvcGVuU3RhcnQsIHJlcGxhY2VUd29XYXkoJGZyb20sICRzdGFydCwgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgICAgICBhZGRSYW5nZSgkc3RhcnQsICRlbmQsIGRlcHRoLCBjb250ZW50KTtcbiAgICAgICAgaWYgKG9wZW5FbmQpXG4gICAgICAgICAgICBhZGROb2RlKGNsb3NlKG9wZW5FbmQsIHJlcGxhY2VUd29XYXkoJGVuZCwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgfVxuICAgIGFkZFJhbmdlKCR0bywgbnVsbCwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29udGVudCk7XG59XG5mdW5jdGlvbiByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBbXTtcbiAgICBhZGRSYW5nZShudWxsLCAkZnJvbSwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIGlmICgkZnJvbS5kZXB0aCA+IGRlcHRoKSB7XG4gICAgICAgIGxldCB0eXBlID0gam9pbmFibGUoJGZyb20sICR0bywgZGVwdGggKyAxKTtcbiAgICAgICAgYWRkTm9kZShjbG9zZSh0eXBlLCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgICB9XG4gICAgYWRkUmFuZ2UoJHRvLCBudWxsLCBkZXB0aCwgY29udGVudCk7XG4gICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVTbGljZUZvclJlcGxhY2Uoc2xpY2UsICRhbG9uZykge1xuICAgIGxldCBleHRyYSA9ICRhbG9uZy5kZXB0aCAtIHNsaWNlLm9wZW5TdGFydCwgcGFyZW50ID0gJGFsb25nLm5vZGUoZXh0cmEpO1xuICAgIGxldCBub2RlID0gcGFyZW50LmNvcHkoc2xpY2UuY29udGVudCk7XG4gICAgZm9yIChsZXQgaSA9IGV4dHJhIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIG5vZGUgPSAkYWxvbmcubm9kZShpKS5jb3B5KEZyYWdtZW50LmZyb20obm9kZSkpO1xuICAgIHJldHVybiB7IHN0YXJ0OiBub2RlLnJlc29sdmVOb0NhY2hlKHNsaWNlLm9wZW5TdGFydCArIGV4dHJhKSxcbiAgICAgICAgZW5kOiBub2RlLnJlc29sdmVOb0NhY2hlKG5vZGUuY29udGVudC5zaXplIC0gc2xpY2Uub3BlbkVuZCAtIGV4dHJhKSB9O1xufVxuXG4vKipcbllvdSBjYW4gW19yZXNvbHZlX10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUucmVzb2x2ZSkgYSBwb3NpdGlvbiB0byBnZXQgbW9yZVxuaW5mb3JtYXRpb24gYWJvdXQgaXQuIE9iamVjdHMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgc3VjaCBhXG5yZXNvbHZlZCBwb3NpdGlvbiwgcHJvdmlkaW5nIHZhcmlvdXMgcGllY2VzIG9mIGNvbnRleHRcbmluZm9ybWF0aW9uLCBhbmQgc29tZSBoZWxwZXIgbWV0aG9kcy5cblxuVGhyb3VnaG91dCB0aGlzIGludGVyZmFjZSwgbWV0aG9kcyB0aGF0IHRha2UgYW4gb3B0aW9uYWwgYGRlcHRoYFxucGFyYW1ldGVyIHdpbGwgaW50ZXJwcmV0IHVuZGVmaW5lZCBhcyBgdGhpcy5kZXB0aGAgYW5kIG5lZ2F0aXZlXG5udW1iZXJzIGFzIGB0aGlzLmRlcHRoICsgdmFsdWVgLlxuKi9cbmNsYXNzIFJlc29sdmVkUG9zIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiB0aGF0IHdhcyByZXNvbHZlZC5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwYXRoLCBcbiAgICAvKipcbiAgICBUaGUgb2Zmc2V0IHRoaXMgcG9zaXRpb24gaGFzIGludG8gaXRzIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgcGFyZW50T2Zmc2V0KSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLnBhcmVudE9mZnNldCA9IHBhcmVudE9mZnNldDtcbiAgICAgICAgdGhpcy5kZXB0aCA9IHBhdGgubGVuZ3RoIC8gMyAtIDE7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzb2x2ZURlcHRoKHZhbCkge1xuICAgICAgICBpZiAodmFsID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXB0aDtcbiAgICAgICAgaWYgKHZhbCA8IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXB0aCArIHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHBhcmVudCBub2RlIHRoYXQgdGhlIHBvc2l0aW9uIHBvaW50cyBpbnRvLiBOb3RlIHRoYXQgZXZlbiBpZlxuICAgIGEgcG9zaXRpb24gcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIHRoYXQgbm9kZSBpcyBub3QgY29uc2lkZXJlZFxuICAgIHRoZSBwYXJlbnRcdTIwMTR0ZXh0IG5vZGVzIGFyZSBcdTIwMThmbGF0XHUyMDE5IGluIHRoaXMgbW9kZWwsIGFuZCBoYXZlIG5vIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgcGFyZW50KCkgeyByZXR1cm4gdGhpcy5ub2RlKHRoaXMuZGVwdGgpOyB9XG4gICAgLyoqXG4gICAgVGhlIHJvb3Qgbm9kZSBpbiB3aGljaCB0aGUgcG9zaXRpb24gd2FzIHJlc29sdmVkLlxuICAgICovXG4gICAgZ2V0IGRvYygpIHsgcmV0dXJuIHRoaXMubm9kZSgwKTsgfVxuICAgIC8qKlxuICAgIFRoZSBhbmNlc3RvciBub2RlIGF0IHRoZSBnaXZlbiBsZXZlbC4gYHAubm9kZShwLmRlcHRoKWAgaXMgdGhlXG4gICAgc2FtZSBhcyBgcC5wYXJlbnRgLlxuICAgICovXG4gICAgbm9kZShkZXB0aCkgeyByZXR1cm4gdGhpcy5wYXRoW3RoaXMucmVzb2x2ZURlcHRoKGRlcHRoKSAqIDNdOyB9XG4gICAgLyoqXG4gICAgVGhlIGluZGV4IGludG8gdGhlIGFuY2VzdG9yIGF0IHRoZSBnaXZlbiBsZXZlbC4gSWYgdGhpcyBwb2ludHNcbiAgICBhdCB0aGUgM3JkIG5vZGUgaW4gdGhlIDJuZCBwYXJhZ3JhcGggb24gdGhlIHRvcCBsZXZlbCwgZm9yXG4gICAgZXhhbXBsZSwgYHAuaW5kZXgoMClgIGlzIDEgYW5kIGBwLmluZGV4KDEpYCBpcyAyLlxuICAgICovXG4gICAgaW5kZXgoZGVwdGgpIHsgcmV0dXJuIHRoaXMucGF0aFt0aGlzLnJlc29sdmVEZXB0aChkZXB0aCkgKiAzICsgMV07IH1cbiAgICAvKipcbiAgICBUaGUgaW5kZXggcG9pbnRpbmcgYWZ0ZXIgdGhpcyBwb3NpdGlvbiBpbnRvIHRoZSBhbmNlc3RvciBhdCB0aGVcbiAgICBnaXZlbiBsZXZlbC5cbiAgICAqL1xuICAgIGluZGV4QWZ0ZXIoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4KGRlcHRoKSArIChkZXB0aCA9PSB0aGlzLmRlcHRoICYmICF0aGlzLnRleHRPZmZzZXQgPyAwIDogMSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGF0IHRoZSBzdGFydCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW5cbiAgICBsZXZlbC5cbiAgICAqL1xuICAgIHN0YXJ0KGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICByZXR1cm4gZGVwdGggPT0gMCA/IDAgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV0gKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBub2RlIGF0IHRoZSBnaXZlblxuICAgIGxldmVsLlxuICAgICovXG4gICAgZW5kKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydChkZXB0aCkgKyB0aGlzLm5vZGUoZGVwdGgpLmNvbnRlbnQuc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gZGlyZWN0bHkgYmVmb3JlIHRoZSB3cmFwcGluZyBub2RlIGF0IHRoZVxuICAgIGdpdmVuIGxldmVsLCBvciwgd2hlbiBgZGVwdGhgIGlzIGB0aGlzLmRlcHRoICsgMWAsIHRoZSBvcmlnaW5hbFxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgYmVmb3JlKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGVyZSBpcyBubyBwb3NpdGlvbiBiZWZvcmUgdGhlIHRvcC1sZXZlbCBub2RlXCIpO1xuICAgICAgICByZXR1cm4gZGVwdGggPT0gdGhpcy5kZXB0aCArIDEgPyB0aGlzLnBvcyA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gZGlyZWN0bHkgYWZ0ZXIgdGhlIHdyYXBwaW5nIG5vZGUgYXQgdGhlXG4gICAgZ2l2ZW4gbGV2ZWwsIG9yIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiB3aGVuIGBkZXB0aGAgaXMgYHRoaXMuZGVwdGggKyAxYC5cbiAgICAqL1xuICAgIGFmdGVyKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGVyZSBpcyBubyBwb3NpdGlvbiBhZnRlciB0aGUgdG9wLWxldmVsIG5vZGVcIik7XG4gICAgICAgIHJldHVybiBkZXB0aCA9PSB0aGlzLmRlcHRoICsgMSA/IHRoaXMucG9zIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgdGhpcy5wYXRoW2RlcHRoICogM10ubm9kZVNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZW4gdGhpcyBwb3NpdGlvbiBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgdGhpcyByZXR1cm5zIHRoZVxuICAgIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvc2l0aW9uIGFuZCB0aGUgc3RhcnQgb2YgdGhlIHRleHQgbm9kZS5cbiAgICBXaWxsIGJlIHplcm8gZm9yIHBvc2l0aW9ucyB0aGF0IHBvaW50IGJldHdlZW4gbm9kZXMuXG4gICAgKi9cbiAgICBnZXQgdGV4dE9mZnNldCgpIHsgcmV0dXJuIHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbm9kZSBkaXJlY3RseSBhZnRlciB0aGUgcG9zaXRpb24sIGlmIGFueS4gSWYgdGhlIHBvc2l0aW9uXG4gICAgcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIG9ubHkgdGhlIHBhcnQgb2YgdGhhdCBub2RlIGFmdGVyIHRoZVxuICAgIHBvc2l0aW9uIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgZ2V0IG5vZGVBZnRlcigpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50LCBpbmRleCA9IHRoaXMuaW5kZXgodGhpcy5kZXB0aCk7XG4gICAgICAgIGlmIChpbmRleCA9PSBwYXJlbnQuY2hpbGRDb3VudClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZE9mZiA9IHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXSwgY2hpbGQgPSBwYXJlbnQuY2hpbGQoaW5kZXgpO1xuICAgICAgICByZXR1cm4gZE9mZiA/IHBhcmVudC5jaGlsZChpbmRleCkuY3V0KGRPZmYpIDogY2hpbGQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbm9kZSBkaXJlY3RseSBiZWZvcmUgdGhlIHBvc2l0aW9uLCBpZiBhbnkuIElmIHRoZVxuICAgIHBvc2l0aW9uIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCBvbmx5IHRoZSBwYXJ0IG9mIHRoYXQgbm9kZVxuICAgIGJlZm9yZSB0aGUgcG9zaXRpb24gaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICBnZXQgbm9kZUJlZm9yZSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5pbmRleCh0aGlzLmRlcHRoKTtcbiAgICAgICAgbGV0IGRPZmYgPSB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChkT2ZmKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkKGluZGV4KS5jdXQoMCwgZE9mZik7XG4gICAgICAgIHJldHVybiBpbmRleCA9PSAwID8gbnVsbCA6IHRoaXMucGFyZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcG9zaXRpb24gYXQgdGhlIGdpdmVuIGluZGV4IGluIHRoZSBwYXJlbnQgbm9kZSBhdCB0aGVcbiAgICBnaXZlbiBkZXB0aCAod2hpY2ggZGVmYXVsdHMgdG8gYHRoaXMuZGVwdGhgKS5cbiAgICAqL1xuICAgIHBvc0F0SW5kZXgoaW5kZXgsIGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMucGF0aFtkZXB0aCAqIDNdLCBwb3MgPSBkZXB0aCA9PSAwID8gMCA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcbiAgICAgICAgICAgIHBvcyArPSBub2RlLmNoaWxkKGkpLm5vZGVTaXplO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG1hcmtzIGF0IHRoaXMgcG9zaXRpb24sIGZhY3RvcmluZyBpbiB0aGUgc3Vycm91bmRpbmdcbiAgICBtYXJrcycgW2BpbmNsdXNpdmVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1NwZWMuaW5jbHVzaXZlKSBwcm9wZXJ0eS4gSWYgdGhlXG4gICAgcG9zaXRpb24gaXMgYXQgdGhlIHN0YXJ0IG9mIGEgbm9uLWVtcHR5IG5vZGUsIHRoZSBtYXJrcyBvZiB0aGVcbiAgICBub2RlIGFmdGVyIGl0IChpZiBhbnkpIGFyZSByZXR1cm5lZC5cbiAgICAqL1xuICAgIG1hcmtzKCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQsIGluZGV4ID0gdGhpcy5pbmRleCgpO1xuICAgICAgICAvLyBJbiBhbiBlbXB0eSBwYXJlbnQsIHJldHVybiB0aGUgZW1wdHkgYXJyYXlcbiAgICAgICAgaWYgKHBhcmVudC5jb250ZW50LnNpemUgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBNYXJrLm5vbmU7XG4gICAgICAgIC8vIFdoZW4gaW5zaWRlIGEgdGV4dCBub2RlLCBqdXN0IHJldHVybiB0aGUgdGV4dCBub2RlJ3MgbWFya3NcbiAgICAgICAgaWYgKHRoaXMudGV4dE9mZnNldClcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuY2hpbGQoaW5kZXgpLm1hcmtzO1xuICAgICAgICBsZXQgbWFpbiA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4IC0gMSksIG90aGVyID0gcGFyZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAvLyBJZiB0aGUgYGFmdGVyYCBmbGFnIGlzIHRydWUgb2YgdGhlcmUgaXMgbm8gbm9kZSBiZWZvcmUsIG1ha2VcbiAgICAgICAgLy8gdGhlIG5vZGUgYWZ0ZXIgdGhpcyBwb3NpdGlvbiB0aGUgbWFpbiByZWZlcmVuY2UuXG4gICAgICAgIGlmICghbWFpbikge1xuICAgICAgICAgICAgbGV0IHRtcCA9IG1haW47XG4gICAgICAgICAgICBtYWluID0gb3RoZXI7XG4gICAgICAgICAgICBvdGhlciA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgYWxsIG1hcmtzIGluIHRoZSBtYWluIG5vZGUsIGV4Y2VwdCB0aG9zZSB0aGF0IGhhdmVcbiAgICAgICAgLy8gYGluY2x1c2l2ZWAgc2V0IHRvIGZhbHNlIGFuZCBhcmUgbm90IHByZXNlbnQgaW4gdGhlIG90aGVyIG5vZGUuXG4gICAgICAgIGxldCBtYXJrcyA9IG1haW4ubWFya3M7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobWFya3NbaV0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UgJiYgKCFvdGhlciB8fCAhbWFya3NbaV0uaXNJblNldChvdGhlci5tYXJrcykpKVxuICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3NbaS0tXS5yZW1vdmVGcm9tU2V0KG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG1hcmtzIGFmdGVyIHRoZSBjdXJyZW50IHBvc2l0aW9uLCBpZiBhbnksIGV4Y2VwdCB0aG9zZVxuICAgIHRoYXQgYXJlIG5vbi1pbmNsdXNpdmUgYW5kIG5vdCBwcmVzZW50IGF0IHBvc2l0aW9uIGAkZW5kYC4gVGhpc1xuICAgIGlzIG1vc3RseSB1c2VmdWwgZm9yIGdldHRpbmcgdGhlIHNldCBvZiBtYXJrcyB0byBwcmVzZXJ2ZSBhZnRlciBhXG4gICAgZGVsZXRpb24uIFdpbGwgcmV0dXJuIGBudWxsYCBpZiB0aGlzIHBvc2l0aW9uIGlzIGF0IHRoZSBlbmQgb2ZcbiAgICBpdHMgcGFyZW50IG5vZGUgb3IgaXRzIHBhcmVudCBub2RlIGlzbid0IGEgdGV4dGJsb2NrIChpbiB3aGljaFxuICAgIGNhc2Ugbm8gbWFya3Mgc2hvdWxkIGJlIHByZXNlcnZlZCkuXG4gICAgKi9cbiAgICBtYXJrc0Fjcm9zcygkZW5kKSB7XG4gICAgICAgIGxldCBhZnRlciA9IHRoaXMucGFyZW50Lm1heWJlQ2hpbGQodGhpcy5pbmRleCgpKTtcbiAgICAgICAgaWYgKCFhZnRlciB8fCAhYWZ0ZXIuaXNJbmxpbmUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IG1hcmtzID0gYWZ0ZXIubWFya3MsIG5leHQgPSAkZW5kLnBhcmVudC5tYXliZUNoaWxkKCRlbmQuaW5kZXgoKSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobWFya3NbaV0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UgJiYgKCFuZXh0IHx8ICFtYXJrc1tpXS5pc0luU2V0KG5leHQubWFya3MpKSlcbiAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzW2ktLV0ucmVtb3ZlRnJvbVNldChtYXJrcyk7XG4gICAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGRlcHRoIHVwIHRvIHdoaWNoIHRoaXMgcG9zaXRpb24gYW5kIHRoZSBnaXZlbiAobm9uLXJlc29sdmVkKVxuICAgIHBvc2l0aW9uIHNoYXJlIHRoZSBzYW1lIHBhcmVudCBub2Rlcy5cbiAgICAqL1xuICAgIHNoYXJlZERlcHRoKHBvcykge1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9IHRoaXMuZGVwdGg7IGRlcHRoID4gMDsgZGVwdGgtLSlcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0KGRlcHRoKSA8PSBwb3MgJiYgdGhpcy5lbmQoZGVwdGgpID49IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVwdGg7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGEgcmFuZ2UgYmFzZWQgb24gdGhlIHBsYWNlIHdoZXJlIHRoaXMgcG9zaXRpb24gYW5kIHRoZVxuICAgIGdpdmVuIHBvc2l0aW9uIGRpdmVyZ2UgYXJvdW5kIGJsb2NrIGNvbnRlbnQuIElmIGJvdGggcG9pbnQgaW50b1xuICAgIHRoZSBzYW1lIHRleHRibG9jaywgZm9yIGV4YW1wbGUsIGEgcmFuZ2UgYXJvdW5kIHRoYXQgdGV4dGJsb2NrXG4gICAgd2lsbCBiZSByZXR1cm5lZC4gSWYgdGhleSBwb2ludCBpbnRvIGRpZmZlcmVudCBibG9ja3MsIHRoZSByYW5nZVxuICAgIGFyb3VuZCB0aG9zZSBibG9ja3MgaW4gdGhlaXIgc2hhcmVkIGFuY2VzdG9yIGlzIHJldHVybmVkLiBZb3UgY2FuXG4gICAgcGFzcyBpbiBhbiBvcHRpb25hbCBwcmVkaWNhdGUgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgcGFyZW50XG4gICAgbm9kZSB0byBzZWUgaWYgYSByYW5nZSBpbnRvIHRoYXQgcGFyZW50IGlzIGFjY2VwdGFibGUuXG4gICAgKi9cbiAgICBibG9ja1JhbmdlKG90aGVyID0gdGhpcywgcHJlZCkge1xuICAgICAgICBpZiAob3RoZXIucG9zIDwgdGhpcy5wb3MpXG4gICAgICAgICAgICByZXR1cm4gb3RoZXIuYmxvY2tSYW5nZSh0aGlzKTtcbiAgICAgICAgZm9yIChsZXQgZCA9IHRoaXMuZGVwdGggLSAodGhpcy5wYXJlbnQuaW5saW5lQ29udGVudCB8fCB0aGlzLnBvcyA9PSBvdGhlci5wb3MgPyAxIDogMCk7IGQgPj0gMDsgZC0tKVxuICAgICAgICAgICAgaWYgKG90aGVyLnBvcyA8PSB0aGlzLmVuZChkKSAmJiAoIXByZWQgfHwgcHJlZCh0aGlzLm5vZGUoZCkpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVSYW5nZSh0aGlzLCBvdGhlciwgZCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBRdWVyeSB3aGV0aGVyIHRoZSBnaXZlbiBwb3NpdGlvbiBzaGFyZXMgdGhlIHNhbWUgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBzYW1lUGFyZW50KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyAtIHRoaXMucGFyZW50T2Zmc2V0ID09IG90aGVyLnBvcyAtIG90aGVyLnBhcmVudE9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRoZSBncmVhdGVyIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIG1heChvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIucG9zID4gdGhpcy5wb3MgPyBvdGhlciA6IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgc21hbGxlciBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBtaW4ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLnBvcyA8IHRoaXMucG9zID8gb3RoZXIgOiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgc3RyID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdGhpcy5kZXB0aDsgaSsrKVxuICAgICAgICAgICAgc3RyICs9IChzdHIgPyBcIi9cIiA6IFwiXCIpICsgdGhpcy5ub2RlKGkpLnR5cGUubmFtZSArIFwiX1wiICsgdGhpcy5pbmRleChpIC0gMSk7XG4gICAgICAgIHJldHVybiBzdHIgKyBcIjpcIiArIHRoaXMucGFyZW50T2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyByZXNvbHZlKGRvYywgcG9zKSB7XG4gICAgICAgIGlmICghKHBvcyA+PSAwICYmIHBvcyA8PSBkb2MuY29udGVudC5zaXplKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUG9zaXRpb24gXCIgKyBwb3MgKyBcIiBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgIGxldCBwYXRoID0gW107XG4gICAgICAgIGxldCBzdGFydCA9IDAsIHBhcmVudE9mZnNldCA9IHBvcztcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IGRvYzs7KSB7XG4gICAgICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KHBhcmVudE9mZnNldCk7XG4gICAgICAgICAgICBsZXQgcmVtID0gcGFyZW50T2Zmc2V0IC0gb2Zmc2V0O1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUsIGluZGV4LCBzdGFydCArIG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoIXJlbSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChub2RlLmlzVGV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBhcmVudE9mZnNldCA9IHJlbSAtIDE7XG4gICAgICAgICAgICBzdGFydCArPSBvZmZzZXQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRQb3MocG9zLCBwYXRoLCBwYXJlbnRPZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyByZXNvbHZlQ2FjaGVkKGRvYywgcG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzb2x2ZUNhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2FjaGVkID0gcmVzb2x2ZUNhY2hlW2ldO1xuICAgICAgICAgICAgaWYgKGNhY2hlZC5wb3MgPT0gcG9zICYmIGNhY2hlZC5kb2MgPT0gZG9jKVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IHJlc29sdmVDYWNoZVtyZXNvbHZlQ2FjaGVQb3NdID0gUmVzb2x2ZWRQb3MucmVzb2x2ZShkb2MsIHBvcyk7XG4gICAgICAgIHJlc29sdmVDYWNoZVBvcyA9IChyZXNvbHZlQ2FjaGVQb3MgKyAxKSAlIHJlc29sdmVDYWNoZVNpemU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxubGV0IHJlc29sdmVDYWNoZSA9IFtdLCByZXNvbHZlQ2FjaGVQb3MgPSAwLCByZXNvbHZlQ2FjaGVTaXplID0gMTI7XG4vKipcblJlcHJlc2VudHMgYSBmbGF0IHJhbmdlIG9mIGNvbnRlbnQsIGkuZS4gb25lIHRoYXQgc3RhcnRzIGFuZFxuZW5kcyBpbiB0aGUgc2FtZSBub2RlLlxuKi9cbmNsYXNzIE5vZGVSYW5nZSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbm9kZSByYW5nZS4gYCRmcm9tYCBhbmQgYCR0b2Agc2hvdWxkIHBvaW50IGludG8gdGhlXG4gICAgc2FtZSBub2RlIHVudGlsIGF0IGxlYXN0IHRoZSBnaXZlbiBgZGVwdGhgLCBzaW5jZSBhIG5vZGUgcmFuZ2VcbiAgICBkZW5vdGVzIGFuIGFkamFjZW50IHNldCBvZiBub2RlcyBpbiBhIHNpbmdsZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEEgcmVzb2x2ZWQgcG9zaXRpb24gYWxvbmcgdGhlIHN0YXJ0IG9mIHRoZSBjb250ZW50LiBNYXkgaGF2ZSBhXG4gICAgYGRlcHRoYCBncmVhdGVyIHRoYW4gdGhpcyBvYmplY3QncyBgZGVwdGhgIHByb3BlcnR5LCBzaW5jZVxuICAgIHRoZXNlIGFyZSB0aGUgcG9zaXRpb25zIHRoYXQgd2VyZSB1c2VkIHRvIGNvbXB1dGUgdGhlIHJhbmdlLFxuICAgIG5vdCByZS1yZXNvbHZlZCBwb3NpdGlvbnMgZGlyZWN0bHkgYXQgaXRzIGJvdW5kYXJpZXMuXG4gICAgKi9cbiAgICAkZnJvbSwgXG4gICAgLyoqXG4gICAgQSBwb3NpdGlvbiBhbG9uZyB0aGUgZW5kIG9mIHRoZSBjb250ZW50LiBTZWVcbiAgICBjYXZlYXQgZm9yIFtgJGZyb21gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVJhbmdlLiRmcm9tKS5cbiAgICAqL1xuICAgICR0bywgXG4gICAgLyoqXG4gICAgVGhlIGRlcHRoIG9mIHRoZSBub2RlIHRoYXQgdGhpcyByYW5nZSBwb2ludHMgaW50by5cbiAgICAqL1xuICAgIGRlcHRoKSB7XG4gICAgICAgIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgICAgICAgdGhpcy4kdG8gPSAkdG87XG4gICAgICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLiRmcm9tLmJlZm9yZSh0aGlzLmRlcHRoICsgMSk7IH1cbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy4kdG8uYWZ0ZXIodGhpcy5kZXB0aCArIDEpOyB9XG4gICAgLyoqXG4gICAgVGhlIHBhcmVudCBub2RlIHRoYXQgdGhlIHJhbmdlIHBvaW50cyBpbnRvLlxuICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHsgcmV0dXJuIHRoaXMuJGZyb20ubm9kZSh0aGlzLmRlcHRoKTsgfVxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBpbmRleCBvZiB0aGUgcmFuZ2UgaW4gdGhlIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgZ2V0IHN0YXJ0SW5kZXgoKSB7IHJldHVybiB0aGlzLiRmcm9tLmluZGV4KHRoaXMuZGVwdGgpOyB9XG4gICAgLyoqXG4gICAgVGhlIGVuZCBpbmRleCBvZiB0aGUgcmFuZ2UgaW4gdGhlIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgZ2V0IGVuZEluZGV4KCkgeyByZXR1cm4gdGhpcy4kdG8uaW5kZXhBZnRlcih0aGlzLmRlcHRoKTsgfVxufVxuXG5jb25zdCBlbXB0eUF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgbm9kZSBpbiB0aGUgdHJlZSB0aGF0IG1ha2VzIHVwIGFcblByb3NlTWlycm9yIGRvY3VtZW50LiBTbyBhIGRvY3VtZW50IGlzIGFuIGluc3RhbmNlIG9mIGBOb2RlYCwgd2l0aFxuY2hpbGRyZW4gdGhhdCBhcmUgYWxzbyBpbnN0YW5jZXMgb2YgYE5vZGVgLlxuXG5Ob2RlcyBhcmUgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZXMuIEluc3RlYWQgb2YgY2hhbmdpbmcgdGhlbSwgeW91XG5jcmVhdGUgbmV3IG9uZXMgd2l0aCB0aGUgY29udGVudCB5b3Ugd2FudC4gT2xkIG9uZXMga2VlcCBwb2ludGluZ1xuYXQgdGhlIG9sZCBkb2N1bWVudCBzaGFwZS4gVGhpcyBpcyBtYWRlIGNoZWFwZXIgYnkgc2hhcmluZ1xuc3RydWN0dXJlIGJldHdlZW4gdGhlIG9sZCBhbmQgbmV3IGRhdGEgYXMgbXVjaCBhcyBwb3NzaWJsZSwgd2hpY2ggYVxudHJlZSBzaGFwZSBsaWtlIHRoaXMgKHdpdGhvdXQgYmFjayBwb2ludGVycykgbWFrZXMgZWFzeS5cblxuKipEbyBub3QqKiBkaXJlY3RseSBtdXRhdGUgdGhlIHByb3BlcnRpZXMgb2YgYSBgTm9kZWAgb2JqZWN0LiBTZWVcblt0aGUgZ3VpZGVdKC9kb2NzL2d1aWRlLyNkb2MpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuKi9cbmNsYXNzIE5vZGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2Ygbm9kZSB0aGF0IHRoaXMgaXMuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBBbiBvYmplY3QgbWFwcGluZyBhdHRyaWJ1dGUgbmFtZXMgdG8gdmFsdWVzLiBUaGUga2luZCBvZlxuICAgIGF0dHJpYnV0ZXMgYWxsb3dlZCBhbmQgcmVxdWlyZWQgYXJlXG4gICAgW2RldGVybWluZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5hdHRycykgYnkgdGhlIG5vZGUgdHlwZS5cbiAgICAqL1xuICAgIGF0dHJzLCBcbiAgICAvLyBBIGZyYWdtZW50IGhvbGRpbmcgdGhlIG5vZGUncyBjaGlsZHJlbi5cbiAgICBjb250ZW50LCBcbiAgICAvKipcbiAgICBUaGUgbWFya3MgKHRoaW5ncyBsaWtlIHdoZXRoZXIgaXQgaXMgZW1waGFzaXplZCBvciBwYXJ0IG9mIGFcbiAgICBsaW5rKSBhcHBsaWVkIHRvIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIG1hcmtzID0gTWFyay5ub25lKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50IHx8IEZyYWdtZW50LmVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2l6ZSBvZiB0aGlzIG5vZGUsIGFzIGRlZmluZWQgYnkgdGhlIGludGVnZXItYmFzZWQgW2luZGV4aW5nXG4gICAgc2NoZW1lXSgvZG9jcy9ndWlkZS8jZG9jLmluZGV4aW5nKS4gRm9yIHRleHQgbm9kZXMsIHRoaXMgaXMgdGhlXG4gICAgYW1vdW50IG9mIGNoYXJhY3RlcnMuIEZvciBvdGhlciBsZWFmIG5vZGVzLCBpdCBpcyBvbmUuIEZvclxuICAgIG5vbi1sZWFmIG5vZGVzLCBpdCBpcyB0aGUgc2l6ZSBvZiB0aGUgY29udGVudCBwbHVzIHR3byAodGhlXG4gICAgc3RhcnQgYW5kIGVuZCB0b2tlbikuXG4gICAgKi9cbiAgICBnZXQgbm9kZVNpemUoKSB7IHJldHVybiB0aGlzLmlzTGVhZiA/IDEgOiAyICsgdGhpcy5jb250ZW50LnNpemU7IH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgdGhlIG5vZGUgaGFzLlxuICAgICovXG4gICAgZ2V0IGNoaWxkQ291bnQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuY2hpbGRDb3VudDsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguIFJhaXNlcyBhbiBlcnJvciB3aGVuIHRoZVxuICAgIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAqL1xuICAgIGNoaWxkKGluZGV4KSB7IHJldHVybiB0aGlzLmNvbnRlbnQuY2hpbGQoaW5kZXgpOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleCwgaWYgaXQgZXhpc3RzLlxuICAgICovXG4gICAgbWF5YmVDaGlsZChpbmRleCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpOyB9XG4gICAgLyoqXG4gICAgQ2FsbCBgZmAgZm9yIGV2ZXJ5IGNoaWxkIG5vZGUsIHBhc3NpbmcgdGhlIG5vZGUsIGl0cyBvZmZzZXRcbiAgICBpbnRvIHRoaXMgcGFyZW50IG5vZGUsIGFuZCBpdHMgaW5kZXguXG4gICAgKi9cbiAgICBmb3JFYWNoKGYpIHsgdGhpcy5jb250ZW50LmZvckVhY2goZik7IH1cbiAgICAvKipcbiAgICBJbnZva2UgYSBjYWxsYmFjayBmb3IgYWxsIGRlc2NlbmRhbnQgbm9kZXMgcmVjdXJzaXZlbHkgYmV0d2VlblxuICAgIHRoZSBnaXZlbiB0d28gcG9zaXRpb25zIHRoYXQgYXJlIHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHRoaXNcbiAgICBub2RlJ3MgY29udGVudC4gVGhlIGNhbGxiYWNrIGlzIGludm9rZWQgd2l0aCB0aGUgbm9kZSwgaXRzXG4gICAgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIG9yaWdpbmFsIG5vZGUgKG1ldGhvZCByZWNlaXZlciksXG4gICAgaXRzIHBhcmVudCBub2RlLCBhbmQgaXRzIGNoaWxkIGluZGV4LiBXaGVuIHRoZSBjYWxsYmFjayByZXR1cm5zXG4gICAgZmFsc2UgZm9yIGEgZ2l2ZW4gbm9kZSwgdGhhdCBub2RlJ3MgY2hpbGRyZW4gd2lsbCBub3QgYmVcbiAgICByZWN1cnNlZCBvdmVyLiBUaGUgbGFzdCBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSBhXG4gICAgc3RhcnRpbmcgcG9zaXRpb24gdG8gY291bnQgZnJvbS5cbiAgICAqL1xuICAgIG5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZiwgc3RhcnRQb3MgPSAwKSB7XG4gICAgICAgIHRoaXMuY29udGVudC5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYsIHN0YXJ0UG9zLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbCB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IGRlc2NlbmRhbnQgbm9kZS4gRG9lc24ndFxuICAgIGRlc2NlbmQgaW50byBhIG5vZGUgd2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLlxuICAgICovXG4gICAgZGVzY2VuZGFudHMoZikge1xuICAgICAgICB0aGlzLm5vZGVzQmV0d2VlbigwLCB0aGlzLmNvbnRlbnQuc2l6ZSwgZik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbmNhdGVuYXRlcyBhbGwgdGhlIHRleHQgbm9kZXMgZm91bmQgaW4gdGhpcyBmcmFnbWVudCBhbmQgaXRzXG4gICAgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBnZXQgdGV4dENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pc0xlYWYgJiYgdGhpcy50eXBlLnNwZWMubGVhZlRleHQpXG4gICAgICAgICAgICA/IHRoaXMudHlwZS5zcGVjLmxlYWZUZXh0KHRoaXMpXG4gICAgICAgICAgICA6IHRoaXMudGV4dEJldHdlZW4oMCwgdGhpcy5jb250ZW50LnNpemUsIFwiXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYWxsIHRleHQgYmV0d2VlbiBwb3NpdGlvbnMgYGZyb21gIGFuZCBgdG9gLiBXaGVuXG4gICAgYGJsb2NrU2VwYXJhdG9yYCBpcyBnaXZlbiwgaXQgd2lsbCBiZSBpbnNlcnRlZCB0byBzZXBhcmF0ZSB0ZXh0XG4gICAgZnJvbSBkaWZmZXJlbnQgYmxvY2sgbm9kZXMuIElmIGBsZWFmVGV4dGAgaXMgZ2l2ZW4sIGl0J2xsIGJlXG4gICAgaW5zZXJ0ZWQgZm9yIGV2ZXJ5IG5vbi10ZXh0IGxlYWYgbm9kZSBlbmNvdW50ZXJlZCwgb3RoZXJ3aXNlXG4gICAgW2BsZWFmVGV4dGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlY15sZWFmVGV4dCkgd2lsbCBiZSB1c2VkLlxuICAgICovXG4gICAgdGV4dEJldHdlZW4oZnJvbSwgdG8sIGJsb2NrU2VwYXJhdG9yLCBsZWFmVGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LnRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoaXMgbm9kZSdzIGZpcnN0IGNoaWxkLCBvciBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vXG4gICAgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5maXJzdENoaWxkOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGlzIG5vZGUncyBsYXN0IGNoaWxkLCBvciBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vXG4gICAgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxhc3RDaGlsZDsgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0d28gbm9kZXMgcmVwcmVzZW50IHRoZSBzYW1lIHBpZWNlIG9mIGRvY3VtZW50LlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgKHRoaXMuc2FtZU1hcmt1cChvdGhlcikgJiYgdGhpcy5jb250ZW50LmVxKG90aGVyLmNvbnRlbnQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGUgbWFya3VwICh0eXBlLCBhdHRyaWJ1dGVzLCBhbmQgbWFya3MpIG9mIHRoaXMgbm9kZSB0b1xuICAgIHRob3NlIG9mIGFub3RoZXIuIFJldHVybnMgYHRydWVgIGlmIGJvdGggaGF2ZSB0aGUgc2FtZSBtYXJrdXAuXG4gICAgKi9cbiAgICBzYW1lTWFya3VwKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc01hcmt1cChvdGhlci50eXBlLCBvdGhlci5hdHRycywgb3RoZXIubWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoaXMgbm9kZSdzIG1hcmt1cCBjb3JyZXNwb25kIHRvIHRoZSBnaXZlbiB0eXBlLFxuICAgIGF0dHJpYnV0ZXMsIGFuZCBtYXJrcy5cbiAgICAqL1xuICAgIGhhc01hcmt1cCh0eXBlLCBhdHRycywgbWFya3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSB0eXBlICYmXG4gICAgICAgICAgICBjb21wYXJlRGVlcCh0aGlzLmF0dHJzLCBhdHRycyB8fCB0eXBlLmRlZmF1bHRBdHRycyB8fCBlbXB0eUF0dHJzKSAmJlxuICAgICAgICAgICAgTWFyay5zYW1lU2V0KHRoaXMubWFya3MsIG1hcmtzIHx8IE1hcmsubm9uZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBub2RlIHdpdGggdGhlIHNhbWUgbWFya3VwIGFzIHRoaXMgbm9kZSwgY29udGFpbmluZ1xuICAgIHRoZSBnaXZlbiBjb250ZW50IChvciBlbXB0eSwgaWYgbm8gY29udGVudCBpcyBnaXZlbikuXG4gICAgKi9cbiAgICBjb3B5KGNvbnRlbnQgPSBudWxsKSB7XG4gICAgICAgIGlmIChjb250ZW50ID09IHRoaXMuY29udGVudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCBjb250ZW50LCB0aGlzLm1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIG5vZGUsIHdpdGggdGhlIGdpdmVuIHNldCBvZiBtYXJrcyBpbnN0ZWFkXG4gICAgb2YgdGhlIG5vZGUncyBvd24gbWFya3MuXG4gICAgKi9cbiAgICBtYXJrKG1hcmtzKSB7XG4gICAgICAgIHJldHVybiBtYXJrcyA9PSB0aGlzLm1hcmtzID8gdGhpcyA6IG5ldyBOb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGhpcy5jb250ZW50LCBtYXJrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBub2RlIHdpdGggb25seSB0aGUgY29udGVudCBiZXR3ZWVuIHRoZVxuICAgIGdpdmVuIHBvc2l0aW9ucy4gSWYgYHRvYCBpcyBub3QgZ2l2ZW4sIGl0IGRlZmF1bHRzIHRvIHRoZSBlbmQgb2ZcbiAgICB0aGUgbm9kZS5cbiAgICAqL1xuICAgIGN1dChmcm9tLCB0byA9IHRoaXMuY29udGVudC5zaXplKSB7XG4gICAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSh0aGlzLmNvbnRlbnQuY3V0KGZyb20sIHRvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEN1dCBvdXQgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucywgYW5kXG4gICAgcmV0dXJuIGl0IGFzIGEgYFNsaWNlYCBvYmplY3QuXG4gICAgKi9cbiAgICBzbGljZShmcm9tLCB0byA9IHRoaXMuY29udGVudC5zaXplLCBpbmNsdWRlUGFyZW50cyA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChmcm9tID09IHRvKVxuICAgICAgICAgICAgcmV0dXJuIFNsaWNlLmVtcHR5O1xuICAgICAgICBsZXQgJGZyb20gPSB0aGlzLnJlc29sdmUoZnJvbSksICR0byA9IHRoaXMucmVzb2x2ZSh0byk7XG4gICAgICAgIGxldCBkZXB0aCA9IGluY2x1ZGVQYXJlbnRzID8gMCA6ICRmcm9tLnNoYXJlZERlcHRoKHRvKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gJGZyb20uc3RhcnQoZGVwdGgpLCBub2RlID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgIGxldCBjb250ZW50ID0gbm9kZS5jb250ZW50LmN1dCgkZnJvbS5wb3MgLSBzdGFydCwgJHRvLnBvcyAtIHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShjb250ZW50LCAkZnJvbS5kZXB0aCAtIGRlcHRoLCAkdG8uZGVwdGggLSBkZXB0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucyB3aXRoXG4gICAgdGhlIGdpdmVuIHNsaWNlLiBUaGUgc2xpY2UgbXVzdCAnZml0JywgbWVhbmluZyBpdHMgb3BlbiBzaWRlc1xuICAgIG11c3QgYmUgYWJsZSB0byBjb25uZWN0IHRvIHRoZSBzdXJyb3VuZGluZyBjb250ZW50LCBhbmQgaXRzXG4gICAgY29udGVudCBub2RlcyBtdXN0IGJlIHZhbGlkIGNoaWxkcmVuIGZvciB0aGUgbm9kZSB0aGV5IGFyZSBwbGFjZWRcbiAgICBpbnRvLiBJZiBhbnkgb2YgdGhpcyBpcyB2aW9sYXRlZCwgYW4gZXJyb3Igb2YgdHlwZVxuICAgIFtgUmVwbGFjZUVycm9yYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlJlcGxhY2VFcnJvcikgaXMgdGhyb3duLlxuICAgICovXG4gICAgcmVwbGFjZShmcm9tLCB0bywgc2xpY2UpIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2UodGhpcy5yZXNvbHZlKGZyb20pLCB0aGlzLnJlc29sdmUodG8pLCBzbGljZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIG5vZGUgZGlyZWN0bHkgYWZ0ZXIgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbm9kZUF0KHBvcykge1xuICAgICAgICBmb3IgKGxldCBub2RlID0gdGhpczs7KSB7XG4gICAgICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KHBvcyk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gcG9zIHx8IG5vZGUuaXNUZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgcG9zIC09IG9mZnNldCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgKGRpcmVjdCkgY2hpbGQgbm9kZSBhZnRlciB0aGUgZ2l2ZW4gb2Zmc2V0LCBpZiBhbnksXG4gICAgYW5kIHJldHVybiBpdCBhbG9uZyB3aXRoIGl0cyBpbmRleCBhbmQgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoaXNcbiAgICBub2RlLlxuICAgICovXG4gICAgY2hpbGRBZnRlcihwb3MpIHtcbiAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gdGhpcy5jb250ZW50LmZpbmRJbmRleChwb3MpO1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnQubWF5YmVDaGlsZChpbmRleCksIGluZGV4LCBvZmZzZXQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgKGRpcmVjdCkgY2hpbGQgbm9kZSBiZWZvcmUgdGhlIGdpdmVuIG9mZnNldCwgaWYgYW55LFxuICAgIGFuZCByZXR1cm4gaXQgYWxvbmcgd2l0aCBpdHMgaW5kZXggYW5kIG9mZnNldCByZWxhdGl2ZSB0byB0aGlzXG4gICAgbm9kZS5cbiAgICAqL1xuICAgIGNoaWxkQmVmb3JlKHBvcykge1xuICAgICAgICBpZiAocG9zID09IDApXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiBudWxsLCBpbmRleDogMCwgb2Zmc2V0OiAwIH07XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IHRoaXMuY29udGVudC5maW5kSW5kZXgocG9zKTtcbiAgICAgICAgaWYgKG9mZnNldCA8IHBvcylcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudC5jaGlsZChpbmRleCksIGluZGV4LCBvZmZzZXQgfTtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmNvbnRlbnQuY2hpbGQoaW5kZXggLSAxKTtcbiAgICAgICAgcmV0dXJuIHsgbm9kZSwgaW5kZXg6IGluZGV4IC0gMSwgb2Zmc2V0OiBvZmZzZXQgLSBub2RlLm5vZGVTaXplIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc29sdmUgdGhlIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCwgcmV0dXJuaW5nIGFuXG4gICAgW29iamVjdF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlJlc29sdmVkUG9zKSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IGl0cyBjb250ZXh0LlxuICAgICovXG4gICAgcmVzb2x2ZShwb3MpIHsgcmV0dXJuIFJlc29sdmVkUG9zLnJlc29sdmVDYWNoZWQodGhpcywgcG9zKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzb2x2ZU5vQ2FjaGUocG9zKSB7IHJldHVybiBSZXNvbHZlZFBvcy5yZXNvbHZlKHRoaXMsIHBvcyk7IH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgYSBnaXZlbiBtYXJrIG9yIG1hcmsgdHlwZSBvY2N1cnMgaW4gdGhpcyBkb2N1bWVudFxuICAgIGJldHdlZW4gdGhlIHR3byBnaXZlbiBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICByYW5nZUhhc01hcmsoZnJvbSwgdG8sIHR5cGUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGlmICh0byA+IGZyb20pXG4gICAgICAgICAgICB0aGlzLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuaXNJblNldChub2RlLm1hcmtzKSlcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAhZm91bmQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhIGJsb2NrIChub24taW5saW5lIG5vZGUpXG4gICAgKi9cbiAgICBnZXQgaXNCbG9jaygpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0Jsb2NrOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSB0ZXh0YmxvY2sgbm9kZSwgYSBibG9jayBub2RlIHdpdGggaW5saW5lXG4gICAgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc1RleHRibG9jaygpIHsgcmV0dXJuIHRoaXMudHlwZS5pc1RleHRibG9jazsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG5vZGUgYWxsb3dzIGlubGluZSBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlubGluZUNvbnRlbnQoKSB7IHJldHVybiB0aGlzLnR5cGUuaW5saW5lQ29udGVudDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGFuIGlubGluZSBub2RlIChhIHRleHQgbm9kZSBvciBhIG5vZGUgdGhhdCBjYW5cbiAgICBhcHBlYXIgYW1vbmcgdGV4dCkuXG4gICAgKi9cbiAgICBnZXQgaXNJbmxpbmUoKSB7IHJldHVybiB0aGlzLnR5cGUuaXNJbmxpbmU7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhIHRleHQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBpc1RleHQoKSB7IHJldHVybiB0aGlzLnR5cGUuaXNUZXh0OyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSBsZWFmIG5vZGUuXG4gICAgKi9cbiAgICBnZXQgaXNMZWFmKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzTGVhZjsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGFuIGF0b20sIGkuZS4gd2hlbiBpdCBkb2VzIG5vdCBoYXZlIGRpcmVjdGx5XG4gICAgZWRpdGFibGUgY29udGVudC4gVGhpcyBpcyB1c3VhbGx5IHRoZSBzYW1lIGFzIGBpc0xlYWZgLCBidXQgY2FuXG4gICAgYmUgY29uZmlndXJlZCB3aXRoIHRoZSBbYGF0b21gIHByb3BlcnR5XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuYXRvbSlcbiAgICBvbiBhIG5vZGUncyBzcGVjICh0eXBpY2FsbHkgdXNlZCB3aGVuIHRoZSBub2RlIGlzIGRpc3BsYXllZCBhc1xuICAgIGFuIHVuZWRpdGFibGUgW25vZGUgdmlld10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuTm9kZVZpZXcpKS5cbiAgICAqL1xuICAgIGdldCBpc0F0b20oKSB7IHJldHVybiB0aGlzLnR5cGUuaXNBdG9tOyB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZSBmb3IgZGVidWdnaW5nXG4gICAgcHVycG9zZXMuXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZyh0aGlzKTtcbiAgICAgICAgbGV0IG5hbWUgPSB0aGlzLnR5cGUubmFtZTtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgbmFtZSArPSBcIihcIiArIHRoaXMuY29udGVudC50b1N0cmluZ0lubmVyKCkgKyBcIilcIjtcbiAgICAgICAgcmV0dXJuIHdyYXBNYXJrcyh0aGlzLm1hcmtzLCBuYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjb250ZW50IG1hdGNoIGluIHRoaXMgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgKi9cbiAgICBjb250ZW50TWF0Y2hBdChpbmRleCkge1xuICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCAwLCBpbmRleCk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgY29udGVudE1hdGNoQXQgb24gYSBub2RlIHdpdGggaW52YWxpZCBjb250ZW50XCIpO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciByZXBsYWNpbmcgdGhlIHJhbmdlIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIChieVxuICAgIGNoaWxkIGluZGV4KSB3aXRoIHRoZSBnaXZlbiByZXBsYWNlbWVudCBmcmFnbWVudCAod2hpY2ggZGVmYXVsdHNcbiAgICB0byB0aGUgZW1wdHkgZnJhZ21lbnQpIHdvdWxkIGxlYXZlIHRoZSBub2RlJ3MgY29udGVudCB2YWxpZC4gWW91XG4gICAgY2FuIG9wdGlvbmFsbHkgcGFzcyBgc3RhcnRgIGFuZCBgZW5kYCBpbmRpY2VzIGludG8gdGhlXG4gICAgcmVwbGFjZW1lbnQgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBjYW5SZXBsYWNlKGZyb20sIHRvLCByZXBsYWNlbWVudCA9IEZyYWdtZW50LmVtcHR5LCBzdGFydCA9IDAsIGVuZCA9IHJlcGxhY2VtZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgbGV0IG9uZSA9IHRoaXMuY29udGVudE1hdGNoQXQoZnJvbSkubWF0Y2hGcmFnbWVudChyZXBsYWNlbWVudCwgc3RhcnQsIGVuZCk7XG4gICAgICAgIGxldCB0d28gPSBvbmUgJiYgb25lLm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCB0byk7XG4gICAgICAgIGlmICghdHdvIHx8ICF0d28udmFsaWRFbmQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnR5cGUuYWxsb3dzTWFya3MocmVwbGFjZW1lbnQuY2hpbGQoaSkubWFya3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciByZXBsYWNpbmcgdGhlIHJhbmdlIGBmcm9tYCB0byBgdG9gIChieSBpbmRleCkgd2l0aFxuICAgIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSB3b3VsZCBsZWF2ZSB0aGUgbm9kZSdzIGNvbnRlbnQgdmFsaWQuXG4gICAgKi9cbiAgICBjYW5SZXBsYWNlV2l0aChmcm9tLCB0bywgdHlwZSwgbWFya3MpIHtcbiAgICAgICAgaWYgKG1hcmtzICYmICF0aGlzLnR5cGUuYWxsb3dzTWFya3MobWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmNvbnRlbnRNYXRjaEF0KGZyb20pLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICYmIHN0YXJ0Lm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCB0byk7XG4gICAgICAgIHJldHVybiBlbmQgPyBlbmQudmFsaWRFbmQgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiBub2RlJ3MgY29udGVudCBjb3VsZCBiZSBhcHBlbmRlZCB0byB0aGlzXG4gICAgbm9kZS4gSWYgdGhhdCBub2RlIGlzIGVtcHR5LCB0aGlzIHdpbGwgb25seSByZXR1cm4gdHJ1ZSBpZiB0aGVyZVxuICAgIGlzIGF0IGxlYXN0IG9uZSBub2RlIHR5cGUgdGhhdCBjYW4gYXBwZWFyIGluIGJvdGggbm9kZXMgKHRvIGF2b2lkXG4gICAgbWVyZ2luZyBjb21wbGV0ZWx5IGluY29tcGF0aWJsZSBub2RlcykuXG4gICAgKi9cbiAgICBjYW5BcHBlbmQob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhblJlcGxhY2UodGhpcy5jaGlsZENvdW50LCB0aGlzLmNoaWxkQ291bnQsIG90aGVyLmNvbnRlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLmNvbXBhdGlibGVDb250ZW50KG90aGVyLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoaXMgbm9kZSBhbmQgaXRzIGRlc2NlbmRhbnRzIGNvbmZvcm0gdG8gdGhlXG4gICAgc2NoZW1hLCBhbmQgcmFpc2UgZXJyb3Igd2hlbiB0aGV5IGRvIG5vdC5cbiAgICAqL1xuICAgIGNoZWNrKCkge1xuICAgICAgICB0aGlzLnR5cGUuY2hlY2tDb250ZW50KHRoaXMuY29udGVudCk7XG4gICAgICAgIGxldCBjb3B5ID0gTWFyay5ub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBjb3B5ID0gdGhpcy5tYXJrc1tpXS5hZGRUb1NldChjb3B5KTtcbiAgICAgICAgaWYgKCFNYXJrLnNhbWVTZXQoY29weSwgdGhpcy5tYXJrcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBjb2xsZWN0aW9uIG9mIG1hcmtzIGZvciBub2RlICR7dGhpcy50eXBlLm5hbWV9OiAke3RoaXMubWFya3MubWFwKG0gPT4gbS50eXBlLm5hbWUpfWApO1xuICAgICAgICB0aGlzLmNvbnRlbnQuZm9yRWFjaChub2RlID0+IG5vZGUuY2hlY2soKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIEpTT04tc2VyaWFsaXplYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBvYmogPSB7IHR5cGU6IHRoaXMudHlwZS5uYW1lIH07XG4gICAgICAgIGZvciAobGV0IF8gaW4gdGhpcy5hdHRycykge1xuICAgICAgICAgICAgb2JqLmF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIG9iai5jb250ZW50ID0gdGhpcy5jb250ZW50LnRvSlNPTigpO1xuICAgICAgICBpZiAodGhpcy5tYXJrcy5sZW5ndGgpXG4gICAgICAgICAgICBvYmoubWFya3MgPSB0aGlzLm1hcmtzLm1hcChuID0+IG4udG9KU09OKCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG5vZGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBOb2RlLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgbWFya3MgPSBudWxsO1xuICAgICAgICBpZiAoanNvbi5tYXJrcykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24ubWFya3MpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBtYXJrIGRhdGEgZm9yIE5vZGUuZnJvbUpTT05cIik7XG4gICAgICAgICAgICBtYXJrcyA9IGpzb24ubWFya3MubWFwKHNjaGVtYS5tYXJrRnJvbUpTT04pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc29uLnR5cGUgPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbi50ZXh0ICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHRleHQgbm9kZSBpbiBKU09OXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS50ZXh0KGpzb24udGV4dCwgbWFya3MpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50ID0gRnJhZ21lbnQuZnJvbUpTT04oc2NoZW1hLCBqc29uLmNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gc2NoZW1hLm5vZGVUeXBlKGpzb24udHlwZSkuY3JlYXRlKGpzb24uYXR0cnMsIGNvbnRlbnQsIG1hcmtzKTtcbiAgICB9XG59XG5Ob2RlLnByb3RvdHlwZS50ZXh0ID0gdW5kZWZpbmVkO1xuY2xhc3MgVGV4dE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGF0dHJzLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBzdXBlcih0eXBlLCBhdHRycywgbnVsbCwgbWFya3MpO1xuICAgICAgICBpZiAoIWNvbnRlbnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkVtcHR5IHRleHQgbm9kZXMgYXJlIG5vdCBhbGxvd2VkXCIpO1xuICAgICAgICB0aGlzLnRleHQgPSBjb250ZW50O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHdyYXBNYXJrcyh0aGlzLm1hcmtzLCBKU09OLnN0cmluZ2lmeSh0aGlzLnRleHQpKTtcbiAgICB9XG4gICAgZ2V0IHRleHRDb250ZW50KCkgeyByZXR1cm4gdGhpcy50ZXh0OyB9XG4gICAgdGV4dEJldHdlZW4oZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMudGV4dC5zbGljZShmcm9tLCB0byk7IH1cbiAgICBnZXQgbm9kZVNpemUoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgbWFyayhtYXJrcykge1xuICAgICAgICByZXR1cm4gbWFya3MgPT0gdGhpcy5tYXJrcyA/IHRoaXMgOiBuZXcgVGV4dE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCB0aGlzLnRleHQsIG1hcmtzKTtcbiAgICB9XG4gICAgd2l0aFRleHQodGV4dCkge1xuICAgICAgICBpZiAodGV4dCA9PSB0aGlzLnRleHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Tm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRleHQsIHRoaXMubWFya3MpO1xuICAgIH1cbiAgICBjdXQoZnJvbSA9IDAsIHRvID0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMudGV4dC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aFRleHQodGhpcy50ZXh0LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhbWVNYXJrdXAob3RoZXIpICYmIHRoaXMudGV4dCA9PSBvdGhlci50ZXh0O1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBiYXNlID0gc3VwZXIudG9KU09OKCk7XG4gICAgICAgIGJhc2UudGV4dCA9IHRoaXMudGV4dDtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JhcE1hcmtzKG1hcmtzLCBzdHIpIHtcbiAgICBmb3IgKGxldCBpID0gbWFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHN0ciA9IG1hcmtzW2ldLnR5cGUubmFtZSArIFwiKFwiICsgc3RyICsgXCIpXCI7XG4gICAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG5JbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgYSBtYXRjaCBzdGF0ZSBvZiBhIG5vZGUgdHlwZSdzXG5bY29udGVudCBleHByZXNzaW9uXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuY29udGVudCksIGFuZCBjYW4gYmUgdXNlZCB0b1xuZmluZCBvdXQgd2hldGhlciBmdXJ0aGVyIGNvbnRlbnQgbWF0Y2hlcyBoZXJlLCBhbmQgd2hldGhlciBhIGdpdmVuXG5wb3NpdGlvbiBpcyBhIHZhbGlkIGVuZCBvZiB0aGUgbm9kZS5cbiovXG5jbGFzcyBDb250ZW50TWF0Y2gge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbWF0Y2ggc3RhdGUgcmVwcmVzZW50cyBhIHZhbGlkIGVuZCBvZiB0aGUgbm9kZS5cbiAgICAqL1xuICAgIHZhbGlkRW5kKSB7XG4gICAgICAgIHRoaXMudmFsaWRFbmQgPSB2YWxpZEVuZDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm5leHQgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLndyYXBDYWNoZSA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBwYXJzZShzdHJpbmcsIG5vZGVUeXBlcykge1xuICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFRva2VuU3RyZWFtKHN0cmluZywgbm9kZVR5cGVzKTtcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gQ29udGVudE1hdGNoLmVtcHR5O1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHJlYW0pO1xuICAgICAgICBpZiAoc3RyZWFtLm5leHQpXG4gICAgICAgICAgICBzdHJlYW0uZXJyKFwiVW5leHBlY3RlZCB0cmFpbGluZyB0ZXh0XCIpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBkZmEobmZhKGV4cHIpKTtcbiAgICAgICAgY2hlY2tGb3JEZWFkRW5kcyhtYXRjaCwgc3RyZWFtKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXRjaCBhIG5vZGUgdHlwZSwgcmV0dXJuaW5nIGEgbWF0Y2ggYWZ0ZXIgdGhhdCBub2RlIGlmXG4gICAgc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIG1hdGNoVHlwZSh0eXBlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMubmV4dFtpXS50eXBlID09IHR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dFtpXS5uZXh0O1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIG1hdGNoIGEgZnJhZ21lbnQuIFJldHVybnMgdGhlIHJlc3VsdGluZyBtYXRjaCB3aGVuXG4gICAgc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIG1hdGNoRnJhZ21lbnQoZnJhZywgc3RhcnQgPSAwLCBlbmQgPSBmcmFnLmNoaWxkQ291bnQpIHtcbiAgICAgICAgbGV0IGN1ciA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgY3VyICYmIGkgPCBlbmQ7IGkrKylcbiAgICAgICAgICAgIGN1ciA9IGN1ci5tYXRjaFR5cGUoZnJhZy5jaGlsZChpKS50eXBlKTtcbiAgICAgICAgcmV0dXJuIGN1cjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaW5saW5lQ29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dC5sZW5ndGggIT0gMCAmJiB0aGlzLm5leHRbMF0udHlwZS5pc0lubGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBmaXJzdCBtYXRjaGluZyBub2RlIHR5cGUgYXQgdGhpcyBtYXRjaCBwb3NpdGlvbiB0aGF0IGNhblxuICAgIGJlIGdlbmVyYXRlZC5cbiAgICAqL1xuICAgIGdldCBkZWZhdWx0VHlwZSgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IHR5cGUgfSA9IHRoaXMubmV4dFtpXTtcbiAgICAgICAgICAgIGlmICghKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXRpYmxlKG90aGVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvdGhlci5uZXh0Lmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5leHRbaV0udHlwZSA9PSBvdGhlci5uZXh0W2pdLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBtYXRjaCB0aGUgZ2l2ZW4gZnJhZ21lbnQsIGFuZCBpZiB0aGF0IGZhaWxzLCBzZWUgaWYgaXQgY2FuXG4gICAgYmUgbWFkZSB0byBtYXRjaCBieSBpbnNlcnRpbmcgbm9kZXMgaW4gZnJvbnQgb2YgaXQuIFdoZW5cbiAgICBzdWNjZXNzZnVsLCByZXR1cm4gYSBmcmFnbWVudCBvZiBpbnNlcnRlZCBub2RlcyAod2hpY2ggbWF5IGJlXG4gICAgZW1wdHkgaWYgbm90aGluZyBoYWQgdG8gYmUgaW5zZXJ0ZWQpLiBXaGVuIGB0b0VuZGAgaXMgdHJ1ZSwgb25seVxuICAgIHJldHVybiBhIGZyYWdtZW50IGlmIHRoZSByZXN1bHRpbmcgbWF0Y2ggZ29lcyB0byB0aGUgZW5kIG9mIHRoZVxuICAgIGNvbnRlbnQgZXhwcmVzc2lvbi5cbiAgICAqL1xuICAgIGZpbGxCZWZvcmUoYWZ0ZXIsIHRvRW5kID0gZmFsc2UsIHN0YXJ0SW5kZXggPSAwKSB7XG4gICAgICAgIGxldCBzZWVuID0gW3RoaXNdO1xuICAgICAgICBmdW5jdGlvbiBzZWFyY2gobWF0Y2gsIHR5cGVzKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSBtYXRjaC5tYXRjaEZyYWdtZW50KGFmdGVyLCBzdGFydEluZGV4KTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZCAmJiAoIXRvRW5kIHx8IGZpbmlzaGVkLnZhbGlkRW5kKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbSh0eXBlcy5tYXAodHAgPT4gdHAuY3JlYXRlQW5kRmlsbCgpKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBuZXh0IH0gPSBtYXRjaC5uZXh0W2ldO1xuICAgICAgICAgICAgICAgIGlmICghKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSAmJiBzZWVuLmluZGV4T2YobmV4dCkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vlbi5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBzZWFyY2gobmV4dCwgdHlwZXMuY29uY2F0KHR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWFyY2godGhpcywgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGEgc2V0IG9mIHdyYXBwaW5nIG5vZGUgdHlwZXMgdGhhdCB3b3VsZCBhbGxvdyBhIG5vZGUgb2YgdGhlXG4gICAgZ2l2ZW4gdHlwZSB0byBhcHBlYXIgYXQgdGhpcyBwb3NpdGlvbi4gVGhlIHJlc3VsdCBtYXkgYmUgZW1wdHlcbiAgICAod2hlbiBpdCBmaXRzIGRpcmVjdGx5KSBhbmQgd2lsbCBiZSBudWxsIHdoZW4gbm8gc3VjaCB3cmFwcGluZ1xuICAgIGV4aXN0cy5cbiAgICAqL1xuICAgIGZpbmRXcmFwcGluZyh0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndyYXBDYWNoZS5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIGlmICh0aGlzLndyYXBDYWNoZVtpXSA9PSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcENhY2hlW2kgKyAxXTtcbiAgICAgICAgbGV0IGNvbXB1dGVkID0gdGhpcy5jb21wdXRlV3JhcHBpbmcodGFyZ2V0KTtcbiAgICAgICAgdGhpcy53cmFwQ2FjaGUucHVzaCh0YXJnZXQsIGNvbXB1dGVkKTtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVkO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXB1dGVXcmFwcGluZyh0YXJnZXQpIHtcbiAgICAgICAgbGV0IHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpLCBhY3RpdmUgPSBbeyBtYXRjaDogdGhpcywgdHlwZTogbnVsbCwgdmlhOiBudWxsIH1dO1xuICAgICAgICB3aGlsZSAoYWN0aXZlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSBhY3RpdmUuc2hpZnQoKSwgbWF0Y2ggPSBjdXJyZW50Lm1hdGNoO1xuICAgICAgICAgICAgaWYgKG1hdGNoLm1hdGNoVHlwZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9iaiA9IGN1cnJlbnQ7IG9iai50eXBlOyBvYmogPSBvYmoudmlhKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmoudHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBuZXh0IH0gPSBtYXRjaC5uZXh0W2ldO1xuICAgICAgICAgICAgICAgIGlmICghdHlwZS5pc0xlYWYgJiYgIXR5cGUuaGFzUmVxdWlyZWRBdHRycygpICYmICEodHlwZS5uYW1lIGluIHNlZW4pICYmICghY3VycmVudC50eXBlIHx8IG5leHQudmFsaWRFbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKHsgbWF0Y2g6IHR5cGUuY29udGVudE1hdGNoLCB0eXBlLCB2aWE6IGN1cnJlbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNlZW5bdHlwZS5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIG91dGdvaW5nIGVkZ2VzIHRoaXMgbm9kZSBoYXMgaW4gdGhlIGZpbml0ZVxuICAgIGF1dG9tYXRvbiB0aGF0IGRlc2NyaWJlcyB0aGUgY29udGVudCBleHByZXNzaW9uLlxuICAgICovXG4gICAgZ2V0IGVkZ2VDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dC5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgX25fXHUyMDBCdGggb3V0Z29pbmcgZWRnZSBmcm9tIHRoaXMgbm9kZSBpbiB0aGUgZmluaXRlXG4gICAgYXV0b21hdG9uIHRoYXQgZGVzY3JpYmVzIHRoZSBjb250ZW50IGV4cHJlc3Npb24uXG4gICAgKi9cbiAgICBlZGdlKG4pIHtcbiAgICAgICAgaWYgKG4gPj0gdGhpcy5uZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGVyZSdzIG5vICR7bn10aCBlZGdlIGluIHRoaXMgY29udGVudCBtYXRjaGApO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0W25dO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgc2VlbiA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBzY2FuKG0pIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChtKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbS5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2YobS5uZXh0W2ldLm5leHQpID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzY2FuKG0ubmV4dFtpXS5uZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBzY2FuKHRoaXMpO1xuICAgICAgICByZXR1cm4gc2Vlbi5tYXAoKG0sIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBvdXQgPSBpICsgKG0udmFsaWRFbmQgPyBcIipcIiA6IFwiIFwiKSArIFwiIFwiO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtLm5leHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgb3V0ICs9IChpID8gXCIsIFwiIDogXCJcIikgKyBtLm5leHRbaV0udHlwZS5uYW1lICsgXCItPlwiICsgc2Vlbi5pbmRleE9mKG0ubmV4dFtpXS5uZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgfVxufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5Db250ZW50TWF0Y2guZW1wdHkgPSBuZXcgQ29udGVudE1hdGNoKHRydWUpO1xuY2xhc3MgVG9rZW5TdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZywgbm9kZVR5cGVzKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICB0aGlzLm5vZGVUeXBlcyA9IG5vZGVUeXBlcztcbiAgICAgICAgdGhpcy5pbmxpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMudG9rZW5zID0gc3RyaW5nLnNwbGl0KC9cXHMqKD89XFxifFxcV3wkKS8pO1xuICAgICAgICBpZiAodGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0gPT0gXCJcIilcbiAgICAgICAgICAgIHRoaXMudG9rZW5zLnBvcCgpO1xuICAgICAgICBpZiAodGhpcy50b2tlbnNbMF0gPT0gXCJcIilcbiAgICAgICAgICAgIHRoaXMudG9rZW5zLnNoaWZ0KCk7XG4gICAgfVxuICAgIGdldCBuZXh0KCkgeyByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5wb3NdOyB9XG4gICAgZWF0KHRvaykgeyByZXR1cm4gdGhpcy5uZXh0ID09IHRvayAmJiAodGhpcy5wb3MrKyB8fCB0cnVlKTsgfVxuICAgIGVycihzdHIpIHsgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN0ciArIFwiIChpbiBjb250ZW50IGV4cHJlc3Npb24gJ1wiICsgdGhpcy5zdHJpbmcgKyBcIicpXCIpOyB9XG59XG5mdW5jdGlvbiBwYXJzZUV4cHIoc3RyZWFtKSB7XG4gICAgbGV0IGV4cHJzID0gW107XG4gICAgZG8ge1xuICAgICAgICBleHBycy5wdXNoKHBhcnNlRXhwclNlcShzdHJlYW0pKTtcbiAgICB9IHdoaWxlIChzdHJlYW0uZWF0KFwifFwiKSk7XG4gICAgcmV0dXJuIGV4cHJzLmxlbmd0aCA9PSAxID8gZXhwcnNbMF0gOiB7IHR5cGU6IFwiY2hvaWNlXCIsIGV4cHJzIH07XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJTZXEoc3RyZWFtKSB7XG4gICAgbGV0IGV4cHJzID0gW107XG4gICAgZG8ge1xuICAgICAgICBleHBycy5wdXNoKHBhcnNlRXhwclN1YnNjcmlwdChzdHJlYW0pKTtcbiAgICB9IHdoaWxlIChzdHJlYW0ubmV4dCAmJiBzdHJlYW0ubmV4dCAhPSBcIilcIiAmJiBzdHJlYW0ubmV4dCAhPSBcInxcIik7XG4gICAgcmV0dXJuIGV4cHJzLmxlbmd0aCA9PSAxID8gZXhwcnNbMF0gOiB7IHR5cGU6IFwic2VxXCIsIGV4cHJzIH07XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJTdWJzY3JpcHQoc3RyZWFtKSB7XG4gICAgbGV0IGV4cHIgPSBwYXJzZUV4cHJBdG9tKHN0cmVhbSk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdChcIitcIikpXG4gICAgICAgICAgICBleHByID0geyB0eXBlOiBcInBsdXNcIiwgZXhwciB9O1xuICAgICAgICBlbHNlIGlmIChzdHJlYW0uZWF0KFwiKlwiKSlcbiAgICAgICAgICAgIGV4cHIgPSB7IHR5cGU6IFwic3RhclwiLCBleHByIH07XG4gICAgICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoXCI/XCIpKVxuICAgICAgICAgICAgZXhwciA9IHsgdHlwZTogXCJvcHRcIiwgZXhwciB9O1xuICAgICAgICBlbHNlIGlmIChzdHJlYW0uZWF0KFwie1wiKSlcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZUV4cHJSYW5nZShzdHJlYW0sIGV4cHIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG59XG5mdW5jdGlvbiBwYXJzZU51bShzdHJlYW0pIHtcbiAgICBpZiAoL1xcRC8udGVzdChzdHJlYW0ubmV4dCkpXG4gICAgICAgIHN0cmVhbS5lcnIoXCJFeHBlY3RlZCBudW1iZXIsIGdvdCAnXCIgKyBzdHJlYW0ubmV4dCArIFwiJ1wiKTtcbiAgICBsZXQgcmVzdWx0ID0gTnVtYmVyKHN0cmVhbS5uZXh0KTtcbiAgICBzdHJlYW0ucG9zKys7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwclJhbmdlKHN0cmVhbSwgZXhwcikge1xuICAgIGxldCBtaW4gPSBwYXJzZU51bShzdHJlYW0pLCBtYXggPSBtaW47XG4gICAgaWYgKHN0cmVhbS5lYXQoXCIsXCIpKSB7XG4gICAgICAgIGlmIChzdHJlYW0ubmV4dCAhPSBcIn1cIilcbiAgICAgICAgICAgIG1heCA9IHBhcnNlTnVtKHN0cmVhbSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1heCA9IC0xO1xuICAgIH1cbiAgICBpZiAoIXN0cmVhbS5lYXQoXCJ9XCIpKVxuICAgICAgICBzdHJlYW0uZXJyKFwiVW5jbG9zZWQgYnJhY2VkIHJhbmdlXCIpO1xuICAgIHJldHVybiB7IHR5cGU6IFwicmFuZ2VcIiwgbWluLCBtYXgsIGV4cHIgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVOYW1lKHN0cmVhbSwgbmFtZSkge1xuICAgIGxldCB0eXBlcyA9IHN0cmVhbS5ub2RlVHlwZXMsIHR5cGUgPSB0eXBlc1tuYW1lXTtcbiAgICBpZiAodHlwZSlcbiAgICAgICAgcmV0dXJuIFt0eXBlXTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgdHlwZU5hbWUgaW4gdHlwZXMpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1t0eXBlTmFtZV07XG4gICAgICAgIGlmICh0eXBlLmdyb3Vwcy5pbmRleE9mKG5hbWUpID4gLTEpXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0eXBlKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPT0gMClcbiAgICAgICAgc3RyZWFtLmVycihcIk5vIG5vZGUgdHlwZSBvciBncm91cCAnXCIgKyBuYW1lICsgXCInIGZvdW5kXCIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJBdG9tKHN0cmVhbSkge1xuICAgIGlmIChzdHJlYW0uZWF0KFwiKFwiKSkge1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHJlYW0pO1xuICAgICAgICBpZiAoIXN0cmVhbS5lYXQoXCIpXCIpKVxuICAgICAgICAgICAgc3RyZWFtLmVycihcIk1pc3NpbmcgY2xvc2luZyBwYXJlblwiKTtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICAgIGVsc2UgaWYgKCEvXFxXLy50ZXN0KHN0cmVhbS5uZXh0KSkge1xuICAgICAgICBsZXQgZXhwcnMgPSByZXNvbHZlTmFtZShzdHJlYW0sIHN0cmVhbS5uZXh0KS5tYXAodHlwZSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLmlubGluZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHN0cmVhbS5pbmxpbmUgPSB0eXBlLmlzSW5saW5lO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmlubGluZSAhPSB0eXBlLmlzSW5saW5lKVxuICAgICAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJNaXhpbmcgaW5saW5lIGFuZCBibG9jayBjb250ZW50XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJuYW1lXCIsIHZhbHVlOiB0eXBlIH07XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW0ucG9zKys7XG4gICAgICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogeyB0eXBlOiBcImNob2ljZVwiLCBleHBycyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RyZWFtLmVycihcIlVuZXhwZWN0ZWQgdG9rZW4gJ1wiICsgc3RyZWFtLm5leHQgKyBcIidcIik7XG4gICAgfVxufVxuLyoqXG5Db25zdHJ1Y3QgYW4gTkZBIGZyb20gYW4gZXhwcmVzc2lvbiBhcyByZXR1cm5lZCBieSB0aGUgcGFyc2VyLiBUaGVcbk5GQSBpcyByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBzdGF0ZXMsIHdoaWNoIGFyZSB0aGVtc2VsdmVzXG5hcnJheXMgb2YgZWRnZXMsIHdoaWNoIGFyZSBge3Rlcm0sIHRvfWAgb2JqZWN0cy4gVGhlIGZpcnN0IHN0YXRlIGlzXG50aGUgZW50cnkgc3RhdGUgYW5kIHRoZSBsYXN0IG5vZGUgaXMgdGhlIHN1Y2Nlc3Mgc3RhdGUuXG5cbk5vdGUgdGhhdCB1bmxpa2UgdHlwaWNhbCBORkFzLCB0aGUgZWRnZSBvcmRlcmluZyBpbiB0aGlzIG9uZSBpc1xuc2lnbmlmaWNhbnQsIGluIHRoYXQgaXQgaXMgdXNlZCB0byBjb250cnVjdCBmaWxsZXIgY29udGVudCB3aGVuXG5uZWNlc3NhcnkuXG4qL1xuZnVuY3Rpb24gbmZhKGV4cHIpIHtcbiAgICBsZXQgbmZhID0gW1tdXTtcbiAgICBjb25uZWN0KGNvbXBpbGUoZXhwciwgMCksIG5vZGUoKSk7XG4gICAgcmV0dXJuIG5mYTtcbiAgICBmdW5jdGlvbiBub2RlKCkgeyByZXR1cm4gbmZhLnB1c2goW10pIC0gMTsgfVxuICAgIGZ1bmN0aW9uIGVkZ2UoZnJvbSwgdG8sIHRlcm0pIHtcbiAgICAgICAgbGV0IGVkZ2UgPSB7IHRlcm0sIHRvIH07XG4gICAgICAgIG5mYVtmcm9tXS5wdXNoKGVkZ2UpO1xuICAgICAgICByZXR1cm4gZWRnZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29ubmVjdChlZGdlcywgdG8pIHtcbiAgICAgICAgZWRnZXMuZm9yRWFjaChlZGdlID0+IGVkZ2UudG8gPSB0byk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBpbGUoZXhwciwgZnJvbSkge1xuICAgICAgICBpZiAoZXhwci50eXBlID09IFwiY2hvaWNlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBleHByLmV4cHJzLnJlZHVjZSgob3V0LCBleHByKSA9PiBvdXQuY29uY2F0KGNvbXBpbGUoZXhwciwgZnJvbSkpLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwic2VxXCIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjb21waWxlKGV4cHIuZXhwcnNbaV0sIGZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChpID09IGV4cHIuZXhwcnMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgY29ubmVjdChuZXh0LCBmcm9tID0gbm9kZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJzdGFyXCIpIHtcbiAgICAgICAgICAgIGxldCBsb29wID0gbm9kZSgpO1xuICAgICAgICAgICAgZWRnZShmcm9tLCBsb29wKTtcbiAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGxvb3ApLCBsb29wKTtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShsb29wKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwicGx1c1wiKSB7XG4gICAgICAgICAgICBsZXQgbG9vcCA9IG5vZGUoKTtcbiAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGZyb20pLCBsb29wKTtcbiAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGxvb3ApLCBsb29wKTtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShsb29wKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwib3B0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShmcm9tKV0uY29uY2F0KGNvbXBpbGUoZXhwci5leHByLCBmcm9tKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwicmFuZ2VcIikge1xuICAgICAgICAgICAgbGV0IGN1ciA9IGZyb207XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHIubWluOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUoKTtcbiAgICAgICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBuZXh0KTtcbiAgICAgICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cHIubWF4ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBleHByLm1pbjsgaSA8IGV4cHIubWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2UoY3VyLCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IG5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGN1cildO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcIm5hbWVcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGZyb20sIHVuZGVmaW5lZCwgZXhwci52YWx1ZSldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBleHByIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjbXAoYSwgYikgeyByZXR1cm4gYiAtIGE7IH1cbi8vIEdldCB0aGUgc2V0IG9mIG5vZGVzIHJlYWNoYWJsZSBieSBudWxsIGVkZ2VzIGZyb20gYG5vZGVgLiBPbWl0XG4vLyBub2RlcyB3aXRoIG9ubHkgYSBzaW5nbGUgbnVsbC1vdXQtZWRnZSwgc2luY2UgdGhleSBtYXkgbGVhZCB0b1xuLy8gbmVlZGxlc3MgZHVwbGljYXRlZCBub2Rlcy5cbmZ1bmN0aW9uIG51bGxGcm9tKG5mYSwgbm9kZSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBzY2FuKG5vZGUpO1xuICAgIHJldHVybiByZXN1bHQuc29ydChjbXApO1xuICAgIGZ1bmN0aW9uIHNjYW4obm9kZSkge1xuICAgICAgICBsZXQgZWRnZXMgPSBuZmFbbm9kZV07XG4gICAgICAgIGlmIChlZGdlcy5sZW5ndGggPT0gMSAmJiAhZWRnZXNbMF0udGVybSlcbiAgICAgICAgICAgIHJldHVybiBzY2FuKGVkZ2VzWzBdLnRvKTtcbiAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IHRlcm0sIHRvIH0gPSBlZGdlc1tpXTtcbiAgICAgICAgICAgIGlmICghdGVybSAmJiByZXN1bHQuaW5kZXhPZih0bykgPT0gLTEpXG4gICAgICAgICAgICAgICAgc2Nhbih0byk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBDb21waWxlcyBhbiBORkEgYXMgcHJvZHVjZWQgYnkgYG5mYWAgaW50byBhIERGQSwgbW9kZWxlZCBhcyBhIHNldFxuLy8gb2Ygc3RhdGUgb2JqZWN0cyAoYENvbnRlbnRNYXRjaGAgaW5zdGFuY2VzKSB3aXRoIHRyYW5zaXRpb25zXG4vLyBiZXR3ZWVuIHRoZW0uXG5mdW5jdGlvbiBkZmEobmZhKSB7XG4gICAgbGV0IGxhYmVsZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiBleHBsb3JlKG51bGxGcm9tKG5mYSwgMCkpO1xuICAgIGZ1bmN0aW9uIGV4cGxvcmUoc3RhdGVzKSB7XG4gICAgICAgIGxldCBvdXQgPSBbXTtcbiAgICAgICAgc3RhdGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBuZmFbbm9kZV0uZm9yRWFjaCgoeyB0ZXJtLCB0byB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0ZXJtKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbGV0IHNldDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dFtpXVswXSA9PSB0ZXJtKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0ID0gb3V0W2ldWzFdO1xuICAgICAgICAgICAgICAgIG51bGxGcm9tKG5mYSwgdG8pLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goW3Rlcm0sIHNldCA9IFtdXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXQuaW5kZXhPZihub2RlKSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgc3RhdGUgPSBsYWJlbGVkW3N0YXRlcy5qb2luKFwiLFwiKV0gPSBuZXcgQ29udGVudE1hdGNoKHN0YXRlcy5pbmRleE9mKG5mYS5sZW5ndGggLSAxKSA+IC0xKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZXMgPSBvdXRbaV1bMV0uc29ydChjbXApO1xuICAgICAgICAgICAgc3RhdGUubmV4dC5wdXNoKHsgdHlwZTogb3V0W2ldWzBdLCBuZXh0OiBsYWJlbGVkW3N0YXRlcy5qb2luKFwiLFwiKV0gfHwgZXhwbG9yZShzdGF0ZXMpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0ZvckRlYWRFbmRzKG1hdGNoLCBzdHJlYW0pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgd29yayA9IFttYXRjaF07IGkgPCB3b3JrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHdvcmtbaV0sIGRlYWQgPSAhc3RhdGUudmFsaWRFbmQsIG5vZGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdGUubmV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gc3RhdGUubmV4dFtqXTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2godHlwZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChkZWFkICYmICEodHlwZS5pc1RleHQgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpKVxuICAgICAgICAgICAgICAgIGRlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh3b3JrLmluZGV4T2YobmV4dCkgPT0gLTEpXG4gICAgICAgICAgICAgICAgd29yay5wdXNoKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWFkKVxuICAgICAgICAgICAgc3RyZWFtLmVycihcIk9ubHkgbm9uLWdlbmVyYXRhYmxlIG5vZGVzIChcIiArIG5vZGVzLmpvaW4oXCIsIFwiKSArIFwiKSBpbiBhIHJlcXVpcmVkIHBvc2l0aW9uIChzZWUgaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9ndWlkZS8jZ2VuZXJhdGFibGUpXCIpO1xuICAgIH1cbn1cblxuLy8gRm9yIG5vZGUgdHlwZXMgd2hlcmUgYWxsIGF0dHJzIGhhdmUgYSBkZWZhdWx0IHZhbHVlIChvciB3aGljaCBkb24ndFxuLy8gaGF2ZSBhbnkgYXR0cmlidXRlcyksIGJ1aWxkIHVwIGEgc2luZ2xlIHJldXNhYmxlIGRlZmF1bHQgYXR0cmlidXRlXG4vLyBvYmplY3QsIGFuZCB1c2UgaXQgZm9yIGFsbCBub2RlcyB0aGF0IGRvbid0IHNwZWNpZnkgc3BlY2lmaWNcbi8vIGF0dHJpYnV0ZXMuXG5mdW5jdGlvbiBkZWZhdWx0QXR0cnMoYXR0cnMpIHtcbiAgICBsZXQgZGVmYXVsdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IGF0dHJOYW1lIGluIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyID0gYXR0cnNbYXR0ck5hbWVdO1xuICAgICAgICBpZiAoIWF0dHIuaGFzRGVmYXVsdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBkZWZhdWx0c1thdHRyTmFtZV0gPSBhdHRyLmRlZmF1bHQ7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0cztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVBdHRycyhhdHRycywgdmFsdWUpIHtcbiAgICBsZXQgYnVpbHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgbGV0IGdpdmVuID0gdmFsdWUgJiYgdmFsdWVbbmFtZV07XG4gICAgICAgIGlmIChnaXZlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgYXR0ciA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgaWYgKGF0dHIuaGFzRGVmYXVsdClcbiAgICAgICAgICAgICAgICBnaXZlbiA9IGF0dHIuZGVmYXVsdDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIHZhbHVlIHN1cHBsaWVkIGZvciBhdHRyaWJ1dGUgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsdFtuYW1lXSA9IGdpdmVuO1xuICAgIH1cbiAgICByZXR1cm4gYnVpbHQ7XG59XG5mdW5jdGlvbiBpbml0QXR0cnMoYXR0cnMpIHtcbiAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoYXR0cnMpXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSBuZXcgQXR0cmlidXRlKGF0dHJzW25hbWVdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5Ob2RlIHR5cGVzIGFyZSBvYmplY3RzIGFsbG9jYXRlZCBvbmNlIHBlciBgU2NoZW1hYCBhbmQgdXNlZCB0b1xuW3RhZ10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUudHlwZSkgYE5vZGVgIGluc3RhbmNlcy4gVGhleSBjb250YWluIGluZm9ybWF0aW9uXG5hYm91dCB0aGUgbm9kZSB0eXBlLCBzdWNoIGFzIGl0cyBuYW1lIGFuZCB3aGF0IGtpbmQgb2Ygbm9kZSBpdFxucmVwcmVzZW50cy5cbiovXG5jbGFzcyBOb2RlVHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSB0aGUgbm9kZSB0eXBlIGhhcyBpbiB0aGlzIHNjaGVtYS5cbiAgICAqL1xuICAgIG5hbWUsIFxuICAgIC8qKlxuICAgIEEgbGluayBiYWNrIHRvIHRoZSBgU2NoZW1hYCB0aGUgbm9kZSB0eXBlIGJlbG9uZ3MgdG8uXG4gICAgKi9cbiAgICBzY2hlbWEsIFxuICAgIC8qKlxuICAgIFRoZSBzcGVjIHRoYXQgdGhpcyB0eXBlIGlzIGJhc2VkIG9uXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIHNldCBvZiBtYXJrcyBhbGxvd2VkIGluIHRoaXMgbm9kZS4gYG51bGxgIG1lYW5zIGFsbCBtYXJrc1xuICAgICAgICBhcmUgYWxsb3dlZC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXJrU2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5ncm91cHMgPSBzcGVjLmdyb3VwID8gc3BlYy5ncm91cC5zcGxpdChcIiBcIikgOiBbXTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGluaXRBdHRycyhzcGVjLmF0dHJzKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0QXR0cnMgPSBkZWZhdWx0QXR0cnModGhpcy5hdHRycyk7XG4gICAgICAgIHRoaXMuY29udGVudE1hdGNoID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmxpbmVDb250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0Jsb2NrID0gIShzcGVjLmlubGluZSB8fCBuYW1lID09IFwidGV4dFwiKTtcbiAgICAgICAgdGhpcy5pc1RleHQgPSBuYW1lID09IFwidGV4dFwiO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHRoaXMgaXMgYW4gaW5saW5lIHR5cGUuXG4gICAgKi9cbiAgICBnZXQgaXNJbmxpbmUoKSB7IHJldHVybiAhdGhpcy5pc0Jsb2NrOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB0aGlzIGlzIGEgdGV4dGJsb2NrIHR5cGUsIGEgYmxvY2sgdGhhdCBjb250YWlucyBpbmxpbmVcbiAgICBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlzVGV4dGJsb2NrKCkgeyByZXR1cm4gdGhpcy5pc0Jsb2NrICYmIHRoaXMuaW5saW5lQ29udGVudDsgfVxuICAgIC8qKlxuICAgIFRydWUgZm9yIG5vZGUgdHlwZXMgdGhhdCBhbGxvdyBubyBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlzTGVhZigpIHsgcmV0dXJuIHRoaXMuY29udGVudE1hdGNoID09IENvbnRlbnRNYXRjaC5lbXB0eTsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG5vZGUgaXMgYW4gYXRvbSwgaS5lLiB3aGVuIGl0IGRvZXMgbm90IGhhdmVcbiAgICBkaXJlY3RseSBlZGl0YWJsZSBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlzQXRvbSgpIHsgcmV0dXJuIHRoaXMuaXNMZWFmIHx8ICEhdGhpcy5zcGVjLmF0b207IH1cbiAgICAvKipcbiAgICBUaGUgbm9kZSB0eXBlJ3MgW3doaXRlc3BhY2VdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy53aGl0ZXNwYWNlKSBvcHRpb24uXG4gICAgKi9cbiAgICBnZXQgd2hpdGVzcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy53aGl0ZXNwYWNlIHx8ICh0aGlzLnNwZWMuY29kZSA/IFwicHJlXCIgOiBcIm5vcm1hbFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhpcyBub2RlIHR5cGUgaGFzIGFueSByZXF1aXJlZCBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgaGFzUmVxdWlyZWRBdHRycygpIHtcbiAgICAgICAgZm9yIChsZXQgbiBpbiB0aGlzLmF0dHJzKVxuICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnNbbl0uaXNSZXF1aXJlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIG5vZGUgYWxsb3dzIHNvbWUgb2YgdGhlIHNhbWUgY29udGVudCBhc1xuICAgIHRoZSBnaXZlbiBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBjb21wYXRpYmxlQ29udGVudChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCB0aGlzLmNvbnRlbnRNYXRjaC5jb21wYXRpYmxlKG90aGVyLmNvbnRlbnRNYXRjaCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcHV0ZUF0dHJzKGF0dHJzKSB7XG4gICAgICAgIGlmICghYXR0cnMgJiYgdGhpcy5kZWZhdWx0QXR0cnMpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0QXR0cnM7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlQXR0cnModGhpcy5hdHRycywgYXR0cnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBgTm9kZWAgb2YgdGhpcyB0eXBlLiBUaGUgZ2l2ZW4gYXR0cmlidXRlcyBhcmVcbiAgICBjaGVja2VkIGFuZCBkZWZhdWx0ZWQgKHlvdSBjYW4gcGFzcyBgbnVsbGAgdG8gdXNlIHRoZSB0eXBlJ3NcbiAgICBkZWZhdWx0cyBlbnRpcmVseSwgaWYgbm8gcmVxdWlyZWQgYXR0cmlidXRlcyBleGlzdCkuIGBjb250ZW50YFxuICAgIG1heSBiZSBhIGBGcmFnbWVudGAsIGEgbm9kZSwgYW4gYXJyYXkgb2Ygbm9kZXMsIG9yXG4gICAgYG51bGxgLiBTaW1pbGFybHkgYG1hcmtzYCBtYXkgYmUgYG51bGxgIHRvIGRlZmF1bHQgdG8gdGhlIGVtcHR5XG4gICAgc2V0IG9mIG1hcmtzLlxuICAgICovXG4gICAgY3JlYXRlKGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUZXh0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZVR5cGUuY3JlYXRlIGNhbid0IGNvbnN0cnVjdCB0ZXh0IG5vZGVzXCIpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpLCBGcmFnbWVudC5mcm9tKGNvbnRlbnQpLCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTGlrZSBbYGNyZWF0ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlVHlwZS5jcmVhdGUpLCBidXQgY2hlY2sgdGhlIGdpdmVuIGNvbnRlbnRcbiAgICBhZ2FpbnN0IHRoZSBub2RlIHR5cGUncyBjb250ZW50IHJlc3RyaWN0aW9ucywgYW5kIHRocm93IGFuIGVycm9yXG4gICAgaWYgaXQgZG9lc24ndCBtYXRjaC5cbiAgICAqL1xuICAgIGNyZWF0ZUNoZWNrZWQoYXR0cnMgPSBudWxsLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbShjb250ZW50KTtcbiAgICAgICAgdGhpcy5jaGVja0NvbnRlbnQoY29udGVudCk7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyksIGNvbnRlbnQsIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBMaWtlIFtgY3JlYXRlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVUeXBlLmNyZWF0ZSksIGJ1dCBzZWUgaWYgaXQgaXNcbiAgICBuZWNlc3NhcnkgdG8gYWRkIG5vZGVzIHRvIHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGdpdmVuIGZyYWdtZW50XG4gICAgdG8gbWFrZSBpdCBmaXQgdGhlIG5vZGUuIElmIG5vIGZpdHRpbmcgd3JhcHBpbmcgY2FuIGJlIGZvdW5kLFxuICAgIHJldHVybiBudWxsLiBOb3RlIHRoYXQsIGR1ZSB0byB0aGUgZmFjdCB0aGF0IHJlcXVpcmVkIG5vZGVzIGNhblxuICAgIGFsd2F5cyBiZSBjcmVhdGVkLCB0aGlzIHdpbGwgYWx3YXlzIHN1Y2NlZWQgaWYgeW91IHBhc3MgbnVsbCBvclxuICAgIGBGcmFnbWVudC5lbXB0eWAgYXMgY29udGVudC5cbiAgICAqL1xuICAgIGNyZWF0ZUFuZEZpbGwoYXR0cnMgPSBudWxsLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBhdHRycyA9IHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKTtcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20oY29udGVudCk7XG4gICAgICAgIGlmIChjb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSB0aGlzLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKCFiZWZvcmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb250ZW50ID0gYmVmb3JlLmFwcGVuZChjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWF0Y2hlZCA9IHRoaXMuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoY29udGVudCk7XG4gICAgICAgIGxldCBhZnRlciA9IG1hdGNoZWQgJiYgbWF0Y2hlZC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgICAgaWYgKCFhZnRlcilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgYXR0cnMsIGNvbnRlbnQuYXBwZW5kKGFmdGVyKSwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZnJhZ21lbnQgaXMgdmFsaWQgY29udGVudCBmb3IgdGhpcyBub2RlXG4gICAgdHlwZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgdmFsaWRDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoY29udGVudCk7XG4gICAgICAgIGlmICghcmVzdWx0IHx8ICFyZXN1bHQudmFsaWRFbmQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudC5jaGlsZENvdW50OyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dzTWFya3MoY29udGVudC5jaGlsZChpKS5tYXJrcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhyb3dzIGEgUmFuZ2VFcnJvciBpZiB0aGUgZ2l2ZW4gZnJhZ21lbnQgaXMgbm90IHZhbGlkIGNvbnRlbnQgZm9yIHRoaXNcbiAgICBub2RlIHR5cGUuXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaGVja0NvbnRlbnQoY29udGVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmFsaWRDb250ZW50KGNvbnRlbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgY29udGVudCBmb3Igbm9kZSAke3RoaXMubmFtZX06ICR7Y29udGVudC50b1N0cmluZygpLnNsaWNlKDAsIDUwKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gbWFyayB0eXBlIGlzIGFsbG93ZWQgaW4gdGhpcyBub2RlLlxuICAgICovXG4gICAgYWxsb3dzTWFya1R5cGUobWFya1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFya1NldCA9PSBudWxsIHx8IHRoaXMubWFya1NldC5pbmRleE9mKG1hcmtUeXBlKSA+IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhlIGdpdmVuIHNldCBvZiBtYXJrcyBhcmUgYWxsb3dlZCBpbiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBhbGxvd3NNYXJrcyhtYXJrcykge1xuICAgICAgICBpZiAodGhpcy5tYXJrU2V0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxvd3NNYXJrVHlwZShtYXJrc1tpXS50eXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmVzIHRoZSBtYXJrcyB0aGF0IGFyZSBub3QgYWxsb3dlZCBpbiB0aGlzIG5vZGUgZnJvbSB0aGUgZ2l2ZW4gc2V0LlxuICAgICovXG4gICAgYWxsb3dlZE1hcmtzKG1hcmtzKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcmtTZXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBtYXJrcztcbiAgICAgICAgbGV0IGNvcHk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxvd3NNYXJrVHlwZShtYXJrc1tpXS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IG1hcmtzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29weSkge1xuICAgICAgICAgICAgICAgIGNvcHkucHVzaChtYXJrc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFjb3B5ID8gbWFya3MgOiBjb3B5Lmxlbmd0aCA/IGNvcHkgOiBNYXJrLm5vbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNvbXBpbGUobm9kZXMsIHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaCgobmFtZSwgc3BlYykgPT4gcmVzdWx0W25hbWVdID0gbmV3IE5vZGVUeXBlKG5hbWUsIHNjaGVtYSwgc3BlYykpO1xuICAgICAgICBsZXQgdG9wVHlwZSA9IHNjaGVtYS5zcGVjLnRvcE5vZGUgfHwgXCJkb2NcIjtcbiAgICAgICAgaWYgKCFyZXN1bHRbdG9wVHlwZV0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlNjaGVtYSBpcyBtaXNzaW5nIGl0cyB0b3Agbm9kZSB0eXBlICgnXCIgKyB0b3BUeXBlICsgXCInKVwiKTtcbiAgICAgICAgaWYgKCFyZXN1bHQudGV4dClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRXZlcnkgc2NoZW1hIG5lZWRzIGEgJ3RleHQnIHR5cGVcIik7XG4gICAgICAgIGZvciAobGV0IF8gaW4gcmVzdWx0LnRleHQuYXR0cnMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSB0ZXh0IG5vZGUgdHlwZSBzaG91bGQgbm90IGhhdmUgYXR0cmlidXRlc1wiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyBBdHRyaWJ1dGUgZGVzY3JpcHRvcnNcbmNsYXNzIEF0dHJpYnV0ZSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLmhhc0RlZmF1bHQgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJkZWZhdWx0XCIpO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSBvcHRpb25zLmRlZmF1bHQ7XG4gICAgfVxuICAgIGdldCBpc1JlcXVpcmVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaGFzRGVmYXVsdDtcbiAgICB9XG59XG4vLyBNYXJrc1xuLyoqXG5MaWtlIG5vZGVzLCBtYXJrcyAod2hpY2ggYXJlIGFzc29jaWF0ZWQgd2l0aCBub2RlcyB0byBzaWduaWZ5XG50aGluZ3MgbGlrZSBlbXBoYXNpcyBvciBiZWluZyBwYXJ0IG9mIGEgbGluaykgYXJlXG5bdGFnZ2VkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFyay50eXBlKSB3aXRoIHR5cGUgb2JqZWN0cywgd2hpY2ggYXJlXG5pbnN0YW50aWF0ZWQgb25jZSBwZXIgYFNjaGVtYWAuXG4qL1xuY2xhc3MgTWFya1R5cGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5hbWUgb2YgdGhlIG1hcmsgdHlwZS5cbiAgICAqL1xuICAgIG5hbWUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmFuaywgXG4gICAgLyoqXG4gICAgVGhlIHNjaGVtYSB0aGF0IHRoaXMgbWFyayB0eXBlIGluc3RhbmNlIGlzIHBhcnQgb2YuXG4gICAgKi9cbiAgICBzY2hlbWEsIFxuICAgIC8qKlxuICAgIFRoZSBzcGVjIG9uIHdoaWNoIHRoZSB0eXBlIGlzIGJhc2VkLlxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnJhbmsgPSByYW5rO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgdGhpcy5hdHRycyA9IGluaXRBdHRycyhzcGVjLmF0dHJzKTtcbiAgICAgICAgdGhpcy5leGNsdWRlZCA9IG51bGw7XG4gICAgICAgIGxldCBkZWZhdWx0cyA9IGRlZmF1bHRBdHRycyh0aGlzLmF0dHJzKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGRlZmF1bHRzID8gbmV3IE1hcmsodGhpcywgZGVmYXVsdHMpIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayBvZiB0aGlzIHR5cGUuIGBhdHRyc2AgbWF5IGJlIGBudWxsYCBvciBhbiBvYmplY3RcbiAgICBjb250YWluaW5nIG9ubHkgc29tZSBvZiB0aGUgbWFyaydzIGF0dHJpYnV0ZXMuIFRoZSBvdGhlcnMsIGlmXG4gICAgdGhleSBoYXZlIGRlZmF1bHRzLCB3aWxsIGJlIGFkZGVkLlxuICAgICovXG4gICAgY3JlYXRlKGF0dHJzID0gbnVsbCkge1xuICAgICAgICBpZiAoIWF0dHJzICYmIHRoaXMuaW5zdGFuY2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrKHRoaXMsIGNvbXB1dGVBdHRycyh0aGlzLmF0dHJzLCBhdHRycykpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjb21waWxlKG1hcmtzLCBzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCksIHJhbmsgPSAwO1xuICAgICAgICBtYXJrcy5mb3JFYWNoKChuYW1lLCBzcGVjKSA9PiByZXN1bHRbbmFtZV0gPSBuZXcgTWFya1R5cGUobmFtZSwgcmFuaysrLCBzY2hlbWEsIHNwZWMpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hlbiB0aGVyZSBpcyBhIG1hcmsgb2YgdGhpcyB0eXBlIGluIHRoZSBnaXZlbiBzZXQsIGEgbmV3IHNldFxuICAgIHdpdGhvdXQgaXQgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSwgdGhlIGlucHV0IHNldCBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIHJlbW92ZUZyb21TZXQoc2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHNldFtpXS50eXBlID09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICBzZXQgPSBzZXQuc2xpY2UoMCwgaSkuY29uY2F0KHNldC5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdHMgd2hldGhlciB0aGVyZSBpcyBhIG1hcmsgb2YgdGhpcyB0eXBlIGluIHRoZSBnaXZlbiBzZXQuXG4gICAgKi9cbiAgICBpc0luU2V0KHNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChzZXRbaV0udHlwZSA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRbaV07XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJpZXMgd2hldGhlciBhIGdpdmVuIG1hcmsgdHlwZSBpc1xuICAgIFtleGNsdWRlZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtTcGVjLmV4Y2x1ZGVzKSBieSB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGV4Y2x1ZGVzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4Y2x1ZGVkLmluZGV4T2Yob3RoZXIpID4gLTE7XG4gICAgfVxufVxuLyoqXG5BIGRvY3VtZW50IHNjaGVtYS4gSG9sZHMgW25vZGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlVHlwZSkgYW5kIFttYXJrXG50eXBlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1R5cGUpIG9iamVjdHMgZm9yIHRoZSBub2RlcyBhbmQgbWFya3MgdGhhdCBtYXlcbm9jY3VyIGluIGNvbmZvcm1pbmcgZG9jdW1lbnRzLCBhbmQgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3JcbmNyZWF0aW5nIGFuZCBkZXNlcmlhbGl6aW5nIHN1Y2ggZG9jdW1lbnRzLlxuXG5XaGVuIGdpdmVuLCB0aGUgdHlwZSBwYXJhbWV0ZXJzIHByb3ZpZGUgdGhlIG5hbWVzIG9mIHRoZSBub2RlcyBhbmRcbm1hcmtzIGluIHRoaXMgc2NoZW1hLlxuKi9cbmNsYXNzIFNjaGVtYSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgc2NoZW1hIGZyb20gYSBzY2hlbWEgW3NwZWNpZmljYXRpb25dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5TY2hlbWFTcGVjKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEFuIG9iamVjdCBmb3Igc3RvcmluZyB3aGF0ZXZlciB2YWx1ZXMgbW9kdWxlcyBtYXkgd2FudCB0b1xuICAgICAgICBjb21wdXRlIGFuZCBjYWNoZSBwZXIgc2NoZW1hLiAoSWYgeW91IHdhbnQgdG8gc3RvcmUgc29tZXRoaW5nXG4gICAgICAgIGluIGl0LCB0cnkgdG8gdXNlIHByb3BlcnR5IG5hbWVzIHVubGlrZWx5IHRvIGNsYXNoLilcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWNoZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgaW5zdGFuY2VTcGVjID0gdGhpcy5zcGVjID0ge307XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gc3BlYylcbiAgICAgICAgICAgIGluc3RhbmNlU3BlY1twcm9wXSA9IHNwZWNbcHJvcF07XG4gICAgICAgIGluc3RhbmNlU3BlYy5ub2RlcyA9IE9yZGVyZWRNYXAuZnJvbShzcGVjLm5vZGVzKSxcbiAgICAgICAgICAgIGluc3RhbmNlU3BlYy5tYXJrcyA9IE9yZGVyZWRNYXAuZnJvbShzcGVjLm1hcmtzIHx8IHt9KSxcbiAgICAgICAgICAgIHRoaXMubm9kZXMgPSBOb2RlVHlwZS5jb21waWxlKHRoaXMuc3BlYy5ub2RlcywgdGhpcyk7XG4gICAgICAgIHRoaXMubWFya3MgPSBNYXJrVHlwZS5jb21waWxlKHRoaXMuc3BlYy5tYXJrcywgdGhpcyk7XG4gICAgICAgIGxldCBjb250ZW50RXhwckNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcCBpbiB0aGlzLm1hcmtzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHByb3AgKyBcIiBjYW4gbm90IGJlIGJvdGggYSBub2RlIGFuZCBhIG1hcmtcIik7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMubm9kZXNbcHJvcF0sIGNvbnRlbnRFeHByID0gdHlwZS5zcGVjLmNvbnRlbnQgfHwgXCJcIiwgbWFya0V4cHIgPSB0eXBlLnNwZWMubWFya3M7XG4gICAgICAgICAgICB0eXBlLmNvbnRlbnRNYXRjaCA9IGNvbnRlbnRFeHByQ2FjaGVbY29udGVudEV4cHJdIHx8XG4gICAgICAgICAgICAgICAgKGNvbnRlbnRFeHByQ2FjaGVbY29udGVudEV4cHJdID0gQ29udGVudE1hdGNoLnBhcnNlKGNvbnRlbnRFeHByLCB0aGlzLm5vZGVzKSk7XG4gICAgICAgICAgICB0eXBlLmlubGluZUNvbnRlbnQgPSB0eXBlLmNvbnRlbnRNYXRjaC5pbmxpbmVDb250ZW50O1xuICAgICAgICAgICAgdHlwZS5tYXJrU2V0ID0gbWFya0V4cHIgPT0gXCJfXCIgPyBudWxsIDpcbiAgICAgICAgICAgICAgICBtYXJrRXhwciA/IGdhdGhlck1hcmtzKHRoaXMsIG1hcmtFeHByLnNwbGl0KFwiIFwiKSkgOlxuICAgICAgICAgICAgICAgICAgICBtYXJrRXhwciA9PSBcIlwiIHx8ICF0eXBlLmlubGluZUNvbnRlbnQgPyBbXSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0aGlzLm1hcmtzKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMubWFya3NbcHJvcF0sIGV4Y2wgPSB0eXBlLnNwZWMuZXhjbHVkZXM7XG4gICAgICAgICAgICB0eXBlLmV4Y2x1ZGVkID0gZXhjbCA9PSBudWxsID8gW3R5cGVdIDogZXhjbCA9PSBcIlwiID8gW10gOiBnYXRoZXJNYXJrcyh0aGlzLCBleGNsLnNwbGl0KFwiIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlRnJvbUpTT04gPSB0aGlzLm5vZGVGcm9tSlNPTi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1hcmtGcm9tSlNPTiA9IHRoaXMubWFya0Zyb21KU09OLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudG9wTm9kZVR5cGUgPSB0aGlzLm5vZGVzW3RoaXMuc3BlYy50b3BOb2RlIHx8IFwiZG9jXCJdO1xuICAgICAgICB0aGlzLmNhY2hlZC53cmFwcGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBub2RlIGluIHRoaXMgc2NoZW1hLiBUaGUgYHR5cGVgIG1heSBiZSBhIHN0cmluZyBvciBhXG4gICAgYE5vZGVUeXBlYCBpbnN0YW5jZS4gQXR0cmlidXRlcyB3aWxsIGJlIGV4dGVuZGVkIHdpdGggZGVmYXVsdHMsXG4gICAgYGNvbnRlbnRgIG1heSBiZSBhIGBGcmFnbWVudGAsIGBudWxsYCwgYSBgTm9kZWAsIG9yIGFuIGFycmF5IG9mXG4gICAgbm9kZXMuXG4gICAgKi9cbiAgICBub2RlKHR5cGUsIGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0eXBlID0gdGhpcy5ub2RlVHlwZSh0eXBlKTtcbiAgICAgICAgZWxzZSBpZiAoISh0eXBlIGluc3RhbmNlb2YgTm9kZVR5cGUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG5vZGUgdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgZWxzZSBpZiAodHlwZS5zY2hlbWEgIT0gdGhpcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGZyb20gZGlmZmVyZW50IHNjaGVtYSB1c2VkIChcIiArIHR5cGUubmFtZSArIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIHR5cGUuY3JlYXRlQ2hlY2tlZChhdHRycywgY29udGVudCwgbWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB0ZXh0IG5vZGUgaW4gdGhlIHNjaGVtYS4gRW1wdHkgdGV4dCBub2RlcyBhcmUgbm90XG4gICAgYWxsb3dlZC5cbiAgICAqL1xuICAgIHRleHQodGV4dCwgbWFya3MpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0aGlzLm5vZGVzLnRleHQ7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUodHlwZSwgdHlwZS5kZWZhdWx0QXR0cnMsIHRleHQsIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrIHdpdGggdGhlIGdpdmVuIHR5cGUgYW5kIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBtYXJrKHR5cGUsIGF0dHJzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdHlwZSA9IHRoaXMubWFya3NbdHlwZV07XG4gICAgICAgIHJldHVybiB0eXBlLmNyZWF0ZShhdHRycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgbm9kZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBUaGlzIG1ldGhvZCBpc1xuICAgIGJvdW5kLlxuICAgICovXG4gICAgbm9kZUZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIE5vZGUuZnJvbUpTT04odGhpcywganNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgbWFyayBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBUaGlzIG1ldGhvZCBpc1xuICAgIGJvdW5kLlxuICAgICovXG4gICAgbWFya0Zyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIE1hcmsuZnJvbUpTT04odGhpcywganNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbm9kZVR5cGUobmFtZSkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLm5vZGVzW25hbWVdO1xuICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIgKyBuYW1lKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdhdGhlck1hcmtzKHNjaGVtYSwgbWFya3MpIHtcbiAgICBsZXQgZm91bmQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBuYW1lID0gbWFya3NbaV0sIG1hcmsgPSBzY2hlbWEubWFya3NbbmFtZV0sIG9rID0gbWFyaztcbiAgICAgICAgaWYgKG1hcmspIHtcbiAgICAgICAgICAgIGZvdW5kLnB1c2gobWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHNjaGVtYS5tYXJrcykge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrID0gc2NoZW1hLm1hcmtzW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwiX1wiIHx8IChtYXJrLnNwZWMuZ3JvdXAgJiYgbWFyay5zcGVjLmdyb3VwLnNwbGl0KFwiIFwiKS5pbmRleE9mKG5hbWUpID4gLTEpKVxuICAgICAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKG9rID0gbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvaylcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlVua25vd24gbWFyayB0eXBlOiAnXCIgKyBtYXJrc1tpXSArIFwiJ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuXG4vKipcbkEgRE9NIHBhcnNlciByZXByZXNlbnRzIGEgc3RyYXRlZ3kgZm9yIHBhcnNpbmcgRE9NIGNvbnRlbnQgaW50byBhXG5Qcm9zZU1pcnJvciBkb2N1bWVudCBjb25mb3JtaW5nIHRvIGEgZ2l2ZW4gc2NoZW1hLiBJdHMgYmVoYXZpb3IgaXNcbmRlZmluZWQgYnkgYW4gYXJyYXkgb2YgW3J1bGVzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUGFyc2VSdWxlKS5cbiovXG5jbGFzcyBET01QYXJzZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBhcnNlciB0aGF0IHRhcmdldHMgdGhlIGdpdmVuIHNjaGVtYSwgdXNpbmcgdGhlIGdpdmVuXG4gICAgcGFyc2luZyBydWxlcy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzY2hlbWEgaW50byB3aGljaCB0aGUgcGFyc2VyIHBhcnNlcy5cbiAgICAqL1xuICAgIHNjaGVtYSwgXG4gICAgLyoqXG4gICAgVGhlIHNldCBvZiBbcGFyc2UgcnVsZXNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5QYXJzZVJ1bGUpIHRoYXQgdGhlIHBhcnNlclxuICAgIHVzZXMsIGluIG9yZGVyIG9mIHByZWNlZGVuY2UuXG4gICAgKi9cbiAgICBydWxlcykge1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudGFncyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc3R5bGVzID0gW107XG4gICAgICAgIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICBpZiAocnVsZS50YWcpXG4gICAgICAgICAgICAgICAgdGhpcy50YWdzLnB1c2gocnVsZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlLnN0eWxlKVxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBPbmx5IG5vcm1hbGl6ZSBsaXN0IGVsZW1lbnRzIHdoZW4gbGlzdHMgaW4gdGhlIHNjaGVtYSBjYW4ndCBkaXJlY3RseSBjb250YWluIHRoZW1zZWx2ZXNcbiAgICAgICAgdGhpcy5ub3JtYWxpemVMaXN0cyA9ICF0aGlzLnRhZ3Muc29tZShyID0+IHtcbiAgICAgICAgICAgIGlmICghL14odWx8b2wpXFxiLy50ZXN0KHIudGFnKSB8fCAhci5ub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBub2RlID0gc2NoZW1hLm5vZGVzW3Iubm9kZV07XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jb250ZW50TWF0Y2gubWF0Y2hUeXBlKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUGFyc2UgYSBkb2N1bWVudCBmcm9tIHRoZSBjb250ZW50IG9mIGEgRE9NIG5vZGUuXG4gICAgKi9cbiAgICBwYXJzZShkb20sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgY29udGV4dCA9IG5ldyBQYXJzZUNvbnRleHQodGhpcywgb3B0aW9ucywgZmFsc2UpO1xuICAgICAgICBjb250ZXh0LmFkZEFsbChkb20sIG9wdGlvbnMuZnJvbSwgb3B0aW9ucy50byk7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBQYXJzZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGdpdmVuIERPTSBub2RlLCBsaWtlXG4gICAgW2BwYXJzZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5ET01QYXJzZXIucGFyc2UpLCBhbmQgdGFrZXMgdGhlIHNhbWUgc2V0IG9mXG4gICAgb3B0aW9ucy4gQnV0IHVubGlrZSB0aGF0IG1ldGhvZCwgd2hpY2ggcHJvZHVjZXMgYSB3aG9sZSBub2RlLFxuICAgIHRoaXMgb25lIHJldHVybnMgYSBzbGljZSB0aGF0IGlzIG9wZW4gYXQgdGhlIHNpZGVzLCBtZWFuaW5nIHRoYXRcbiAgICB0aGUgc2NoZW1hIGNvbnN0cmFpbnRzIGFyZW4ndCBhcHBsaWVkIHRvIHRoZSBzdGFydCBvZiBub2RlcyB0b1xuICAgIHRoZSBsZWZ0IG9mIHRoZSBpbnB1dCBhbmQgdGhlIGVuZCBvZiBub2RlcyBhdCB0aGUgZW5kLlxuICAgICovXG4gICAgcGFyc2VTbGljZShkb20sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgY29udGV4dCA9IG5ldyBQYXJzZUNvbnRleHQodGhpcywgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIGNvbnRleHQuYWRkQWxsKGRvbSwgb3B0aW9ucy5mcm9tLCBvcHRpb25zLnRvKTtcbiAgICAgICAgcmV0dXJuIFNsaWNlLm1heE9wZW4oY29udGV4dC5maW5pc2goKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWF0Y2hUYWcoZG9tLCBjb250ZXh0LCBhZnRlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gYWZ0ZXIgPyB0aGlzLnRhZ3MuaW5kZXhPZihhZnRlcikgKyAxIDogMDsgaSA8IHRoaXMudGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnRhZ3NbaV07XG4gICAgICAgICAgICBpZiAobWF0Y2hlcyhkb20sIHJ1bGUudGFnKSAmJlxuICAgICAgICAgICAgICAgIChydWxlLm5hbWVzcGFjZSA9PT0gdW5kZWZpbmVkIHx8IGRvbS5uYW1lc3BhY2VVUkkgPT0gcnVsZS5uYW1lc3BhY2UpICYmXG4gICAgICAgICAgICAgICAgKCFydWxlLmNvbnRleHQgfHwgY29udGV4dC5tYXRjaGVzQ29udGV4dChydWxlLmNvbnRleHQpKSkge1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmdldEF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBydWxlLmdldEF0dHJzKGRvbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuYXR0cnMgPSByZXN1bHQgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hdGNoU3R5bGUocHJvcCwgdmFsdWUsIGNvbnRleHQsIGFmdGVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBhZnRlciA/IHRoaXMuc3R5bGVzLmluZGV4T2YoYWZ0ZXIpICsgMSA6IDA7IGkgPCB0aGlzLnN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnN0eWxlc1tpXSwgc3R5bGUgPSBydWxlLnN0eWxlO1xuICAgICAgICAgICAgaWYgKHN0eWxlLmluZGV4T2YocHJvcCkgIT0gMCB8fFxuICAgICAgICAgICAgICAgIHJ1bGUuY29udGV4dCAmJiAhY29udGV4dC5tYXRjaGVzQ29udGV4dChydWxlLmNvbnRleHQpIHx8XG4gICAgICAgICAgICAgICAgLy8gVGVzdCB0aGF0IHRoZSBzdHlsZSBzdHJpbmcgZWl0aGVyIHByZWNpc2VseSBtYXRjaGVzIHRoZSBwcm9wLFxuICAgICAgICAgICAgICAgIC8vIG9yIGhhcyBhbiAnPScgc2lnbiBhZnRlciB0aGUgcHJvcCwgZm9sbG93ZWQgYnkgdGhlIGdpdmVuXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICAgICAgc3R5bGUubGVuZ3RoID4gcHJvcC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgKHN0eWxlLmNoYXJDb2RlQXQocHJvcC5sZW5ndGgpICE9IDYxIHx8IHN0eWxlLnNsaWNlKHByb3AubGVuZ3RoICsgMSkgIT0gdmFsdWUpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJ1bGUuZ2V0QXR0cnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcnVsZS5nZXRBdHRycyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJ1bGUuYXR0cnMgPSByZXN1bHQgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgc2NoZW1hUnVsZXMoc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0KHJ1bGUpIHtcbiAgICAgICAgICAgIGxldCBwcmlvcml0eSA9IHJ1bGUucHJpb3JpdHkgPT0gbnVsbCA/IDUwIDogcnVsZS5wcmlvcml0eSwgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcmVzdWx0W2ldLCBuZXh0UHJpb3JpdHkgPSBuZXh0LnByaW9yaXR5ID09IG51bGwgPyA1MCA6IG5leHQucHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRQcmlvcml0eSA8IHByaW9yaXR5KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoaSwgMCwgcnVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBzY2hlbWEubWFya3MpIHtcbiAgICAgICAgICAgIGxldCBydWxlcyA9IHNjaGVtYS5tYXJrc1tuYW1lXS5zcGVjLnBhcnNlRE9NO1xuICAgICAgICAgICAgaWYgKHJ1bGVzKVxuICAgICAgICAgICAgICAgIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydChydWxlID0gY29weShydWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJ1bGUubWFyayB8fCBydWxlLmlnbm9yZSB8fCBydWxlLmNsZWFyTWFyaykpXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLm1hcmsgPSBuYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gc2NoZW1hLm5vZGVzKSB7XG4gICAgICAgICAgICBsZXQgcnVsZXMgPSBzY2hlbWEubm9kZXNbbmFtZV0uc3BlYy5wYXJzZURPTTtcbiAgICAgICAgICAgIGlmIChydWxlcylcbiAgICAgICAgICAgICAgICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQocnVsZSA9IGNvcHkocnVsZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShydWxlLm5vZGUgfHwgcnVsZS5pZ25vcmUgfHwgcnVsZS5tYXJrKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUubm9kZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgRE9NIHBhcnNlciB1c2luZyB0aGUgcGFyc2luZyBydWxlcyBsaXN0ZWQgaW4gYVxuICAgIHNjaGVtYSdzIFtub2RlIHNwZWNzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMucGFyc2VET00pLCByZW9yZGVyZWQgYnlcbiAgICBbcHJpb3JpdHldKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5QYXJzZVJ1bGUucHJpb3JpdHkpLlxuICAgICovXG4gICAgc3RhdGljIGZyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuY2FjaGVkLmRvbVBhcnNlciB8fFxuICAgICAgICAgICAgKHNjaGVtYS5jYWNoZWQuZG9tUGFyc2VyID0gbmV3IERPTVBhcnNlcihzY2hlbWEsIERPTVBhcnNlci5zY2hlbWFSdWxlcyhzY2hlbWEpKSk7XG4gICAgfVxufVxuY29uc3QgYmxvY2tUYWdzID0ge1xuICAgIGFkZHJlc3M6IHRydWUsIGFydGljbGU6IHRydWUsIGFzaWRlOiB0cnVlLCBibG9ja3F1b3RlOiB0cnVlLCBjYW52YXM6IHRydWUsXG4gICAgZGQ6IHRydWUsIGRpdjogdHJ1ZSwgZGw6IHRydWUsIGZpZWxkc2V0OiB0cnVlLCBmaWdjYXB0aW9uOiB0cnVlLCBmaWd1cmU6IHRydWUsXG4gICAgZm9vdGVyOiB0cnVlLCBmb3JtOiB0cnVlLCBoMTogdHJ1ZSwgaDI6IHRydWUsIGgzOiB0cnVlLCBoNDogdHJ1ZSwgaDU6IHRydWUsXG4gICAgaDY6IHRydWUsIGhlYWRlcjogdHJ1ZSwgaGdyb3VwOiB0cnVlLCBocjogdHJ1ZSwgbGk6IHRydWUsIG5vc2NyaXB0OiB0cnVlLCBvbDogdHJ1ZSxcbiAgICBvdXRwdXQ6IHRydWUsIHA6IHRydWUsIHByZTogdHJ1ZSwgc2VjdGlvbjogdHJ1ZSwgdGFibGU6IHRydWUsIHRmb290OiB0cnVlLCB1bDogdHJ1ZVxufTtcbmNvbnN0IGlnbm9yZVRhZ3MgPSB7XG4gICAgaGVhZDogdHJ1ZSwgbm9zY3JpcHQ6IHRydWUsIG9iamVjdDogdHJ1ZSwgc2NyaXB0OiB0cnVlLCBzdHlsZTogdHJ1ZSwgdGl0bGU6IHRydWVcbn07XG5jb25zdCBsaXN0VGFncyA9IHsgb2w6IHRydWUsIHVsOiB0cnVlIH07XG4vLyBVc2luZyBhIGJpdGZpZWxkIGZvciBub2RlIGNvbnRleHQgb3B0aW9uc1xuY29uc3QgT1BUX1BSRVNFUlZFX1dTID0gMSwgT1BUX1BSRVNFUlZFX1dTX0ZVTEwgPSAyLCBPUFRfT1BFTl9MRUZUID0gNDtcbmZ1bmN0aW9uIHdzT3B0aW9uc0Zvcih0eXBlLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIGJhc2UpIHtcbiAgICBpZiAocHJlc2VydmVXaGl0ZXNwYWNlICE9IG51bGwpXG4gICAgICAgIHJldHVybiAocHJlc2VydmVXaGl0ZXNwYWNlID8gT1BUX1BSRVNFUlZFX1dTIDogMCkgfFxuICAgICAgICAgICAgKHByZXNlcnZlV2hpdGVzcGFjZSA9PT0gXCJmdWxsXCIgPyBPUFRfUFJFU0VSVkVfV1NfRlVMTCA6IDApO1xuICAgIHJldHVybiB0eXBlICYmIHR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiID8gT1BUX1BSRVNFUlZFX1dTIHwgT1BUX1BSRVNFUlZFX1dTX0ZVTEwgOiBiYXNlICYgfk9QVF9PUEVOX0xFRlQ7XG59XG5jbGFzcyBOb2RlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgYXR0cnMsIFxuICAgIC8vIE1hcmtzIGFwcGxpZWQgdG8gdGhpcyBub2RlIGl0c2VsZlxuICAgIG1hcmtzLCBcbiAgICAvLyBNYXJrcyB0aGF0IGNhbid0IGFwcGx5IGhlcmUsIGJ1dCB3aWxsIGJlIHVzZWQgaW4gY2hpbGRyZW4gaWYgcG9zc2libGVcbiAgICBwZW5kaW5nTWFya3MsIHNvbGlkLCBtYXRjaCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICAgICAgdGhpcy5wZW5kaW5nTWFya3MgPSBwZW5kaW5nTWFya3M7XG4gICAgICAgIHRoaXMuc29saWQgPSBzb2xpZDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb250ZW50ID0gW107XG4gICAgICAgIC8vIE1hcmtzIGFwcGxpZWQgdG8gdGhlIG5vZGUncyBjaGlsZHJlblxuICAgICAgICB0aGlzLmFjdGl2ZU1hcmtzID0gTWFyay5ub25lO1xuICAgICAgICAvLyBOZXN0ZWQgTWFya3Mgd2l0aCBzYW1lIHR5cGVcbiAgICAgICAgdGhpcy5zdGFzaE1hcmtzID0gW107XG4gICAgICAgIHRoaXMubWF0Y2ggPSBtYXRjaCB8fCAob3B0aW9ucyAmIE9QVF9PUEVOX0xFRlQgPyBudWxsIDogdHlwZS5jb250ZW50TWF0Y2gpO1xuICAgIH1cbiAgICBmaW5kV3JhcHBpbmcobm9kZSkge1xuICAgICAgICBpZiAoIXRoaXMubWF0Y2gpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy50eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIGxldCBmaWxsID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmZyb20obm9kZSkpO1xuICAgICAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGZpbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaCwgd3JhcDtcbiAgICAgICAgICAgICAgICBpZiAod3JhcCA9IHN0YXJ0LmZpbmRXcmFwcGluZyhub2RlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2ggPSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2guZmluZFdyYXBwaW5nKG5vZGUudHlwZSk7XG4gICAgfVxuICAgIGZpbmlzaChvcGVuRW5kKSB7XG4gICAgICAgIGlmICghKHRoaXMub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XUykpIHsgLy8gU3RyaXAgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdLCBtO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC5pc1RleHQgJiYgKG0gPSAvWyBcXHRcXHJcXG5cXHUwMDBjXSskLy5leGVjKGxhc3QudGV4dCkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHQgPSBsYXN0O1xuICAgICAgICAgICAgICAgIGlmIChsYXN0LnRleHQubGVuZ3RoID09IG1bMF0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQucG9wKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdID0gdGV4dC53aXRoVGV4dCh0ZXh0LnRleHQuc2xpY2UoMCwgdGV4dC50ZXh0Lmxlbmd0aCAtIG1bMF0ubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHRoaXMuY29udGVudCk7XG4gICAgICAgIGlmICghb3BlbkVuZCAmJiB0aGlzLm1hdGNoKVxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuYXBwZW5kKHRoaXMubWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID8gdGhpcy50eXBlLmNyZWF0ZSh0aGlzLmF0dHJzLCBjb250ZW50LCB0aGlzLm1hcmtzKSA6IGNvbnRlbnQ7XG4gICAgfVxuICAgIHBvcEZyb21TdGFzaE1hcmsobWFyaykge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGFzaE1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgaWYgKG1hcmsuZXEodGhpcy5zdGFzaE1hcmtzW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFzaE1hcmtzLnNwbGljZShpLCAxKVswXTtcbiAgICB9XG4gICAgYXBwbHlQZW5kaW5nKG5leHRUeXBlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nTWFya3M7IGkgPCBwZW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFyayA9IHBlbmRpbmdbaV07XG4gICAgICAgICAgICBpZiAoKHRoaXMudHlwZSA/IHRoaXMudHlwZS5hbGxvd3NNYXJrVHlwZShtYXJrLnR5cGUpIDogbWFya01heUFwcGx5KG1hcmsudHlwZSwgbmV4dFR5cGUpKSAmJlxuICAgICAgICAgICAgICAgICFtYXJrLmlzSW5TZXQodGhpcy5hY3RpdmVNYXJrcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZU1hcmtzID0gbWFyay5hZGRUb1NldCh0aGlzLmFjdGl2ZU1hcmtzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdNYXJrcyA9IG1hcmsucmVtb3ZlRnJvbVNldCh0aGlzLnBlbmRpbmdNYXJrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5saW5lQ29udGV4dChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLmlubGluZUNvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFswXS5pc0lubGluZTtcbiAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZSAmJiAhYmxvY2tUYWdzLmhhc093blByb3BlcnR5KG5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG59XG5jbGFzcyBQYXJzZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIFRoZSBwYXJzZXIgd2UgYXJlIHVzaW5nLlxuICAgIHBhcnNlciwgXG4gICAgLy8gVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoaXMgcGFyc2UuXG4gICAgb3B0aW9ucywgaXNPcGVuKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmlzT3BlbiA9IGlzT3BlbjtcbiAgICAgICAgdGhpcy5vcGVuID0gMDtcbiAgICAgICAgbGV0IHRvcE5vZGUgPSBvcHRpb25zLnRvcE5vZGUsIHRvcENvbnRleHQ7XG4gICAgICAgIGxldCB0b3BPcHRpb25zID0gd3NPcHRpb25zRm9yKG51bGwsIG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlLCAwKSB8IChpc09wZW4gPyBPUFRfT1BFTl9MRUZUIDogMCk7XG4gICAgICAgIGlmICh0b3BOb2RlKVxuICAgICAgICAgICAgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dCh0b3BOb2RlLnR5cGUsIHRvcE5vZGUuYXR0cnMsIE1hcmsubm9uZSwgTWFyay5ub25lLCB0cnVlLCBvcHRpb25zLnRvcE1hdGNoIHx8IHRvcE5vZGUudHlwZS5jb250ZW50TWF0Y2gsIHRvcE9wdGlvbnMpO1xuICAgICAgICBlbHNlIGlmIChpc09wZW4pXG4gICAgICAgICAgICB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KG51bGwsIG51bGwsIE1hcmsubm9uZSwgTWFyay5ub25lLCB0cnVlLCBudWxsLCB0b3BPcHRpb25zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dChwYXJzZXIuc2NoZW1hLnRvcE5vZGVUeXBlLCBudWxsLCBNYXJrLm5vbmUsIE1hcmsubm9uZSwgdHJ1ZSwgbnVsbCwgdG9wT3B0aW9ucyk7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbdG9wQ29udGV4dF07XG4gICAgICAgIHRoaXMuZmluZCA9IG9wdGlvbnMuZmluZFBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5uZWVkc0Jsb2NrID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCB0b3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzW3RoaXMub3Blbl07XG4gICAgfVxuICAgIC8vIEFkZCBhIERPTSBub2RlIHRvIHRoZSBjb250ZW50LiBUZXh0IGlzIGluc2VydGVkIGFzIHRleHQgbm9kZSxcbiAgICAvLyBvdGhlcndpc2UsIHRoZSBub2RlIGlzIHBhc3NlZCB0byBgYWRkRWxlbWVudGAgb3IsIGlmIGl0IGhhcyBhXG4gICAgLy8gYHN0eWxlYCBhdHRyaWJ1dGUsIGBhZGRFbGVtZW50V2l0aFN0eWxlc2AuXG4gICAgYWRkRE9NKGRvbSkge1xuICAgICAgICBpZiAoZG9tLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB0aGlzLmFkZFRleHROb2RlKGRvbSk7XG4gICAgICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50KGRvbSk7XG4gICAgfVxuICAgIHdpdGhTdHlsZVJ1bGVzKGRvbSwgZikge1xuICAgICAgICBsZXQgc3R5bGUgPSBkb20uZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgICAgIGlmICghc3R5bGUpXG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICBsZXQgbWFya3MgPSB0aGlzLnJlYWRTdHlsZXMocGFyc2VTdHlsZXMoc3R5bGUpKTtcbiAgICAgICAgaWYgKCFtYXJrcylcbiAgICAgICAgICAgIHJldHVybjsgLy8gQSBzdHlsZSB3aXRoIGlnbm9yZTogdHJ1ZVxuICAgICAgICBsZXQgW2FkZE1hcmtzLCByZW1vdmVNYXJrc10gPSBtYXJrcywgdG9wID0gdGhpcy50b3A7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlTWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBlbmRpbmdNYXJrKHJlbW92ZU1hcmtzW2ldLCB0b3ApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZE1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5hZGRQZW5kaW5nTWFyayhhZGRNYXJrc1tpXSk7XG4gICAgICAgIGYoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUGVuZGluZ01hcmsoYWRkTWFya3NbaV0sIHRvcCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlTWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLmFkZFBlbmRpbmdNYXJrKHJlbW92ZU1hcmtzW2ldKTtcbiAgICB9XG4gICAgYWRkVGV4dE5vZGUoZG9tKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGRvbS5ub2RlVmFsdWU7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgaWYgKHRvcC5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTX0ZVTEwgfHxcbiAgICAgICAgICAgIHRvcC5pbmxpbmVDb250ZXh0KGRvbSkgfHxcbiAgICAgICAgICAgIC9bXiBcXHRcXHJcXG5cXHUwMDBjXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICghKHRvcC5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvWyBcXHRcXHJcXG5cXHUwMDBjXSsvZywgXCIgXCIpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgc3RhcnRzIHdpdGggd2hpdGVzcGFjZSwgYW5kIHRoZXJlIGlzIG5vIG5vZGUgYmVmb3JlIGl0LCBvclxuICAgICAgICAgICAgICAgIC8vIGEgaGFyZCBicmVhaywgb3IgYSB0ZXh0IG5vZGUgdGhhdCBlbmRzIHdpdGggd2hpdGVzcGFjZSwgc3RyaXAgdGhlXG4gICAgICAgICAgICAgICAgLy8gbGVhZGluZyBzcGFjZS5cbiAgICAgICAgICAgICAgICBpZiAoL15bIFxcdFxcclxcblxcdTAwMGNdLy50ZXN0KHZhbHVlKSAmJiB0aGlzLm9wZW4gPT0gdGhpcy5ub2Rlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub2RlQmVmb3JlID0gdG9wLmNvbnRlbnRbdG9wLmNvbnRlbnQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBkb21Ob2RlQmVmb3JlID0gZG9tLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlQmVmb3JlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoZG9tTm9kZUJlZm9yZSAmJiBkb21Ob2RlQmVmb3JlLm5vZGVOYW1lID09ICdCUicpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAobm9kZUJlZm9yZS5pc1RleHQgJiYgL1sgXFx0XFxyXFxuXFx1MDAwY10kLy50ZXN0KG5vZGVCZWZvcmUudGV4dCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghKHRvcC5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTX0ZVTEwpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHI/XFxufFxcci9nLCBcIiBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnROb2RlKHRoaXMucGFyc2VyLnNjaGVtYS50ZXh0KHZhbHVlKSk7XG4gICAgICAgICAgICB0aGlzLmZpbmRJblRleHQoZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRyeSB0byBmaW5kIGEgaGFuZGxlciBmb3IgdGhlIGdpdmVuIHRhZyBhbmQgdXNlIHRoYXQgdG8gcGFyc2UuIElmXG4gICAgLy8gbm9uZSBpcyBmb3VuZCwgdGhlIGVsZW1lbnQncyBjb250ZW50IG5vZGVzIGFyZSBhZGRlZCBkaXJlY3RseS5cbiAgICBhZGRFbGVtZW50KGRvbSwgbWF0Y2hBZnRlcikge1xuICAgICAgICBsZXQgbmFtZSA9IGRvbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBydWxlSUQ7XG4gICAgICAgIGlmIChsaXN0VGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB0aGlzLnBhcnNlci5ub3JtYWxpemVMaXN0cylcbiAgICAgICAgICAgIG5vcm1hbGl6ZUxpc3QoZG9tKTtcbiAgICAgICAgbGV0IHJ1bGUgPSAodGhpcy5vcHRpb25zLnJ1bGVGcm9tTm9kZSAmJiB0aGlzLm9wdGlvbnMucnVsZUZyb21Ob2RlKGRvbSkpIHx8XG4gICAgICAgICAgICAocnVsZUlEID0gdGhpcy5wYXJzZXIubWF0Y2hUYWcoZG9tLCB0aGlzLCBtYXRjaEFmdGVyKSk7XG4gICAgICAgIGlmIChydWxlID8gcnVsZS5pZ25vcmUgOiBpZ25vcmVUYWdzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlRmFsbGJhY2soZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcnVsZSB8fCBydWxlLnNraXAgfHwgcnVsZS5jbG9zZVBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHJ1bGUgJiYgcnVsZS5jbG9zZVBhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4gPSBNYXRoLm1heCgwLCB0aGlzLm9wZW4gLSAxKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUgJiYgcnVsZS5za2lwLm5vZGVUeXBlKVxuICAgICAgICAgICAgICAgIGRvbSA9IHJ1bGUuc2tpcDtcbiAgICAgICAgICAgIGxldCBzeW5jLCB0b3AgPSB0aGlzLnRvcCwgb2xkTmVlZHNCbG9jayA9IHRoaXMubmVlZHNCbG9jaztcbiAgICAgICAgICAgIGlmIChibG9ja1RhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9wLmNvbnRlbnQubGVuZ3RoICYmIHRvcC5jb250ZW50WzBdLmlzSW5saW5lICYmIHRoaXMub3Blbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW4tLTtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gdGhpcy50b3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghdG9wLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmVlZHNCbG9jayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZG9tLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlYWZGYWxsYmFjayhkb20pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydWxlICYmIHJ1bGUuc2tpcClcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEFsbChkb20pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMud2l0aFN0eWxlUnVsZXMoZG9tLCAoKSA9PiB0aGlzLmFkZEFsbChkb20pKTtcbiAgICAgICAgICAgIGlmIChzeW5jKVxuICAgICAgICAgICAgICAgIHRoaXMuc3luYyh0b3ApO1xuICAgICAgICAgICAgdGhpcy5uZWVkc0Jsb2NrID0gb2xkTmVlZHNCbG9jaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud2l0aFN0eWxlUnVsZXMoZG9tLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50QnlSdWxlKGRvbSwgcnVsZSwgcnVsZS5jb25zdW1pbmcgPT09IGZhbHNlID8gcnVsZUlEIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENhbGxlZCBmb3IgbGVhZiBET00gbm9kZXMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYmUgaWdub3JlZFxuICAgIGxlYWZGYWxsYmFjayhkb20pIHtcbiAgICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgdGhpcy50b3AudHlwZSAmJiB0aGlzLnRvcC50eXBlLmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICB0aGlzLmFkZFRleHROb2RlKGRvbS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXCIpKTtcbiAgICB9XG4gICAgLy8gQ2FsbGVkIGZvciBpZ25vcmVkIG5vZGVzXG4gICAgaWdub3JlRmFsbGJhY2soZG9tKSB7XG4gICAgICAgIC8vIElnbm9yZWQgQlIgbm9kZXMgc2hvdWxkIGF0IGxlYXN0IGNyZWF0ZSBhbiBpbmxpbmUgY29udGV4dFxuICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiAoIXRoaXMudG9wLnR5cGUgfHwgIXRoaXMudG9wLnR5cGUuaW5saW5lQ29udGVudCkpXG4gICAgICAgICAgICB0aGlzLmZpbmRQbGFjZSh0aGlzLnBhcnNlci5zY2hlbWEudGV4dChcIi1cIikpO1xuICAgIH1cbiAgICAvLyBSdW4gYW55IHN0eWxlIHBhcnNlciBhc3NvY2lhdGVkIHdpdGggdGhlIG5vZGUncyBzdHlsZXMuIEVpdGhlclxuICAgIC8vIHJldHVybiBhbiBhcnJheSBvZiBtYXJrcywgb3IgbnVsbCB0byBpbmRpY2F0ZSBzb21lIG9mIHRoZSBzdHlsZXNcbiAgICAvLyBoYWQgYSBydWxlIHdpdGggYGlnbm9yZWAgc2V0LlxuICAgIHJlYWRTdHlsZXMoc3R5bGVzKSB7XG4gICAgICAgIGxldCBhZGQgPSBNYXJrLm5vbmUsIHJlbW92ZSA9IE1hcmsubm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGFmdGVyID0gdW5kZWZpbmVkOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IHRoaXMucGFyc2VyLm1hdGNoU3R5bGUoc3R5bGVzW2ldLCBzdHlsZXNbaSArIDFdLCB0aGlzLCBhZnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKCFydWxlKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5pZ25vcmUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmNsZWFyTWFyaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvcC5wZW5kaW5nTWFya3MuY29uY2F0KHRoaXMudG9wLmFjdGl2ZU1hcmtzKS5mb3JFYWNoKG0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUuY2xlYXJNYXJrKG0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSA9IG0uYWRkVG9TZXQocmVtb3ZlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGQgPSB0aGlzLnBhcnNlci5zY2hlbWEubWFya3NbcnVsZS5tYXJrXS5jcmVhdGUocnVsZS5hdHRycykuYWRkVG9TZXQoYWRkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuY29uc3VtaW5nID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSBydWxlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFthZGQsIHJlbW92ZV07XG4gICAgfVxuICAgIC8vIExvb2sgdXAgYSBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gbm9kZS4gSWYgbm9uZSBhcmUgZm91bmQsIHJldHVyblxuICAgIC8vIGZhbHNlLiBPdGhlcndpc2UsIGFwcGx5IGl0LCB1c2UgaXRzIHJldHVybiB2YWx1ZSB0byBkcml2ZSB0aGUgd2F5XG4gICAgLy8gdGhlIG5vZGUncyBjb250ZW50IGlzIHdyYXBwZWQsIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICBhZGRFbGVtZW50QnlSdWxlKGRvbSwgcnVsZSwgY29udGludWVBZnRlcikge1xuICAgICAgICBsZXQgc3luYywgbm9kZVR5cGUsIG1hcms7XG4gICAgICAgIGlmIChydWxlLm5vZGUpIHtcbiAgICAgICAgICAgIG5vZGVUeXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzW3J1bGUubm9kZV07XG4gICAgICAgICAgICBpZiAoIW5vZGVUeXBlLmlzTGVhZikge1xuICAgICAgICAgICAgICAgIHN5bmMgPSB0aGlzLmVudGVyKG5vZGVUeXBlLCBydWxlLmF0dHJzIHx8IG51bGwsIHJ1bGUucHJlc2VydmVXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmluc2VydE5vZGUobm9kZVR5cGUuY3JlYXRlKHJ1bGUuYXR0cnMpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhZkZhbGxiYWNrKGRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWFya1R5cGUgPSB0aGlzLnBhcnNlci5zY2hlbWEubWFya3NbcnVsZS5tYXJrXTtcbiAgICAgICAgICAgIG1hcmsgPSBtYXJrVHlwZS5jcmVhdGUocnVsZS5hdHRycyk7XG4gICAgICAgICAgICB0aGlzLmFkZFBlbmRpbmdNYXJrKG1hcmspO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydEluID0gdGhpcy50b3A7XG4gICAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZS5pc0xlYWYpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRpbnVlQWZ0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudChkb20sIGNvbnRpbnVlQWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJ1bGUuZ2V0Q29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgICAgICBydWxlLmdldENvbnRlbnQoZG9tLCB0aGlzLnBhcnNlci5zY2hlbWEpLmZvckVhY2gobm9kZSA9PiB0aGlzLmluc2VydE5vZGUobm9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRET00gPSBkb207XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGUuY29udGVudEVsZW1lbnQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NID0gZG9tLnF1ZXJ5U2VsZWN0b3IocnVsZS5jb250ZW50RWxlbWVudCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcnVsZS5jb250ZW50RWxlbWVudCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgY29udGVudERPTSA9IHJ1bGUuY29udGVudEVsZW1lbnQoZG9tKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUuY29udGVudEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgY29udGVudERPTSA9IHJ1bGUuY29udGVudEVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmRBcm91bmQoZG9tLCBjb250ZW50RE9NLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQWxsKGNvbnRlbnRET00pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzeW5jICYmIHRoaXMuc3luYyhzdGFydEluKSlcbiAgICAgICAgICAgIHRoaXMub3Blbi0tO1xuICAgICAgICBpZiAobWFyaylcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUGVuZGluZ01hcmsobWFyaywgc3RhcnRJbik7XG4gICAgfVxuICAgIC8vIEFkZCBhbGwgY2hpbGQgbm9kZXMgYmV0d2VlbiBgc3RhcnRJbmRleGAgYW5kIGBlbmRJbmRleGAgKG9yIHRoZVxuICAgIC8vIHdob2xlIG5vZGUsIGlmIG5vdCBnaXZlbikuIElmIGBzeW5jYCBpcyBwYXNzZWQsIHVzZSBpdCB0b1xuICAgIC8vIHN5bmNocm9uaXplIGFmdGVyIGV2ZXJ5IGJsb2NrIGVsZW1lbnQuXG4gICAgYWRkQWxsKHBhcmVudCwgc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gc3RhcnRJbmRleCB8fCAwO1xuICAgICAgICBmb3IgKGxldCBkb20gPSBzdGFydEluZGV4ID8gcGFyZW50LmNoaWxkTm9kZXNbc3RhcnRJbmRleF0gOiBwYXJlbnQuZmlyc3RDaGlsZCwgZW5kID0gZW5kSW5kZXggPT0gbnVsbCA/IG51bGwgOiBwYXJlbnQuY2hpbGROb2Rlc1tlbmRJbmRleF07IGRvbSAhPSBlbmQ7IGRvbSA9IGRvbS5uZXh0U2libGluZywgKytpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5maW5kQXRQb2ludChwYXJlbnQsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYWRkRE9NKGRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5kQXRQb2ludChwYXJlbnQsIGluZGV4KTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSB3YXkgdG8gZml0IHRoZSBnaXZlbiBub2RlIHR5cGUgaW50byB0aGUgY3VycmVudFxuICAgIC8vIGNvbnRleHQuIE1heSBhZGQgaW50ZXJtZWRpYXRlIHdyYXBwZXJzIGFuZC9vciBsZWF2ZSBub24tc29saWRcbiAgICAvLyBub2RlcyB0aGF0IHdlJ3JlIGluLlxuICAgIGZpbmRQbGFjZShub2RlKSB7XG4gICAgICAgIGxldCByb3V0ZSwgc3luYztcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSB0aGlzLm9wZW47IGRlcHRoID49IDA7IGRlcHRoLS0pIHtcbiAgICAgICAgICAgIGxldCBjeCA9IHRoaXMubm9kZXNbZGVwdGhdO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gY3guZmluZFdyYXBwaW5nKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGZvdW5kICYmICghcm91dGUgfHwgcm91dGUubGVuZ3RoID4gZm91bmQubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHJvdXRlID0gZm91bmQ7XG4gICAgICAgICAgICAgICAgc3luYyA9IGN4O1xuICAgICAgICAgICAgICAgIGlmICghZm91bmQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjeC5zb2xpZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJvdXRlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnN5bmMoc3luYyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLmVudGVySW5uZXIocm91dGVbaV0sIG51bGwsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFRyeSB0byBpbnNlcnQgdGhlIGdpdmVuIG5vZGUsIGFkanVzdGluZyB0aGUgY29udGV4dCB3aGVuIG5lZWRlZC5cbiAgICBpbnNlcnROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuaXNJbmxpbmUgJiYgdGhpcy5uZWVkc0Jsb2NrICYmICF0aGlzLnRvcC50eXBlKSB7XG4gICAgICAgICAgICBsZXQgYmxvY2sgPSB0aGlzLnRleHRibG9ja0Zyb21Db250ZXh0KCk7XG4gICAgICAgICAgICBpZiAoYmxvY2spXG4gICAgICAgICAgICAgICAgdGhpcy5lbnRlcklubmVyKGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maW5kUGxhY2Uobm9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VFeHRyYSgpO1xuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgICAgICAgdG9wLmFwcGx5UGVuZGluZyhub2RlLnR5cGUpO1xuICAgICAgICAgICAgaWYgKHRvcC5tYXRjaClcbiAgICAgICAgICAgICAgICB0b3AubWF0Y2ggPSB0b3AubWF0Y2gubWF0Y2hUeXBlKG5vZGUudHlwZSk7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSB0b3AuYWN0aXZlTWFya3M7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKCF0b3AudHlwZSB8fCB0b3AudHlwZS5hbGxvd3NNYXJrVHlwZShub2RlLm1hcmtzW2ldLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICBtYXJrcyA9IG5vZGUubWFya3NbaV0uYWRkVG9TZXQobWFya3MpO1xuICAgICAgICAgICAgdG9wLmNvbnRlbnQucHVzaChub2RlLm1hcmsobWFya3MpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIHN0YXJ0IGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSwgYWRqdXN0aW5nIHRoZSBjb250ZXh0IHdoZW5cbiAgICAvLyBuZWNlc3NhcnkuXG4gICAgZW50ZXIodHlwZSwgYXR0cnMsIHByZXNlcnZlV1MpIHtcbiAgICAgICAgbGV0IG9rID0gdGhpcy5maW5kUGxhY2UodHlwZS5jcmVhdGUoYXR0cnMpKTtcbiAgICAgICAgaWYgKG9rKVxuICAgICAgICAgICAgdGhpcy5lbnRlcklubmVyKHR5cGUsIGF0dHJzLCB0cnVlLCBwcmVzZXJ2ZVdTKTtcbiAgICAgICAgcmV0dXJuIG9rO1xuICAgIH1cbiAgICAvLyBPcGVuIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZVxuICAgIGVudGVySW5uZXIodHlwZSwgYXR0cnMgPSBudWxsLCBzb2xpZCA9IGZhbHNlLCBwcmVzZXJ2ZVdTKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFeHRyYSgpO1xuICAgICAgICBsZXQgdG9wID0gdGhpcy50b3A7XG4gICAgICAgIHRvcC5hcHBseVBlbmRpbmcodHlwZSk7XG4gICAgICAgIHRvcC5tYXRjaCA9IHRvcC5tYXRjaCAmJiB0b3AubWF0Y2gubWF0Y2hUeXBlKHR5cGUpO1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHdzT3B0aW9uc0Zvcih0eXBlLCBwcmVzZXJ2ZVdTLCB0b3Aub3B0aW9ucyk7XG4gICAgICAgIGlmICgodG9wLm9wdGlvbnMgJiBPUFRfT1BFTl9MRUZUKSAmJiB0b3AuY29udGVudC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIG9wdGlvbnMgfD0gT1BUX09QRU5fTEVGVDtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBOb2RlQ29udGV4dCh0eXBlLCBhdHRycywgdG9wLmFjdGl2ZU1hcmtzLCB0b3AucGVuZGluZ01hcmtzLCBzb2xpZCwgbnVsbCwgb3B0aW9ucykpO1xuICAgICAgICB0aGlzLm9wZW4rKztcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIGFsbCBub2RlcyBhYm92ZSB0aGlzLm9wZW4gYXJlIGZpbmlzaGVkIGFuZCBhZGRlZCB0b1xuICAgIC8vIHRoZWlyIHBhcmVudHNcbiAgICBjbG9zZUV4dHJhKG9wZW5FbmQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgaSA9IHRoaXMubm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGkgPiB0aGlzLm9wZW4pIHtcbiAgICAgICAgICAgIGZvciAoOyBpID4gdGhpcy5vcGVuOyBpLS0pXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlc1tpIC0gMV0uY29udGVudC5wdXNoKHRoaXMubm9kZXNbaV0uZmluaXNoKG9wZW5FbmQpKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMubGVuZ3RoID0gdGhpcy5vcGVuICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHRoaXMub3BlbiA9IDA7XG4gICAgICAgIHRoaXMuY2xvc2VFeHRyYSh0aGlzLmlzT3Blbik7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzWzBdLmZpbmlzaCh0aGlzLmlzT3BlbiB8fCB0aGlzLm9wdGlvbnMudG9wT3Blbik7XG4gICAgfVxuICAgIHN5bmModG8pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMub3BlbjsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1tpXSA9PSB0bykge1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbiA9IGk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRQb3MoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFeHRyYSgpO1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMub3BlbjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5ub2Rlc1tpXS5jb250ZW50O1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGNvbnRlbnQubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG4gICAgICAgICAgICAgICAgcG9zICs9IGNvbnRlbnRbal0ubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBmaW5kQXRQb2ludChwYXJlbnQsIG9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLm5vZGUgPT0gcGFyZW50ICYmIHRoaXMuZmluZFtpXS5vZmZzZXQgPT0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kSW5zaWRlKHBhcmVudCkge1xuICAgICAgICBpZiAodGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLnBvcyA9PSBudWxsICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxICYmIHBhcmVudC5jb250YWlucyh0aGlzLmZpbmRbaV0ubm9kZSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3M7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRBcm91bmQocGFyZW50LCBjb250ZW50LCBiZWZvcmUpIHtcbiAgICAgICAgaWYgKHBhcmVudCAhPSBjb250ZW50ICYmIHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5wb3MgPT0gbnVsbCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMSAmJiBwYXJlbnQuY29udGFpbnModGhpcy5maW5kW2ldLm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3MgPSBjb250ZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuZmluZFtpXS5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyAmIChiZWZvcmUgPyAyIDogNCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZmluZEluVGV4dCh0ZXh0Tm9kZSkge1xuICAgICAgICBpZiAodGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLm5vZGUgPT0gdGV4dE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3MgLSAodGV4dE5vZGUubm9kZVZhbHVlLmxlbmd0aCAtIHRoaXMuZmluZFtpXS5vZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIGNvbnRleHQgc3RyaW5nIG1hdGNoZXMgdGhpcyBjb250ZXh0LlxuICAgIG1hdGNoZXNDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuaW5kZXhPZihcInxcIikgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnNwbGl0KC9cXHMqXFx8XFxzKi8pLnNvbWUodGhpcy5tYXRjaGVzQ29udGV4dCwgdGhpcyk7XG4gICAgICAgIGxldCBwYXJ0cyA9IGNvbnRleHQuc3BsaXQoXCIvXCIpO1xuICAgICAgICBsZXQgb3B0aW9uID0gdGhpcy5vcHRpb25zLmNvbnRleHQ7XG4gICAgICAgIGxldCB1c2VSb290ID0gIXRoaXMuaXNPcGVuICYmICghb3B0aW9uIHx8IG9wdGlvbi5wYXJlbnQudHlwZSA9PSB0aGlzLm5vZGVzWzBdLnR5cGUpO1xuICAgICAgICBsZXQgbWluRGVwdGggPSAtKG9wdGlvbiA/IG9wdGlvbi5kZXB0aCArIDEgOiAwKSArICh1c2VSb290ID8gMCA6IDEpO1xuICAgICAgICBsZXQgbWF0Y2ggPSAoaSwgZGVwdGgpID0+IHtcbiAgICAgICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQgPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSBwYXJ0cy5sZW5ndGggLSAxIHx8IGkgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZGVwdGggPj0gbWluRGVwdGg7IGRlcHRoLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2goaSAtIDEsIGRlcHRoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBkZXB0aCA+IDAgfHwgKGRlcHRoID09IDAgJiYgdXNlUm9vdCkgPyB0aGlzLm5vZGVzW2RlcHRoXS50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9wdGlvbiAmJiBkZXB0aCA+PSBtaW5EZXB0aCA/IG9wdGlvbi5ub2RlKGRlcHRoIC0gbWluRGVwdGgpLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dCB8fCAobmV4dC5uYW1lICE9IHBhcnQgJiYgbmV4dC5ncm91cHMuaW5kZXhPZihwYXJ0KSA9PSAtMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtYXRjaChwYXJ0cy5sZW5ndGggLSAxLCB0aGlzLm9wZW4pO1xuICAgIH1cbiAgICB0ZXh0YmxvY2tGcm9tQ29udGV4dCgpIHtcbiAgICAgICAgbGV0ICRjb250ZXh0ID0gdGhpcy5vcHRpb25zLmNvbnRleHQ7XG4gICAgICAgIGlmICgkY29udGV4dClcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAkY29udGV4dC5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVmbHQgPSAkY29udGV4dC5ub2RlKGQpLmNvbnRlbnRNYXRjaEF0KCRjb250ZXh0LmluZGV4QWZ0ZXIoZCkpLmRlZmF1bHRUeXBlO1xuICAgICAgICAgICAgICAgIGlmIChkZWZsdCAmJiBkZWZsdC5pc1RleHRibG9jayAmJiBkZWZsdC5kZWZhdWx0QXR0cnMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLnBhcnNlci5zY2hlbWEubm9kZXMpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGUuaXNUZXh0YmxvY2sgJiYgdHlwZS5kZWZhdWx0QXR0cnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkUGVuZGluZ01hcmsobWFyaykge1xuICAgICAgICBsZXQgZm91bmQgPSBmaW5kU2FtZU1hcmtJblNldChtYXJrLCB0aGlzLnRvcC5wZW5kaW5nTWFya3MpO1xuICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICB0aGlzLnRvcC5zdGFzaE1hcmtzLnB1c2goZm91bmQpO1xuICAgICAgICB0aGlzLnRvcC5wZW5kaW5nTWFya3MgPSBtYXJrLmFkZFRvU2V0KHRoaXMudG9wLnBlbmRpbmdNYXJrcyk7XG4gICAgfVxuICAgIHJlbW92ZVBlbmRpbmdNYXJrKG1hcmssIHVwdG8pIHtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSB0aGlzLm9wZW47IGRlcHRoID49IDA7IGRlcHRoLS0pIHtcbiAgICAgICAgICAgIGxldCBsZXZlbCA9IHRoaXMubm9kZXNbZGVwdGhdO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gbGV2ZWwucGVuZGluZ01hcmtzLmxhc3RJbmRleE9mKG1hcmspO1xuICAgICAgICAgICAgaWYgKGZvdW5kID4gLTEpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5wZW5kaW5nTWFya3MgPSBtYXJrLnJlbW92ZUZyb21TZXQobGV2ZWwucGVuZGluZ01hcmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldmVsLmFjdGl2ZU1hcmtzID0gbWFyay5yZW1vdmVGcm9tU2V0KGxldmVsLmFjdGl2ZU1hcmtzKTtcbiAgICAgICAgICAgICAgICBsZXQgc3Rhc2hNYXJrID0gbGV2ZWwucG9wRnJvbVN0YXNoTWFyayhtYXJrKTtcbiAgICAgICAgICAgICAgICBpZiAoc3Rhc2hNYXJrICYmIGxldmVsLnR5cGUgJiYgbGV2ZWwudHlwZS5hbGxvd3NNYXJrVHlwZShzdGFzaE1hcmsudHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIGxldmVsLmFjdGl2ZU1hcmtzID0gc3Rhc2hNYXJrLmFkZFRvU2V0KGxldmVsLmFjdGl2ZU1hcmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZXZlbCA9PSB1cHRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gS2x1ZGdlIHRvIHdvcmsgYXJvdW5kIGRpcmVjdGx5IG5lc3RlZCBsaXN0IG5vZGVzIHByb2R1Y2VkIGJ5IHNvbWVcbi8vIHRvb2xzIGFuZCBhbGxvd2VkIGJ5IGJyb3dzZXJzIHRvIG1lYW4gdGhhdCB0aGUgbmVzdGVkIGxpc3QgaXNcbi8vIGFjdHVhbGx5IHBhcnQgb2YgdGhlIGxpc3QgaXRlbSBhYm92ZSBpdC5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpc3QoZG9tKSB7XG4gICAgZm9yIChsZXQgY2hpbGQgPSBkb20uZmlyc3RDaGlsZCwgcHJldkl0ZW0gPSBudWxsOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICBsZXQgbmFtZSA9IGNoaWxkLm5vZGVUeXBlID09IDEgPyBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbiAgICAgICAgaWYgKG5hbWUgJiYgbGlzdFRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgcHJldkl0ZW0pIHtcbiAgICAgICAgICAgIHByZXZJdGVtLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIGNoaWxkID0gcHJldkl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PSBcImxpXCIpIHtcbiAgICAgICAgICAgIHByZXZJdGVtID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSkge1xuICAgICAgICAgICAgcHJldkl0ZW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gQXBwbHkgYSBDU1Mgc2VsZWN0b3IuXG5mdW5jdGlvbiBtYXRjaGVzKGRvbSwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gKGRvbS5tYXRjaGVzIHx8IGRvbS5tc01hdGNoZXNTZWxlY3RvciB8fCBkb20ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGRvbS5tb3pNYXRjaGVzU2VsZWN0b3IpLmNhbGwoZG9tLCBzZWxlY3Rvcik7XG59XG4vLyBUb2tlbml6ZSBhIHN0eWxlIGF0dHJpYnV0ZSBpbnRvIHByb3BlcnR5L3ZhbHVlIHBhaXJzLlxuZnVuY3Rpb24gcGFyc2VTdHlsZXMoc3R5bGUpIHtcbiAgICBsZXQgcmUgPSAvXFxzKihbXFx3LV0rKVxccyo6XFxzKihbXjtdKykvZywgbSwgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKG0gPSByZS5leGVjKHN0eWxlKSlcbiAgICAgICAgcmVzdWx0LnB1c2gobVsxXSwgbVsyXS50cmltKCkpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb3B5KG9iaikge1xuICAgIGxldCBjb3B5ID0ge307XG4gICAgZm9yIChsZXQgcHJvcCBpbiBvYmopXG4gICAgICAgIGNvcHlbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgcmV0dXJuIGNvcHk7XG59XG4vLyBVc2VkIHdoZW4gZmluZGluZyBhIG1hcmsgYXQgdGhlIHRvcCBsZXZlbCBvZiBhIGZyYWdtZW50IHBhcnNlLlxuLy8gQ2hlY2tzIHdoZXRoZXIgaXQgd291bGQgYmUgcmVhc29uYWJsZSB0byBhcHBseSBhIGdpdmVuIG1hcmsgdHlwZSB0b1xuLy8gYSBnaXZlbiBub2RlLCBieSBsb29raW5nIGF0IHRoZSB3YXkgdGhlIG1hcmsgb2NjdXJzIGluIHRoZSBzY2hlbWEuXG5mdW5jdGlvbiBtYXJrTWF5QXBwbHkobWFya1R5cGUsIG5vZGVUeXBlKSB7XG4gICAgbGV0IG5vZGVzID0gbm9kZVR5cGUuc2NoZW1hLm5vZGVzO1xuICAgIGZvciAobGV0IG5hbWUgaW4gbm9kZXMpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IG5vZGVzW25hbWVdO1xuICAgICAgICBpZiAoIXBhcmVudC5hbGxvd3NNYXJrVHlwZShtYXJrVHlwZSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IHNlZW4gPSBbXSwgc2NhbiA9IChtYXRjaCkgPT4ge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKG1hdGNoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2guZWRnZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBuZXh0IH0gPSBtYXRjaC5lZGdlKGkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IG5vZGVUeXBlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG5leHQpIDwgMCAmJiBzY2FuKG5leHQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNjYW4ocGFyZW50LmNvbnRlbnRNYXRjaCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kU2FtZU1hcmtJblNldChtYXJrLCBzZXQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobWFyay5lcShzZXRbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIHNldFtpXTtcbiAgICB9XG59XG5cbi8qKlxuQSBET00gc2VyaWFsaXplciBrbm93cyBob3cgdG8gY29udmVydCBQcm9zZU1pcnJvciBub2RlcyBhbmRcbm1hcmtzIG9mIHZhcmlvdXMgdHlwZXMgdG8gRE9NIG5vZGVzLlxuKi9cbmNsYXNzIERPTVNlcmlhbGl6ZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlcmlhbGl6ZXIuIGBub2Rlc2Agc2hvdWxkIG1hcCBub2RlIG5hbWVzIHRvIGZ1bmN0aW9uc1xuICAgIHRoYXQgdGFrZSBhIG5vZGUgYW5kIHJldHVybiBhIGRlc2NyaXB0aW9uIG9mIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgRE9NLiBgbWFya3NgIGRvZXMgdGhlIHNhbWUgZm9yIG1hcmsgbmFtZXMsIGJ1dCBhbHNvIGdldHMgYW5cbiAgICBhcmd1bWVudCB0aGF0IHRlbGxzIGl0IHdoZXRoZXIgdGhlIG1hcmsncyBjb250ZW50IGlzIGJsb2NrIG9yXG4gICAgaW5saW5lIGNvbnRlbnQgKGZvciB0eXBpY2FsIHVzZSwgaXQnbGwgYWx3YXlzIGJlIGlubGluZSkuIEEgbWFya1xuICAgIHNlcmlhbGl6ZXIgbWF5IGJlIGBudWxsYCB0byBpbmRpY2F0ZSB0aGF0IG1hcmtzIG9mIHRoYXQgdHlwZVxuICAgIHNob3VsZCBub3QgYmUgc2VyaWFsaXplZC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHNlcmlhbGl6YXRpb24gZnVuY3Rpb25zLlxuICAgICovXG4gICAgbm9kZXMsIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHNlcmlhbGl6YXRpb24gZnVuY3Rpb25zLlxuICAgICovXG4gICAgbWFya3MpIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgICAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGUgY29udGVudCBvZiB0aGlzIGZyYWdtZW50IHRvIGEgRE9NIGZyYWdtZW50LiBXaGVuXG4gICAgbm90IGluIHRoZSBicm93c2VyLCB0aGUgYGRvY3VtZW50YCBvcHRpb24sIGNvbnRhaW5pbmcgYSBET01cbiAgICBkb2N1bWVudCwgc2hvdWxkIGJlIHBhc3NlZCBzbyB0aGF0IHRoZSBzZXJpYWxpemVyIGNhbiBjcmVhdGVcbiAgICBub2Rlcy5cbiAgICAqL1xuICAgIHNlcmlhbGl6ZUZyYWdtZW50KGZyYWdtZW50LCBvcHRpb25zID0ge30sIHRhcmdldCkge1xuICAgICAgICBpZiAoIXRhcmdldClcbiAgICAgICAgICAgIHRhcmdldCA9IGRvYyhvcHRpb25zKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIGxldCB0b3AgPSB0YXJnZXQsIGFjdGl2ZSA9IFtdO1xuICAgICAgICBmcmFnbWVudC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGFjdGl2ZS5sZW5ndGggfHwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQga2VlcCA9IDAsIHJlbmRlcmVkID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoa2VlcCA8IGFjdGl2ZS5sZW5ndGggJiYgcmVuZGVyZWQgPCBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUubWFya3NbcmVuZGVyZWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWFya3NbbmV4dC50eXBlLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0LmVxKGFjdGl2ZVtrZWVwXVswXSkgfHwgbmV4dC50eXBlLnNwZWMuc3Bhbm5pbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGtlZXArKztcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGtlZXAgPCBhY3RpdmUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0b3AgPSBhY3RpdmUucG9wKClbMV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlbmRlcmVkIDwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFkZCA9IG5vZGUubWFya3NbcmVuZGVyZWQrK107XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXJrRE9NID0gdGhpcy5zZXJpYWxpemVNYXJrKGFkZCwgbm9kZS5pc0lubGluZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXJrRE9NKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUucHVzaChbYWRkLCB0b3BdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5hcHBlbmRDaGlsZChtYXJrRE9NLmRvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSBtYXJrRE9NLmNvbnRlbnRET00gfHwgbWFya0RPTS5kb207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3AuYXBwZW5kQ2hpbGQodGhpcy5zZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucykge1xuICAgICAgICBsZXQgeyBkb20sIGNvbnRlbnRET00gfSA9IERPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2Mob3B0aW9ucyksIHRoaXMubm9kZXNbbm9kZS50eXBlLm5hbWVdKG5vZGUpKTtcbiAgICAgICAgaWYgKGNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNvbnRlbnQgaG9sZSBub3QgYWxsb3dlZCBpbiBhIGxlYWYgbm9kZSBzcGVjXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVGcmFnbWVudChub2RlLmNvbnRlbnQsIG9wdGlvbnMsIGNvbnRlbnRET00pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGlzIG5vZGUgdG8gYSBET00gbm9kZS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4geW91XG4gICAgbmVlZCB0byBzZXJpYWxpemUgYSBwYXJ0IG9mIGEgZG9jdW1lbnQsIGFzIG9wcG9zZWQgdG8gdGhlIHdob2xlXG4gICAgZG9jdW1lbnQuIFRvIHNlcmlhbGl6ZSBhIHdob2xlIGRvY3VtZW50LCB1c2VcbiAgICBbYHNlcmlhbGl6ZUZyYWdtZW50YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkRPTVNlcmlhbGl6ZXIuc2VyaWFsaXplRnJhZ21lbnQpIG9uXG4gICAgaXRzIFtjb250ZW50XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS5jb250ZW50KS5cbiAgICAqL1xuICAgIHNlcmlhbGl6ZU5vZGUobm9kZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBkb20gPSB0aGlzLnNlcmlhbGl6ZU5vZGVJbm5lcihub2RlLCBvcHRpb25zKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IG5vZGUubWFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB3cmFwID0gdGhpcy5zZXJpYWxpemVNYXJrKG5vZGUubWFya3NbaV0sIG5vZGUuaXNJbmxpbmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHdyYXApIHtcbiAgICAgICAgICAgICAgICAod3JhcC5jb250ZW50RE9NIHx8IHdyYXAuZG9tKS5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgICAgIGRvbSA9IHdyYXAuZG9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2VyaWFsaXplTWFyayhtYXJrLCBpbmxpbmUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgdG9ET00gPSB0aGlzLm1hcmtzW21hcmsudHlwZS5uYW1lXTtcbiAgICAgICAgcmV0dXJuIHRvRE9NICYmIERPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2Mob3B0aW9ucyksIHRvRE9NKG1hcmssIGlubGluZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW5kZXIgYW4gW291dHB1dCBzcGVjXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuRE9NT3V0cHV0U3BlYykgdG8gYSBET00gbm9kZS4gSWZcbiAgICB0aGUgc3BlYyBoYXMgYSBob2xlICh6ZXJvKSBpbiBpdCwgYGNvbnRlbnRET01gIHdpbGwgcG9pbnQgYXQgdGhlXG4gICAgbm9kZSB3aXRoIHRoZSBob2xlLlxuICAgICovXG4gICAgc3RhdGljIHJlbmRlclNwZWMoZG9jLCBzdHJ1Y3R1cmUsIHhtbE5TID0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIHN0cnVjdHVyZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIHsgZG9tOiBkb2MuY3JlYXRlVGV4dE5vZGUoc3RydWN0dXJlKSB9O1xuICAgICAgICBpZiAoc3RydWN0dXJlLm5vZGVUeXBlICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm4geyBkb206IHN0cnVjdHVyZSB9O1xuICAgICAgICBpZiAoc3RydWN0dXJlLmRvbSAmJiBzdHJ1Y3R1cmUuZG9tLm5vZGVUeXBlICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gc3RydWN0dXJlO1xuICAgICAgICBsZXQgdGFnTmFtZSA9IHN0cnVjdHVyZVswXSwgc3BhY2UgPSB0YWdOYW1lLmluZGV4T2YoXCIgXCIpO1xuICAgICAgICBpZiAoc3BhY2UgPiAwKSB7XG4gICAgICAgICAgICB4bWxOUyA9IHRhZ05hbWUuc2xpY2UoMCwgc3BhY2UpO1xuICAgICAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWUuc2xpY2Uoc3BhY2UgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudERPTTtcbiAgICAgICAgbGV0IGRvbSA9ICh4bWxOUyA/IGRvYy5jcmVhdGVFbGVtZW50TlMoeG1sTlMsIHRhZ05hbWUpIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSkpO1xuICAgICAgICBsZXQgYXR0cnMgPSBzdHJ1Y3R1cmVbMV0sIHN0YXJ0ID0gMTtcbiAgICAgICAgaWYgKGF0dHJzICYmIHR5cGVvZiBhdHRycyA9PSBcIm9iamVjdFwiICYmIGF0dHJzLm5vZGVUeXBlID09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoYXR0cnMpKSB7XG4gICAgICAgICAgICBzdGFydCA9IDI7XG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKVxuICAgICAgICAgICAgICAgIGlmIChhdHRyc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZSA9IG5hbWUuaW5kZXhPZihcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGFjZSA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlTlMobmFtZS5zbGljZSgwLCBzcGFjZSksIG5hbWUuc2xpY2Uoc3BhY2UgKyAxKSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RydWN0dXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBzdHJ1Y3R1cmVbaV07XG4gICAgICAgICAgICBpZiAoY2hpbGQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IHN0cnVjdHVyZS5sZW5ndGggLSAxIHx8IGkgPiBzdGFydClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDb250ZW50IGhvbGUgbXVzdCBiZSB0aGUgb25seSBjaGlsZCBvZiBpdHMgcGFyZW50IG5vZGVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9tLCBjb250ZW50RE9NOiBkb20gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB7IGRvbTogaW5uZXIsIGNvbnRlbnRET006IGlubmVyQ29udGVudCB9ID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvYywgY2hpbGQsIHhtbE5TKTtcbiAgICAgICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoaW5uZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lckNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk11bHRpcGxlIGNvbnRlbnQgaG9sZXNcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBpbm5lckNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbSwgY29udGVudERPTSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBCdWlsZCBhIHNlcmlhbGl6ZXIgdXNpbmcgdGhlIFtgdG9ET01gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMudG9ET00pXG4gICAgcHJvcGVydGllcyBpbiBhIHNjaGVtYSdzIG5vZGUgYW5kIG1hcmsgc3BlY3MuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5jYWNoZWQuZG9tU2VyaWFsaXplciB8fFxuICAgICAgICAgICAgKHNjaGVtYS5jYWNoZWQuZG9tU2VyaWFsaXplciA9IG5ldyBET01TZXJpYWxpemVyKHRoaXMubm9kZXNGcm9tU2NoZW1hKHNjaGVtYSksIHRoaXMubWFya3NGcm9tU2NoZW1hKHNjaGVtYSkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2F0aGVyIHRoZSBzZXJpYWxpemVycyBpbiBhIHNjaGVtYSdzIG5vZGUgc3BlY3MgaW50byBhbiBvYmplY3QuXG4gICAgVGhpcyBjYW4gYmUgdXNlZnVsIGFzIGEgYmFzZSB0byBidWlsZCBhIGN1c3RvbSBzZXJpYWxpemVyIGZyb20uXG4gICAgKi9cbiAgICBzdGF0aWMgbm9kZXNGcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gZ2F0aGVyVG9ET00oc2NoZW1hLm5vZGVzKTtcbiAgICAgICAgaWYgKCFyZXN1bHQudGV4dClcbiAgICAgICAgICAgIHJlc3VsdC50ZXh0ID0gbm9kZSA9PiBub2RlLnRleHQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdhdGhlciB0aGUgc2VyaWFsaXplcnMgaW4gYSBzY2hlbWEncyBtYXJrIHNwZWNzIGludG8gYW4gb2JqZWN0LlxuICAgICovXG4gICAgc3RhdGljIG1hcmtzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIGdhdGhlclRvRE9NKHNjaGVtYS5tYXJrcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2F0aGVyVG9ET00ob2JqKSB7XG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IG5hbWUgaW4gb2JqKSB7XG4gICAgICAgIGxldCB0b0RPTSA9IG9ialtuYW1lXS5zcGVjLnRvRE9NO1xuICAgICAgICBpZiAodG9ET00pXG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSB0b0RPTTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGRvYyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZG9jdW1lbnQgfHwgd2luZG93LmRvY3VtZW50O1xufVxuXG5leHBvcnQgeyBDb250ZW50TWF0Y2gsIERPTVBhcnNlciwgRE9NU2VyaWFsaXplciwgRnJhZ21lbnQsIE1hcmssIE1hcmtUeXBlLCBOb2RlLCBOb2RlUmFuZ2UsIE5vZGVUeXBlLCBSZXBsYWNlRXJyb3IsIFJlc29sdmVkUG9zLCBTY2hlbWEsIFNsaWNlIH07XG4iLCAiaW1wb3J0IHsgUmVwbGFjZUVycm9yLCBTbGljZSwgRnJhZ21lbnQsIE1hcmtUeXBlLCBNYXJrIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuXG4vLyBSZWNvdmVyeSB2YWx1ZXMgZW5jb2RlIGEgcmFuZ2UgaW5kZXggYW5kIGFuIG9mZnNldC4gVGhleSBhcmVcbi8vIHJlcHJlc2VudGVkIGFzIG51bWJlcnMsIGJlY2F1c2UgdG9ucyBvZiB0aGVtIHdpbGwgYmUgY3JlYXRlZCB3aGVuXG4vLyBtYXBwaW5nLCBmb3IgZXhhbXBsZSwgYSBsYXJnZSBudW1iZXIgb2YgZGVjb3JhdGlvbnMuIFRoZSBudW1iZXInc1xuLy8gbG93ZXIgMTYgYml0cyBwcm92aWRlIHRoZSBpbmRleCwgdGhlIHJlbWFpbmluZyBiaXRzIHRoZSBvZmZzZXQuXG4vL1xuLy8gTm90ZTogV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYml0IHNoaWZ0IG9wZXJhdG9ycyB0byBlbi0gYW5kXG4vLyBkZWNvZGUgdGhlc2UsIHNpbmNlIHRob3NlIGNsaXAgdG8gMzIgYml0cywgd2hpY2ggd2UgbWlnaHQgaW4gcmFyZVxuLy8gY2FzZXMgd2FudCB0byBvdmVyZmxvdy4gQSA2NC1iaXQgZmxvYXQgY2FuIHJlcHJlc2VudCA0OC1iaXRcbi8vIGludGVnZXJzIHByZWNpc2VseS5cbmNvbnN0IGxvd2VyMTYgPSAweGZmZmY7XG5jb25zdCBmYWN0b3IxNiA9IE1hdGgucG93KDIsIDE2KTtcbmZ1bmN0aW9uIG1ha2VSZWNvdmVyKGluZGV4LCBvZmZzZXQpIHsgcmV0dXJuIGluZGV4ICsgb2Zmc2V0ICogZmFjdG9yMTY7IH1cbmZ1bmN0aW9uIHJlY292ZXJJbmRleCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgJiBsb3dlcjE2OyB9XG5mdW5jdGlvbiByZWNvdmVyT2Zmc2V0KHZhbHVlKSB7IHJldHVybiAodmFsdWUgLSAodmFsdWUgJiBsb3dlcjE2KSkgLyBmYWN0b3IxNjsgfVxuY29uc3QgREVMX0JFRk9SRSA9IDEsIERFTF9BRlRFUiA9IDIsIERFTF9BQ1JPU1MgPSA0LCBERUxfU0lERSA9IDg7XG4vKipcbkFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBtYXBwZWQgcG9zaXRpb24gd2l0aCBleHRyYVxuaW5mb3JtYXRpb24uXG4qL1xuY2xhc3MgTWFwUmVzdWx0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBtYXBwZWQgdmVyc2lvbiBvZiB0aGUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZGVsSW5mbywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWNvdmVyKSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmRlbEluZm8gPSBkZWxJbmZvO1xuICAgICAgICB0aGlzLnJlY292ZXIgPSByZWNvdmVyO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGUgcG9zaXRpb24gd2FzIGRlbGV0ZWQsIHRoYXQgaXMsIHdoZXRoZXIgdGhlXG4gICAgc3RlcCByZW1vdmVkIHRoZSB0b2tlbiBvbiB0aGUgc2lkZSBxdWVyaWVkICh2aWEgdGhlIGBhc3NvY2ApXG4gICAgYXJndW1lbnQgZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZGVsZXRlZCgpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiBERUxfU0lERSkgPiAwOyB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIHRva2VuIGJlZm9yZSB0aGUgbWFwcGVkIHBvc2l0aW9uIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRCZWZvcmUoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgKERFTF9CRUZPUkUgfCBERUxfQUNST1NTKSkgPiAwOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoZSB0b2tlbiBhZnRlciB0aGUgbWFwcGVkIHBvc2l0aW9uIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRBZnRlcigpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiAoREVMX0FGVEVSIHwgREVMX0FDUk9TUykpID4gMDsgfVxuICAgIC8qKlxuICAgIFRlbGxzIHdoZXRoZXIgYW55IG9mIHRoZSBzdGVwcyBtYXBwZWQgdGhyb3VnaCBkZWxldGVzIGFjcm9zcyB0aGVcbiAgICBwb3NpdGlvbiAoaW5jbHVkaW5nIGJvdGggdGhlIHRva2VuIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlXG4gICAgcG9zaXRpb24pLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRBY3Jvc3MoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgREVMX0FDUk9TUykgPiAwOyB9XG59XG4vKipcbkEgbWFwIGRlc2NyaWJpbmcgdGhlIGRlbGV0aW9ucyBhbmQgaW5zZXJ0aW9ucyBtYWRlIGJ5IGEgc3RlcCwgd2hpY2hcbmNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlIGNvcnJlc3BvbmRlbmNlIGJldHdlZW4gcG9zaXRpb25zIGluIHRoZVxucHJlLXN0ZXAgdmVyc2lvbiBvZiBhIGRvY3VtZW50IGFuZCB0aGUgc2FtZSBwb3NpdGlvbiBpbiB0aGVcbnBvc3Qtc3RlcCB2ZXJzaW9uLlxuKi9cbmNsYXNzIFN0ZXBNYXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBvc2l0aW9uIG1hcC4gVGhlIG1vZGlmaWNhdGlvbnMgdG8gdGhlIGRvY3VtZW50IGFyZVxuICAgIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIG51bWJlcnMsIGluIHdoaWNoIGVhY2ggZ3JvdXAgb2YgdGhyZWVcbiAgICByZXByZXNlbnRzIGEgbW9kaWZpZWQgY2h1bmsgYXMgYFtzdGFydCwgb2xkU2l6ZSwgbmV3U2l6ZV1gLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByYW5nZXMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW52ZXJ0ZWQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5pbnZlcnRlZCA9IGludmVydGVkO1xuICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGggJiYgU3RlcE1hcC5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlY292ZXIodmFsdWUpIHtcbiAgICAgICAgbGV0IGRpZmYgPSAwLCBpbmRleCA9IHJlY292ZXJJbmRleCh2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5pbnZlcnRlZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICBkaWZmICs9IHRoaXMucmFuZ2VzW2kgKiAzICsgMl0gLSB0aGlzLnJhbmdlc1tpICogMyArIDFdO1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXNbaW5kZXggKiAzXSArIGRpZmYgKyByZWNvdmVyT2Zmc2V0KHZhbHVlKTtcbiAgICB9XG4gICAgbWFwUmVzdWx0KHBvcywgYXNzb2MgPSAxKSB7IHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgZmFsc2UpOyB9XG4gICAgbWFwKHBvcywgYXNzb2MgPSAxKSB7IHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIF9tYXAocG9zLCBhc3NvYywgc2ltcGxlKSB7XG4gICAgICAgIGxldCBkaWZmID0gMCwgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsIG5ld0luZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDEgOiAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1tpXSAtICh0aGlzLmludmVydGVkID8gZGlmZiA6IDApO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IG9sZFNpemUgPSB0aGlzLnJhbmdlc1tpICsgb2xkSW5kZXhdLCBuZXdTaXplID0gdGhpcy5yYW5nZXNbaSArIG5ld0luZGV4XSwgZW5kID0gc3RhcnQgKyBvbGRTaXplO1xuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2lkZSA9ICFvbGRTaXplID8gYXNzb2MgOiBwb3MgPT0gc3RhcnQgPyAtMSA6IHBvcyA9PSBlbmQgPyAxIDogYXNzb2M7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHN0YXJ0ICsgZGlmZiArIChzaWRlIDwgMCA/IDAgOiBuZXdTaXplKTtcbiAgICAgICAgICAgICAgICBpZiAoc2ltcGxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGxldCByZWNvdmVyID0gcG9zID09IChhc3NvYyA8IDAgPyBzdGFydCA6IGVuZCkgPyBudWxsIDogbWFrZVJlY292ZXIoaSAvIDMsIHBvcyAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBsZXQgZGVsID0gcG9zID09IHN0YXJ0ID8gREVMX0FGVEVSIDogcG9zID09IGVuZCA/IERFTF9CRUZPUkUgOiBERUxfQUNST1NTO1xuICAgICAgICAgICAgICAgIGlmIChhc3NvYyA8IDAgPyBwb3MgIT0gc3RhcnQgOiBwb3MgIT0gZW5kKVxuICAgICAgICAgICAgICAgICAgICBkZWwgfD0gREVMX1NJREU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXBSZXN1bHQocmVzdWx0LCBkZWwsIHJlY292ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlmZiArPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2ltcGxlID8gcG9zICsgZGlmZiA6IG5ldyBNYXBSZXN1bHQocG9zICsgZGlmZiwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG91Y2hlcyhwb3MsIHJlY292ZXIpIHtcbiAgICAgICAgbGV0IGRpZmYgPSAwLCBpbmRleCA9IHJlY292ZXJJbmRleChyZWNvdmVyKTtcbiAgICAgICAgbGV0IG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0gLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgZW5kID0gc3RhcnQgKyBvbGRTaXplO1xuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQgJiYgaSA9PSBpbmRleCAqIDMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkaWZmICs9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF0gLSBvbGRTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbHMgdGhlIGdpdmVuIGZ1bmN0aW9uIG9uIGVhY2ggb2YgdGhlIGNoYW5nZWQgcmFuZ2VzIGluY2x1ZGVkIGluXG4gICAgdGhpcyBtYXAuXG4gICAgKi9cbiAgICBmb3JFYWNoKGYpIHtcbiAgICAgICAgbGV0IG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGRpZmYgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzW2ldLCBvbGRTdGFydCA9IHN0YXJ0IC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCksIG5ld1N0YXJ0ID0gc3RhcnQgKyAodGhpcy5pbnZlcnRlZCA/IDAgOiBkaWZmKTtcbiAgICAgICAgICAgIGxldCBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgbmV3U2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF07XG4gICAgICAgICAgICBmKG9sZFN0YXJ0LCBvbGRTdGFydCArIG9sZFNpemUsIG5ld1N0YXJ0LCBuZXdTdGFydCArIG5ld1NpemUpO1xuICAgICAgICAgICAgZGlmZiArPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW52ZXJ0ZWQgdmVyc2lvbiBvZiB0aGlzIG1hcC4gVGhlIHJlc3VsdCBjYW4gYmUgdXNlZCB0b1xuICAgIG1hcCBwb3NpdGlvbnMgaW4gdGhlIHBvc3Qtc3RlcCBkb2N1bWVudCB0byB0aGUgcHJlLXN0ZXAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RlcE1hcCh0aGlzLnJhbmdlcywgIXRoaXMuaW52ZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW52ZXJ0ZWQgPyBcIi1cIiA6IFwiXCIpICsgSlNPTi5zdHJpbmdpZnkodGhpcy5yYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXAgdGhhdCBtb3ZlcyBhbGwgcG9zaXRpb25zIGJ5IG9mZnNldCBgbmAgKHdoaWNoIG1heSBiZVxuICAgIG5lZ2F0aXZlKS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gYXBwbHlpbmcgc3RlcHMgbWVhbnQgZm9yIGFcbiAgICBzdWItZG9jdW1lbnQgdG8gYSBsYXJnZXIgZG9jdW1lbnQsIG9yIHZpY2UtdmVyc2EuXG4gICAgKi9cbiAgICBzdGF0aWMgb2Zmc2V0KG4pIHtcbiAgICAgICAgcmV0dXJuIG4gPT0gMCA/IFN0ZXBNYXAuZW1wdHkgOiBuZXcgU3RlcE1hcChuIDwgMCA/IFswLCAtbiwgMF0gOiBbMCwgMCwgbl0pO1xuICAgIH1cbn1cbi8qKlxuQSBTdGVwTWFwIHRoYXQgY29udGFpbnMgbm8gY2hhbmdlZCByYW5nZXMuXG4qL1xuU3RlcE1hcC5lbXB0eSA9IG5ldyBTdGVwTWFwKFtdKTtcbi8qKlxuQSBtYXBwaW5nIHJlcHJlc2VudHMgYSBwaXBlbGluZSBvZiB6ZXJvIG9yIG1vcmUgW3N0ZXBcbm1hcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcE1hcCkuIEl0IGhhcyBzcGVjaWFsIHByb3Zpc2lvbnMgZm9yIGxvc3NsZXNzbHlcbmhhbmRsaW5nIG1hcHBpbmcgcG9zaXRpb25zIHRocm91Z2ggYSBzZXJpZXMgb2Ygc3RlcHMgaW4gd2hpY2ggc29tZVxuc3RlcHMgYXJlIGludmVydGVkIHZlcnNpb25zIG9mIGVhcmxpZXIgc3RlcHMuIChUaGlzIGNvbWVzIHVwIHdoZW5cblx1MjAxOFtyZWJhc2luZ10oL2RvY3MvZ3VpZGUvI3RyYW5zZm9ybS5yZWJhc2luZylcdTIwMTkgc3RlcHMgZm9yXG5jb2xsYWJvcmF0aW9uIG9yIGhpc3RvcnkgbWFuYWdlbWVudC4pXG4qL1xuY2xhc3MgTWFwcGluZyB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IG1hcHBpbmcgd2l0aCB0aGUgZ2l2ZW4gcG9zaXRpb24gbWFwcy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGVwIG1hcHMgaW4gdGhpcyBtYXBwaW5nLlxuICAgICovXG4gICAgbWFwcyA9IFtdLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1pcnJvciwgXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGluIHRoZSBgbWFwc2AgYXJyYXksIHVzZWQgd2hlbiBgbWFwYCBvclxuICAgIGBtYXBSZXN1bHRgIGlzIGNhbGxlZC5cbiAgICAqL1xuICAgIGZyb20gPSAwLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uIGluIHRoZSBgbWFwc2AgYXJyYXkuXG4gICAgKi9cbiAgICB0byA9IG1hcHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubWFwcyA9IG1hcHM7XG4gICAgICAgIHRoaXMubWlycm9yID0gbWlycm9yO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcHBpbmcgdGhhdCBtYXBzIG9ubHkgdGhyb3VnaCBhIHBhcnQgb2YgdGhpcyBvbmUuXG4gICAgKi9cbiAgICBzbGljZShmcm9tID0gMCwgdG8gPSB0aGlzLm1hcHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwcGluZyh0aGlzLm1hcHMsIHRoaXMubWlycm9yLCBmcm9tLCB0byk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXBwaW5nKHRoaXMubWFwcy5zbGljZSgpLCB0aGlzLm1pcnJvciAmJiB0aGlzLm1pcnJvci5zbGljZSgpLCB0aGlzLmZyb20sIHRoaXMudG8pO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSBzdGVwIG1hcCB0byB0aGUgZW5kIG9mIHRoaXMgbWFwcGluZy4gSWYgYG1pcnJvcnNgIGlzXG4gICAgZ2l2ZW4sIGl0IHNob3VsZCBiZSB0aGUgaW5kZXggb2YgdGhlIHN0ZXAgbWFwIHRoYXQgaXMgdGhlIG1pcnJvclxuICAgIGltYWdlIG9mIHRoaXMgb25lLlxuICAgICovXG4gICAgYXBwZW5kTWFwKG1hcCwgbWlycm9ycykge1xuICAgICAgICB0aGlzLnRvID0gdGhpcy5tYXBzLnB1c2gobWFwKTtcbiAgICAgICAgaWYgKG1pcnJvcnMgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuc2V0TWlycm9yKHRoaXMubWFwcy5sZW5ndGggLSAxLCBtaXJyb3JzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGFsbCB0aGUgc3RlcCBtYXBzIGluIGEgZ2l2ZW4gbWFwcGluZyB0byB0aGlzIG9uZSAocHJlc2VydmluZ1xuICAgIG1pcnJvcmluZyBpbmZvcm1hdGlvbikuXG4gICAgKi9cbiAgICBhcHBlbmRNYXBwaW5nKG1hcHBpbmcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHN0YXJ0U2l6ZSA9IHRoaXMubWFwcy5sZW5ndGg7IGkgPCBtYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtaXJyID0gbWFwcGluZy5nZXRNaXJyb3IoaSk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZE1hcChtYXBwaW5nLm1hcHNbaV0sIG1pcnIgIT0gbnVsbCAmJiBtaXJyIDwgaSA/IHN0YXJ0U2l6ZSArIG1pcnIgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmRzIHRoZSBvZmZzZXQgb2YgdGhlIHN0ZXAgbWFwIHRoYXQgbWlycm9ycyB0aGUgbWFwIGF0IHRoZVxuICAgIGdpdmVuIG9mZnNldCwgaW4gdGhpcyBtYXBwaW5nIChhcyBwZXIgdGhlIHNlY29uZCBhcmd1bWVudCB0b1xuICAgIGBhcHBlbmRNYXBgKS5cbiAgICAqL1xuICAgIGdldE1pcnJvcihuKSB7XG4gICAgICAgIGlmICh0aGlzLm1pcnJvcilcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5taXJyb3IubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yW2ldID09IG4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1pcnJvcltpICsgKGkgJSAyID8gLTEgOiAxKV07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2V0TWlycm9yKG4sIG0pIHtcbiAgICAgICAgaWYgKCF0aGlzLm1pcnJvcilcbiAgICAgICAgICAgIHRoaXMubWlycm9yID0gW107XG4gICAgICAgIHRoaXMubWlycm9yLnB1c2gobiwgbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGVuZCB0aGUgaW52ZXJzZSBvZiB0aGUgZ2l2ZW4gbWFwcGluZyB0byB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZE1hcHBpbmdJbnZlcnRlZChtYXBwaW5nKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBtYXBwaW5nLm1hcHMubGVuZ3RoIC0gMSwgdG90YWxTaXplID0gdGhpcy5tYXBzLmxlbmd0aCArIG1hcHBpbmcubWFwcy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgbWlyciA9IG1hcHBpbmcuZ2V0TWlycm9yKGkpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRNYXAobWFwcGluZy5tYXBzW2ldLmludmVydCgpLCBtaXJyICE9IG51bGwgJiYgbWlyciA+IGkgPyB0b3RhbFNpemUgLSBtaXJyIC0gMSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGludmVydGVkIHZlcnNpb24gb2YgdGhpcyBtYXBwaW5nLlxuICAgICovXG4gICAgaW52ZXJ0KCkge1xuICAgICAgICBsZXQgaW52ZXJzZSA9IG5ldyBNYXBwaW5nO1xuICAgICAgICBpbnZlcnNlLmFwcGVuZE1hcHBpbmdJbnZlcnRlZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGludmVyc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhIHBvc2l0aW9uIHRocm91Z2ggdGhpcyBtYXBwaW5nLlxuICAgICovXG4gICAgbWFwKHBvcywgYXNzb2MgPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLm1pcnJvcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgdHJ1ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZyb207IGkgPCB0aGlzLnRvOyBpKyspXG4gICAgICAgICAgICBwb3MgPSB0aGlzLm1hcHNbaV0ubWFwKHBvcywgYXNzb2MpO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYSBwb3NpdGlvbiB0aHJvdWdoIHRoaXMgbWFwcGluZywgcmV0dXJuaW5nIGEgbWFwcGluZ1xuICAgIHJlc3VsdC5cbiAgICAqL1xuICAgIG1hcFJlc3VsdChwb3MsIGFzc29jID0gMSkgeyByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIGZhbHNlKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgX21hcChwb3MsIGFzc29jLCBzaW1wbGUpIHtcbiAgICAgICAgbGV0IGRlbEluZm8gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcm9tOyBpIDwgdGhpcy50bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwID0gdGhpcy5tYXBzW2ldLCByZXN1bHQgPSBtYXAubWFwUmVzdWx0KHBvcywgYXNzb2MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29yciA9IHRoaXMuZ2V0TWlycm9yKGkpO1xuICAgICAgICAgICAgICAgIGlmIChjb3JyICE9IG51bGwgJiYgY29yciA+IGkgJiYgY29yciA8IHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGNvcnI7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMubWFwc1tjb3JyXS5yZWNvdmVyKHJlc3VsdC5yZWNvdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsSW5mbyB8PSByZXN1bHQuZGVsSW5mbztcbiAgICAgICAgICAgIHBvcyA9IHJlc3VsdC5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbXBsZSA/IHBvcyA6IG5ldyBNYXBSZXN1bHQocG9zLCBkZWxJbmZvLCBudWxsKTtcbiAgICB9XG59XG5cbmNvbnN0IHN0ZXBzQnlJRCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcbkEgc3RlcCBvYmplY3QgcmVwcmVzZW50cyBhbiBhdG9taWMgY2hhbmdlLiBJdCBnZW5lcmFsbHkgYXBwbGllc1xub25seSB0byB0aGUgZG9jdW1lbnQgaXQgd2FzIGNyZWF0ZWQgZm9yLCBzaW5jZSB0aGUgcG9zaXRpb25zXG5zdG9yZWQgaW4gaXQgd2lsbCBvbmx5IG1ha2Ugc2Vuc2UgZm9yIHRoYXQgZG9jdW1lbnQuXG5cbk5ldyBzdGVwcyBhcmUgZGVmaW5lZCBieSBjcmVhdGluZyBjbGFzc2VzIHRoYXQgZXh0ZW5kIGBTdGVwYCxcbm92ZXJyaWRpbmcgdGhlIGBhcHBseWAsIGBpbnZlcnRgLCBgbWFwYCwgYGdldE1hcGAgYW5kIGBmcm9tSlNPTmBcbm1ldGhvZHMsIGFuZCByZWdpc3RlcmluZyB5b3VyIGNsYXNzIHdpdGggYSB1bmlxdWVcbkpTT04tc2VyaWFsaXphdGlvbiBpZGVudGlmaWVyIHVzaW5nXG5bYFN0ZXAuanNvbklEYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwXmpzb25JRCkuXG4qL1xuY2xhc3MgU3RlcCB7XG4gICAgLyoqXG4gICAgR2V0IHRoZSBzdGVwIG1hcCB0aGF0IHJlcHJlc2VudHMgdGhlIGNoYW5nZXMgbWFkZSBieSB0aGlzIHN0ZXAsXG4gICAgYW5kIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHRyYW5zZm9ybSBiZXR3ZWVuIHBvc2l0aW9ucyBpbiB0aGUgb2xkXG4gICAgYW5kIHRoZSBuZXcgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXRNYXAoKSB7IHJldHVybiBTdGVwTWFwLmVtcHR5OyB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIG1lcmdlIHRoaXMgc3RlcCB3aXRoIGFub3RoZXIgb25lLCB0byBiZSBhcHBsaWVkIGRpcmVjdGx5XG4gICAgYWZ0ZXIgaXQuIFJldHVybnMgdGhlIG1lcmdlZCBzdGVwIHdoZW4gcG9zc2libGUsIG51bGwgaWYgdGhlXG4gICAgc3RlcHMgY2FuJ3QgYmUgbWVyZ2VkLlxuICAgICovXG4gICAgbWVyZ2Uob3RoZXIpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIHN0ZXAgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gV2lsbCBjYWxsXG4gICAgdGhyb3VnaCB0byB0aGUgc3RlcCBjbGFzcycgb3duIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIWpzb24uc3RlcFR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIGxldCB0eXBlID0gc3RlcHNCeUlEW2pzb24uc3RlcFR5cGVdO1xuICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gc3RlcCB0eXBlICR7anNvbi5zdGVwVHlwZX0gZGVmaW5lZGApO1xuICAgICAgICByZXR1cm4gdHlwZS5mcm9tSlNPTihzY2hlbWEsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBUbyBiZSBhYmxlIHRvIHNlcmlhbGl6ZSBzdGVwcyB0byBKU09OLCBlYWNoIHN0ZXAgbmVlZHMgYSBzdHJpbmdcbiAgICBJRCB0byBhdHRhY2ggdG8gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFVzZSB0aGlzIG1ldGhvZCB0b1xuICAgIHJlZ2lzdGVyIGFuIElEIGZvciB5b3VyIHN0ZXAgY2xhc3Nlcy4gVHJ5IHRvIHBpY2sgc29tZXRoaW5nXG4gICAgdGhhdCdzIHVubGlrZWx5IHRvIGNsYXNoIHdpdGggc3RlcHMgZnJvbSBvdGhlciBtb2R1bGVzLlxuICAgICovXG4gICAgc3RhdGljIGpzb25JRChpZCwgc3RlcENsYXNzKSB7XG4gICAgICAgIGlmIChpZCBpbiBzdGVwc0J5SUQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkR1cGxpY2F0ZSB1c2Ugb2Ygc3RlcCBKU09OIElEIFwiICsgaWQpO1xuICAgICAgICBzdGVwc0J5SURbaWRdID0gc3RlcENsYXNzO1xuICAgICAgICBzdGVwQ2xhc3MucHJvdG90eXBlLmpzb25JRCA9IGlkO1xuICAgICAgICByZXR1cm4gc3RlcENsYXNzO1xuICAgIH1cbn1cbi8qKlxuVGhlIHJlc3VsdCBvZiBbYXBwbHlpbmddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcC5hcHBseSkgYSBzdGVwLiBDb250YWlucyBlaXRoZXIgYVxubmV3IGRvY3VtZW50IG9yIGEgZmFpbHVyZSB2YWx1ZS5cbiovXG5jbGFzcyBTdGVwUmVzdWx0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0cmFuc2Zvcm1lZCBkb2N1bWVudCwgaWYgc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIGRvYywgXG4gICAgLyoqXG4gICAgVGhlIGZhaWx1cmUgbWVzc2FnZSwgaWYgdW5zdWNjZXNzZnVsLlxuICAgICovXG4gICAgZmFpbGVkKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLmZhaWxlZCA9IGZhaWxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc3VjY2Vzc2Z1bCBzdGVwIHJlc3VsdC5cbiAgICAqL1xuICAgIHN0YXRpYyBvayhkb2MpIHsgcmV0dXJuIG5ldyBTdGVwUmVzdWx0KGRvYywgbnVsbCk7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmYWlsZWQgc3RlcCByZXN1bHQuXG4gICAgKi9cbiAgICBzdGF0aWMgZmFpbChtZXNzYWdlKSB7IHJldHVybiBuZXcgU3RlcFJlc3VsdChudWxsLCBtZXNzYWdlKTsgfVxuICAgIC8qKlxuICAgIENhbGwgW2BOb2RlLnJlcGxhY2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS5yZXBsYWNlKSB3aXRoIHRoZSBnaXZlblxuICAgIGFyZ3VtZW50cy4gQ3JlYXRlIGEgc3VjY2Vzc2Z1bCByZXN1bHQgaWYgaXQgc3VjY2VlZHMsIGFuZCBhXG4gICAgZmFpbGVkIG9uZSBpZiBpdCB0aHJvd3MgYSBgUmVwbGFjZUVycm9yYC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tUmVwbGFjZShkb2MsIGZyb20sIHRvLCBzbGljZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQub2soZG9jLnJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmVwbGFjZUVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1hcEZyYWdtZW50KGZyYWdtZW50LCBmLCBwYXJlbnQpIHtcbiAgICBsZXQgbWFwcGVkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFnbWVudC5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gZnJhZ21lbnQuY2hpbGQoaSk7XG4gICAgICAgIGlmIChjaGlsZC5jb250ZW50LnNpemUpXG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmNvcHkobWFwRnJhZ21lbnQoY2hpbGQuY29udGVudCwgZiwgY2hpbGQpKTtcbiAgICAgICAgaWYgKGNoaWxkLmlzSW5saW5lKVxuICAgICAgICAgICAgY2hpbGQgPSBmKGNoaWxkLCBwYXJlbnQsIGkpO1xuICAgICAgICBtYXBwZWQucHVzaChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBGcmFnbWVudC5mcm9tQXJyYXkobWFwcGVkKTtcbn1cbi8qKlxuQWRkIGEgbWFyayB0byBhbGwgaW5saW5lIGNvbnRlbnQgYmV0d2VlbiB0d28gcG9zaXRpb25zLlxuKi9cbmNsYXNzIEFkZE1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBtYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSBtYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gYWRkLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgb2xkU2xpY2UgPSBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKSwgJGZyb20gPSBkb2MucmVzb2x2ZSh0aGlzLmZyb20pO1xuICAgICAgICBsZXQgcGFyZW50ID0gJGZyb20ubm9kZSgkZnJvbS5zaGFyZWREZXB0aCh0aGlzLnRvKSk7XG4gICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShtYXBGcmFnbWVudChvbGRTbGljZS5jb250ZW50LCAobm9kZSwgcGFyZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIW5vZGUuaXNBdG9tIHx8ICFwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZSh0aGlzLm1hcmsudHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5tYXJrKHRoaXMubWFyay5hZGRUb1NldChub2RlLm1hcmtzKSk7XG4gICAgICAgIH0sIHBhcmVudCksIG9sZFNsaWNlLm9wZW5TdGFydCwgb2xkU2xpY2Uub3BlbkVuZCk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBzbGljZSk7XG4gICAgfVxuICAgIGludmVydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcCh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQgJiYgdG8uZGVsZXRlZCB8fCBmcm9tLnBvcyA+PSB0by5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChmcm9tLnBvcywgdG8ucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBBZGRNYXJrU3RlcCAmJlxuICAgICAgICAgICAgb3RoZXIubWFyay5lcSh0aGlzLm1hcmspICYmXG4gICAgICAgICAgICB0aGlzLmZyb20gPD0gb3RoZXIudG8gJiYgdGhpcy50byA+PSBvdGhlci5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChNYXRoLm1pbih0aGlzLmZyb20sIG90aGVyLmZyb20pLCBNYXRoLm1heCh0aGlzLnRvLCBvdGhlci50byksIHRoaXMubWFyayk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImFkZE1hcmtcIiwgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpLFxuICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBBZGRNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChqc29uLmZyb20sIGpzb24udG8sIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJhZGRNYXJrXCIsIEFkZE1hcmtTdGVwKTtcbi8qKlxuUmVtb3ZlIGEgbWFyayBmcm9tIGFsbCBpbmxpbmUgY29udGVudCBiZXR3ZWVuIHR3byBwb3NpdGlvbnMuXG4qL1xuY2xhc3MgUmVtb3ZlTWFya1N0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrLXJlbW92aW5nIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgdGhlIHVubWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgdW5tYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gcmVtb3ZlLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgb2xkU2xpY2UgPSBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKG1hcEZyYWdtZW50KG9sZFNsaWNlLmNvbnRlbnQsIG5vZGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubWFyayh0aGlzLm1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSk7XG4gICAgICAgIH0sIGRvYyksIG9sZFNsaWNlLm9wZW5TdGFydCwgb2xkU2xpY2Uub3BlbkVuZCk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBzbGljZSk7XG4gICAgfVxuICAgIGludmVydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcCh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQgJiYgdG8uZGVsZXRlZCB8fCBmcm9tLnBvcyA+PSB0by5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChmcm9tLnBvcywgdG8ucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBSZW1vdmVNYXJrU3RlcCAmJlxuICAgICAgICAgICAgb3RoZXIubWFyay5lcSh0aGlzLm1hcmspICYmXG4gICAgICAgICAgICB0aGlzLmZyb20gPD0gb3RoZXIudG8gJiYgdGhpcy50byA+PSBvdGhlci5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChNYXRoLm1pbih0aGlzLmZyb20sIG90aGVyLmZyb20pLCBNYXRoLm1heCh0aGlzLnRvLCBvdGhlci50byksIHRoaXMubWFyayk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcInJlbW92ZU1hcmtcIiwgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpLFxuICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZW1vdmVNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChqc29uLmZyb20sIGpzb24udG8sIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZW1vdmVNYXJrXCIsIFJlbW92ZU1hcmtTdGVwKTtcbi8qKlxuQWRkIGEgbWFyayB0byBhIHNwZWNpZmljIG5vZGUuXG4qL1xuY2xhc3MgQWRkTm9kZU1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBtYXJrIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBub2RlLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayB0byBhZGQuXG4gICAgKi9cbiAgICBtYXJrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgbWFyayBzdGVwJ3MgcG9zaXRpb25cIik7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbm9kZS50eXBlLmNyZWF0ZShub2RlLmF0dHJzLCBudWxsLCB0aGlzLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMucG9zLCB0aGlzLnBvcyArIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLCAwLCBub2RlLmlzTGVhZiA/IDAgOiAxKSk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIGxldCBuZXdTZXQgPSB0aGlzLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcyk7XG4gICAgICAgICAgICBpZiAobmV3U2V0Lmxlbmd0aCA9PSBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5tYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLm1hcmtzW2ldLmlzSW5TZXQobmV3U2V0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKHRoaXMucG9zLCBub2RlLm1hcmtzW2ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcCh0aGlzLnBvcywgdGhpcy5tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU5vZGVNYXJrU3RlcCh0aGlzLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMucG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIHBvcy5kZWxldGVkQWZ0ZXIgPyBudWxsIDogbmV3IEFkZE5vZGVNYXJrU3RlcChwb3MucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImFkZE5vZGVNYXJrXCIsIHBvczogdGhpcy5wb3MsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBBZGROb2RlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKGpzb24ucG9zLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiYWRkTm9kZU1hcmtcIiwgQWRkTm9kZU1hcmtTdGVwKTtcbi8qKlxuUmVtb3ZlIGEgbWFyayBmcm9tIGEgc3BlY2lmaWMgbm9kZS5cbiovXG5jbGFzcyBSZW1vdmVOb2RlTWFya1N0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrLXJlbW92aW5nIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBub2RlLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayB0byByZW1vdmUuXG4gICAgKi9cbiAgICBtYXJrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgbWFyayBzdGVwJ3MgcG9zaXRpb25cIik7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbm9kZS50eXBlLmNyZWF0ZShub2RlLmF0dHJzLCBudWxsLCB0aGlzLm1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5wb3MsIHRoaXMucG9zICsgMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odXBkYXRlZCksIDAsIG5vZGUuaXNMZWFmID8gMCA6IDEpKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoIW5vZGUgfHwgIXRoaXMubWFyay5pc0luU2V0KG5vZGUubWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKHRoaXMucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgcG9zID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5wb3MsIDEpO1xuICAgICAgICByZXR1cm4gcG9zLmRlbGV0ZWRBZnRlciA/IG51bGwgOiBuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKHBvcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwicmVtb3ZlTm9kZU1hcmtcIiwgcG9zOiB0aGlzLnBvcywgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24ucG9zICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlbW92ZU5vZGVNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAoanNvbi5wb3MsIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZW1vdmVOb2RlTWFya1wiLCBSZW1vdmVOb2RlTWFya1N0ZXApO1xuXG4vKipcblJlcGxhY2UgYSBwYXJ0IG9mIHRoZSBkb2N1bWVudCB3aXRoIGEgc2xpY2Ugb2YgbmV3IGNvbnRlbnQuXG4qL1xuY2xhc3MgUmVwbGFjZVN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBUaGUgZ2l2ZW4gYHNsaWNlYCBzaG91bGQgZml0IHRoZSAnZ2FwJyBiZXR3ZWVuIGBmcm9tYCBhbmRcbiAgICBgdG9gXHUyMDE0dGhlIGRlcHRocyBtdXN0IGxpbmUgdXAsIGFuZCB0aGUgc3Vycm91bmRpbmcgbm9kZXMgbXVzdCBiZVxuICAgIGFibGUgdG8gYmUgam9pbmVkIHdpdGggdGhlIG9wZW4gc2lkZXMgb2YgdGhlIHNsaWNlLiBXaGVuXG4gICAgYHN0cnVjdHVyZWAgaXMgdHJ1ZSwgdGhlIHN0ZXAgd2lsbCBmYWlsIGlmIHRoZSBjb250ZW50IGJldHdlZW5cbiAgICBmcm9tIGFuZCB0byBpcyBub3QganVzdCBhIHNlcXVlbmNlIG9mIGNsb3NpbmcgYW5kIHRoZW4gb3BlbmluZ1xuICAgIHRva2VucyAodGhpcyBpcyB0byBndWFyZCBhZ2FpbnN0IHJlYmFzZWQgcmVwbGFjZSBzdGVwc1xuICAgIG92ZXJ3cml0aW5nIHNvbWV0aGluZyB0aGV5IHdlcmVuJ3Qgc3VwcG9zZWQgdG8pLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBzbGljZSB0byBpbnNlcnQuXG4gICAgKi9cbiAgICBzbGljZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdHJ1Y3R1cmUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuc2xpY2UgPSBzbGljZTtcbiAgICAgICAgdGhpcy5zdHJ1Y3R1cmUgPSBzdHJ1Y3R1cmU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUgJiYgY29udGVudEJldHdlZW4oZG9jLCB0aGlzLmZyb20sIHRoaXMudG8pKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIlN0cnVjdHVyZSByZXBsYWNlIHdvdWxkIG92ZXJ3cml0ZSBjb250ZW50XCIpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5zbGljZSk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGVwTWFwKFt0aGlzLmZyb20sIHRoaXMudG8gLSB0aGlzLmZyb20sIHRoaXMuc2xpY2Uuc2l6ZV0pO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAodGhpcy5mcm9tLCB0aGlzLmZyb20gKyB0aGlzLnNsaWNlLnNpemUsIGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICAgICAgaWYgKGZyb20uZGVsZXRlZEFjcm9zcyAmJiB0by5kZWxldGVkQWNyb3NzKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoZnJvbS5wb3MsIE1hdGgubWF4KGZyb20ucG9zLCB0by5wb3MpLCB0aGlzLnNsaWNlKTtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCkgfHwgb3RoZXIuc3RydWN0dXJlIHx8IHRoaXMuc3RydWN0dXJlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0aGlzLmZyb20gKyB0aGlzLnNsaWNlLnNpemUgPT0gb3RoZXIuZnJvbSAmJiAhdGhpcy5zbGljZS5vcGVuRW5kICYmICFvdGhlci5zbGljZS5vcGVuU3RhcnQpIHtcbiAgICAgICAgICAgIGxldCBzbGljZSA9IHRoaXMuc2xpY2Uuc2l6ZSArIG90aGVyLnNsaWNlLnNpemUgPT0gMCA/IFNsaWNlLmVtcHR5XG4gICAgICAgICAgICAgICAgOiBuZXcgU2xpY2UodGhpcy5zbGljZS5jb250ZW50LmFwcGVuZChvdGhlci5zbGljZS5jb250ZW50KSwgdGhpcy5zbGljZS5vcGVuU3RhcnQsIG90aGVyLnNsaWNlLm9wZW5FbmQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcCh0aGlzLmZyb20sIHRoaXMudG8gKyAob3RoZXIudG8gLSBvdGhlci5mcm9tKSwgc2xpY2UsIHRoaXMuc3RydWN0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlci50byA9PSB0aGlzLmZyb20gJiYgIXRoaXMuc2xpY2Uub3BlblN0YXJ0ICYmICFvdGhlci5zbGljZS5vcGVuRW5kKSB7XG4gICAgICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLnNsaWNlLnNpemUgKyBvdGhlci5zbGljZS5zaXplID09IDAgPyBTbGljZS5lbXB0eVxuICAgICAgICAgICAgICAgIDogbmV3IFNsaWNlKG90aGVyLnNsaWNlLmNvbnRlbnQuYXBwZW5kKHRoaXMuc2xpY2UuY29udGVudCksIG90aGVyLnNsaWNlLm9wZW5TdGFydCwgdGhpcy5zbGljZS5vcGVuRW5kKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAob3RoZXIuZnJvbSwgdGhpcy50bywgc2xpY2UsIHRoaXMuc3RydWN0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGpzb24gPSB7IHN0ZXBUeXBlOiBcInJlcGxhY2VcIiwgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byB9O1xuICAgICAgICBpZiAodGhpcy5zbGljZS5zaXplKVxuICAgICAgICAgICAganNvbi5zbGljZSA9IHRoaXMuc2xpY2UudG9KU09OKCk7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSlcbiAgICAgICAgICAgIGpzb24uc3RydWN0dXJlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlcGxhY2VTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGpzb24uZnJvbSwganNvbi50bywgU2xpY2UuZnJvbUpTT04oc2NoZW1hLCBqc29uLnNsaWNlKSwgISFqc29uLnN0cnVjdHVyZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZXBsYWNlXCIsIFJlcGxhY2VTdGVwKTtcbi8qKlxuUmVwbGFjZSBhIHBhcnQgb2YgdGhlIGRvY3VtZW50IHdpdGggYSBzbGljZSBvZiBjb250ZW50LCBidXRcbnByZXNlcnZlIGEgcmFuZ2Ugb2YgdGhlIHJlcGxhY2VkIGNvbnRlbnQgYnkgbW92aW5nIGl0IGludG8gdGhlXG5zbGljZS5cbiovXG5jbGFzcyBSZXBsYWNlQXJvdW5kU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJlcGxhY2UtYXJvdW5kIHN0ZXAgd2l0aCB0aGUgZ2l2ZW4gcmFuZ2UgYW5kIGdhcC5cbiAgICBgaW5zZXJ0YCBzaG91bGQgYmUgdGhlIHBvaW50IGluIHRoZSBzbGljZSBpbnRvIHdoaWNoIHRoZSBjb250ZW50XG4gICAgb2YgdGhlIGdhcCBzaG91bGQgYmUgbW92ZWQuIGBzdHJ1Y3R1cmVgIGhhcyB0aGUgc2FtZSBtZWFuaW5nIGFzXG4gICAgaXQgaGFzIGluIHRoZSBbYFJlcGxhY2VTdGVwYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5SZXBsYWNlU3RlcCkgY2xhc3MuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHByZXNlcnZlZCByYW5nZS5cbiAgICAqL1xuICAgIGdhcEZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgcHJlc2VydmVkIHJhbmdlLlxuICAgICovXG4gICAgZ2FwVG8sIFxuICAgIC8qKlxuICAgIFRoZSBzbGljZSB0byBpbnNlcnQuXG4gICAgKi9cbiAgICBzbGljZSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGluIHRoZSBzbGljZSB3aGVyZSB0aGUgcHJlc2VydmVkIHJhbmdlIHNob3VsZCBiZVxuICAgIGluc2VydGVkLlxuICAgICovXG4gICAgaW5zZXJ0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0cnVjdHVyZSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5nYXBGcm9tID0gZ2FwRnJvbTtcbiAgICAgICAgdGhpcy5nYXBUbyA9IGdhcFRvO1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgICAgICB0aGlzLnN0cnVjdHVyZSA9IHN0cnVjdHVyZTtcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSAmJiAoY29udGVudEJldHdlZW4oZG9jLCB0aGlzLmZyb20sIHRoaXMuZ2FwRnJvbSkgfHxcbiAgICAgICAgICAgIGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5nYXBUbywgdGhpcy50bykpKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIlN0cnVjdHVyZSBnYXAtcmVwbGFjZSB3b3VsZCBvdmVyd3JpdGUgY29udGVudFwiKTtcbiAgICAgICAgbGV0IGdhcCA9IGRvYy5zbGljZSh0aGlzLmdhcEZyb20sIHRoaXMuZ2FwVG8pO1xuICAgICAgICBpZiAoZ2FwLm9wZW5TdGFydCB8fCBnYXAub3BlbkVuZClcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJHYXAgaXMgbm90IGEgZmxhdCByYW5nZVwiKTtcbiAgICAgICAgbGV0IGluc2VydGVkID0gdGhpcy5zbGljZS5pbnNlcnRBdCh0aGlzLmluc2VydCwgZ2FwLmNvbnRlbnQpO1xuICAgICAgICBpZiAoIWluc2VydGVkKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIkNvbnRlbnQgZG9lcyBub3QgZml0IGluIGdhcFwiKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIGluc2VydGVkKTtcbiAgICB9XG4gICAgZ2V0TWFwKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0ZXBNYXAoW3RoaXMuZnJvbSwgdGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLmluc2VydCxcbiAgICAgICAgICAgIHRoaXMuZ2FwVG8sIHRoaXMudG8gLSB0aGlzLmdhcFRvLCB0aGlzLnNsaWNlLnNpemUgLSB0aGlzLmluc2VydF0pO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBnYXAgPSB0aGlzLmdhcFRvIC0gdGhpcy5nYXBGcm9tO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKHRoaXMuZnJvbSwgdGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplICsgZ2FwLCB0aGlzLmZyb20gKyB0aGlzLmluc2VydCwgdGhpcy5mcm9tICsgdGhpcy5pbnNlcnQgKyBnYXAsIGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pLnJlbW92ZUJldHdlZW4odGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLmdhcFRvIC0gdGhpcy5mcm9tKSwgdGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGxldCBnYXBGcm9tID0gbWFwcGluZy5tYXAodGhpcy5nYXBGcm9tLCAtMSksIGdhcFRvID0gbWFwcGluZy5tYXAodGhpcy5nYXBUbywgMSk7XG4gICAgICAgIGlmICgoZnJvbS5kZWxldGVkQWNyb3NzICYmIHRvLmRlbGV0ZWRBY3Jvc3MpIHx8IGdhcEZyb20gPCBmcm9tLnBvcyB8fCBnYXBUbyA+IHRvLnBvcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKGZyb20ucG9zLCB0by5wb3MsIGdhcEZyb20sIGdhcFRvLCB0aGlzLnNsaWNlLCB0aGlzLmluc2VydCwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBqc29uID0geyBzdGVwVHlwZTogXCJyZXBsYWNlQXJvdW5kXCIsIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8sXG4gICAgICAgICAgICBnYXBGcm9tOiB0aGlzLmdhcEZyb20sIGdhcFRvOiB0aGlzLmdhcFRvLCBpbnNlcnQ6IHRoaXMuaW5zZXJ0IH07XG4gICAgICAgIGlmICh0aGlzLnNsaWNlLnNpemUpXG4gICAgICAgICAgICBqc29uLnNsaWNlID0gdGhpcy5zbGljZS50b0pTT04oKTtcbiAgICAgICAgaWYgKHRoaXMuc3RydWN0dXJlKVxuICAgICAgICAgICAganNvbi5zdHJ1Y3R1cmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAgICAgdHlwZW9mIGpzb24uZ2FwRnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmdhcFRvICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaW5zZXJ0ICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlcGxhY2VBcm91bmRTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKGpzb24uZnJvbSwganNvbi50bywganNvbi5nYXBGcm9tLCBqc29uLmdhcFRvLCBTbGljZS5mcm9tSlNPTihzY2hlbWEsIGpzb24uc2xpY2UpLCBqc29uLmluc2VydCwgISFqc29uLnN0cnVjdHVyZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZXBsYWNlQXJvdW5kXCIsIFJlcGxhY2VBcm91bmRTdGVwKTtcbmZ1bmN0aW9uIGNvbnRlbnRCZXR3ZWVuKGRvYywgZnJvbSwgdG8pIHtcbiAgICBsZXQgJGZyb20gPSBkb2MucmVzb2x2ZShmcm9tKSwgZGlzdCA9IHRvIC0gZnJvbSwgZGVwdGggPSAkZnJvbS5kZXB0aDtcbiAgICB3aGlsZSAoZGlzdCA+IDAgJiYgZGVwdGggPiAwICYmICRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpID09ICRmcm9tLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpIHtcbiAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgZGlzdC0tO1xuICAgIH1cbiAgICBpZiAoZGlzdCA+IDApIHtcbiAgICAgICAgbGV0IG5leHQgPSAkZnJvbS5ub2RlKGRlcHRoKS5tYXliZUNoaWxkKCRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpKTtcbiAgICAgICAgd2hpbGUgKGRpc3QgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dC5pc0xlYWYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dC5maXJzdENoaWxkO1xuICAgICAgICAgICAgZGlzdC0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkTWFyayh0ciwgZnJvbSwgdG8sIG1hcmspIHtcbiAgICBsZXQgcmVtb3ZlZCA9IFtdLCBhZGRlZCA9IFtdO1xuICAgIGxldCByZW1vdmluZywgYWRkaW5nO1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MsIHBhcmVudCkgPT4ge1xuICAgICAgICBpZiAoIW5vZGUuaXNJbmxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBtYXJrcyA9IG5vZGUubWFya3M7XG4gICAgICAgIGlmICghbWFyay5pc0luU2V0KG1hcmtzKSAmJiBwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZShtYXJrLnR5cGUpKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLCBlbmQgPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICBsZXQgbmV3U2V0ID0gbWFyay5hZGRUb1NldChtYXJrcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXJrc1tpXS5pc0luU2V0KG5ld1NldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92aW5nICYmIHJlbW92aW5nLnRvID09IHN0YXJ0ICYmIHJlbW92aW5nLm1hcmsuZXEobWFya3NbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZpbmcudG8gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaChyZW1vdmluZyA9IG5ldyBSZW1vdmVNYXJrU3RlcChzdGFydCwgZW5kLCBtYXJrc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZGRpbmcgJiYgYWRkaW5nLnRvID09IHN0YXJ0KVxuICAgICAgICAgICAgICAgIGFkZGluZy50byA9IGVuZDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhZGRlZC5wdXNoKGFkZGluZyA9IG5ldyBBZGRNYXJrU3RlcChzdGFydCwgZW5kLCBtYXJrKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZW1vdmVkLmZvckVhY2gocyA9PiB0ci5zdGVwKHMpKTtcbiAgICBhZGRlZC5mb3JFYWNoKHMgPT4gdHIuc3RlcChzKSk7XG59XG5mdW5jdGlvbiByZW1vdmVNYXJrKHRyLCBmcm9tLCB0bywgbWFyaykge1xuICAgIGxldCBtYXRjaGVkID0gW10sIHN0ZXAgPSAwO1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKCFub2RlLmlzSW5saW5lKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdGVwKys7XG4gICAgICAgIGxldCB0b1JlbW92ZSA9IG51bGw7XG4gICAgICAgIGlmIChtYXJrIGluc3RhbmNlb2YgTWFya1R5cGUpIHtcbiAgICAgICAgICAgIGxldCBzZXQgPSBub2RlLm1hcmtzLCBmb3VuZDtcbiAgICAgICAgICAgIHdoaWxlIChmb3VuZCA9IG1hcmsuaXNJblNldChzZXQpKSB7XG4gICAgICAgICAgICAgICAgKHRvUmVtb3ZlIHx8ICh0b1JlbW92ZSA9IFtdKSkucHVzaChmb3VuZCk7XG4gICAgICAgICAgICAgICAgc2V0ID0gZm91bmQucmVtb3ZlRnJvbVNldChzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hcmspIHtcbiAgICAgICAgICAgIGlmIChtYXJrLmlzSW5TZXQobm9kZS5tYXJrcykpXG4gICAgICAgICAgICAgICAgdG9SZW1vdmUgPSBbbWFya107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b1JlbW92ZSA9IG5vZGUubWFya3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvUmVtb3ZlICYmIHRvUmVtb3ZlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9SZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSB0b1JlbW92ZVtpXSwgZm91bmQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaGVkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtID0gbWF0Y2hlZFtqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0uc3RlcCA9PSBzdGVwIC0gMSAmJiBzdHlsZS5lcShtYXRjaGVkW2pdLnN0eWxlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kLnRvID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZC5zdGVwID0gc3RlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaCh7IHN0eWxlLCBmcm9tOiBNYXRoLm1heChwb3MsIGZyb20pLCB0bzogZW5kLCBzdGVwIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG1hdGNoZWQuZm9yRWFjaChtID0+IHRyLnN0ZXAobmV3IFJlbW92ZU1hcmtTdGVwKG0uZnJvbSwgbS50bywgbS5zdHlsZSkpKTtcbn1cbmZ1bmN0aW9uIGNsZWFySW5jb21wYXRpYmxlKHRyLCBwb3MsIHBhcmVudFR5cGUsIG1hdGNoID0gcGFyZW50VHlwZS5jb250ZW50TWF0Y2gpIHtcbiAgICBsZXQgbm9kZSA9IHRyLmRvYy5ub2RlQXQocG9zKTtcbiAgICBsZXQgcmVwbFN0ZXBzID0gW10sIGN1ciA9IHBvcyArIDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBub2RlLmNoaWxkKGkpLCBlbmQgPSBjdXIgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgbGV0IGFsbG93ZWQgPSBtYXRjaC5tYXRjaFR5cGUoY2hpbGQudHlwZSk7XG4gICAgICAgIGlmICghYWxsb3dlZCkge1xuICAgICAgICAgICAgcmVwbFN0ZXBzLnB1c2gobmV3IFJlcGxhY2VTdGVwKGN1ciwgZW5kLCBTbGljZS5lbXB0eSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2ggPSBhbGxvd2VkO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZC5tYXJrcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFR5cGUuYWxsb3dzTWFya1R5cGUoY2hpbGQubWFya3Nbal0udHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIHRyLnN0ZXAobmV3IFJlbW92ZU1hcmtTdGVwKGN1ciwgZW5kLCBjaGlsZC5tYXJrc1tqXSkpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmlzVGV4dCAmJiAhcGFyZW50VHlwZS5zcGVjLmNvZGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgbSwgbmV3bGluZSA9IC9cXHI/XFxufFxcci9nLCBzbGljZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobSA9IG5ld2xpbmUuZXhlYyhjaGlsZC50ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNsaWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2UgPSBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShwYXJlbnRUeXBlLnNjaGVtYS50ZXh0KFwiIFwiLCBwYXJlbnRUeXBlLmFsbG93ZWRNYXJrcyhjaGlsZC5tYXJrcykpKSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxTdGVwcy5wdXNoKG5ldyBSZXBsYWNlU3RlcChjdXIgKyBtLmluZGV4LCBjdXIgKyBtLmluZGV4ICsgbVswXS5sZW5ndGgsIHNsaWNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1ciA9IGVuZDtcbiAgICB9XG4gICAgaWYgKCFtYXRjaC52YWxpZEVuZCkge1xuICAgICAgICBsZXQgZmlsbCA9IG1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgICAgICB0ci5yZXBsYWNlKGN1ciwgY3VyLCBuZXcgU2xpY2UoZmlsbCwgMCwgMCkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gcmVwbFN0ZXBzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICB0ci5zdGVwKHJlcGxTdGVwc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNhbkN1dChub2RlLCBzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChzdGFydCA9PSAwIHx8IG5vZGUuY2FuUmVwbGFjZShzdGFydCwgbm9kZS5jaGlsZENvdW50KSkgJiZcbiAgICAgICAgKGVuZCA9PSBub2RlLmNoaWxkQ291bnQgfHwgbm9kZS5jYW5SZXBsYWNlKDAsIGVuZCkpO1xufVxuLyoqXG5UcnkgdG8gZmluZCBhIHRhcmdldCBkZXB0aCB0byB3aGljaCB0aGUgY29udGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2VcbmNhbiBiZSBsaWZ0ZWQuIFdpbGwgbm90IGdvIGFjcm9zc1xuW2lzb2xhdGluZ10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmlzb2xhdGluZykgcGFyZW50IG5vZGVzLlxuKi9cbmZ1bmN0aW9uIGxpZnRUYXJnZXQocmFuZ2UpIHtcbiAgICBsZXQgcGFyZW50ID0gcmFuZ2UucGFyZW50O1xuICAgIGxldCBjb250ZW50ID0gcGFyZW50LmNvbnRlbnQuY3V0QnlJbmRleChyYW5nZS5zdGFydEluZGV4LCByYW5nZS5lbmRJbmRleCk7XG4gICAgZm9yIChsZXQgZGVwdGggPSByYW5nZS5kZXB0aDs7IC0tZGVwdGgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSByYW5nZS4kZnJvbS5ub2RlKGRlcHRoKTtcbiAgICAgICAgbGV0IGluZGV4ID0gcmFuZ2UuJGZyb20uaW5kZXgoZGVwdGgpLCBlbmRJbmRleCA9IHJhbmdlLiR0by5pbmRleEFmdGVyKGRlcHRoKTtcbiAgICAgICAgaWYgKGRlcHRoIDwgcmFuZ2UuZGVwdGggJiYgbm9kZS5jYW5SZXBsYWNlKGluZGV4LCBlbmRJbmRleCwgY29udGVudCkpXG4gICAgICAgICAgICByZXR1cm4gZGVwdGg7XG4gICAgICAgIGlmIChkZXB0aCA9PSAwIHx8IG5vZGUudHlwZS5zcGVjLmlzb2xhdGluZyB8fCAhY2FuQ3V0KG5vZGUsIGluZGV4LCBlbmRJbmRleCkpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBsaWZ0KHRyLCByYW5nZSwgdGFyZ2V0KSB7XG4gICAgbGV0IHsgJGZyb20sICR0bywgZGVwdGggfSA9IHJhbmdlO1xuICAgIGxldCBnYXBTdGFydCA9ICRmcm9tLmJlZm9yZShkZXB0aCArIDEpLCBnYXBFbmQgPSAkdG8uYWZ0ZXIoZGVwdGggKyAxKTtcbiAgICBsZXQgc3RhcnQgPSBnYXBTdGFydCwgZW5kID0gZ2FwRW5kO1xuICAgIGxldCBiZWZvcmUgPSBGcmFnbWVudC5lbXB0eSwgb3BlblN0YXJ0ID0gMDtcbiAgICBmb3IgKGxldCBkID0gZGVwdGgsIHNwbGl0dGluZyA9IGZhbHNlOyBkID4gdGFyZ2V0OyBkLS0pXG4gICAgICAgIGlmIChzcGxpdHRpbmcgfHwgJGZyb20uaW5kZXgoZCkgPiAwKSB7XG4gICAgICAgICAgICBzcGxpdHRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYmVmb3JlID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGQpLmNvcHkoYmVmb3JlKSk7XG4gICAgICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgIH1cbiAgICBsZXQgYWZ0ZXIgPSBGcmFnbWVudC5lbXB0eSwgb3BlbkVuZCA9IDA7XG4gICAgZm9yIChsZXQgZCA9IGRlcHRoLCBzcGxpdHRpbmcgPSBmYWxzZTsgZCA+IHRhcmdldDsgZC0tKVxuICAgICAgICBpZiAoc3BsaXR0aW5nIHx8ICR0by5hZnRlcihkICsgMSkgPCAkdG8uZW5kKGQpKSB7XG4gICAgICAgICAgICBzcGxpdHRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYWZ0ZXIgPSBGcmFnbWVudC5mcm9tKCR0by5ub2RlKGQpLmNvcHkoYWZ0ZXIpKTtcbiAgICAgICAgICAgIG9wZW5FbmQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICB9XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQsIGVuZCwgZ2FwU3RhcnQsIGdhcEVuZCwgbmV3IFNsaWNlKGJlZm9yZS5hcHBlbmQoYWZ0ZXIpLCBvcGVuU3RhcnQsIG9wZW5FbmQpLCBiZWZvcmUuc2l6ZSAtIG9wZW5TdGFydCwgdHJ1ZSkpO1xufVxuLyoqXG5UcnkgdG8gZmluZCBhIHZhbGlkIHdheSB0byB3cmFwIHRoZSBjb250ZW50IGluIHRoZSBnaXZlbiByYW5nZSBpbiBhXG5ub2RlIG9mIHRoZSBnaXZlbiB0eXBlLiBNYXkgaW50cm9kdWNlIGV4dHJhIG5vZGVzIGFyb3VuZCBhbmQgaW5zaWRlXG50aGUgd3JhcHBlciBub2RlLCBpZiBuZWNlc3NhcnkuIFJldHVybnMgbnVsbCBpZiBubyB2YWxpZCB3cmFwcGluZ1xuY291bGQgYmUgZm91bmQuIFdoZW4gYGlubmVyUmFuZ2VgIGlzIGdpdmVuLCB0aGF0IHJhbmdlJ3MgY29udGVudCBpc1xudXNlZCBhcyB0aGUgY29udGVudCB0byBmaXQgaW50byB0aGUgd3JhcHBpbmcsIGluc3RlYWQgb2YgdGhlXG5jb250ZW50IG9mIGByYW5nZWAuXG4qL1xuZnVuY3Rpb24gZmluZFdyYXBwaW5nKHJhbmdlLCBub2RlVHlwZSwgYXR0cnMgPSBudWxsLCBpbm5lclJhbmdlID0gcmFuZ2UpIHtcbiAgICBsZXQgYXJvdW5kID0gZmluZFdyYXBwaW5nT3V0c2lkZShyYW5nZSwgbm9kZVR5cGUpO1xuICAgIGxldCBpbm5lciA9IGFyb3VuZCAmJiBmaW5kV3JhcHBpbmdJbnNpZGUoaW5uZXJSYW5nZSwgbm9kZVR5cGUpO1xuICAgIGlmICghaW5uZXIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBhcm91bmQubWFwKHdpdGhBdHRycylcbiAgICAgICAgLmNvbmNhdCh7IHR5cGU6IG5vZGVUeXBlLCBhdHRycyB9KS5jb25jYXQoaW5uZXIubWFwKHdpdGhBdHRycykpO1xufVxuZnVuY3Rpb24gd2l0aEF0dHJzKHR5cGUpIHsgcmV0dXJuIHsgdHlwZSwgYXR0cnM6IG51bGwgfTsgfVxuZnVuY3Rpb24gZmluZFdyYXBwaW5nT3V0c2lkZShyYW5nZSwgdHlwZSkge1xuICAgIGxldCB7IHBhcmVudCwgc3RhcnRJbmRleCwgZW5kSW5kZXggfSA9IHJhbmdlO1xuICAgIGxldCBhcm91bmQgPSBwYXJlbnQuY29udGVudE1hdGNoQXQoc3RhcnRJbmRleCkuZmluZFdyYXBwaW5nKHR5cGUpO1xuICAgIGlmICghYXJvdW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgb3V0ZXIgPSBhcm91bmQubGVuZ3RoID8gYXJvdW5kWzBdIDogdHlwZTtcbiAgICByZXR1cm4gcGFyZW50LmNhblJlcGxhY2VXaXRoKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBvdXRlcikgPyBhcm91bmQgOiBudWxsO1xufVxuZnVuY3Rpb24gZmluZFdyYXBwaW5nSW5zaWRlKHJhbmdlLCB0eXBlKSB7XG4gICAgbGV0IHsgcGFyZW50LCBzdGFydEluZGV4LCBlbmRJbmRleCB9ID0gcmFuZ2U7XG4gICAgbGV0IGlubmVyID0gcGFyZW50LmNoaWxkKHN0YXJ0SW5kZXgpO1xuICAgIGxldCBpbnNpZGUgPSB0eXBlLmNvbnRlbnRNYXRjaC5maW5kV3JhcHBpbmcoaW5uZXIudHlwZSk7XG4gICAgaWYgKCFpbnNpZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBsYXN0VHlwZSA9IGluc2lkZS5sZW5ndGggPyBpbnNpZGVbaW5zaWRlLmxlbmd0aCAtIDFdIDogdHlwZTtcbiAgICBsZXQgaW5uZXJNYXRjaCA9IGxhc3RUeXBlLmNvbnRlbnRNYXRjaDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaW5uZXJNYXRjaCAmJiBpIDwgZW5kSW5kZXg7IGkrKylcbiAgICAgICAgaW5uZXJNYXRjaCA9IGlubmVyTWF0Y2gubWF0Y2hUeXBlKHBhcmVudC5jaGlsZChpKS50eXBlKTtcbiAgICBpZiAoIWlubmVyTWF0Y2ggfHwgIWlubmVyTWF0Y2gudmFsaWRFbmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBpbnNpZGU7XG59XG5mdW5jdGlvbiB3cmFwKHRyLCByYW5nZSwgd3JhcHBlcnMpIHtcbiAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGZvciAobGV0IGkgPSB3cmFwcGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB3cmFwcGVyc1tpXS50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCB8fCAhbWF0Y2gudmFsaWRFbmQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJXcmFwcGVyIHR5cGUgZ2l2ZW4gdG8gVHJhbnNmb3JtLndyYXAgZG9lcyBub3QgZm9ybSB2YWxpZCBjb250ZW50IG9mIGl0cyBwYXJlbnQgd3JhcHBlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh3cmFwcGVyc1tpXS50eXBlLmNyZWF0ZSh3cmFwcGVyc1tpXS5hdHRycywgY29udGVudCkpO1xuICAgIH1cbiAgICBsZXQgc3RhcnQgPSByYW5nZS5zdGFydCwgZW5kID0gcmFuZ2UuZW5kO1xuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0LCBlbmQsIHN0YXJ0LCBlbmQsIG5ldyBTbGljZShjb250ZW50LCAwLCAwKSwgd3JhcHBlcnMubGVuZ3RoLCB0cnVlKSk7XG59XG5mdW5jdGlvbiBzZXRCbG9ja1R5cGUodHIsIGZyb20sIHRvLCB0eXBlLCBhdHRycykge1xuICAgIGlmICghdHlwZS5pc1RleHRibG9jaylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUeXBlIGdpdmVuIHRvIHNldEJsb2NrVHlwZSBzaG91bGQgYmUgYSB0ZXh0YmxvY2tcIik7XG4gICAgbGV0IG1hcEZyb20gPSB0ci5zdGVwcy5sZW5ndGg7XG4gICAgdHIuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBpZiAobm9kZS5pc1RleHRibG9jayAmJiAhbm9kZS5oYXNNYXJrdXAodHlwZSwgYXR0cnMpICYmIGNhbkNoYW5nZVR5cGUodHIuZG9jLCB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MpLCB0eXBlKSkge1xuICAgICAgICAgICAgLy8gRW5zdXJlIGFsbCBtYXJrdXAgdGhhdCBpc24ndCBhbGxvd2VkIGluIHRoZSBuZXcgbm9kZSB0eXBlIGlzIGNsZWFyZWRcbiAgICAgICAgICAgIHRyLmNsZWFySW5jb21wYXRpYmxlKHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcywgMSksIHR5cGUpO1xuICAgICAgICAgICAgbGV0IG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgICAgICAgICAgbGV0IHN0YXJ0TSA9IG1hcHBpbmcubWFwKHBvcywgMSksIGVuZE0gPSBtYXBwaW5nLm1hcChwb3MgKyBub2RlLm5vZGVTaXplLCAxKTtcbiAgICAgICAgICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0TSwgZW5kTSwgc3RhcnRNICsgMSwgZW5kTSAtIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBub2RlLm1hcmtzKSksIDAsIDApLCAxLCB0cnVlKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNhbkNoYW5nZVR5cGUoZG9jLCBwb3MsIHR5cGUpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyksIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICAgIHJldHVybiAkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXggKyAxLCB0eXBlKTtcbn1cbi8qKlxuQ2hhbmdlIHRoZSB0eXBlLCBhdHRyaWJ1dGVzLCBhbmQvb3IgbWFya3Mgb2YgdGhlIG5vZGUgYXQgYHBvc2AuXG5XaGVuIGB0eXBlYCBpc24ndCBnaXZlbiwgdGhlIGV4aXN0aW5nIG5vZGUgdHlwZSBpcyBwcmVzZXJ2ZWQsXG4qL1xuZnVuY3Rpb24gc2V0Tm9kZU1hcmt1cCh0ciwgcG9zLCB0eXBlLCBhdHRycywgbWFya3MpIHtcbiAgICBsZXQgbm9kZSA9IHRyLmRvYy5ub2RlQXQocG9zKTtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gbm9kZSBhdCBnaXZlbiBwb3NpdGlvblwiKTtcbiAgICBpZiAoIXR5cGUpXG4gICAgICAgIHR5cGUgPSBub2RlLnR5cGU7XG4gICAgbGV0IG5ld05vZGUgPSB0eXBlLmNyZWF0ZShhdHRycywgbnVsbCwgbWFya3MgfHwgbm9kZS5tYXJrcyk7XG4gICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICByZXR1cm4gdHIucmVwbGFjZVdpdGgocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCBuZXdOb2RlKTtcbiAgICBpZiAoIXR5cGUudmFsaWRDb250ZW50KG5vZGUuY29udGVudCkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBjb250ZW50IGZvciBub2RlIHR5cGUgXCIgKyB0eXBlLm5hbWUpO1xuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwgcG9zICsgMSwgcG9zICsgbm9kZS5ub2RlU2l6ZSAtIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5ld05vZGUpLCAwLCAwKSwgMSwgdHJ1ZSkpO1xufVxuLyoqXG5DaGVjayB3aGV0aGVyIHNwbGl0dGluZyBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgYWxsb3dlZC5cbiovXG5mdW5jdGlvbiBjYW5TcGxpdChkb2MsIHBvcywgZGVwdGggPSAxLCB0eXBlc0FmdGVyKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLCBiYXNlID0gJHBvcy5kZXB0aCAtIGRlcHRoO1xuICAgIGxldCBpbm5lclR5cGUgPSAodHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW3R5cGVzQWZ0ZXIubGVuZ3RoIC0gMV0pIHx8ICRwb3MucGFyZW50O1xuICAgIGlmIChiYXNlIDwgMCB8fCAkcG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nIHx8XG4gICAgICAgICEkcG9zLnBhcmVudC5jYW5SZXBsYWNlKCRwb3MuaW5kZXgoKSwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudCkgfHxcbiAgICAgICAgIWlubmVyVHlwZS50eXBlLnZhbGlkQ29udGVudCgkcG9zLnBhcmVudC5jb250ZW50LmN1dEJ5SW5kZXgoJHBvcy5pbmRleCgpLCAkcG9zLnBhcmVudC5jaGlsZENvdW50KSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCAtIDEsIGkgPSBkZXB0aCAtIDI7IGQgPiBiYXNlOyBkLS0sIGktLSkge1xuICAgICAgICBsZXQgbm9kZSA9ICRwb3Mubm9kZShkKSwgaW5kZXggPSAkcG9zLmluZGV4KGQpO1xuICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgcmVzdCA9IG5vZGUuY29udGVudC5jdXRCeUluZGV4KGluZGV4LCBub2RlLmNoaWxkQ291bnQpO1xuICAgICAgICBsZXQgb3ZlcnJpZGVDaGlsZCA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlcltpICsgMV07XG4gICAgICAgIGlmIChvdmVycmlkZUNoaWxkKVxuICAgICAgICAgICAgcmVzdCA9IHJlc3QucmVwbGFjZUNoaWxkKDAsIG92ZXJyaWRlQ2hpbGQudHlwZS5jcmVhdGUob3ZlcnJpZGVDaGlsZC5hdHRycykpO1xuICAgICAgICBsZXQgYWZ0ZXIgPSAodHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW2ldKSB8fCBub2RlO1xuICAgICAgICBpZiAoIW5vZGUuY2FuUmVwbGFjZShpbmRleCArIDEsIG5vZGUuY2hpbGRDb3VudCkgfHwgIWFmdGVyLnR5cGUudmFsaWRDb250ZW50KHJlc3QpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoYmFzZSk7XG4gICAgbGV0IGJhc2VUeXBlID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyWzBdO1xuICAgIHJldHVybiAkcG9zLm5vZGUoYmFzZSkuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBiYXNlVHlwZSA/IGJhc2VUeXBlLnR5cGUgOiAkcG9zLm5vZGUoYmFzZSArIDEpLnR5cGUpO1xufVxuZnVuY3Rpb24gc3BsaXQodHIsIHBvcywgZGVwdGggPSAxLCB0eXBlc0FmdGVyKSB7XG4gICAgbGV0ICRwb3MgPSB0ci5kb2MucmVzb2x2ZShwb3MpLCBiZWZvcmUgPSBGcmFnbWVudC5lbXB0eSwgYWZ0ZXIgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCwgZSA9ICRwb3MuZGVwdGggLSBkZXB0aCwgaSA9IGRlcHRoIC0gMTsgZCA+IGU7IGQtLSwgaS0tKSB7XG4gICAgICAgIGJlZm9yZSA9IEZyYWdtZW50LmZyb20oJHBvcy5ub2RlKGQpLmNvcHkoYmVmb3JlKSk7XG4gICAgICAgIGxldCB0eXBlQWZ0ZXIgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbaV07XG4gICAgICAgIGFmdGVyID0gRnJhZ21lbnQuZnJvbSh0eXBlQWZ0ZXIgPyB0eXBlQWZ0ZXIudHlwZS5jcmVhdGUodHlwZUFmdGVyLmF0dHJzLCBhZnRlcikgOiAkcG9zLm5vZGUoZCkuY29weShhZnRlcikpO1xuICAgIH1cbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlU3RlcChwb3MsIHBvcywgbmV3IFNsaWNlKGJlZm9yZS5hcHBlbmQoYWZ0ZXIpLCBkZXB0aCwgZGVwdGgpLCB0cnVlKSk7XG59XG4vKipcblRlc3Qgd2hldGhlciB0aGUgYmxvY2tzIGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBwb3NpdGlvbiBjYW4gYmVcbmpvaW5lZC5cbiovXG5mdW5jdGlvbiBjYW5Kb2luKGRvYywgcG9zKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICByZXR1cm4gam9pbmFibGUoJHBvcy5ub2RlQmVmb3JlLCAkcG9zLm5vZGVBZnRlcikgJiZcbiAgICAgICAgJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKTtcbn1cbmZ1bmN0aW9uIGpvaW5hYmxlKGEsIGIpIHtcbiAgICByZXR1cm4gISEoYSAmJiBiICYmICFhLmlzTGVhZiAmJiBhLmNhbkFwcGVuZChiKSk7XG59XG4vKipcbkZpbmQgYW4gYW5jZXN0b3Igb2YgdGhlIGdpdmVuIHBvc2l0aW9uIHRoYXQgY2FuIGJlIGpvaW5lZCB0byB0aGVcbmJsb2NrIGJlZm9yZSAob3IgYWZ0ZXIgaWYgYGRpcmAgaXMgcG9zaXRpdmUpLiBSZXR1cm5zIHRoZSBqb2luYWJsZVxucG9pbnQsIGlmIGFueS5cbiovXG5mdW5jdGlvbiBqb2luUG9pbnQoZG9jLCBwb3MsIGRpciA9IC0xKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOzsgZC0tKSB7XG4gICAgICAgIGxldCBiZWZvcmUsIGFmdGVyLCBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgICAgIGlmIChkID09ICRwb3MuZGVwdGgpIHtcbiAgICAgICAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZTtcbiAgICAgICAgICAgIGFmdGVyID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgYmVmb3JlID0gJHBvcy5ub2RlKGQgKyAxKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBhZnRlciA9ICRwb3Mubm9kZShkKS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZShkKS5tYXliZUNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgICAgICBhZnRlciA9ICRwb3Mubm9kZShkICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlZm9yZSAmJiAhYmVmb3JlLmlzVGV4dGJsb2NrICYmIGpvaW5hYmxlKGJlZm9yZSwgYWZ0ZXIpICYmXG4gICAgICAgICAgICAkcG9zLm5vZGUoZCkuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKSlcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIGlmIChkID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgcG9zID0gZGlyIDwgMCA/ICRwb3MuYmVmb3JlKGQpIDogJHBvcy5hZnRlcihkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBqb2luKHRyLCBwb3MsIGRlcHRoKSB7XG4gICAgbGV0IHN0ZXAgPSBuZXcgUmVwbGFjZVN0ZXAocG9zIC0gZGVwdGgsIHBvcyArIGRlcHRoLCBTbGljZS5lbXB0eSwgdHJ1ZSk7XG4gICAgdHIuc3RlcChzdGVwKTtcbn1cbi8qKlxuVHJ5IHRvIGZpbmQgYSBwb2ludCB3aGVyZSBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUgY2FuIGJlIGluc2VydGVkXG5uZWFyIGBwb3NgLCBieSBzZWFyY2hpbmcgdXAgdGhlIG5vZGUgaGllcmFyY2h5IHdoZW4gYHBvc2AgaXRzZWxmXG5pc24ndCBhIHZhbGlkIHBsYWNlIGJ1dCBpcyBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGEgbm9kZS4gUmV0dXJuXG5udWxsIGlmIG5vIHBvc2l0aW9uIHdhcyBmb3VuZC5cbiovXG5mdW5jdGlvbiBpbnNlcnRQb2ludChkb2MsIHBvcywgbm9kZVR5cGUpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKCRwb3MuaW5kZXgoKSwgJHBvcy5pbmRleCgpLCBub2RlVHlwZSkpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgaWYgKCRwb3MucGFyZW50T2Zmc2V0ID09IDApXG4gICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgICAgICAgICBpZiAoJHBvcy5ub2RlKGQpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgbm9kZVR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmJlZm9yZShkICsgMSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgaWYgKCRwb3MucGFyZW50T2Zmc2V0ID09ICRwb3MucGFyZW50LmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleEFmdGVyKGQpO1xuICAgICAgICAgICAgaWYgKCRwb3Mubm9kZShkKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIG5vZGVUeXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5hZnRlcihkICsgMSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAkcG9zLm5vZGUoZCkuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5GaW5kcyBhIHBvc2l0aW9uIGF0IG9yIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24gd2hlcmUgdGhlIGdpdmVuXG5zbGljZSBjYW4gYmUgaW5zZXJ0ZWQuIFdpbGwgbG9vayBhdCBwYXJlbnQgbm9kZXMnIG5lYXJlc3QgYm91bmRhcnlcbmFuZCB0cnkgdGhlcmUsIGV2ZW4gaWYgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIHdhc24ndCBkaXJlY3RseSBhdCB0aGVcbnN0YXJ0IG9yIGVuZCBvZiB0aGF0IG5vZGUuIFJldHVybnMgbnVsbCB3aGVuIG5vIHBvc2l0aW9uIHdhcyBmb3VuZC5cbiovXG5mdW5jdGlvbiBkcm9wUG9pbnQoZG9jLCBwb3MsIHNsaWNlKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmICghc2xpY2UuY29udGVudC5zaXplKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGxldCBjb250ZW50ID0gc2xpY2UuY29udGVudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWNlLm9wZW5TdGFydDsgaSsrKVxuICAgICAgICBjb250ZW50ID0gY29udGVudC5maXJzdENoaWxkLmNvbnRlbnQ7XG4gICAgZm9yIChsZXQgcGFzcyA9IDE7IHBhc3MgPD0gKHNsaWNlLm9wZW5TdGFydCA9PSAwICYmIHNsaWNlLnNpemUgPyAyIDogMSk7IHBhc3MrKykge1xuICAgICAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGxldCBiaWFzID0gZCA9PSAkcG9zLmRlcHRoID8gMCA6ICRwb3MucG9zIDw9ICgkcG9zLnN0YXJ0KGQgKyAxKSArICRwb3MuZW5kKGQgKyAxKSkgLyAyID8gLTEgOiAxO1xuICAgICAgICAgICAgbGV0IGluc2VydFBvcyA9ICRwb3MuaW5kZXgoZCkgKyAoYmlhcyA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gJHBvcy5ub2RlKGQpLCBmaXRzID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocGFzcyA9PSAxKSB7XG4gICAgICAgICAgICAgICAgZml0cyA9IHBhcmVudC5jYW5SZXBsYWNlKGluc2VydFBvcywgaW5zZXJ0UG9zLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB3cmFwcGluZyA9IHBhcmVudC5jb250ZW50TWF0Y2hBdChpbnNlcnRQb3MpLmZpbmRXcmFwcGluZyhjb250ZW50LmZpcnN0Q2hpbGQudHlwZSk7XG4gICAgICAgICAgICAgICAgZml0cyA9IHdyYXBwaW5nICYmIHBhcmVudC5jYW5SZXBsYWNlV2l0aChpbnNlcnRQb3MsIGluc2VydFBvcywgd3JhcHBpbmdbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpdHMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpYXMgPT0gMCA/ICRwb3MucG9zIDogYmlhcyA8IDAgPyAkcG9zLmJlZm9yZShkICsgMSkgOiAkcG9zLmFmdGVyKGQgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG5cdTIwMThGaXRcdTIwMTkgYSBzbGljZSBpbnRvIGEgZ2l2ZW4gcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LCBwcm9kdWNpbmcgYVxuW3N0ZXBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcCkgdGhhdCBpbnNlcnRzIGl0LiBXaWxsIHJldHVybiBudWxsIGlmXG50aGVyZSdzIG5vIG1lYW5pbmdmdWwgd2F5IHRvIGluc2VydCB0aGUgc2xpY2UgaGVyZSwgb3IgaW5zZXJ0aW5nIGl0XG53b3VsZCBiZSBhIG5vLW9wIChhbiBlbXB0eSBzbGljZSBvdmVyIGFuIGVtcHR5IHJhbmdlKS5cbiovXG5mdW5jdGlvbiByZXBsYWNlU3RlcChkb2MsIGZyb20sIHRvID0gZnJvbSwgc2xpY2UgPSBTbGljZS5lbXB0eSkge1xuICAgIGlmIChmcm9tID09IHRvICYmICFzbGljZS5zaXplKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgJGZyb20gPSBkb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gZG9jLnJlc29sdmUodG8pO1xuICAgIC8vIE9wdGltaXphdGlvbiAtLSBhdm9pZCB3b3JrIGlmIGl0J3Mgb2J2aW91cyB0aGF0IGl0J3Mgbm90IG5lZWRlZC5cbiAgICBpZiAoZml0c1RyaXZpYWxseSgkZnJvbSwgJHRvLCBzbGljZSkpXG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoZnJvbSwgdG8sIHNsaWNlKTtcbiAgICByZXR1cm4gbmV3IEZpdHRlcigkZnJvbSwgJHRvLCBzbGljZSkuZml0KCk7XG59XG5mdW5jdGlvbiBmaXRzVHJpdmlhbGx5KCRmcm9tLCAkdG8sIHNsaWNlKSB7XG4gICAgcmV0dXJuICFzbGljZS5vcGVuU3RhcnQgJiYgIXNsaWNlLm9wZW5FbmQgJiYgJGZyb20uc3RhcnQoKSA9PSAkdG8uc3RhcnQoKSAmJlxuICAgICAgICAkZnJvbS5wYXJlbnQuY2FuUmVwbGFjZSgkZnJvbS5pbmRleCgpLCAkdG8uaW5kZXgoKSwgc2xpY2UuY29udGVudCk7XG59XG4vLyBBbGdvcml0aG0gZm9yICdwbGFjaW5nJyB0aGUgZWxlbWVudHMgb2YgYSBzbGljZSBpbnRvIGEgZ2FwOlxuLy9cbi8vIFdlIGNvbnNpZGVyIHRoZSBjb250ZW50IG9mIGVhY2ggbm9kZSB0aGF0IGlzIG9wZW4gdG8gdGhlIGxlZnQgdG8gYmVcbi8vIGluZGVwZW5kZW50bHkgcGxhY2VhYmxlLiBJLmUuIGluIDxwKFwiZm9vXCIpLCBwKFwiYmFyXCIpPiwgd2hlbiB0aGVcbi8vIHBhcmFncmFwaCBvbiB0aGUgbGVmdCBpcyBvcGVuLCBcImZvb1wiIGNhbiBiZSBwbGFjZWQgKHNvbWV3aGVyZSBvblxuLy8gdGhlIGxlZnQgc2lkZSBvZiB0aGUgcmVwbGFjZW1lbnQgZ2FwKSBpbmRlcGVuZGVudGx5IGZyb20gcChcImJhclwiKS5cbi8vXG4vLyBUaGlzIGNsYXNzIHRyYWNrcyB0aGUgc3RhdGUgb2YgdGhlIHBsYWNlbWVudCBwcm9ncmVzcyBpbiB0aGVcbi8vIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuLy9cbi8vICAtIGBmcm9udGllcmAgaG9sZHMgYSBzdGFjayBvZiBge3R5cGUsIG1hdGNofWAgb2JqZWN0cyB0aGF0XG4vLyAgICByZXByZXNlbnQgdGhlIG9wZW4gc2lkZSBvZiB0aGUgcmVwbGFjZW1lbnQuIEl0IHN0YXJ0cyBhdFxuLy8gICAgYCRmcm9tYCwgdGhlbiBtb3ZlcyBmb3J3YXJkIGFzIGNvbnRlbnQgaXMgcGxhY2VkLCBhbmQgaXMgZmluYWxseVxuLy8gICAgcmVjb25jaWxlZCB3aXRoIGAkdG9gLlxuLy9cbi8vICAtIGB1bnBsYWNlZGAgaXMgYSBzbGljZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvbnRlbnQgdGhhdCBoYXNuJ3Rcbi8vICAgIGJlZW4gcGxhY2VkIHlldC5cbi8vXG4vLyAgLSBgcGxhY2VkYCBpcyBhIGZyYWdtZW50IG9mIHBsYWNlZCBjb250ZW50LiBJdHMgb3Blbi1zdGFydCB2YWx1ZVxuLy8gICAgaXMgaW1wbGljaXQgaW4gYCRmcm9tYCwgYW5kIGl0cyBvcGVuLWVuZCB2YWx1ZSBpbiBgZnJvbnRpZXJgLlxuY2xhc3MgRml0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigkZnJvbSwgJHRvLCB1bnBsYWNlZCkge1xuICAgICAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgICAgIHRoaXMuJHRvID0gJHRvO1xuICAgICAgICB0aGlzLnVucGxhY2VkID0gdW5wbGFjZWQ7XG4gICAgICAgIHRoaXMuZnJvbnRpZXIgPSBbXTtcbiAgICAgICAgdGhpcy5wbGFjZWQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gJGZyb20uZGVwdGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSAkZnJvbS5ub2RlKGkpO1xuICAgICAgICAgICAgdGhpcy5mcm9udGllci5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgICAgICAgICAgbWF0Y2g6IG5vZGUuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcihpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAkZnJvbS5kZXB0aDsgaSA+IDA7IGktLSlcbiAgICAgICAgICAgIHRoaXMucGxhY2VkID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGkpLmNvcHkodGhpcy5wbGFjZWQpKTtcbiAgICB9XG4gICAgZ2V0IGRlcHRoKCkgeyByZXR1cm4gdGhpcy5mcm9udGllci5sZW5ndGggLSAxOyB9XG4gICAgZml0KCkge1xuICAgICAgICAvLyBBcyBsb25nIGFzIHRoZXJlJ3MgdW5wbGFjZWQgY29udGVudCwgdHJ5IHRvIHBsYWNlIHNvbWUgb2YgaXQuXG4gICAgICAgIC8vIElmIHRoYXQgZmFpbHMsIGVpdGhlciBpbmNyZWFzZSB0aGUgb3BlbiBzY29yZSBvZiB0aGUgdW5wbGFjZWRcbiAgICAgICAgLy8gc2xpY2UsIG9yIGRyb3Agbm9kZXMgZnJvbSBpdCwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgICAgICB3aGlsZSAodGhpcy51bnBsYWNlZC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgZml0ID0gdGhpcy5maW5kRml0dGFibGUoKTtcbiAgICAgICAgICAgIGlmIChmaXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wbGFjZU5vZGVzKGZpdCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuTW9yZSgpIHx8IHRoaXMuZHJvcE5vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZXJlJ3MgaW5saW5lIGNvbnRlbnQgZGlyZWN0bHkgYWZ0ZXIgdGhlIGZyb250aWVyIF9hbmRfXG4gICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIGB0aGlzLiR0b2AsIHdlIG11c3QgZ2VuZXJhdGUgYSBgUmVwbGFjZUFyb3VuZGBcbiAgICAgICAgLy8gc3RlcCB0aGF0IHB1bGxzIHRoYXQgY29udGVudCBpbnRvIHRoZSBub2RlIGFmdGVyIHRoZSBmcm9udGllci5cbiAgICAgICAgLy8gVGhhdCBtZWFucyB0aGUgZml0dGluZyBtdXN0IGJlIGRvbmUgdG8gdGhlIGVuZCBvZiB0aGUgdGV4dGJsb2NrXG4gICAgICAgIC8vIG5vZGUgYWZ0ZXIgYHRoaXMuJHRvYCwgbm90IGB0aGlzLiR0b2AgaXRzZWxmLlxuICAgICAgICBsZXQgbW92ZUlubGluZSA9IHRoaXMubXVzdE1vdmVJbmxpbmUoKSwgcGxhY2VkU2l6ZSA9IHRoaXMucGxhY2VkLnNpemUgLSB0aGlzLmRlcHRoIC0gdGhpcy4kZnJvbS5kZXB0aDtcbiAgICAgICAgbGV0ICRmcm9tID0gdGhpcy4kZnJvbSwgJHRvID0gdGhpcy5jbG9zZShtb3ZlSW5saW5lIDwgMCA/IHRoaXMuJHRvIDogJGZyb20uZG9jLnJlc29sdmUobW92ZUlubGluZSkpO1xuICAgICAgICBpZiAoISR0bylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvLyBJZiBjbG9zaW5nIHRvIGAkdG9gIHN1Y2NlZWRlZCwgY3JlYXRlIGEgc3RlcFxuICAgICAgICBsZXQgY29udGVudCA9IHRoaXMucGxhY2VkLCBvcGVuU3RhcnQgPSAkZnJvbS5kZXB0aCwgb3BlbkVuZCA9ICR0by5kZXB0aDtcbiAgICAgICAgd2hpbGUgKG9wZW5TdGFydCAmJiBvcGVuRW5kICYmIGNvbnRlbnQuY2hpbGRDb3VudCA9PSAxKSB7IC8vIE5vcm1hbGl6ZSBieSBkcm9wcGluZyBvcGVuIHBhcmVudCBub2Rlc1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgICAgICAgICAgb3BlblN0YXJ0LS07XG4gICAgICAgICAgICBvcGVuRW5kLS07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIGlmIChtb3ZlSW5saW5lID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKCRmcm9tLnBvcywgbW92ZUlubGluZSwgdGhpcy4kdG8ucG9zLCB0aGlzLiR0by5lbmQoKSwgc2xpY2UsIHBsYWNlZFNpemUpO1xuICAgICAgICBpZiAoc2xpY2Uuc2l6ZSB8fCAkZnJvbS5wb3MgIT0gdGhpcy4kdG8ucG9zKSAvLyBEb24ndCBnZW5lcmF0ZSBuby1vcCBzdGVwc1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcCgkZnJvbS5wb3MsICR0by5wb3MsIHNsaWNlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEZpbmQgYSBwb3NpdGlvbiBvbiB0aGUgc3RhcnQgc3BpbmUgb2YgYHRoaXMudW5wbGFjZWRgIHRoYXQgaGFzXG4gICAgLy8gY29udGVudCB0aGF0IGNhbiBiZSBtb3ZlZCBzb21ld2hlcmUgb24gdGhlIGZyb250aWVyLiBSZXR1cm5zIHR3b1xuICAgIC8vIGRlcHRocywgb25lIGZvciB0aGUgc2xpY2UgYW5kIG9uZSBmb3IgdGhlIGZyb250aWVyLlxuICAgIGZpbmRGaXR0YWJsZSgpIHtcbiAgICAgICAgbGV0IHN0YXJ0RGVwdGggPSB0aGlzLnVucGxhY2VkLm9wZW5TdGFydDtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gdGhpcy51bnBsYWNlZC5jb250ZW50LCBkID0gMCwgb3BlbkVuZCA9IHRoaXMudW5wbGFjZWQub3BlbkVuZDsgZCA8IHN0YXJ0RGVwdGg7IGQrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBjdXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChjdXIuY2hpbGRDb3VudCA+IDEpXG4gICAgICAgICAgICAgICAgb3BlbkVuZCA9IDA7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nICYmIG9wZW5FbmQgPD0gZCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RGVwdGggPSBkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gbm9kZS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgdHJ5IHdyYXBwaW5nIG5vZGVzIChwYXNzIDIpIGFmdGVyIGZpbmRpbmcgYSBwbGFjZSB3aXRob3V0XG4gICAgICAgIC8vIHdyYXBwaW5nIGZhaWxlZC5cbiAgICAgICAgZm9yIChsZXQgcGFzcyA9IDE7IHBhc3MgPD0gMjsgcGFzcysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzbGljZURlcHRoID0gcGFzcyA9PSAxID8gc3RhcnREZXB0aCA6IHRoaXMudW5wbGFjZWQub3BlblN0YXJ0OyBzbGljZURlcHRoID49IDA7IHNsaWNlRGVwdGgtLSkge1xuICAgICAgICAgICAgICAgIGxldCBmcmFnbWVudCwgcGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc2xpY2VEZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBjb250ZW50QXQodGhpcy51bnBsYWNlZC5jb250ZW50LCBzbGljZURlcHRoIC0gMSkuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBwYXJlbnQuY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy51bnBsYWNlZC5jb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGZyb250aWVyRGVwdGggPSB0aGlzLmRlcHRoOyBmcm9udGllckRlcHRoID49IDA7IGZyb250aWVyRGVwdGgtLSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBtYXRjaCB9ID0gdGhpcy5mcm9udGllcltmcm9udGllckRlcHRoXSwgd3JhcCwgaW5qZWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gcGFzcyAxLCBpZiB0aGUgbmV4dCBub2RlIG1hdGNoZXMsIG9yIHRoZXJlIGlzIG5vIG5leHRcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9kZSBidXQgdGhlIHBhcmVudHMgbG9vayBjb21wYXRpYmxlLCB3ZSd2ZSBmb3VuZCBhXG4gICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFzcyA9PSAxICYmIChmaXJzdCA/IG1hdGNoLm1hdGNoVHlwZShmaXJzdC50eXBlKSB8fCAoaW5qZWN0ID0gbWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5mcm9tKGZpcnN0KSwgZmFsc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwYXJlbnQgJiYgdHlwZS5jb21wYXRpYmxlQ29udGVudChwYXJlbnQudHlwZSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc2xpY2VEZXB0aCwgZnJvbnRpZXJEZXB0aCwgcGFyZW50LCBpbmplY3QgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gcGFzcyAyLCBsb29rIGZvciBhIHNldCBvZiB3cmFwcGluZyBub2RlcyB0aGF0IG1ha2VcbiAgICAgICAgICAgICAgICAgICAgLy8gYGZpcnN0YCBmaXQgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFzcyA9PSAyICYmIGZpcnN0ICYmICh3cmFwID0gbWF0Y2guZmluZFdyYXBwaW5nKGZpcnN0LnR5cGUpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHNsaWNlRGVwdGgsIGZyb250aWVyRGVwdGgsIHBhcmVudCwgd3JhcCB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjb250aW51ZSBsb29raW5nIGZ1cnRoZXIgdXAgaWYgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdvdWxkIGZpdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIG1hdGNoLm1hdGNoVHlwZShwYXJlbnQudHlwZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3Blbk1vcmUoKSB7XG4gICAgICAgIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gdGhpcy51bnBsYWNlZDtcbiAgICAgICAgbGV0IGlubmVyID0gY29udGVudEF0KGNvbnRlbnQsIG9wZW5TdGFydCk7XG4gICAgICAgIGlmICghaW5uZXIuY2hpbGRDb3VudCB8fCBpbm5lci5maXJzdENoaWxkLmlzTGVhZilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBTbGljZShjb250ZW50LCBvcGVuU3RhcnQgKyAxLCBNYXRoLm1heChvcGVuRW5kLCBpbm5lci5zaXplICsgb3BlblN0YXJ0ID49IGNvbnRlbnQuc2l6ZSAtIG9wZW5FbmQgPyBvcGVuU3RhcnQgKyAxIDogMCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZHJvcE5vZGUoKSB7XG4gICAgICAgIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gdGhpcy51bnBsYWNlZDtcbiAgICAgICAgbGV0IGlubmVyID0gY29udGVudEF0KGNvbnRlbnQsIG9wZW5TdGFydCk7XG4gICAgICAgIGlmIChpbm5lci5jaGlsZENvdW50IDw9IDEgJiYgb3BlblN0YXJ0ID4gMCkge1xuICAgICAgICAgICAgbGV0IG9wZW5BdEVuZCA9IGNvbnRlbnQuc2l6ZSAtIG9wZW5TdGFydCA8PSBvcGVuU3RhcnQgKyBpbm5lci5zaXplO1xuICAgICAgICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KGNvbnRlbnQsIG9wZW5TdGFydCAtIDEsIDEpLCBvcGVuU3RhcnQgLSAxLCBvcGVuQXRFbmQgPyBvcGVuU3RhcnQgLSAxIDogb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVucGxhY2VkID0gbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoY29udGVudCwgb3BlblN0YXJ0LCAxKSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNb3ZlIGNvbnRlbnQgZnJvbSB0aGUgdW5wbGFjZWQgc2xpY2UgYXQgYHNsaWNlRGVwdGhgIHRvIHRoZVxuICAgIC8vIGZyb250aWVyIG5vZGUgYXQgYGZyb250aWVyRGVwdGhgLiBDbG9zZSB0aGF0IGZyb250aWVyIG5vZGUgd2hlblxuICAgIC8vIGFwcGxpY2FibGUuXG4gICAgcGxhY2VOb2Rlcyh7IHNsaWNlRGVwdGgsIGZyb250aWVyRGVwdGgsIHBhcmVudCwgaW5qZWN0LCB3cmFwIH0pIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuZGVwdGggPiBmcm9udGllckRlcHRoKVxuICAgICAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgICBpZiAod3JhcClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JhcC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5Gcm9udGllck5vZGUod3JhcFtpXSk7XG4gICAgICAgIGxldCBzbGljZSA9IHRoaXMudW5wbGFjZWQsIGZyYWdtZW50ID0gcGFyZW50ID8gcGFyZW50LmNvbnRlbnQgOiBzbGljZS5jb250ZW50O1xuICAgICAgICBsZXQgb3BlblN0YXJ0ID0gc2xpY2Uub3BlblN0YXJ0IC0gc2xpY2VEZXB0aDtcbiAgICAgICAgbGV0IHRha2VuID0gMCwgYWRkID0gW107XG4gICAgICAgIGxldCB7IG1hdGNoLCB0eXBlIH0gPSB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdO1xuICAgICAgICBpZiAoaW5qZWN0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluamVjdC5jaGlsZENvdW50OyBpKyspXG4gICAgICAgICAgICAgICAgYWRkLnB1c2goaW5qZWN0LmNoaWxkKGkpKTtcbiAgICAgICAgICAgIG1hdGNoID0gbWF0Y2gubWF0Y2hGcmFnbWVudChpbmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGVzIHRoZSBhbW91bnQgb2YgKGVuZCkgb3BlbiBub2RlcyBhdCB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAvLyBmcmFnbWVudC4gV2hlbiAwLCB0aGUgcGFyZW50IGlzIG9wZW4sIGJ1dCBubyBtb3JlLiBXaGVuXG4gICAgICAgIC8vIG5lZ2F0aXZlLCBub3RoaW5nIGlzIG9wZW4uXG4gICAgICAgIGxldCBvcGVuRW5kQ291bnQgPSAoZnJhZ21lbnQuc2l6ZSArIHNsaWNlRGVwdGgpIC0gKHNsaWNlLmNvbnRlbnQuc2l6ZSAtIHNsaWNlLm9wZW5FbmQpO1xuICAgICAgICAvLyBTY2FuIG92ZXIgdGhlIGZyYWdtZW50LCBmaXR0aW5nIGFzIG1hbnkgY2hpbGQgbm9kZXMgYXNcbiAgICAgICAgLy8gcG9zc2libGUuXG4gICAgICAgIHdoaWxlICh0YWtlbiA8IGZyYWdtZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZnJhZ21lbnQuY2hpbGQodGFrZW4pLCBtYXRjaGVzID0gbWF0Y2gubWF0Y2hUeXBlKG5leHQudHlwZSk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB0YWtlbisrO1xuICAgICAgICAgICAgaWYgKHRha2VuID4gMSB8fCBvcGVuU3RhcnQgPT0gMCB8fCBuZXh0LmNvbnRlbnQuc2l6ZSkgeyAvLyBEcm9wIGVtcHR5IG9wZW4gbm9kZXNcbiAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoZXM7XG4gICAgICAgICAgICAgICAgYWRkLnB1c2goY2xvc2VOb2RlU3RhcnQobmV4dC5tYXJrKHR5cGUuYWxsb3dlZE1hcmtzKG5leHQubWFya3MpKSwgdGFrZW4gPT0gMSA/IG9wZW5TdGFydCA6IDAsIHRha2VuID09IGZyYWdtZW50LmNoaWxkQ291bnQgPyBvcGVuRW5kQ291bnQgOiAtMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0b0VuZCA9IHRha2VuID09IGZyYWdtZW50LmNoaWxkQ291bnQ7XG4gICAgICAgIGlmICghdG9FbmQpXG4gICAgICAgICAgICBvcGVuRW5kQ291bnQgPSAtMTtcbiAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCBmcm9udGllckRlcHRoLCBGcmFnbWVudC5mcm9tKGFkZCkpO1xuICAgICAgICB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdLm1hdGNoID0gbWF0Y2g7XG4gICAgICAgIC8vIElmIHRoZSBwYXJlbnQgdHlwZXMgbWF0Y2gsIGFuZCB0aGUgZW50aXJlIG5vZGUgd2FzIG1vdmVkLCBhbmRcbiAgICAgICAgLy8gaXQncyBub3Qgb3BlbiwgY2xvc2UgdGhpcyBmcm9udGllciBub2RlIHJpZ2h0IGF3YXkuXG4gICAgICAgIGlmICh0b0VuZCAmJiBvcGVuRW5kQ291bnQgPCAwICYmIHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdLnR5cGUgJiYgdGhpcy5mcm9udGllci5sZW5ndGggPiAxKVxuICAgICAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgICAvLyBBZGQgbmV3IGZyb250aWVyIG5vZGVzIGZvciBhbnkgb3BlbiBub2RlcyBhdCB0aGUgZW5kLlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgY3VyID0gZnJhZ21lbnQ7IGkgPCBvcGVuRW5kQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBjdXIubGFzdENoaWxkO1xuICAgICAgICAgICAgdGhpcy5mcm9udGllci5wdXNoKHsgdHlwZTogbm9kZS50eXBlLCBtYXRjaDogbm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpIH0pO1xuICAgICAgICAgICAgY3VyID0gbm9kZS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBgdGhpcy51bnBsYWNlZGAuIERyb3AgdGhlIGVudGlyZSBub2RlIGZyb20gd2hpY2ggd2VcbiAgICAgICAgLy8gcGxhY2VkIGl0IHdlIGdvdCB0byBpdHMgZW5kLCBvdGhlcndpc2UganVzdCBkcm9wIHRoZSBwbGFjZWRcbiAgICAgICAgLy8gbm9kZXMuXG4gICAgICAgIHRoaXMudW5wbGFjZWQgPSAhdG9FbmQgPyBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChzbGljZS5jb250ZW50LCBzbGljZURlcHRoLCB0YWtlbiksIHNsaWNlLm9wZW5TdGFydCwgc2xpY2Uub3BlbkVuZClcbiAgICAgICAgICAgIDogc2xpY2VEZXB0aCA9PSAwID8gU2xpY2UuZW1wdHlcbiAgICAgICAgICAgICAgICA6IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIHNsaWNlRGVwdGggLSAxLCAxKSwgc2xpY2VEZXB0aCAtIDEsIG9wZW5FbmRDb3VudCA8IDAgPyBzbGljZS5vcGVuRW5kIDogc2xpY2VEZXB0aCAtIDEpO1xuICAgIH1cbiAgICBtdXN0TW92ZUlubGluZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiR0by5wYXJlbnQuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdLCBsZXZlbDtcbiAgICAgICAgaWYgKCF0b3AudHlwZS5pc1RleHRibG9jayB8fCAhY29udGVudEFmdGVyRml0cyh0aGlzLiR0bywgdGhpcy4kdG8uZGVwdGgsIHRvcC50eXBlLCB0b3AubWF0Y2gsIGZhbHNlKSB8fFxuICAgICAgICAgICAgKHRoaXMuJHRvLmRlcHRoID09IHRoaXMuZGVwdGggJiYgKGxldmVsID0gdGhpcy5maW5kQ2xvc2VMZXZlbCh0aGlzLiR0bykpICYmIGxldmVsLmRlcHRoID09IHRoaXMuZGVwdGgpKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBsZXQgeyBkZXB0aCB9ID0gdGhpcy4kdG8sIGFmdGVyID0gdGhpcy4kdG8uYWZ0ZXIoZGVwdGgpO1xuICAgICAgICB3aGlsZSAoZGVwdGggPiAxICYmIGFmdGVyID09IHRoaXMuJHRvLmVuZCgtLWRlcHRoKSlcbiAgICAgICAgICAgICsrYWZ0ZXI7XG4gICAgICAgIHJldHVybiBhZnRlcjtcbiAgICB9XG4gICAgZmluZENsb3NlTGV2ZWwoJHRvKSB7XG4gICAgICAgIHNjYW46IGZvciAobGV0IGkgPSBNYXRoLm1pbih0aGlzLmRlcHRoLCAkdG8uZGVwdGgpOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHsgbWF0Y2gsIHR5cGUgfSA9IHRoaXMuZnJvbnRpZXJbaV07XG4gICAgICAgICAgICBsZXQgZHJvcElubmVyID0gaSA8ICR0by5kZXB0aCAmJiAkdG8uZW5kKGkgKyAxKSA9PSAkdG8ucG9zICsgKCR0by5kZXB0aCAtIChpICsgMSkpO1xuICAgICAgICAgICAgbGV0IGZpdCA9IGNvbnRlbnRBZnRlckZpdHMoJHRvLCBpLCB0eXBlLCBtYXRjaCwgZHJvcElubmVyKTtcbiAgICAgICAgICAgIGlmICghZml0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgZCA9IGkgLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgICAgIGxldCB7IG1hdGNoLCB0eXBlIH0gPSB0aGlzLmZyb250aWVyW2RdO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaGVzID0gY29udGVudEFmdGVyRml0cygkdG8sIGQsIHR5cGUsIG1hdGNoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5jaGlsZENvdW50KVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGVwdGg6IGksIGZpdCwgbW92ZTogZHJvcElubmVyID8gJHRvLmRvYy5yZXNvbHZlKCR0by5hZnRlcihpICsgMSkpIDogJHRvIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2UoJHRvKSB7XG4gICAgICAgIGxldCBjbG9zZSA9IHRoaXMuZmluZENsb3NlTGV2ZWwoJHRvKTtcbiAgICAgICAgaWYgKCFjbG9zZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAodGhpcy5kZXB0aCA+IGNsb3NlLmRlcHRoKVxuICAgICAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgICBpZiAoY2xvc2UuZml0LmNoaWxkQ291bnQpXG4gICAgICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIGNsb3NlLmRlcHRoLCBjbG9zZS5maXQpO1xuICAgICAgICAkdG8gPSBjbG9zZS5tb3ZlO1xuICAgICAgICBmb3IgKGxldCBkID0gY2xvc2UuZGVwdGggKyAxOyBkIDw9ICR0by5kZXB0aDsgZCsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9ICR0by5ub2RlKGQpLCBhZGQgPSBub2RlLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUobm9kZS5jb250ZW50LCB0cnVlLCAkdG8uaW5kZXgoZCkpO1xuICAgICAgICAgICAgdGhpcy5vcGVuRnJvbnRpZXJOb2RlKG5vZGUudHlwZSwgbm9kZS5hdHRycywgYWRkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRvO1xuICAgIH1cbiAgICBvcGVuRnJvbnRpZXJOb2RlKHR5cGUsIGF0dHJzID0gbnVsbCwgY29udGVudCkge1xuICAgICAgICBsZXQgdG9wID0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXTtcbiAgICAgICAgdG9wLm1hdGNoID0gdG9wLm1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCB0aGlzLmRlcHRoLCBGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGF0dHJzLCBjb250ZW50KSkpO1xuICAgICAgICB0aGlzLmZyb250aWVyLnB1c2goeyB0eXBlLCBtYXRjaDogdHlwZS5jb250ZW50TWF0Y2ggfSk7XG4gICAgfVxuICAgIGNsb3NlRnJvbnRpZXJOb2RlKCkge1xuICAgICAgICBsZXQgb3BlbiA9IHRoaXMuZnJvbnRpZXIucG9wKCk7XG4gICAgICAgIGxldCBhZGQgPSBvcGVuLm1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgICAgICBpZiAoYWRkLmNoaWxkQ291bnQpXG4gICAgICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIHRoaXMuZnJvbnRpZXIubGVuZ3RoLCBhZGQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRyb3BGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBjb3VudCkge1xuICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQuY3V0QnlJbmRleChjb3VudCwgZnJhZ21lbnQuY2hpbGRDb3VudCk7XG4gICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2VDaGlsZCgwLCBmcmFnbWVudC5maXJzdENoaWxkLmNvcHkoZHJvcEZyb21GcmFnbWVudChmcmFnbWVudC5maXJzdENoaWxkLmNvbnRlbnQsIGRlcHRoIC0gMSwgY291bnQpKSk7XG59XG5mdW5jdGlvbiBhZGRUb0ZyYWdtZW50KGZyYWdtZW50LCBkZXB0aCwgY29udGVudCkge1xuICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQuYXBwZW5kKGNvbnRlbnQpO1xuICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoZnJhZ21lbnQuY2hpbGRDb3VudCAtIDEsIGZyYWdtZW50Lmxhc3RDaGlsZC5jb3B5KGFkZFRvRnJhZ21lbnQoZnJhZ21lbnQubGFzdENoaWxkLmNvbnRlbnQsIGRlcHRoIC0gMSwgY29udGVudCkpKTtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRBdChmcmFnbWVudCwgZGVwdGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHRoOyBpKyspXG4gICAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgIHJldHVybiBmcmFnbWVudDtcbn1cbmZ1bmN0aW9uIGNsb3NlTm9kZVN0YXJ0KG5vZGUsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGlmIChvcGVuU3RhcnQgPD0gMClcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgbGV0IGZyYWcgPSBub2RlLmNvbnRlbnQ7XG4gICAgaWYgKG9wZW5TdGFydCA+IDEpXG4gICAgICAgIGZyYWcgPSBmcmFnLnJlcGxhY2VDaGlsZCgwLCBjbG9zZU5vZGVTdGFydChmcmFnLmZpcnN0Q2hpbGQsIG9wZW5TdGFydCAtIDEsIGZyYWcuY2hpbGRDb3VudCA9PSAxID8gb3BlbkVuZCAtIDEgOiAwKSk7XG4gICAgaWYgKG9wZW5TdGFydCA+IDApIHtcbiAgICAgICAgZnJhZyA9IG5vZGUudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShmcmFnKS5hcHBlbmQoZnJhZyk7XG4gICAgICAgIGlmIChvcGVuRW5kIDw9IDApXG4gICAgICAgICAgICBmcmFnID0gZnJhZy5hcHBlbmQobm9kZS50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGZyYWcpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUuY29weShmcmFnKTtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRBZnRlckZpdHMoJHRvLCBkZXB0aCwgdHlwZSwgbWF0Y2gsIG9wZW4pIHtcbiAgICBsZXQgbm9kZSA9ICR0by5ub2RlKGRlcHRoKSwgaW5kZXggPSBvcGVuID8gJHRvLmluZGV4QWZ0ZXIoZGVwdGgpIDogJHRvLmluZGV4KGRlcHRoKTtcbiAgICBpZiAoaW5kZXggPT0gbm9kZS5jaGlsZENvdW50ICYmICF0eXBlLmNvbXBhdGlibGVDb250ZW50KG5vZGUudHlwZSkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmaXQgPSBtYXRjaC5maWxsQmVmb3JlKG5vZGUuY29udGVudCwgdHJ1ZSwgaW5kZXgpO1xuICAgIHJldHVybiBmaXQgJiYgIWludmFsaWRNYXJrcyh0eXBlLCBub2RlLmNvbnRlbnQsIGluZGV4KSA/IGZpdCA6IG51bGw7XG59XG5mdW5jdGlvbiBpbnZhbGlkTWFya3ModHlwZSwgZnJhZ21lbnQsIHN0YXJ0KSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZnJhZ21lbnQuY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICBpZiAoIXR5cGUuYWxsb3dzTWFya3MoZnJhZ21lbnQuY2hpbGQoaSkubWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZGVmaW5lc0NvbnRlbnQodHlwZSkge1xuICAgIHJldHVybiB0eXBlLnNwZWMuZGVmaW5pbmcgfHwgdHlwZS5zcGVjLmRlZmluaW5nRm9yQ29udGVudDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VSYW5nZSh0ciwgZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgaWYgKCFzbGljZS5zaXplKVxuICAgICAgICByZXR1cm4gdHIuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgIGxldCAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLCAkdG8gPSB0ci5kb2MucmVzb2x2ZSh0byk7XG4gICAgaWYgKGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpKVxuICAgICAgICByZXR1cm4gdHIuc3RlcChuZXcgUmVwbGFjZVN0ZXAoZnJvbSwgdG8sIHNsaWNlKSk7XG4gICAgbGV0IHRhcmdldERlcHRocyA9IGNvdmVyZWREZXB0aHMoJGZyb20sIHRyLmRvYy5yZXNvbHZlKHRvKSk7XG4gICAgLy8gQ2FuJ3QgcmVwbGFjZSB0aGUgd2hvbGUgZG9jdW1lbnQsIHNvIHJlbW92ZSAwIGlmIGl0J3MgcHJlc2VudFxuICAgIGlmICh0YXJnZXREZXB0aHNbdGFyZ2V0RGVwdGhzLmxlbmd0aCAtIDFdID09IDApXG4gICAgICAgIHRhcmdldERlcHRocy5wb3AoKTtcbiAgICAvLyBOZWdhdGl2ZSBudW1iZXJzIHJlcHJlc2VudCBub3QgZXhwYW5zaW9uIG92ZXIgdGhlIHdob2xlIG5vZGUgYXRcbiAgICAvLyB0aGF0IGRlcHRoLCBidXQgcmVwbGFjaW5nIGZyb20gJGZyb20uYmVmb3JlKC1EKSB0byAkdG8ucG9zLlxuICAgIGxldCBwcmVmZXJyZWRUYXJnZXQgPSAtKCRmcm9tLmRlcHRoICsgMSk7XG4gICAgdGFyZ2V0RGVwdGhzLnVuc2hpZnQocHJlZmVycmVkVGFyZ2V0KTtcbiAgICAvLyBUaGlzIGxvb3AgcGlja3MgYSBwcmVmZXJyZWQgdGFyZ2V0IGRlcHRoLCBpZiBvbmUgb2YgdGhlIGNvdmVyaW5nXG4gICAgLy8gZGVwdGhzIGlzIG5vdCBvdXRzaWRlIG9mIGEgZGVmaW5pbmcgbm9kZSwgYW5kIGFkZHMgbmVnYXRpdmVcbiAgICAvLyBkZXB0aHMgZm9yIGFueSBkZXB0aCB0aGF0IGhhcyAkZnJvbSBhdCBpdHMgc3RhcnQgYW5kIGRvZXMgbm90XG4gICAgLy8gY3Jvc3MgYSBkZWZpbmluZyBub2RlLlxuICAgIGZvciAobGV0IGQgPSAkZnJvbS5kZXB0aCwgcG9zID0gJGZyb20ucG9zIC0gMTsgZCA+IDA7IGQtLSwgcG9zLS0pIHtcbiAgICAgICAgbGV0IHNwZWMgPSAkZnJvbS5ub2RlKGQpLnR5cGUuc3BlYztcbiAgICAgICAgaWYgKHNwZWMuZGVmaW5pbmcgfHwgc3BlYy5kZWZpbmluZ0FzQ29udGV4dCB8fCBzcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAodGFyZ2V0RGVwdGhzLmluZGV4T2YoZCkgPiAtMSlcbiAgICAgICAgICAgIHByZWZlcnJlZFRhcmdldCA9IGQ7XG4gICAgICAgIGVsc2UgaWYgKCRmcm9tLmJlZm9yZShkKSA9PSBwb3MpXG4gICAgICAgICAgICB0YXJnZXREZXB0aHMuc3BsaWNlKDEsIDAsIC1kKTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpdCBlYWNoIHBvc3NpYmxlIGRlcHRoIG9mIHRoZSBzbGljZSBpbnRvIGVhY2ggcG9zc2libGVcbiAgICAvLyB0YXJnZXQgZGVwdGgsIHN0YXJ0aW5nIHdpdGggdGhlIHByZWZlcnJlZCBkZXB0aHMuXG4gICAgbGV0IHByZWZlcnJlZFRhcmdldEluZGV4ID0gdGFyZ2V0RGVwdGhzLmluZGV4T2YocHJlZmVycmVkVGFyZ2V0KTtcbiAgICBsZXQgbGVmdE5vZGVzID0gW10sIHByZWZlcnJlZERlcHRoID0gc2xpY2Uub3BlblN0YXJ0O1xuICAgIGZvciAobGV0IGNvbnRlbnQgPSBzbGljZS5jb250ZW50LCBpID0gMDs7IGkrKykge1xuICAgICAgICBsZXQgbm9kZSA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgbGVmdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIGlmIChpID09IHNsaWNlLm9wZW5TdGFydClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb250ZW50ID0gbm9kZS5jb250ZW50O1xuICAgIH1cbiAgICAvLyBCYWNrIHVwIHByZWZlcnJlZERlcHRoIHRvIGNvdmVyIGRlZmluaW5nIHRleHRibG9ja3MgZGlyZWN0bHlcbiAgICAvLyBhYm92ZSBpdCwgcG9zc2libHkgc2tpcHBpbmcgYSBub24tZGVmaW5pbmcgdGV4dGJsb2NrLlxuICAgIGZvciAobGV0IGQgPSBwcmVmZXJyZWREZXB0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBsZWZ0Tm9kZSA9IGxlZnROb2Rlc1tkXSwgZGVmID0gZGVmaW5lc0NvbnRlbnQobGVmdE5vZGUudHlwZSk7XG4gICAgICAgIGlmIChkZWYgJiYgIWxlZnROb2RlLnNhbWVNYXJrdXAoJGZyb20ubm9kZShNYXRoLmFicyhwcmVmZXJyZWRUYXJnZXQpIC0gMSkpKVxuICAgICAgICAgICAgcHJlZmVycmVkRGVwdGggPSBkO1xuICAgICAgICBlbHNlIGlmIChkZWYgfHwgIWxlZnROb2RlLnR5cGUuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IHNsaWNlLm9wZW5TdGFydDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgbGV0IG9wZW5EZXB0aCA9IChqICsgcHJlZmVycmVkRGVwdGggKyAxKSAlIChzbGljZS5vcGVuU3RhcnQgKyAxKTtcbiAgICAgICAgbGV0IGluc2VydCA9IGxlZnROb2Rlc1tvcGVuRGVwdGhdO1xuICAgICAgICBpZiAoIWluc2VydClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldERlcHRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gTG9vcCBvdmVyIHBvc3NpYmxlIGV4cGFuc2lvbiBsZXZlbHMsIHN0YXJ0aW5nIHdpdGggdGhlXG4gICAgICAgICAgICAvLyBwcmVmZXJyZWQgb25lXG4gICAgICAgICAgICBsZXQgdGFyZ2V0RGVwdGggPSB0YXJnZXREZXB0aHNbKGkgKyBwcmVmZXJyZWRUYXJnZXRJbmRleCkgJSB0YXJnZXREZXB0aHMubGVuZ3RoXSwgZXhwYW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0YXJnZXREZXB0aCA8IDApIHtcbiAgICAgICAgICAgICAgICBleHBhbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0YXJnZXREZXB0aCA9IC10YXJnZXREZXB0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkZnJvbS5ub2RlKHRhcmdldERlcHRoIC0gMSksIGluZGV4ID0gJGZyb20uaW5kZXgodGFyZ2V0RGVwdGggLSAxKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBpbnNlcnQudHlwZSwgaW5zZXJ0Lm1hcmtzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHIucmVwbGFjZSgkZnJvbS5iZWZvcmUodGFyZ2V0RGVwdGgpLCBleHBhbmQgPyAkdG8uYWZ0ZXIodGFyZ2V0RGVwdGgpIDogdG8sIG5ldyBTbGljZShjbG9zZUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIDAsIHNsaWNlLm9wZW5TdGFydCwgb3BlbkRlcHRoKSwgb3BlbkRlcHRoLCBzbGljZS5vcGVuRW5kKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0YXJ0U3RlcHMgPSB0ci5zdGVwcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IHRhcmdldERlcHRocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0ci5yZXBsYWNlKGZyb20sIHRvLCBzbGljZSk7XG4gICAgICAgIGlmICh0ci5zdGVwcy5sZW5ndGggPiBzdGFydFN0ZXBzKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBkZXB0aCA9IHRhcmdldERlcHRoc1tpXTtcbiAgICAgICAgaWYgKGRlcHRoIDwgMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmcm9tID0gJGZyb20uYmVmb3JlKGRlcHRoKTtcbiAgICAgICAgdG8gPSAkdG8uYWZ0ZXIoZGVwdGgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb3NlRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBvbGRPcGVuLCBuZXdPcGVuLCBwYXJlbnQpIHtcbiAgICBpZiAoZGVwdGggPCBvbGRPcGVuKSB7XG4gICAgICAgIGxldCBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQucmVwbGFjZUNoaWxkKDAsIGZpcnN0LmNvcHkoY2xvc2VGcmFnbWVudChmaXJzdC5jb250ZW50LCBkZXB0aCArIDEsIG9sZE9wZW4sIG5ld09wZW4sIGZpcnN0KSkpO1xuICAgIH1cbiAgICBpZiAoZGVwdGggPiBuZXdPcGVuKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdCgwKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gbWF0Y2guZmlsbEJlZm9yZShmcmFnbWVudCkuYXBwZW5kKGZyYWdtZW50KTtcbiAgICAgICAgZnJhZ21lbnQgPSBzdGFydC5hcHBlbmQobWF0Y2gubWF0Y2hGcmFnbWVudChzdGFydCkuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG59XG5mdW5jdGlvbiByZXBsYWNlUmFuZ2VXaXRoKHRyLCBmcm9tLCB0bywgbm9kZSkge1xuICAgIGlmICghbm9kZS5pc0lubGluZSAmJiBmcm9tID09IHRvICYmIHRyLmRvYy5yZXNvbHZlKGZyb20pLnBhcmVudC5jb250ZW50LnNpemUpIHtcbiAgICAgICAgbGV0IHBvaW50ID0gaW5zZXJ0UG9pbnQodHIuZG9jLCBmcm9tLCBub2RlLnR5cGUpO1xuICAgICAgICBpZiAocG9pbnQgIT0gbnVsbClcbiAgICAgICAgICAgIGZyb20gPSB0byA9IHBvaW50O1xuICAgIH1cbiAgICB0ci5yZXBsYWNlUmFuZ2UoZnJvbSwgdG8sIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5vZGUpLCAwLCAwKSk7XG59XG5mdW5jdGlvbiBkZWxldGVSYW5nZSh0ciwgZnJvbSwgdG8pIHtcbiAgICBsZXQgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gdHIuZG9jLnJlc29sdmUodG8pO1xuICAgIGxldCBjb3ZlcmVkID0gY292ZXJlZERlcHRocygkZnJvbSwgJHRvKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlcHRoID0gY292ZXJlZFtpXSwgbGFzdCA9IGkgPT0gY292ZXJlZC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoKGxhc3QgJiYgZGVwdGggPT0gMCkgfHwgJGZyb20ubm9kZShkZXB0aCkudHlwZS5jb250ZW50TWF0Y2gudmFsaWRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdHIuZGVsZXRlKCRmcm9tLnN0YXJ0KGRlcHRoKSwgJHRvLmVuZChkZXB0aCkpO1xuICAgICAgICBpZiAoZGVwdGggPiAwICYmIChsYXN0IHx8ICRmcm9tLm5vZGUoZGVwdGggLSAxKS5jYW5SZXBsYWNlKCRmcm9tLmluZGV4KGRlcHRoIC0gMSksICR0by5pbmRleEFmdGVyKGRlcHRoIC0gMSkpKSlcbiAgICAgICAgICAgIHJldHVybiB0ci5kZWxldGUoJGZyb20uYmVmb3JlKGRlcHRoKSwgJHRvLmFmdGVyKGRlcHRoKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGQgPSAxOyBkIDw9ICRmcm9tLmRlcHRoICYmIGQgPD0gJHRvLmRlcHRoOyBkKyspIHtcbiAgICAgICAgaWYgKGZyb20gLSAkZnJvbS5zdGFydChkKSA9PSAkZnJvbS5kZXB0aCAtIGQgJiYgdG8gPiAkZnJvbS5lbmQoZCkgJiYgJHRvLmVuZChkKSAtIHRvICE9ICR0by5kZXB0aCAtIGQpXG4gICAgICAgICAgICByZXR1cm4gdHIuZGVsZXRlKCRmcm9tLmJlZm9yZShkKSwgdG8pO1xuICAgIH1cbiAgICB0ci5kZWxldGUoZnJvbSwgdG8pO1xufVxuLy8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgZGVwdGhzIGZvciB3aGljaCAkZnJvbSAtICR0byBzcGFucyB0aGVcbi8vIHdob2xlIGNvbnRlbnQgb2YgdGhlIG5vZGVzIGF0IHRoYXQgZGVwdGguXG5mdW5jdGlvbiBjb3ZlcmVkRGVwdGhzKCRmcm9tLCAkdG8pIHtcbiAgICBsZXQgcmVzdWx0ID0gW10sIG1pbkRlcHRoID0gTWF0aC5taW4oJGZyb20uZGVwdGgsICR0by5kZXB0aCk7XG4gICAgZm9yIChsZXQgZCA9IG1pbkRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgc3RhcnQgPSAkZnJvbS5zdGFydChkKTtcbiAgICAgICAgaWYgKHN0YXJ0IDwgJGZyb20ucG9zIC0gKCRmcm9tLmRlcHRoIC0gZCkgfHxcbiAgICAgICAgICAgICR0by5lbmQoZCkgPiAkdG8ucG9zICsgKCR0by5kZXB0aCAtIGQpIHx8XG4gICAgICAgICAgICAkZnJvbS5ub2RlKGQpLnR5cGUuc3BlYy5pc29sYXRpbmcgfHxcbiAgICAgICAgICAgICR0by5ub2RlKGQpLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHN0YXJ0ID09ICR0by5zdGFydChkKSB8fFxuICAgICAgICAgICAgKGQgPT0gJGZyb20uZGVwdGggJiYgZCA9PSAkdG8uZGVwdGggJiYgJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgJiYgJHRvLnBhcmVudC5pbmxpbmVDb250ZW50ICYmXG4gICAgICAgICAgICAgICAgZCAmJiAkdG8uc3RhcnQoZCAtIDEpID09IHN0YXJ0IC0gMSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG5VcGRhdGUgYW4gYXR0cmlidXRlIGluIGEgc3BlY2lmaWMgbm9kZS5cbiovXG5jbGFzcyBBdHRyU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhbiBhdHRyaWJ1dGUgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIFRoZSBhdHRyaWJ1dGUgdG8gc2V0LlxuICAgICovXG4gICAgYXR0ciwgXG4gICAgLy8gVGhlIGF0dHJpYnV0ZSdzIG5ldyB2YWx1ZS5cbiAgICB2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5hdHRyID0gYXR0cjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgYXR0cmlidXRlIHN0ZXAncyBwb3NpdGlvblwiKTtcbiAgICAgICAgbGV0IGF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBub2RlLmF0dHJzKVxuICAgICAgICAgICAgYXR0cnNbbmFtZV0gPSBub2RlLmF0dHJzW25hbWVdO1xuICAgICAgICBhdHRyc1t0aGlzLmF0dHJdID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBub2RlLnR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBub2RlLm1hcmtzKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLnBvcywgdGhpcy5wb3MgKyAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh1cGRhdGVkKSwgMCwgbm9kZS5pc0xlYWYgPyAwIDogMSkpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXR0clN0ZXAodGhpcy5wb3MsIHRoaXMuYXR0ciwgZG9jLm5vZGVBdCh0aGlzLnBvcykuYXR0cnNbdGhpcy5hdHRyXSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnBvcywgMSk7XG4gICAgICAgIHJldHVybiBwb3MuZGVsZXRlZEFmdGVyID8gbnVsbCA6IG5ldyBBdHRyU3RlcChwb3MucG9zLCB0aGlzLmF0dHIsIHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImF0dHJcIiwgcG9zOiB0aGlzLnBvcywgYXR0cjogdGhpcy5hdHRyLCB2YWx1ZTogdGhpcy52YWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5hdHRyICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEF0dHJTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJTdGVwKGpzb24ucG9zLCBqc29uLmF0dHIsIGpzb24udmFsdWUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiYXR0clwiLCBBdHRyU3RlcCk7XG4vKipcblVwZGF0ZSBhbiBhdHRyaWJ1dGUgaW4gdGhlIGRvYyBub2RlLlxuKi9cbmNsYXNzIERvY0F0dHJTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGFuIGF0dHJpYnV0ZSBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGF0dHJpYnV0ZSB0byBzZXQuXG4gICAgKi9cbiAgICBhdHRyLCBcbiAgICAvLyBUaGUgYXR0cmlidXRlJ3MgbmV3IHZhbHVlLlxuICAgIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXR0ciA9IGF0dHI7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gZG9jLmF0dHJzKVxuICAgICAgICAgICAgYXR0cnNbbmFtZV0gPSBkb2MuYXR0cnNbbmFtZV07XG4gICAgICAgIGF0dHJzW3RoaXMuYXR0cl0gPSB0aGlzLnZhbHVlO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IGRvYy50eXBlLmNyZWF0ZShhdHRycywgZG9jLmNvbnRlbnQsIGRvYy5tYXJrcyk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0Lm9rKHVwZGF0ZWQpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9jQXR0clN0ZXAodGhpcy5hdHRyLCBkb2MuYXR0cnNbdGhpcy5hdHRyXSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImRvY0F0dHJcIiwgYXR0cjogdGhpcy5hdHRyLCB2YWx1ZTogdGhpcy52YWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5hdHRyICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIERvY0F0dHJTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IERvY0F0dHJTdGVwKGpzb24uYXR0ciwganNvbi52YWx1ZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJkb2NBdHRyXCIsIERvY0F0dHJTdGVwKTtcblxuLyoqXG5AaW50ZXJuYWxcbiovXG5sZXQgVHJhbnNmb3JtRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbn07XG5UcmFuc2Zvcm1FcnJvciA9IGZ1bmN0aW9uIFRyYW5zZm9ybUVycm9yKG1lc3NhZ2UpIHtcbiAgICBsZXQgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICBlcnIuX19wcm90b19fID0gVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlO1xuICAgIHJldHVybiBlcnI7XG59O1xuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJhbnNmb3JtRXJyb3I7XG5UcmFuc2Zvcm1FcnJvci5wcm90b3R5cGUubmFtZSA9IFwiVHJhbnNmb3JtRXJyb3JcIjtcbi8qKlxuQWJzdHJhY3Rpb24gdG8gYnVpbGQgdXAgYW5kIHRyYWNrIGFuIGFycmF5IG9mXG5bc3RlcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcCkgcmVwcmVzZW50aW5nIGEgZG9jdW1lbnQgdHJhbnNmb3JtYXRpb24uXG5cbk1vc3QgdHJhbnNmb3JtaW5nIG1ldGhvZHMgcmV0dXJuIHRoZSBgVHJhbnNmb3JtYCBvYmplY3QgaXRzZWxmLCBzb1xudGhhdCB0aGV5IGNhbiBiZSBjaGFpbmVkLlxuKi9cbmNsYXNzIFRyYW5zZm9ybSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdHJhbnNmb3JtIHRoYXQgc3RhcnRzIHdpdGggdGhlIGdpdmVuIGRvY3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZG9jdW1lbnQgKHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIHN0ZXBzIGluIHRoZVxuICAgIHRyYW5zZm9ybSkuXG4gICAgKi9cbiAgICBkb2MpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgc3RlcHMgaW4gdGhpcyB0cmFuc2Zvcm0uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc3RlcHMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBkb2N1bWVudHMgYmVmb3JlIGVhY2ggb2YgdGhlIHN0ZXBzLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvY3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEEgbWFwcGluZyB3aXRoIHRoZSBtYXBzIGZvciBlYWNoIG9mIHRoZSBzdGVwcyBpbiB0aGlzIHRyYW5zZm9ybS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBwaW5nID0gbmV3IE1hcHBpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzdGFydGluZyBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBiZWZvcmUoKSB7IHJldHVybiB0aGlzLmRvY3MubGVuZ3RoID8gdGhpcy5kb2NzWzBdIDogdGhpcy5kb2M7IH1cbiAgICAvKipcbiAgICBBcHBseSBhIG5ldyBzdGVwIGluIHRoaXMgdHJhbnNmb3JtLCBzYXZpbmcgdGhlIHJlc3VsdC4gVGhyb3dzIGFuXG4gICAgZXJyb3Igd2hlbiB0aGUgc3RlcCBmYWlscy5cbiAgICAqL1xuICAgIHN0ZXAoc3RlcCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5tYXliZVN0ZXAoc3RlcCk7XG4gICAgICAgIGlmIChyZXN1bHQuZmFpbGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zZm9ybUVycm9yKHJlc3VsdC5mYWlsZWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIGFwcGx5IGEgc3RlcCBpbiB0aGlzIHRyYW5zZm9ybWF0aW9uLCBpZ25vcmluZyBpdCBpZiBpdFxuICAgIGZhaWxzLiBSZXR1cm5zIHRoZSBzdGVwIHJlc3VsdC5cbiAgICAqL1xuICAgIG1heWJlU3RlcChzdGVwKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzdGVwLmFwcGx5KHRoaXMuZG9jKTtcbiAgICAgICAgaWYgKCFyZXN1bHQuZmFpbGVkKVxuICAgICAgICAgICAgdGhpcy5hZGRTdGVwKHN0ZXAsIHJlc3VsdC5kb2MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhlIGRvY3VtZW50IGhhcyBiZWVuIGNoYW5nZWQgKHdoZW4gdGhlcmUgYXJlIGFueVxuICAgIHN0ZXBzKS5cbiAgICAqL1xuICAgIGdldCBkb2NDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwcy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFkZFN0ZXAoc3RlcCwgZG9jKSB7XG4gICAgICAgIHRoaXMuZG9jcy5wdXNoKHRoaXMuZG9jKTtcbiAgICAgICAgdGhpcy5zdGVwcy5wdXNoKHN0ZXApO1xuICAgICAgICB0aGlzLm1hcHBpbmcuYXBwZW5kTWFwKHN0ZXAuZ2V0TWFwKCkpO1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgcGFydCBvZiB0aGUgZG9jdW1lbnQgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2Agd2l0aCB0aGVcbiAgICBnaXZlbiBgc2xpY2VgLlxuICAgICovXG4gICAgcmVwbGFjZShmcm9tLCB0byA9IGZyb20sIHNsaWNlID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgbGV0IHN0ZXAgPSByZXBsYWNlU3RlcCh0aGlzLmRvYywgZnJvbSwgdG8sIHNsaWNlKTtcbiAgICAgICAgaWYgKHN0ZXApXG4gICAgICAgICAgICB0aGlzLnN0ZXAoc3RlcCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBnaXZlbiByYW5nZSB3aXRoIHRoZSBnaXZlbiBjb250ZW50LCB3aGljaCBtYXkgYmUgYVxuICAgIGZyYWdtZW50LCBub2RlLCBvciBhcnJheSBvZiBub2Rlcy5cbiAgICAqL1xuICAgIHJlcGxhY2VXaXRoKGZyb20sIHRvLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoZnJvbSwgdG8sIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKGNvbnRlbnQpLCAwLCAwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSB0aGUgY29udGVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBkZWxldGUoZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZShmcm9tLCB0bywgU2xpY2UuZW1wdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICBJbnNlcnQgdGhlIGdpdmVuIGNvbnRlbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgaW5zZXJ0KHBvcywgY29udGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlV2l0aChwb3MsIHBvcywgY29udGVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgYSByYW5nZSBvZiB0aGUgZG9jdW1lbnQgd2l0aCBhIGdpdmVuIHNsaWNlLCB1c2luZ1xuICAgIGBmcm9tYCwgYHRvYCwgYW5kIHRoZSBzbGljZSdzXG4gICAgW2BvcGVuU3RhcnRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuU2xpY2Uub3BlblN0YXJ0KSBwcm9wZXJ0eSBhcyBoaW50cywgcmF0aGVyXG4gICAgdGhhbiBmaXhlZCBzdGFydCBhbmQgZW5kIHBvaW50cy4gVGhpcyBtZXRob2QgbWF5IGdyb3cgdGhlXG4gICAgcmVwbGFjZWQgYXJlYSBvciBjbG9zZSBvcGVuIG5vZGVzIGluIHRoZSBzbGljZSBpbiBvcmRlciB0byBnZXQgYVxuICAgIGZpdCB0aGF0IGlzIG1vcmUgaW4gbGluZSB3aXRoIFdZU0lXWUcgZXhwZWN0YXRpb25zLCBieSBkcm9wcGluZ1xuICAgIGZ1bGx5IGNvdmVyZWQgcGFyZW50IG5vZGVzIG9mIHRoZSByZXBsYWNlZCByZWdpb24gd2hlbiB0aGV5IGFyZVxuICAgIG1hcmtlZCBbbm9uLWRlZmluaW5nIGFzXG4gICAgY29udGV4dF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmRlZmluaW5nQXNDb250ZXh0KSwgb3IgaW5jbHVkaW5nIGFuXG4gICAgb3BlbiBwYXJlbnQgbm9kZSBmcm9tIHRoZSBzbGljZSB0aGF0IF9pc18gbWFya2VkIGFzIFtkZWZpbmluZ1xuICAgIGl0cyBjb250ZW50XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuZGVmaW5pbmdGb3JDb250ZW50KS5cbiAgICBcbiAgICBUaGlzIGlzIHRoZSBtZXRob2QsIGZvciBleGFtcGxlLCB0byBoYW5kbGUgcGFzdGUuIFRoZSBzaW1pbGFyXG4gICAgW2ByZXBsYWNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5UcmFuc2Zvcm0ucmVwbGFjZSkgbWV0aG9kIGlzIGEgbW9yZVxuICAgIHByaW1pdGl2ZSB0b29sIHdoaWNoIHdpbGwgX25vdF8gbW92ZSB0aGUgc3RhcnQgYW5kIGVuZCBvZiBpdHMgZ2l2ZW5cbiAgICByYW5nZSwgYW5kIGlzIHVzZWZ1bCBpbiBzaXR1YXRpb25zIHdoZXJlIHlvdSBuZWVkIG1vcmUgcHJlY2lzZVxuICAgIGNvbnRyb2wgb3ZlciB3aGF0IGhhcHBlbnMuXG4gICAgKi9cbiAgICByZXBsYWNlUmFuZ2UoZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgICAgIHJlcGxhY2VSYW5nZSh0aGlzLCBmcm9tLCB0bywgc2xpY2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aCBhIG5vZGUsIGJ1dCB1c2UgYGZyb21gIGFuZCBgdG9gIGFzXG4gICAgaGludHMsIHJhdGhlciB0aGFuIHByZWNpc2UgcG9zaXRpb25zLiBXaGVuIGZyb20gYW5kIHRvIGFyZSB0aGUgc2FtZVxuICAgIGFuZCBhcmUgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhIHBhcmVudCBub2RlIGluIHdoaWNoIHRoZSBnaXZlblxuICAgIG5vZGUgZG9lc24ndCBmaXQsIHRoaXMgbWV0aG9kIG1heSBfbW92ZV8gdGhlbSBvdXQgdG93YXJkcyBhIHBhcmVudFxuICAgIHRoYXQgZG9lcyBhbGxvdyB0aGUgZ2l2ZW4gbm9kZSB0byBiZSBwbGFjZWQuIFdoZW4gdGhlIGdpdmVuIHJhbmdlXG4gICAgY29tcGxldGVseSBjb3ZlcnMgYSBwYXJlbnQgbm9kZSwgdGhpcyBtZXRob2QgbWF5IGNvbXBsZXRlbHkgcmVwbGFjZVxuICAgIHRoYXQgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICByZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBub2RlKSB7XG4gICAgICAgIHJlcGxhY2VSYW5nZVdpdGgodGhpcywgZnJvbSwgdG8sIG5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIHRoZSBnaXZlbiByYW5nZSwgZXhwYW5kaW5nIGl0IHRvIGNvdmVyIGZ1bGx5IGNvdmVyZWRcbiAgICBwYXJlbnQgbm9kZXMgdW50aWwgYSB2YWxpZCByZXBsYWNlIGlzIGZvdW5kLlxuICAgICovXG4gICAgZGVsZXRlUmFuZ2UoZnJvbSwgdG8pIHtcbiAgICAgICAgZGVsZXRlUmFuZ2UodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU3BsaXQgdGhlIGNvbnRlbnQgaW4gdGhlIGdpdmVuIHJhbmdlIG9mZiBmcm9tIGl0cyBwYXJlbnQsIGlmIHRoZXJlXG4gICAgaXMgc2libGluZyBjb250ZW50IGJlZm9yZSBvciBhZnRlciBpdCwgYW5kIG1vdmUgaXQgdXAgdGhlIHRyZWUgdG9cbiAgICB0aGUgZGVwdGggc3BlY2lmaWVkIGJ5IGB0YXJnZXRgLiBZb3UnbGwgcHJvYmFibHkgd2FudCB0byB1c2VcbiAgICBbYGxpZnRUYXJnZXRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLmxpZnRUYXJnZXQpIHRvIGNvbXB1dGUgYHRhcmdldGAsIHRvIG1ha2VcbiAgICBzdXJlIHRoZSBsaWZ0IGlzIHZhbGlkLlxuICAgICovXG4gICAgbGlmdChyYW5nZSwgdGFyZ2V0KSB7XG4gICAgICAgIGxpZnQodGhpcywgcmFuZ2UsIHRhcmdldCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBKb2luIHRoZSBibG9ja3MgYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvbi4gSWYgZGVwdGggaXMgMiwgdGhlaXJcbiAgICBsYXN0IGFuZCBmaXJzdCBzaWJsaW5ncyBhcmUgYWxzbyBqb2luZWQsIGFuZCBzbyBvbi5cbiAgICAqL1xuICAgIGpvaW4ocG9zLCBkZXB0aCA9IDEpIHtcbiAgICAgICAgam9pbih0aGlzLCBwb3MsIGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFdyYXAgdGhlIGdpdmVuIFtyYW5nZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVSYW5nZSkgaW4gdGhlIGdpdmVuIHNldCBvZiB3cmFwcGVycy5cbiAgICBUaGUgd3JhcHBlcnMgYXJlIGFzc3VtZWQgdG8gYmUgdmFsaWQgaW4gdGhpcyBwb3NpdGlvbiwgYW5kIHNob3VsZFxuICAgIHByb2JhYmx5IGJlIGNvbXB1dGVkIHdpdGggW2BmaW5kV3JhcHBpbmdgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLmZpbmRXcmFwcGluZykuXG4gICAgKi9cbiAgICB3cmFwKHJhbmdlLCB3cmFwcGVycykge1xuICAgICAgICB3cmFwKHRoaXMsIHJhbmdlLCB3cmFwcGVycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIHR5cGUgb2YgYWxsIHRleHRibG9ja3MgKHBhcnRseSkgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AgdG9cbiAgICB0aGUgZ2l2ZW4gbm9kZSB0eXBlIHdpdGggdGhlIGdpdmVuIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBzZXRCbG9ja1R5cGUoZnJvbSwgdG8gPSBmcm9tLCB0eXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICAgICAgc2V0QmxvY2tUeXBlKHRoaXMsIGZyb20sIHRvLCB0eXBlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGFuZ2UgdGhlIHR5cGUsIGF0dHJpYnV0ZXMsIGFuZC9vciBtYXJrcyBvZiB0aGUgbm9kZSBhdCBgcG9zYC5cbiAgICBXaGVuIGB0eXBlYCBpc24ndCBnaXZlbiwgdGhlIGV4aXN0aW5nIG5vZGUgdHlwZSBpcyBwcmVzZXJ2ZWQsXG4gICAgKi9cbiAgICBzZXROb2RlTWFya3VwKHBvcywgdHlwZSwgYXR0cnMgPSBudWxsLCBtYXJrcykge1xuICAgICAgICBzZXROb2RlTWFya3VwKHRoaXMsIHBvcywgdHlwZSwgYXR0cnMsIG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCBhIHNpbmdsZSBhdHRyaWJ1dGUgb24gYSBnaXZlbiBub2RlIHRvIGEgbmV3IHZhbHVlLlxuICAgIFRoZSBgcG9zYCBhZGRyZXNzZXMgdGhlIGRvY3VtZW50IGNvbnRlbnQuIFVzZSBgc2V0RG9jQXR0cmlidXRlYFxuICAgIHRvIHNldCBhdHRyaWJ1dGVzIG9uIHRoZSBkb2N1bWVudCBpdHNlbGYuXG4gICAgKi9cbiAgICBzZXROb2RlQXR0cmlidXRlKHBvcywgYXR0ciwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdGVwKG5ldyBBdHRyU3RlcChwb3MsIGF0dHIsIHZhbHVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgYSBzaW5nbGUgYXR0cmlidXRlIG9uIHRoZSBkb2N1bWVudCB0byBhIG5ldyB2YWx1ZS5cbiAgICAqL1xuICAgIHNldERvY0F0dHJpYnV0ZShhdHRyLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnN0ZXAobmV3IERvY0F0dHJTdGVwKGF0dHIsIHZhbHVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSBtYXJrIHRvIHRoZSBub2RlIGF0IHBvc2l0aW9uIGBwb3NgLlxuICAgICovXG4gICAgYWRkTm9kZU1hcmsocG9zLCBtYXJrKSB7XG4gICAgICAgIHRoaXMuc3RlcChuZXcgQWRkTm9kZU1hcmtTdGVwKHBvcywgbWFyaykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIGEgbWFyayAob3IgYSBtYXJrIG9mIHRoZSBnaXZlbiB0eXBlKSBmcm9tIHRoZSBub2RlIGF0XG4gICAgcG9zaXRpb24gYHBvc2AuXG4gICAgKi9cbiAgICByZW1vdmVOb2RlTWFyayhwb3MsIG1hcmspIHtcbiAgICAgICAgaWYgKCEobWFyayBpbnN0YW5jZW9mIE1hcmspKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZG9jLm5vZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gbm9kZSBhdCBwb3NpdGlvbiBcIiArIHBvcyk7XG4gICAgICAgICAgICBtYXJrID0gbWFyay5pc0luU2V0KG5vZGUubWFya3MpO1xuICAgICAgICAgICAgaWYgKCFtYXJrKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RlcChuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKHBvcywgbWFyaykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU3BsaXQgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBhbmQgb3B0aW9uYWxseSwgaWYgYGRlcHRoYCBpc1xuICAgIGdyZWF0ZXIgdGhhbiBvbmUsIGFueSBudW1iZXIgb2Ygbm9kZXMgYWJvdmUgdGhhdC4gQnkgZGVmYXVsdCwgdGhlXG4gICAgcGFydHMgc3BsaXQgb2ZmIHdpbGwgaW5oZXJpdCB0aGUgbm9kZSB0eXBlIG9mIHRoZSBvcmlnaW5hbCBub2RlLlxuICAgIFRoaXMgY2FuIGJlIGNoYW5nZWQgYnkgcGFzc2luZyBhbiBhcnJheSBvZiB0eXBlcyBhbmQgYXR0cmlidXRlcyB0b1xuICAgIHVzZSBhZnRlciB0aGUgc3BsaXQuXG4gICAgKi9cbiAgICBzcGxpdChwb3MsIGRlcHRoID0gMSwgdHlwZXNBZnRlcikge1xuICAgICAgICBzcGxpdCh0aGlzLCBwb3MsIGRlcHRoLCB0eXBlc0FmdGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCB0aGUgZ2l2ZW4gbWFyayB0byB0aGUgaW5saW5lIGNvbnRlbnQgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AuXG4gICAgKi9cbiAgICBhZGRNYXJrKGZyb20sIHRvLCBtYXJrKSB7XG4gICAgICAgIGFkZE1hcmsodGhpcywgZnJvbSwgdG8sIG1hcmspO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIG1hcmtzIGZyb20gaW5saW5lIG5vZGVzIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLiBXaGVuXG4gICAgYG1hcmtgIGlzIGEgc2luZ2xlIG1hcmssIHJlbW92ZSBwcmVjaXNlbHkgdGhhdCBtYXJrLiBXaGVuIGl0IGlzXG4gICAgYSBtYXJrIHR5cGUsIHJlbW92ZSBhbGwgbWFya3Mgb2YgdGhhdCB0eXBlLiBXaGVuIGl0IGlzIG51bGwsXG4gICAgcmVtb3ZlIGFsbCBtYXJrcyBvZiBhbnkgdHlwZS5cbiAgICAqL1xuICAgIHJlbW92ZU1hcmsoZnJvbSwgdG8sIG1hcmspIHtcbiAgICAgICAgcmVtb3ZlTWFyayh0aGlzLCBmcm9tLCB0bywgbWFyayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmVzIGFsbCBtYXJrcyBhbmQgbm9kZXMgZnJvbSB0aGUgY29udGVudCBvZiB0aGUgbm9kZSBhdFxuICAgIGBwb3NgIHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIGdpdmVuIG5ldyBwYXJlbnQgbm9kZSB0eXBlLiBBY2NlcHRzXG4gICAgYW4gb3B0aW9uYWwgc3RhcnRpbmcgW2NvbnRlbnQgbWF0Y2hdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Db250ZW50TWF0Y2gpIGFzXG4gICAgdGhpcmQgYXJndW1lbnQuXG4gICAgKi9cbiAgICBjbGVhckluY29tcGF0aWJsZShwb3MsIHBhcmVudFR5cGUsIG1hdGNoKSB7XG4gICAgICAgIGNsZWFySW5jb21wYXRpYmxlKHRoaXMsIHBvcywgcGFyZW50VHlwZSwgbWF0Y2gpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmV4cG9ydCB7IEFkZE1hcmtTdGVwLCBBZGROb2RlTWFya1N0ZXAsIEF0dHJTdGVwLCBEb2NBdHRyU3RlcCwgTWFwUmVzdWx0LCBNYXBwaW5nLCBSZW1vdmVNYXJrU3RlcCwgUmVtb3ZlTm9kZU1hcmtTdGVwLCBSZXBsYWNlQXJvdW5kU3RlcCwgUmVwbGFjZVN0ZXAsIFN0ZXAsIFN0ZXBNYXAsIFN0ZXBSZXN1bHQsIFRyYW5zZm9ybSwgVHJhbnNmb3JtRXJyb3IsIGNhbkpvaW4sIGNhblNwbGl0LCBkcm9wUG9pbnQsIGZpbmRXcmFwcGluZywgaW5zZXJ0UG9pbnQsIGpvaW5Qb2ludCwgbGlmdFRhcmdldCwgcmVwbGFjZVN0ZXAgfTtcbiIsICJpbXBvcnQgeyBTbGljZSwgRnJhZ21lbnQsIE1hcmssIE5vZGUgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBSZXBsYWNlU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIFRyYW5zZm9ybSB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5cbmNvbnN0IGNsYXNzZXNCeUlkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuU3VwZXJjbGFzcyBmb3IgZWRpdG9yIHNlbGVjdGlvbnMuIEV2ZXJ5IHNlbGVjdGlvbiB0eXBlIHNob3VsZFxuZXh0ZW5kIHRoaXMuIFNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuKi9cbmNsYXNzIFNlbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgSW5pdGlhbGl6ZSBhIHNlbGVjdGlvbiB3aXRoIHRoZSBoZWFkIGFuZCBhbmNob3IgYW5kIHJhbmdlcy4gSWYgbm9cbiAgICByYW5nZXMgYXJlIGdpdmVuLCBjb25zdHJ1Y3RzIGEgc2luZ2xlIHJhbmdlIGFjcm9zcyBgJGFuY2hvcmAgYW5kXG4gICAgYCRoZWFkYC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSByZXNvbHZlZCBhbmNob3Igb2YgdGhlIHNlbGVjdGlvbiAodGhlIHNpZGUgdGhhdCBzdGF5cyBpblxuICAgIHBsYWNlIHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBtb2RpZmllZCkuXG4gICAgKi9cbiAgICAkYW5jaG9yLCBcbiAgICAvKipcbiAgICBUaGUgcmVzb2x2ZWQgaGVhZCBvZiB0aGUgc2VsZWN0aW9uICh0aGUgc2lkZSB0aGF0IG1vdmVzIHdoZW5cbiAgICB0aGUgc2VsZWN0aW9uIGlzIG1vZGlmaWVkKS5cbiAgICAqL1xuICAgICRoZWFkLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy4kYW5jaG9yID0gJGFuY2hvcjtcbiAgICAgICAgdGhpcy4kaGVhZCA9ICRoZWFkO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcyB8fCBbbmV3IFNlbGVjdGlvblJhbmdlKCRhbmNob3IubWluKCRoZWFkKSwgJGFuY2hvci5tYXgoJGhlYWQpKV07XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzZWxlY3Rpb24ncyBhbmNob3IsIGFzIGFuIHVucmVzb2x2ZWQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgYW5jaG9yKCkgeyByZXR1cm4gdGhpcy4kYW5jaG9yLnBvczsgfVxuICAgIC8qKlxuICAgIFRoZSBzZWxlY3Rpb24ncyBoZWFkLlxuICAgICovXG4gICAgZ2V0IGhlYWQoKSB7IHJldHVybiB0aGlzLiRoZWFkLnBvczsgfVxuICAgIC8qKlxuICAgIFRoZSBsb3dlciBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbiAgICAqL1xuICAgIGdldCBmcm9tKCkgeyByZXR1cm4gdGhpcy4kZnJvbS5wb3M7IH1cbiAgICAvKipcbiAgICBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIHNlbGVjdGlvbidzIG1haW4gcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLiR0by5wb3M7IH1cbiAgICAvKipcbiAgICBUaGUgcmVzb2x2ZWQgbG93ZXIgIGJvdW5kIG9mIHRoZSBzZWxlY3Rpb24ncyBtYWluIHJhbmdlLlxuICAgICovXG4gICAgZ2V0ICRmcm9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXNbMF0uJGZyb207XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSByZXNvbHZlZCB1cHBlciBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbiAgICAqL1xuICAgIGdldCAkdG8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1swXS4kdG87XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gY29udGFpbnMgYW55IGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAocmFuZ2VzW2ldLiRmcm9tLnBvcyAhPSByYW5nZXNbaV0uJHRvLnBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbnRlbnQgb2YgdGhpcyBzZWxlY3Rpb24gYXMgYSBzbGljZS5cbiAgICAqL1xuICAgIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRmcm9tLmRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8sIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIHNsaWNlIG9yLCBpZiBubyBzbGljZSBpcyBnaXZlbixcbiAgICBkZWxldGUgdGhlIHNlbGVjdGlvbi4gV2lsbCBhcHBlbmQgdG8gdGhlIGdpdmVuIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgcmVwbGFjZSh0ciwgY29udGVudCA9IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgIC8vIFB1dCB0aGUgbmV3IHNlbGVjdGlvbiBhdCB0aGUgcG9zaXRpb24gYWZ0ZXIgdGhlIGluc2VydGVkXG4gICAgICAgIC8vIGNvbnRlbnQuIFdoZW4gdGhhdCBlbmRlZCBpbiBhbiBpbmxpbmUgbm9kZSwgc2VhcmNoIGJhY2t3YXJkcyxcbiAgICAgICAgLy8gdG8gZ2V0IHRoZSBwb3NpdGlvbiBhZnRlciB0aGF0IG5vZGUuIElmIG5vdCwgc2VhcmNoIGZvcndhcmQuXG4gICAgICAgIGxldCBsYXN0Tm9kZSA9IGNvbnRlbnQuY29udGVudC5sYXN0Q2hpbGQsIGxhc3RQYXJlbnQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQub3BlbkVuZDsgaSsrKSB7XG4gICAgICAgICAgICBsYXN0UGFyZW50ID0gbGFzdE5vZGU7XG4gICAgICAgICAgICBsYXN0Tm9kZSA9IGxhc3ROb2RlLmxhc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aCwgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV0sIG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgICAgICAgICAgdHIucmVwbGFjZVJhbmdlKG1hcHBpbmcubWFwKCRmcm9tLnBvcyksIG1hcHBpbmcubWFwKCR0by5wb3MpLCBpID8gU2xpY2UuZW1wdHkgOiBjb250ZW50KTtcbiAgICAgICAgICAgIGlmIChpID09IDApXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIG1hcEZyb20sIChsYXN0Tm9kZSA/IGxhc3ROb2RlLmlzSW5saW5lIDogbGFzdFBhcmVudCAmJiBsYXN0UGFyZW50LmlzVGV4dGJsb2NrKSA/IC0xIDogMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIG5vZGUsIGFwcGVuZGluZyB0aGUgY2hhbmdlc1xuICAgIHRvIHRoZSBnaXZlbiB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHJlcGxhY2VXaXRoKHRyLCBub2RlKSB7XG4gICAgICAgIGxldCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoLCByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXSwgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwKCRmcm9tLnBvcyksIHRvID0gbWFwcGluZy5tYXAoJHRvLnBvcyk7XG4gICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgIHRyLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VSYW5nZVdpdGgoZnJvbSwgdG8sIG5vZGUpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBtYXBGcm9tLCBub2RlLmlzSW5saW5lID8gLTEgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGEgdmFsaWQgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gc3RhcnRpbmcgYXQgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24gYW5kIHNlYXJjaGluZyBiYWNrIGlmIGBkaXJgIGlzIG5lZ2F0aXZlLCBhbmQgZm9yd2FyZCBpZlxuICAgIHBvc2l0aXZlLiBXaGVuIGB0ZXh0T25seWAgaXMgdHJ1ZSwgb25seSBjb25zaWRlciBjdXJzb3JcbiAgICBzZWxlY3Rpb25zLiBXaWxsIHJldHVybiBudWxsIHdoZW4gbm8gdmFsaWQgc2VsZWN0aW9uIHBvc2l0aW9uIGlzXG4gICAgZm91bmQuXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZEZyb20oJHBvcywgZGlyLCB0ZXh0T25seSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBpbm5lciA9ICRwb3MucGFyZW50LmlubGluZUNvbnRlbnQgPyBuZXcgVGV4dFNlbGVjdGlvbigkcG9zKVxuICAgICAgICAgICAgOiBmaW5kU2VsZWN0aW9uSW4oJHBvcy5ub2RlKDApLCAkcG9zLnBhcmVudCwgJHBvcy5wb3MsICRwb3MuaW5kZXgoKSwgZGlyLCB0ZXh0T25seSk7XG4gICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoIC0gMTsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gZGlyIDwgMFxuICAgICAgICAgICAgICAgID8gZmluZFNlbGVjdGlvbkluKCRwb3Mubm9kZSgwKSwgJHBvcy5ub2RlKGRlcHRoKSwgJHBvcy5iZWZvcmUoZGVwdGggKyAxKSwgJHBvcy5pbmRleChkZXB0aCksIGRpciwgdGV4dE9ubHkpXG4gICAgICAgICAgICAgICAgOiBmaW5kU2VsZWN0aW9uSW4oJHBvcy5ub2RlKDApLCAkcG9zLm5vZGUoZGVwdGgpLCAkcG9zLmFmdGVyKGRlcHRoICsgMSksICRwb3MuaW5kZXgoZGVwdGgpICsgMSwgZGlyLCB0ZXh0T25seSk7XG4gICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGEgdmFsaWQgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gbmVhciB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbi4gU2VhcmNoZXMgZm9yd2FyZCBmaXJzdCBieSBkZWZhdWx0LCBidXQgaWYgYGJpYXNgIGlzXG4gICAgbmVnYXRpdmUsIGl0IHdpbGwgc2VhcmNoIGJhY2t3YXJkcyBmaXJzdC5cbiAgICAqL1xuICAgIHN0YXRpYyBuZWFyKCRwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRGcm9tKCRwb3MsIGJpYXMpIHx8IHRoaXMuZmluZEZyb20oJHBvcywgLWJpYXMpIHx8IG5ldyBBbGxTZWxlY3Rpb24oJHBvcy5ub2RlKDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gY2xvc2VzdCB0byB0aGUgc3RhcnQgb2ZcbiAgICB0aGUgZ2l2ZW4gZG9jdW1lbnQuIFdpbGwgcmV0dXJuIGFuXG4gICAgW2BBbGxTZWxlY3Rpb25gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuQWxsU2VsZWN0aW9uKSBpZiBubyB2YWxpZCBwb3NpdGlvblxuICAgIGV4aXN0cy5cbiAgICAqL1xuICAgIHN0YXRpYyBhdFN0YXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gZmluZFNlbGVjdGlvbkluKGRvYywgZG9jLCAwLCAwLCAxKSB8fCBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGN1cnNvciBvciBsZWFmIG5vZGUgc2VsZWN0aW9uIGNsb3Nlc3QgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBhdEVuZChkb2MpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRTZWxlY3Rpb25Jbihkb2MsIGRvYywgZG9jLmNvbnRlbnQuc2l6ZSwgZG9jLmNoaWxkQ291bnQsIC0xKSB8fCBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgc2VsZWN0aW9uLiBNdXN0IGJlXG4gICAgaW1wbGVtZW50ZWQgZm9yIGN1c3RvbSBjbGFzc2VzIChhcyBhIHN0YXRpYyBjbGFzcyBtZXRob2QpLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIWpzb24udHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgU2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgY2xzID0gY2xhc3Nlc0J5SWRbanNvbi50eXBlXTtcbiAgICAgICAgaWYgKCFjbHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gc2VsZWN0aW9uIHR5cGUgJHtqc29uLnR5cGV9IGRlZmluZWRgKTtcbiAgICAgICAgcmV0dXJuIGNscy5mcm9tSlNPTihkb2MsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBUbyBiZSBhYmxlIHRvIGRlc2VyaWFsaXplIHNlbGVjdGlvbnMgZnJvbSBKU09OLCBjdXN0b20gc2VsZWN0aW9uXG4gICAgY2xhc3NlcyBtdXN0IHJlZ2lzdGVyIHRoZW1zZWx2ZXMgd2l0aCBhbiBJRCBzdHJpbmcsIHNvIHRoYXQgdGhleVxuICAgIGNhbiBiZSBkaXNhbWJpZ3VhdGVkLiBUcnkgdG8gcGljayBzb21ldGhpbmcgdGhhdCdzIHVubGlrZWx5IHRvXG4gICAgY2xhc2ggd2l0aCBjbGFzc2VzIGZyb20gb3RoZXIgbW9kdWxlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBqc29uSUQoaWQsIHNlbGVjdGlvbkNsYXNzKSB7XG4gICAgICAgIGlmIChpZCBpbiBjbGFzc2VzQnlJZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRHVwbGljYXRlIHVzZSBvZiBzZWxlY3Rpb24gSlNPTiBJRCBcIiArIGlkKTtcbiAgICAgICAgY2xhc3Nlc0J5SWRbaWRdID0gc2VsZWN0aW9uQ2xhc3M7XG4gICAgICAgIHNlbGVjdGlvbkNsYXNzLnByb3RvdHlwZS5qc29uSUQgPSBpZDtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbkNsYXNzO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbYm9va21hcmtdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25Cb29rbWFyaykgZm9yIHRoaXMgc2VsZWN0aW9uLFxuICAgIHdoaWNoIGlzIGEgdmFsdWUgdGhhdCBjYW4gYmUgbWFwcGVkIHdpdGhvdXQgaGF2aW5nIGFjY2VzcyB0byBhXG4gICAgY3VycmVudCBkb2N1bWVudCwgYW5kIGxhdGVyIHJlc29sdmVkIHRvIGEgcmVhbCBzZWxlY3Rpb24gZm9yIGFcbiAgICBnaXZlbiBkb2N1bWVudCBhZ2Fpbi4gKFRoaXMgaXMgdXNlZCBtb3N0bHkgYnkgdGhlIGhpc3RvcnkgdG9cbiAgICB0cmFjayBhbmQgcmVzdG9yZSBvbGQgc2VsZWN0aW9ucy4pIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mXG4gICAgdGhpcyBtZXRob2QganVzdCBjb252ZXJ0cyB0aGUgc2VsZWN0aW9uIHRvIGEgdGV4dCBzZWxlY3Rpb24gYW5kXG4gICAgcmV0dXJucyB0aGUgYm9va21hcmsgZm9yIHRoYXQuXG4gICAgKi9cbiAgICBnZXRCb29rbWFyaygpIHtcbiAgICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uYmV0d2Vlbih0aGlzLiRhbmNob3IsIHRoaXMuJGhlYWQpLmdldEJvb2ttYXJrKCk7XG4gICAgfVxufVxuU2VsZWN0aW9uLnByb3RvdHlwZS52aXNpYmxlID0gdHJ1ZTtcbi8qKlxuUmVwcmVzZW50cyBhIHNlbGVjdGVkIHJhbmdlIGluIGEgZG9jdW1lbnQuXG4qL1xuY2xhc3MgU2VsZWN0aW9uUmFuZ2Uge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJhbmdlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgICRmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgJHRvKSB7XG4gICAgICAgIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgICAgICAgdGhpcy4kdG8gPSAkdG87XG4gICAgfVxufVxubGV0IHdhcm5lZEFib3V0VGV4dFNlbGVjdGlvbiA9IGZhbHNlO1xuZnVuY3Rpb24gY2hlY2tUZXh0U2VsZWN0aW9uKCRwb3MpIHtcbiAgICBpZiAoIXdhcm5lZEFib3V0VGV4dFNlbGVjdGlvbiAmJiAhJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICB3YXJuZWRBYm91dFRleHRTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb25zb2xlW1wid2FyblwiXShcIlRleHRTZWxlY3Rpb24gZW5kcG9pbnQgbm90IHBvaW50aW5nIGludG8gYSBub2RlIHdpdGggaW5saW5lIGNvbnRlbnQgKFwiICsgJHBvcy5wYXJlbnQudHlwZS5uYW1lICsgXCIpXCIpO1xuICAgIH1cbn1cbi8qKlxuQSB0ZXh0IHNlbGVjdGlvbiByZXByZXNlbnRzIGEgY2xhc3NpY2FsIGVkaXRvciBzZWxlY3Rpb24sIHdpdGggYVxuaGVhZCAodGhlIG1vdmluZyBzaWRlKSBhbmQgYW5jaG9yIChpbW1vYmlsZSBzaWRlKSwgYm90aCBvZiB3aGljaFxucG9pbnQgaW50byB0ZXh0YmxvY2sgbm9kZXMuIEl0IGNhbiBiZSBlbXB0eSAoYSByZWd1bGFyIGN1cnNvclxucG9zaXRpb24pLlxuKi9cbmNsYXNzIFRleHRTZWxlY3Rpb24gZXh0ZW5kcyBTZWxlY3Rpb24ge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIHRleHQgc2VsZWN0aW9uIGJldHdlZW4gdGhlIGdpdmVuIHBvaW50cy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCRhbmNob3IsICRoZWFkID0gJGFuY2hvcikge1xuICAgICAgICBjaGVja1RleHRTZWxlY3Rpb24oJGFuY2hvcik7XG4gICAgICAgIGNoZWNrVGV4dFNlbGVjdGlvbigkaGVhZCk7XG4gICAgICAgIHN1cGVyKCRhbmNob3IsICRoZWFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIHJlc29sdmVkIHBvc2l0aW9uIGlmIHRoaXMgaXMgYSBjdXJzb3Igc2VsZWN0aW9uIChhblxuICAgIGVtcHR5IHRleHQgc2VsZWN0aW9uKSwgYW5kIG51bGwgb3RoZXJ3aXNlLlxuICAgICovXG4gICAgZ2V0ICRjdXJzb3IoKSB7IHJldHVybiB0aGlzLiRhbmNob3IucG9zID09IHRoaXMuJGhlYWQucG9zID8gdGhpcy4kaGVhZCA6IG51bGw7IH1cbiAgICBtYXAoZG9jLCBtYXBwaW5nKSB7XG4gICAgICAgIGxldCAkaGVhZCA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICAgICAgICBpZiAoISRoZWFkLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRoZWFkKTtcbiAgICAgICAgbGV0ICRhbmNob3IgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLmFuY2hvcikpO1xuICAgICAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb24oJGFuY2hvci5wYXJlbnQuaW5saW5lQ29udGVudCA/ICRhbmNob3IgOiAkaGVhZCwgJGhlYWQpO1xuICAgIH1cbiAgICByZXBsYWNlKHRyLCBjb250ZW50ID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgc3VwZXIucmVwbGFjZSh0ciwgY29udGVudCk7XG4gICAgICAgIGlmIChjb250ZW50ID09IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSB0aGlzLiRmcm9tLm1hcmtzQWNyb3NzKHRoaXMuJHRvKTtcbiAgICAgICAgICAgIGlmIChtYXJrcylcbiAgICAgICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhtYXJrcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiAmJiBvdGhlci5hbmNob3IgPT0gdGhpcy5hbmNob3IgJiYgb3RoZXIuaGVhZCA9PSB0aGlzLmhlYWQ7XG4gICAgfVxuICAgIGdldEJvb2ttYXJrKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHRCb29rbWFyayh0aGlzLmFuY2hvciwgdGhpcy5oZWFkKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInRleHRcIiwgYW5jaG9yOiB0aGlzLmFuY2hvciwgaGVhZDogdGhpcy5oZWFkIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uYW5jaG9yICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaGVhZCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBUZXh0U2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb24oZG9jLnJlc29sdmUoanNvbi5hbmNob3IpLCBkb2MucmVzb2x2ZShqc29uLmhlYWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGV4dCBzZWxlY3Rpb24gZnJvbSBub24tcmVzb2x2ZWQgcG9zaXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGFuY2hvciwgaGVhZCA9IGFuY2hvcikge1xuICAgICAgICBsZXQgJGFuY2hvciA9IGRvYy5yZXNvbHZlKGFuY2hvcik7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcygkYW5jaG9yLCBoZWFkID09IGFuY2hvciA/ICRhbmNob3IgOiBkb2MucmVzb2x2ZShoZWFkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIHRleHQgc2VsZWN0aW9uIHRoYXQgc3BhbnMgdGhlIGdpdmVuIHBvc2l0aW9ucyBvciwgaWZcbiAgICB0aGV5IGFyZW4ndCB0ZXh0IHBvc2l0aW9ucywgZmluZCBhIHRleHQgc2VsZWN0aW9uIG5lYXIgdGhlbS5cbiAgICBgYmlhc2AgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBtZXRob2Qgc2VhcmNoZXMgZm9yd2FyZCAoZGVmYXVsdClcbiAgICBvciBiYWNrd2FyZHMgKG5lZ2F0aXZlIG51bWJlcikgZmlyc3QuIFdpbGwgZmFsbCBiYWNrIHRvIGNhbGxpbmdcbiAgICBbYFNlbGVjdGlvbi5uZWFyYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvbl5uZWFyKSB3aGVuIHRoZSBkb2N1bWVudFxuICAgIGRvZXNuJ3QgY29udGFpbiBhIHZhbGlkIHRleHQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgYmV0d2VlbigkYW5jaG9yLCAkaGVhZCwgYmlhcykge1xuICAgICAgICBsZXQgZFBvcyA9ICRhbmNob3IucG9zIC0gJGhlYWQucG9zO1xuICAgICAgICBpZiAoIWJpYXMgfHwgZFBvcylcbiAgICAgICAgICAgIGJpYXMgPSBkUG9zID49IDAgPyAxIDogLTE7XG4gICAgICAgIGlmICghJGhlYWQucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IFNlbGVjdGlvbi5maW5kRnJvbSgkaGVhZCwgYmlhcywgdHJ1ZSkgfHwgU2VsZWN0aW9uLmZpbmRGcm9tKCRoZWFkLCAtYmlhcywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgJGhlYWQgPSBmb3VuZC4kaGVhZDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJGhlYWQsIGJpYXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghJGFuY2hvci5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICAgICAgaWYgKGRQb3MgPT0gMCkge1xuICAgICAgICAgICAgICAgICRhbmNob3IgPSAkaGVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICRhbmNob3IgPSAoU2VsZWN0aW9uLmZpbmRGcm9tKCRhbmNob3IsIC1iaWFzLCB0cnVlKSB8fCBTZWxlY3Rpb24uZmluZEZyb20oJGFuY2hvciwgYmlhcywgdHJ1ZSkpLiRhbmNob3I7XG4gICAgICAgICAgICAgICAgaWYgKCgkYW5jaG9yLnBvcyA8ICRoZWFkLnBvcykgIT0gKGRQb3MgPCAwKSlcbiAgICAgICAgICAgICAgICAgICAgJGFuY2hvciA9ICRoZWFkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdGlvbigkYW5jaG9yLCAkaGVhZCk7XG4gICAgfVxufVxuU2VsZWN0aW9uLmpzb25JRChcInRleHRcIiwgVGV4dFNlbGVjdGlvbik7XG5jbGFzcyBUZXh0Qm9va21hcmsge1xuICAgIGNvbnN0cnVjdG9yKGFuY2hvciwgaGVhZCkge1xuICAgICAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgICAgdGhpcy5oZWFkID0gaGVhZDtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Qm9va21hcmsobWFwcGluZy5tYXAodGhpcy5hbmNob3IpLCBtYXBwaW5nLm1hcCh0aGlzLmhlYWQpKTtcbiAgICB9XG4gICAgcmVzb2x2ZShkb2MpIHtcbiAgICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uYmV0d2Vlbihkb2MucmVzb2x2ZSh0aGlzLmFuY2hvciksIGRvYy5yZXNvbHZlKHRoaXMuaGVhZCkpO1xuICAgIH1cbn1cbi8qKlxuQSBub2RlIHNlbGVjdGlvbiBpcyBhIHNlbGVjdGlvbiB0aGF0IHBvaW50cyBhdCBhIHNpbmdsZSBub2RlLiBBbGxcbm5vZGVzIG1hcmtlZCBbc2VsZWN0YWJsZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLnNlbGVjdGFibGUpIGNhbiBiZSB0aGVcbnRhcmdldCBvZiBhIG5vZGUgc2VsZWN0aW9uLiBJbiBzdWNoIGEgc2VsZWN0aW9uLCBgZnJvbWAgYW5kIGB0b2BcbnBvaW50IGRpcmVjdGx5IGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHNlbGVjdGVkIG5vZGUsIGBhbmNob3JgIGVxdWFsc1xuYGZyb21gLCBhbmQgYGhlYWRgIGVxdWFscyBgdG9gLi5cbiovXG5jbGFzcyBOb2RlU2VsZWN0aW9uIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBub2RlIHNlbGVjdGlvbi4gRG9lcyBub3QgdmVyaWZ5IHRoZSB2YWxpZGl0eSBvZiBpdHNcbiAgICBhcmd1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCRwb3MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgbGV0ICRlbmQgPSAkcG9zLm5vZGUoMCkucmVzb2x2ZSgkcG9zLnBvcyArIG5vZGUubm9kZVNpemUpO1xuICAgICAgICBzdXBlcigkcG9zLCAkZW5kKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgbWFwKGRvYywgbWFwcGluZykge1xuICAgICAgICBsZXQgeyBkZWxldGVkLCBwb3MgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuYW5jaG9yKTtcbiAgICAgICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgICAgICBpZiAoZGVsZXRlZClcbiAgICAgICAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpO1xuICAgIH1cbiAgICBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odGhpcy5ub2RlKSwgMCwgMCk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgb3RoZXIuYW5jaG9yID09IHRoaXMuYW5jaG9yO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibm9kZVwiLCBhbmNob3I6IHRoaXMuYW5jaG9yIH07XG4gICAgfVxuICAgIGdldEJvb2ttYXJrKCkgeyByZXR1cm4gbmV3IE5vZGVCb29rbWFyayh0aGlzLmFuY2hvcik7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmFuY2hvciAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBOb2RlU2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oZG9jLnJlc29sdmUoanNvbi5hbmNob3IpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBzZWxlY3Rpb24gZnJvbSBub24tcmVzb2x2ZWQgcG9zaXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGZyb20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKGRvYy5yZXNvbHZlKGZyb20pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBub2RlIG1heSBiZSBzZWxlY3RlZCBhcyBhIG5vZGVcbiAgICBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgaXNTZWxlY3RhYmxlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICFub2RlLmlzVGV4dCAmJiBub2RlLnR5cGUuc3BlYy5zZWxlY3RhYmxlICE9PSBmYWxzZTtcbiAgICB9XG59XG5Ob2RlU2VsZWN0aW9uLnByb3RvdHlwZS52aXNpYmxlID0gZmFsc2U7XG5TZWxlY3Rpb24uanNvbklEKFwibm9kZVwiLCBOb2RlU2VsZWN0aW9uKTtcbmNsYXNzIE5vZGVCb29rbWFyayB7XG4gICAgY29uc3RydWN0b3IoYW5jaG9yKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgeyBkZWxldGVkLCBwb3MgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuYW5jaG9yKTtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZWQgPyBuZXcgVGV4dEJvb2ttYXJrKHBvcywgcG9zKSA6IG5ldyBOb2RlQm9va21hcmsocG9zKTtcbiAgICB9XG4gICAgcmVzb2x2ZShkb2MpIHtcbiAgICAgICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZSh0aGlzLmFuY2hvciksIG5vZGUgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgaWYgKG5vZGUgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oJHBvcyk7XG4gICAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICB9XG59XG4vKipcbkEgc2VsZWN0aW9uIHR5cGUgdGhhdCByZXByZXNlbnRzIHNlbGVjdGluZyB0aGUgd2hvbGUgZG9jdW1lbnRcbih3aGljaCBjYW4gbm90IG5lY2Vzc2FyaWx5IGJlIGV4cHJlc3NlZCB3aXRoIGEgdGV4dCBzZWxlY3Rpb24sIHdoZW5cbnRoZXJlIGFyZSBmb3IgZXhhbXBsZSBsZWFmIGJsb2NrIG5vZGVzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgdGhlXG5kb2N1bWVudCkuXG4qL1xuY2xhc3MgQWxsU2VsZWN0aW9uIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gYWxsLXNlbGVjdGlvbiBvdmVyIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRvYykge1xuICAgICAgICBzdXBlcihkb2MucmVzb2x2ZSgwKSwgZG9jLnJlc29sdmUoZG9jLmNvbnRlbnQuc2l6ZSkpO1xuICAgIH1cbiAgICByZXBsYWNlKHRyLCBjb250ZW50ID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgICAgIHRyLmRlbGV0ZSgwLCB0ci5kb2MuY29udGVudC5zaXplKTtcbiAgICAgICAgICAgIGxldCBzZWwgPSBTZWxlY3Rpb24uYXRTdGFydCh0ci5kb2MpO1xuICAgICAgICAgICAgaWYgKCFzZWwuZXEodHIuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLnJlcGxhY2UodHIsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHsgcmV0dXJuIHsgdHlwZTogXCJhbGxcIiB9OyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7IH1cbiAgICBtYXAoZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7IH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb247IH1cbiAgICBnZXRCb29rbWFyaygpIHsgcmV0dXJuIEFsbEJvb2ttYXJrOyB9XG59XG5TZWxlY3Rpb24uanNvbklEKFwiYWxsXCIsIEFsbFNlbGVjdGlvbik7XG5jb25zdCBBbGxCb29rbWFyayA9IHtcbiAgICBtYXAoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgIHJlc29sdmUoZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7IH1cbn07XG4vLyBGSVhNRSB3ZSdsbCBuZWVkIHNvbWUgYXdhcmVuZXNzIG9mIHRleHQgZGlyZWN0aW9uIHdoZW4gc2Nhbm5pbmcgZm9yIHNlbGVjdGlvbnNcbi8vIFRyeSB0byBmaW5kIGEgc2VsZWN0aW9uIGluc2lkZSB0aGUgZ2l2ZW4gbm9kZS4gYHBvc2AgcG9pbnRzIGF0IHRoZVxuLy8gcG9zaXRpb24gd2hlcmUgdGhlIHNlYXJjaCBzdGFydHMuIFdoZW4gYHRleHRgIGlzIHRydWUsIG9ubHkgcmV0dXJuXG4vLyB0ZXh0IHNlbGVjdGlvbnMuXG5mdW5jdGlvbiBmaW5kU2VsZWN0aW9uSW4oZG9jLCBub2RlLCBwb3MsIGluZGV4LCBkaXIsIHRleHQgPSBmYWxzZSkge1xuICAgIGlmIChub2RlLmlubGluZUNvbnRlbnQpXG4gICAgICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHBvcyk7XG4gICAgZm9yIChsZXQgaSA9IGluZGV4IC0gKGRpciA+IDAgPyAwIDogMSk7IGRpciA+IDAgPyBpIDwgbm9kZS5jaGlsZENvdW50IDogaSA+PSAwOyBpICs9IGRpcikge1xuICAgICAgICBsZXQgY2hpbGQgPSBub2RlLmNoaWxkKGkpO1xuICAgICAgICBpZiAoIWNoaWxkLmlzQXRvbSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gZmluZFNlbGVjdGlvbkluKGRvYywgY2hpbGQsIHBvcyArIGRpciwgZGlyIDwgMCA/IGNoaWxkLmNoaWxkQ291bnQgOiAwLCBkaXIsIHRleHQpO1xuICAgICAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGV4dCAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShjaGlsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIHBvcyAtIChkaXIgPCAwID8gY2hpbGQubm9kZVNpemUgOiAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGNoaWxkLm5vZGVTaXplICogZGlyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBzdGFydExlbiwgYmlhcykge1xuICAgIGxldCBsYXN0ID0gdHIuc3RlcHMubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA8IHN0YXJ0TGVuKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHN0ZXAgPSB0ci5zdGVwc1tsYXN0XTtcbiAgICBpZiAoIShzdGVwIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXAgfHwgc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VBcm91bmRTdGVwKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbbGFzdF0sIGVuZDtcbiAgICBtYXAuZm9yRWFjaCgoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSA9PiB7IGlmIChlbmQgPT0gbnVsbClcbiAgICAgICAgZW5kID0gbmV3VG87IH0pO1xuICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShlbmQpLCBiaWFzKSk7XG59XG5cbmNvbnN0IFVQREFURURfU0VMID0gMSwgVVBEQVRFRF9NQVJLUyA9IDIsIFVQREFURURfU0NST0xMID0gNDtcbi8qKlxuQW4gZWRpdG9yIHN0YXRlIHRyYW5zYWN0aW9uLCB3aGljaCBjYW4gYmUgYXBwbGllZCB0byBhIHN0YXRlIHRvXG5jcmVhdGUgYW4gdXBkYXRlZCBzdGF0ZS4gVXNlXG5bYEVkaXRvclN0YXRlLnRyYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRyKSB0byBjcmVhdGUgYW4gaW5zdGFuY2UuXG5cblRyYW5zYWN0aW9ucyB0cmFjayBjaGFuZ2VzIHRvIHRoZSBkb2N1bWVudCAodGhleSBhcmUgYSBzdWJjbGFzcyBvZlxuW2BUcmFuc2Zvcm1gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlRyYW5zZm9ybSkpLCBidXQgYWxzbyBvdGhlciBzdGF0ZSBjaGFuZ2VzLFxubGlrZSBzZWxlY3Rpb24gdXBkYXRlcyBhbmQgYWRqdXN0bWVudHMgb2YgdGhlIHNldCBvZiBbc3RvcmVkXG5tYXJrc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnN0b3JlZE1hcmtzKS4gSW4gYWRkaXRpb24sIHlvdSBjYW4gc3RvcmVcbm1ldGFkYXRhIHByb3BlcnRpZXMgaW4gYSB0cmFuc2FjdGlvbiwgd2hpY2ggYXJlIGV4dHJhIHBpZWNlcyBvZlxuaW5mb3JtYXRpb24gdGhhdCBjbGllbnQgY29kZSBvciBwbHVnaW5zIGNhbiB1c2UgdG8gZGVzY3JpYmUgd2hhdCBhXG50cmFuc2FjdGlvbiByZXByZXNlbnRzLCBzbyB0aGF0IHRoZXkgY2FuIHVwZGF0ZSB0aGVpciBbb3duXG5zdGF0ZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRmllbGQpIGFjY29yZGluZ2x5LlxuXG5UaGUgW2VkaXRvciB2aWV3XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3KSB1c2VzIGEgZmV3IG1ldGFkYXRhXG5wcm9wZXJ0aWVzOiBpdCB3aWxsIGF0dGFjaCBhIHByb3BlcnR5IGBcInBvaW50ZXJcImAgd2l0aCB0aGUgdmFsdWVcbmB0cnVlYCB0byBzZWxlY3Rpb24gdHJhbnNhY3Rpb25zIGRpcmVjdGx5IGNhdXNlZCBieSBtb3VzZSBvciB0b3VjaFxuaW5wdXQsIGEgYFwiY29tcG9zaXRpb25cImAgcHJvcGVydHkgaG9sZGluZyBhbiBJRCBpZGVudGlmeWluZyB0aGVcbmNvbXBvc2l0aW9uIHRoYXQgY2F1c2VkIGl0IHRvIHRyYW5zYWN0aW9ucyBjYXVzZWQgYnkgY29tcG9zZWQgRE9NXG5pbnB1dCwgYW5kIGEgYFwidWlFdmVudFwiYCBwcm9wZXJ0eSBvZiB0aGF0IG1heSBiZSBgXCJwYXN0ZVwiYCxcbmBcImN1dFwiYCwgb3IgYFwiZHJvcFwiYC5cbiovXG5jbGFzcyBUcmFuc2FjdGlvbiBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdGF0ZSkge1xuICAgICAgICBzdXBlcihzdGF0ZS5kb2MpO1xuICAgICAgICAvLyBUaGUgc3RlcCBjb3VudCBmb3Igd2hpY2ggdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIHZhbGlkLlxuICAgICAgICB0aGlzLmN1clNlbGVjdGlvbkZvciA9IDA7XG4gICAgICAgIC8vIEJpdGZpZWxkIHRvIHRyYWNrIHdoaWNoIGFzcGVjdHMgb2YgdGhlIHN0YXRlIHdlcmUgdXBkYXRlZCBieVxuICAgICAgICAvLyB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAgICB0aGlzLnVwZGF0ZWQgPSAwO1xuICAgICAgICAvLyBPYmplY3QgdXNlZCB0byBzdG9yZSBtZXRhZGF0YSBwcm9wZXJ0aWVzIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgIHRoaXMubWV0YSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMudGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLnN0b3JlZE1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSB0cmFuc2FjdGlvbidzIGN1cnJlbnQgc2VsZWN0aW9uLiBUaGlzIGRlZmF1bHRzIHRvIHRoZSBlZGl0b3JcbiAgICBzZWxlY3Rpb24gW21hcHBlZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvbi5tYXApIHRocm91Z2ggdGhlIHN0ZXBzIGluIHRoZVxuICAgIHRyYW5zYWN0aW9uLCBidXQgY2FuIGJlIG92ZXJ3cml0dGVuIHdpdGhcbiAgICBbYHNldFNlbGVjdGlvbmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zZXRTZWxlY3Rpb24pLlxuICAgICovXG4gICAgZ2V0IHNlbGVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyU2VsZWN0aW9uRm9yIDwgdGhpcy5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uID0gdGhpcy5jdXJTZWxlY3Rpb24ubWFwKHRoaXMuZG9jLCB0aGlzLm1hcHBpbmcuc2xpY2UodGhpcy5jdXJTZWxlY3Rpb25Gb3IpKTtcbiAgICAgICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uRm9yID0gdGhpcy5zdGVwcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyU2VsZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHRyYW5zYWN0aW9uJ3MgY3VycmVudCBzZWxlY3Rpb24uIFdpbGwgZGV0ZXJtaW5lIHRoZVxuICAgIHNlbGVjdGlvbiB0aGF0IHRoZSBlZGl0b3IgZ2V0cyB3aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyBhcHBsaWVkLlxuICAgICovXG4gICAgc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAoc2VsZWN0aW9uLiRmcm9tLmRvYyAhPSB0aGlzLmRvYylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2VsZWN0aW9uIHBhc3NlZCB0byBzZXRTZWxlY3Rpb24gbXVzdCBwb2ludCBhdCB0aGUgY3VycmVudCBkb2N1bWVudFwiKTtcbiAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uRm9yID0gdGhpcy5zdGVwcy5sZW5ndGg7XG4gICAgICAgIHRoaXMudXBkYXRlZCA9ICh0aGlzLnVwZGF0ZWQgfCBVUERBVEVEX1NFTCkgJiB+VVBEQVRFRF9NQVJLUztcbiAgICAgICAgdGhpcy5zdG9yZWRNYXJrcyA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gd2FzIGV4cGxpY2l0bHkgdXBkYXRlZCBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZ2V0IHNlbGVjdGlvblNldCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnVwZGF0ZWQgJiBVUERBVEVEX1NFTCkgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIGN1cnJlbnQgc3RvcmVkIG1hcmtzLlxuICAgICovXG4gICAgc2V0U3RvcmVkTWFya3MobWFya3MpIHtcbiAgICAgICAgdGhpcy5zdG9yZWRNYXJrcyA9IG1hcmtzO1xuICAgICAgICB0aGlzLnVwZGF0ZWQgfD0gVVBEQVRFRF9NQVJLUztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIE1ha2Ugc3VyZSB0aGUgY3VycmVudCBzdG9yZWQgbWFya3Mgb3IsIGlmIHRoYXQgaXMgbnVsbCwgdGhlIG1hcmtzXG4gICAgYXQgdGhlIHNlbGVjdGlvbiwgbWF0Y2ggdGhlIGdpdmVuIHNldCBvZiBtYXJrcy4gRG9lcyBub3RoaW5nIGlmXG4gICAgdGhpcyBpcyBhbHJlYWR5IHRoZSBjYXNlLlxuICAgICovXG4gICAgZW5zdXJlTWFya3MobWFya3MpIHtcbiAgICAgICAgaWYgKCFNYXJrLnNhbWVTZXQodGhpcy5zdG9yZWRNYXJrcyB8fCB0aGlzLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpLCBtYXJrcykpXG4gICAgICAgICAgICB0aGlzLnNldFN0b3JlZE1hcmtzKG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIG1hcmsgdG8gdGhlIHNldCBvZiBzdG9yZWQgbWFya3MuXG4gICAgKi9cbiAgICBhZGRTdG9yZWRNYXJrKG1hcmspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlTWFya3MobWFyay5hZGRUb1NldCh0aGlzLnN0b3JlZE1hcmtzIHx8IHRoaXMuc2VsZWN0aW9uLiRoZWFkLm1hcmtzKCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIGEgbWFyayBvciBtYXJrIHR5cGUgZnJvbSB0aGUgc2V0IG9mIHN0b3JlZCBtYXJrcy5cbiAgICAqL1xuICAgIHJlbW92ZVN0b3JlZE1hcmsobWFyaykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVNYXJrcyhtYXJrLnJlbW92ZUZyb21TZXQodGhpcy5zdG9yZWRNYXJrcyB8fCB0aGlzLnNlbGVjdGlvbi4kaGVhZC5tYXJrcygpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHN0b3JlZCBtYXJrcyB3ZXJlIGV4cGxpY2l0bHkgc2V0IGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZ2V0IHN0b3JlZE1hcmtzU2V0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudXBkYXRlZCAmIFVQREFURURfTUFSS1MpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRTdGVwKHN0ZXAsIGRvYykge1xuICAgICAgICBzdXBlci5hZGRTdGVwKHN0ZXAsIGRvYyk7XG4gICAgICAgIHRoaXMudXBkYXRlZCA9IHRoaXMudXBkYXRlZCAmIH5VUERBVEVEX01BUktTO1xuICAgICAgICB0aGlzLnN0b3JlZE1hcmtzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB0aW1lc3RhbXAgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHNldFRpbWUodGltZSkge1xuICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgY3VycmVudCBzZWxlY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gc2xpY2UuXG4gICAgKi9cbiAgICByZXBsYWNlU2VsZWN0aW9uKHNsaWNlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnJlcGxhY2UodGhpcywgc2xpY2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIG5vZGUuIFdoZW4gYGluaGVyaXRNYXJrc2AgaXNcbiAgICB0cnVlIGFuZCB0aGUgY29udGVudCBpcyBpbmxpbmUsIGl0IGluaGVyaXRzIHRoZSBtYXJrcyBmcm9tIHRoZVxuICAgIHBsYWNlIHdoZXJlIGl0IGlzIGluc2VydGVkLlxuICAgICovXG4gICAgcmVwbGFjZVNlbGVjdGlvbldpdGgobm9kZSwgaW5oZXJpdE1hcmtzID0gdHJ1ZSkge1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XG4gICAgICAgIGlmIChpbmhlcml0TWFya3MpXG4gICAgICAgICAgICBub2RlID0gbm9kZS5tYXJrKHRoaXMuc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi5lbXB0eSA/IHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpIDogKHNlbGVjdGlvbi4kZnJvbS5tYXJrc0Fjcm9zcyhzZWxlY3Rpb24uJHRvKSB8fCBNYXJrLm5vbmUpKSk7XG4gICAgICAgIHNlbGVjdGlvbi5yZXBsYWNlV2l0aCh0aGlzLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSB0aGUgc2VsZWN0aW9uLlxuICAgICovXG4gICAgZGVsZXRlU2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5yZXBsYWNlKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgZ2l2ZW4gcmFuZ2UsIG9yIHRoZSBzZWxlY3Rpb24gaWYgbm8gcmFuZ2UgaXMgZ2l2ZW4sXG4gICAgd2l0aCBhIHRleHQgbm9kZSBjb250YWluaW5nIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICBpbnNlcnRUZXh0KHRleHQsIGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBzY2hlbWEgPSB0aGlzLmRvYy50eXBlLnNjaGVtYTtcbiAgICAgICAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCF0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVNlbGVjdGlvbldpdGgoc2NoZW1hLnRleHQodGV4dCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICAgICAgdG8gPSBmcm9tO1xuICAgICAgICAgICAgdG8gPSB0byA9PSBudWxsID8gZnJvbSA6IHRvO1xuICAgICAgICAgICAgaWYgKCF0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9IHRoaXMuc3RvcmVkTWFya3M7XG4gICAgICAgICAgICBpZiAoIW1hcmtzKSB7XG4gICAgICAgICAgICAgICAgbGV0ICRmcm9tID0gdGhpcy5kb2MucmVzb2x2ZShmcm9tKTtcbiAgICAgICAgICAgICAgICBtYXJrcyA9IHRvID09IGZyb20gPyAkZnJvbS5tYXJrcygpIDogJGZyb20ubWFya3NBY3Jvc3ModGhpcy5kb2MucmVzb2x2ZSh0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBzY2hlbWEudGV4dCh0ZXh0LCBtYXJrcykpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5lbXB0eSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0aGlzLnNlbGVjdGlvbi4kdG8pKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFN0b3JlIGEgbWV0YWRhdGEgcHJvcGVydHkgaW4gdGhpcyB0cmFuc2FjdGlvbiwga2V5ZWQgZWl0aGVyIGJ5XG4gICAgbmFtZSBvciBieSBwbHVnaW4uXG4gICAgKi9cbiAgICBzZXRNZXRhKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5tZXRhW3R5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiA/IGtleSA6IGtleS5rZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSBhIG1ldGFkYXRhIHByb3BlcnR5IGZvciBhIGdpdmVuIG5hbWUgb3IgcGx1Z2luLlxuICAgICovXG4gICAgZ2V0TWV0YShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YVt0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgPyBrZXkgOiBrZXkua2V5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gZG9lc24ndCBjb250YWluIGFueSBtZXRhZGF0YSxcbiAgICBhbmQgY2FuIHRodXMgc2FmZWx5IGJlIGV4dGVuZGVkLlxuICAgICovXG4gICAgZ2V0IGlzR2VuZXJpYygpIHtcbiAgICAgICAgZm9yIChsZXQgXyBpbiB0aGlzLm1ldGEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZSB0aGF0IHRoZSBlZGl0b3Igc2hvdWxkIHNjcm9sbCB0aGUgc2VsZWN0aW9uIGludG8gdmlld1xuICAgIHdoZW4gdXBkYXRlZCB0byB0aGUgc3RhdGUgcHJvZHVjZWQgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHNjcm9sbEludG9WaWV3KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZWQgfD0gVVBEQVRFRF9TQ1JPTEw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyB0cmFuc2FjdGlvbiBoYXMgaGFkIGBzY3JvbGxJbnRvVmlld2AgY2FsbGVkIG9uIGl0LlxuICAgICovXG4gICAgZ2V0IHNjcm9sbGVkSW50b1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy51cGRhdGVkICYgVVBEQVRFRF9TQ1JPTEwpID4gMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJpbmQoZiwgc2VsZikge1xuICAgIHJldHVybiAhc2VsZiB8fCAhZiA/IGYgOiBmLmJpbmQoc2VsZik7XG59XG5jbGFzcyBGaWVsZERlc2Mge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGRlc2MsIHNlbGYpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pbml0ID0gYmluZChkZXNjLmluaXQsIHNlbGYpO1xuICAgICAgICB0aGlzLmFwcGx5ID0gYmluZChkZXNjLmFwcGx5LCBzZWxmKTtcbiAgICB9XG59XG5jb25zdCBiYXNlRmllbGRzID0gW1xuICAgIG5ldyBGaWVsZERlc2MoXCJkb2NcIiwge1xuICAgICAgICBpbml0KGNvbmZpZykgeyByZXR1cm4gY29uZmlnLmRvYyB8fCBjb25maWcuc2NoZW1hLnRvcE5vZGVUeXBlLmNyZWF0ZUFuZEZpbGwoKTsgfSxcbiAgICAgICAgYXBwbHkodHIpIHsgcmV0dXJuIHRyLmRvYzsgfVxuICAgIH0pLFxuICAgIG5ldyBGaWVsZERlc2MoXCJzZWxlY3Rpb25cIiwge1xuICAgICAgICBpbml0KGNvbmZpZywgaW5zdGFuY2UpIHsgcmV0dXJuIGNvbmZpZy5zZWxlY3Rpb24gfHwgU2VsZWN0aW9uLmF0U3RhcnQoaW5zdGFuY2UuZG9jKTsgfSxcbiAgICAgICAgYXBwbHkodHIpIHsgcmV0dXJuIHRyLnNlbGVjdGlvbjsgfVxuICAgIH0pLFxuICAgIG5ldyBGaWVsZERlc2MoXCJzdG9yZWRNYXJrc1wiLCB7XG4gICAgICAgIGluaXQoY29uZmlnKSB7IHJldHVybiBjb25maWcuc3RvcmVkTWFya3MgfHwgbnVsbDsgfSxcbiAgICAgICAgYXBwbHkodHIsIF9tYXJrcywgX29sZCwgc3RhdGUpIHsgcmV0dXJuIHN0YXRlLnNlbGVjdGlvbi4kY3Vyc29yID8gdHIuc3RvcmVkTWFya3MgOiBudWxsOyB9XG4gICAgfSksXG4gICAgbmV3IEZpZWxkRGVzYyhcInNjcm9sbFRvU2VsZWN0aW9uXCIsIHtcbiAgICAgICAgaW5pdCgpIHsgcmV0dXJuIDA7IH0sXG4gICAgICAgIGFwcGx5KHRyLCBwcmV2KSB7IHJldHVybiB0ci5zY3JvbGxlZEludG9WaWV3ID8gcHJldiArIDEgOiBwcmV2OyB9XG4gICAgfSlcbl07XG4vLyBPYmplY3Qgd3JhcHBpbmcgdGhlIHBhcnQgb2YgYSBzdGF0ZSBvYmplY3QgdGhhdCBzdGF5cyB0aGUgc2FtZVxuLy8gYWNyb3NzIHRyYW5zYWN0aW9ucy4gU3RvcmVkIGluIHRoZSBzdGF0ZSdzIGBjb25maWdgIHByb3BlcnR5LlxuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hLCBwbHVnaW5zKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5wbHVnaW5zQnlLZXkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGJhc2VGaWVsZHMuc2xpY2UoKTtcbiAgICAgICAgaWYgKHBsdWdpbnMpXG4gICAgICAgICAgICBwbHVnaW5zLmZvckVhY2gocGx1Z2luID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wbHVnaW5zQnlLZXlbcGx1Z2luLmtleV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQWRkaW5nIGRpZmZlcmVudCBpbnN0YW5jZXMgb2YgYSBrZXllZCBwbHVnaW4gKFwiICsgcGx1Z2luLmtleSArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luc0J5S2V5W3BsdWdpbi5rZXldID0gcGx1Z2luO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy5zdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWVsZHMucHVzaChuZXcgRmllbGREZXNjKHBsdWdpbi5rZXksIHBsdWdpbi5zcGVjLnN0YXRlLCBwbHVnaW4pKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuVGhlIHN0YXRlIG9mIGEgUHJvc2VNaXJyb3IgZWRpdG9yIGlzIHJlcHJlc2VudGVkIGJ5IGFuIG9iamVjdCBvZlxudGhpcyB0eXBlLiBBIHN0YXRlIGlzIGEgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZVx1MjAxNGl0IGlzbid0XG51cGRhdGVkLCBidXQgcmF0aGVyIGEgbmV3IHN0YXRlIHZhbHVlIGlzIGNvbXB1dGVkIGZyb20gYW4gb2xkIG9uZVxudXNpbmcgdGhlIFtgYXBwbHlgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuYXBwbHkpIG1ldGhvZC5cblxuQSBzdGF0ZSBob2xkcyBhIG51bWJlciBvZiBidWlsdC1pbiBmaWVsZHMsIGFuZCBwbHVnaW5zIGNhblxuW2RlZmluZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlBsdWdpblNwZWMuc3RhdGUpIGFkZGl0aW9uYWwgZmllbGRzLlxuKi9cbmNsYXNzIEVkaXRvclN0YXRlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2NoZW1hIG9mIHRoZSBzdGF0ZSdzIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnNjaGVtYTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHBsdWdpbnMgdGhhdCBhcmUgYWN0aXZlIGluIHRoaXMgc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgcGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnBsdWdpbnM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGx5IHRoZSBnaXZlbiB0cmFuc2FjdGlvbiB0byBwcm9kdWNlIGEgbmV3IHN0YXRlLlxuICAgICovXG4gICAgYXBwbHkodHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUcmFuc2FjdGlvbih0cikuc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmlsdGVyVHJhbnNhY3Rpb24odHIsIGlnbm9yZSA9IC0xKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChpICE9IGlnbm9yZSkge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLmNvbmZpZy5wbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy5maWx0ZXJUcmFuc2FjdGlvbiAmJiAhcGx1Z2luLnNwZWMuZmlsdGVyVHJhbnNhY3Rpb24uY2FsbChwbHVnaW4sIHRyLCB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVmVyYm9zZSB2YXJpYW50IG9mIFtgYXBwbHlgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuYXBwbHkpIHRoYXRcbiAgICByZXR1cm5zIHRoZSBwcmVjaXNlIHRyYW5zYWN0aW9ucyB0aGF0IHdlcmUgYXBwbGllZCAod2hpY2ggbWlnaHRcbiAgICBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBbdHJhbnNhY3Rpb25cbiAgICBob29rc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlBsdWdpblNwZWMuZmlsdGVyVHJhbnNhY3Rpb24pIG9mXG4gICAgcGx1Z2lucykgYWxvbmcgd2l0aCB0aGUgbmV3IHN0YXRlLlxuICAgICovXG4gICAgYXBwbHlUcmFuc2FjdGlvbihyb290VHIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbHRlclRyYW5zYWN0aW9uKHJvb3RUcikpXG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogdGhpcywgdHJhbnNhY3Rpb25zOiBbXSB9O1xuICAgICAgICBsZXQgdHJzID0gW3Jvb3RUcl0sIG5ld1N0YXRlID0gdGhpcy5hcHBseUlubmVyKHJvb3RUciksIHNlZW4gPSBudWxsO1xuICAgICAgICAvLyBUaGlzIGxvb3AgcmVwZWF0ZWRseSBnaXZlcyBwbHVnaW5zIGEgY2hhbmNlIHRvIHJlc3BvbmQgdG9cbiAgICAgICAgLy8gdHJhbnNhY3Rpb25zIGFzIG5ldyB0cmFuc2FjdGlvbnMgYXJlIGFkZGVkLCBtYWtpbmcgc3VyZSB0byBvbmx5XG4gICAgICAgIC8vIHBhc3MgdGhlIHRyYW5zYWN0aW9ucyB0aGUgcGx1Z2luIGRpZCBub3Qgc2VlIGJlZm9yZS5cbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGhhdmVOZXcgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLmNvbmZpZy5wbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy5hcHBlbmRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbiA9IHNlZW4gPyBzZWVuW2ldLm4gOiAwLCBvbGRTdGF0ZSA9IHNlZW4gPyBzZWVuW2ldLnN0YXRlIDogdGhpcztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyID0gbiA8IHRycy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uLmNhbGwocGx1Z2luLCBuID8gdHJzLnNsaWNlKG4pIDogdHJzLCBvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHIgJiYgbmV3U3RhdGUuZmlsdGVyVHJhbnNhY3Rpb24odHIsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwiYXBwZW5kZWRUcmFuc2FjdGlvblwiLCByb290VHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vlbi5wdXNoKGogPCBpID8geyBzdGF0ZTogbmV3U3RhdGUsIG46IHRycy5sZW5ndGggfSA6IHsgc3RhdGU6IHRoaXMsIG46IDAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnMucHVzaCh0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlLmFwcGx5SW5uZXIodHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZU5ldyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuW2ldID0geyBzdGF0ZTogbmV3U3RhdGUsIG46IHRycy5sZW5ndGggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhdmVOZXcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IG5ld1N0YXRlLCB0cmFuc2FjdGlvbnM6IHRycyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYXBwbHlJbm5lcih0cikge1xuICAgICAgICBpZiAoIXRyLmJlZm9yZS5lcSh0aGlzLmRvYykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFwcGx5aW5nIGEgbWlzbWF0Y2hlZCB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgbGV0IG5ld0luc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKHRoaXMuY29uZmlnKSwgZmllbGRzID0gdGhpcy5jb25maWcuZmllbGRzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICAgICAgbmV3SW5zdGFuY2VbZmllbGQubmFtZV0gPSBmaWVsZC5hcHBseSh0ciwgdGhpc1tmaWVsZC5uYW1lXSwgdGhpcywgbmV3SW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdJbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgU3RhcnQgYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbikgZnJvbSB0aGlzIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IHRyKCkgeyByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHRoaXMpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHN0YXRlLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcpIHtcbiAgICAgICAgbGV0ICRjb25maWcgPSBuZXcgQ29uZmlndXJhdGlvbihjb25maWcuZG9jID8gY29uZmlnLmRvYy50eXBlLnNjaGVtYSA6IGNvbmZpZy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKCRjb25maWcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICRjb25maWcuZmllbGRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaW5zdGFuY2VbJGNvbmZpZy5maWVsZHNbaV0ubmFtZV0gPSAkY29uZmlnLmZpZWxkc1tpXS5pbml0KGNvbmZpZywgaW5zdGFuY2UpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBzdGF0ZSBiYXNlZCBvbiB0aGlzIG9uZSwgYnV0IHdpdGggYW4gYWRqdXN0ZWQgc2V0XG4gICAgb2YgYWN0aXZlIHBsdWdpbnMuIFN0YXRlIGZpZWxkcyB0aGF0IGV4aXN0IGluIGJvdGggc2V0cyBvZlxuICAgIHBsdWdpbnMgYXJlIGtlcHQgdW5jaGFuZ2VkLiBUaG9zZSB0aGF0IG5vIGxvbmdlciBleGlzdCBhcmVcbiAgICBkcm9wcGVkLCBhbmQgdGhvc2UgdGhhdCBhcmUgbmV3IGFyZSBpbml0aWFsaXplZCB1c2luZyB0aGVpclxuICAgIFtgaW5pdGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUZpZWxkLmluaXQpIG1ldGhvZCwgcGFzc2luZyBpbiB0aGUgbmV3XG4gICAgY29uZmlndXJhdGlvbiBvYmplY3QuLlxuICAgICovXG4gICAgcmVjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIGxldCAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24odGhpcy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgICAgICAgbGV0IGZpZWxkcyA9ICRjb25maWcuZmllbGRzLCBpbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSgkY29uZmlnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gZmllbGRzW2ldLm5hbWU7XG4gICAgICAgICAgICBpbnN0YW5jZVtuYW1lXSA9IHRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyB0aGlzW25hbWVdIDogZmllbGRzW2ldLmluaXQoY29uZmlnLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBzdGF0ZSB0byBKU09OLiBJZiB5b3Ugd2FudCB0byBzZXJpYWxpemUgdGhlIHN0YXRlXG4gICAgb2YgcGx1Z2lucywgcGFzcyBhbiBvYmplY3QgbWFwcGluZyBwcm9wZXJ0eSBuYW1lcyB0byB1c2UgaW4gdGhlXG4gICAgcmVzdWx0aW5nIEpTT04gb2JqZWN0IHRvIHBsdWdpbiBvYmplY3RzLiBUaGUgYXJndW1lbnQgbWF5IGFsc28gYmVcbiAgICBhIHN0cmluZyBvciBudW1iZXIsIGluIHdoaWNoIGNhc2UgaXQgaXMgaWdub3JlZCwgdG8gc3VwcG9ydCB0aGVcbiAgICB3YXkgYEpTT04uc3RyaW5naWZ5YCBjYWxscyBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gICAgKi9cbiAgICB0b0pTT04ocGx1Z2luRmllbGRzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IGRvYzogdGhpcy5kb2MudG9KU09OKCksIHNlbGVjdGlvbjogdGhpcy5zZWxlY3Rpb24udG9KU09OKCkgfTtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmVkTWFya3MpXG4gICAgICAgICAgICByZXN1bHQuc3RvcmVkTWFya3MgPSB0aGlzLnN0b3JlZE1hcmtzLm1hcChtID0+IG0udG9KU09OKCkpO1xuICAgICAgICBpZiAocGx1Z2luRmllbGRzICYmIHR5cGVvZiBwbHVnaW5GaWVsZHMgPT0gJ29iamVjdCcpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHBsdWdpbkZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09IFwiZG9jXCIgfHwgcHJvcCA9PSBcInNlbGVjdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBKU09OIGZpZWxkcyBgZG9jYCBhbmQgYHNlbGVjdGlvbmAgYXJlIHJlc2VydmVkXCIpO1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSBwbHVnaW5GaWVsZHNbcHJvcF0sIHN0YXRlID0gcGx1Z2luLnNwZWMuc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLnRvSlNPTilcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gc3RhdGUudG9KU09OLmNhbGwocGx1Z2luLCB0aGlzW3BsdWdpbi5rZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgc3RhdGUuIGBjb25maWdgIHNob3VsZFxuICAgIGhhdmUgYXQgbGVhc3QgYSBgc2NoZW1hYCBmaWVsZCwgYW5kIHNob3VsZCBjb250YWluIGFycmF5IG9mXG4gICAgcGx1Z2lucyB0byBpbml0aWFsaXplIHRoZSBzdGF0ZSB3aXRoLiBgcGx1Z2luRmllbGRzYCBjYW4gYmUgdXNlZFxuICAgIHRvIGRlc2VyaWFsaXplIHRoZSBzdGF0ZSBvZiBwbHVnaW5zLCBieSBhc3NvY2lhdGluZyBwbHVnaW5cbiAgICBpbnN0YW5jZXMgd2l0aCB0aGUgcHJvcGVydHkgbmFtZXMgdGhleSB1c2UgaW4gdGhlIEpTT04gb2JqZWN0LlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGNvbmZpZywganNvbiwgcGx1Z2luRmllbGRzKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgRWRpdG9yU3RhdGUuZnJvbUpTT05cIik7XG4gICAgICAgIGlmICghY29uZmlnLnNjaGVtYSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVxdWlyZWQgY29uZmlnIGZpZWxkICdzY2hlbWEnIG1pc3NpbmdcIik7XG4gICAgICAgIGxldCAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24oY29uZmlnLnNjaGVtYSwgY29uZmlnLnBsdWdpbnMpO1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBuZXcgRWRpdG9yU3RhdGUoJGNvbmZpZyk7XG4gICAgICAgICRjb25maWcuZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgPT0gXCJkb2NcIikge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRvYyA9IE5vZGUuZnJvbUpTT04oY29uZmlnLnNjaGVtYSwganNvbi5kb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQubmFtZSA9PSBcInNlbGVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2VsZWN0aW9uID0gU2VsZWN0aW9uLmZyb21KU09OKGluc3RhbmNlLmRvYywganNvbi5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQubmFtZSA9PSBcInN0b3JlZE1hcmtzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoanNvbi5zdG9yZWRNYXJrcylcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RvcmVkTWFya3MgPSBqc29uLnN0b3JlZE1hcmtzLm1hcChjb25maWcuc2NoZW1hLm1hcmtGcm9tSlNPTik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luRmllbGRzKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHBsdWdpbkZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHBsdWdpbkZpZWxkc1twcm9wXSwgc3RhdGUgPSBwbHVnaW4uc3BlYy5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ua2V5ID09IGZpZWxkLm5hbWUgJiYgc3RhdGUgJiYgc3RhdGUuZnJvbUpTT04gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoanNvbiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVtmaWVsZC5uYW1lXSA9IHN0YXRlLmZyb21KU09OLmNhbGwocGx1Z2luLCBjb25maWcsIGpzb25bcHJvcF0sIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0YW5jZVtmaWVsZC5uYW1lXSA9IGZpZWxkLmluaXQoY29uZmlnLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBiaW5kUHJvcHMob2JqLCBzZWxmLCB0YXJnZXQpIHtcbiAgICBmb3IgKGxldCBwcm9wIGluIG9iaikge1xuICAgICAgICBsZXQgdmFsID0gb2JqW3Byb3BdO1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgICAgICB2YWwgPSB2YWwuYmluZChzZWxmKTtcbiAgICAgICAgZWxzZSBpZiAocHJvcCA9PSBcImhhbmRsZURPTUV2ZW50c1wiKVxuICAgICAgICAgICAgdmFsID0gYmluZFByb3BzKHZhbCwgc2VsZiwge30pO1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG4vKipcblBsdWdpbnMgYnVuZGxlIGZ1bmN0aW9uYWxpdHkgdGhhdCBjYW4gYmUgYWRkZWQgdG8gYW4gZWRpdG9yLlxuVGhleSBhcmUgcGFydCBvZiB0aGUgW2VkaXRvciBzdGF0ZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlKSBhbmRcbm1heSBpbmZsdWVuY2UgdGhhdCBzdGF0ZSBhbmQgdGhlIHZpZXcgdGhhdCBjb250YWlucyBpdC5cbiovXG5jbGFzcyBQbHVnaW4ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBsdWdpbi5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwbHVnaW4ncyBbc3BlYyBvYmplY3RdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5QbHVnaW5TcGVjKS5cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBbcHJvcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzKSBleHBvcnRlZCBieSB0aGlzIHBsdWdpbi5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9wcyA9IHt9O1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGJpbmRQcm9wcyhzcGVjLnByb3BzLCB0aGlzLCB0aGlzLnByb3BzKTtcbiAgICAgICAgdGhpcy5rZXkgPSBzcGVjLmtleSA/IHNwZWMua2V5LmtleSA6IGNyZWF0ZUtleShcInBsdWdpblwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0cmFjdCB0aGUgcGx1Z2luJ3Mgc3RhdGUgZmllbGQgZnJvbSBhbiBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBnZXRTdGF0ZShzdGF0ZSkgeyByZXR1cm4gc3RhdGVbdGhpcy5rZXldOyB9XG59XG5jb25zdCBrZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGNyZWF0ZUtleShuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW4ga2V5cylcbiAgICAgICAgcmV0dXJuIG5hbWUgKyBcIiRcIiArICsra2V5c1tuYW1lXTtcbiAgICBrZXlzW25hbWVdID0gMDtcbiAgICByZXR1cm4gbmFtZSArIFwiJFwiO1xufVxuLyoqXG5BIGtleSBpcyB1c2VkIHRvIFt0YWddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5QbHVnaW5TcGVjLmtleSkgcGx1Z2lucyBpbiBhIHdheVxudGhhdCBtYWtlcyBpdCBwb3NzaWJsZSB0byBmaW5kIHRoZW0sIGdpdmVuIGFuIGVkaXRvciBzdGF0ZS5cbkFzc2lnbmluZyBhIGtleSBkb2VzIG1lYW4gb25seSBvbmUgcGx1Z2luIG9mIHRoYXQgdHlwZSBjYW4gYmVcbmFjdGl2ZSBpbiBhIHN0YXRlLlxuKi9cbmNsYXNzIFBsdWdpbktleSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGx1Z2luIGtleS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUgPSBcImtleVwiKSB7IHRoaXMua2V5ID0gY3JlYXRlS2V5KG5hbWUpOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBhY3RpdmUgcGx1Z2luIHdpdGggdGhpcyBrZXksIGlmIGFueSwgZnJvbSBhbiBlZGl0b3JcbiAgICBzdGF0ZS5cbiAgICAqL1xuICAgIGdldChzdGF0ZSkgeyByZXR1cm4gc3RhdGUuY29uZmlnLnBsdWdpbnNCeUtleVt0aGlzLmtleV07IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHBsdWdpbidzIHN0YXRlIGZyb20gYW4gZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgZ2V0U3RhdGUoc3RhdGUpIHsgcmV0dXJuIHN0YXRlW3RoaXMua2V5XTsgfVxufVxuXG5leHBvcnQgeyBBbGxTZWxlY3Rpb24sIEVkaXRvclN0YXRlLCBOb2RlU2VsZWN0aW9uLCBQbHVnaW4sIFBsdWdpbktleSwgU2VsZWN0aW9uLCBTZWxlY3Rpb25SYW5nZSwgVGV4dFNlbGVjdGlvbiwgVHJhbnNhY3Rpb24gfTtcbiIsICJpbXBvcnQgeyBsaWZ0VGFyZ2V0LCByZXBsYWNlU3RlcCwgUmVwbGFjZVN0ZXAsIGNhbkpvaW4sIGpvaW5Qb2ludCwgY2FuU3BsaXQsIFJlcGxhY2VBcm91bmRTdGVwLCBmaW5kV3JhcHBpbmcgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgU2xpY2UsIEZyYWdtZW50IH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiwgU2VsZWN0aW9uLCBUZXh0U2VsZWN0aW9uLCBBbGxTZWxlY3Rpb24gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5cbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIGlmIHRoZXJlIGlzIG9uZS5cbiovXG5jb25zdCBkZWxldGVTZWxlY3Rpb24gPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlU2VsZWN0aW9uKCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gYXRCbG9ja1N0YXJ0KHN0YXRlLCB2aWV3KSB7XG4gICAgbGV0IHsgJGN1cnNvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGN1cnNvciB8fCAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiYmFja3dhcmRcIiwgc3RhdGUpXG4gICAgICAgIDogJGN1cnNvci5wYXJlbnRPZmZzZXQgPiAwKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuICRjdXJzb3I7XG59XG4vKipcbklmIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jaywgdHJ5IHRvXG5yZWR1Y2UgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhhdCBibG9jayBhbmQgdGhlIG9uZSBiZWZvcmUgaXRcdTIwMTRpZlxudGhlcmUncyBhIGJsb2NrIGRpcmVjdGx5IGJlZm9yZSBpdCB0aGF0IGNhbiBiZSBqb2luZWQsIGpvaW4gdGhlbS5cbklmIG5vdCwgdHJ5IHRvIG1vdmUgdGhlIHNlbGVjdGVkIGJsb2NrIGNsb3NlciB0byB0aGUgbmV4dCBvbmUgaW5cbnRoZSBkb2N1bWVudCBzdHJ1Y3R1cmUgYnkgbGlmdGluZyBpdCBvdXQgb2YgaXRzIHBhcmVudCBvciBtb3ZpbmcgaXRcbmludG8gYSBwYXJlbnQgb2YgdGhlIHByZXZpb3VzIGJsb2NrLiBXaWxsIHVzZSB0aGUgdmlldyBmb3IgYWNjdXJhdGVcbihiaWRpLWF3YXJlKSBzdGFydC1vZi10ZXh0YmxvY2sgZGV0ZWN0aW9uIGlmIGdpdmVuLlxuKi9cbmNvbnN0IGpvaW5CYWNrd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRjdXJzb3IpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIG5vZGUgYmVmb3JlIHRoaXMsIHRyeSB0byBsaWZ0XG4gICAgaWYgKCEkY3V0KSB7XG4gICAgICAgIGxldCByYW5nZSA9ICRjdXJzb3IuYmxvY2tSYW5nZSgpLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGJlZm9yZSA9ICRjdXQubm9kZUJlZm9yZTtcbiAgICAvLyBBcHBseSB0aGUgam9pbmluZyBhbGdvcml0aG1cbiAgICBpZiAoIWJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nICYmIGRlbGV0ZUJhcnJpZXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gSWYgdGhlIG5vZGUgYmVsb3cgaGFzIG5vIGNvbnRlbnQgYW5kIHRoZSBub2RlIGFib3ZlIGlzXG4gICAgLy8gc2VsZWN0YWJsZSwgZGVsZXRlIHRoZSBub2RlIGJlbG93IGFuZCBzZWxlY3QgdGhlIG9uZSBhYm92ZS5cbiAgICBpZiAoJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiZcbiAgICAgICAgKHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIikgfHwgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoYmVmb3JlKSkpIHtcbiAgICAgICAgbGV0IGRlbFN0ZXAgPSByZXBsYWNlU3RlcChzdGF0ZS5kb2MsICRjdXJzb3IuYmVmb3JlKCksICRjdXJzb3IuYWZ0ZXIoKSwgU2xpY2UuZW1wdHkpO1xuICAgICAgICBpZiAoZGVsU3RlcCAmJiBkZWxTdGVwLnNsaWNlLnNpemUgPCBkZWxTdGVwLnRvIC0gZGVsU3RlcC5mcm9tKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKGRlbFN0ZXApO1xuICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbih0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpID8gU2VsZWN0aW9uLmZpbmRGcm9tKHRyLmRvYy5yZXNvbHZlKHRyLm1hcHBpbmcubWFwKCRjdXQucG9zLCAtMSkpLCAtMSlcbiAgICAgICAgICAgICAgICAgICAgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsICRjdXQucG9zIC0gYmVmb3JlLm5vZGVTaXplKSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgbm9kZSBiZWZvcmUgaXMgYW4gYXRvbSwgZGVsZXRlIGl0XG4gICAgaWYgKGJlZm9yZS5pc0F0b20gJiYgJGN1dC5kZXB0aCA9PSAkY3Vyc29yLmRlcHRoIC0gMSkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGUoJGN1dC5wb3MgLSBiZWZvcmUubm9kZVNpemUsICRjdXQucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbkEgbW9yZSBsaW1pdGVkIGZvcm0gb2YgW2Bqb2luQmFja3dhcmRgXSgkY29tbWFuZHMuam9pbkJhY2t3YXJkKVxudGhhdCBvbmx5IHRyaWVzIHRvIGpvaW4gdGhlIGN1cnJlbnQgdGV4dGJsb2NrIHRvIHRoZSBvbmUgYmVmb3JlXG5pdCwgaWYgdGhlIGN1cnNvciBpcyBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2suXG4qL1xuY29uc3Qgam9pblRleHRibG9ja0JhY2t3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCAkY3Vyc29yID0gYXRCbG9ja1N0YXJ0KHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGN1cnNvcik7XG4gICAgcmV0dXJuICRjdXQgPyBqb2luVGV4dGJsb2Nrc0Fyb3VuZChzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpIDogZmFsc2U7XG59O1xuLyoqXG5BIG1vcmUgbGltaXRlZCBmb3JtIG9mIFtgam9pbkZvcndhcmRgXSgkY29tbWFuZHMuam9pbkZvcndhcmQpXG50aGF0IG9ubHkgdHJpZXMgdG8gam9pbiB0aGUgY3VycmVudCB0ZXh0YmxvY2sgdG8gdGhlIG9uZSBhZnRlclxuaXQsIGlmIHRoZSBjdXJzb3IgaXMgYXQgdGhlIGVuZCBvZiBhIHRleHRibG9jay5cbiovXG5jb25zdCBqb2luVGV4dGJsb2NrRm9yd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEFmdGVyKCRjdXJzb3IpO1xuICAgIHJldHVybiAkY3V0ID8gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSA6IGZhbHNlO1xufTtcbmZ1bmN0aW9uIGpvaW5UZXh0YmxvY2tzQXJvdW5kKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkge1xuICAgIGxldCBiZWZvcmUgPSAkY3V0Lm5vZGVCZWZvcmUsIGJlZm9yZVRleHQgPSBiZWZvcmUsIGJlZm9yZVBvcyA9ICRjdXQucG9zIC0gMTtcbiAgICBmb3IgKDsgIWJlZm9yZVRleHQuaXNUZXh0YmxvY2s7IGJlZm9yZVBvcy0tKSB7XG4gICAgICAgIGlmIChiZWZvcmVUZXh0LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBjaGlsZCA9IGJlZm9yZVRleHQubGFzdENoaWxkO1xuICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBiZWZvcmVUZXh0ID0gY2hpbGQ7XG4gICAgfVxuICAgIGxldCBhZnRlciA9ICRjdXQubm9kZUFmdGVyLCBhZnRlclRleHQgPSBhZnRlciwgYWZ0ZXJQb3MgPSAkY3V0LnBvcyArIDE7XG4gICAgZm9yICg7ICFhZnRlclRleHQuaXNUZXh0YmxvY2s7IGFmdGVyUG9zKyspIHtcbiAgICAgICAgaWYgKGFmdGVyVGV4dC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hpbGQgPSBhZnRlclRleHQuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgYWZ0ZXJUZXh0ID0gY2hpbGQ7XG4gICAgfVxuICAgIGxldCBzdGVwID0gcmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCBiZWZvcmVQb3MsIGFmdGVyUG9zLCBTbGljZS5lbXB0eSk7XG4gICAgaWYgKCFzdGVwIHx8IHN0ZXAuZnJvbSAhPSBiZWZvcmVQb3MgfHxcbiAgICAgICAgc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VTdGVwICYmIHN0ZXAuc2xpY2Uuc2l6ZSA+PSBhZnRlclBvcyAtIGJlZm9yZVBvcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKHN0ZXApO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBiZWZvcmVQb3MpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdGV4dGJsb2NrQXQobm9kZSwgc2lkZSwgb25seSA9IGZhbHNlKSB7XG4gICAgZm9yIChsZXQgc2NhbiA9IG5vZGU7IHNjYW47IHNjYW4gPSAoc2lkZSA9PSBcInN0YXJ0XCIgPyBzY2FuLmZpcnN0Q2hpbGQgOiBzY2FuLmxhc3RDaGlsZCkpIHtcbiAgICAgICAgaWYgKHNjYW4uaXNUZXh0YmxvY2spXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG9ubHkgJiYgc2Nhbi5jaGlsZENvdW50ICE9IDEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuV2hlbiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2ssIHNlbGVjdFxudGhlIG5vZGUgYmVmb3JlIHRoYXQgdGV4dGJsb2NrLCBpZiBwb3NzaWJsZS4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuYm91bmQgdG8ga2V5cyBsaWtlIGJhY2tzcGFjZSwgYWZ0ZXJcbltgam9pbkJhY2t3YXJkYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLmpvaW5CYWNrd2FyZCkgb3Igb3RoZXIgZGVsZXRpbmdcbmNvbW1hbmRzLCBhcyBhIGZhbGwtYmFjayBiZWhhdmlvciB3aGVuIHRoZSBzY2hlbWEgZG9lc24ndCBhbGxvd1xuZGVsZXRpb24gYXQgdGhlIHNlbGVjdGVkIHBvaW50LlxuKi9cbmNvbnN0IHNlbGVjdE5vZGVCYWNrd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgeyAkaGVhZCwgZW1wdHkgfSA9IHN0YXRlLnNlbGVjdGlvbiwgJGN1dCA9ICRoZWFkO1xuICAgIGlmICghZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKSB7XG4gICAgICAgIGlmICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJiYWNrd2FyZFwiLCBzdGF0ZSkgOiAkaGVhZC5wYXJlbnRPZmZzZXQgPiAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAkY3V0ID0gZmluZEN1dEJlZm9yZSgkaGVhZCk7XG4gICAgfVxuICAgIGxldCBub2RlID0gJGN1dCAmJiAkY3V0Lm5vZGVCZWZvcmU7XG4gICAgaWYgKCFub2RlIHx8ICFOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgJGN1dC5wb3MgLSBub2RlLm5vZGVTaXplKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZmluZEN1dEJlZm9yZSgkcG9zKSB7XG4gICAgaWYgKCEkcG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoJHBvcy5pbmRleChpKSA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3MuZG9jLnJlc29sdmUoJHBvcy5iZWZvcmUoaSArIDEpKTtcbiAgICAgICAgICAgIGlmICgkcG9zLm5vZGUoaSkudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYXRCbG9ja0VuZChzdGF0ZSwgdmlldykge1xuICAgIGxldCB7ICRjdXJzb3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRjdXJzb3IgfHwgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImZvcndhcmRcIiwgc3RhdGUpXG4gICAgICAgIDogJGN1cnNvci5wYXJlbnRPZmZzZXQgPCAkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gJGN1cnNvcjtcbn1cbi8qKlxuSWYgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgdGhlIGN1cnNvciBpcyBhdCB0aGUgZW5kIG9mIGFcbnRleHRibG9jaywgdHJ5IHRvIHJlZHVjZSBvciByZW1vdmUgdGhlIGJvdW5kYXJ5IGJldHdlZW4gdGhhdCBibG9ja1xuYW5kIHRoZSBvbmUgYWZ0ZXIgaXQsIGVpdGhlciBieSBqb2luaW5nIHRoZW0gb3IgYnkgbW92aW5nIHRoZSBvdGhlclxuYmxvY2sgY2xvc2VyIHRvIHRoaXMgb25lIGluIHRoZSB0cmVlIHN0cnVjdHVyZS4gV2lsbCB1c2UgdGhlIHZpZXdcbmZvciBhY2N1cmF0ZSBzdGFydC1vZi10ZXh0YmxvY2sgZGV0ZWN0aW9uIGlmIGdpdmVuLlxuKi9cbmNvbnN0IGpvaW5Gb3J3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCAkY3Vyc29yID0gYXRCbG9ja0VuZChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QWZ0ZXIoJGN1cnNvcik7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gbm9kZSBhZnRlciB0aGlzLCB0aGVyZSdzIG5vdGhpbmcgdG8gZG9cbiAgICBpZiAoISRjdXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYWZ0ZXIgPSAkY3V0Lm5vZGVBZnRlcjtcbiAgICAvLyBUcnkgdGhlIGpvaW5pbmcgYWxnb3JpdGhtXG4gICAgaWYgKGRlbGV0ZUJhcnJpZXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gSWYgdGhlIG5vZGUgYWJvdmUgaGFzIG5vIGNvbnRlbnQgYW5kIHRoZSBub2RlIGJlbG93IGlzXG4gICAgLy8gc2VsZWN0YWJsZSwgZGVsZXRlIHRoZSBub2RlIGFib3ZlIGFuZCBzZWxlY3QgdGhlIG9uZSBiZWxvdy5cbiAgICBpZiAoJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiZcbiAgICAgICAgKHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIpIHx8IE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGFmdGVyKSkpIHtcbiAgICAgICAgbGV0IGRlbFN0ZXAgPSByZXBsYWNlU3RlcChzdGF0ZS5kb2MsICRjdXJzb3IuYmVmb3JlKCksICRjdXJzb3IuYWZ0ZXIoKSwgU2xpY2UuZW1wdHkpO1xuICAgICAgICBpZiAoZGVsU3RlcCAmJiBkZWxTdGVwLnNsaWNlLnNpemUgPCBkZWxTdGVwLnRvIC0gZGVsU3RlcC5mcm9tKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKGRlbFN0ZXApO1xuICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbih0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiKSA/IFNlbGVjdGlvbi5maW5kRnJvbSh0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLm1hcCgkY3V0LnBvcykpLCAxKVxuICAgICAgICAgICAgICAgICAgICA6IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGN1dC5wb3MpKSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgbmV4dCBub2RlIGlzIGFuIGF0b20sIGRlbGV0ZSBpdFxuICAgIGlmIChhZnRlci5pc0F0b20gJiYgJGN1dC5kZXB0aCA9PSAkY3Vyc29yLmRlcHRoIC0gMSkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGUoJGN1dC5wb3MsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuV2hlbiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgZW5kIG9mIGEgdGV4dGJsb2NrLCBzZWxlY3RcbnRoZSBub2RlIGNvbWluZyBhZnRlciB0aGF0IHRleHRibG9jaywgaWYgcG9zc2libGUuIFRoaXMgaXMgaW50ZW5kZWRcbnRvIGJlIGJvdW5kIHRvIGtleXMgbGlrZSBkZWxldGUsIGFmdGVyXG5bYGpvaW5Gb3J3YXJkYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLmpvaW5Gb3J3YXJkKSBhbmQgc2ltaWxhciBkZWxldGluZ1xuY29tbWFuZHMsIHRvIHByb3ZpZGUgYSBmYWxsLWJhY2sgYmVoYXZpb3Igd2hlbiB0aGUgc2NoZW1hIGRvZXNuJ3RcbmFsbG93IGRlbGV0aW9uIGF0IHRoZSBzZWxlY3RlZCBwb2ludC5cbiovXG5jb25zdCBzZWxlY3ROb2RlRm9yd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgeyAkaGVhZCwgZW1wdHkgfSA9IHN0YXRlLnNlbGVjdGlvbiwgJGN1dCA9ICRoZWFkO1xuICAgIGlmICghZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKSB7XG4gICAgICAgIGlmICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJmb3J3YXJkXCIsIHN0YXRlKSA6ICRoZWFkLnBhcmVudE9mZnNldCA8ICRoZWFkLnBhcmVudC5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICRjdXQgPSBmaW5kQ3V0QWZ0ZXIoJGhlYWQpO1xuICAgIH1cbiAgICBsZXQgbm9kZSA9ICRjdXQgJiYgJGN1dC5ub2RlQWZ0ZXI7XG4gICAgaWYgKCFub2RlIHx8ICFOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgJGN1dC5wb3MpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBmaW5kQ3V0QWZ0ZXIoJHBvcykge1xuICAgIGlmICghJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9ICRwb3Mubm9kZShpKTtcbiAgICAgICAgICAgIGlmICgkcG9zLmluZGV4KGkpICsgMSA8IHBhcmVudC5jaGlsZENvdW50KVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmRvYy5yZXNvbHZlKCRwb3MuYWZ0ZXIoaSArIDEpKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5Kb2luIHRoZSBzZWxlY3RlZCBibG9jayBvciwgaWYgdGhlcmUgaXMgYSB0ZXh0IHNlbGVjdGlvbiwgdGhlXG5jbG9zZXN0IGFuY2VzdG9yIGJsb2NrIG9mIHRoZSBzZWxlY3Rpb24gdGhhdCBjYW4gYmUgam9pbmVkLCB3aXRoXG50aGUgc2libGluZyBhYm92ZSBpdC5cbiovXG5jb25zdCBqb2luVXAgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgbm9kZVNlbCA9IHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24sIHBvaW50O1xuICAgIGlmIChub2RlU2VsKSB7XG4gICAgICAgIGlmIChzZWwubm9kZS5pc1RleHRibG9jayB8fCAhY2FuSm9pbihzdGF0ZS5kb2MsIHNlbC5mcm9tKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcG9pbnQgPSBzZWwuZnJvbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc2VsLmZyb20sIC0xKTtcbiAgICAgICAgaWYgKHBvaW50ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5qb2luKHBvaW50KTtcbiAgICAgICAgaWYgKG5vZGVTZWwpXG4gICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBwb2ludCAtIHN0YXRlLmRvYy5yZXNvbHZlKHBvaW50KS5ub2RlQmVmb3JlLm5vZGVTaXplKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkpvaW4gdGhlIHNlbGVjdGVkIGJsb2NrLCBvciB0aGUgY2xvc2VzdCBhbmNlc3RvciBvZiB0aGUgc2VsZWN0aW9uXG50aGF0IGNhbiBiZSBqb2luZWQsIHdpdGggdGhlIHNpYmxpbmcgYWZ0ZXIgaXQuXG4qL1xuY29uc3Qgam9pbkRvd24gPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgcG9pbnQ7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHNlbC5ub2RlLmlzVGV4dGJsb2NrIHx8ICFjYW5Kb2luKHN0YXRlLmRvYywgc2VsLnRvKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcG9pbnQgPSBzZWwudG87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHNlbC50bywgMSk7XG4gICAgICAgIGlmIChwb2ludCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmpvaW4ocG9pbnQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTGlmdCB0aGUgc2VsZWN0ZWQgYmxvY2ssIG9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yIGJsb2NrIG9mIHRoZVxuc2VsZWN0aW9uIHRoYXQgY2FuIGJlIGxpZnRlZCwgb3V0IG9mIGl0cyBwYXJlbnQgbm9kZS5cbiovXG5jb25zdCBsaWZ0ID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbklmIHRoZSBzZWxlY3Rpb24gaXMgaW4gYSBub2RlIHdob3NlIHR5cGUgaGFzIGEgdHJ1dGh5XG5bYGNvZGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuY29kZSkgcHJvcGVydHkgaW4gaXRzIHNwZWMsIHJlcGxhY2UgdGhlXG5zZWxlY3Rpb24gd2l0aCBhIG5ld2xpbmUgY2hhcmFjdGVyLlxuKi9cbmNvbnN0IG5ld2xpbmVJbkNvZGUgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsICRhbmNob3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRoZWFkLnBhcmVudC50eXBlLnNwZWMuY29kZSB8fCAhJGhlYWQuc2FtZVBhcmVudCgkYW5jaG9yKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuaW5zZXJ0VGV4dChcIlxcblwiKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBkZWZhdWx0QmxvY2tBdChtYXRjaCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2guZWRnZUNvdW50OyBpKyspIHtcbiAgICAgICAgbGV0IHsgdHlwZSB9ID0gbWF0Y2guZWRnZShpKTtcbiAgICAgICAgaWYgKHR5cGUuaXNUZXh0YmxvY2sgJiYgIXR5cGUuaGFzUmVxdWlyZWRBdHRycygpKVxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5XaGVuIHRoZSBzZWxlY3Rpb24gaXMgaW4gYSBub2RlIHdpdGggYSB0cnV0aHlcbltgY29kZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5jb2RlKSBwcm9wZXJ0eSBpbiBpdHMgc3BlYywgY3JlYXRlIGFcbmRlZmF1bHQgYmxvY2sgYWZ0ZXIgdGhlIGNvZGUgYmxvY2ssIGFuZCBtb3ZlIHRoZSBjdXJzb3IgdGhlcmUuXG4qL1xuY29uc3QgZXhpdENvZGUgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsICRhbmNob3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRoZWFkLnBhcmVudC50eXBlLnNwZWMuY29kZSB8fCAhJGhlYWQuc2FtZVBhcmVudCgkYW5jaG9yKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhYm92ZSA9ICRoZWFkLm5vZGUoLTEpLCBhZnRlciA9ICRoZWFkLmluZGV4QWZ0ZXIoLTEpLCB0eXBlID0gZGVmYXVsdEJsb2NrQXQoYWJvdmUuY29udGVudE1hdGNoQXQoYWZ0ZXIpKTtcbiAgICBpZiAoIXR5cGUgfHwgIWFib3ZlLmNhblJlcGxhY2VXaXRoKGFmdGVyLCBhZnRlciwgdHlwZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHBvcyA9ICRoZWFkLmFmdGVyKCksIHRyID0gc3RhdGUudHIucmVwbGFjZVdpdGgocG9zLCBwb3MsIHR5cGUuY3JlYXRlQW5kRmlsbCgpKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKHBvcyksIDEpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSWYgYSBibG9jayBub2RlIGlzIHNlbGVjdGVkLCBjcmVhdGUgYW4gZW1wdHkgcGFyYWdyYXBoIGJlZm9yZSAoaWZcbml0IGlzIGl0cyBwYXJlbnQncyBmaXJzdCBjaGlsZCkgb3IgYWZ0ZXIgaXQuXG4qL1xuY29uc3QgY3JlYXRlUGFyYWdyYXBoTmVhciA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCB7ICRmcm9tLCAkdG8gfSA9IHNlbDtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uIHx8ICRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50IHx8ICR0by5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0eXBlID0gZGVmYXVsdEJsb2NrQXQoJHRvLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkdG8uaW5kZXhBZnRlcigpKSk7XG4gICAgaWYgKCF0eXBlIHx8ICF0eXBlLmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBzaWRlID0gKCEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJHRvLmluZGV4KCkgPCAkdG8ucGFyZW50LmNoaWxkQ291bnQgPyAkZnJvbSA6ICR0bykucG9zO1xuICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5pbnNlcnQoc2lkZSwgdHlwZS5jcmVhdGVBbmRGaWxsKCkpO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBzaWRlICsgMSkpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JZiB0aGUgY3Vyc29yIGlzIGluIGFuIGVtcHR5IHRleHRibG9jayB0aGF0IGNhbiBiZSBsaWZ0ZWQsIGxpZnQgdGhlXG5ibG9jay5cbiovXG5jb25zdCBsaWZ0RW1wdHlCbG9jayA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkY3Vyc29yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkY3Vyc29yIHx8ICRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgkY3Vyc29yLmRlcHRoID4gMSAmJiAkY3Vyc29yLmFmdGVyKCkgIT0gJGN1cnNvci5lbmQoLTEpKSB7XG4gICAgICAgIGxldCBiZWZvcmUgPSAkY3Vyc29yLmJlZm9yZSgpO1xuICAgICAgICBpZiAoY2FuU3BsaXQoc3RhdGUuZG9jLCBiZWZvcmUpKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc3BsaXQoYmVmb3JlKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCByYW5nZSA9ICRjdXJzb3IuYmxvY2tSYW5nZSgpLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5DcmVhdGUgYSB2YXJpYW50IG9mIFtgc3BsaXRCbG9ja2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5zcGxpdEJsb2NrKSB0aGF0IHVzZXNcbmEgY3VzdG9tIGZ1bmN0aW9uIHRvIGRldGVybWluZSB0aGUgdHlwZSBvZiB0aGUgbmV3bHkgc3BsaXQgb2ZmIGJsb2NrLlxuKi9cbmZ1bmN0aW9uIHNwbGl0QmxvY2tBcyhzcGxpdE5vZGUpIHtcbiAgICByZXR1cm4gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHN0YXRlLnNlbGVjdGlvbi5ub2RlLmlzQmxvY2spIHtcbiAgICAgICAgICAgIGlmICghJGZyb20ucGFyZW50T2Zmc2V0IHx8ICFjYW5TcGxpdChzdGF0ZS5kb2MsICRmcm9tLnBvcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNwbGl0KCRmcm9tLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISRmcm9tLnBhcmVudC5pc0Jsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBhdEVuZCA9ICR0by5wYXJlbnRPZmZzZXQgPT0gJHRvLnBhcmVudC5jb250ZW50LnNpemU7XG4gICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uIHx8IHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICB0ci5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGxldCBkZWZsdCA9ICRmcm9tLmRlcHRoID09IDAgPyBudWxsIDogZGVmYXVsdEJsb2NrQXQoJGZyb20ubm9kZSgtMSkuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcigtMSkpKTtcbiAgICAgICAgICAgIGxldCBzcGxpdFR5cGUgPSBzcGxpdE5vZGUgJiYgc3BsaXROb2RlKCR0by5wYXJlbnQsIGF0RW5kKTtcbiAgICAgICAgICAgIGxldCB0eXBlcyA9IHNwbGl0VHlwZSA/IFtzcGxpdFR5cGVdIDogYXRFbmQgJiYgZGVmbHQgPyBbeyB0eXBlOiBkZWZsdCB9XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBjYW4gPSBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKTtcbiAgICAgICAgICAgIGlmICghdHlwZXMgJiYgIWNhbiAmJiBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIGRlZmx0ID8gW3sgdHlwZTogZGVmbHQgfV0gOiB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmx0KVxuICAgICAgICAgICAgICAgICAgICB0eXBlcyA9IFt7IHR5cGU6IGRlZmx0IH1dO1xuICAgICAgICAgICAgICAgIGNhbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuKSB7XG4gICAgICAgICAgICAgICAgdHIuc3BsaXQodHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpO1xuICAgICAgICAgICAgICAgIGlmICghYXRFbmQgJiYgISRmcm9tLnBhcmVudE9mZnNldCAmJiAkZnJvbS5wYXJlbnQudHlwZSAhPSBkZWZsdCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmlyc3QgPSB0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSksICRmaXJzdCA9IHRyLmRvYy5yZXNvbHZlKGZpcnN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmx0ICYmICRmcm9tLm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRmaXJzdC5pbmRleCgpLCAkZmlyc3QuaW5kZXgoKSArIDEsIGRlZmx0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAodHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpLCBkZWZsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuU3BsaXQgdGhlIHBhcmVudCBibG9jayBvZiB0aGUgc2VsZWN0aW9uLiBJZiB0aGUgc2VsZWN0aW9uIGlzIGEgdGV4dFxuc2VsZWN0aW9uLCBhbHNvIGRlbGV0ZSBpdHMgY29udGVudC5cbiovXG5jb25zdCBzcGxpdEJsb2NrID0gc3BsaXRCbG9ja0FzKCk7XG4vKipcbkFjdHMgbGlrZSBbYHNwbGl0QmxvY2tgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuc3BsaXRCbG9jayksIGJ1dCB3aXRob3V0XG5yZXNldHRpbmcgdGhlIHNldCBvZiBhY3RpdmUgbWFya3MgYXQgdGhlIGN1cnNvci5cbiovXG5jb25zdCBzcGxpdEJsb2NrS2VlcE1hcmtzID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIHJldHVybiBzcGxpdEJsb2NrKHN0YXRlLCBkaXNwYXRjaCAmJiAodHIgPT4ge1xuICAgICAgICBsZXQgbWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcyB8fCAoc3RhdGUuc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpO1xuICAgICAgICBpZiAobWFya3MpXG4gICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhtYXJrcyk7XG4gICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICB9KSk7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIG5vZGUgd3JhcHBpbmcgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLCBpZlxuYW55LiAoV2lsbCBub3Qgc2VsZWN0IHRoZSBkb2N1bWVudCBub2RlLilcbiovXG5jb25zdCBzZWxlY3RQYXJlbnROb2RlID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRmcm9tLCB0byB9ID0gc3RhdGUuc2VsZWN0aW9uLCBwb3M7XG4gICAgbGV0IHNhbWUgPSAkZnJvbS5zaGFyZWREZXB0aCh0byk7XG4gICAgaWYgKHNhbWUgPT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHBvcyA9ICRmcm9tLmJlZm9yZShzYW1lKTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsIHBvcykpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblNlbGVjdCB0aGUgd2hvbGUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0QWxsID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ldyBBbGxTZWxlY3Rpb24oc3RhdGUuZG9jKSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGpvaW5NYXliZUNsZWFyKHN0YXRlLCAkcG9zLCBkaXNwYXRjaCkge1xuICAgIGxldCBiZWZvcmUgPSAkcG9zLm5vZGVCZWZvcmUsIGFmdGVyID0gJHBvcy5ub2RlQWZ0ZXIsIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICAgIGlmICghYmVmb3JlIHx8ICFhZnRlciB8fCAhYmVmb3JlLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQoYWZ0ZXIudHlwZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWJlZm9yZS5jb250ZW50LnNpemUgJiYgJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCAtIDEsIGluZGV4KSkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGUoJHBvcy5wb3MgLSBiZWZvcmUubm9kZVNpemUsICRwb3MucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKSB8fCAhKGFmdGVyLmlzVGV4dGJsb2NrIHx8IGNhbkpvaW4oc3RhdGUuZG9jLCAkcG9zLnBvcykpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50clxuICAgICAgICAgICAgLmNsZWFySW5jb21wYXRpYmxlKCRwb3MucG9zLCBiZWZvcmUudHlwZSwgYmVmb3JlLmNvbnRlbnRNYXRjaEF0KGJlZm9yZS5jaGlsZENvdW50KSlcbiAgICAgICAgICAgIC5qb2luKCRwb3MucG9zKVxuICAgICAgICAgICAgLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpIHtcbiAgICBsZXQgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlLCBhZnRlciA9ICRjdXQubm9kZUFmdGVyLCBjb25uLCBtYXRjaDtcbiAgICBpZiAoYmVmb3JlLnR5cGUuc3BlYy5pc29sYXRpbmcgfHwgYWZ0ZXIudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChqb2luTWF5YmVDbGVhcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgY2FuRGVsQWZ0ZXIgPSAkY3V0LnBhcmVudC5jYW5SZXBsYWNlKCRjdXQuaW5kZXgoKSwgJGN1dC5pbmRleCgpICsgMSk7XG4gICAgaWYgKGNhbkRlbEFmdGVyICYmXG4gICAgICAgIChjb25uID0gKG1hdGNoID0gYmVmb3JlLmNvbnRlbnRNYXRjaEF0KGJlZm9yZS5jaGlsZENvdW50KSkuZmluZFdyYXBwaW5nKGFmdGVyLnR5cGUpKSAmJlxuICAgICAgICBtYXRjaC5tYXRjaFR5cGUoY29ublswXSB8fCBhZnRlci50eXBlKS52YWxpZEVuZCkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplLCB3cmFwID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gY29ubi5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbShjb25uW2ldLmNyZWF0ZShudWxsLCB3cmFwKSk7XG4gICAgICAgICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbShiZWZvcmUuY29weSh3cmFwKSk7XG4gICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcCgkY3V0LnBvcyAtIDEsIGVuZCwgJGN1dC5wb3MsIGVuZCwgbmV3IFNsaWNlKHdyYXAsIDEsIDApLCBjb25uLmxlbmd0aCwgdHJ1ZSkpO1xuICAgICAgICAgICAgbGV0IGpvaW5BdCA9IGVuZCArIDIgKiBjb25uLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChjYW5Kb2luKHRyLmRvYywgam9pbkF0KSlcbiAgICAgICAgICAgICAgICB0ci5qb2luKGpvaW5BdCk7XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHNlbEFmdGVyID0gU2VsZWN0aW9uLmZpbmRGcm9tKCRjdXQsIDEpO1xuICAgIGxldCByYW5nZSA9IHNlbEFmdGVyICYmIHNlbEFmdGVyLiRmcm9tLmJsb2NrUmFuZ2Uoc2VsQWZ0ZXIuJHRvKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCAhPSBudWxsICYmIHRhcmdldCA+PSAkY3V0LmRlcHRoKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY2FuRGVsQWZ0ZXIgJiYgdGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIiwgdHJ1ZSkgJiYgdGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSkge1xuICAgICAgICBsZXQgYXQgPSBiZWZvcmUsIHdyYXAgPSBbXTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgd3JhcC5wdXNoKGF0KTtcbiAgICAgICAgICAgIGlmIChhdC5pc1RleHRibG9jaylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGF0ID0gYXQubGFzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhZnRlclRleHQgPSBhZnRlciwgYWZ0ZXJEZXB0aCA9IDE7XG4gICAgICAgIGZvciAoOyAhYWZ0ZXJUZXh0LmlzVGV4dGJsb2NrOyBhZnRlclRleHQgPSBhZnRlclRleHQuZmlyc3RDaGlsZClcbiAgICAgICAgICAgIGFmdGVyRGVwdGgrKztcbiAgICAgICAgaWYgKGF0LmNhblJlcGxhY2UoYXQuY2hpbGRDb3VudCwgYXQuY2hpbGRDb3VudCwgYWZ0ZXJUZXh0LmNvbnRlbnQpKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHdyYXAubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IEZyYWdtZW50LmZyb20od3JhcFtpXS5jb3B5KGVuZCkpO1xuICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKCRjdXQucG9zIC0gd3JhcC5sZW5ndGgsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUsICRjdXQucG9zICsgYWZ0ZXJEZXB0aCwgJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSAtIGFmdGVyRGVwdGgsIG5ldyBTbGljZShlbmQsIHdyYXAubGVuZ3RoLCAwKSwgMCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2VsZWN0VGV4dGJsb2NrU2lkZShzaWRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgJHBvcyA9IHNpZGUgPCAwID8gc2VsLiRmcm9tIDogc2VsLiR0bztcbiAgICAgICAgbGV0IGRlcHRoID0gJHBvcy5kZXB0aDtcbiAgICAgICAgd2hpbGUgKCRwb3Mubm9kZShkZXB0aCkuaXNJbmxpbmUpIHtcbiAgICAgICAgICAgIGlmICghZGVwdGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISRwb3Mubm9kZShkZXB0aCkuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsIHNpZGUgPCAwID8gJHBvcy5zdGFydChkZXB0aCkgOiAkcG9zLmVuZChkZXB0aCkpKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbk1vdmVzIHRoZSBjdXJzb3IgdG8gdGhlIHN0YXJ0IG9mIGN1cnJlbnQgdGV4dCBibG9jay5cbiovXG5jb25zdCBzZWxlY3RUZXh0YmxvY2tTdGFydCA9IHNlbGVjdFRleHRibG9ja1NpZGUoLTEpO1xuLyoqXG5Nb3ZlcyB0aGUgY3Vyc29yIHRvIHRoZSBlbmQgb2YgY3VycmVudCB0ZXh0IGJsb2NrLlxuKi9cbmNvbnN0IHNlbGVjdFRleHRibG9ja0VuZCA9IHNlbGVjdFRleHRibG9ja1NpZGUoMSk7XG4vLyBQYXJhbWV0ZXJpemVkIGNvbW1hbmRzXG4vKipcbldyYXAgdGhlIHNlbGVjdGlvbiBpbiBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUgd2l0aCB0aGUgZ2l2ZW5cbmF0dHJpYnV0ZXMuXG4qL1xuZnVuY3Rpb24gd3JhcEluKG5vZGVUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKSwgd3JhcHBpbmcgPSByYW5nZSAmJiBmaW5kV3JhcHBpbmcocmFuZ2UsIG5vZGVUeXBlLCBhdHRycyk7XG4gICAgICAgIGlmICghd3JhcHBpbmcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLndyYXAocmFuZ2UsIHdyYXBwaW5nKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuUmV0dXJucyBhIGNvbW1hbmQgdGhhdCB0cmllcyB0byBzZXQgdGhlIHNlbGVjdGVkIHRleHRibG9ja3MgdG8gdGhlXG5naXZlbiBub2RlIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gYXR0cmlidXRlcy5cbiovXG5mdW5jdGlvbiBzZXRCbG9ja1R5cGUobm9kZVR5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBhcHBsaWNhYmxlID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGggJiYgIWFwcGxpY2FibGU7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgJGZyb206IHsgcG9zOiBmcm9tIH0sICR0bzogeyBwb3M6IHRvIH0gfSA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXNbaV07XG4gICAgICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFwcGxpY2FibGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaXNUZXh0YmxvY2sgfHwgbm9kZS5oYXNNYXJrdXAobm9kZVR5cGUsIGF0dHJzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT0gbm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbGljYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgJHBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKHBvcyksIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWNhYmxlID0gJHBvcy5wYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4ICsgMSwgbm9kZVR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXBwbGljYWJsZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB7ICRmcm9tOiB7IHBvczogZnJvbSB9LCAkdG86IHsgcG9zOiB0byB9IH0gPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgIHRyLnNldEJsb2NrVHlwZShmcm9tLCB0bywgbm9kZVR5cGUsIGF0dHJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBtYXJrQXBwbGllcyhkb2MsIHJhbmdlcywgdHlwZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgbGV0IGNhbiA9ICRmcm9tLmRlcHRoID09IDAgPyBkb2MuaW5saW5lQ29udGVudCAmJiBkb2MudHlwZS5hbGxvd3NNYXJrVHlwZSh0eXBlKSA6IGZhbHNlO1xuICAgICAgICBkb2Mubm9kZXNCZXR3ZWVuKCRmcm9tLnBvcywgJHRvLnBvcywgbm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FuKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhbiA9IG5vZGUuaW5saW5lQ29udGVudCAmJiBub2RlLnR5cGUuYWxsb3dzTWFya1R5cGUodHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2FuKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuQ3JlYXRlIGEgY29tbWFuZCBmdW5jdGlvbiB0aGF0IHRvZ2dsZXMgdGhlIGdpdmVuIG1hcmsgd2l0aCB0aGVcbmdpdmVuIGF0dHJpYnV0ZXMuIFdpbGwgcmV0dXJuIGBmYWxzZWAgd2hlbiB0aGUgY3VycmVudCBzZWxlY3Rpb25cbmRvZXNuJ3Qgc3VwcG9ydCB0aGF0IG1hcmsuIFRoaXMgd2lsbCByZW1vdmUgdGhlIG1hcmsgaWYgYW55IG1hcmtzXG5vZiB0aGF0IHR5cGUgZXhpc3QgaW4gdGhlIHNlbGVjdGlvbiwgb3IgYWRkIGl0IG90aGVyd2lzZS4gSWYgdGhlXG5zZWxlY3Rpb24gaXMgZW1wdHksIHRoaXMgYXBwbGllcyB0byB0aGUgW3N0b3JlZFxubWFya3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5zdG9yZWRNYXJrcykgaW5zdGVhZCBvZiBhIHJhbmdlIG9mIHRoZVxuZG9jdW1lbnQuXG4qL1xuZnVuY3Rpb24gdG9nZ2xlTWFyayhtYXJrVHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgZW1wdHksICRjdXJzb3IsIHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoKGVtcHR5ICYmICEkY3Vyc29yKSB8fCAhbWFya0FwcGxpZXMoc3RhdGUuZG9jLCByYW5nZXMsIG1hcmtUeXBlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZS5pc0luU2V0KHN0YXRlLnN0b3JlZE1hcmtzIHx8ICRjdXJzb3IubWFya3MoKSkpXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnJlbW92ZVN0b3JlZE1hcmsobWFya1R5cGUpKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmFkZFN0b3JlZE1hcmsobWFya1R5cGUuY3JlYXRlKGF0dHJzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGhhcyA9IGZhbHNlLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyAhaGFzICYmIGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICBoYXMgPSBzdGF0ZS5kb2MucmFuZ2VIYXNNYXJrKCRmcm9tLnBvcywgJHRvLnBvcywgbWFya1R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnJlbW92ZU1hcmsoJGZyb20ucG9zLCAkdG8ucG9zLCBtYXJrVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9ICRmcm9tLnBvcywgdG8gPSAkdG8ucG9zLCBzdGFydCA9ICRmcm9tLm5vZGVBZnRlciwgZW5kID0gJHRvLm5vZGVCZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2VTdGFydCA9IHN0YXJ0ICYmIHN0YXJ0LmlzVGV4dCA/IC9eXFxzKi8uZXhlYyhzdGFydC50ZXh0KVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlRW5kID0gZW5kICYmIGVuZC5pc1RleHQgPyAvXFxzKiQvLmV4ZWMoZW5kLnRleHQpWzBdLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSArIHNwYWNlU3RhcnQgPCB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gKz0gc3BhY2VTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byAtPSBzcGFjZUVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsoZnJvbSwgdG8sIG1hcmtUeXBlLmNyZWF0ZShhdHRycykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiB3cmFwRGlzcGF0Y2hGb3JKb2luKGRpc3BhdGNoLCBpc0pvaW5hYmxlKSB7XG4gICAgcmV0dXJuICh0cikgPT4ge1xuICAgICAgICBpZiAoIXRyLmlzR2VuZXJpYylcbiAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaCh0cik7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ci5tYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbaV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJhbmdlcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICByYW5nZXNbal0gPSBtYXAubWFwKHJhbmdlc1tqXSk7XG4gICAgICAgICAgICBtYXAuZm9yRWFjaCgoX3MsIF9lLCBmcm9tLCB0bykgPT4gcmFuZ2VzLnB1c2goZnJvbSwgdG8pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIGpvaW5hYmxlIHBvaW50cyBleGlzdCBpbnNpZGUgdGhvc2UgcmFuZ2VzLFxuICAgICAgICAvLyBieSBjaGVja2luZyBhbGwgbm9kZSBib3VuZGFyaWVzIGluIHRoZWlyIHBhcmVudCBub2Rlcy5cbiAgICAgICAgbGV0IGpvaW5hYmxlID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1tpXSwgdG8gPSByYW5nZXNbaSArIDFdO1xuICAgICAgICAgICAgbGV0ICRmcm9tID0gdHIuZG9jLnJlc29sdmUoZnJvbSksIGRlcHRoID0gJGZyb20uc2hhcmVkRGVwdGgodG8pLCBwYXJlbnQgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gJGZyb20uaW5kZXhBZnRlcihkZXB0aCksIHBvcyA9ICRmcm9tLmFmdGVyKGRlcHRoICsgMSk7IHBvcyA8PSB0bzsgKytpbmRleCkge1xuICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIWFmdGVyKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggJiYgam9pbmFibGUuaW5kZXhPZihwb3MpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBwYXJlbnQuY2hpbGQoaW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZS50eXBlID09IGFmdGVyLnR5cGUgJiYgaXNKb2luYWJsZShiZWZvcmUsIGFmdGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW5hYmxlLnB1c2gocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zICs9IGFmdGVyLm5vZGVTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpvaW4gdGhlIGpvaW5hYmxlIHBvaW50c1xuICAgICAgICBqb2luYWJsZS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgIGZvciAobGV0IGkgPSBqb2luYWJsZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKGNhbkpvaW4odHIuZG9jLCBqb2luYWJsZVtpXSkpXG4gICAgICAgICAgICAgICAgdHIuam9pbihqb2luYWJsZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgIH07XG59XG4vKipcbldyYXAgYSBjb21tYW5kIHNvIHRoYXQsIHdoZW4gaXQgcHJvZHVjZXMgYSB0cmFuc2Zvcm0gdGhhdCBjYXVzZXNcbnR3byBqb2luYWJsZSBub2RlcyB0byBlbmQgdXAgbmV4dCB0byBlYWNoIG90aGVyLCB0aG9zZSBhcmUgam9pbmVkLlxuTm9kZXMgYXJlIGNvbnNpZGVyZWQgam9pbmFibGUgd2hlbiB0aGV5IGFyZSBvZiB0aGUgc2FtZSB0eXBlIGFuZFxud2hlbiB0aGUgYGlzSm9pbmFibGVgIHByZWRpY2F0ZSByZXR1cm5zIHRydWUgZm9yIHRoZW0gb3IsIGlmIGFuXG5hcnJheSBvZiBzdHJpbmdzIHdhcyBwYXNzZWQsIGlmIHRoZWlyIG5vZGUgdHlwZSBuYW1lIGlzIGluIHRoYXRcbmFycmF5LlxuKi9cbmZ1bmN0aW9uIGF1dG9Kb2luKGNvbW1hbmQsIGlzSm9pbmFibGUpIHtcbiAgICBsZXQgY2FuSm9pbiA9IEFycmF5LmlzQXJyYXkoaXNKb2luYWJsZSkgPyAobm9kZSkgPT4gaXNKb2luYWJsZS5pbmRleE9mKG5vZGUudHlwZS5uYW1lKSA+IC0xXG4gICAgICAgIDogaXNKb2luYWJsZTtcbiAgICByZXR1cm4gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4gY29tbWFuZChzdGF0ZSwgZGlzcGF0Y2ggJiYgd3JhcERpc3BhdGNoRm9ySm9pbihkaXNwYXRjaCwgY2FuSm9pbiksIHZpZXcpO1xufVxuLyoqXG5Db21iaW5lIGEgbnVtYmVyIG9mIGNvbW1hbmQgZnVuY3Rpb25zIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gKHdoaWNoXG5jYWxscyB0aGVtIG9uZSBieSBvbmUgdW50aWwgb25lIHJldHVybnMgdHJ1ZSkuXG4qL1xuZnVuY3Rpb24gY2hhaW5Db21tYW5kcyguLi5jb21tYW5kcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY29tbWFuZHNbaV0oc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5sZXQgYmFja3NwYWNlID0gY2hhaW5Db21tYW5kcyhkZWxldGVTZWxlY3Rpb24sIGpvaW5CYWNrd2FyZCwgc2VsZWN0Tm9kZUJhY2t3YXJkKTtcbmxldCBkZWwgPSBjaGFpbkNvbW1hbmRzKGRlbGV0ZVNlbGVjdGlvbiwgam9pbkZvcndhcmQsIHNlbGVjdE5vZGVGb3J3YXJkKTtcbi8qKlxuQSBiYXNpYyBrZXltYXAgY29udGFpbmluZyBiaW5kaW5ncyBub3Qgc3BlY2lmaWMgdG8gYW55IHNjaGVtYS5cbkJpbmRzIHRoZSBmb2xsb3dpbmcga2V5cyAod2hlbiBtdWx0aXBsZSBjb21tYW5kcyBhcmUgbGlzdGVkLCB0aGV5XG5hcmUgY2hhaW5lZCB3aXRoIFtgY2hhaW5Db21tYW5kc2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5jaGFpbkNvbW1hbmRzKSk6XG5cbiogKipFbnRlcioqIHRvIGBuZXdsaW5lSW5Db2RlYCwgYGNyZWF0ZVBhcmFncmFwaE5lYXJgLCBgbGlmdEVtcHR5QmxvY2tgLCBgc3BsaXRCbG9ja2BcbiogKipNb2QtRW50ZXIqKiB0byBgZXhpdENvZGVgXG4qICoqQmFja3NwYWNlKiogYW5kICoqTW9kLUJhY2tzcGFjZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkJhY2t3YXJkYCwgYHNlbGVjdE5vZGVCYWNrd2FyZGBcbiogKipEZWxldGUqKiBhbmQgKipNb2QtRGVsZXRlKiogdG8gYGRlbGV0ZVNlbGVjdGlvbmAsIGBqb2luRm9yd2FyZGAsIGBzZWxlY3ROb2RlRm9yd2FyZGBcbiogKipNb2QtRGVsZXRlKiogdG8gYGRlbGV0ZVNlbGVjdGlvbmAsIGBqb2luRm9yd2FyZGAsIGBzZWxlY3ROb2RlRm9yd2FyZGBcbiogKipNb2QtYSoqIHRvIGBzZWxlY3RBbGxgXG4qL1xuY29uc3QgcGNCYXNlS2V5bWFwID0ge1xuICAgIFwiRW50ZXJcIjogY2hhaW5Db21tYW5kcyhuZXdsaW5lSW5Db2RlLCBjcmVhdGVQYXJhZ3JhcGhOZWFyLCBsaWZ0RW1wdHlCbG9jaywgc3BsaXRCbG9jayksXG4gICAgXCJNb2QtRW50ZXJcIjogZXhpdENvZGUsXG4gICAgXCJCYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICAgIFwiTW9kLUJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gICAgXCJTaGlmdC1CYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICAgIFwiRGVsZXRlXCI6IGRlbCxcbiAgICBcIk1vZC1EZWxldGVcIjogZGVsLFxuICAgIFwiTW9kLWFcIjogc2VsZWN0QWxsXG59O1xuLyoqXG5BIGNvcHkgb2YgYHBjQmFzZUtleW1hcGAgdGhhdCBhbHNvIGJpbmRzICoqQ3RybC1oKiogbGlrZSBCYWNrc3BhY2UsXG4qKkN0cmwtZCoqIGxpa2UgRGVsZXRlLCAqKkFsdC1CYWNrc3BhY2UqKiBsaWtlIEN0cmwtQmFja3NwYWNlLCBhbmRcbioqQ3RybC1BbHQtQmFja3NwYWNlKiosICoqQWx0LURlbGV0ZSoqLCBhbmQgKipBbHQtZCoqIGxpa2VcbkN0cmwtRGVsZXRlLlxuKi9cbmNvbnN0IG1hY0Jhc2VLZXltYXAgPSB7XG4gICAgXCJDdHJsLWhcIjogcGNCYXNlS2V5bWFwW1wiQmFja3NwYWNlXCJdLFxuICAgIFwiQWx0LUJhY2tzcGFjZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtQmFja3NwYWNlXCJdLFxuICAgIFwiQ3RybC1kXCI6IHBjQmFzZUtleW1hcFtcIkRlbGV0ZVwiXSxcbiAgICBcIkN0cmwtQWx0LUJhY2tzcGFjZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICAgIFwiQWx0LURlbGV0ZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICAgIFwiQWx0LWRcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgICBcIkN0cmwtYVwiOiBzZWxlY3RUZXh0YmxvY2tTdGFydCxcbiAgICBcIkN0cmwtZVwiOiBzZWxlY3RUZXh0YmxvY2tFbmRcbn07XG5mb3IgKGxldCBrZXkgaW4gcGNCYXNlS2V5bWFwKVxuICAgIG1hY0Jhc2VLZXltYXBba2V5XSA9IHBjQmFzZUtleW1hcFtrZXldO1xuY29uc3QgbWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gL01hY3xpUChob25lfFtvYV1kKS8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIDogdHlwZW9mIG9zICE9IFwidW5kZWZpbmVkXCIgJiYgb3MucGxhdGZvcm0gPyBvcy5wbGF0Zm9ybSgpID09IFwiZGFyd2luXCIgOiBmYWxzZTtcbi8qKlxuRGVwZW5kaW5nIG9uIHRoZSBkZXRlY3RlZCBwbGF0Zm9ybSwgdGhpcyB3aWxsIGhvbGRcbltgcGNCYXNla2V5bWFwYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLnBjQmFzZUtleW1hcCkgb3JcbltgbWFjQmFzZUtleW1hcGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5tYWNCYXNlS2V5bWFwKS5cbiovXG5jb25zdCBiYXNlS2V5bWFwID0gbWFjID8gbWFjQmFzZUtleW1hcCA6IHBjQmFzZUtleW1hcDtcblxuZXhwb3J0IHsgYXV0b0pvaW4sIGJhc2VLZXltYXAsIGNoYWluQ29tbWFuZHMsIGNyZWF0ZVBhcmFncmFwaE5lYXIsIGRlbGV0ZVNlbGVjdGlvbiwgZXhpdENvZGUsIGpvaW5CYWNrd2FyZCwgam9pbkRvd24sIGpvaW5Gb3J3YXJkLCBqb2luVGV4dGJsb2NrQmFja3dhcmQsIGpvaW5UZXh0YmxvY2tGb3J3YXJkLCBqb2luVXAsIGxpZnQsIGxpZnRFbXB0eUJsb2NrLCBtYWNCYXNlS2V5bWFwLCBuZXdsaW5lSW5Db2RlLCBwY0Jhc2VLZXltYXAsIHNlbGVjdEFsbCwgc2VsZWN0Tm9kZUJhY2t3YXJkLCBzZWxlY3ROb2RlRm9yd2FyZCwgc2VsZWN0UGFyZW50Tm9kZSwgc2VsZWN0VGV4dGJsb2NrRW5kLCBzZWxlY3RUZXh0YmxvY2tTdGFydCwgc2V0QmxvY2tUeXBlLCBzcGxpdEJsb2NrLCBzcGxpdEJsb2NrQXMsIHNwbGl0QmxvY2tLZWVwTWFya3MsIHRvZ2dsZU1hcmssIHdyYXBJbiB9O1xuIiwgImltcG9ydCB7IGZpbmRXcmFwcGluZywgUmVwbGFjZUFyb3VuZFN0ZXAsIGNhblNwbGl0LCBsaWZ0VGFyZ2V0LCBjYW5Kb2luIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcbmltcG9ydCB7IE5vZGVSYW5nZSwgRnJhZ21lbnQsIFNsaWNlIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgU2VsZWN0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG5jb25zdCBvbERPTSA9IFtcIm9sXCIsIDBdLCB1bERPTSA9IFtcInVsXCIsIDBdLCBsaURPTSA9IFtcImxpXCIsIDBdO1xuLyoqXG5BbiBvcmRlcmVkIGxpc3QgW25vZGUgc3BlY10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjKS4gSGFzIGEgc2luZ2xlXG5hdHRyaWJ1dGUsIGBvcmRlcmAsIHdoaWNoIGRldGVybWluZXMgdGhlIG51bWJlciBhdCB3aGljaCB0aGUgbGlzdFxuc3RhcnRzIGNvdW50aW5nLCBhbmQgZGVmYXVsdHMgdG8gMS4gUmVwcmVzZW50ZWQgYXMgYW4gYDxvbD5gXG5lbGVtZW50LlxuKi9cbmNvbnN0IG9yZGVyZWRMaXN0ID0ge1xuICAgIGF0dHJzOiB7IG9yZGVyOiB7IGRlZmF1bHQ6IDEgfSB9LFxuICAgIHBhcnNlRE9NOiBbeyB0YWc6IFwib2xcIiwgZ2V0QXR0cnMoZG9tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb3JkZXI6IGRvbS5oYXNBdHRyaWJ1dGUoXCJzdGFydFwiKSA/ICtkb20uZ2V0QXR0cmlidXRlKFwic3RhcnRcIikgOiAxIH07XG4gICAgICAgICAgICB9IH1dLFxuICAgIHRvRE9NKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuYXR0cnMub3JkZXIgPT0gMSA/IG9sRE9NIDogW1wib2xcIiwgeyBzdGFydDogbm9kZS5hdHRycy5vcmRlciB9LCAwXTtcbiAgICB9XG59O1xuLyoqXG5BIGJ1bGxldCBsaXN0IG5vZGUgc3BlYywgcmVwcmVzZW50ZWQgaW4gdGhlIERPTSBhcyBgPHVsPmAuXG4qL1xuY29uc3QgYnVsbGV0TGlzdCA9IHtcbiAgICBwYXJzZURPTTogW3sgdGFnOiBcInVsXCIgfV0sXG4gICAgdG9ET00oKSB7IHJldHVybiB1bERPTTsgfVxufTtcbi8qKlxuQSBsaXN0IGl0ZW0gKGA8bGk+YCkgc3BlYy5cbiovXG5jb25zdCBsaXN0SXRlbSA9IHtcbiAgICBwYXJzZURPTTogW3sgdGFnOiBcImxpXCIgfV0sXG4gICAgdG9ET00oKSB7IHJldHVybiBsaURPTTsgfSxcbiAgICBkZWZpbmluZzogdHJ1ZVxufTtcbmZ1bmN0aW9uIGFkZChvYmosIHByb3BzKSB7XG4gICAgbGV0IGNvcHkgPSB7fTtcbiAgICBmb3IgKGxldCBwcm9wIGluIG9iailcbiAgICAgICAgY29weVtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICBmb3IgKGxldCBwcm9wIGluIHByb3BzKVxuICAgICAgICBjb3B5W3Byb3BdID0gcHJvcHNbcHJvcF07XG4gICAgcmV0dXJuIGNvcHk7XG59XG4vKipcbkNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBhZGRpbmcgbGlzdC1yZWxhdGVkIG5vZGUgdHlwZXMgdG8gYSBtYXBcbnNwZWNpZnlpbmcgdGhlIG5vZGVzIGZvciBhIHNjaGVtYS4gQWRkc1xuW2BvcmRlcmVkTGlzdGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzY2hlbWEtbGlzdC5vcmRlcmVkTGlzdCkgYXMgYFwib3JkZXJlZF9saXN0XCJgLFxuW2BidWxsZXRMaXN0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3NjaGVtYS1saXN0LmJ1bGxldExpc3QpIGFzIGBcImJ1bGxldF9saXN0XCJgLCBhbmRcbltgbGlzdEl0ZW1gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc2NoZW1hLWxpc3QubGlzdEl0ZW0pIGFzIGBcImxpc3RfaXRlbVwiYC5cblxuYGl0ZW1Db250ZW50YCBkZXRlcm1pbmVzIHRoZSBjb250ZW50IGV4cHJlc3Npb24gZm9yIHRoZSBsaXN0IGl0ZW1zLlxuSWYgeW91IHdhbnQgdGhlIGNvbW1hbmRzIGRlZmluZWQgaW4gdGhpcyBtb2R1bGUgdG8gYXBwbHkgdG8geW91clxubGlzdCBzdHJ1Y3R1cmUsIGl0IHNob3VsZCBoYXZlIGEgc2hhcGUgbGlrZSBgXCJwYXJhZ3JhcGggYmxvY2sqXCJgIG9yXG5gXCJwYXJhZ3JhcGggKG9yZGVyZWRfbGlzdCB8IGJ1bGxldF9saXN0KSpcImAuIGBsaXN0R3JvdXBgIGNhbiBiZVxuZ2l2ZW4gdG8gYXNzaWduIGEgZ3JvdXAgbmFtZSB0byB0aGUgbGlzdCBub2RlIHR5cGVzLCBmb3IgZXhhbXBsZVxuYFwiYmxvY2tcImAuXG4qL1xuZnVuY3Rpb24gYWRkTGlzdE5vZGVzKG5vZGVzLCBpdGVtQ29udGVudCwgbGlzdEdyb3VwKSB7XG4gICAgcmV0dXJuIG5vZGVzLmFwcGVuZCh7XG4gICAgICAgIG9yZGVyZWRfbGlzdDogYWRkKG9yZGVyZWRMaXN0LCB7IGNvbnRlbnQ6IFwibGlzdF9pdGVtK1wiLCBncm91cDogbGlzdEdyb3VwIH0pLFxuICAgICAgICBidWxsZXRfbGlzdDogYWRkKGJ1bGxldExpc3QsIHsgY29udGVudDogXCJsaXN0X2l0ZW0rXCIsIGdyb3VwOiBsaXN0R3JvdXAgfSksXG4gICAgICAgIGxpc3RfaXRlbTogYWRkKGxpc3RJdGVtLCB7IGNvbnRlbnQ6IGl0ZW1Db250ZW50IH0pXG4gICAgfSk7XG59XG4vKipcblJldHVybnMgYSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgd3JhcHMgdGhlIHNlbGVjdGlvbiBpbiBhIGxpc3Qgd2l0aFxudGhlIGdpdmVuIHR5cGUgYW4gYXR0cmlidXRlcy4gSWYgYGRpc3BhdGNoYCBpcyBudWxsLCBvbmx5IHJldHVybiBhXG52YWx1ZSB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoaXMgaXMgcG9zc2libGUsIGJ1dCBkb24ndCBhY3R1YWxseVxucGVyZm9ybSB0aGUgY2hhbmdlLlxuKi9cbmZ1bmN0aW9uIHdyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLCBkb0pvaW4gPSBmYWxzZSwgb3V0ZXJSYW5nZSA9IHJhbmdlO1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBUaGlzIGlzIGF0IHRoZSB0b3Agb2YgYW4gZXhpc3RpbmcgbGlzdCBpdGVtXG4gICAgICAgIGlmIChyYW5nZS5kZXB0aCA+PSAyICYmICRmcm9tLm5vZGUocmFuZ2UuZGVwdGggLSAxKS50eXBlLmNvbXBhdGlibGVDb250ZW50KGxpc3RUeXBlKSAmJiByYW5nZS5zdGFydEluZGV4ID09IDApIHtcbiAgICAgICAgICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHRoaXMgaXMgdGhlIHRvcCBvZiB0aGUgbGlzdFxuICAgICAgICAgICAgaWYgKCRmcm9tLmluZGV4KHJhbmdlLmRlcHRoIC0gMSkgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgJGluc2VydCA9IHN0YXRlLmRvYy5yZXNvbHZlKHJhbmdlLnN0YXJ0IC0gMik7XG4gICAgICAgICAgICBvdXRlclJhbmdlID0gbmV3IE5vZGVSYW5nZSgkaW5zZXJ0LCAkaW5zZXJ0LCByYW5nZS5kZXB0aCk7XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW5kSW5kZXggPCByYW5nZS5wYXJlbnQuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBOb2RlUmFuZ2UoJGZyb20sIHN0YXRlLmRvYy5yZXNvbHZlKCR0by5lbmQocmFuZ2UuZGVwdGgpKSwgcmFuZ2UuZGVwdGgpO1xuICAgICAgICAgICAgZG9Kb2luID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgd3JhcCA9IGZpbmRXcmFwcGluZyhvdXRlclJhbmdlLCBsaXN0VHlwZSwgYXR0cnMsIHJhbmdlKTtcbiAgICAgICAgaWYgKCF3cmFwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChkb1dyYXBJbkxpc3Qoc3RhdGUudHIsIHJhbmdlLCB3cmFwLCBkb0pvaW4sIGxpc3RUeXBlKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRvV3JhcEluTGlzdCh0ciwgcmFuZ2UsIHdyYXBwZXJzLCBqb2luQmVmb3JlLCBsaXN0VHlwZSkge1xuICAgIGxldCBjb250ZW50ID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgZm9yIChsZXQgaSA9IHdyYXBwZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh3cmFwcGVyc1tpXS50eXBlLmNyZWF0ZSh3cmFwcGVyc1tpXS5hdHRycywgY29udGVudCkpO1xuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHJhbmdlLnN0YXJ0IC0gKGpvaW5CZWZvcmUgPyAyIDogMCksIHJhbmdlLmVuZCwgcmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgbmV3IFNsaWNlKGNvbnRlbnQsIDAsIDApLCB3cmFwcGVycy5sZW5ndGgsIHRydWUpKTtcbiAgICBsZXQgZm91bmQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JhcHBlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICh3cmFwcGVyc1tpXS50eXBlID09IGxpc3RUeXBlKVxuICAgICAgICAgICAgZm91bmQgPSBpICsgMTtcbiAgICBsZXQgc3BsaXREZXB0aCA9IHdyYXBwZXJzLmxlbmd0aCAtIGZvdW5kO1xuICAgIGxldCBzcGxpdFBvcyA9IHJhbmdlLnN0YXJ0ICsgd3JhcHBlcnMubGVuZ3RoIC0gKGpvaW5CZWZvcmUgPyAyIDogMCksIHBhcmVudCA9IHJhbmdlLnBhcmVudDtcbiAgICBmb3IgKGxldCBpID0gcmFuZ2Uuc3RhcnRJbmRleCwgZSA9IHJhbmdlLmVuZEluZGV4LCBmaXJzdCA9IHRydWU7IGkgPCBlOyBpKyssIGZpcnN0ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFmaXJzdCAmJiBjYW5TcGxpdCh0ci5kb2MsIHNwbGl0UG9zLCBzcGxpdERlcHRoKSkge1xuICAgICAgICAgICAgdHIuc3BsaXQoc3BsaXRQb3MsIHNwbGl0RGVwdGgpO1xuICAgICAgICAgICAgc3BsaXRQb3MgKz0gMiAqIHNwbGl0RGVwdGg7XG4gICAgICAgIH1cbiAgICAgICAgc3BsaXRQb3MgKz0gcGFyZW50LmNoaWxkKGkpLm5vZGVTaXplO1xuICAgIH1cbiAgICByZXR1cm4gdHI7XG59XG4vKipcbkJ1aWxkIGEgY29tbWFuZCB0aGF0IHNwbGl0cyBhIG5vbi1lbXB0eSB0ZXh0YmxvY2sgYXQgdGhlIHRvcCBsZXZlbFxub2YgYSBsaXN0IGl0ZW0gYnkgYWxzbyBzcGxpdHRpbmcgdGhhdCBsaXN0IGl0ZW0uXG4qL1xuZnVuY3Rpb24gc3BsaXRMaXN0SXRlbShpdGVtVHlwZSwgaXRlbUF0dHJzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0bywgbm9kZSB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoKG5vZGUgJiYgbm9kZS5pc0Jsb2NrKSB8fCAkZnJvbS5kZXB0aCA8IDIgfHwgISRmcm9tLnNhbWVQYXJlbnQoJHRvKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGdyYW5kUGFyZW50ID0gJGZyb20ubm9kZSgtMSk7XG4gICAgICAgIGlmIChncmFuZFBhcmVudC50eXBlICE9IGl0ZW1UeXBlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoJGZyb20ucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmICRmcm9tLm5vZGUoLTEpLmNoaWxkQ291bnQgPT0gJGZyb20uaW5kZXhBZnRlcigtMSkpIHtcbiAgICAgICAgICAgIC8vIEluIGFuIGVtcHR5IGJsb2NrLiBJZiB0aGlzIGlzIGEgbmVzdGVkIGxpc3QsIHRoZSB3cmFwcGluZ1xuICAgICAgICAgICAgLy8gbGlzdCBpdGVtIHNob3VsZCBiZSBzcGxpdC4gT3RoZXJ3aXNlLCBiYWlsIG91dCBhbmQgbGV0IG5leHRcbiAgICAgICAgICAgIC8vIGNvbW1hbmQgaGFuZGxlIGxpZnRpbmcuXG4gICAgICAgICAgICBpZiAoJGZyb20uZGVwdGggPT0gMyB8fCAkZnJvbS5ub2RlKC0zKS50eXBlICE9IGl0ZW1UeXBlIHx8XG4gICAgICAgICAgICAgICAgJGZyb20uaW5kZXgoLTIpICE9ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgLSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCB3cmFwID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgICAgICAgICAgbGV0IGRlcHRoQmVmb3JlID0gJGZyb20uaW5kZXgoLTEpID8gMSA6ICRmcm9tLmluZGV4KC0yKSA/IDIgOiAzO1xuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIGEgZnJhZ21lbnQgY29udGFpbmluZyBlbXB0eSB2ZXJzaW9ucyBvZiB0aGUgc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgb3V0ZXIgbGlzdCBpdGVtIHRvIHRoZSBwYXJlbnQgbm9kZSBvZiB0aGUgY3Vyc29yXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9ICRmcm9tLmRlcHRoIC0gZGVwdGhCZWZvcmU7IGQgPj0gJGZyb20uZGVwdGggLSAzOyBkLS0pXG4gICAgICAgICAgICAgICAgICAgIHdyYXAgPSBGcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoZCkuY29weSh3cmFwKSk7XG4gICAgICAgICAgICAgICAgbGV0IGRlcHRoQWZ0ZXIgPSAkZnJvbS5pbmRleEFmdGVyKC0xKSA8ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgPyAxXG4gICAgICAgICAgICAgICAgICAgIDogJGZyb20uaW5kZXhBZnRlcigtMikgPCAkZnJvbS5ub2RlKC0zKS5jaGlsZENvdW50ID8gMiA6IDM7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgc2Vjb25kIGxpc3QgaXRlbSB3aXRoIGFuIGVtcHR5IGRlZmF1bHQgc3RhcnQgbm9kZVxuICAgICAgICAgICAgICAgIHdyYXAgPSB3cmFwLmFwcGVuZChGcmFnbWVudC5mcm9tKGl0ZW1UeXBlLmNyZWF0ZUFuZEZpbGwoKSkpO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9ICRmcm9tLmJlZm9yZSgkZnJvbS5kZXB0aCAtIChkZXB0aEJlZm9yZSAtIDEpKTtcbiAgICAgICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5yZXBsYWNlKHN0YXJ0LCAkZnJvbS5hZnRlcigtZGVwdGhBZnRlciksIG5ldyBTbGljZSh3cmFwLCA0IC0gZGVwdGhCZWZvcmUsIDApKTtcbiAgICAgICAgICAgICAgICBsZXQgc2VsID0gLTE7XG4gICAgICAgICAgICAgICAgdHIuZG9jLm5vZGVzQmV0d2VlbihzdGFydCwgdHIuZG9jLmNvbnRlbnQuc2l6ZSwgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsID4gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmlzVGV4dGJsb2NrICYmIG5vZGUuY29udGVudC5zaXplID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWwgPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzZWwgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKHNlbCkpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0VHlwZSA9ICR0by5wb3MgPT0gJGZyb20uZW5kKCkgPyBncmFuZFBhcmVudC5jb250ZW50TWF0Y2hBdCgwKS5kZWZhdWx0VHlwZSA6IG51bGw7XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLmRlbGV0ZSgkZnJvbS5wb3MsICR0by5wb3MpO1xuICAgICAgICBsZXQgdHlwZXMgPSBuZXh0VHlwZSA/IFtpdGVtQXR0cnMgPyB7IHR5cGU6IGl0ZW1UeXBlLCBhdHRyczogaXRlbUF0dHJzIH0gOiBudWxsLCB7IHR5cGU6IG5leHRUeXBlIH1dIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIWNhblNwbGl0KHRyLmRvYywgJGZyb20ucG9zLCAyLCB0eXBlcykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNwbGl0KCRmcm9tLnBvcywgMiwgdHlwZXMpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5DcmVhdGUgYSBjb21tYW5kIHRvIGxpZnQgdGhlIGxpc3QgaXRlbSBhcm91bmQgdGhlIHNlbGVjdGlvbiB1cCBpbnRvXG5hIHdyYXBwaW5nIGxpc3QuXG4qL1xuZnVuY3Rpb24gbGlmdExpc3RJdGVtKGl0ZW1UeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bywgbm9kZSA9PiBub2RlLmNoaWxkQ291bnQgPiAwICYmIG5vZGUuZmlyc3RDaGlsZC50eXBlID09IGl0ZW1UeXBlKTtcbiAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFkaXNwYXRjaClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoJGZyb20ubm9kZShyYW5nZS5kZXB0aCAtIDEpLnR5cGUgPT0gaXRlbVR5cGUpIC8vIEluc2lkZSBhIHBhcmVudCBsaXN0XG4gICAgICAgICAgICByZXR1cm4gbGlmdFRvT3V0ZXJMaXN0KHN0YXRlLCBkaXNwYXRjaCwgaXRlbVR5cGUsIHJhbmdlKTtcbiAgICAgICAgZWxzZSAvLyBPdXRlciBsaXN0IG5vZGVcbiAgICAgICAgICAgIHJldHVybiBsaWZ0T3V0T2ZMaXN0KHN0YXRlLCBkaXNwYXRjaCwgcmFuZ2UpO1xuICAgIH07XG59XG5mdW5jdGlvbiBsaWZ0VG9PdXRlckxpc3Qoc3RhdGUsIGRpc3BhdGNoLCBpdGVtVHlwZSwgcmFuZ2UpIHtcbiAgICBsZXQgdHIgPSBzdGF0ZS50ciwgZW5kID0gcmFuZ2UuZW5kLCBlbmRPZkxpc3QgPSByYW5nZS4kdG8uZW5kKHJhbmdlLmRlcHRoKTtcbiAgICBpZiAoZW5kIDwgZW5kT2ZMaXN0KSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBzaWJsaW5ncyBhZnRlciB0aGUgbGlmdGVkIGl0ZW1zLCB3aGljaCBtdXN0IGJlY29tZVxuICAgICAgICAvLyBjaGlsZHJlbiBvZiB0aGUgbGFzdCBpdGVtXG4gICAgICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKGVuZCAtIDEsIGVuZE9mTGlzdCwgZW5kLCBlbmRPZkxpc3QsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKGl0ZW1UeXBlLmNyZWF0ZShudWxsLCByYW5nZS5wYXJlbnQuY29weSgpKSksIDEsIDApLCAxLCB0cnVlKSk7XG4gICAgICAgIHJhbmdlID0gbmV3IE5vZGVSYW5nZSh0ci5kb2MucmVzb2x2ZShyYW5nZS4kZnJvbS5wb3MpLCB0ci5kb2MucmVzb2x2ZShlbmRPZkxpc3QpLCByYW5nZS5kZXB0aCk7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyLmxpZnQocmFuZ2UsIHRhcmdldCk7XG4gICAgbGV0IGFmdGVyID0gdHIubWFwcGluZy5tYXAoZW5kLCAtMSkgLSAxO1xuICAgIGlmIChjYW5Kb2luKHRyLmRvYywgYWZ0ZXIpKVxuICAgICAgICB0ci5qb2luKGFmdGVyKTtcbiAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGxpZnRPdXRPZkxpc3Qoc3RhdGUsIGRpc3BhdGNoLCByYW5nZSkge1xuICAgIGxldCB0ciA9IHN0YXRlLnRyLCBsaXN0ID0gcmFuZ2UucGFyZW50O1xuICAgIC8vIE1lcmdlIHRoZSBsaXN0IGl0ZW1zIGludG8gYSBzaW5nbGUgYmlnIGl0ZW1cbiAgICBmb3IgKGxldCBwb3MgPSByYW5nZS5lbmQsIGkgPSByYW5nZS5lbmRJbmRleCAtIDEsIGUgPSByYW5nZS5zdGFydEluZGV4OyBpID4gZTsgaS0tKSB7XG4gICAgICAgIHBvcyAtPSBsaXN0LmNoaWxkKGkpLm5vZGVTaXplO1xuICAgICAgICB0ci5kZWxldGUocG9zIC0gMSwgcG9zICsgMSk7XG4gICAgfVxuICAgIGxldCAkc3RhcnQgPSB0ci5kb2MucmVzb2x2ZShyYW5nZS5zdGFydCksIGl0ZW0gPSAkc3RhcnQubm9kZUFmdGVyO1xuICAgIGlmICh0ci5tYXBwaW5nLm1hcChyYW5nZS5lbmQpICE9IHJhbmdlLnN0YXJ0ICsgJHN0YXJ0Lm5vZGVBZnRlci5ub2RlU2l6ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhdFN0YXJ0ID0gcmFuZ2Uuc3RhcnRJbmRleCA9PSAwLCBhdEVuZCA9IHJhbmdlLmVuZEluZGV4ID09IGxpc3QuY2hpbGRDb3VudDtcbiAgICBsZXQgcGFyZW50ID0gJHN0YXJ0Lm5vZGUoLTEpLCBpbmRleEJlZm9yZSA9ICRzdGFydC5pbmRleCgtMSk7XG4gICAgaWYgKCFwYXJlbnQuY2FuUmVwbGFjZShpbmRleEJlZm9yZSArIChhdFN0YXJ0ID8gMCA6IDEpLCBpbmRleEJlZm9yZSArIDEsIGl0ZW0uY29udGVudC5hcHBlbmQoYXRFbmQgPyBGcmFnbWVudC5lbXB0eSA6IEZyYWdtZW50LmZyb20obGlzdCkpKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzdGFydCA9ICRzdGFydC5wb3MsIGVuZCA9IHN0YXJ0ICsgaXRlbS5ub2RlU2l6ZTtcbiAgICAvLyBTdHJpcCBvZmYgdGhlIHN1cnJvdW5kaW5nIGxpc3QuIEF0IHRoZSBzaWRlcyB3aGVyZSB3ZSdyZSBub3QgYXRcbiAgICAvLyB0aGUgZW5kIG9mIHRoZSBsaXN0LCB0aGUgZXhpc3RpbmcgbGlzdCBpcyBjbG9zZWQuIEF0IHNpZGVzIHdoZXJlXG4gICAgLy8gdGhpcyBpcyB0aGUgZW5kLCBpdCBpcyBvdmVyd3JpdHRlbiB0byBpdHMgZW5kLlxuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0IC0gKGF0U3RhcnQgPyAxIDogMCksIGVuZCArIChhdEVuZCA/IDEgOiAwKSwgc3RhcnQgKyAxLCBlbmQgLSAxLCBuZXcgU2xpY2UoKGF0U3RhcnQgPyBGcmFnbWVudC5lbXB0eSA6IEZyYWdtZW50LmZyb20obGlzdC5jb3B5KEZyYWdtZW50LmVtcHR5KSkpXG4gICAgICAgIC5hcHBlbmQoYXRFbmQgPyBGcmFnbWVudC5lbXB0eSA6IEZyYWdtZW50LmZyb20obGlzdC5jb3B5KEZyYWdtZW50LmVtcHR5KSkpLCBhdFN0YXJ0ID8gMCA6IDEsIGF0RW5kID8gMCA6IDEpLCBhdFN0YXJ0ID8gMCA6IDEpKTtcbiAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuQ3JlYXRlIGEgY29tbWFuZCB0byBzaW5rIHRoZSBsaXN0IGl0ZW0gYXJvdW5kIHRoZSBzZWxlY3Rpb24gZG93blxuaW50byBhbiBpbm5lciBsaXN0LlxuKi9cbmZ1bmN0aW9uIHNpbmtMaXN0SXRlbShpdGVtVHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8sIG5vZGUgPT4gbm9kZS5jaGlsZENvdW50ID4gMCAmJiBub2RlLmZpcnN0Q2hpbGQudHlwZSA9PSBpdGVtVHlwZSk7XG4gICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydEluZGV4ID0gcmFuZ2Uuc3RhcnRJbmRleDtcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHBhcmVudCA9IHJhbmdlLnBhcmVudCwgbm9kZUJlZm9yZSA9IHBhcmVudC5jaGlsZChzdGFydEluZGV4IC0gMSk7XG4gICAgICAgIGlmIChub2RlQmVmb3JlLnR5cGUgIT0gaXRlbVR5cGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgbGV0IG5lc3RlZEJlZm9yZSA9IG5vZGVCZWZvcmUubGFzdENoaWxkICYmIG5vZGVCZWZvcmUubGFzdENoaWxkLnR5cGUgPT0gcGFyZW50LnR5cGU7XG4gICAgICAgICAgICBsZXQgaW5uZXIgPSBGcmFnbWVudC5mcm9tKG5lc3RlZEJlZm9yZSA/IGl0ZW1UeXBlLmNyZWF0ZSgpIDogbnVsbCk7XG4gICAgICAgICAgICBsZXQgc2xpY2UgPSBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShpdGVtVHlwZS5jcmVhdGUobnVsbCwgRnJhZ21lbnQuZnJvbShwYXJlbnQudHlwZS5jcmVhdGUobnVsbCwgaW5uZXIpKSkpLCBuZXN0ZWRCZWZvcmUgPyAzIDogMSwgMCk7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gcmFuZ2Uuc3RhcnQsIGFmdGVyID0gcmFuZ2UuZW5kO1xuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoYmVmb3JlIC0gKG5lc3RlZEJlZm9yZSA/IDMgOiAxKSwgYWZ0ZXIsIGJlZm9yZSwgYWZ0ZXIsIHNsaWNlLCAxLCB0cnVlKSlcbiAgICAgICAgICAgICAgICAuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgYWRkTGlzdE5vZGVzLCBidWxsZXRMaXN0LCBsaWZ0TGlzdEl0ZW0sIGxpc3RJdGVtLCBvcmRlcmVkTGlzdCwgc2lua0xpc3RJdGVtLCBzcGxpdExpc3RJdGVtLCB3cmFwSW5MaXN0IH07XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUsIFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVN0YXRlKGNvbmZpZzoge1xuICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25cbiAgc3RhdGU6IEVkaXRvclN0YXRlXG59KTogRWRpdG9yU3RhdGUge1xuICBjb25zdCB7IHN0YXRlLCB0cmFuc2FjdGlvbiB9ID0gY29uZmlnXG4gIGxldCB7IHNlbGVjdGlvbiB9ID0gdHJhbnNhY3Rpb25cbiAgbGV0IHsgZG9jIH0gPSB0cmFuc2FjdGlvblxuICBsZXQgeyBzdG9yZWRNYXJrcyB9ID0gdHJhbnNhY3Rpb25cblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGFwcGx5OiBzdGF0ZS5hcHBseS5iaW5kKHN0YXRlKSxcbiAgICBhcHBseVRyYW5zYWN0aW9uOiBzdGF0ZS5hcHBseVRyYW5zYWN0aW9uLmJpbmQoc3RhdGUpLFxuICAgIGZpbHRlclRyYW5zYWN0aW9uOiBzdGF0ZS5maWx0ZXJUcmFuc2FjdGlvbixcbiAgICBwbHVnaW5zOiBzdGF0ZS5wbHVnaW5zLFxuICAgIHNjaGVtYTogc3RhdGUuc2NoZW1hLFxuICAgIHJlY29uZmlndXJlOiBzdGF0ZS5yZWNvbmZpZ3VyZS5iaW5kKHN0YXRlKSxcbiAgICB0b0pTT046IHN0YXRlLnRvSlNPTi5iaW5kKHN0YXRlKSxcbiAgICBnZXQgc3RvcmVkTWFya3MoKSB7XG4gICAgICByZXR1cm4gc3RvcmVkTWFya3NcbiAgICB9LFxuICAgIGdldCBzZWxlY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2VsZWN0aW9uXG4gICAgfSxcbiAgICBnZXQgZG9jKCkge1xuICAgICAgcmV0dXJuIGRvY1xuICAgIH0sXG4gICAgZ2V0IHRyKCkge1xuICAgICAgc2VsZWN0aW9uID0gdHJhbnNhY3Rpb24uc2VsZWN0aW9uXG4gICAgICBkb2MgPSB0cmFuc2FjdGlvbi5kb2NcbiAgICAgIHN0b3JlZE1hcmtzID0gdHJhbnNhY3Rpb24uc3RvcmVkTWFya3NcblxuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uXG4gICAgfSxcbiAgfVxufVxuIiwgImltcG9ydCB7IEVkaXRvclN0YXRlLCBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgY3JlYXRlQ2hhaW5hYmxlU3RhdGUgfSBmcm9tICcuL2hlbHBlcnMvY3JlYXRlQ2hhaW5hYmxlU3RhdGUuanMnXG5pbXBvcnQge1xuICBBbnlDb21tYW5kcywgQ2FuQ29tbWFuZHMsIENoYWluZWRDb21tYW5kcywgQ29tbWFuZFByb3BzLCBTaW5nbGVDb21tYW5kcyxcbn0gZnJvbSAnLi90eXBlcy5qcydcblxuZXhwb3J0IGNsYXNzIENvbW1hbmRNYW5hZ2VyIHtcbiAgZWRpdG9yOiBFZGl0b3JcblxuICByYXdDb21tYW5kczogQW55Q29tbWFuZHNcblxuICBjdXN0b21TdGF0ZT86IEVkaXRvclN0YXRlXG5cbiAgY29uc3RydWN0b3IocHJvcHM6IHsgZWRpdG9yOiBFZGl0b3I7IHN0YXRlPzogRWRpdG9yU3RhdGUgfSkge1xuICAgIHRoaXMuZWRpdG9yID0gcHJvcHMuZWRpdG9yXG4gICAgdGhpcy5yYXdDb21tYW5kcyA9IHRoaXMuZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuY29tbWFuZHNcbiAgICB0aGlzLmN1c3RvbVN0YXRlID0gcHJvcHMuc3RhdGVcbiAgfVxuXG4gIGdldCBoYXNDdXN0b21TdGF0ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLmN1c3RvbVN0YXRlXG4gIH1cblxuICBnZXQgc3RhdGUoKTogRWRpdG9yU3RhdGUge1xuICAgIHJldHVybiB0aGlzLmN1c3RvbVN0YXRlIHx8IHRoaXMuZWRpdG9yLnN0YXRlXG4gIH1cblxuICBnZXQgY29tbWFuZHMoKTogU2luZ2xlQ29tbWFuZHMge1xuICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXNcbiAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvclxuICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlXG4gICAgY29uc3QgcHJvcHMgPSB0aGlzLmJ1aWxkUHJvcHModHIpXG5cbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMocmF3Q29tbWFuZHMpLm1hcCgoW25hbWUsIGNvbW1hbmRdKSA9PiB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gY29tbWFuZCguLi5hcmdzKShwcm9wcylcblxuICAgICAgICAgIGlmICghdHIuZ2V0TWV0YSgncHJldmVudERpc3BhdGNoJykgJiYgIXRoaXMuaGFzQ3VzdG9tU3RhdGUpIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW25hbWUsIG1ldGhvZF1cbiAgICAgIH0pLFxuICAgICkgYXMgdW5rbm93biBhcyBTaW5nbGVDb21tYW5kc1xuICB9XG5cbiAgZ2V0IGNoYWluKCk6ICgpID0+IENoYWluZWRDb21tYW5kcyB7XG4gICAgcmV0dXJuICgpID0+IHRoaXMuY3JlYXRlQ2hhaW4oKVxuICB9XG5cbiAgZ2V0IGNhbigpOiAoKSA9PiBDYW5Db21tYW5kcyB7XG4gICAgcmV0dXJuICgpID0+IHRoaXMuY3JlYXRlQ2FuKClcbiAgfVxuXG4gIHB1YmxpYyBjcmVhdGVDaGFpbihzdGFydFRyPzogVHJhbnNhY3Rpb24sIHNob3VsZERpc3BhdGNoID0gdHJ1ZSk6IENoYWluZWRDb21tYW5kcyB7XG4gICAgY29uc3QgeyByYXdDb21tYW5kcywgZWRpdG9yLCBzdGF0ZSB9ID0gdGhpc1xuICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yXG4gICAgY29uc3QgY2FsbGJhY2tzOiBib29sZWFuW10gPSBbXVxuICAgIGNvbnN0IGhhc1N0YXJ0VHJhbnNhY3Rpb24gPSAhIXN0YXJ0VHJcbiAgICBjb25zdCB0ciA9IHN0YXJ0VHIgfHwgc3RhdGUudHJcblxuICAgIGNvbnN0IHJ1biA9ICgpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgIWhhc1N0YXJ0VHJhbnNhY3Rpb25cbiAgICAgICAgJiYgc2hvdWxkRGlzcGF0Y2hcbiAgICAgICAgJiYgIXRyLmdldE1ldGEoJ3ByZXZlbnREaXNwYXRjaCcpXG4gICAgICAgICYmICF0aGlzLmhhc0N1c3RvbVN0YXRlXG4gICAgICApIHtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh0cilcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhbGxiYWNrcy5ldmVyeShjYWxsYmFjayA9PiBjYWxsYmFjayA9PT0gdHJ1ZSlcbiAgICB9XG5cbiAgICBjb25zdCBjaGFpbiA9IHtcbiAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocmF3Q29tbWFuZHMpLm1hcCgoW25hbWUsIGNvbW1hbmRdKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hhaW5lZENvbW1hbmQgPSAoLi4uYXJnczogbmV2ZXJbXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLmJ1aWxkUHJvcHModHIsIHNob3VsZERpc3BhdGNoKVxuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjb21tYW5kKC4uLmFyZ3MpKHByb3BzKVxuXG4gICAgICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjaylcblxuICAgICAgICAgICAgcmV0dXJuIGNoYWluXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFtuYW1lLCBjaGFpbmVkQ29tbWFuZF1cbiAgICAgICAgfSksXG4gICAgICApLFxuICAgICAgcnVuLFxuICAgIH0gYXMgdW5rbm93biBhcyBDaGFpbmVkQ29tbWFuZHNcblxuICAgIHJldHVybiBjaGFpblxuICB9XG5cbiAgcHVibGljIGNyZWF0ZUNhbihzdGFydFRyPzogVHJhbnNhY3Rpb24pOiBDYW5Db21tYW5kcyB7XG4gICAgY29uc3QgeyByYXdDb21tYW5kcywgc3RhdGUgfSA9IHRoaXNcbiAgICBjb25zdCBkaXNwYXRjaCA9IGZhbHNlXG4gICAgY29uc3QgdHIgPSBzdGFydFRyIHx8IHN0YXRlLnRyXG4gICAgY29uc3QgcHJvcHMgPSB0aGlzLmJ1aWxkUHJvcHModHIsIGRpc3BhdGNoKVxuICAgIGNvbnN0IGZvcm1hdHRlZENvbW1hbmRzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMocmF3Q29tbWFuZHMpLm1hcCgoW25hbWUsIGNvbW1hbmRdKSA9PiB7XG4gICAgICAgIHJldHVybiBbbmFtZSwgKC4uLmFyZ3M6IG5ldmVyW10pID0+IGNvbW1hbmQoLi4uYXJncykoeyAuLi5wcm9wcywgZGlzcGF0Y2g6IHVuZGVmaW5lZCB9KV1cbiAgICAgIH0pLFxuICAgICkgYXMgdW5rbm93biBhcyBTaW5nbGVDb21tYW5kc1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZvcm1hdHRlZENvbW1hbmRzLFxuICAgICAgY2hhaW46ICgpID0+IHRoaXMuY3JlYXRlQ2hhaW4odHIsIGRpc3BhdGNoKSxcbiAgICB9IGFzIENhbkNvbW1hbmRzXG4gIH1cblxuICBwdWJsaWMgYnVpbGRQcm9wcyh0cjogVHJhbnNhY3Rpb24sIHNob3VsZERpc3BhdGNoID0gdHJ1ZSk6IENvbW1hbmRQcm9wcyB7XG4gICAgY29uc3QgeyByYXdDb21tYW5kcywgZWRpdG9yLCBzdGF0ZSB9ID0gdGhpc1xuICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yXG5cbiAgICBjb25zdCBwcm9wczogQ29tbWFuZFByb3BzID0ge1xuICAgICAgdHIsXG4gICAgICBlZGl0b3IsXG4gICAgICB2aWV3LFxuICAgICAgc3RhdGU6IGNyZWF0ZUNoYWluYWJsZVN0YXRlKHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHRyYW5zYWN0aW9uOiB0cixcbiAgICAgIH0pLFxuICAgICAgZGlzcGF0Y2g6IHNob3VsZERpc3BhdGNoID8gKCkgPT4gdW5kZWZpbmVkIDogdW5kZWZpbmVkLFxuICAgICAgY2hhaW46ICgpID0+IHRoaXMuY3JlYXRlQ2hhaW4odHIsIHNob3VsZERpc3BhdGNoKSxcbiAgICAgIGNhbjogKCkgPT4gdGhpcy5jcmVhdGVDYW4odHIpLFxuICAgICAgZ2V0IGNvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kXSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtuYW1lLCAoLi4uYXJnczogbmV2ZXJbXSkgPT4gY29tbWFuZCguLi5hcmdzKShwcm9wcyldXG4gICAgICAgICAgfSksXG4gICAgICAgICkgYXMgdW5rbm93biBhcyBTaW5nbGVDb21tYW5kc1xuICAgICAgfSxcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHNcbiAgfVxufVxuIiwgInR5cGUgU3RyaW5nS2V5T2Y8VD4gPSBFeHRyYWN0PGtleW9mIFQsIHN0cmluZz5cbnR5cGUgQ2FsbGJhY2tUeXBlPFxuICBUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PixcbiAgRXZlbnROYW1lIGV4dGVuZHMgU3RyaW5nS2V5T2Y8VD4sXG4+ID0gVFtFdmVudE5hbWVdIGV4dGVuZHMgYW55W10gPyBUW0V2ZW50TmFtZV0gOiBbVFtFdmVudE5hbWVdXVxudHlwZSBDYWxsYmFja0Z1bmN0aW9uPFxuICBUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PixcbiAgRXZlbnROYW1lIGV4dGVuZHMgU3RyaW5nS2V5T2Y8VD4sXG4+ID0gKC4uLnByb3BzOiBDYWxsYmFja1R5cGU8VCwgRXZlbnROYW1lPikgPT4gYW55XG5cbmV4cG9ydCBjbGFzcyBFdmVudEVtaXR0ZXI8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4+IHtcblxuICBwcml2YXRlIGNhbGxiYWNrczogeyBba2V5OiBzdHJpbmddOiBGdW5jdGlvbltdIH0gPSB7fVxuXG4gIHB1YmxpYyBvbjxFdmVudE5hbWUgZXh0ZW5kcyBTdHJpbmdLZXlPZjxUPj4oZXZlbnQ6IEV2ZW50TmFtZSwgZm46IENhbGxiYWNrRnVuY3Rpb248VCwgRXZlbnROYW1lPik6IHRoaXMge1xuICAgIGlmICghdGhpcy5jYWxsYmFja3NbZXZlbnRdKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0gPSBbXVxuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XS5wdXNoKGZuKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByb3RlY3RlZCBlbWl0PEV2ZW50TmFtZSBleHRlbmRzIFN0cmluZ0tleU9mPFQ+PihldmVudDogRXZlbnROYW1lLCAuLi5hcmdzOiBDYWxsYmFja1R5cGU8VCwgRXZlbnROYW1lPik6IHRoaXMge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzW2V2ZW50XVxuXG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgY2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJncykpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHB1YmxpYyBvZmY8RXZlbnROYW1lIGV4dGVuZHMgU3RyaW5nS2V5T2Y8VD4+KGV2ZW50OiBFdmVudE5hbWUsIGZuPzogQ2FsbGJhY2tGdW5jdGlvbjxULCBFdmVudE5hbWU+KTogdGhpcyB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3NbZXZlbnRdXG5cbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdID0gY2FsbGJhY2tzLmZpbHRlcihjYWxsYmFjayA9PiBjYWxsYmFjayAhPT0gZm4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFja3NbZXZlbnRdXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByb3RlY3RlZCByZW1vdmVBbGxMaXN0ZW5lcnMoKTogdm9pZCB7XG4gICAgdGhpcy5jYWxsYmFja3MgPSB7fVxuICB9XG59XG4iLCAiaW1wb3J0IHsgQW55RXh0ZW5zaW9uLCBNYXliZVRoaXNQYXJhbWV0ZXJUeXBlLCBSZW1vdmVUaGlzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFeHRlbnNpb25GaWVsZDxUID0gYW55PihcbiAgZXh0ZW5zaW9uOiBBbnlFeHRlbnNpb24sXG4gIGZpZWxkOiBzdHJpbmcsXG4gIGNvbnRleHQ/OiBPbWl0PE1heWJlVGhpc1BhcmFtZXRlclR5cGU8VD4sICdwYXJlbnQnPixcbik6IFJlbW92ZVRoaXM8VD4ge1xuXG4gIGlmIChleHRlbnNpb24uY29uZmlnW2ZpZWxkXSA9PT0gdW5kZWZpbmVkICYmIGV4dGVuc2lvbi5wYXJlbnQpIHtcbiAgICByZXR1cm4gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLnBhcmVudCwgZmllbGQsIGNvbnRleHQpXG4gIH1cblxuICBpZiAodHlwZW9mIGV4dGVuc2lvbi5jb25maWdbZmllbGRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgdmFsdWUgPSBleHRlbnNpb24uY29uZmlnW2ZpZWxkXS5iaW5kKHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICBwYXJlbnQ6IGV4dGVuc2lvbi5wYXJlbnRcbiAgICAgICAgPyBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24ucGFyZW50LCBmaWVsZCwgY29udGV4dClcbiAgICAgICAgOiBudWxsLFxuICAgIH0pXG5cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJldHVybiBleHRlbnNpb24uY29uZmlnW2ZpZWxkXVxufVxuIiwgImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcbmltcG9ydCB7IE1hcmsgfSBmcm9tICcuLi9NYXJrLmpzJ1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4uL05vZGUuanMnXG5pbXBvcnQgeyBFeHRlbnNpb25zIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdEV4dGVuc2lvbnMoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucykge1xuICBjb25zdCBiYXNlRXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMuZmlsdGVyKGV4dGVuc2lvbiA9PiBleHRlbnNpb24udHlwZSA9PT0gJ2V4dGVuc2lvbicpIGFzIEV4dGVuc2lvbltdXG4gIGNvbnN0IG5vZGVFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi50eXBlID09PSAnbm9kZScpIGFzIE5vZGVbXVxuICBjb25zdCBtYXJrRXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMuZmlsdGVyKGV4dGVuc2lvbiA9PiBleHRlbnNpb24udHlwZSA9PT0gJ21hcmsnKSBhcyBNYXJrW11cblxuICByZXR1cm4ge1xuICAgIGJhc2VFeHRlbnNpb25zLFxuICAgIG5vZGVFeHRlbnNpb25zLFxuICAgIG1hcmtFeHRlbnNpb25zLFxuICB9XG59XG4iLCAiaW1wb3J0IHsgTWFya0NvbmZpZywgTm9kZUNvbmZpZyB9IGZyb20gJy4uL2luZGV4LmpzJ1xuaW1wb3J0IHtcbiAgQW55Q29uZmlnLFxuICBBdHRyaWJ1dGUsXG4gIEF0dHJpYnV0ZXMsXG4gIEV4dGVuc2lvbkF0dHJpYnV0ZSxcbiAgRXh0ZW5zaW9ucyxcbiAgR2xvYmFsQXR0cmlidXRlcyxcbn0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBzcGxpdEV4dGVuc2lvbnMgfSBmcm9tICcuL3NwbGl0RXh0ZW5zaW9ucy5qcydcblxuLyoqXG4gKiBHZXQgYSBsaXN0IG9mIGFsbCBleHRlbnNpb24gYXR0cmlidXRlcyBkZWZpbmVkIGluIGBhZGRBdHRyaWJ1dGVgIGFuZCBgYWRkR2xvYmFsQXR0cmlidXRlYC5cbiAqIEBwYXJhbSBleHRlbnNpb25zIExpc3Qgb2YgZXh0ZW5zaW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpOiBFeHRlbnNpb25BdHRyaWJ1dGVbXSB7XG4gIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXM6IEV4dGVuc2lvbkF0dHJpYnV0ZVtdID0gW11cbiAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucywgbWFya0V4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKVxuICBjb25zdCBub2RlQW5kTWFya0V4dGVuc2lvbnMgPSBbLi4ubm9kZUV4dGVuc2lvbnMsIC4uLm1hcmtFeHRlbnNpb25zXVxuICBjb25zdCBkZWZhdWx0QXR0cmlidXRlOiBSZXF1aXJlZDxBdHRyaWJ1dGU+ID0ge1xuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgcmVuZGVyZWQ6IHRydWUsXG4gICAgcmVuZGVySFRNTDogbnVsbCxcbiAgICBwYXJzZUhUTUw6IG51bGwsXG4gICAga2VlcE9uU3BsaXQ6IHRydWUsXG4gICAgaXNSZXF1aXJlZDogZmFsc2UsXG4gIH1cblxuICBleHRlbnNpb25zLmZvckVhY2goZXh0ZW5zaW9uID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgIH1cblxuICAgIGNvbnN0IGFkZEdsb2JhbEF0dHJpYnV0ZXMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZEdsb2JhbEF0dHJpYnV0ZXMnXT4oXG4gICAgICBleHRlbnNpb24sXG4gICAgICAnYWRkR2xvYmFsQXR0cmlidXRlcycsXG4gICAgICBjb250ZXh0LFxuICAgIClcblxuICAgIGlmICghYWRkR2xvYmFsQXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGBhcyBHbG9iYWxBdHRyaWJ1dGVzYFxuICAgIGNvbnN0IGdsb2JhbEF0dHJpYnV0ZXMgPSBhZGRHbG9iYWxBdHRyaWJ1dGVzKCkgYXMgR2xvYmFsQXR0cmlidXRlc1xuXG4gICAgZ2xvYmFsQXR0cmlidXRlcy5mb3JFYWNoKGdsb2JhbEF0dHJpYnV0ZSA9PiB7XG4gICAgICBnbG9iYWxBdHRyaWJ1dGUudHlwZXMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgICAgT2JqZWN0XG4gICAgICAgICAgLmVudHJpZXMoZ2xvYmFsQXR0cmlidXRlLmF0dHJpYnV0ZXMpXG4gICAgICAgICAgLmZvckVhY2goKFtuYW1lLCBhdHRyaWJ1dGVdKSA9PiB7XG4gICAgICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGU6IHtcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0QXR0cmlidXRlLFxuICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcblxuICBub2RlQW5kTWFya0V4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgfVxuXG4gICAgY29uc3QgYWRkQXR0cmlidXRlcyA9IGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2FkZEF0dHJpYnV0ZXMnXSB8IE1hcmtDb25maWdbJ2FkZEF0dHJpYnV0ZXMnXT4oXG4gICAgICBleHRlbnNpb24sXG4gICAgICAnYWRkQXR0cmlidXRlcycsXG4gICAgICBjb250ZXh0LFxuICAgIClcblxuICAgIGlmICghYWRkQXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGBhcyBBdHRyaWJ1dGVzYFxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBhZGRBdHRyaWJ1dGVzKCkgYXMgQXR0cmlidXRlc1xuXG4gICAgT2JqZWN0XG4gICAgICAuZW50cmllcyhhdHRyaWJ1dGVzKVxuICAgICAgLmZvckVhY2goKFtuYW1lLCBhdHRyaWJ1dGVdKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lcmdlZEF0dHIgPSB7XG4gICAgICAgICAgLi4uZGVmYXVsdEF0dHJpYnV0ZSxcbiAgICAgICAgICAuLi5hdHRyaWJ1dGUsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1lcmdlZEF0dHI/LmRlZmF1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBtZXJnZWRBdHRyLmRlZmF1bHQgPSBtZXJnZWRBdHRyLmRlZmF1bHQoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lcmdlZEF0dHI/LmlzUmVxdWlyZWQgJiYgbWVyZ2VkQXR0cj8uZGVmYXVsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVsZXRlIG1lcmdlZEF0dHIuZGVmYXVsdFxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGF0dHJpYnV0ZTogbWVyZ2VkQXR0cixcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIGV4dGVuc2lvbkF0dHJpYnV0ZXNcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSwgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVUeXBlKG5hbWVPclR5cGU6IHN0cmluZyB8IE5vZGVUeXBlLCBzY2hlbWE6IFNjaGVtYSk6IE5vZGVUeXBlIHtcbiAgaWYgKHR5cGVvZiBuYW1lT3JUeXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmICghc2NoZW1hLm5vZGVzW25hbWVPclR5cGVdKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYFRoZXJlIGlzIG5vIG5vZGUgdHlwZSBuYW1lZCAnJHtuYW1lT3JUeXBlfScuIE1heWJlIHlvdSBmb3Jnb3QgdG8gYWRkIHRoZSBleHRlbnNpb24/YCxcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gc2NoZW1hLm5vZGVzW25hbWVPclR5cGVdXG4gIH1cblxuICByZXR1cm4gbmFtZU9yVHlwZVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBtZXJnZUF0dHJpYnV0ZXMoLi4ub2JqZWN0czogUmVjb3JkPHN0cmluZywgYW55PltdKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIHJldHVybiBvYmplY3RzXG4gICAgLmZpbHRlcihpdGVtID0+ICEhaXRlbSlcbiAgICAucmVkdWNlKChpdGVtcywgaXRlbSkgPT4ge1xuICAgICAgY29uc3QgbWVyZ2VkQXR0cmlidXRlcyA9IHsgLi4uaXRlbXMgfVxuXG4gICAgICBPYmplY3QuZW50cmllcyhpdGVtKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgY29uc3QgZXhpc3RzID0gbWVyZ2VkQXR0cmlidXRlc1trZXldXG5cbiAgICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZVxuXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWVDbGFzc2VzOiBzdHJpbmdbXSA9IHZhbHVlID8gdmFsdWUuc3BsaXQoJyAnKSA6IFtdXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdDbGFzc2VzOiBzdHJpbmdbXSA9IG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA/IG1lcmdlZEF0dHJpYnV0ZXNba2V5XS5zcGxpdCgnICcpIDogW11cblxuICAgICAgICAgIGNvbnN0IGluc2VydENsYXNzZXMgPSB2YWx1ZUNsYXNzZXMuZmlsdGVyKFxuICAgICAgICAgICAgdmFsdWVDbGFzcyA9PiAhZXhpc3RpbmdDbGFzc2VzLmluY2x1ZGVzKHZhbHVlQ2xhc3MpLFxuICAgICAgICAgIClcblxuICAgICAgICAgIG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA9IFsuLi5leGlzdGluZ0NsYXNzZXMsIC4uLmluc2VydENsYXNzZXNdLmpvaW4oJyAnKVxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgIG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA9IFttZXJnZWRBdHRyaWJ1dGVzW2tleV0sIHZhbHVlXS5qb2luKCc7ICcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gdmFsdWVcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIG1lcmdlZEF0dHJpYnV0ZXNcbiAgICB9LCB7fSlcbn1cbiIsICJpbXBvcnQgeyBNYXJrLCBOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRXh0ZW5zaW9uQXR0cmlidXRlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICcuLi91dGlsaXRpZXMvbWVyZ2VBdHRyaWJ1dGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKFxuICBub2RlT3JNYXJrOiBOb2RlIHwgTWFyayxcbiAgZXh0ZW5zaW9uQXR0cmlidXRlczogRXh0ZW5zaW9uQXR0cmlidXRlW10sXG4pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgcmV0dXJuIGV4dGVuc2lvbkF0dHJpYnV0ZXNcbiAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS5hdHRyaWJ1dGUucmVuZGVyZWQpXG4gICAgLm1hcChpdGVtID0+IHtcbiAgICAgIGlmICghaXRlbS5hdHRyaWJ1dGUucmVuZGVySFRNTCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIFtpdGVtLm5hbWVdOiBub2RlT3JNYXJrLmF0dHJzW2l0ZW0ubmFtZV0sXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZW0uYXR0cmlidXRlLnJlbmRlckhUTUwobm9kZU9yTWFyay5hdHRycykgfHwge31cbiAgICB9KVxuICAgIC5yZWR1Y2UoKGF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSkgPT4gbWVyZ2VBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSksIHt9KVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBGdW5jdGlvbiB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbidcbn1cbiIsICJpbXBvcnQgeyBNYXliZVJldHVyblR5cGUgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuL2lzRnVuY3Rpb24uanMnXG5cbi8qKlxuICogT3B0aW9uYWxseSBjYWxscyBgdmFsdWVgIGFzIGEgZnVuY3Rpb24uXG4gKiBPdGhlcndpc2UgaXQgaXMgcmV0dXJuZWQgZGlyZWN0bHkuXG4gKiBAcGFyYW0gdmFsdWUgRnVuY3Rpb24gb3IgYW55IHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQgT3B0aW9uYWwgY29udGV4dCB0byBiaW5kIHRvIGZ1bmN0aW9uLlxuICogQHBhcmFtIHByb3BzIE9wdGlvbmFsIHByb3BzIHRvIHBhc3MgdG8gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxsT3JSZXR1cm48VD4odmFsdWU6IFQsIGNvbnRleHQ6IGFueSA9IHVuZGVmaW5lZCwgLi4ucHJvcHM6IGFueVtdKTogTWF5YmVSZXR1cm5UeXBlPFQ+IHtcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5iaW5kKGNvbnRleHQpKC4uLnByb3BzKVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZSguLi5wcm9wcylcbiAgfVxuXG4gIHJldHVybiB2YWx1ZSBhcyBNYXliZVJldHVyblR5cGU8VD5cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNFbXB0eU9iamVjdCh2YWx1ZSA9IHt9KTogYm9vbGVhbiB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Rcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZTogYW55KTogYW55IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIGlmICh2YWx1ZS5tYXRjaCgvXlsrLV0/KD86XFxkKlxcLik/XFxkKyQvKSkge1xuICAgIHJldHVybiBOdW1iZXIodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT09ICd0cnVlJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAodmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB2YWx1ZVxufVxuIiwgImltcG9ydCB7IFBhcnNlUnVsZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IEV4dGVuc2lvbkF0dHJpYnV0ZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZnJvbVN0cmluZyB9IGZyb20gJy4uL3V0aWxpdGllcy9mcm9tU3RyaW5nLmpzJ1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gbWVyZ2VzIGV4dGVuc2lvbiBhdHRyaWJ1dGVzIGludG8gcGFyc2VydWxlIGF0dHJpYnV0ZXMgKGBhdHRyc2Agb3IgYGdldEF0dHJzYCkuXG4gKiBDYW5jZWxzIHdoZW4gYGdldEF0dHJzYCByZXR1cm5lZCBgZmFsc2VgLlxuICogQHBhcmFtIHBhcnNlUnVsZSBQcm9zZU1pcnJvciBQYXJzZVJ1bGVcbiAqIEBwYXJhbSBleHRlbnNpb25BdHRyaWJ1dGVzIExpc3Qgb2YgYXR0cmlidXRlcyB0byBpbmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZShcbiAgcGFyc2VSdWxlOiBQYXJzZVJ1bGUsXG4gIGV4dGVuc2lvbkF0dHJpYnV0ZXM6IEV4dGVuc2lvbkF0dHJpYnV0ZVtdLFxuKTogUGFyc2VSdWxlIHtcbiAgaWYgKHBhcnNlUnVsZS5zdHlsZSkge1xuICAgIHJldHVybiBwYXJzZVJ1bGVcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4ucGFyc2VSdWxlLFxuICAgIGdldEF0dHJzOiBub2RlID0+IHtcbiAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBwYXJzZVJ1bGUuZ2V0QXR0cnMgPyBwYXJzZVJ1bGUuZ2V0QXR0cnMobm9kZSkgOiBwYXJzZVJ1bGUuYXR0cnNcblxuICAgICAgaWYgKG9sZEF0dHJpYnV0ZXMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gZXh0ZW5zaW9uQXR0cmlidXRlcy5yZWR1Y2UoKGl0ZW1zLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXRlbS5hdHRyaWJ1dGUucGFyc2VIVE1MXG4gICAgICAgICAgPyBpdGVtLmF0dHJpYnV0ZS5wYXJzZUhUTUwobm9kZSBhcyBIVE1MRWxlbWVudClcbiAgICAgICAgICA6IGZyb21TdHJpbmcoKG5vZGUgYXMgSFRNTEVsZW1lbnQpLmdldEF0dHJpYnV0ZShpdGVtLm5hbWUpKVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW1zXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLml0ZW1zLFxuICAgICAgICAgIFtpdGVtLm5hbWVdOiB2YWx1ZSxcbiAgICAgICAgfVxuICAgICAgfSwge30pXG5cbiAgICAgIHJldHVybiB7IC4uLm9sZEF0dHJpYnV0ZXMsIC4uLm5ld0F0dHJpYnV0ZXMgfVxuICAgIH0sXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBNYXJrU3BlYywgTm9kZVNwZWMsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IEVkaXRvciwgTWFya0NvbmZpZywgTm9kZUNvbmZpZyB9IGZyb20gJy4uL2luZGV4LmpzJ1xuaW1wb3J0IHsgQW55Q29uZmlnLCBFeHRlbnNpb25zIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuaW1wb3J0IHsgaXNFbXB0eU9iamVjdCB9IGZyb20gJy4uL3V0aWxpdGllcy9pc0VtcHR5T2JqZWN0LmpzJ1xuaW1wb3J0IHsgZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zIH0gZnJvbSAnLi9nZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMgfSBmcm9tICcuL2dldFJlbmRlcmVkQXR0cmlidXRlcy5qcydcbmltcG9ydCB7IGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZSB9IGZyb20gJy4vaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlLmpzJ1xuaW1wb3J0IHsgc3BsaXRFeHRlbnNpb25zIH0gZnJvbSAnLi9zcGxpdEV4dGVuc2lvbnMuanMnXG5cbmZ1bmN0aW9uIGNsZWFuVXBTY2hlbWFJdGVtPFQ+KGRhdGE6IFQpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgT2JqZWN0LmVudHJpZXMoZGF0YSkuZmlsdGVyKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmIChrZXkgPT09ICdhdHRycycgJiYgaXNFbXB0eU9iamVjdCh2YWx1ZSBhcyB7fSB8IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkXG4gICAgfSksXG4gICkgYXMgVFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucywgZWRpdG9yPzogRWRpdG9yKTogU2NoZW1hIHtcbiAgY29uc3QgYWxsQXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyhleHRlbnNpb25zKVxuICBjb25zdCB7IG5vZGVFeHRlbnNpb25zLCBtYXJrRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpXG4gIGNvbnN0IHRvcE5vZGUgPSBub2RlRXh0ZW5zaW9ucy5maW5kKGV4dGVuc2lvbiA9PiBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICd0b3BOb2RlJykpPy5uYW1lXG5cbiAgY29uc3Qgbm9kZXMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgbm9kZUV4dGVuc2lvbnMubWFwKGV4dGVuc2lvbiA9PiB7XG4gICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gYWxsQXR0cmlidXRlcy5maWx0ZXIoXG4gICAgICAgIGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUsXG4gICAgICApXG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICBlZGl0b3IsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4dHJhTm9kZUZpZWxkcyA9IGV4dGVuc2lvbnMucmVkdWNlKChmaWVsZHMsIGUpID0+IHtcbiAgICAgICAgY29uc3QgZXh0ZW5kTm9kZVNjaGVtYSA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snZXh0ZW5kTm9kZVNjaGVtYSddPihcbiAgICAgICAgICBlLFxuICAgICAgICAgICdleHRlbmROb2RlU2NoZW1hJyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICApXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgLi4uKGV4dGVuZE5vZGVTY2hlbWEgPyBleHRlbmROb2RlU2NoZW1hKGV4dGVuc2lvbikgOiB7fSksXG4gICAgICAgIH1cbiAgICAgIH0sIHt9KVxuXG4gICAgICBjb25zdCBzY2hlbWE6IE5vZGVTcGVjID0gY2xlYW5VcFNjaGVtYUl0ZW0oe1xuICAgICAgICAuLi5leHRyYU5vZGVGaWVsZHMsXG4gICAgICAgIGNvbnRlbnQ6IGNhbGxPclJldHVybihcbiAgICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydjb250ZW50J10+KGV4dGVuc2lvbiwgJ2NvbnRlbnQnLCBjb250ZXh0KSxcbiAgICAgICAgKSxcbiAgICAgICAgbWFya3M6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydtYXJrcyddPihleHRlbnNpb24sICdtYXJrcycsIGNvbnRleHQpKSxcbiAgICAgICAgZ3JvdXA6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydncm91cCddPihleHRlbnNpb24sICdncm91cCcsIGNvbnRleHQpKSxcbiAgICAgICAgaW5saW5lOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snaW5saW5lJ10+KGV4dGVuc2lvbiwgJ2lubGluZScsIGNvbnRleHQpKSxcbiAgICAgICAgYXRvbTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2F0b20nXT4oZXh0ZW5zaW9uLCAnYXRvbScsIGNvbnRleHQpKSxcbiAgICAgICAgc2VsZWN0YWJsZTogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ3NlbGVjdGFibGUnXT4oZXh0ZW5zaW9uLCAnc2VsZWN0YWJsZScsIGNvbnRleHQpLFxuICAgICAgICApLFxuICAgICAgICBkcmFnZ2FibGU6IGNhbGxPclJldHVybihcbiAgICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydkcmFnZ2FibGUnXT4oZXh0ZW5zaW9uLCAnZHJhZ2dhYmxlJywgY29udGV4dCksXG4gICAgICAgICksXG4gICAgICAgIGNvZGU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydjb2RlJ10+KGV4dGVuc2lvbiwgJ2NvZGUnLCBjb250ZXh0KSksXG4gICAgICAgIGRlZmluaW5nOiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snZGVmaW5pbmcnXT4oZXh0ZW5zaW9uLCAnZGVmaW5pbmcnLCBjb250ZXh0KSxcbiAgICAgICAgKSxcbiAgICAgICAgaXNvbGF0aW5nOiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snaXNvbGF0aW5nJ10+KGV4dGVuc2lvbiwgJ2lzb2xhdGluZycsIGNvbnRleHQpLFxuICAgICAgICApLFxuICAgICAgICBhdHRyczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMubWFwKGV4dGVuc2lvbkF0dHJpYnV0ZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbkF0dHJpYnV0ZS5uYW1lLCB7IGRlZmF1bHQ6IGV4dGVuc2lvbkF0dHJpYnV0ZT8uYXR0cmlidXRlPy5kZWZhdWx0IH1dXG4gICAgICAgICAgfSksXG4gICAgICAgICksXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBwYXJzZUhUTUwgPSBjYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ3BhcnNlSFRNTCddPihleHRlbnNpb24sICdwYXJzZUhUTUwnLCBjb250ZXh0KSxcbiAgICAgIClcblxuICAgICAgaWYgKHBhcnNlSFRNTCkge1xuICAgICAgICBzY2hlbWEucGFyc2VET00gPSBwYXJzZUhUTUwubWFwKHBhcnNlUnVsZSA9PiBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUocGFyc2VSdWxlLCBleHRlbnNpb25BdHRyaWJ1dGVzKSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVuZGVySFRNTCA9IGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ3JlbmRlckhUTUwnXT4oXG4gICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgJ3JlbmRlckhUTUwnLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuXG4gICAgICBpZiAocmVuZGVySFRNTCkge1xuICAgICAgICBzY2hlbWEudG9ET00gPSBub2RlID0+IHJlbmRlckhUTUwoe1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IGdldFJlbmRlcmVkQXR0cmlidXRlcyhub2RlLCBleHRlbnNpb25BdHRyaWJ1dGVzKSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVuZGVyVGV4dCA9IGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ3JlbmRlclRleHQnXT4oXG4gICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgJ3JlbmRlclRleHQnLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuXG4gICAgICBpZiAocmVuZGVyVGV4dCkge1xuICAgICAgICBzY2hlbWEudG9UZXh0ID0gcmVuZGVyVGV4dFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2V4dGVuc2lvbi5uYW1lLCBzY2hlbWFdXG4gICAgfSksXG4gIClcblxuICBjb25zdCBtYXJrcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBtYXJrRXh0ZW5zaW9ucy5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBhbGxBdHRyaWJ1dGVzLmZpbHRlcihcbiAgICAgICAgYXR0cmlidXRlID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSxcbiAgICAgIClcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgIGVkaXRvcixcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXh0cmFNYXJrRmllbGRzID0gZXh0ZW5zaW9ucy5yZWR1Y2UoKGZpZWxkcywgZSkgPT4ge1xuICAgICAgICBjb25zdCBleHRlbmRNYXJrU2NoZW1hID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydleHRlbmRNYXJrU2NoZW1hJ10+KFxuICAgICAgICAgIGUsXG4gICAgICAgICAgJ2V4dGVuZE1hcmtTY2hlbWEnLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIClcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAuLi4oZXh0ZW5kTWFya1NjaGVtYSA/IGV4dGVuZE1hcmtTY2hlbWEoZXh0ZW5zaW9uKSA6IHt9KSxcbiAgICAgICAgfVxuICAgICAgfSwge30pXG5cbiAgICAgIGNvbnN0IHNjaGVtYTogTWFya1NwZWMgPSBjbGVhblVwU2NoZW1hSXRlbSh7XG4gICAgICAgIC4uLmV4dHJhTWFya0ZpZWxkcyxcbiAgICAgICAgaW5jbHVzaXZlOiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1snaW5jbHVzaXZlJ10+KGV4dGVuc2lvbiwgJ2luY2x1c2l2ZScsIGNvbnRleHQpLFxuICAgICAgICApLFxuICAgICAgICBleGNsdWRlczogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE1hcmtDb25maWdbJ2V4Y2x1ZGVzJ10+KGV4dGVuc2lvbiwgJ2V4Y2x1ZGVzJywgY29udGV4dCksXG4gICAgICAgICksXG4gICAgICAgIGdyb3VwOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1snZ3JvdXAnXT4oZXh0ZW5zaW9uLCAnZ3JvdXAnLCBjb250ZXh0KSksXG4gICAgICAgIHNwYW5uaW5nOiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1snc3Bhbm5pbmcnXT4oZXh0ZW5zaW9uLCAnc3Bhbm5pbmcnLCBjb250ZXh0KSxcbiAgICAgICAgKSxcbiAgICAgICAgY29kZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE1hcmtDb25maWdbJ2NvZGUnXT4oZXh0ZW5zaW9uLCAnY29kZScsIGNvbnRleHQpKSxcbiAgICAgICAgYXR0cnM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLm1hcChleHRlbnNpb25BdHRyaWJ1dGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25BdHRyaWJ1dGUubmFtZSwgeyBkZWZhdWx0OiBleHRlbnNpb25BdHRyaWJ1dGU/LmF0dHJpYnV0ZT8uZGVmYXVsdCB9XVxuICAgICAgICAgIH0pLFxuICAgICAgICApLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgcGFyc2VIVE1MID0gY2FsbE9yUmV0dXJuKFxuICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydwYXJzZUhUTUwnXT4oZXh0ZW5zaW9uLCAncGFyc2VIVE1MJywgY29udGV4dCksXG4gICAgICApXG5cbiAgICAgIGlmIChwYXJzZUhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnBhcnNlRE9NID0gcGFyc2VIVE1MLm1hcChwYXJzZVJ1bGUgPT4gaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlKHBhcnNlUnVsZSwgZXh0ZW5zaW9uQXR0cmlidXRlcykpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlbmRlckhUTUwgPSBnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydyZW5kZXJIVE1MJ10+KFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICdyZW5kZXJIVE1MJyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgIClcblxuICAgICAgaWYgKHJlbmRlckhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnRvRE9NID0gbWFyayA9PiByZW5kZXJIVE1MKHtcbiAgICAgICAgICBtYXJrLFxuICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobWFyaywgZXh0ZW5zaW9uQXR0cmlidXRlcyksXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIHNjaGVtYV1cbiAgICB9KSxcbiAgKVxuXG4gIHJldHVybiBuZXcgU2NoZW1hKHtcbiAgICB0b3BOb2RlLFxuICAgIG5vZGVzLFxuICAgIG1hcmtzLFxuICB9KVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlLCBOb2RlVHlwZSwgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjaGVtYVR5cGVCeU5hbWUobmFtZTogc3RyaW5nLCBzY2hlbWE6IFNjaGVtYSk6IE5vZGVUeXBlIHwgTWFya1R5cGUgfCBudWxsIHtcbiAgcmV0dXJuIHNjaGVtYS5ub2Rlc1tuYW1lXSB8fCBzY2hlbWEubWFya3NbbmFtZV0gfHwgbnVsbFxufVxuIiwgImltcG9ydCB7IEFueUV4dGVuc2lvbiwgRW5hYmxlUnVsZXMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkKGV4dGVuc2lvbjogQW55RXh0ZW5zaW9uLCBlbmFibGVkOiBFbmFibGVSdWxlcyk6IGJvb2xlYW4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShlbmFibGVkKSkge1xuICAgIHJldHVybiBlbmFibGVkLnNvbWUoZW5hYmxlZEV4dGVuc2lvbiA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gdHlwZW9mIGVuYWJsZWRFeHRlbnNpb24gPT09ICdzdHJpbmcnXG4gICAgICAgID8gZW5hYmxlZEV4dGVuc2lvblxuICAgICAgICA6IGVuYWJsZWRFeHRlbnNpb24ubmFtZVxuXG4gICAgICByZXR1cm4gbmFtZSA9PT0gZXh0ZW5zaW9uLm5hbWVcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIGVuYWJsZWRcbn1cbiIsICJpbXBvcnQgeyBSZXNvbHZlZFBvcyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBjb25zdCBnZXRUZXh0Q29udGVudEZyb21Ob2RlcyA9ICgkZnJvbTogUmVzb2x2ZWRQb3MsIG1heE1hdGNoID0gNTAwKSA9PiB7XG4gIGxldCB0ZXh0QmVmb3JlID0gJydcblxuICBjb25zdCBzbGljZUVuZFBvcyA9ICRmcm9tLnBhcmVudE9mZnNldFxuXG4gICRmcm9tLnBhcmVudC5ub2Rlc0JldHdlZW4oXG4gICAgTWF0aC5tYXgoMCwgc2xpY2VFbmRQb3MgLSBtYXhNYXRjaCksXG4gICAgc2xpY2VFbmRQb3MsXG4gICAgKG5vZGUsIHBvcywgcGFyZW50LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgY2h1bmsgPSBub2RlLnR5cGUuc3BlYy50b1RleHQ/Lih7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIHBvcyxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBpbmRleCxcbiAgICAgIH0pXG4gICAgICAgIHx8IG5vZGUudGV4dENvbnRlbnRcbiAgICAgICAgfHwgJyVsZWFmJSdcblxuICAgICAgdGV4dEJlZm9yZSArPSBjaHVuay5zbGljZSgwLCBNYXRoLm1heCgwLCBzbGljZUVuZFBvcyAtIHBvcykpXG4gICAgfSxcbiAgKVxuXG4gIHJldHVybiB0ZXh0QmVmb3JlXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBSZWdFeHAge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cbiIsICJpbXBvcnQgeyBFZGl0b3JTdGF0ZSwgUGx1Z2luLCBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgQ29tbWFuZE1hbmFnZXIgfSBmcm9tICcuL0NvbW1hbmRNYW5hZ2VyLmpzJ1xuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBjcmVhdGVDaGFpbmFibGVTdGF0ZSB9IGZyb20gJy4vaGVscGVycy9jcmVhdGVDaGFpbmFibGVTdGF0ZS5qcydcbmltcG9ydCB7IGdldFRleHRDb250ZW50RnJvbU5vZGVzIH0gZnJvbSAnLi9oZWxwZXJzL2dldFRleHRDb250ZW50RnJvbU5vZGVzLmpzJ1xuaW1wb3J0IHtcbiAgQ2FuQ29tbWFuZHMsXG4gIENoYWluZWRDb21tYW5kcyxcbiAgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5LFxuICBSYW5nZSxcbiAgU2luZ2xlQ29tbWFuZHMsXG59IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBpc1JlZ0V4cCB9IGZyb20gJy4vdXRpbGl0aWVzL2lzUmVnRXhwLmpzJ1xuXG5leHBvcnQgdHlwZSBJbnB1dFJ1bGVNYXRjaCA9IHtcbiAgaW5kZXg6IG51bWJlclxuICB0ZXh0OiBzdHJpbmdcbiAgcmVwbGFjZVdpdGg/OiBzdHJpbmdcbiAgbWF0Y2g/OiBSZWdFeHBNYXRjaEFycmF5XG4gIGRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG59XG5cbmV4cG9ydCB0eXBlIElucHV0UnVsZUZpbmRlciA9IFJlZ0V4cCB8ICgodGV4dDogc3RyaW5nKSA9PiBJbnB1dFJ1bGVNYXRjaCB8IG51bGwpXG5cbmV4cG9ydCBjbGFzcyBJbnB1dFJ1bGUge1xuICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXJcblxuICBoYW5kbGVyOiAocHJvcHM6IHtcbiAgICBzdGF0ZTogRWRpdG9yU3RhdGVcbiAgICByYW5nZTogUmFuZ2VcbiAgICBtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5XG4gICAgY29tbWFuZHM6IFNpbmdsZUNvbW1hbmRzXG4gICAgY2hhaW46ICgpID0+IENoYWluZWRDb21tYW5kc1xuICAgIGNhbjogKCkgPT4gQ2FuQ29tbWFuZHNcbiAgfSkgPT4gdm9pZCB8IG51bGxcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IHtcbiAgICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXJcbiAgICBoYW5kbGVyOiAocHJvcHM6IHtcbiAgICAgIHN0YXRlOiBFZGl0b3JTdGF0ZVxuICAgICAgcmFuZ2U6IFJhbmdlXG4gICAgICBtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5XG4gICAgICBjb21tYW5kczogU2luZ2xlQ29tbWFuZHNcbiAgICAgIGNoYWluOiAoKSA9PiBDaGFpbmVkQ29tbWFuZHNcbiAgICAgIGNhbjogKCkgPT4gQ2FuQ29tbWFuZHNcbiAgICB9KSA9PiB2b2lkIHwgbnVsbFxuICB9KSB7XG4gICAgdGhpcy5maW5kID0gY29uZmlnLmZpbmRcbiAgICB0aGlzLmhhbmRsZXIgPSBjb25maWcuaGFuZGxlclxuICB9XG59XG5cbmNvbnN0IGlucHV0UnVsZU1hdGNoZXJIYW5kbGVyID0gKFxuICB0ZXh0OiBzdHJpbmcsXG4gIGZpbmQ6IElucHV0UnVsZUZpbmRlcixcbik6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB8IG51bGwgPT4ge1xuICBpZiAoaXNSZWdFeHAoZmluZCkpIHtcbiAgICByZXR1cm4gZmluZC5leGVjKHRleHQpXG4gIH1cblxuICBjb25zdCBpbnB1dFJ1bGVNYXRjaCA9IGZpbmQodGV4dClcblxuICBpZiAoIWlucHV0UnVsZU1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5ID0gW2lucHV0UnVsZU1hdGNoLnRleHRdXG5cbiAgcmVzdWx0LmluZGV4ID0gaW5wdXRSdWxlTWF0Y2guaW5kZXhcbiAgcmVzdWx0LmlucHV0ID0gdGV4dFxuICByZXN1bHQuZGF0YSA9IGlucHV0UnVsZU1hdGNoLmRhdGFcblxuICBpZiAoaW5wdXRSdWxlTWF0Y2gucmVwbGFjZVdpdGgpIHtcbiAgICBpZiAoIWlucHV0UnVsZU1hdGNoLnRleHQuaW5jbHVkZXMoaW5wdXRSdWxlTWF0Y2gucmVwbGFjZVdpdGgpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdbdGlwdGFwIHdhcm5dOiBcImlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoXCIgbXVzdCBiZSBwYXJ0IG9mIFwiaW5wdXRSdWxlTWF0Y2gudGV4dFwiLicsXG4gICAgICApXG4gICAgfVxuXG4gICAgcmVzdWx0LnB1c2goaW5wdXRSdWxlTWF0Y2gucmVwbGFjZVdpdGgpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHJ1bihjb25maWc6IHtcbiAgZWRpdG9yOiBFZGl0b3JcbiAgZnJvbTogbnVtYmVyXG4gIHRvOiBudW1iZXJcbiAgdGV4dDogc3RyaW5nXG4gIHJ1bGVzOiBJbnB1dFJ1bGVbXVxuICBwbHVnaW46IFBsdWdpblxufSk6IGJvb2xlYW4ge1xuICBjb25zdCB7XG4gICAgZWRpdG9yLCBmcm9tLCB0bywgdGV4dCwgcnVsZXMsIHBsdWdpbixcbiAgfSA9IGNvbmZpZ1xuICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvclxuXG4gIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgJGZyb20gPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGZyb20pXG5cbiAgaWYgKFxuICAgIC8vIGNoZWNrIGZvciBjb2RlIG5vZGVcbiAgICAkZnJvbS5wYXJlbnQudHlwZS5zcGVjLmNvZGVcbiAgICAvLyBjaGVjayBmb3IgY29kZSBtYXJrXG4gICAgfHwgISEoJGZyb20ubm9kZUJlZm9yZSB8fCAkZnJvbS5ub2RlQWZ0ZXIpPy5tYXJrcy5maW5kKG1hcmsgPT4gbWFyay50eXBlLnNwZWMuY29kZSlcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBsZXQgbWF0Y2hlZCA9IGZhbHNlXG5cbiAgY29uc3QgdGV4dEJlZm9yZSA9IGdldFRleHRDb250ZW50RnJvbU5vZGVzKCRmcm9tKSArIHRleHRcblxuICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBtYXRjaCA9IGlucHV0UnVsZU1hdGNoZXJIYW5kbGVyKHRleHRCZWZvcmUsIHJ1bGUuZmluZClcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRyID0gdmlldy5zdGF0ZS50clxuICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgc3RhdGU6IHZpZXcuc3RhdGUsXG4gICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgfSlcbiAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgIGZyb206IGZyb20gLSAobWF0Y2hbMF0ubGVuZ3RoIC0gdGV4dC5sZW5ndGgpLFxuICAgICAgdG8sXG4gICAgfVxuXG4gICAgY29uc3QgeyBjb21tYW5kcywgY2hhaW4sIGNhbiB9ID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgIGVkaXRvcixcbiAgICAgIHN0YXRlLFxuICAgIH0pXG5cbiAgICBjb25zdCBoYW5kbGVyID0gcnVsZS5oYW5kbGVyKHtcbiAgICAgIHN0YXRlLFxuICAgICAgcmFuZ2UsXG4gICAgICBtYXRjaCxcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgY2hhaW4sXG4gICAgICBjYW4sXG4gICAgfSlcblxuICAgIC8vIHN0b3AgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXNcbiAgICBpZiAoaGFuZGxlciA9PT0gbnVsbCB8fCAhdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBzdG9yZSB0cmFuc2Zvcm0gYXMgbWV0YSBkYXRhXG4gICAgLy8gc28gd2UgY2FuIHVuZG8gaW5wdXQgcnVsZXMgd2l0aGluIHRoZSBgdW5kb0lucHV0UnVsZXNgIGNvbW1hbmRcbiAgICB0ci5zZXRNZXRhKHBsdWdpbiwge1xuICAgICAgdHJhbnNmb3JtOiB0cixcbiAgICAgIGZyb20sXG4gICAgICB0byxcbiAgICAgIHRleHQsXG4gICAgfSlcblxuICAgIHZpZXcuZGlzcGF0Y2godHIpXG4gICAgbWF0Y2hlZCA9IHRydWVcbiAgfSlcblxuICByZXR1cm4gbWF0Y2hlZFxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnB1dCBydWxlcyBwbHVnaW4uIFdoZW4gZW5hYmxlZCwgaXQgd2lsbCBjYXVzZSB0ZXh0XG4gKiBpbnB1dCB0aGF0IG1hdGNoZXMgYW55IG9mIHRoZSBnaXZlbiBydWxlcyB0byB0cmlnZ2VyIHRoZSBydWxl4oCZc1xuICogYWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5wdXRSdWxlc1BsdWdpbihwcm9wczogeyBlZGl0b3I6IEVkaXRvcjsgcnVsZXM6IElucHV0UnVsZVtdIH0pOiBQbHVnaW4ge1xuICBjb25zdCB7IGVkaXRvciwgcnVsZXMgfSA9IHByb3BzXG4gIGNvbnN0IHBsdWdpbiA9IG5ldyBQbHVnaW4oe1xuICAgIHN0YXRlOiB7XG4gICAgICBpbml0KCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfSxcbiAgICAgIGFwcGx5KHRyLCBwcmV2KSB7XG4gICAgICAgIGNvbnN0IHN0b3JlZCA9IHRyLmdldE1ldGEocGx1Z2luKVxuXG4gICAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgICByZXR1cm4gc3RvcmVkXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHIuc2VsZWN0aW9uU2V0IHx8IHRyLmRvY0NoYW5nZWQgPyBudWxsIDogcHJldlxuICAgICAgfSxcbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcbiAgICAgIGhhbmRsZVRleHRJbnB1dCh2aWV3LCBmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICByZXR1cm4gcnVuKHtcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgZnJvbSxcbiAgICAgICAgICB0byxcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgfSlcbiAgICAgIH0sXG5cbiAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICBjb21wb3NpdGlvbmVuZDogdmlldyA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7ICRjdXJzb3IgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uIGFzIFRleHRTZWxlY3Rpb25cblxuICAgICAgICAgICAgaWYgKCRjdXJzb3IpIHtcbiAgICAgICAgICAgICAgcnVuKHtcbiAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgZnJvbTogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICAgICAgdG86ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0sXG4gICAgICB9LFxuXG4gICAgICAvLyBhZGQgc3VwcG9ydCBmb3IgaW5wdXQgcnVsZXMgdG8gdHJpZ2dlciBvbiBlbnRlclxuICAgICAgLy8gdGhpcyBpcyB1c2VmdWwgZm9yIGV4YW1wbGUgZm9yIGNvZGUgYmxvY2tzXG4gICAgICBoYW5kbGVLZXlEb3duKHZpZXcsIGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXkgIT09ICdFbnRlcicpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24gYXMgVGV4dFNlbGVjdGlvblxuXG4gICAgICAgIGlmICgkY3Vyc29yKSB7XG4gICAgICAgICAgcmV0dXJuIHJ1bih7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBmcm9tOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgIHRvOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgIHRleHQ6ICdcXG4nLFxuICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgICBwbHVnaW4sXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSxcbiAgICB9LFxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlzSW5wdXRSdWxlczogdHJ1ZSxcbiAgfSkgYXMgUGx1Z2luXG5cbiAgcmV0dXJuIHBsdWdpblxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBpc051bWJlcih2YWx1ZTogYW55KTogdmFsdWUgaXMgbnVtYmVyIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbn1cbiIsICJpbXBvcnQgeyBFZGl0b3JTdGF0ZSwgUGx1Z2luIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgQ29tbWFuZE1hbmFnZXIgfSBmcm9tICcuL0NvbW1hbmRNYW5hZ2VyLmpzJ1xuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBjcmVhdGVDaGFpbmFibGVTdGF0ZSB9IGZyb20gJy4vaGVscGVycy9jcmVhdGVDaGFpbmFibGVTdGF0ZS5qcydcbmltcG9ydCB7XG4gIENhbkNvbW1hbmRzLFxuICBDaGFpbmVkQ29tbWFuZHMsXG4gIEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSxcbiAgUmFuZ2UsXG4gIFNpbmdsZUNvbW1hbmRzLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tICcuL3V0aWxpdGllcy9pc051bWJlci5qcydcbmltcG9ydCB7IGlzUmVnRXhwIH0gZnJvbSAnLi91dGlsaXRpZXMvaXNSZWdFeHAuanMnXG5cbmV4cG9ydCB0eXBlIFBhc3RlUnVsZU1hdGNoID0ge1xuICBpbmRleDogbnVtYmVyXG4gIHRleHQ6IHN0cmluZ1xuICByZXBsYWNlV2l0aD86IHN0cmluZ1xuICBtYXRjaD86IFJlZ0V4cE1hdGNoQXJyYXlcbiAgZGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT5cbn1cblxuZXhwb3J0IHR5cGUgUGFzdGVSdWxlRmluZGVyID0gUmVnRXhwIHwgKCh0ZXh0OiBzdHJpbmcpID0+IFBhc3RlUnVsZU1hdGNoW10gfCBudWxsIHwgdW5kZWZpbmVkKVxuXG5leHBvcnQgY2xhc3MgUGFzdGVSdWxlIHtcbiAgZmluZDogUGFzdGVSdWxlRmluZGVyXG5cbiAgaGFuZGxlcjogKHByb3BzOiB7XG4gICAgc3RhdGU6IEVkaXRvclN0YXRlXG4gICAgcmFuZ2U6IFJhbmdlXG4gICAgbWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheVxuICAgIGNvbW1hbmRzOiBTaW5nbGVDb21tYW5kc1xuICAgIGNoYWluOiAoKSA9PiBDaGFpbmVkQ29tbWFuZHNcbiAgICBjYW46ICgpID0+IENhbkNvbW1hbmRzXG4gICAgcGFzdGVFdmVudDogQ2xpcGJvYXJkRXZlbnRcbiAgICBkcm9wRXZlbnQ6IERyYWdFdmVudFxuICB9KSA9PiB2b2lkIHwgbnVsbFxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzoge1xuICAgIGZpbmQ6IFBhc3RlUnVsZUZpbmRlclxuICAgIGhhbmRsZXI6IChwcm9wczoge1xuICAgICAgY2FuOiAoKSA9PiBDYW5Db21tYW5kc1xuICAgICAgY2hhaW46ICgpID0+IENoYWluZWRDb21tYW5kc1xuICAgICAgY29tbWFuZHM6IFNpbmdsZUNvbW1hbmRzXG4gICAgICBkcm9wRXZlbnQ6IERyYWdFdmVudFxuICAgICAgbWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheVxuICAgICAgcGFzdGVFdmVudDogQ2xpcGJvYXJkRXZlbnRcbiAgICAgIHJhbmdlOiBSYW5nZVxuICAgICAgc3RhdGU6IEVkaXRvclN0YXRlXG4gICAgfSkgPT4gdm9pZCB8IG51bGxcbiAgfSkge1xuICAgIHRoaXMuZmluZCA9IGNvbmZpZy5maW5kXG4gICAgdGhpcy5oYW5kbGVyID0gY29uZmlnLmhhbmRsZXJcbiAgfVxufVxuXG5jb25zdCBwYXN0ZVJ1bGVNYXRjaGVySGFuZGxlciA9IChcbiAgdGV4dDogc3RyaW5nLFxuICBmaW5kOiBQYXN0ZVJ1bGVGaW5kZXIsXG4pOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXlbXSA9PiB7XG4gIGlmIChpc1JlZ0V4cChmaW5kKSkge1xuICAgIHJldHVybiBbLi4udGV4dC5tYXRjaEFsbChmaW5kKV1cbiAgfVxuXG4gIGNvbnN0IG1hdGNoZXMgPSBmaW5kKHRleHQpXG5cbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcy5tYXAocGFzdGVSdWxlTWF0Y2ggPT4ge1xuICAgIGNvbnN0IHJlc3VsdDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5ID0gW3Bhc3RlUnVsZU1hdGNoLnRleHRdXG5cbiAgICByZXN1bHQuaW5kZXggPSBwYXN0ZVJ1bGVNYXRjaC5pbmRleFxuICAgIHJlc3VsdC5pbnB1dCA9IHRleHRcbiAgICByZXN1bHQuZGF0YSA9IHBhc3RlUnVsZU1hdGNoLmRhdGFcblxuICAgIGlmIChwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkge1xuICAgICAgaWYgKCFwYXN0ZVJ1bGVNYXRjaC50ZXh0LmluY2x1ZGVzKHBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ1t0aXB0YXAgd2Fybl06IFwicGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGhcIiBtdXN0IGJlIHBhcnQgb2YgXCJwYXN0ZVJ1bGVNYXRjaC50ZXh0XCIuJyxcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICByZXN1bHQucHVzaChwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJ1bihjb25maWc6IHtcbiAgZWRpdG9yOiBFZGl0b3JcbiAgc3RhdGU6IEVkaXRvclN0YXRlXG4gIGZyb206IG51bWJlclxuICB0bzogbnVtYmVyXG4gIHJ1bGU6IFBhc3RlUnVsZVxuICBwYXN0ZUV2ZW50OiBDbGlwYm9hcmRFdmVudFxuICBkcm9wRXZlbnQ6IERyYWdFdmVudFxufSk6IGJvb2xlYW4ge1xuICBjb25zdCB7XG4gICAgZWRpdG9yLCBzdGF0ZSwgZnJvbSwgdG8sIHJ1bGUsIHBhc3RlRXZlbnQsIGRyb3BFdmVudCxcbiAgfSA9IGNvbmZpZ1xuXG4gIGNvbnN0IHsgY29tbWFuZHMsIGNoYWluLCBjYW4gfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgZWRpdG9yLFxuICAgIHN0YXRlLFxuICB9KVxuXG4gIGNvbnN0IGhhbmRsZXJzOiAodm9pZCB8IG51bGwpW10gPSBbXVxuXG4gIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICBpZiAoIW5vZGUuaXNUZXh0YmxvY2sgfHwgbm9kZS50eXBlLnNwZWMuY29kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVzb2x2ZWRGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKVxuICAgIGNvbnN0IHJlc29sdmVkVG8gPSBNYXRoLm1pbih0bywgcG9zICsgbm9kZS5jb250ZW50LnNpemUpXG4gICAgY29uc3QgdGV4dFRvTWF0Y2ggPSBub2RlLnRleHRCZXR3ZWVuKHJlc29sdmVkRnJvbSAtIHBvcywgcmVzb2x2ZWRUbyAtIHBvcywgdW5kZWZpbmVkLCAnXFx1ZmZmYycpXG5cbiAgICBjb25zdCBtYXRjaGVzID0gcGFzdGVSdWxlTWF0Y2hlckhhbmRsZXIodGV4dFRvTWF0Y2gsIHJ1bGUuZmluZClcblxuICAgIG1hdGNoZXMuZm9yRWFjaChtYXRjaCA9PiB7XG4gICAgICBpZiAobWF0Y2guaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhcnQgPSByZXNvbHZlZEZyb20gKyBtYXRjaC5pbmRleCArIDFcbiAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgICAgZnJvbTogc3RhdGUudHIubWFwcGluZy5tYXAoc3RhcnQpLFxuICAgICAgICB0bzogc3RhdGUudHIubWFwcGluZy5tYXAoZW5kKSxcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGFuZGxlciA9IHJ1bGUuaGFuZGxlcih7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICByYW5nZSxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGNvbW1hbmRzLFxuICAgICAgICBjaGFpbixcbiAgICAgICAgY2FuLFxuICAgICAgICBwYXN0ZUV2ZW50LFxuICAgICAgICBkcm9wRXZlbnQsXG4gICAgICB9KVxuXG4gICAgICBoYW5kbGVycy5wdXNoKGhhbmRsZXIpXG4gICAgfSlcbiAgfSlcblxuICBjb25zdCBzdWNjZXNzID0gaGFuZGxlcnMuZXZlcnkoaGFuZGxlciA9PiBoYW5kbGVyICE9PSBudWxsKVxuXG4gIHJldHVybiBzdWNjZXNzXG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIHBhc3RlIHJ1bGVzIHBsdWdpbi4gV2hlbiBlbmFibGVkLCBpdCB3aWxsIGNhdXNlIHBhc3RlZFxuICogdGV4dCB0aGF0IG1hdGNoZXMgYW55IG9mIHRoZSBnaXZlbiBydWxlcyB0byB0cmlnZ2VyIHRoZSBydWxl4oCZc1xuICogYWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFzdGVSdWxlc1BsdWdpbihwcm9wczogeyBlZGl0b3I6IEVkaXRvcjsgcnVsZXM6IFBhc3RlUnVsZVtdIH0pOiBQbHVnaW5bXSB7XG4gIGNvbnN0IHsgZWRpdG9yLCBydWxlcyB9ID0gcHJvcHNcbiAgbGV0IGRyYWdTb3VyY2VFbGVtZW50OiBFbGVtZW50IHwgbnVsbCA9IG51bGxcbiAgbGV0IGlzUGFzdGVkRnJvbVByb3NlTWlycm9yID0gZmFsc2VcbiAgbGV0IGlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvciA9IGZhbHNlXG4gIGxldCBwYXN0ZUV2ZW50ID0gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScpXG4gIGxldCBkcm9wRXZlbnQgPSBuZXcgRHJhZ0V2ZW50KCdkcm9wJylcblxuICBjb25zdCBwbHVnaW5zID0gcnVsZXMubWFwKHJ1bGUgPT4ge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgIC8vIHdlIHJlZ2lzdGVyIGEgZ2xvYmFsIGRyYWcgaGFuZGxlciB0byB0cmFjayB0aGUgY3VycmVudCBkcmFnIHNvdXJjZSBlbGVtZW50XG4gICAgICB2aWV3KHZpZXcpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlRHJhZ3N0YXJ0ID0gKGV2ZW50OiBEcmFnRXZlbnQpID0+IHtcbiAgICAgICAgICBkcmFnU291cmNlRWxlbWVudCA9IHZpZXcuZG9tLnBhcmVudEVsZW1lbnQ/LmNvbnRhaW5zKGV2ZW50LnRhcmdldCBhcyBFbGVtZW50KVxuICAgICAgICAgICAgPyB2aWV3LmRvbS5wYXJlbnRFbGVtZW50XG4gICAgICAgICAgICA6IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBoYW5kbGVEcmFnc3RhcnQpXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkZXN0cm95KCkge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIGhhbmRsZURyYWdzdGFydClcbiAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICBkcm9wOiAodmlldywgZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpc0Ryb3BwZWRGcm9tUHJvc2VNaXJyb3IgPSBkcmFnU291cmNlRWxlbWVudCA9PT0gdmlldy5kb20ucGFyZW50RWxlbWVudFxuICAgICAgICAgICAgZHJvcEV2ZW50ID0gZXZlbnQgYXMgRHJhZ0V2ZW50XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBwYXN0ZTogKF92aWV3LCBldmVudDogRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSAoZXZlbnQgYXMgQ2xpcGJvYXJkRXZlbnQpLmNsaXBib2FyZERhdGE/LmdldERhdGEoJ3RleHQvaHRtbCcpXG5cbiAgICAgICAgICAgIHBhc3RlRXZlbnQgPSBldmVudCBhcyBDbGlwYm9hcmRFdmVudFxuXG4gICAgICAgICAgICBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9ICEhaHRtbD8uaW5jbHVkZXMoJ2RhdGEtcG0tc2xpY2UnKVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcblxuICAgICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbnMsIG9sZFN0YXRlLCBzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uc1swXVxuICAgICAgICBjb25zdCBpc1Bhc3RlID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgndWlFdmVudCcpID09PSAncGFzdGUnICYmICFpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvclxuICAgICAgICBjb25zdCBpc0Ryb3AgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCd1aUV2ZW50JykgPT09ICdkcm9wJyAmJiAhaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yXG5cbiAgICAgICAgaWYgKCFpc1Bhc3RlICYmICFpc0Ryb3ApIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0b3AgaWYgdGhlcmUgaXMgbm8gY2hhbmdlZCByYW5nZVxuICAgICAgICBjb25zdCBmcm9tID0gb2xkU3RhdGUuZG9jLmNvbnRlbnQuZmluZERpZmZTdGFydChzdGF0ZS5kb2MuY29udGVudClcbiAgICAgICAgY29uc3QgdG8gPSBvbGRTdGF0ZS5kb2MuY29udGVudC5maW5kRGlmZkVuZChzdGF0ZS5kb2MuY29udGVudClcblxuICAgICAgICBpZiAoIWlzTnVtYmVyKGZyb20pIHx8ICF0byB8fCBmcm9tID09PSB0by5iKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBidWlsZCBhIGNoYWluYWJsZSBzdGF0ZVxuICAgICAgICAvLyBzbyB3ZSBjYW4gdXNlIGEgc2luZ2xlIHRyYW5zYWN0aW9uIGZvciBhbGwgcGFzdGUgcnVsZXNcbiAgICAgICAgY29uc3QgdHIgPSBzdGF0ZS50clxuICAgICAgICBjb25zdCBjaGFpbmFibGVTdGF0ZSA9IGNyZWF0ZUNoYWluYWJsZVN0YXRlKHtcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHJ1bih7XG4gICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgIHN0YXRlOiBjaGFpbmFibGVTdGF0ZSxcbiAgICAgICAgICBmcm9tOiBNYXRoLm1heChmcm9tIC0gMSwgMCksXG4gICAgICAgICAgdG86IHRvLmIgLSAxLFxuICAgICAgICAgIHJ1bGUsXG4gICAgICAgICAgcGFzdGVFdmVudCxcbiAgICAgICAgICBkcm9wRXZlbnQsXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gc3RvcCBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlc1xuICAgICAgICBpZiAoIWhhbmRsZXIgfHwgIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgZHJvcEV2ZW50ID0gbmV3IERyYWdFdmVudCgnZHJvcCcpXG4gICAgICAgIHBhc3RlRXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJylcblxuICAgICAgICByZXR1cm4gdHJcbiAgICAgIH0sXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gcGx1Z2luc1xufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBmaW5kRHVwbGljYXRlcyhpdGVtczogYW55W10pOiBhbnlbXSB7XG4gIGNvbnN0IGZpbHRlcmVkID0gaXRlbXMuZmlsdGVyKChlbCwgaW5kZXgpID0+IGl0ZW1zLmluZGV4T2YoZWwpICE9PSBpbmRleClcblxuICByZXR1cm4gWy4uLm5ldyBTZXQoZmlsdGVyZWQpXVxufVxuIiwgImltcG9ydCB7IGtleW1hcCB9IGZyb20gJ0B0aXB0YXAvcG0va2V5bWFwJ1xuaW1wb3J0IHsgTm9kZSBhcyBQcm9zZW1pcnJvck5vZGUsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgRGVjb3JhdGlvbiwgRWRpdG9yVmlldyB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldydcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMgfSBmcm9tICcuL2hlbHBlcnMvZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zLmpzJ1xuaW1wb3J0IHsgZ2V0RXh0ZW5zaW9uRmllbGQgfSBmcm9tICcuL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGdldFJlbmRlcmVkQXR0cmlidXRlcyB9IGZyb20gJy4vaGVscGVycy9nZXRSZW5kZXJlZEF0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyB9IGZyb20gJy4vaGVscGVycy9nZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucy5qcydcbmltcG9ydCB7IGdldFNjaGVtYVR5cGVCeU5hbWUgfSBmcm9tICcuL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZUJ5TmFtZS5qcydcbmltcG9ydCB7IGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkIH0gZnJvbSAnLi9oZWxwZXJzL2lzRXh0ZW5zaW9uUnVsZXNFbmFibGVkLmpzJ1xuaW1wb3J0IHsgc3BsaXRFeHRlbnNpb25zIH0gZnJvbSAnLi9oZWxwZXJzL3NwbGl0RXh0ZW5zaW9ucy5qcydcbmltcG9ydCB7IE1hcmssIE5vZGVDb25maWcgfSBmcm9tICcuL2luZGV4LmpzJ1xuaW1wb3J0IHsgaW5wdXRSdWxlc1BsdWdpbiB9IGZyb20gJy4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgcGFzdGVSdWxlc1BsdWdpbiB9IGZyb20gJy4vUGFzdGVSdWxlLmpzJ1xuaW1wb3J0IHsgQW55Q29uZmlnLCBFeHRlbnNpb25zLCBSYXdDb21tYW5kcyB9IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5pbXBvcnQgeyBmaW5kRHVwbGljYXRlcyB9IGZyb20gJy4vdXRpbGl0aWVzL2ZpbmREdXBsaWNhdGVzLmpzJ1xuXG5leHBvcnQgY2xhc3MgRXh0ZW5zaW9uTWFuYWdlciB7XG4gIGVkaXRvcjogRWRpdG9yXG5cbiAgc2NoZW1hOiBTY2hlbWFcblxuICBleHRlbnNpb25zOiBFeHRlbnNpb25zXG5cbiAgc3BsaXR0YWJsZU1hcmtzOiBzdHJpbmdbXSA9IFtdXG5cbiAgY29uc3RydWN0b3IoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucywgZWRpdG9yOiBFZGl0b3IpIHtcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvclxuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IEV4dGVuc2lvbk1hbmFnZXIucmVzb2x2ZShleHRlbnNpb25zKVxuICAgIHRoaXMuc2NoZW1hID0gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zLCBlZGl0b3IpXG5cbiAgICB0aGlzLmV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgICAgLy8gc3RvcmUgZXh0ZW5zaW9uIHN0b3JhZ2UgaW4gZWRpdG9yXG4gICAgICB0aGlzLmVkaXRvci5leHRlbnNpb25TdG9yYWdlW2V4dGVuc2lvbi5uYW1lXSA9IGV4dGVuc2lvbi5zdG9yYWdlXG5cbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgIHR5cGU6IGdldFNjaGVtYVR5cGVCeU5hbWUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKSxcbiAgICAgIH1cblxuICAgICAgaWYgKGV4dGVuc2lvbi50eXBlID09PSAnbWFyaycpIHtcbiAgICAgICAgY29uc3Qga2VlcE9uU3BsaXQgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAna2VlcE9uU3BsaXQnLCBjb250ZXh0KSkgPz8gdHJ1ZVxuXG4gICAgICAgIGlmIChrZWVwT25TcGxpdCkge1xuICAgICAgICAgIHRoaXMuc3BsaXR0YWJsZU1hcmtzLnB1c2goZXh0ZW5zaW9uLm5hbWUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25CZWZvcmVDcmVhdGUgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ29uQmVmb3JlQ3JlYXRlJ10+KFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICdvbkJlZm9yZUNyZWF0ZScsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApXG5cbiAgICAgIGlmIChvbkJlZm9yZUNyZWF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbignYmVmb3JlQ3JlYXRlJywgb25CZWZvcmVDcmVhdGUpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uQ3JlYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvbkNyZWF0ZSddPihleHRlbnNpb24sICdvbkNyZWF0ZScsIGNvbnRleHQpXG5cbiAgICAgIGlmIChvbkNyZWF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbignY3JlYXRlJywgb25DcmVhdGUpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uVXBkYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvblVwZGF0ZSddPihleHRlbnNpb24sICdvblVwZGF0ZScsIGNvbnRleHQpXG5cbiAgICAgIGlmIChvblVwZGF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbigndXBkYXRlJywgb25VcGRhdGUpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uU2VsZWN0aW9uVXBkYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvblNlbGVjdGlvblVwZGF0ZSddPihcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAnb25TZWxlY3Rpb25VcGRhdGUnLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuXG4gICAgICBpZiAob25TZWxlY3Rpb25VcGRhdGUpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3NlbGVjdGlvblVwZGF0ZScsIG9uU2VsZWN0aW9uVXBkYXRlKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvblRyYW5zYWN0aW9uID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvblRyYW5zYWN0aW9uJ10+KFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICdvblRyYW5zYWN0aW9uJyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgIClcblxuICAgICAgaWYgKG9uVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3RyYW5zYWN0aW9uJywgb25UcmFuc2FjdGlvbilcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25Gb2N1cyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25Gb2N1cyddPihleHRlbnNpb24sICdvbkZvY3VzJywgY29udGV4dClcblxuICAgICAgaWYgKG9uRm9jdXMpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2ZvY3VzJywgb25Gb2N1cylcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25CbHVyID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvbkJsdXInXT4oZXh0ZW5zaW9uLCAnb25CbHVyJywgY29udGV4dClcblxuICAgICAgaWYgKG9uQmx1cikge1xuICAgICAgICB0aGlzLmVkaXRvci5vbignYmx1cicsIG9uQmx1cilcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25EZXN0cm95ID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvbkRlc3Ryb3knXT4oZXh0ZW5zaW9uLCAnb25EZXN0cm95JywgY29udGV4dClcblxuICAgICAgaWYgKG9uRGVzdHJveSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbignZGVzdHJveScsIG9uRGVzdHJveSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc3RhdGljIHJlc29sdmUoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyk6IEV4dGVuc2lvbnMge1xuICAgIGNvbnN0IHJlc29sdmVkRXh0ZW5zaW9ucyA9IEV4dGVuc2lvbk1hbmFnZXIuc29ydChFeHRlbnNpb25NYW5hZ2VyLmZsYXR0ZW4oZXh0ZW5zaW9ucykpXG4gICAgY29uc3QgZHVwbGljYXRlZE5hbWVzID0gZmluZER1cGxpY2F0ZXMocmVzb2x2ZWRFeHRlbnNpb25zLm1hcChleHRlbnNpb24gPT4gZXh0ZW5zaW9uLm5hbWUpKVxuXG4gICAgaWYgKGR1cGxpY2F0ZWROYW1lcy5sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFt0aXB0YXAgd2Fybl06IER1cGxpY2F0ZSBleHRlbnNpb24gbmFtZXMgZm91bmQ6IFske2R1cGxpY2F0ZWROYW1lc1xuICAgICAgICAgIC5tYXAoaXRlbSA9PiBgJyR7aXRlbX0nYClcbiAgICAgICAgICAuam9pbignLCAnKX1dLiBUaGlzIGNhbiBsZWFkIHRvIGlzc3Vlcy5gLFxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiByZXNvbHZlZEV4dGVuc2lvbnNcbiAgfVxuXG4gIHN0YXRpYyBmbGF0dGVuKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpOiBFeHRlbnNpb25zIHtcbiAgICByZXR1cm4gKFxuICAgICAgZXh0ZW5zaW9uc1xuICAgICAgICAubWFwKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBhZGRFeHRlbnNpb25zID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRFeHRlbnNpb25zJ10+KFxuICAgICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICAgJ2FkZEV4dGVuc2lvbnMnLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICApXG5cbiAgICAgICAgICBpZiAoYWRkRXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIFtleHRlbnNpb24sIC4uLnRoaXMuZmxhdHRlbihhZGRFeHRlbnNpb25zKCkpXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBleHRlbnNpb25cbiAgICAgICAgfSlcbiAgICAgICAgLy8gYEluZmluaXR5YCB3aWxsIGJyZWFrIFR5cGVTY3JpcHQgc28gd2Ugc2V0IGEgbnVtYmVyIHRoYXQgaXMgcHJvYmFibHkgaGlnaCBlbm91Z2hcbiAgICAgICAgLmZsYXQoMTApXG4gICAgKVxuICB9XG5cbiAgc3RhdGljIHNvcnQoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyk6IEV4dGVuc2lvbnMge1xuICAgIGNvbnN0IGRlZmF1bHRQcmlvcml0eSA9IDEwMFxuXG4gICAgcmV0dXJuIGV4dGVuc2lvbnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgcHJpb3JpdHlBID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydwcmlvcml0eSddPihhLCAncHJpb3JpdHknKSB8fCBkZWZhdWx0UHJpb3JpdHlcbiAgICAgIGNvbnN0IHByaW9yaXR5QiA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1sncHJpb3JpdHknXT4oYiwgJ3ByaW9yaXR5JykgfHwgZGVmYXVsdFByaW9yaXR5XG5cbiAgICAgIGlmIChwcmlvcml0eUEgPiBwcmlvcml0eUIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG5cbiAgICAgIGlmIChwcmlvcml0eUEgPCBwcmlvcml0eUIpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDBcbiAgICB9KVxuICB9XG5cbiAgZ2V0IGNvbW1hbmRzKCk6IFJhd0NvbW1hbmRzIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zLnJlZHVjZSgoY29tbWFuZHMsIGV4dGVuc2lvbikgPT4ge1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgdHlwZTogZ2V0U2NoZW1hVHlwZUJ5TmFtZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxuICAgICAgfVxuXG4gICAgICBjb25zdCBhZGRDb21tYW5kcyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkQ29tbWFuZHMnXT4oXG4gICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgJ2FkZENvbW1hbmRzJyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgIClcblxuICAgICAgaWYgKCFhZGRDb21tYW5kcykge1xuICAgICAgICByZXR1cm4gY29tbWFuZHNcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29tbWFuZHMsXG4gICAgICAgIC4uLmFkZENvbW1hbmRzKCksXG4gICAgICB9XG4gICAgfSwge30gYXMgUmF3Q29tbWFuZHMpXG4gIH1cblxuICBnZXQgcGx1Z2lucygpOiBQbHVnaW5bXSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXNcblxuICAgIC8vIFdpdGggUHJvc2VNaXJyb3IsIGZpcnN0IHBsdWdpbnMgd2l0aGluIGFuIGFycmF5IGFyZSBleGVjdXRlZCBmaXJzdC5cbiAgICAvLyBJbiBUaXB0YXAsIHdlIHByb3ZpZGUgdGhlIGFiaWxpdHkgdG8gb3ZlcnJpZGUgcGx1Z2lucyxcbiAgICAvLyBzbyBpdCBmZWVscyBtb3JlIG5hdHVyYWwgdG8gcnVuIHBsdWdpbnMgYXQgdGhlIGVuZCBvZiBhbiBhcnJheSBmaXJzdC5cbiAgICAvLyBUaGF04oCZcyB3aHkgd2UgaGF2ZSB0byByZXZlcnNlIHRoZSBgZXh0ZW5zaW9uc2AgYXJyYXkgYW5kIHNvcnQgYWdhaW5cbiAgICAvLyBiYXNlZCBvbiB0aGUgYHByaW9yaXR5YCBvcHRpb24uXG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IEV4dGVuc2lvbk1hbmFnZXIuc29ydChbLi4udGhpcy5leHRlbnNpb25zXS5yZXZlcnNlKCkpXG5cbiAgICBjb25zdCBpbnB1dFJ1bGVzOiBhbnlbXSA9IFtdXG4gICAgY29uc3QgcGFzdGVSdWxlczogYW55W10gPSBbXVxuXG4gICAgY29uc3QgYWxsUGx1Z2lucyA9IGV4dGVuc2lvbnNcbiAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgdHlwZTogZ2V0U2NoZW1hVHlwZUJ5TmFtZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGx1Z2luczogUGx1Z2luW10gPSBbXVxuXG4gICAgICAgIGNvbnN0IGFkZEtleWJvYXJkU2hvcnRjdXRzID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRLZXlib2FyZFNob3J0Y3V0cyddPihcbiAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgJ2FkZEtleWJvYXJkU2hvcnRjdXRzJyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICApXG5cbiAgICAgICAgbGV0IGRlZmF1bHRCaW5kaW5nczogUmVjb3JkPHN0cmluZywgKCkgPT4gYm9vbGVhbj4gPSB7fVxuXG4gICAgICAgIC8vIGJpbmQgZXhpdCBoYW5kbGluZ1xuICAgICAgICBpZiAoZXh0ZW5zaW9uLnR5cGUgPT09ICdtYXJrJyAmJiBleHRlbnNpb24uY29uZmlnLmV4aXRhYmxlKSB7XG4gICAgICAgICAgZGVmYXVsdEJpbmRpbmdzLkFycm93UmlnaHQgPSAoKSA9PiBNYXJrLmhhbmRsZUV4aXQoeyBlZGl0b3IsIG1hcms6IGV4dGVuc2lvbiBhcyBNYXJrIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWRkS2V5Ym9hcmRTaG9ydGN1dHMpIHtcbiAgICAgICAgICBjb25zdCBiaW5kaW5ncyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGFkZEtleWJvYXJkU2hvcnRjdXRzKCkpLm1hcCgoW3Nob3J0Y3V0LCBtZXRob2RdKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBbc2hvcnRjdXQsICgpID0+IG1ldGhvZCh7IGVkaXRvciB9KV1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIClcblxuICAgICAgICAgIGRlZmF1bHRCaW5kaW5ncyA9IHsgLi4uZGVmYXVsdEJpbmRpbmdzLCAuLi5iaW5kaW5ncyB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBrZXlNYXBQbHVnaW4gPSBrZXltYXAoZGVmYXVsdEJpbmRpbmdzKVxuXG4gICAgICAgIHBsdWdpbnMucHVzaChrZXlNYXBQbHVnaW4pXG5cbiAgICAgICAgY29uc3QgYWRkSW5wdXRSdWxlcyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkSW5wdXRSdWxlcyddPihcbiAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgJ2FkZElucHV0UnVsZXMnLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIClcblxuICAgICAgICBpZiAoaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQoZXh0ZW5zaW9uLCBlZGl0b3Iub3B0aW9ucy5lbmFibGVJbnB1dFJ1bGVzKSAmJiBhZGRJbnB1dFJ1bGVzKSB7XG4gICAgICAgICAgaW5wdXRSdWxlcy5wdXNoKC4uLmFkZElucHV0UnVsZXMoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFkZFBhc3RlUnVsZXMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFBhc3RlUnVsZXMnXT4oXG4gICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICdhZGRQYXN0ZVJ1bGVzJyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkKGV4dGVuc2lvbiwgZWRpdG9yLm9wdGlvbnMuZW5hYmxlUGFzdGVSdWxlcykgJiYgYWRkUGFzdGVSdWxlcykge1xuICAgICAgICAgIHBhc3RlUnVsZXMucHVzaCguLi5hZGRQYXN0ZVJ1bGVzKCkpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhZGRQcm9zZU1pcnJvclBsdWdpbnMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFByb3NlTWlycm9yUGx1Z2lucyddPihcbiAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgJ2FkZFByb3NlTWlycm9yUGx1Z2lucycsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChhZGRQcm9zZU1pcnJvclBsdWdpbnMpIHtcbiAgICAgICAgICBjb25zdCBwcm9zZU1pcnJvclBsdWdpbnMgPSBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKVxuXG4gICAgICAgICAgcGx1Z2lucy5wdXNoKC4uLnByb3NlTWlycm9yUGx1Z2lucylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwbHVnaW5zXG4gICAgICB9KVxuICAgICAgLmZsYXQoKVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIGlucHV0UnVsZXNQbHVnaW4oe1xuICAgICAgICBlZGl0b3IsXG4gICAgICAgIHJ1bGVzOiBpbnB1dFJ1bGVzLFxuICAgICAgfSksXG4gICAgICAuLi5wYXN0ZVJ1bGVzUGx1Z2luKHtcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICBydWxlczogcGFzdGVSdWxlcyxcbiAgICAgIH0pLFxuICAgICAgLi4uYWxsUGx1Z2lucyxcbiAgICBdXG4gIH1cblxuICBnZXQgYXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucylcbiAgfVxuXG4gIGdldCBub2RlVmlld3MoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXNcbiAgICBjb25zdCB7IG5vZGVFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKVxuXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIG5vZGVFeHRlbnNpb25zXG4gICAgICAgIC5maWx0ZXIoZXh0ZW5zaW9uID0+ICEhZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkTm9kZVZpZXcnKSlcbiAgICAgICAgLm1hcChleHRlbnNpb24gPT4ge1xuICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgYXR0cmlidXRlID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIHR5cGU6IGdldE5vZGVUeXBlKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGFkZE5vZGVWaWV3ID0gZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snYWRkTm9kZVZpZXcnXT4oXG4gICAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgICAnYWRkTm9kZVZpZXcnLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICApXG5cbiAgICAgICAgICBpZiAoIWFkZE5vZGVWaWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBub2RldmlldyA9IChcbiAgICAgICAgICAgIG5vZGU6IFByb3NlbWlycm9yTm9kZSxcbiAgICAgICAgICAgIHZpZXc6IEVkaXRvclZpZXcsXG4gICAgICAgICAgICBnZXRQb3M6ICgoKSA9PiBudW1iZXIpIHwgYm9vbGVhbixcbiAgICAgICAgICAgIGRlY29yYXRpb25zOiBEZWNvcmF0aW9uW10sXG4gICAgICAgICAgKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBIVE1MQXR0cmlidXRlcyA9IGdldFJlbmRlcmVkQXR0cmlidXRlcyhub2RlLCBleHRlbnNpb25BdHRyaWJ1dGVzKVxuXG4gICAgICAgICAgICByZXR1cm4gYWRkTm9kZVZpZXcoKSh7XG4gICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgZ2V0UG9zLFxuICAgICAgICAgICAgICBkZWNvcmF0aW9ucyxcbiAgICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb24ubmFtZSwgbm9kZXZpZXddXG4gICAgICAgIH0pLFxuICAgIClcbiAgfVxufVxuIiwgIi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL21lc3F1ZWViL2lzLXdoYXQvYmxvYi84OGQ2ZTRjYTkyZmIyYmFhYjYwMDNjNTRlMDJlZWRmNGU3MjllNWFiL3NyYy9pbmRleC50c1xuXG5mdW5jdGlvbiBnZXRUeXBlKHZhbHVlOiBhbnkpOiBzdHJpbmcge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWU6IGFueSk6IHZhbHVlIGlzIFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBpZiAoZ2V0VHlwZSh2YWx1ZSkgIT09ICdPYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBPYmplY3QucHJvdG90eXBlXG59XG4iLCAiaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4vaXNQbGFpbk9iamVjdC5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGVlcCh0YXJnZXQ6IFJlY29yZDxzdHJpbmcsIGFueT4sIHNvdXJjZTogUmVjb3JkPHN0cmluZywgYW55Pik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCBvdXRwdXQgPSB7IC4uLnRhcmdldCB9XG5cbiAgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiBpc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3V0cHV0LCB7IFtrZXldOiBzb3VyY2Vba2V5XSB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dFtrZXldID0gbWVyZ2VEZWVwKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvdXRwdXQsIHsgW2tleV06IHNvdXJjZVtrZXldIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cbiIsICJpbXBvcnQgeyBQbHVnaW4sIFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vaGVscGVycy9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IEV4dGVuc2lvbkNvbmZpZyB9IGZyb20gJy4vaW5kZXguanMnXG5pbXBvcnQgeyBJbnB1dFJ1bGUgfSBmcm9tICcuL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IE1hcmsgfSBmcm9tICcuL01hcmsuanMnXG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi9Ob2RlLmpzJ1xuaW1wb3J0IHsgUGFzdGVSdWxlIH0gZnJvbSAnLi9QYXN0ZVJ1bGUuanMnXG5pbXBvcnQge1xuICBBbnlDb25maWcsXG4gIEV4dGVuc2lvbnMsXG4gIEdsb2JhbEF0dHJpYnV0ZXMsXG4gIEtleWJvYXJkU2hvcnRjdXRDb21tYW5kLFxuICBQYXJlbnRDb25maWcsXG4gIFJhd0NvbW1hbmRzLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuaW1wb3J0IHsgbWVyZ2VEZWVwIH0gZnJvbSAnLi91dGlsaXRpZXMvbWVyZ2VEZWVwLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBFeHRlbnNpb25Db25maWc8T3B0aW9ucyA9IGFueSwgU3RvcmFnZSA9IGFueT4ge1xuICAgIFtrZXk6IHN0cmluZ106IGFueVxuXG4gICAgLyoqXG4gICAgICogTmFtZVxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZ1xuXG4gICAgLyoqXG4gICAgICogUHJpb3JpdHlcbiAgICAgKi9cbiAgICBwcmlvcml0eT86IG51bWJlclxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBvcHRpb25zXG4gICAgICovXG4gICAgZGVmYXVsdE9wdGlvbnM/OiBPcHRpb25zXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IE9wdGlvbnNcbiAgICAgKi9cbiAgICBhZGRPcHRpb25zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgcGFyZW50OiBFeGNsdWRlPFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRPcHRpb25zJ10sIHVuZGVmaW5lZD5cbiAgICB9KSA9PiBPcHRpb25zXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IFN0b3JhZ2VcbiAgICAgKi9cbiAgICBhZGRTdG9yYWdlPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgcGFyZW50OiBFeGNsdWRlPFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRTdG9yYWdlJ10sIHVuZGVmaW5lZD5cbiAgICB9KSA9PiBTdG9yYWdlXG5cbiAgICAvKipcbiAgICAgKiBHbG9iYWwgYXR0cmlidXRlc1xuICAgICAqL1xuICAgIGFkZEdsb2JhbEF0dHJpYnV0ZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRHbG9iYWxBdHRyaWJ1dGVzJ11cbiAgICB9KSA9PiBHbG9iYWxBdHRyaWJ1dGVzIHwge31cblxuICAgIC8qKlxuICAgICAqIFJhd1xuICAgICAqL1xuICAgIGFkZENvbW1hbmRzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZENvbW1hbmRzJ11cbiAgICB9KSA9PiBQYXJ0aWFsPFJhd0NvbW1hbmRzPlxuXG4gICAgLyoqXG4gICAgICogS2V5Ym9hcmQgc2hvcnRjdXRzXG4gICAgICovXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkS2V5Ym9hcmRTaG9ydGN1dHMnXVxuICAgIH0pID0+IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IEtleWJvYXJkU2hvcnRjdXRDb21tYW5kXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5wdXQgcnVsZXNcbiAgICAgKi9cbiAgICBhZGRJbnB1dFJ1bGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZElucHV0UnVsZXMnXVxuICAgIH0pID0+IElucHV0UnVsZVtdXG5cbiAgICAvKipcbiAgICAgKiBQYXN0ZSBydWxlc1xuICAgICAqL1xuICAgIGFkZFBhc3RlUnVsZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkUGFzdGVSdWxlcyddXG4gICAgfSkgPT4gUGFzdGVSdWxlW11cblxuICAgIC8qKlxuICAgICAqIFByb3NlTWlycm9yIHBsdWdpbnNcbiAgICAgKi9cbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkUHJvc2VNaXJyb3JQbHVnaW5zJ11cbiAgICB9KSA9PiBQbHVnaW5bXVxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5zaW9uc1xuICAgICAqL1xuICAgIGFkZEV4dGVuc2lvbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRFeHRlbnNpb25zJ11cbiAgICB9KSA9PiBFeHRlbnNpb25zXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgTm9kZSBTY2hlbWFcbiAgICAgKi9cbiAgICBleHRlbmROb2RlU2NoZW1hPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4dGVuZE5vZGVTY2hlbWEnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXh0ZW5zaW9uOiBOb2RlLFxuICAgICAgICApID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBNYXJrIFNjaGVtYVxuICAgICAqL1xuICAgIGV4dGVuZE1hcmtTY2hlbWE/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZXh0ZW5kTWFya1NjaGVtYSddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHRlbnNpb246IE1hcmssXG4gICAgICAgICkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBub3QgcmVhZHkgeWV0LlxuICAgICAqL1xuICAgIG9uQmVmb3JlQ3JlYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uQmVmb3JlQ3JlYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyByZWFkeS5cbiAgICAgKi9cbiAgICBvbkNyZWF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkNyZWF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZW50IGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uVXBkYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uVXBkYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdGlvbiBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblNlbGVjdGlvblVwZGF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblNlbGVjdGlvblVwZGF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3Igc3RhdGUgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25UcmFuc2FjdGlvbj86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25UcmFuc2FjdGlvbiddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGZvY3VzZWQuXG4gICAgICovXG4gICAgb25Gb2N1cz86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25Gb2N1cyddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZXZlbnQ6IEZvY3VzRXZlbnRcbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXNu4oCZdCBmb2N1c2VkIGFueW1vcmUuXG4gICAgICovXG4gICAgb25CbHVyPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkJsdXInXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGV2ZW50OiBGb2N1c0V2ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBvbkRlc3Ryb3k/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25EZXN0cm95J11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBFeHRlbnNpb248T3B0aW9ucyA9IGFueSwgU3RvcmFnZSA9IGFueT4ge1xuICB0eXBlID0gJ2V4dGVuc2lvbidcblxuICBuYW1lID0gJ2V4dGVuc2lvbidcblxuICBwYXJlbnQ6IEV4dGVuc2lvbiB8IG51bGwgPSBudWxsXG5cbiAgY2hpbGQ6IEV4dGVuc2lvbiB8IG51bGwgPSBudWxsXG5cbiAgb3B0aW9uczogT3B0aW9uc1xuXG4gIHN0b3JhZ2U6IFN0b3JhZ2VcblxuICBjb25maWc6IEV4dGVuc2lvbkNvbmZpZyA9IHtcbiAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgZGVmYXVsdE9wdGlvbnM6IHt9LFxuICB9XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBQYXJ0aWFsPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj4gPSB7fSkge1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICAuLi5jb25maWcsXG4gICAgfVxuXG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25maWcubmFtZVxuXG4gICAgaWYgKGNvbmZpZy5kZWZhdWx0T3B0aW9ucykge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHt0aGlzLm5hbWV9XCIuYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgYGFkZE9wdGlvbnNgIGZhbGxiYWNrXG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5jb25maWcuZGVmYXVsdE9wdGlvbnNcblxuICAgIGlmICh0aGlzLmNvbmZpZy5hZGRPcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkT3B0aW9ucyddPih0aGlzLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIH0pLFxuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMuc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPih0aGlzLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApIHx8IHt9XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlPE8gPSBhbnksIFMgPSBhbnk+KGNvbmZpZzogUGFydGlhbDxFeHRlbnNpb25Db25maWc8TywgUz4+ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEV4dGVuc2lvbjxPLCBTPihjb25maWcpXG4gIH1cblxuICBjb25maWd1cmUob3B0aW9uczogUGFydGlhbDxPcHRpb25zPiA9IHt9KSB7XG4gICAgLy8gcmV0dXJuIGEgbmV3IGluc3RhbmNlIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgZXh0ZW5zaW9uXG4gICAgLy8gd2l0aCBkaWZmZXJlbnQgY2FsbHMgb2YgYGNvbmZpZ3VyZWBcbiAgICBjb25zdCBleHRlbnNpb24gPSB0aGlzLmV4dGVuZCgpXG5cbiAgICBleHRlbnNpb24ub3B0aW9ucyA9IG1lcmdlRGVlcCh0aGlzLm9wdGlvbnMgYXMgUmVjb3JkPHN0cmluZywgYW55Piwgb3B0aW9ucykgYXMgT3B0aW9uc1xuXG4gICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4oZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG5cbiAgZXh0ZW5kPEV4dGVuZGVkT3B0aW9ucyA9IE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZSA9IFN0b3JhZ2U+KFxuICAgIGV4dGVuZGVkQ29uZmlnOiBQYXJ0aWFsPEV4dGVuc2lvbkNvbmZpZzxFeHRlbmRlZE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZT4+ID0ge30sXG4gICkge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5ldyBFeHRlbnNpb248RXh0ZW5kZWRPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2U+KGV4dGVuZGVkQ29uZmlnKVxuXG4gICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXNcblxuICAgIHRoaXMuY2hpbGQgPSBleHRlbnNpb25cblxuICAgIGV4dGVuc2lvbi5uYW1lID0gZXh0ZW5kZWRDb25maWcubmFtZSA/IGV4dGVuZGVkQ29uZmlnLm5hbWUgOiBleHRlbnNpb24ucGFyZW50Lm5hbWVcblxuICAgIGlmIChleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucykge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHtleHRlbnNpb24ubmFtZX1cIi5gLFxuICAgICAgKVxuICAgIH1cblxuICAgIGV4dGVuc2lvbi5vcHRpb25zID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRPcHRpb25zJ10+KGV4dGVuc2lvbiwgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4oZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBSYW5nZSwgVGV4dFNlcmlhbGl6ZXIgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRleHRCZXR3ZWVuKFxuICBzdGFydE5vZGU6IFByb3NlTWlycm9yTm9kZSxcbiAgcmFuZ2U6IFJhbmdlLFxuICBvcHRpb25zPzoge1xuICAgIGJsb2NrU2VwYXJhdG9yPzogc3RyaW5nXG4gICAgdGV4dFNlcmlhbGl6ZXJzPzogUmVjb3JkPHN0cmluZywgVGV4dFNlcmlhbGl6ZXI+XG4gIH0sXG4pOiBzdHJpbmcge1xuICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZVxuICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gJ1xcblxcbicsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9XG4gIGxldCB0ZXh0ID0gJydcbiAgbGV0IHNlcGFyYXRlZCA9IHRydWVcblxuICBzdGFydE5vZGUubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zLCBwYXJlbnQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgdGV4dFNlcmlhbGl6ZXIgPSB0ZXh0U2VyaWFsaXplcnM/Lltub2RlLnR5cGUubmFtZV1cblxuICAgIGlmICh0ZXh0U2VyaWFsaXplcikge1xuICAgICAgaWYgKG5vZGUuaXNCbG9jayAmJiAhc2VwYXJhdGVkKSB7XG4gICAgICAgIHRleHQgKz0gYmxvY2tTZXBhcmF0b3JcbiAgICAgICAgc2VwYXJhdGVkID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHRleHQgKz0gdGV4dFNlcmlhbGl6ZXIoe1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgcG9zLFxuICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICByYW5nZSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICB0ZXh0ICs9IG5vZGU/LnRleHQ/LnNsaWNlKE1hdGgubWF4KGZyb20sIHBvcykgLSBwb3MsIHRvIC0gcG9zKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBzZXBhcmF0ZWQgPSBmYWxzZVxuICAgIH0gZWxzZSBpZiAobm9kZS5pc0Jsb2NrICYmICFzZXBhcmF0ZWQpIHtcbiAgICAgIHRleHQgKz0gYmxvY2tTZXBhcmF0b3JcbiAgICAgIHNlcGFyYXRlZCA9IHRydWVcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHRleHRcbn1cbiIsICJpbXBvcnQgeyBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBUZXh0U2VyaWFsaXplciB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWE6IFNjaGVtYSk6IFJlY29yZDxzdHJpbmcsIFRleHRTZXJpYWxpemVyPiB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hLm5vZGVzKVxuICAgICAgLmZpbHRlcigoWywgbm9kZV0pID0+IG5vZGUuc3BlYy50b1RleHQpXG4gICAgICAubWFwKChbbmFtZSwgbm9kZV0pID0+IFtuYW1lLCBub2RlLnNwZWMudG9UZXh0XSksXG4gIClcbn1cbiIsICJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcbmltcG9ydCB7IGdldFRleHRCZXR3ZWVuIH0gZnJvbSAnLi4vaGVscGVycy9nZXRUZXh0QmV0d2Vlbi5qcydcbmltcG9ydCB7IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEgfSBmcm9tICcuLi9oZWxwZXJzL2dldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEuanMnXG5cbmV4cG9ydCBjb25zdCBDbGlwYm9hcmRUZXh0U2VyaWFsaXplciA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAnY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXInLFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXInKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBjbGlwYm9hcmRUZXh0U2VyaWFsaXplcjogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXNcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUsIHNjaGVtYSB9ID0gZWRpdG9yXG4gICAgICAgICAgICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICAgICAgICAgICAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvblxuICAgICAgICAgICAgY29uc3QgZnJvbSA9IE1hdGgubWluKC4uLnJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuJGZyb20ucG9zKSlcbiAgICAgICAgICAgIGNvbnN0IHRvID0gTWF0aC5tYXgoLi4ucmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS4kdG8ucG9zKSlcbiAgICAgICAgICAgIGNvbnN0IHRleHRTZXJpYWxpemVycyA9IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hKVxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB7IGZyb20sIHRvIH1cblxuICAgICAgICAgICAgcmV0dXJuIGdldFRleHRCZXR3ZWVuKGRvYywgcmFuZ2UsIHtcbiAgICAgICAgICAgICAgdGV4dFNlcmlhbGl6ZXJzLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgYmx1cjoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGZvY3VzIGZyb20gdGhlIGVkaXRvci5cbiAgICAgICAqL1xuICAgICAgYmx1cjogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGJsdXI6IFJhd0NvbW1hbmRzWydibHVyJ10gPSAoKSA9PiAoeyBlZGl0b3IsIHZpZXcgfSkgPT4ge1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAodmlldy5kb20gYXMgSFRNTEVsZW1lbnQpLmJsdXIoKVxuXG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgcmVtb3ZlIHRoZSBjYXJldCBvbiBibHVyIGJ1dCBzYWZhcmkgZG9lcyBub3QuXG4gICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMjQwNVxuICAgICAgd2luZG93Py5nZXRTZWxlY3Rpb24oKT8ucmVtb3ZlQWxsUmFuZ2VzKClcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgY2xlYXJDb250ZW50OiB7XG4gICAgICAvKipcbiAgICAgICAqIENsZWFyIHRoZSB3aG9sZSBkb2N1bWVudC5cbiAgICAgICAqL1xuICAgICAgY2xlYXJDb250ZW50OiAoZW1pdFVwZGF0ZT86IGJvb2xlYW4pID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjbGVhckNvbnRlbnQ6IFJhd0NvbW1hbmRzWydjbGVhckNvbnRlbnQnXSA9IChlbWl0VXBkYXRlID0gZmFsc2UpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgcmV0dXJuIGNvbW1hbmRzLnNldENvbnRlbnQoJycsIGVtaXRVcGRhdGUpXG59XG4iLCAiaW1wb3J0IHsgbGlmdFRhcmdldCB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgY2xlYXJOb2Rlczoge1xuICAgICAgLyoqXG4gICAgICAgKiBOb3JtYWxpemUgbm9kZXMgdG8gYSBzaW1wbGUgcGFyYWdyYXBoLlxuICAgICAgICovXG4gICAgICBjbGVhck5vZGVzOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY2xlYXJOb2RlczogUmF3Q29tbWFuZHNbJ2NsZWFyTm9kZXMnXSA9ICgpID0+ICh7IHN0YXRlLCB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHJcbiAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvblxuXG4gIGlmICghZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmFuZ2VzLmZvckVhY2goKHsgJGZyb20sICR0byB9KSA9PiB7XG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIChub2RlLCBwb3MpID0+IHtcbiAgICAgIGlmIChub2RlLnR5cGUuaXNUZXh0KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGRvYywgbWFwcGluZyB9ID0gdHJcbiAgICAgIGNvbnN0ICRtYXBwZWRGcm9tID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAocG9zKSlcbiAgICAgIGNvbnN0ICRtYXBwZWRUbyA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHBvcyArIG5vZGUubm9kZVNpemUpKVxuICAgICAgY29uc3Qgbm9kZVJhbmdlID0gJG1hcHBlZEZyb20uYmxvY2tSYW5nZSgkbWFwcGVkVG8pXG5cbiAgICAgIGlmICghbm9kZVJhbmdlKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB0YXJnZXRMaWZ0RGVwdGggPSBsaWZ0VGFyZ2V0KG5vZGVSYW5nZSlcblxuICAgICAgaWYgKG5vZGUudHlwZS5pc1RleHRibG9jaykge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHRUeXBlIH0gPSAkbWFwcGVkRnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJG1hcHBlZEZyb20uaW5kZXgoKSlcblxuICAgICAgICB0ci5zZXROb2RlTWFya3VwKG5vZGVSYW5nZS5zdGFydCwgZGVmYXVsdFR5cGUpXG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXRMaWZ0RGVwdGggfHwgdGFyZ2V0TGlmdERlcHRoID09PSAwKSB7XG4gICAgICAgIHRyLmxpZnQobm9kZVJhbmdlLCB0YXJnZXRMaWZ0RGVwdGgpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IENvbW1hbmQsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBjb21tYW5kOiB7XG4gICAgICAvKipcbiAgICAgICAqIERlZmluZSBhIGNvbW1hbmQgaW5saW5lLlxuICAgICAgICovXG4gICAgICBjb21tYW5kOiAoZm46IChwcm9wczogUGFyYW1ldGVyczxDb21tYW5kPlswXSkgPT4gYm9vbGVhbikgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNvbW1hbmQ6IFJhd0NvbW1hbmRzWydjb21tYW5kJ10gPSBmbiA9PiBwcm9wcyA9PiB7XG4gIHJldHVybiBmbihwcm9wcylcbn1cbiIsICJpbXBvcnQgeyBjcmVhdGVQYXJhZ3JhcGhOZWFyIGFzIG9yaWdpbmFsQ3JlYXRlUGFyYWdyYXBoTmVhciB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBjcmVhdGVQYXJhZ3JhcGhOZWFyOiB7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSBhIHBhcmFncmFwaCBuZWFyYnkuXG4gICAgICAgKi9cbiAgICAgIGNyZWF0ZVBhcmFncmFwaE5lYXI6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVBhcmFncmFwaE5lYXI6IFJhd0NvbW1hbmRzWydjcmVhdGVQYXJhZ3JhcGhOZWFyJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxDcmVhdGVQYXJhZ3JhcGhOZWFyKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGN1dDoge1xuICAgICAgLyoqXG4gICAgICAgKiBDdXRzIGNvbnRlbnQgZnJvbSBhIHJhbmdlIGFuZCBpbnNlcnRzIGl0IGF0IGEgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICAgKi9cbiAgICAgIGN1dDogKHsgZnJvbSwgdG8gfTogeyBmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIgfSwgdGFyZ2V0UG9zOiBudW1iZXIpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjdXQ6IFJhd0NvbW1hbmRzWydjdXQnXSA9IChvcmlnaW5SYW5nZSwgdGFyZ2V0UG9zKSA9PiAoeyBlZGl0b3IsIHRyIH0pID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yXG5cbiAgY29uc3QgY29udGVudFNsaWNlID0gc3RhdGUuZG9jLnNsaWNlKG9yaWdpblJhbmdlLmZyb20sIG9yaWdpblJhbmdlLnRvKVxuXG4gIHRyLmRlbGV0ZVJhbmdlKG9yaWdpblJhbmdlLmZyb20sIG9yaWdpblJhbmdlLnRvKVxuICBjb25zdCBuZXdQb3MgPSB0ci5tYXBwaW5nLm1hcCh0YXJnZXRQb3MpXG5cbiAgdHIuaW5zZXJ0KG5ld1BvcywgY29udGVudFNsaWNlLmNvbnRlbnQpXG5cbiAgdHIuc2V0U2VsZWN0aW9uKG5ldyBUZXh0U2VsZWN0aW9uKHRyLmRvYy5yZXNvbHZlKG5ld1BvcyAtIDEpKSlcblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBkZWxldGVDdXJyZW50Tm9kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBEZWxldGUgdGhlIG5vZGUgdGhhdCBjdXJyZW50bHkgaGFzIHRoZSBzZWxlY3Rpb24gYW5jaG9yLlxuICAgICAgICovXG4gICAgICBkZWxldGVDdXJyZW50Tm9kZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlbGV0ZUN1cnJlbnROb2RlOiBSYXdDb21tYW5kc1snZGVsZXRlQ3VycmVudE5vZGUnXSA9ICgpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0clxuICBjb25zdCBjdXJyZW50Tm9kZSA9IHNlbGVjdGlvbi4kYW5jaG9yLm5vZGUoKVxuXG4gIC8vIGlmIHRoZXJlIGlzIGNvbnRlbnQgaW5zaWRlIHRoZSBjdXJyZW50IG5vZGUsIGJyZWFrIG91dCBvZiB0aGlzIGNvbW1hbmRcbiAgaWYgKGN1cnJlbnROb2RlLmNvbnRlbnQuc2l6ZSA+IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0ICRwb3MgPSB0ci5zZWxlY3Rpb24uJGFuY2hvclxuXG4gIGZvciAobGV0IGRlcHRoID0gJHBvcy5kZXB0aDsgZGVwdGggPiAwOyBkZXB0aCAtPSAxKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRwb3Mubm9kZShkZXB0aClcblxuICAgIGlmIChub2RlLnR5cGUgPT09IGN1cnJlbnROb2RlLnR5cGUpIHtcbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCBmcm9tID0gJHBvcy5iZWZvcmUoZGVwdGgpXG4gICAgICAgIGNvbnN0IHRvID0gJHBvcy5hZnRlcihkZXB0aClcblxuICAgICAgICB0ci5kZWxldGUoZnJvbSwgdG8pLnNjcm9sbEludG9WaWV3KClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBkZWxldGVOb2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIERlbGV0ZSBhIG5vZGUuXG4gICAgICAgKi9cbiAgICAgIGRlbGV0ZU5vZGU6ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlbGV0ZU5vZGU6IFJhd0NvbW1hbmRzWydkZWxldGVOb2RlJ10gPSB0eXBlT3JOYW1lID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCAkcG9zID0gdHIuc2VsZWN0aW9uLiRhbmNob3JcblxuICBmb3IgKGxldCBkZXB0aCA9ICRwb3MuZGVwdGg7IGRlcHRoID4gMDsgZGVwdGggLT0gMSkge1xuICAgIGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoZGVwdGgpXG5cbiAgICBpZiAobm9kZS50eXBlID09PSB0eXBlKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgZnJvbSA9ICRwb3MuYmVmb3JlKGRlcHRoKVxuICAgICAgICBjb25zdCB0byA9ICRwb3MuYWZ0ZXIoZGVwdGgpXG5cbiAgICAgICAgdHIuZGVsZXRlKGZyb20sIHRvKS5zY3JvbGxJbnRvVmlldygpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCAiaW1wb3J0IHsgUmFuZ2UsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBkZWxldGVSYW5nZToge1xuICAgICAgLyoqXG4gICAgICAgKiBEZWxldGUgYSBnaXZlbiByYW5nZS5cbiAgICAgICAqL1xuICAgICAgZGVsZXRlUmFuZ2U6IChyYW5nZTogUmFuZ2UpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWxldGVSYW5nZTogUmF3Q29tbWFuZHNbJ2RlbGV0ZVJhbmdlJ10gPSByYW5nZSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHRyLmRlbGV0ZShmcm9tLCB0bylcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgZGVsZXRlU2VsZWN0aW9uIGFzIG9yaWdpbmFsRGVsZXRlU2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGRlbGV0ZVNlbGVjdGlvbjoge1xuICAgICAgLyoqXG4gICAgICAgKiBEZWxldGUgdGhlIHNlbGVjdGlvbiwgaWYgdGhlcmUgaXMgb25lLlxuICAgICAgICovXG4gICAgICBkZWxldGVTZWxlY3Rpb246ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlbGV0ZVNlbGVjdGlvbjogUmF3Q29tbWFuZHNbJ2RlbGV0ZVNlbGVjdGlvbiddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsRGVsZXRlU2VsZWN0aW9uKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZW50ZXI6IHtcbiAgICAgIC8qKlxuICAgICAgICogVHJpZ2dlciBlbnRlci5cbiAgICAgICAqL1xuICAgICAgZW50ZXI6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBlbnRlcjogUmF3Q29tbWFuZHNbJ2VudGVyJ10gPSAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gIHJldHVybiBjb21tYW5kcy5rZXlib2FyZFNob3J0Y3V0KCdFbnRlcicpXG59XG4iLCAiaW1wb3J0IHsgZXhpdENvZGUgYXMgb3JpZ2luYWxFeGl0Q29kZSB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBleGl0Q29kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBFeGl0IGZyb20gYSBjb2RlIGJsb2NrLlxuICAgICAgICovXG4gICAgICBleGl0Q29kZTogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZXhpdENvZGU6IFJhd0NvbW1hbmRzWydleGl0Q29kZSddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsRXhpdENvZGUoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IGlzUmVnRXhwIH0gZnJvbSAnLi9pc1JlZ0V4cC5qcydcblxuLyoqXG4gKiBDaGVjayBpZiBvYmplY3QxIGluY2x1ZGVzIG9iamVjdDJcbiAqIEBwYXJhbSBvYmplY3QxIE9iamVjdFxuICogQHBhcmFtIG9iamVjdDIgT2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3RJbmNsdWRlcyhcbiAgb2JqZWN0MTogUmVjb3JkPHN0cmluZywgYW55PixcbiAgb2JqZWN0MjogUmVjb3JkPHN0cmluZywgYW55PixcbiAgb3B0aW9uczogeyBzdHJpY3Q6IGJvb2xlYW4gfSA9IHsgc3RyaWN0OiB0cnVlIH0sXG4pOiBib29sZWFuIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdDIpXG5cbiAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4ga2V5cy5ldmVyeShrZXkgPT4ge1xuICAgIGlmIChvcHRpb25zLnN0cmljdCkge1xuICAgICAgcmV0dXJuIG9iamVjdDJba2V5XSA9PT0gb2JqZWN0MVtrZXldXG4gICAgfVxuXG4gICAgaWYgKGlzUmVnRXhwKG9iamVjdDJba2V5XSkpIHtcbiAgICAgIHJldHVybiBvYmplY3QyW2tleV0udGVzdChvYmplY3QxW2tleV0pXG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdDJba2V5XSA9PT0gb2JqZWN0MVtrZXldXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgTWFyayBhcyBQcm9zZU1pcnJvck1hcmssIE1hcmtUeXBlLCBSZXNvbHZlZFBvcyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBvYmplY3RJbmNsdWRlcyB9IGZyb20gJy4uL3V0aWxpdGllcy9vYmplY3RJbmNsdWRlcy5qcydcblxuZnVuY3Rpb24gZmluZE1hcmtJblNldChcbiAgbWFya3M6IFByb3NlTWlycm9yTWFya1tdLFxuICB0eXBlOiBNYXJrVHlwZSxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogUHJvc2VNaXJyb3JNYXJrIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIG1hcmtzLmZpbmQoaXRlbSA9PiB7XG4gICAgcmV0dXJuIGl0ZW0udHlwZSA9PT0gdHlwZSAmJiBvYmplY3RJbmNsdWRlcyhpdGVtLmF0dHJzLCBhdHRyaWJ1dGVzKVxuICB9KVxufVxuXG5mdW5jdGlvbiBpc01hcmtJblNldChcbiAgbWFya3M6IFByb3NlTWlycm9yTWFya1tdLFxuICB0eXBlOiBNYXJrVHlwZSxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogYm9vbGVhbiB7XG4gIHJldHVybiAhIWZpbmRNYXJrSW5TZXQobWFya3MsIHR5cGUsIGF0dHJpYnV0ZXMpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXJrUmFuZ2UoXG4gICRwb3M6IFJlc29sdmVkUG9zLFxuICB0eXBlOiBNYXJrVHlwZSxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogUmFuZ2UgfCB2b2lkIHtcbiAgaWYgKCEkcG9zIHx8ICF0eXBlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgc3RhcnQgPSAkcG9zLnBhcmVudC5jaGlsZEFmdGVyKCRwb3MucGFyZW50T2Zmc2V0KVxuXG4gIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PT0gc3RhcnQub2Zmc2V0ICYmIHN0YXJ0Lm9mZnNldCAhPT0gMCkge1xuICAgIHN0YXJ0ID0gJHBvcy5wYXJlbnQuY2hpbGRCZWZvcmUoJHBvcy5wYXJlbnRPZmZzZXQpXG4gIH1cblxuICBpZiAoIXN0YXJ0Lm5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IG1hcmsgPSBmaW5kTWFya0luU2V0KFsuLi5zdGFydC5ub2RlLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcylcblxuICBpZiAoIW1hcmspIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGxldCBzdGFydEluZGV4ID0gc3RhcnQuaW5kZXhcbiAgbGV0IHN0YXJ0UG9zID0gJHBvcy5zdGFydCgpICsgc3RhcnQub2Zmc2V0XG4gIGxldCBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyAxXG4gIGxldCBlbmRQb3MgPSBzdGFydFBvcyArIHN0YXJ0Lm5vZGUubm9kZVNpemVcblxuICBmaW5kTWFya0luU2V0KFsuLi5zdGFydC5ub2RlLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcylcblxuICB3aGlsZSAoc3RhcnRJbmRleCA+IDAgJiYgbWFyay5pc0luU2V0KCRwb3MucGFyZW50LmNoaWxkKHN0YXJ0SW5kZXggLSAxKS5tYXJrcykpIHtcbiAgICBzdGFydEluZGV4IC09IDFcbiAgICBzdGFydFBvcyAtPSAkcG9zLnBhcmVudC5jaGlsZChzdGFydEluZGV4KS5ub2RlU2l6ZVxuICB9XG5cbiAgd2hpbGUgKFxuICAgIGVuZEluZGV4IDwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudFxuICAgICYmIGlzTWFya0luU2V0KFsuLi4kcG9zLnBhcmVudC5jaGlsZChlbmRJbmRleCkubWFya3NdLCB0eXBlLCBhdHRyaWJ1dGVzKVxuICApIHtcbiAgICBlbmRQb3MgKz0gJHBvcy5wYXJlbnQuY2hpbGQoZW5kSW5kZXgpLm5vZGVTaXplXG4gICAgZW5kSW5kZXggKz0gMVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmcm9tOiBzdGFydFBvcyxcbiAgICB0bzogZW5kUG9zLFxuICB9XG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXJrVHlwZShuYW1lT3JUeXBlOiBzdHJpbmcgfCBNYXJrVHlwZSwgc2NoZW1hOiBTY2hlbWEpOiBNYXJrVHlwZSB7XG4gIGlmICh0eXBlb2YgbmFtZU9yVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIXNjaGVtYS5tYXJrc1tuYW1lT3JUeXBlXSkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBUaGVyZSBpcyBubyBtYXJrIHR5cGUgbmFtZWQgJyR7bmFtZU9yVHlwZX0nLiBNYXliZSB5b3UgZm9yZ290IHRvIGFkZCB0aGUgZXh0ZW5zaW9uP2AsXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYS5tYXJrc1tuYW1lT3JUeXBlXVxuICB9XG5cbiAgcmV0dXJuIG5hbWVPclR5cGVcbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgZ2V0TWFya1JhbmdlIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrUmFuZ2UuanMnXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZXh0ZW5kTWFya1JhbmdlOiB7XG4gICAgICAvKipcbiAgICAgICAqIEV4dGVuZHMgdGhlIHRleHQgc2VsZWN0aW9uIHRvIHRoZSBjdXJyZW50IG1hcmsuXG4gICAgICAgKi9cbiAgICAgIGV4dGVuZE1hcmtSYW5nZTogKFxuICAgICAgICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBNYXJrVHlwZSxcbiAgICAgICAgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGV4dGVuZE1hcmtSYW5nZTogUmF3Q29tbWFuZHNbJ2V4dGVuZE1hcmtSYW5nZSddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgZG9jLCBzZWxlY3Rpb24gfSA9IHRyXG4gIGNvbnN0IHsgJGZyb20sIGZyb20sIHRvIH0gPSBzZWxlY3Rpb25cblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkZnJvbSwgdHlwZSwgYXR0cmlidXRlcylcblxuICAgIGlmIChyYW5nZSAmJiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8pIHtcbiAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgcmFuZ2UuZnJvbSwgcmFuZ2UudG8pXG5cbiAgICAgIHRyLnNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBDb21tYW5kLCBDb21tYW5kUHJvcHMsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBmaXJzdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBSdW5zIG9uZSBjb21tYW5kIGFmdGVyIHRoZSBvdGhlciBhbmQgc3RvcHMgYXQgdGhlIGZpcnN0IHdoaWNoIHJldHVybnMgdHJ1ZS5cbiAgICAgICAqL1xuICAgICAgZmlyc3Q6IChjb21tYW5kczogQ29tbWFuZFtdIHwgKChwcm9wczogQ29tbWFuZFByb3BzKSA9PiBDb21tYW5kW10pKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZmlyc3Q6IFJhd0NvbW1hbmRzWydmaXJzdCddID0gY29tbWFuZHMgPT4gcHJvcHMgPT4ge1xuICBjb25zdCBpdGVtcyA9IHR5cGVvZiBjb21tYW5kcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gY29tbWFuZHMocHJvcHMpXG4gICAgOiBjb21tYW5kc1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoaXRlbXNbaV0ocHJvcHMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwgImltcG9ydCB7IFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNUZXh0U2VsZWN0aW9uKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgVGV4dFNlbGVjdGlvbiB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb25cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gbWluTWF4KHZhbHVlID0gMCwgbWluID0gMCwgbWF4ID0gMCk6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KVxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEZvY3VzUG9zaXRpb24gfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG1pbk1heCB9IGZyb20gJy4uL3V0aWxpdGllcy9taW5NYXguanMnXG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlRm9jdXNQb3NpdGlvbihcbiAgZG9jOiBQcm9zZU1pcnJvck5vZGUsXG4gIHBvc2l0aW9uOiBGb2N1c1Bvc2l0aW9uID0gbnVsbCxcbik6IFNlbGVjdGlvbiB8IG51bGwge1xuICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IHNlbGVjdGlvbkF0U3RhcnQgPSBTZWxlY3Rpb24uYXRTdGFydChkb2MpXG4gIGNvbnN0IHNlbGVjdGlvbkF0RW5kID0gU2VsZWN0aW9uLmF0RW5kKGRvYylcblxuICBpZiAocG9zaXRpb24gPT09ICdzdGFydCcgfHwgcG9zaXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uQXRTdGFydFxuICB9XG5cbiAgaWYgKHBvc2l0aW9uID09PSAnZW5kJykge1xuICAgIHJldHVybiBzZWxlY3Rpb25BdEVuZFxuICB9XG5cbiAgY29uc3QgbWluUG9zID0gc2VsZWN0aW9uQXRTdGFydC5mcm9tXG4gIGNvbnN0IG1heFBvcyA9IHNlbGVjdGlvbkF0RW5kLnRvXG5cbiAgaWYgKHBvc2l0aW9uID09PSAnYWxsJykge1xuICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZShcbiAgICAgIGRvYyxcbiAgICAgIG1pbk1heCgwLCBtaW5Qb3MsIG1heFBvcyksXG4gICAgICBtaW5NYXgoZG9jLmNvbnRlbnQuc2l6ZSwgbWluUG9zLCBtYXhQb3MpLFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZShcbiAgICBkb2MsXG4gICAgbWluTWF4KHBvc2l0aW9uLCBtaW5Qb3MsIG1heFBvcyksXG4gICAgbWluTWF4KHBvc2l0aW9uLCBtaW5Qb3MsIG1heFBvcyksXG4gIClcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNpT1MoKTogYm9vbGVhbiB7XG4gIHJldHVybiBbXG4gICAgJ2lQYWQgU2ltdWxhdG9yJyxcbiAgICAnaVBob25lIFNpbXVsYXRvcicsXG4gICAgJ2lQb2QgU2ltdWxhdG9yJyxcbiAgICAnaVBhZCcsXG4gICAgJ2lQaG9uZScsXG4gICAgJ2lQb2QnLFxuICBdLmluY2x1ZGVzKG5hdmlnYXRvci5wbGF0Zm9ybSlcbiAgLy8gaVBhZCBvbiBpT1MgMTMgZGV0ZWN0aW9uXG4gIHx8IChuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdNYWMnKSAmJiAnb250b3VjaGVuZCcgaW4gZG9jdW1lbnQpXG59XG4iLCAiaW1wb3J0IHsgaXNUZXh0U2VsZWN0aW9uIH0gZnJvbSAnLi4vaGVscGVycy9pc1RleHRTZWxlY3Rpb24uanMnXG5pbXBvcnQgeyByZXNvbHZlRm9jdXNQb3NpdGlvbiB9IGZyb20gJy4uL2hlbHBlcnMvcmVzb2x2ZUZvY3VzUG9zaXRpb24uanMnXG5pbXBvcnQgeyBGb2N1c1Bvc2l0aW9uLCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgaXNpT1MgfSBmcm9tICcuLi91dGlsaXRpZXMvaXNpT1MuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBmb2N1czoge1xuICAgICAgLyoqXG4gICAgICAgKiBGb2N1cyB0aGUgZWRpdG9yIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgICAqL1xuICAgICAgZm9jdXM6IChcbiAgICAgICAgcG9zaXRpb24/OiBGb2N1c1Bvc2l0aW9uLFxuICAgICAgICBvcHRpb25zPzoge1xuICAgICAgICAgIHNjcm9sbEludG9WaWV3PzogYm9vbGVhbixcbiAgICAgICAgfSxcbiAgICAgICkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGZvY3VzOiBSYXdDb21tYW5kc1snZm9jdXMnXSA9IChwb3NpdGlvbiA9IG51bGwsIG9wdGlvbnMgPSB7fSkgPT4gKHtcbiAgZWRpdG9yLFxuICB2aWV3LFxuICB0cixcbiAgZGlzcGF0Y2gsXG59KSA9PiB7XG4gIG9wdGlvbnMgPSB7XG4gICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxuXG4gIGNvbnN0IGRlbGF5ZWRGb2N1cyA9ICgpID0+IHtcbiAgICAvLyBmb2N1cyB3aXRoaW4gYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYnJlYWtzIGZvY3VzIG9uIGlPU1xuICAgIC8vIHNvIHdlIGhhdmUgdG8gY2FsbCB0aGlzXG4gICAgaWYgKGlzaU9TKCkpIHtcbiAgICAgICh2aWV3LmRvbSBhcyBIVE1MRWxlbWVudCkuZm9jdXMoKVxuICAgIH1cblxuICAgIC8vIEZvciBSZWFjdCB3ZSBoYXZlIHRvIGZvY3VzIGFzeW5jaHJvbm91c2x5LiBPdGhlcndpc2Ugd2lsZCB0aGluZ3MgaGFwcGVuLlxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8xNTIwXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAgIHZpZXcuZm9jdXMoKVxuXG4gICAgICAgIGlmIChvcHRpb25zPy5zY3JvbGxJbnRvVmlldykge1xuICAgICAgICAgIGVkaXRvci5jb21tYW5kcy5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaWYgKCh2aWV3Lmhhc0ZvY3VzKCkgJiYgcG9zaXRpb24gPT09IG51bGwpIHx8IHBvc2l0aW9uID09PSBmYWxzZSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyB3ZSBkb27igJl0IHRyeSB0byByZXNvbHZlIGEgTm9kZVNlbGVjdGlvbiBvciBDZWxsU2VsZWN0aW9uXG4gIGlmIChkaXNwYXRjaCAmJiBwb3NpdGlvbiA9PT0gbnVsbCAmJiAhaXNUZXh0U2VsZWN0aW9uKGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24pKSB7XG4gICAgZGVsYXllZEZvY3VzKClcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gcGFzcyB0aHJvdWdoIHRyLmRvYyBpbnN0ZWFkIG9mIGVkaXRvci5zdGF0ZS5kb2NcbiAgLy8gc2luY2UgdHJhbnNhY3Rpb25zIGNvdWxkIGNoYW5nZSB0aGUgZWRpdG9ycyBzdGF0ZSBiZWZvcmUgdGhpcyBjb21tYW5kIGhhcyBiZWVuIHJ1blxuICBjb25zdCBzZWxlY3Rpb24gPSByZXNvbHZlRm9jdXNQb3NpdGlvbih0ci5kb2MsIHBvc2l0aW9uKSB8fCBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uXG4gIGNvbnN0IGlzU2FtZVNlbGVjdGlvbiA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZXEoc2VsZWN0aW9uKVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGlmICghaXNTYW1lU2VsZWN0aW9uKSB7XG4gICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKVxuICAgIH1cblxuICAgIC8vIGB0ci5zZXRTZWxlY3Rpb25gIHJlc2V0cyB0aGUgc3RvcmVkIG1hcmtzXG4gICAgLy8gc28gd2XigJlsbCByZXN0b3JlIHRoZW0gaWYgdGhlIHNlbGVjdGlvbiBpcyB0aGUgc2FtZSBhcyBiZWZvcmVcbiAgICBpZiAoaXNTYW1lU2VsZWN0aW9uICYmIHRyLnN0b3JlZE1hcmtzKSB7XG4gICAgICB0ci5zZXRTdG9yZWRNYXJrcyh0ci5zdG9yZWRNYXJrcylcbiAgICB9XG5cbiAgICBkZWxheWVkRm9jdXMoKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBDb21tYW5kUHJvcHMsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBmb3JFYWNoOiB7XG4gICAgICAvKipcbiAgICAgICAqIExvb3AgdGhyb3VnaCBhbiBhcnJheSBvZiBpdGVtcy5cbiAgICAgICAqL1xuICAgICAgZm9yRWFjaDogPFQ+KFxuICAgICAgICBpdGVtczogVFtdLFxuICAgICAgICBmbjogKFxuICAgICAgICAgIGl0ZW06IFQsXG4gICAgICAgICAgcHJvcHM6IENvbW1hbmRQcm9wcyAmIHtcbiAgICAgICAgICAgIGluZGV4OiBudW1iZXIsXG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiBib29sZWFuLFxuICAgICAgKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZm9yRWFjaDogUmF3Q29tbWFuZHNbJ2ZvckVhY2gnXSA9IChpdGVtcywgZm4pID0+IHByb3BzID0+IHtcbiAgcmV0dXJuIGl0ZW1zLmV2ZXJ5KChpdGVtLCBpbmRleCkgPT4gZm4oaXRlbSwgeyAuLi5wcm9wcywgaW5kZXggfSkpXG59XG4iLCAiaW1wb3J0IHsgUGFyc2VPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgQ29udGVudCwgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGluc2VydENvbnRlbnQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSW5zZXJ0IGEgbm9kZSBvciBzdHJpbmcgb2YgSFRNTCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAqL1xuICAgICAgaW5zZXJ0Q29udGVudDogKFxuICAgICAgICB2YWx1ZTogQ29udGVudCxcbiAgICAgICAgb3B0aW9ucz86IHtcbiAgICAgICAgICBwYXJzZU9wdGlvbnM/OiBQYXJzZU9wdGlvbnNcbiAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24/OiBib29sZWFuXG4gICAgICAgIH0sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGluc2VydENvbnRlbnQ6IFJhd0NvbW1hbmRzWydpbnNlcnRDb250ZW50J10gPSAodmFsdWUsIG9wdGlvbnMpID0+ICh7IHRyLCBjb21tYW5kcyB9KSA9PiB7XG4gIHJldHVybiBjb21tYW5kcy5pbnNlcnRDb250ZW50QXQoXG4gICAgeyBmcm9tOiB0ci5zZWxlY3Rpb24uZnJvbSwgdG86IHRyLnNlbGVjdGlvbi50byB9LFxuICAgIHZhbHVlLFxuICAgIG9wdGlvbnMsXG4gIClcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZWxlbWVudEZyb21TdHJpbmcodmFsdWU6IHN0cmluZyk6IEhUTUxFbGVtZW50IHtcbiAgLy8gYWRkIGEgd3JhcHBlciB0byBwcmVzZXJ2ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gIGNvbnN0IHdyYXBwZWRWYWx1ZSA9IGA8Ym9keT4ke3ZhbHVlfTwvYm9keT5gXG5cbiAgcmV0dXJuIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHdyYXBwZWRWYWx1ZSwgJ3RleHQvaHRtbCcpLmJvZHlcbn1cbiIsICJpbXBvcnQge1xuICBET01QYXJzZXIsXG4gIEZyYWdtZW50LFxuICBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSxcbiAgUGFyc2VPcHRpb25zLFxuICBTY2hlbWEsXG59IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IENvbnRlbnQgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGVsZW1lbnRGcm9tU3RyaW5nIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2VsZW1lbnRGcm9tU3RyaW5nLmpzJ1xuXG5leHBvcnQgdHlwZSBDcmVhdGVOb2RlRnJvbUNvbnRlbnRPcHRpb25zID0ge1xuICBzbGljZT86IGJvb2xlYW5cbiAgcGFyc2VPcHRpb25zPzogUGFyc2VPcHRpb25zXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoXG4gIGNvbnRlbnQ6IENvbnRlbnQsXG4gIHNjaGVtYTogU2NoZW1hLFxuICBvcHRpb25zPzogQ3JlYXRlTm9kZUZyb21Db250ZW50T3B0aW9ucyxcbik6IFByb3NlTWlycm9yTm9kZSB8IEZyYWdtZW50IHtcbiAgb3B0aW9ucyA9IHtcbiAgICBzbGljZTogdHJ1ZSxcbiAgICBwYXJzZU9wdGlvbnM6IHt9LFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdvYmplY3QnICYmIGNvbnRlbnQgIT09IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudCkgJiYgY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tQXJyYXkoY29udGVudC5tYXAoaXRlbSA9PiBzY2hlbWEubm9kZUZyb21KU09OKGl0ZW0pKSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNjaGVtYS5ub2RlRnJvbUpTT04oY29udGVudClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBJbnZhbGlkIGNvbnRlbnQuJywgJ1Bhc3NlZCB2YWx1ZTonLCBjb250ZW50LCAnRXJyb3I6JywgZXJyb3IpXG5cbiAgICAgIHJldHVybiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoJycsIHNjaGVtYSwgb3B0aW9ucylcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgcGFyc2VyID0gRE9NUGFyc2VyLmZyb21TY2hlbWEoc2NoZW1hKVxuXG4gICAgcmV0dXJuIG9wdGlvbnMuc2xpY2VcbiAgICAgID8gcGFyc2VyLnBhcnNlU2xpY2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKS5jb250ZW50XG4gICAgICA6IHBhcnNlci5wYXJzZShlbGVtZW50RnJvbVN0cmluZyhjb250ZW50KSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KCcnLCBzY2hlbWEsIG9wdGlvbnMpXG59XG4iLCAiaW1wb3J0IHsgU2VsZWN0aW9uLCBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBSZXBsYWNlQXJvdW5kU3RlcCwgUmVwbGFjZVN0ZXAgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3Itc3RhdGUvYmxvYi9tYXN0ZXIvc3JjL3NlbGVjdGlvbi5qcyNMNDY2XG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHI6IFRyYW5zYWN0aW9uLCBzdGFydExlbjogbnVtYmVyLCBiaWFzOiBudW1iZXIpIHtcbiAgY29uc3QgbGFzdCA9IHRyLnN0ZXBzLmxlbmd0aCAtIDFcblxuICBpZiAobGFzdCA8IHN0YXJ0TGVuKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBzdGVwID0gdHIuc3RlcHNbbGFzdF1cblxuICBpZiAoIShzdGVwIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXAgfHwgc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VBcm91bmRTdGVwKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgbWFwID0gdHIubWFwcGluZy5tYXBzW2xhc3RdXG4gIGxldCBlbmQgPSAwXG5cbiAgbWFwLmZvckVhY2goKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgPT4ge1xuICAgIGlmIChlbmQgPT09IDApIHtcbiAgICAgIGVuZCA9IG5ld1RvXG4gICAgfVxuICB9KVxuXG4gIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShlbmQpLCBiaWFzKSlcbn1cbiIsICJpbXBvcnQgeyBGcmFnbWVudCwgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUsIFBhcnNlT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGNyZWF0ZU5vZGVGcm9tQ29udGVudCB9IGZyb20gJy4uL2hlbHBlcnMvY3JlYXRlTm9kZUZyb21Db250ZW50LmpzJ1xuaW1wb3J0IHsgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQgfSBmcm9tICcuLi9oZWxwZXJzL3NlbGVjdGlvblRvSW5zZXJ0aW9uRW5kLmpzJ1xuaW1wb3J0IHsgQ29udGVudCwgUmFuZ2UsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBpbnNlcnRDb250ZW50QXQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSW5zZXJ0IGEgbm9kZSBvciBzdHJpbmcgb2YgSFRNTCBhdCBhIHNwZWNpZmljIHBvc2l0aW9uLlxuICAgICAgICovXG4gICAgICBpbnNlcnRDb250ZW50QXQ6IChcbiAgICAgICAgcG9zaXRpb246IG51bWJlciB8IFJhbmdlLFxuICAgICAgICB2YWx1ZTogQ29udGVudCxcbiAgICAgICAgb3B0aW9ucz86IHtcbiAgICAgICAgICBwYXJzZU9wdGlvbnM/OiBQYXJzZU9wdGlvbnNcbiAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24/OiBib29sZWFuXG4gICAgICAgIH0sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaXNGcmFnbWVudCA9IChub2RlT3JGcmFnbWVudDogUHJvc2VNaXJyb3JOb2RlIHwgRnJhZ21lbnQpOiBub2RlT3JGcmFnbWVudCBpcyBGcmFnbWVudCA9PiB7XG4gIHJldHVybiBub2RlT3JGcmFnbWVudC50b1N0cmluZygpLnN0YXJ0c1dpdGgoJzwnKVxufVxuXG5leHBvcnQgY29uc3QgaW5zZXJ0Q29udGVudEF0OiBSYXdDb21tYW5kc1snaW5zZXJ0Q29udGVudEF0J10gPSAocG9zaXRpb24sIHZhbHVlLCBvcHRpb25zKSA9PiAoeyB0ciwgZGlzcGF0Y2gsIGVkaXRvciB9KSA9PiB7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBwYXJzZU9wdGlvbnM6IHt9LFxuICAgICAgdXBkYXRlU2VsZWN0aW9uOiB0cnVlLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50ID0gY3JlYXRlTm9kZUZyb21Db250ZW50KHZhbHVlLCBlZGl0b3Iuc2NoZW1hLCB7XG4gICAgICBwYXJzZU9wdGlvbnM6IHtcbiAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAnZnVsbCcsXG4gICAgICAgIC4uLm9wdGlvbnMucGFyc2VPcHRpb25zLFxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgLy8gZG9u4oCZdCBkaXNwYXRjaCBhbiBlbXB0eSBmcmFnbWVudCBiZWNhdXNlIHRoaXMgY2FuIGxlYWQgdG8gc3RyYW5nZSBlcnJvcnNcbiAgICBpZiAoY29udGVudC50b1N0cmluZygpID09PSAnPD4nKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGxldCB7IGZyb20sIHRvIH0gPSB0eXBlb2YgcG9zaXRpb24gPT09ICdudW1iZXInID8geyBmcm9tOiBwb3NpdGlvbiwgdG86IHBvc2l0aW9uIH0gOiB7IGZyb206IHBvc2l0aW9uLmZyb20sIHRvOiBwb3NpdGlvbi50byB9XG5cbiAgICBsZXQgaXNPbmx5VGV4dENvbnRlbnQgPSB0cnVlXG4gICAgbGV0IGlzT25seUJsb2NrQ29udGVudCA9IHRydWVcbiAgICBjb25zdCBub2RlcyA9IGlzRnJhZ21lbnQoY29udGVudCkgPyBjb250ZW50IDogW2NvbnRlbnRdXG5cbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgLy8gY2hlY2sgaWYgYWRkZWQgbm9kZSBpcyB2YWxpZFxuICAgICAgbm9kZS5jaGVjaygpXG5cbiAgICAgIGlzT25seVRleHRDb250ZW50ID0gaXNPbmx5VGV4dENvbnRlbnQgPyBub2RlLmlzVGV4dCAmJiBub2RlLm1hcmtzLmxlbmd0aCA9PT0gMCA6IGZhbHNlXG5cbiAgICAgIGlzT25seUJsb2NrQ29udGVudCA9IGlzT25seUJsb2NrQ29udGVudCA/IG5vZGUuaXNCbG9jayA6IGZhbHNlXG4gICAgfSlcblxuICAgIC8vIGNoZWNrIGlmIHdlIGNhbiByZXBsYWNlIHRoZSB3cmFwcGluZyBub2RlIGJ5XG4gICAgLy8gdGhlIG5ld2x5IGluc2VydGVkIGNvbnRlbnRcbiAgICAvLyBleGFtcGxlOlxuICAgIC8vIHJlcGxhY2UgYW4gZW1wdHkgcGFyYWdyYXBoIGJ5IGFuIGluc2VydGVkIGltYWdlXG4gICAgLy8gaW5zdGVhZCBvZiBpbnNlcnRpbmcgdGhlIGltYWdlIGJlbG93IHRoZSBwYXJhZ3JhcGhcbiAgICBpZiAoZnJvbSA9PT0gdG8gJiYgaXNPbmx5QmxvY2tDb250ZW50KSB7XG4gICAgICBjb25zdCB7IHBhcmVudCB9ID0gdHIuZG9jLnJlc29sdmUoZnJvbSlcbiAgICAgIGNvbnN0IGlzRW1wdHlUZXh0QmxvY2sgPSBwYXJlbnQuaXNUZXh0YmxvY2sgJiYgIXBhcmVudC50eXBlLnNwZWMuY29kZSAmJiAhcGFyZW50LmNoaWxkQ291bnRcblxuICAgICAgaWYgKGlzRW1wdHlUZXh0QmxvY2spIHtcbiAgICAgICAgZnJvbSAtPSAxXG4gICAgICAgIHRvICs9IDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBvbmx5IHBsYWluIHRleHQgd2UgaGF2ZSB0byB1c2UgYGluc2VydFRleHRgXG4gICAgLy8gYmVjYXVzZSB0aGlzIHdpbGwga2VlcCB0aGUgY3VycmVudCBtYXJrc1xuICAgIGlmIChpc09ubHlUZXh0Q29udGVudCkge1xuICAgICAgLy8gaWYgdmFsdWUgaXMgc3RyaW5nLCB3ZSBjYW4gdXNlIGl0IGRpcmVjdGx5XG4gICAgICAvLyBvdGhlcndpc2UgaWYgaXQgaXMgYW4gYXJyYXksIHdlIGhhdmUgdG8gam9pbiBpdFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRyLmluc2VydFRleHQodmFsdWUubWFwKHYgPT4gdi50ZXh0IHx8ICcnKS5qb2luKCcnKSwgZnJvbSwgdG8pXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgISF2YWx1ZSAmJiAhIXZhbHVlLnRleHQpIHtcbiAgICAgICAgdHIuaW5zZXJ0VGV4dCh2YWx1ZS50ZXh0LCBmcm9tLCB0bylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyLmluc2VydFRleHQodmFsdWUgYXMgc3RyaW5nLCBmcm9tLCB0bylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHIucmVwbGFjZVdpdGgoZnJvbSwgdG8sIGNvbnRlbnQpXG4gICAgfVxuXG4gICAgLy8gc2V0IGN1cnNvciBhdCBlbmQgb2YgaW5zZXJ0ZWQgY29udGVudFxuICAgIGlmIChvcHRpb25zLnVwZGF0ZVNlbGVjdGlvbikge1xuICAgICAgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIHRyLnN0ZXBzLmxlbmd0aCAtIDEsIC0xKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHtcbiAgam9pbkJhY2t3YXJkIGFzIG9yaWdpbmFsSm9pbkJhY2t3YXJkLFxuICBqb2luRG93biBhcyBvcmlnaW5hbEpvaW5Eb3duLFxuICBqb2luRm9yd2FyZCBhcyBvcmlnaW5hbEpvaW5Gb3J3YXJkLFxuICBqb2luVXAgYXMgb3JpZ2luYWxKb2luVXAsXG59IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBqb2luVXA6IHtcbiAgICAgIC8qKlxuICAgICAgICogSm9pbiB0d28gbm9kZXMgVXAuXG4gICAgICAgKi9cbiAgICAgIGpvaW5VcDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgICBqb2luRG93bjoge1xuICAgICAgLyoqXG4gICAgICAgKiBKb2luIHR3byBub2RlcyBEb3duLlxuICAgICAgICovXG4gICAgICBqb2luRG93bjogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgICBqb2luQmFja3dhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSm9pbiB0d28gbm9kZXMgQmFja3dhcmRzLlxuICAgICAgICovXG4gICAgICBqb2luQmFja3dhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gICAgam9pbkZvcndhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSm9pbiB0d28gbm9kZXMgRm9yd2FyZHMuXG4gICAgICAgKi9cbiAgICAgIGpvaW5Gb3J3YXJkOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBqb2luVXA6IFJhd0NvbW1hbmRzWydqb2luVXAnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbEpvaW5VcChzdGF0ZSwgZGlzcGF0Y2gpXG59XG5cbmV4cG9ydCBjb25zdCBqb2luRG93bjogUmF3Q29tbWFuZHNbJ2pvaW5Eb3duJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxKb2luRG93bihzdGF0ZSwgZGlzcGF0Y2gpXG59XG5cbmV4cG9ydCBjb25zdCBqb2luQmFja3dhcmQ6IFJhd0NvbW1hbmRzWydqb2luQmFja3dhcmQnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbEpvaW5CYWNrd2FyZChzdGF0ZSwgZGlzcGF0Y2gpXG59XG5cbmV4cG9ydCBjb25zdCBqb2luRm9yd2FyZDogUmF3Q29tbWFuZHNbJ2pvaW5Gb3J3YXJkJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxKb2luRm9yd2FyZChzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgam9pblBvaW50IH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBqb2luSXRlbUJhY2t3YXJkOiB7XG4gICAgICAvKipcbiAgICAgICAqIEpvaW4gdHdvIG5vZGVzIEZvcndhcmRzLlxuICAgICAgICovXG4gICAgICBqb2luSXRlbUJhY2t3YXJkOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBqb2luSXRlbUJhY2t3YXJkOiBSYXdDb21tYW5kc1snam9pbkl0ZW1CYWNrd2FyZCddID0gKCkgPT4gKHtcbiAgdHIsIHN0YXRlLCBkaXNwYXRjaCxcbn0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wb3MsIC0xKVxuXG4gICAgaWYgKHBvaW50ID09PSBudWxsIHx8IHBvaW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHRyLmpvaW4ocG9pbnQsIDIpXG5cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGRpc3BhdGNoKHRyKVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG4iLCAiaW1wb3J0IHsgam9pblBvaW50IH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBqb2luSXRlbUZvcndhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSm9pbiB0d28gbm9kZXMgRm9yd2FyZHMuXG4gICAgICAgKi9cbiAgICAgIGpvaW5JdGVtRm9yd2FyZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgam9pbkl0ZW1Gb3J3YXJkOiBSYXdDb21tYW5kc1snam9pbkl0ZW1Gb3J3YXJkJ10gPSAoKSA9PiAoe1xuICBzdGF0ZSxcbiAgZGlzcGF0Y2gsXG4gIHRyLFxufSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBvcywgKzEpXG5cbiAgICBpZiAocG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdHIuam9pbihwb2ludCwgMilcblxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgZGlzcGF0Y2godHIpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzTWFjT1MoKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJ1xuICAgID8gL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG4gICAgOiBmYWxzZVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBpc2lPUyB9IGZyb20gJy4uL3V0aWxpdGllcy9pc2lPUy5qcydcbmltcG9ydCB7IGlzTWFjT1MgfSBmcm9tICcuLi91dGlsaXRpZXMvaXNNYWNPUy5qcydcblxuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lOiBzdHJpbmcpIHtcbiAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKVxuICBsZXQgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV1cblxuICBpZiAocmVzdWx0ID09PSAnU3BhY2UnKSB7XG4gICAgcmVzdWx0ID0gJyAnXG4gIH1cblxuICBsZXQgYWx0XG4gIGxldCBjdHJsXG4gIGxldCBzaGlmdFxuICBsZXQgbWV0YVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgY29uc3QgbW9kID0gcGFydHNbaV1cblxuICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIG1ldGEgPSB0cnVlXG4gICAgfSBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIGFsdCA9IHRydWVcbiAgICB9IGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIGN0cmwgPSB0cnVlXG4gICAgfSBlbHNlIGlmICgvXnMoaGlmdCk/JC9pLnRlc3QobW9kKSkge1xuICAgICAgc2hpZnQgPSB0cnVlXG4gICAgfSBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIGlmIChpc2lPUygpIHx8IGlzTWFjT1MoKSkge1xuICAgICAgICBtZXRhID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3RybCA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogJHttb2R9YClcbiAgICB9XG4gIH1cblxuICBpZiAoYWx0KSB7XG4gICAgcmVzdWx0ID0gYEFsdC0ke3Jlc3VsdH1gXG4gIH1cblxuICBpZiAoY3RybCkge1xuICAgIHJlc3VsdCA9IGBDdHJsLSR7cmVzdWx0fWBcbiAgfVxuXG4gIGlmIChtZXRhKSB7XG4gICAgcmVzdWx0ID0gYE1ldGEtJHtyZXN1bHR9YFxuICB9XG5cbiAgaWYgKHNoaWZ0KSB7XG4gICAgcmVzdWx0ID0gYFNoaWZ0LSR7cmVzdWx0fWBcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGtleWJvYXJkU2hvcnRjdXQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogVHJpZ2dlciBhIGtleWJvYXJkIHNob3J0Y3V0LlxuICAgICAgICovXG4gICAgICBrZXlib2FyZFNob3J0Y3V0OiAobmFtZTogc3RyaW5nKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qga2V5Ym9hcmRTaG9ydGN1dDogUmF3Q29tbWFuZHNbJ2tleWJvYXJkU2hvcnRjdXQnXSA9IG5hbWUgPT4gKHtcbiAgZWRpdG9yLFxuICB2aWV3LFxuICB0cixcbiAgZGlzcGF0Y2gsXG59KSA9PiB7XG4gIGNvbnN0IGtleXMgPSBub3JtYWxpemVLZXlOYW1lKG5hbWUpLnNwbGl0KC8tKD8hJCkvKVxuICBjb25zdCBrZXkgPSBrZXlzLmZpbmQoaXRlbSA9PiAhWydBbHQnLCAnQ3RybCcsICdNZXRhJywgJ1NoaWZ0J10uaW5jbHVkZXMoaXRlbSkpXG4gIGNvbnN0IGV2ZW50ID0gbmV3IEtleWJvYXJkRXZlbnQoJ2tleWRvd24nLCB7XG4gICAga2V5OiBrZXkgPT09ICdTcGFjZSdcbiAgICAgID8gJyAnXG4gICAgICA6IGtleSxcbiAgICBhbHRLZXk6IGtleXMuaW5jbHVkZXMoJ0FsdCcpLFxuICAgIGN0cmxLZXk6IGtleXMuaW5jbHVkZXMoJ0N0cmwnKSxcbiAgICBtZXRhS2V5OiBrZXlzLmluY2x1ZGVzKCdNZXRhJyksXG4gICAgc2hpZnRLZXk6IGtleXMuaW5jbHVkZXMoJ1NoaWZ0JyksXG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICB9KVxuXG4gIGNvbnN0IGNhcHR1cmVkVHJhbnNhY3Rpb24gPSBlZGl0b3IuY2FwdHVyZVRyYW5zYWN0aW9uKCgpID0+IHtcbiAgICB2aWV3LnNvbWVQcm9wKCdoYW5kbGVLZXlEb3duJywgZiA9PiBmKHZpZXcsIGV2ZW50KSlcbiAgfSlcblxuICBjYXB0dXJlZFRyYW5zYWN0aW9uPy5zdGVwcy5mb3JFYWNoKHN0ZXAgPT4ge1xuICAgIGNvbnN0IG5ld1N0ZXAgPSBzdGVwLm1hcCh0ci5tYXBwaW5nKVxuXG4gICAgaWYgKG5ld1N0ZXAgJiYgZGlzcGF0Y2gpIHtcbiAgICAgIHRyLm1heWJlU3RlcChuZXdTdGVwKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgTm9kZVJhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBvYmplY3RJbmNsdWRlcyB9IGZyb20gJy4uL3V0aWxpdGllcy9vYmplY3RJbmNsdWRlcy5qcydcbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi9nZXROb2RlVHlwZS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZUFjdGl2ZShcbiAgc3RhdGU6IEVkaXRvclN0YXRlLFxuICB0eXBlT3JOYW1lOiBOb2RlVHlwZSB8IHN0cmluZyB8IG51bGwsXG4gIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSxcbik6IGJvb2xlYW4ge1xuICBjb25zdCB7IGZyb20sIHRvLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uXG4gIGNvbnN0IHR5cGUgPSB0eXBlT3JOYW1lID8gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKSA6IG51bGxcblxuICBjb25zdCBub2RlUmFuZ2VzOiBOb2RlUmFuZ2VbXSA9IFtdXG5cbiAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVsYXRpdmVGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKVxuICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBNYXRoLm1pbih0bywgcG9zICsgbm9kZS5ub2RlU2l6ZSlcblxuICAgIG5vZGVSYW5nZXMucHVzaCh7XG4gICAgICBub2RlLFxuICAgICAgZnJvbTogcmVsYXRpdmVGcm9tLFxuICAgICAgdG86IHJlbGF0aXZlVG8sXG4gICAgfSlcbiAgfSlcblxuICBjb25zdCBzZWxlY3Rpb25SYW5nZSA9IHRvIC0gZnJvbVxuICBjb25zdCBtYXRjaGVkTm9kZVJhbmdlcyA9IG5vZGVSYW5nZXNcbiAgICAuZmlsdGVyKG5vZGVSYW5nZSA9PiB7XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gbm9kZVJhbmdlLm5vZGUudHlwZS5uYW1lXG4gICAgfSlcbiAgICAuZmlsdGVyKG5vZGVSYW5nZSA9PiBvYmplY3RJbmNsdWRlcyhub2RlUmFuZ2Uubm9kZS5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKVxuXG4gIGlmIChlbXB0eSkge1xuICAgIHJldHVybiAhIW1hdGNoZWROb2RlUmFuZ2VzLmxlbmd0aFxuICB9XG5cbiAgY29uc3QgcmFuZ2UgPSBtYXRjaGVkTm9kZVJhbmdlcy5yZWR1Y2UoKHN1bSwgbm9kZVJhbmdlKSA9PiBzdW0gKyBub2RlUmFuZ2UudG8gLSBub2RlUmFuZ2UuZnJvbSwgMClcblxuICByZXR1cm4gcmFuZ2UgPj0gc2VsZWN0aW9uUmFuZ2Vcbn1cbiIsICJpbXBvcnQgeyBsaWZ0IGFzIG9yaWdpbmFsTGlmdCB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5pbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGlzTm9kZUFjdGl2ZSB9IGZyb20gJy4uL2hlbHBlcnMvaXNOb2RlQWN0aXZlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGxpZnQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBhbiBleGlzdGluZyB3cmFwLlxuICAgICAgICovXG4gICAgICBsaWZ0OiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBsaWZ0OiBSYXdDb21tYW5kc1snbGlmdCddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgaXNBY3RpdmUgPSBpc05vZGVBY3RpdmUoc3RhdGUsIHR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgaWYgKCFpc0FjdGl2ZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIG9yaWdpbmFsTGlmdChzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgbGlmdEVtcHR5QmxvY2sgYXMgb3JpZ2luYWxMaWZ0RW1wdHlCbG9jayB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBsaWZ0RW1wdHlCbG9jazoge1xuICAgICAgLyoqXG4gICAgICAgKiBMaWZ0IGJsb2NrIGlmIGVtcHR5LlxuICAgICAgICovXG4gICAgICBsaWZ0RW1wdHlCbG9jazogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGxpZnRFbXB0eUJsb2NrOiBSYXdDb21tYW5kc1snbGlmdEVtcHR5QmxvY2snXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbExpZnRFbXB0eUJsb2NrKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBsaWZ0TGlzdEl0ZW0gYXMgb3JpZ2luYWxMaWZ0TGlzdEl0ZW0gfSBmcm9tICdAdGlwdGFwL3BtL3NjaGVtYS1saXN0J1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgbGlmdExpc3RJdGVtOiB7XG4gICAgICAvKipcbiAgICAgICAqIExpZnQgdGhlIGxpc3QgaXRlbSBpbnRvIGEgd3JhcHBpbmcgbGlzdC5cbiAgICAgICAqL1xuICAgICAgbGlmdExpc3RJdGVtOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGxpZnRMaXN0SXRlbTogUmF3Q29tbWFuZHNbJ2xpZnRMaXN0SXRlbSddID0gdHlwZU9yTmFtZSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIHJldHVybiBvcmlnaW5hbExpZnRMaXN0SXRlbSh0eXBlKShzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgbmV3bGluZUluQ29kZSBhcyBvcmlnaW5hbE5ld2xpbmVJbkNvZGUgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgbmV3bGluZUluQ29kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYSBuZXdsaW5lIGNoYXJhY3RlciBpbiBjb2RlLlxuICAgICAgICovXG4gICAgICBuZXdsaW5lSW5Db2RlOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBuZXdsaW5lSW5Db2RlOiBSYXdDb21tYW5kc1snbmV3bGluZUluQ29kZSddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsTmV3bGluZUluQ29kZShzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKG5hbWU6IHN0cmluZywgc2NoZW1hOiBTY2hlbWEpOiAnbm9kZScgfCAnbWFyaycgfCBudWxsIHtcbiAgaWYgKHNjaGVtYS5ub2Rlc1tuYW1lXSkge1xuICAgIHJldHVybiAnbm9kZSdcbiAgfVxuXG4gIGlmIChzY2hlbWEubWFya3NbbmFtZV0pIHtcbiAgICByZXR1cm4gJ21hcmsnXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuIiwgIi8qKlxuICogUmVtb3ZlIGEgcHJvcGVydHkgb3IgYW4gYXJyYXkgb2YgcHJvcGVydGllcyBmcm9tIGFuIG9iamVjdFxuICogQHBhcmFtIG9iaiBPYmplY3RcbiAqIEBwYXJhbSBrZXkgS2V5IHRvIHJlbW92ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlUHJvcHMob2JqOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBwcm9wT3JQcm9wczogc3RyaW5nIHwgc3RyaW5nW10pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgY29uc3QgcHJvcHMgPSB0eXBlb2YgcHJvcE9yUHJvcHMgPT09ICdzdHJpbmcnXG4gICAgPyBbcHJvcE9yUHJvcHNdXG4gICAgOiBwcm9wT3JQcm9wc1xuXG4gIHJldHVybiBPYmplY3RcbiAgICAua2V5cyhvYmopXG4gICAgLnJlZHVjZSgobmV3T2JqOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBwcm9wKSA9PiB7XG4gICAgICBpZiAoIXByb3BzLmluY2x1ZGVzKHByb3ApKSB7XG4gICAgICAgIG5ld09ialtwcm9wXSA9IG9ialtwcm9wXVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3T2JqXG4gICAgfSwge30pXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtUeXBlLmpzJ1xuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUgfSBmcm9tICcuLi9oZWxwZXJzL2dldFNjaGVtYVR5cGVOYW1lQnlOYW1lLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGRlbGV0ZVByb3BzIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2RlbGV0ZVByb3BzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgcmVzZXRBdHRyaWJ1dGVzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlc2V0cyBzb21lIG5vZGUgYXR0cmlidXRlcyB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAqL1xuICAgICAgcmVzZXRBdHRyaWJ1dGVzOiAoXG4gICAgICAgIHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlIHwgTWFya1R5cGUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHN0cmluZyB8IHN0cmluZ1tdLFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCByZXNldEF0dHJpYnV0ZXM6IFJhd0NvbW1hbmRzWydyZXNldEF0dHJpYnV0ZXMnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzKSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgbGV0IG5vZGVUeXBlOiBOb2RlVHlwZSB8IG51bGwgPSBudWxsXG4gIGxldCBtYXJrVHlwZTogTWFya1R5cGUgfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShcbiAgICB0eXBlb2YgdHlwZU9yTmFtZSA9PT0gJ3N0cmluZycgPyB0eXBlT3JOYW1lIDogdHlwZU9yTmFtZS5uYW1lLFxuICAgIHN0YXRlLnNjaGVtYSxcbiAgKVxuXG4gIGlmICghc2NoZW1hVHlwZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09ICdub2RlJykge1xuICAgIG5vZGVUeXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSBhcyBOb2RlVHlwZSwgc3RhdGUuc2NoZW1hKVxuICB9XG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09ICdtYXJrJykge1xuICAgIG1hcmtUeXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSBhcyBNYXJrVHlwZSwgc3RhdGUuc2NoZW1hKVxuICB9XG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdHIuc2VsZWN0aW9uLnJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4ocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XG4gICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIHVuZGVmaW5lZCwgZGVsZXRlUHJvcHMobm9kZS5hdHRycywgYXR0cmlidXRlcykpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFya1R5cGUgJiYgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgICAgICBpZiAobWFya1R5cGUgPT09IG1hcmsudHlwZSkge1xuICAgICAgICAgICAgICB0ci5hZGRNYXJrKFxuICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICBwb3MgKyBub2RlLm5vZGVTaXplLFxuICAgICAgICAgICAgICAgIG1hcmtUeXBlLmNyZWF0ZShkZWxldGVQcm9wcyhtYXJrLmF0dHJzLCBhdHRyaWJ1dGVzKSksXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzY3JvbGxJbnRvVmlldzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgdGhlIHNlbGVjdGlvbiBpbnRvIHZpZXcuXG4gICAgICAgKi9cbiAgICAgIHNjcm9sbEludG9WaWV3OiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2Nyb2xsSW50b1ZpZXc6IFJhd0NvbW1hbmRzWydzY3JvbGxJbnRvVmlldyddID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdHIuc2Nyb2xsSW50b1ZpZXcoKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2VsZWN0QWxsOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNlbGVjdCB0aGUgd2hvbGUgZG9jdW1lbnQuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdEFsbDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNlbGVjdEFsbDogUmF3Q29tbWFuZHNbJ3NlbGVjdEFsbCddID0gKCkgPT4gKHsgdHIsIGNvbW1hbmRzIH0pID0+IHtcbiAgcmV0dXJuIGNvbW1hbmRzLnNldFRleHRTZWxlY3Rpb24oe1xuICAgIGZyb206IDAsXG4gICAgdG86IHRyLmRvYy5jb250ZW50LnNpemUsXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgc2VsZWN0Tm9kZUJhY2t3YXJkIGFzIG9yaWdpbmFsU2VsZWN0Tm9kZUJhY2t3YXJkIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNlbGVjdE5vZGVCYWNrd2FyZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZWxlY3QgYSBub2RlIGJhY2t3YXJkLlxuICAgICAgICovXG4gICAgICBzZWxlY3ROb2RlQmFja3dhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNlbGVjdE5vZGVCYWNrd2FyZDogUmF3Q29tbWFuZHNbJ3NlbGVjdE5vZGVCYWNrd2FyZCddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0Tm9kZUJhY2t3YXJkKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBzZWxlY3ROb2RlRm9yd2FyZCBhcyBvcmlnaW5hbFNlbGVjdE5vZGVGb3J3YXJkIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNlbGVjdE5vZGVGb3J3YXJkOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNlbGVjdCBhIG5vZGUgZm9yd2FyZC5cbiAgICAgICAqL1xuICAgICAgc2VsZWN0Tm9kZUZvcndhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNlbGVjdE5vZGVGb3J3YXJkOiBSYXdDb21tYW5kc1snc2VsZWN0Tm9kZUZvcndhcmQnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbFNlbGVjdE5vZGVGb3J3YXJkKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBzZWxlY3RQYXJlbnROb2RlIGFzIG9yaWdpbmFsU2VsZWN0UGFyZW50Tm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZWxlY3RQYXJlbnROb2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNlbGVjdCB0aGUgcGFyZW50IG5vZGUuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdFBhcmVudE5vZGU6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNlbGVjdFBhcmVudE5vZGU6IFJhd0NvbW1hbmRzWydzZWxlY3RQYXJlbnROb2RlJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3RQYXJlbnROb2RlKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICIvLyBAdHMtaWdub3JlXG4vLyBUT0RPOiBhZGQgdHlwZXMgdG8gQHR5cGVzL3Byb3NlbWlycm9yLWNvbW1hbmRzXG5pbXBvcnQgeyBzZWxlY3RUZXh0YmxvY2tFbmQgYXMgb3JpZ2luYWxTZWxlY3RUZXh0YmxvY2tFbmQgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2VsZWN0VGV4dGJsb2NrRW5kOiB7XG4gICAgICAvKipcbiAgICAgICAqIE1vdmVzIHRoZSBjdXJzb3IgdG8gdGhlIGVuZCBvZiBjdXJyZW50IHRleHQgYmxvY2suXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdFRleHRibG9ja0VuZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2VsZWN0VGV4dGJsb2NrRW5kOiBSYXdDb21tYW5kc1snc2VsZWN0VGV4dGJsb2NrRW5kJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3RUZXh0YmxvY2tFbmQoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgIi8vIEB0cy1pZ25vcmVcbi8vIFRPRE86IGFkZCB0eXBlcyB0byBAdHlwZXMvcHJvc2VtaXJyb3ItY29tbWFuZHNcbmltcG9ydCB7IHNlbGVjdFRleHRibG9ja1N0YXJ0IGFzIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrU3RhcnQgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2VsZWN0VGV4dGJsb2NrU3RhcnQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogTW92ZXMgdGhlIGN1cnNvciB0byB0aGUgc3RhcnQgb2YgY3VycmVudCB0ZXh0IGJsb2NrLlxuICAgICAgICovXG4gICAgICBzZWxlY3RUZXh0YmxvY2tTdGFydDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2VsZWN0VGV4dGJsb2NrU3RhcnQ6IFJhd0NvbW1hbmRzWydzZWxlY3RUZXh0YmxvY2tTdGFydCddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrU3RhcnQoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLCBQYXJzZU9wdGlvbnMsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IENvbnRlbnQgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGNyZWF0ZU5vZGVGcm9tQ29udGVudCB9IGZyb20gJy4vY3JlYXRlTm9kZUZyb21Db250ZW50LmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnQoXG4gIGNvbnRlbnQ6IENvbnRlbnQsXG4gIHNjaGVtYTogU2NoZW1hLFxuICBwYXJzZU9wdGlvbnM6IFBhcnNlT3B0aW9ucyA9IHt9LFxuKTogUHJvc2VNaXJyb3JOb2RlIHtcbiAgcmV0dXJuIGNyZWF0ZU5vZGVGcm9tQ29udGVudChjb250ZW50LCBzY2hlbWEsIHsgc2xpY2U6IGZhbHNlLCBwYXJzZU9wdGlvbnMgfSkgYXMgUHJvc2VNaXJyb3JOb2RlXG59XG4iLCAiaW1wb3J0IHsgUGFyc2VPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgY3JlYXRlRG9jdW1lbnQgfSBmcm9tICcuLi9oZWxwZXJzL2NyZWF0ZURvY3VtZW50LmpzJ1xuaW1wb3J0IHsgQ29udGVudCwgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNldENvbnRlbnQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVwbGFjZSB0aGUgd2hvbGUgZG9jdW1lbnQgd2l0aCBuZXcgY29udGVudC5cbiAgICAgICAqL1xuICAgICAgc2V0Q29udGVudDogKFxuICAgICAgICBjb250ZW50OiBDb250ZW50LFxuICAgICAgICBlbWl0VXBkYXRlPzogYm9vbGVhbixcbiAgICAgICAgcGFyc2VPcHRpb25zPzogUGFyc2VPcHRpb25zLFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZXRDb250ZW50OiBSYXdDb21tYW5kc1snc2V0Q29udGVudCddID0gKGNvbnRlbnQsIGVtaXRVcGRhdGUgPSBmYWxzZSwgcGFyc2VPcHRpb25zID0ge30pID0+ICh7IHRyLCBlZGl0b3IsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBkb2MgfSA9IHRyXG4gIGNvbnN0IGRvY3VtZW50ID0gY3JlYXRlRG9jdW1lbnQoY29udGVudCwgZWRpdG9yLnNjaGVtYSwgcGFyc2VPcHRpb25zKVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHRyLnJlcGxhY2VXaXRoKDAsIGRvYy5jb250ZW50LnNpemUsIGRvY3VtZW50KS5zZXRNZXRhKCdwcmV2ZW50VXBkYXRlJywgIWVtaXRVcGRhdGUpXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IE1hcmssIE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuL2dldE1hcmtUeXBlLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFya0F0dHJpYnV0ZXMoXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZSxcbiAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTWFya1R5cGUsXG4pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgeyBmcm9tLCB0bywgZW1wdHkgfSA9IHN0YXRlLnNlbGVjdGlvblxuICBjb25zdCBtYXJrczogTWFya1tdID0gW11cblxuICBpZiAoZW1wdHkpIHtcbiAgICBpZiAoc3RhdGUuc3RvcmVkTWFya3MpIHtcbiAgICAgIG1hcmtzLnB1c2goLi4uc3RhdGUuc3RvcmVkTWFya3MpXG4gICAgfVxuXG4gICAgbWFya3MucHVzaCguLi5zdGF0ZS5zZWxlY3Rpb24uJGhlYWQubWFya3MoKSlcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBub2RlID0+IHtcbiAgICAgIG1hcmtzLnB1c2goLi4ubm9kZS5tYXJrcylcbiAgICB9KVxuICB9XG5cbiAgY29uc3QgbWFyayA9IG1hcmtzLmZpbmQobWFya0l0ZW0gPT4gbWFya0l0ZW0udHlwZS5uYW1lID09PSB0eXBlLm5hbWUpXG5cbiAgaWYgKCFtYXJrKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cblxuICByZXR1cm4geyAuLi5tYXJrLmF0dHJzIH1cbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGBUcmFuc2Zvcm1gIGJhc2VkIG9uIGFsbCBzdGVwcyBvZiB0aGUgcGFzc2VkIHRyYW5zYWN0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzKFxuICBvbGREb2M6IFByb3NlTWlycm9yTm9kZSxcbiAgdHJhbnNhY3Rpb25zOiBUcmFuc2FjdGlvbltdLFxuKTogVHJhbnNmb3JtIHtcbiAgY29uc3QgdHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybShvbGREb2MpXG5cbiAgdHJhbnNhY3Rpb25zLmZvckVhY2godHJhbnNhY3Rpb24gPT4ge1xuICAgIHRyYW5zYWN0aW9uLnN0ZXBzLmZvckVhY2goc3RlcCA9PiB7XG4gICAgICB0cmFuc2Zvcm0uc3RlcChzdGVwKVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHRyYW5zZm9ybVxufVxuIiwgImltcG9ydCB7IENvbnRlbnRNYXRjaCwgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdEJsb2NrQXQobWF0Y2g6IENvbnRlbnRNYXRjaCk6IE5vZGVUeXBlIHwgbnVsbCB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2guZWRnZUNvdW50OyBpICs9IDEpIHtcbiAgICBjb25zdCB7IHR5cGUgfSA9IG1hdGNoLmVkZ2UoaSlcblxuICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkge1xuICAgICAgcmV0dXJuIHR5cGVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgTm9kZVdpdGhQb3MsIFByZWRpY2F0ZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZmluZENoaWxkcmVuKG5vZGU6IFByb3NlTWlycm9yTm9kZSwgcHJlZGljYXRlOiBQcmVkaWNhdGUpOiBOb2RlV2l0aFBvc1tdIHtcbiAgY29uc3Qgbm9kZXNXaXRoUG9zOiBOb2RlV2l0aFBvc1tdID0gW11cblxuICBub2RlLmRlc2NlbmRhbnRzKChjaGlsZCwgcG9zKSA9PiB7XG4gICAgaWYgKHByZWRpY2F0ZShjaGlsZCkpIHtcbiAgICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgIHBvcyxcbiAgICAgIH0pXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBub2Rlc1dpdGhQb3Ncbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IE5vZGVXaXRoUG9zLCBQcmVkaWNhdGUsIFJhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbi8qKlxuICogU2FtZSBhcyBgZmluZENoaWxkcmVuYCBidXQgc2VhcmNoZXMgb25seSB3aXRoaW4gYSBgcmFuZ2VgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZENoaWxkcmVuSW5SYW5nZShcbiAgbm9kZTogUHJvc2VNaXJyb3JOb2RlLFxuICByYW5nZTogUmFuZ2UsXG4gIHByZWRpY2F0ZTogUHJlZGljYXRlLFxuKTogTm9kZVdpdGhQb3NbXSB7XG4gIGNvbnN0IG5vZGVzV2l0aFBvczogTm9kZVdpdGhQb3NbXSA9IFtdXG5cbiAgLy8gaWYgKHJhbmdlLmZyb20gPT09IHJhbmdlLnRvKSB7XG4gIC8vICAgY29uc3Qgbm9kZUF0ID0gbm9kZS5ub2RlQXQocmFuZ2UuZnJvbSlcblxuICAvLyAgIGlmIChub2RlQXQpIHtcbiAgLy8gICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgLy8gICAgICAgbm9kZTogbm9kZUF0LFxuICAvLyAgICAgICBwb3M6IHJhbmdlLmZyb20sXG4gIC8vICAgICB9KVxuICAvLyAgIH1cbiAgLy8gfVxuXG4gIG5vZGUubm9kZXNCZXR3ZWVuKHJhbmdlLmZyb20sIHJhbmdlLnRvLCAoY2hpbGQsIHBvcykgPT4ge1xuICAgIGlmIChwcmVkaWNhdGUoY2hpbGQpKSB7XG4gICAgICBub2Rlc1dpdGhQb3MucHVzaCh7XG4gICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICBwb3MsXG4gICAgICB9KVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gbm9kZXNXaXRoUG9zXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUsIFJlc29sdmVkUG9zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgUHJlZGljYXRlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1BvcyhcbiAgJHBvczogUmVzb2x2ZWRQb3MsXG4gIHByZWRpY2F0ZTogUHJlZGljYXRlLFxuKTpcbiAgfCB7XG4gICAgICBwb3M6IG51bWJlclxuICAgICAgc3RhcnQ6IG51bWJlclxuICAgICAgZGVwdGg6IG51bWJlclxuICAgICAgbm9kZTogUHJvc2VNaXJyb3JOb2RlXG4gICAgfVxuICB8IHVuZGVmaW5lZCB7XG4gIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoOyBpID4gMDsgaSAtPSAxKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRwb3Mubm9kZShpKVxuXG4gICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9zOiBpID4gMCA/ICRwb3MuYmVmb3JlKGkpIDogMCxcbiAgICAgICAgc3RhcnQ6ICRwb3Muc3RhcnQoaSksXG4gICAgICAgIGRlcHRoOiBpLFxuICAgICAgICBub2RlLFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IFByZWRpY2F0ZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MgfSBmcm9tICcuL2ZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZmluZFBhcmVudE5vZGUocHJlZGljYXRlOiBQcmVkaWNhdGUpIHtcbiAgcmV0dXJuIChzZWxlY3Rpb246IFNlbGVjdGlvbikgPT4gZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3Moc2VsZWN0aW9uLiRmcm9tLCBwcmVkaWNhdGUpXG59XG4iLCAiaW1wb3J0IHsgRE9NU2VyaWFsaXplciwgRnJhZ21lbnQsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIVE1MRnJvbUZyYWdtZW50KGZyYWdtZW50OiBGcmFnbWVudCwgc2NoZW1hOiBTY2hlbWEpOiBzdHJpbmcge1xuICBjb25zdCBkb2N1bWVudEZyYWdtZW50ID0gRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHNjaGVtYSkuc2VyaWFsaXplRnJhZ21lbnQoZnJhZ21lbnQpXG5cbiAgY29uc3QgdGVtcG9yYXJ5RG9jdW1lbnQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoKVxuICBjb25zdCBjb250YWluZXIgPSB0ZW1wb3JhcnlEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudEZyYWdtZW50KVxuXG4gIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG59XG4iLCAiaW1wb3J0IHsgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgRXh0ZW5zaW9uTWFuYWdlciB9IGZyb20gJy4uL0V4dGVuc2lvbk1hbmFnZXIuanMnXG5pbXBvcnQgeyBFeHRlbnNpb25zIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyB9IGZyb20gJy4vZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2hlbWEoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucywgZWRpdG9yPzogRWRpdG9yKTogU2NoZW1hIHtcbiAgY29uc3QgcmVzb2x2ZWRFeHRlbnNpb25zID0gRXh0ZW5zaW9uTWFuYWdlci5yZXNvbHZlKGV4dGVuc2lvbnMpXG5cbiAgcmV0dXJuIGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zKHJlc29sdmVkRXh0ZW5zaW9ucywgZWRpdG9yKVxufVxuIiwgImltcG9ydCB7IE5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb25zLCBKU09OQ29udGVudCB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZ2V0SFRNTEZyb21GcmFnbWVudCB9IGZyb20gJy4vZ2V0SFRNTEZyb21GcmFnbWVudC5qcydcbmltcG9ydCB7IGdldFNjaGVtYSB9IGZyb20gJy4vZ2V0U2NoZW1hLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVIVE1MKGRvYzogSlNPTkNvbnRlbnQsIGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpOiBzdHJpbmcge1xuICBjb25zdCBzY2hlbWEgPSBnZXRTY2hlbWEoZXh0ZW5zaW9ucylcbiAgY29uc3QgY29udGVudE5vZGUgPSBOb2RlLmZyb21KU09OKHNjaGVtYSwgZG9jKVxuXG4gIHJldHVybiBnZXRIVE1MRnJvbUZyYWdtZW50KGNvbnRlbnROb2RlLmNvbnRlbnQsIHNjaGVtYSlcbn1cbiIsICJpbXBvcnQgeyBET01QYXJzZXIgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb25zIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBlbGVtZW50RnJvbVN0cmluZyB9IGZyb20gJy4uL3V0aWxpdGllcy9lbGVtZW50RnJvbVN0cmluZy5qcydcbmltcG9ydCB7IGdldFNjaGVtYSB9IGZyb20gJy4vZ2V0U2NoZW1hLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVKU09OKGh0bWw6IHN0cmluZywgZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCBzY2hlbWEgPSBnZXRTY2hlbWEoZXh0ZW5zaW9ucylcbiAgY29uc3QgZG9tID0gZWxlbWVudEZyb21TdHJpbmcoaHRtbClcblxuICByZXR1cm4gRE9NUGFyc2VyLmZyb21TY2hlbWEoc2NoZW1hKS5wYXJzZShkb20pLnRvSlNPTigpXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBUZXh0U2VyaWFsaXplciB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZ2V0VGV4dEJldHdlZW4gfSBmcm9tICcuL2dldFRleHRCZXR3ZWVuLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dChcbiAgbm9kZTogUHJvc2VNaXJyb3JOb2RlLFxuICBvcHRpb25zPzoge1xuICAgIGJsb2NrU2VwYXJhdG9yPzogc3RyaW5nXG4gICAgdGV4dFNlcmlhbGl6ZXJzPzogUmVjb3JkPHN0cmluZywgVGV4dFNlcmlhbGl6ZXI+XG4gIH0sXG4pIHtcbiAgY29uc3QgcmFuZ2UgPSB7XG4gICAgZnJvbTogMCxcbiAgICB0bzogbm9kZS5jb250ZW50LnNpemUsXG4gIH1cblxuICByZXR1cm4gZ2V0VGV4dEJldHdlZW4obm9kZSwgcmFuZ2UsIG9wdGlvbnMpXG59XG4iLCAiaW1wb3J0IHsgTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IEV4dGVuc2lvbnMsIEpTT05Db250ZW50LCBUZXh0U2VyaWFsaXplciB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hIH0gZnJvbSAnLi9nZXRTY2hlbWEuanMnXG5pbXBvcnQgeyBnZXRUZXh0IH0gZnJvbSAnLi9nZXRUZXh0LmpzJ1xuaW1wb3J0IHsgZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSB9IGZyb20gJy4vZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVGV4dChcbiAgZG9jOiBKU09OQ29udGVudCxcbiAgZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyxcbiAgb3B0aW9ucz86IHtcbiAgICBibG9ja1NlcGFyYXRvcj86IHN0cmluZ1xuICAgIHRleHRTZXJpYWxpemVycz86IFJlY29yZDxzdHJpbmcsIFRleHRTZXJpYWxpemVyPlxuICB9LFxuKTogc3RyaW5nIHtcbiAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9ICdcXG5cXG4nLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fVxuICBjb25zdCBzY2hlbWEgPSBnZXRTY2hlbWEoZXh0ZW5zaW9ucylcbiAgY29uc3QgY29udGVudE5vZGUgPSBOb2RlLmZyb21KU09OKHNjaGVtYSwgZG9jKVxuXG4gIHJldHVybiBnZXRUZXh0KGNvbnRlbnROb2RlLCB7XG4gICAgYmxvY2tTZXBhcmF0b3IsXG4gICAgdGV4dFNlcmlhbGl6ZXJzOiB7XG4gICAgICAuLi5nZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hKHNjaGVtYSksXG4gICAgICAuLi50ZXh0U2VyaWFsaXplcnMsXG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBOb2RlLCBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi9nZXROb2RlVHlwZS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVBdHRyaWJ1dGVzKFxuICBzdGF0ZTogRWRpdG9yU3RhdGUsXG4gIHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLFxuKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvblxuICBjb25zdCBub2RlczogTm9kZVtdID0gW11cblxuICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBub2RlID0+IHtcbiAgICBub2Rlcy5wdXNoKG5vZGUpXG4gIH0pXG5cbiAgY29uc3Qgbm9kZSA9IG5vZGVzLnJldmVyc2UoKS5maW5kKG5vZGVJdGVtID0+IG5vZGVJdGVtLnR5cGUubmFtZSA9PT0gdHlwZS5uYW1lKVxuXG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB7fVxuICB9XG5cbiAgcmV0dXJuIHsgLi4ubm9kZS5hdHRycyB9XG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgZ2V0TWFya0F0dHJpYnV0ZXMgfSBmcm9tICcuL2dldE1hcmtBdHRyaWJ1dGVzLmpzJ1xuaW1wb3J0IHsgZ2V0Tm9kZUF0dHJpYnV0ZXMgfSBmcm9tICcuL2dldE5vZGVBdHRyaWJ1dGVzLmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUgfSBmcm9tICcuL2dldFNjaGVtYVR5cGVOYW1lQnlOYW1lLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyhcbiAgc3RhdGU6IEVkaXRvclN0YXRlLFxuICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSB8IE1hcmtUeXBlLFxuKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShcbiAgICB0eXBlb2YgdHlwZU9yTmFtZSA9PT0gJ3N0cmluZycgPyB0eXBlT3JOYW1lIDogdHlwZU9yTmFtZS5uYW1lLFxuICAgIHN0YXRlLnNjaGVtYSxcbiAgKVxuXG4gIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcbiAgICByZXR1cm4gZ2V0Tm9kZUF0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUgYXMgTm9kZVR5cGUpXG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgcmV0dXJuIGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lIGFzIE1hcmtUeXBlKVxuICB9XG5cbiAgcmV0dXJuIHt9XG59XG4iLCAiLyoqXG4gKiBSZW1vdmVzIGR1cGxpY2F0ZWQgdmFsdWVzIHdpdGhpbiBhbiBhcnJheS5cbiAqIFN1cHBvcnRzIG51bWJlcnMsIHN0cmluZ3MgYW5kIG9iamVjdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVzPFQ+KGFycmF5OiBUW10sIGJ5ID0gSlNPTi5zdHJpbmdpZnkpOiBUW10ge1xuICBjb25zdCBzZWVuOiBSZWNvcmQ8YW55LCBhbnk+ID0ge31cblxuICByZXR1cm4gYXJyYXkuZmlsdGVyKGl0ZW0gPT4ge1xuICAgIGNvbnN0IGtleSA9IGJ5KGl0ZW0pXG5cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlZW4sIGtleSlcbiAgICAgID8gZmFsc2VcbiAgICAgIDogKHNlZW5ba2V5XSA9IHRydWUpXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgU3RlcCwgVHJhbnNmb3JtIH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyByZW1vdmVEdXBsaWNhdGVzIH0gZnJvbSAnLi4vdXRpbGl0aWVzL3JlbW92ZUR1cGxpY2F0ZXMuanMnXG5cbmV4cG9ydCB0eXBlIENoYW5nZWRSYW5nZSA9IHtcbiAgb2xkUmFuZ2U6IFJhbmdlLFxuICBuZXdSYW5nZTogUmFuZ2UsXG59XG5cbi8qKlxuICogUmVtb3ZlcyBkdXBsaWNhdGVkIHJhbmdlcyBhbmQgcmFuZ2VzIHRoYXQgYXJlXG4gKiBmdWxseSBjYXB0dXJlZCBieSBvdGhlciByYW5nZXMuXG4gKi9cbmZ1bmN0aW9uIHNpbXBsaWZ5Q2hhbmdlZFJhbmdlcyhjaGFuZ2VzOiBDaGFuZ2VkUmFuZ2VbXSk6IENoYW5nZWRSYW5nZVtdIHtcbiAgY29uc3QgdW5pcXVlQ2hhbmdlcyA9IHJlbW92ZUR1cGxpY2F0ZXMoY2hhbmdlcylcblxuICByZXR1cm4gdW5pcXVlQ2hhbmdlcy5sZW5ndGggPT09IDFcbiAgICA/IHVuaXF1ZUNoYW5nZXNcbiAgICA6IHVuaXF1ZUNoYW5nZXMuZmlsdGVyKChjaGFuZ2UsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCByZXN0ID0gdW5pcXVlQ2hhbmdlcy5maWx0ZXIoKF8sIGkpID0+IGkgIT09IGluZGV4KVxuXG4gICAgICByZXR1cm4gIXJlc3Quc29tZShvdGhlckNoYW5nZSA9PiB7XG4gICAgICAgIHJldHVybiBjaGFuZ2Uub2xkUmFuZ2UuZnJvbSA+PSBvdGhlckNoYW5nZS5vbGRSYW5nZS5mcm9tXG4gICAgICAgICAgJiYgY2hhbmdlLm9sZFJhbmdlLnRvIDw9IG90aGVyQ2hhbmdlLm9sZFJhbmdlLnRvXG4gICAgICAgICAgJiYgY2hhbmdlLm5ld1JhbmdlLmZyb20gPj0gb3RoZXJDaGFuZ2UubmV3UmFuZ2UuZnJvbVxuICAgICAgICAgICYmIGNoYW5nZS5uZXdSYW5nZS50byA8PSBvdGhlckNoYW5nZS5uZXdSYW5nZS50b1xuICAgICAgfSlcbiAgICB9KVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGNoYW5nZWQgcmFuZ2VzXG4gKiBiYXNlZCBvbiB0aGUgZmlyc3QgYW5kIGxhc3Qgc3RhdGUgb2YgYWxsIHN0ZXBzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hhbmdlZFJhbmdlcyh0cmFuc2Zvcm06IFRyYW5zZm9ybSk6IENoYW5nZWRSYW5nZVtdIHtcbiAgY29uc3QgeyBtYXBwaW5nLCBzdGVwcyB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IGNoYW5nZXM6IENoYW5nZWRSYW5nZVtdID0gW11cblxuICBtYXBwaW5nLm1hcHMuZm9yRWFjaCgoc3RlcE1hcCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCByYW5nZXM6IFJhbmdlW10gPSBbXVxuXG4gICAgLy8gVGhpcyBhY2NvdW50cyBmb3Igc3RlcCBjaGFuZ2VzIHdoZXJlIG5vIHJhbmdlIHdhcyBhY3R1YWxseSBhbHRlcmVkXG4gICAgLy8gZS5nLiB3aGVuIHNldHRpbmcgYSBtYXJrLCBub2RlIGF0dHJpYnV0ZSwgZXRjLlxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoIXN0ZXBNYXAucmFuZ2VzLmxlbmd0aCkge1xuICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gc3RlcHNbaW5kZXhdIGFzIFN0ZXAgJiB7XG4gICAgICAgIGZyb20/OiBudW1iZXIsXG4gICAgICAgIHRvPzogbnVtYmVyLFxuICAgICAgfVxuXG4gICAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkIHx8IHRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3RlcE1hcC5mb3JFYWNoKChmcm9tLCB0bykgPT4ge1xuICAgICAgICByYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJhbmdlcy5mb3JFYWNoKCh7IGZyb20sIHRvIH0pID0+IHtcbiAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gbWFwcGluZy5zbGljZShpbmRleCkubWFwKGZyb20sIC0xKVxuICAgICAgY29uc3QgbmV3RW5kID0gbWFwcGluZy5zbGljZShpbmRleCkubWFwKHRvKVxuICAgICAgY29uc3Qgb2xkU3RhcnQgPSBtYXBwaW5nLmludmVydCgpLm1hcChuZXdTdGFydCwgLTEpXG4gICAgICBjb25zdCBvbGRFbmQgPSBtYXBwaW5nLmludmVydCgpLm1hcChuZXdFbmQpXG5cbiAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgIG9sZFJhbmdlOiB7XG4gICAgICAgICAgZnJvbTogb2xkU3RhcnQsXG4gICAgICAgICAgdG86IG9sZEVuZCxcbiAgICAgICAgfSxcbiAgICAgICAgbmV3UmFuZ2U6IHtcbiAgICAgICAgICBmcm9tOiBuZXdTdGFydCxcbiAgICAgICAgICB0bzogbmV3RW5kLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9KVxuICB9KVxuXG4gIHJldHVybiBzaW1wbGlmeUNoYW5nZWRSYW5nZXMoY2hhbmdlcylcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IEpTT05Db250ZW50IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmludGVyZmFjZSBEZWJ1Z0pTT05Db250ZW50IGV4dGVuZHMgSlNPTkNvbnRlbnQge1xuICBmcm9tOiBudW1iZXJcbiAgdG86IG51bWJlclxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVidWdKU09OKG5vZGU6IFByb3NlTWlycm9yTm9kZSwgc3RhcnRPZmZzZXQgPSAwKTogRGVidWdKU09OQ29udGVudCB7XG4gIGNvbnN0IGlzVG9wTm9kZSA9IG5vZGUudHlwZSA9PT0gbm9kZS50eXBlLnNjaGVtYS50b3BOb2RlVHlwZVxuICBjb25zdCBpbmNyZW1lbnQgPSBpc1RvcE5vZGUgPyAwIDogMVxuICBjb25zdCBmcm9tID0gc3RhcnRPZmZzZXRcbiAgY29uc3QgdG8gPSBmcm9tICsgbm9kZS5ub2RlU2l6ZVxuICBjb25zdCBtYXJrcyA9IG5vZGUubWFya3MubWFwKG1hcmsgPT4ge1xuICAgIGNvbnN0IG91dHB1dDogeyB0eXBlOiBzdHJpbmc7IGF0dHJzPzogUmVjb3JkPHN0cmluZywgYW55PiB9ID0ge1xuICAgICAgdHlwZTogbWFyay50eXBlLm5hbWUsXG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKG1hcmsuYXR0cnMpLmxlbmd0aCkge1xuICAgICAgb3V0cHV0LmF0dHJzID0geyAuLi5tYXJrLmF0dHJzIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0XG4gIH0pXG4gIGNvbnN0IGF0dHJzID0geyAuLi5ub2RlLmF0dHJzIH1cbiAgY29uc3Qgb3V0cHV0OiBEZWJ1Z0pTT05Db250ZW50ID0ge1xuICAgIHR5cGU6IG5vZGUudHlwZS5uYW1lLFxuICAgIGZyb20sXG4gICAgdG8sXG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoYXR0cnMpLmxlbmd0aCkge1xuICAgIG91dHB1dC5hdHRycyA9IGF0dHJzXG4gIH1cblxuICBpZiAobWFya3MubGVuZ3RoKSB7XG4gICAgb3V0cHV0Lm1hcmtzID0gbWFya3NcbiAgfVxuXG4gIGlmIChub2RlLmNvbnRlbnQuY2hpbGRDb3VudCkge1xuICAgIG91dHB1dC5jb250ZW50ID0gW11cblxuICAgIG5vZGUuZm9yRWFjaCgoY2hpbGQsIG9mZnNldCkgPT4ge1xuICAgICAgb3V0cHV0LmNvbnRlbnQ/LnB1c2goZ2V0RGVidWdKU09OKGNoaWxkLCBzdGFydE9mZnNldCArIG9mZnNldCArIGluY3JlbWVudCkpXG4gICAgfSlcbiAgfVxuXG4gIGlmIChub2RlLnRleHQpIHtcbiAgICBvdXRwdXQudGV4dCA9IG5vZGUudGV4dFxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgTWFya1JhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRNYXJrUmFuZ2UgfSBmcm9tICcuL2dldE1hcmtSYW5nZS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmtzQmV0d2Vlbihmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIsIGRvYzogUHJvc2VNaXJyb3JOb2RlKTogTWFya1JhbmdlW10ge1xuICBjb25zdCBtYXJrczogTWFya1JhbmdlW10gPSBbXVxuXG4gIC8vIGdldCBhbGwgaW5jbHVzaXZlIG1hcmtzIG9uIGVtcHR5IHNlbGVjdGlvblxuICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICBkb2NcbiAgICAgIC5yZXNvbHZlKGZyb20pXG4gICAgICAubWFya3MoKVxuICAgICAgLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgIGNvbnN0ICRwb3MgPSBkb2MucmVzb2x2ZShmcm9tIC0gMSlcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRNYXJrUmFuZ2UoJHBvcywgbWFyay50eXBlKVxuXG4gICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgIG1hcmssXG4gICAgICAgICAgLi4ucmFuZ2UsXG4gICAgICAgIH0pXG4gICAgICB9KVxuICB9IGVsc2Uge1xuICAgIGRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgIG1hcmtzLnB1c2goXG4gICAgICAgIC4uLm5vZGUubWFya3MubWFwKG1hcmsgPT4gKHtcbiAgICAgICAgICBmcm9tOiBwb3MsXG4gICAgICAgICAgdG86IHBvcyArIG5vZGUubm9kZVNpemUsXG4gICAgICAgICAgbWFyayxcbiAgICAgICAgfSkpLFxuICAgICAgKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gbWFya3Ncbn1cbiIsICJpbXBvcnQgeyBOb2RlLCBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IG5vZGUgb2YgYSBnaXZlbiB0eXBlIG9yIG5hbWUgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICogQHBhcmFtIHN0YXRlIFRoZSBlZGl0b3Igc3RhdGUuXG4gKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgbm9kZSB0eXBlIG9yIG5hbWUuXG4gKiBAcGFyYW0gcG9zIFRoZSBwb3NpdGlvbiB0byBzdGFydCBzZWFyY2hpbmcgZnJvbS5cbiAqIEBwYXJhbSBtYXhEZXB0aCBUaGUgbWF4aW11bSBkZXB0aCB0byBzZWFyY2guXG4gKiBAcmV0dXJucyBUaGUgbm9kZSBhbmQgdGhlIGRlcHRoIGFzIGFuIGFycmF5LlxuICovXG5leHBvcnQgY29uc3QgZ2V0Tm9kZUF0UG9zaXRpb24gPSAoc3RhdGU6IEVkaXRvclN0YXRlLCB0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgcG9zOiBudW1iZXIsIG1heERlcHRoID0gMjApID0+IHtcbiAgY29uc3QgJHBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKHBvcylcblxuICBsZXQgY3VycmVudERlcHRoID0gbWF4RGVwdGhcbiAgbGV0IG5vZGU6IE5vZGUgfCBudWxsID0gbnVsbFxuXG4gIHdoaWxlIChjdXJyZW50RGVwdGggPiAwICYmIG5vZGUgPT09IG51bGwpIHtcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9ICRwb3Mubm9kZShjdXJyZW50RGVwdGgpXG5cbiAgICBpZiAoY3VycmVudE5vZGU/LnR5cGUubmFtZSA9PT0gdHlwZU9yTmFtZSkge1xuICAgICAgbm9kZSA9IGN1cnJlbnROb2RlXG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnREZXB0aCAtPSAxXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtub2RlLCBjdXJyZW50RGVwdGhdIGFzIFtOb2RlIHwgbnVsbCwgbnVtYmVyXVxufVxuIiwgImltcG9ydCB7IEV4dGVuc2lvbkF0dHJpYnV0ZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKFxuICBleHRlbnNpb25BdHRyaWJ1dGVzOiBFeHRlbnNpb25BdHRyaWJ1dGVbXSxcbiAgdHlwZU5hbWU6IHN0cmluZyxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdFxuICAgIC5lbnRyaWVzKGF0dHJpYnV0ZXMpXG4gICAgLmZpbHRlcigoW25hbWVdKSA9PiB7XG4gICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGUgPSBleHRlbnNpb25BdHRyaWJ1dGVzLmZpbmQoaXRlbSA9PiB7XG4gICAgICAgIHJldHVybiBpdGVtLnR5cGUgPT09IHR5cGVOYW1lICYmIGl0ZW0ubmFtZSA9PT0gbmFtZVxuICAgICAgfSlcblxuICAgICAgaWYgKCFleHRlbnNpb25BdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGUuYXR0cmlidXRlLmtlZXBPblNwbGl0XG4gICAgfSkpXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBNYXJrUmFuZ2UgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG9iamVjdEluY2x1ZGVzIH0gZnJvbSAnLi4vdXRpbGl0aWVzL29iamVjdEluY2x1ZGVzLmpzJ1xuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuL2dldE1hcmtUeXBlLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNNYXJrQWN0aXZlKFxuICBzdGF0ZTogRWRpdG9yU3RhdGUsXG4gIHR5cGVPck5hbWU6IE1hcmtUeXBlIHwgc3RyaW5nIHwgbnVsbCxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uXG4gIGNvbnN0IHR5cGUgPSB0eXBlT3JOYW1lID8gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKSA6IG51bGxcblxuICBpZiAoZW1wdHkpIHtcbiAgICByZXR1cm4gISEoc3RhdGUuc3RvcmVkTWFya3MgfHwgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpXG4gICAgICAuZmlsdGVyKG1hcmsgPT4ge1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gbWFyay50eXBlLm5hbWVcbiAgICAgIH0pXG4gICAgICAuZmluZChtYXJrID0+IG9iamVjdEluY2x1ZGVzKG1hcmsuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSlcbiAgfVxuXG4gIGxldCBzZWxlY3Rpb25SYW5nZSA9IDBcbiAgY29uc3QgbWFya1JhbmdlczogTWFya1JhbmdlW10gPSBbXVxuXG4gIHJhbmdlcy5mb3JFYWNoKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgIGNvbnN0IGZyb20gPSAkZnJvbS5wb3NcbiAgICBjb25zdCB0byA9ICR0by5wb3NcblxuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgIGlmICghbm9kZS5pc1RleHQgJiYgIW5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCByZWxhdGl2ZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpXG4gICAgICBjb25zdCByZWxhdGl2ZVRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUubm9kZVNpemUpXG4gICAgICBjb25zdCByYW5nZSA9IHJlbGF0aXZlVG8gLSByZWxhdGl2ZUZyb21cblxuICAgICAgc2VsZWN0aW9uUmFuZ2UgKz0gcmFuZ2VcblxuICAgICAgbWFya1Jhbmdlcy5wdXNoKFxuICAgICAgICAuLi5ub2RlLm1hcmtzLm1hcChtYXJrID0+ICh7XG4gICAgICAgICAgbWFyayxcbiAgICAgICAgICBmcm9tOiByZWxhdGl2ZUZyb20sXG4gICAgICAgICAgdG86IHJlbGF0aXZlVG8sXG4gICAgICAgIH0pKSxcbiAgICAgIClcbiAgICB9KVxuICB9KVxuXG4gIGlmIChzZWxlY3Rpb25SYW5nZSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gY2FsY3VsYXRlIHJhbmdlIG9mIG1hdGNoZWQgbWFya1xuICBjb25zdCBtYXRjaGVkUmFuZ2UgPSBtYXJrUmFuZ2VzXG4gICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4ge1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09IG1hcmtSYW5nZS5tYXJrLnR5cGUubmFtZVxuICAgIH0pXG4gICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4gb2JqZWN0SW5jbHVkZXMobWFya1JhbmdlLm1hcmsuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSlcbiAgICAucmVkdWNlKChzdW0sIG1hcmtSYW5nZSkgPT4gc3VtICsgbWFya1JhbmdlLnRvIC0gbWFya1JhbmdlLmZyb20sIDApXG5cbiAgLy8gY2FsY3VsYXRlIHJhbmdlIG9mIG1hcmtzIHRoYXQgZXhjbHVkZXMgdGhlIHNlYXJjaGVkIG1hcmtcbiAgLy8gZm9yIGV4YW1wbGUgYGNvZGVgIGRvZXNu4oCZdCBhbGxvdyBhbnkgb3RoZXIgbWFya3NcbiAgY29uc3QgZXhjbHVkZWRSYW5nZSA9IG1hcmtSYW5nZXNcbiAgICAuZmlsdGVyKG1hcmtSYW5nZSA9PiB7XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcmtSYW5nZS5tYXJrLnR5cGUgIT09IHR5cGUgJiYgbWFya1JhbmdlLm1hcmsudHlwZS5leGNsdWRlcyh0eXBlKVxuICAgIH0pXG4gICAgLnJlZHVjZSgoc3VtLCBtYXJrUmFuZ2UpID0+IHN1bSArIG1hcmtSYW5nZS50byAtIG1hcmtSYW5nZS5mcm9tLCAwKVxuXG4gIC8vIHdlIG9ubHkgaW5jbHVkZSB0aGUgcmVzdWx0IG9mIGBleGNsdWRlZFJhbmdlYFxuICAvLyBpZiB0aGVyZSBpcyBhIG1hdGNoIGF0IGFsbFxuICBjb25zdCByYW5nZSA9IG1hdGNoZWRSYW5nZSA+IDAgPyBtYXRjaGVkUmFuZ2UgKyBleGNsdWRlZFJhbmdlIDogbWF0Y2hlZFJhbmdlXG5cbiAgcmV0dXJuIHJhbmdlID49IHNlbGVjdGlvblJhbmdlXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSB9IGZyb20gJy4vZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUuanMnXG5pbXBvcnQgeyBpc01hcmtBY3RpdmUgfSBmcm9tICcuL2lzTWFya0FjdGl2ZS5qcydcbmltcG9ydCB7IGlzTm9kZUFjdGl2ZSB9IGZyb20gJy4vaXNOb2RlQWN0aXZlLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNBY3RpdmUoXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZSxcbiAgbmFtZTogc3RyaW5nIHwgbnVsbCxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogYm9vbGVhbiB7XG4gIGlmICghbmFtZSkge1xuICAgIHJldHVybiBpc05vZGVBY3RpdmUoc3RhdGUsIG51bGwsIGF0dHJpYnV0ZXMpIHx8IGlzTWFya0FjdGl2ZShzdGF0ZSwgbnVsbCwgYXR0cmlidXRlcylcbiAgfVxuXG4gIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShuYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09ICdub2RlJykge1xuICAgIHJldHVybiBpc05vZGVBY3RpdmUoc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMpXG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgcmV0dXJuIGlzTWFya0FjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcylcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwgImltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgZmluZFBhcmVudE5vZGUgfSBmcm9tICcuL2ZpbmRQYXJlbnROb2RlLmpzJ1xuXG5leHBvcnQgY29uc3QgaXNBdEVuZE9mTm9kZSA9IChzdGF0ZTogRWRpdG9yU3RhdGUsIG5vZGVUeXBlPzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHsgJGZyb20sICR0bywgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uXG5cbiAgaWYgKG5vZGVUeXBlKSB7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gbm9kZS50eXBlLm5hbWUgPT09IG5vZGVUeXBlKShzdGF0ZS5zZWxlY3Rpb24pXG5cbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0ICRwYXJlbnRQb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwYXJlbnROb2RlLnBvcyArIDEpXG5cbiAgICBpZiAoJGFuY2hvci5wb3MgKyAxID09PSAkcGFyZW50UG9zLmVuZCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKCR0by5wYXJlbnRPZmZzZXQgPCAkdG8ucGFyZW50Lm5vZGVTaXplIC0gMiB8fCAkZnJvbS5wb3MgIT09ICR0by5wb3MpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5leHBvcnQgY29uc3QgaXNBdFN0YXJ0T2ZOb2RlID0gKHN0YXRlOiBFZGl0b3JTdGF0ZSkgPT4ge1xuICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvblxuXG4gIGlmICgkZnJvbS5wYXJlbnRPZmZzZXQgPiAwIHx8ICRmcm9tLnBvcyAhPT0gJHRvLnBvcykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBOb2RlQ29uZmlnIH0gZnJvbSAnLi4vaW5kZXguanMnXG5pbXBvcnQgeyBFeHRlbnNpb25zIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuaW1wb3J0IHsgc3BsaXRFeHRlbnNpb25zIH0gZnJvbSAnLi9zcGxpdEV4dGVuc2lvbnMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xpc3QobmFtZTogc3RyaW5nLCBleHRlbnNpb25zOiBFeHRlbnNpb25zKTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgbm9kZUV4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKVxuICBjb25zdCBleHRlbnNpb24gPSBub2RlRXh0ZW5zaW9ucy5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lID09PSBuYW1lKVxuXG4gIGlmICghZXh0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICB9XG4gIGNvbnN0IGdyb3VwID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2dyb3VwJ10+KGV4dGVuc2lvbiwgJ2dyb3VwJywgY29udGV4dCkpXG5cbiAgaWYgKHR5cGVvZiBncm91cCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBncm91cC5zcGxpdCgnICcpLmluY2x1ZGVzKCdsaXN0Jylcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVFbXB0eShub2RlOiBQcm9zZU1pcnJvck5vZGUpOiBib29sZWFuIHtcbiAgY29uc3QgZGVmYXVsdENvbnRlbnQgPSBub2RlLnR5cGUuY3JlYXRlQW5kRmlsbCgpPy50b0pTT04oKVxuICBjb25zdCBjb250ZW50ID0gbm9kZS50b0pTT04oKVxuXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShkZWZhdWx0Q29udGVudCkgPT09IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpXG59XG4iLCAiaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVTZWxlY3Rpb24odmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBOb2RlU2VsZWN0aW9uIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvblxufVxuIiwgImltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnXG5cbmltcG9ydCB7IG1pbk1heCB9IGZyb20gJy4uL3V0aWxpdGllcy9taW5NYXguanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBwb3NUb0RPTVJlY3QodmlldzogRWRpdG9yVmlldywgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyKTogRE9NUmVjdCB7XG4gIGNvbnN0IG1pblBvcyA9IDBcbiAgY29uc3QgbWF4UG9zID0gdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplXG4gIGNvbnN0IHJlc29sdmVkRnJvbSA9IG1pbk1heChmcm9tLCBtaW5Qb3MsIG1heFBvcylcbiAgY29uc3QgcmVzb2x2ZWRFbmQgPSBtaW5NYXgodG8sIG1pblBvcywgbWF4UG9zKVxuICBjb25zdCBzdGFydCA9IHZpZXcuY29vcmRzQXRQb3MocmVzb2x2ZWRGcm9tKVxuICBjb25zdCBlbmQgPSB2aWV3LmNvb3Jkc0F0UG9zKHJlc29sdmVkRW5kLCAtMSlcbiAgY29uc3QgdG9wID0gTWF0aC5taW4oc3RhcnQudG9wLCBlbmQudG9wKVxuICBjb25zdCBib3R0b20gPSBNYXRoLm1heChzdGFydC5ib3R0b20sIGVuZC5ib3R0b20pXG4gIGNvbnN0IGxlZnQgPSBNYXRoLm1pbihzdGFydC5sZWZ0LCBlbmQubGVmdClcbiAgY29uc3QgcmlnaHQgPSBNYXRoLm1heChzdGFydC5yaWdodCwgZW5kLnJpZ2h0KVxuICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdFxuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3BcbiAgY29uc3QgeCA9IGxlZnRcbiAgY29uc3QgeSA9IHRvcFxuICBjb25zdCBkYXRhID0ge1xuICAgIHRvcCxcbiAgICBib3R0b20sXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5LFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIHRvSlNPTjogKCkgPT4gZGF0YSxcbiAgfVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlLCBSZXNvbHZlZFBvcyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSwgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXRNYXJrQXR0cmlidXRlcyB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya0F0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBpc1RleHRTZWxlY3Rpb24gfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNldE1hcms6IHtcbiAgICAgIC8qKlxuICAgICAgICogQWRkIGEgbWFyayB3aXRoIG5ldyBhdHRyaWJ1dGVzLlxuICAgICAgICovXG4gICAgICBzZXRNYXJrOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTWFya1R5cGUsIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhblNldE1hcmsoc3RhdGU6IEVkaXRvclN0YXRlLCB0cjogVHJhbnNhY3Rpb24sIG5ld01hcmtUeXBlOiBNYXJrVHlwZSkge1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHJcbiAgbGV0IGN1cnNvcjogUmVzb2x2ZWRQb3MgfCBudWxsID0gbnVsbFxuXG4gIGlmIChpc1RleHRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGN1cnNvciA9IHNlbGVjdGlvbi4kY3Vyc29yXG4gIH1cblxuICBpZiAoY3Vyc29yKSB7XG4gICAgY29uc3QgY3VycmVudE1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3MgPz8gY3Vyc29yLm1hcmtzKClcblxuICAgIC8vIFRoZXJlIGNhbiBiZSBubyBjdXJyZW50IG1hcmtzIHRoYXQgZXhjbHVkZSB0aGUgbmV3IG1hcmtcbiAgICByZXR1cm4gKFxuICAgICAgISFuZXdNYXJrVHlwZS5pc0luU2V0KGN1cnJlbnRNYXJrcylcbiAgICAgIHx8ICFjdXJyZW50TWFya3Muc29tZShtYXJrID0+IG1hcmsudHlwZS5leGNsdWRlcyhuZXdNYXJrVHlwZSkpXG4gICAgKVxuICB9XG5cbiAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvblxuXG4gIHJldHVybiByYW5nZXMuc29tZSgoeyAkZnJvbSwgJHRvIH0pID0+IHtcbiAgICBsZXQgc29tZU5vZGVTdXBwb3J0c01hcmsgPSAkZnJvbS5kZXB0aCA9PT0gMFxuICAgICAgPyBzdGF0ZS5kb2MuaW5saW5lQ29udGVudCAmJiBzdGF0ZS5kb2MudHlwZS5hbGxvd3NNYXJrVHlwZShuZXdNYXJrVHlwZSlcbiAgICAgIDogZmFsc2VcblxuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgX3BvcywgcGFyZW50KSA9PiB7XG4gICAgICAvLyBJZiB3ZSBhbHJlYWR5IGZvdW5kIGEgbWFyayB0aGF0IHdlIGNhbiBlbmFibGUsIHJldHVybiBmYWxzZSB0byBieXBhc3MgdGhlIHJlbWFpbmluZyBzZWFyY2hcbiAgICAgIGlmIChzb21lTm9kZVN1cHBvcnRzTWFyaykge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuaXNJbmxpbmUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50QWxsb3dzTWFya1R5cGUgPSAhcGFyZW50IHx8IHBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG5ld01hcmtUeXBlKVxuICAgICAgICBjb25zdCBjdXJyZW50TWFya3NBbGxvd01hcmtUeXBlID0gISFuZXdNYXJrVHlwZS5pc0luU2V0KG5vZGUubWFya3MpXG4gICAgICAgICAgfHwgIW5vZGUubWFya3Muc29tZShvdGhlck1hcmsgPT4gb3RoZXJNYXJrLnR5cGUuZXhjbHVkZXMobmV3TWFya1R5cGUpKVxuXG4gICAgICAgIHNvbWVOb2RlU3VwcG9ydHNNYXJrID0gcGFyZW50QWxsb3dzTWFya1R5cGUgJiYgY3VycmVudE1hcmtzQWxsb3dNYXJrVHlwZVxuICAgICAgfVxuICAgICAgcmV0dXJuICFzb21lTm9kZVN1cHBvcnRzTWFya1xuICAgIH0pXG5cbiAgICByZXR1cm4gc29tZU5vZGVTdXBwb3J0c01hcmtcbiAgfSlcbn1cbmV4cG9ydCBjb25zdCBzZXRNYXJrOiBSYXdDb21tYW5kc1snc2V0TWFyayddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0clxuICBjb25zdCB7IGVtcHR5LCByYW5nZXMgfSA9IHNlbGVjdGlvblxuICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGlmIChlbXB0eSkge1xuICAgICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlKVxuXG4gICAgICB0ci5hZGRTdG9yZWRNYXJrKFxuICAgICAgICB0eXBlLmNyZWF0ZSh7XG4gICAgICAgICAgLi4ub2xkQXR0cmlidXRlcyxcbiAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICBjb25zdCBmcm9tID0gcmFuZ2UuJGZyb20ucG9zXG4gICAgICAgIGNvbnN0IHRvID0gcmFuZ2UuJHRvLnBvc1xuXG4gICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICBjb25zdCB0cmltbWVkRnJvbSA9IE1hdGgubWF4KHBvcywgZnJvbSlcbiAgICAgICAgICBjb25zdCB0cmltbWVkVG8gPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0bylcbiAgICAgICAgICBjb25zdCBzb21lSGFzTWFyayA9IG5vZGUubWFya3MuZmluZChtYXJrID0+IG1hcmsudHlwZSA9PT0gdHlwZSlcblxuICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBtYXJrIG9mIHRoaXMgdHlwZVxuICAgICAgICAgIC8vIHdlIGtub3cgdGhhdCB3ZSBoYXZlIHRvIG1lcmdlIGl0cyBhdHRyaWJ1dGVzXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGFkZCBhIGZyZXNoIG5ldyBtYXJrXG4gICAgICAgICAgaWYgKHNvbWVIYXNNYXJrKSB7XG4gICAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgICAgICAgIGlmICh0eXBlID09PSBtYXJrLnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKFxuICAgICAgICAgICAgICAgICAgdHJpbW1lZEZyb20sXG4gICAgICAgICAgICAgICAgICB0cmltbWVkVG8sXG4gICAgICAgICAgICAgICAgICB0eXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyLmFkZE1hcmsodHJpbW1lZEZyb20sIHRyaW1tZWRUbywgdHlwZS5jcmVhdGUoYXR0cmlidXRlcykpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FuU2V0TWFyayhzdGF0ZSwgdHIsIHR5cGUpXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNldE1ldGE6IHtcbiAgICAgIC8qKlxuICAgICAgICogU3RvcmUgYSBtZXRhZGF0YSBwcm9wZXJ0eSBpbiB0aGUgY3VycmVudCB0cmFuc2FjdGlvbi5cbiAgICAgICAqL1xuICAgICAgc2V0TWV0YTogKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2V0TWV0YTogUmF3Q29tbWFuZHNbJ3NldE1ldGEnXSA9IChrZXksIHZhbHVlKSA9PiAoeyB0ciB9KSA9PiB7XG4gIHRyLnNldE1ldGEoa2V5LCB2YWx1ZSlcblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IHNldEJsb2NrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5pbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZXROb2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlcGxhY2UgYSBnaXZlbiByYW5nZSB3aXRoIGEgbm9kZS5cbiAgICAgICAqL1xuICAgICAgc2V0Tm9kZTogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2V0Tm9kZTogUmF3Q29tbWFuZHNbJ3NldE5vZGUnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCwgY2hhaW4gfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIC8vIFRPRE86IHVzZSBhIGZhbGxiYWNrIGxpa2UgaW5zZXJ0Q29udGVudD9cbiAgaWYgKCF0eXBlLmlzVGV4dGJsb2NrKSB7XG4gICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBDdXJyZW50bHkgXCJzZXROb2RlKClcIiBvbmx5IHN1cHBvcnRzIHRleHQgYmxvY2sgbm9kZXMuJylcblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICBjaGFpbigpXG4gICAgLy8gdHJ5IHRvIGNvbnZlcnQgbm9kZSB0byBkZWZhdWx0IG5vZGUgaWYgbmVlZGVkXG4gICAgICAuY29tbWFuZCgoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhblNldEJsb2NrID0gc2V0QmxvY2tUeXBlKHR5cGUsIGF0dHJpYnV0ZXMpKHN0YXRlKVxuXG4gICAgICAgIGlmIChjYW5TZXRCbG9jaykge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpXG4gICAgICB9KVxuICAgICAgLmNvbW1hbmQoKHsgc3RhdGU6IHVwZGF0ZWRTdGF0ZSB9KSA9PiB7XG4gICAgICAgIHJldHVybiBzZXRCbG9ja1R5cGUodHlwZSwgYXR0cmlidXRlcykodXBkYXRlZFN0YXRlLCBkaXNwYXRjaClcbiAgICAgIH0pXG4gICAgICAucnVuKClcbiAgKVxufVxuIiwgImltcG9ydCB7IE5vZGVTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgbWluTWF4IH0gZnJvbSAnLi4vdXRpbGl0aWVzL21pbk1heC5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNldE5vZGVTZWxlY3Rpb246IHtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIE5vZGVTZWxlY3Rpb24uXG4gICAgICAgKi9cbiAgICAgIHNldE5vZGVTZWxlY3Rpb246IChwb3NpdGlvbjogbnVtYmVyKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZXROb2RlU2VsZWN0aW9uOiBSYXdDb21tYW5kc1snc2V0Tm9kZVNlbGVjdGlvbiddID0gcG9zaXRpb24gPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgeyBkb2MgfSA9IHRyXG4gICAgY29uc3QgZnJvbSA9IG1pbk1heChwb3NpdGlvbiwgMCwgZG9jLmNvbnRlbnQuc2l6ZSlcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIGZyb20pXG5cbiAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgUmFuZ2UsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBtaW5NYXggfSBmcm9tICcuLi91dGlsaXRpZXMvbWluTWF4LmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2V0VGV4dFNlbGVjdGlvbjoge1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgVGV4dFNlbGVjdGlvbi5cbiAgICAgICAqL1xuICAgICAgc2V0VGV4dFNlbGVjdGlvbjogKHBvc2l0aW9uOiBudW1iZXIgfCBSYW5nZSkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2V0VGV4dFNlbGVjdGlvbjogUmF3Q29tbWFuZHNbJ3NldFRleHRTZWxlY3Rpb24nXSA9IHBvc2l0aW9uID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHsgZG9jIH0gPSB0clxuICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHR5cGVvZiBwb3NpdGlvbiA9PT0gJ251bWJlcicgPyB7IGZyb206IHBvc2l0aW9uLCB0bzogcG9zaXRpb24gfSA6IHBvc2l0aW9uXG4gICAgY29uc3QgbWluUG9zID0gVGV4dFNlbGVjdGlvbi5hdFN0YXJ0KGRvYykuZnJvbVxuICAgIGNvbnN0IG1heFBvcyA9IFRleHRTZWxlY3Rpb24uYXRFbmQoZG9jKS50b1xuICAgIGNvbnN0IHJlc29sdmVkRnJvbSA9IG1pbk1heChmcm9tLCBtaW5Qb3MsIG1heFBvcylcbiAgICBjb25zdCByZXNvbHZlZEVuZCA9IG1pbk1heCh0bywgbWluUG9zLCBtYXhQb3MpXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCByZXNvbHZlZEZyb20sIHJlc29sdmVkRW5kKVxuXG4gICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbilcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgc2lua0xpc3RJdGVtIGFzIG9yaWdpbmFsU2lua0xpc3RJdGVtIH0gZnJvbSAnQHRpcHRhcC9wbS9zY2hlbWEtbGlzdCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNpbmtMaXN0SXRlbToge1xuICAgICAgLyoqXG4gICAgICAgKiBTaW5rIHRoZSBsaXN0IGl0ZW0gZG93biBpbnRvIGFuIGlubmVyIGxpc3QuXG4gICAgICAgKi9cbiAgICAgIHNpbmtMaXN0SXRlbTogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzaW5rTGlzdEl0ZW06IFJhd0NvbW1hbmRzWydzaW5rTGlzdEl0ZW0nXSA9IHR5cGVPck5hbWUgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcblxuICByZXR1cm4gb3JpZ2luYWxTaW5rTGlzdEl0ZW0odHlwZSkoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IEVkaXRvclN0YXRlLCBOb2RlU2VsZWN0aW9uLCBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IGNhblNwbGl0IH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IGRlZmF1bHRCbG9ja0F0IH0gZnJvbSAnLi4vaGVscGVycy9kZWZhdWx0QmxvY2tBdC5qcydcbmltcG9ydCB7IGdldFNwbGl0dGVkQXR0cmlidXRlcyB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZnVuY3Rpb24gZW5zdXJlTWFya3Moc3RhdGU6IEVkaXRvclN0YXRlLCBzcGxpdHRhYmxlTWFya3M/OiBzdHJpbmdbXSkge1xuICBjb25zdCBtYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzIHx8IChzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSlcblxuICBpZiAobWFya3MpIHtcbiAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzPy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpXG5cbiAgICBzdGF0ZS50ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKVxuICB9XG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzcGxpdEJsb2NrOiB7XG4gICAgICAvKipcbiAgICAgICAqIEZvcmtzIGEgbmV3IG5vZGUgZnJvbSBhbiBleGlzdGluZyBub2RlLlxuICAgICAgICovXG4gICAgICBzcGxpdEJsb2NrOiAob3B0aW9ucz86IHsga2VlcE1hcmtzPzogYm9vbGVhbiB9KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzcGxpdEJsb2NrOiBSYXdDb21tYW5kc1snc3BsaXRCbG9jayddID0gKHsga2VlcE1hcmtzID0gdHJ1ZSB9ID0ge30pID0+ICh7XG4gIHRyLCBzdGF0ZSwgZGlzcGF0Y2gsIGVkaXRvcixcbn0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gdHJcbiAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzZWxlY3Rpb25cbiAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmF0dHJpYnV0ZXNcbiAgY29uc3QgbmV3QXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhcbiAgICBleHRlbnNpb25BdHRyaWJ1dGVzLFxuICAgICRmcm9tLm5vZGUoKS50eXBlLm5hbWUsXG4gICAgJGZyb20ubm9kZSgpLmF0dHJzLFxuICApXG5cbiAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc2VsZWN0aW9uLm5vZGUuaXNCbG9jaykge1xuICAgIGlmICghJGZyb20ucGFyZW50T2Zmc2V0IHx8ICFjYW5TcGxpdChkb2MsICRmcm9tLnBvcykpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgaWYgKGtlZXBNYXJrcykge1xuICAgICAgICBlbnN1cmVNYXJrcyhzdGF0ZSwgZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuc3BsaXR0YWJsZU1hcmtzKVxuICAgICAgfVxuXG4gICAgICB0ci5zcGxpdCgkZnJvbS5wb3MpLnNjcm9sbEludG9WaWV3KClcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKCEkZnJvbS5wYXJlbnQuaXNCbG9jaykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgYXRFbmQgPSAkdG8ucGFyZW50T2Zmc2V0ID09PSAkdG8ucGFyZW50LmNvbnRlbnQuc2l6ZVxuXG4gICAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICAgIHRyLmRlbGV0ZVNlbGVjdGlvbigpXG4gICAgfVxuXG4gICAgY29uc3QgZGVmbHQgPSAkZnJvbS5kZXB0aCA9PT0gMFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogZGVmYXVsdEJsb2NrQXQoJGZyb20ubm9kZSgtMSkuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcigtMSkpKVxuXG4gICAgbGV0IHR5cGVzID0gYXRFbmQgJiYgZGVmbHRcbiAgICAgID8gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogZGVmbHQsXG4gICAgICAgICAgYXR0cnM6IG5ld0F0dHJpYnV0ZXMsXG4gICAgICAgIH0sXG4gICAgICBdXG4gICAgICA6IHVuZGVmaW5lZFxuXG4gICAgbGV0IGNhbiA9IGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpXG5cbiAgICBpZiAoXG4gICAgICAhdHlwZXNcbiAgICAgICAgJiYgIWNhblxuICAgICAgICAmJiBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIGRlZmx0ID8gW3sgdHlwZTogZGVmbHQgfV0gOiB1bmRlZmluZWQpXG4gICAgKSB7XG4gICAgICBjYW4gPSB0cnVlXG4gICAgICB0eXBlcyA9IGRlZmx0XG4gICAgICAgID8gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IGRlZmx0LFxuICAgICAgICAgICAgYXR0cnM6IG5ld0F0dHJpYnV0ZXMsXG4gICAgICAgICAgfSxcbiAgICAgICAgXVxuICAgICAgICA6IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmIChjYW4pIHtcbiAgICAgIHRyLnNwbGl0KHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKVxuXG4gICAgICBpZiAoZGVmbHQgJiYgIWF0RW5kICYmICEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJGZyb20ucGFyZW50LnR5cGUgIT09IGRlZmx0KSB7XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gdHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpXG4gICAgICAgIGNvbnN0ICRmaXJzdCA9IHRyLmRvYy5yZXNvbHZlKGZpcnN0KVxuXG4gICAgICAgIGlmICgkZnJvbS5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkZmlyc3QuaW5kZXgoKSwgJGZpcnN0LmluZGV4KCkgKyAxLCBkZWZsdCkpIHtcbiAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKSwgZGVmbHQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2VlcE1hcmtzKSB7XG4gICAgICBlbnN1cmVNYXJrcyhzdGF0ZSwgZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuc3BsaXR0YWJsZU1hcmtzKVxuICAgIH1cblxuICAgIHRyLnNjcm9sbEludG9WaWV3KClcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHtcbiAgRnJhZ21lbnQsIE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLCBOb2RlVHlwZSwgU2xpY2UsXG59IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IGNhblNwbGl0IH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGdldFNwbGl0dGVkQXR0cmlidXRlcyB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNwbGl0TGlzdEl0ZW06IHtcbiAgICAgIC8qKlxuICAgICAgICogU3BsaXRzIG9uZSBsaXN0IGl0ZW0gaW50byB0d28gbGlzdCBpdGVtcy5cbiAgICAgICAqL1xuICAgICAgc3BsaXRMaXN0SXRlbTogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzcGxpdExpc3RJdGVtOiBSYXdDb21tYW5kc1snc3BsaXRMaXN0SXRlbSddID0gdHlwZU9yTmFtZSA9PiAoe1xuICB0ciwgc3RhdGUsIGRpc3BhdGNoLCBlZGl0b3IsXG59KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uXG5cbiAgLy8gQHRzLWlnbm9yZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBjb25zdCBub2RlOiBQcm9zZU1pcnJvck5vZGUgPSBzdGF0ZS5zZWxlY3Rpb24ubm9kZVxuXG4gIGlmICgobm9kZSAmJiBub2RlLmlzQmxvY2spIHx8ICRmcm9tLmRlcHRoIDwgMiB8fCAhJGZyb20uc2FtZVBhcmVudCgkdG8pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBncmFuZFBhcmVudCA9ICRmcm9tLm5vZGUoLTEpXG5cbiAgaWYgKGdyYW5kUGFyZW50LnR5cGUgIT09IHR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5hdHRyaWJ1dGVzXG5cbiAgaWYgKCRmcm9tLnBhcmVudC5jb250ZW50LnNpemUgPT09IDAgJiYgJGZyb20ubm9kZSgtMSkuY2hpbGRDb3VudCA9PT0gJGZyb20uaW5kZXhBZnRlcigtMSkpIHtcbiAgICAvLyBJbiBhbiBlbXB0eSBibG9jay4gSWYgdGhpcyBpcyBhIG5lc3RlZCBsaXN0LCB0aGUgd3JhcHBpbmdcbiAgICAvLyBsaXN0IGl0ZW0gc2hvdWxkIGJlIHNwbGl0LiBPdGhlcndpc2UsIGJhaWwgb3V0IGFuZCBsZXQgbmV4dFxuICAgIC8vIGNvbW1hbmQgaGFuZGxlIGxpZnRpbmcuXG4gICAgaWYgKFxuICAgICAgJGZyb20uZGVwdGggPT09IDJcbiAgICAgICAgfHwgJGZyb20ubm9kZSgtMykudHlwZSAhPT0gdHlwZVxuICAgICAgICB8fCAkZnJvbS5pbmRleCgtMikgIT09ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgLSAxXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGxldCB3cmFwID0gRnJhZ21lbnQuZW1wdHlcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBjb25zdCBkZXB0aEJlZm9yZSA9ICRmcm9tLmluZGV4KC0xKSA/IDEgOiAkZnJvbS5pbmRleCgtMikgPyAyIDogM1xuXG4gICAgICAvLyBCdWlsZCBhIGZyYWdtZW50IGNvbnRhaW5pbmcgZW1wdHkgdmVyc2lvbnMgb2YgdGhlIHN0cnVjdHVyZVxuICAgICAgLy8gZnJvbSB0aGUgb3V0ZXIgbGlzdCBpdGVtIHRvIHRoZSBwYXJlbnQgbm9kZSBvZiB0aGUgY3Vyc29yXG4gICAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGggLSBkZXB0aEJlZm9yZTsgZCA+PSAkZnJvbS5kZXB0aCAtIDM7IGQgLT0gMSkge1xuICAgICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGQpLmNvcHkod3JhcCkpXG4gICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBjb25zdCBkZXB0aEFmdGVyID0gJGZyb20uaW5kZXhBZnRlcigtMSkgPCAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50ID8gMSA6ICRmcm9tLmluZGV4QWZ0ZXIoLTIpIDwgJGZyb20ubm9kZSgtMykuY2hpbGRDb3VudCA/IDIgOiAzXG5cbiAgICAgIC8vIEFkZCBhIHNlY29uZCBsaXN0IGl0ZW0gd2l0aCBhbiBlbXB0eSBkZWZhdWx0IHN0YXJ0IG5vZGVcbiAgICAgIGNvbnN0IG5ld05leHRUeXBlQXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhcbiAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcyxcbiAgICAgICAgJGZyb20ubm9kZSgpLnR5cGUubmFtZSxcbiAgICAgICAgJGZyb20ubm9kZSgpLmF0dHJzLFxuICAgICAgKVxuICAgICAgY29uc3QgbmV4dFR5cGUgPSB0eXBlLmNvbnRlbnRNYXRjaC5kZWZhdWx0VHlwZT8uY3JlYXRlQW5kRmlsbChuZXdOZXh0VHlwZUF0dHJpYnV0ZXMpIHx8IHVuZGVmaW5lZFxuXG4gICAgICB3cmFwID0gd3JhcC5hcHBlbmQoRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZUFuZEZpbGwobnVsbCwgbmV4dFR5cGUpIHx8IHVuZGVmaW5lZCkpXG5cbiAgICAgIGNvbnN0IHN0YXJ0ID0gJGZyb20uYmVmb3JlKCRmcm9tLmRlcHRoIC0gKGRlcHRoQmVmb3JlIC0gMSkpXG5cbiAgICAgIHRyLnJlcGxhY2Uoc3RhcnQsICRmcm9tLmFmdGVyKC1kZXB0aEFmdGVyKSwgbmV3IFNsaWNlKHdyYXAsIDQgLSBkZXB0aEJlZm9yZSwgMCkpXG5cbiAgICAgIGxldCBzZWwgPSAtMVxuXG4gICAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKHN0YXJ0LCB0ci5kb2MuY29udGVudC5zaXplLCAobiwgcG9zKSA9PiB7XG4gICAgICAgIGlmIChzZWwgPiAtMSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4uaXNUZXh0YmxvY2sgJiYgbi5jb250ZW50LnNpemUgPT09IDApIHtcbiAgICAgICAgICBzZWwgPSBwb3MgKyAxXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGlmIChzZWwgPiAtMSkge1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKHNlbCkpKVxuICAgICAgfVxuXG4gICAgICB0ci5zY3JvbGxJbnRvVmlldygpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNvbnN0IG5leHRUeXBlID0gJHRvLnBvcyA9PT0gJGZyb20uZW5kKCkgPyBncmFuZFBhcmVudC5jb250ZW50TWF0Y2hBdCgwKS5kZWZhdWx0VHlwZSA6IG51bGxcblxuICBjb25zdCBuZXdUeXBlQXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhcbiAgICBleHRlbnNpb25BdHRyaWJ1dGVzLFxuICAgIGdyYW5kUGFyZW50LnR5cGUubmFtZSxcbiAgICBncmFuZFBhcmVudC5hdHRycyxcbiAgKVxuICBjb25zdCBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgPSBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoXG4gICAgZXh0ZW5zaW9uQXR0cmlidXRlcyxcbiAgICAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLFxuICAgICRmcm9tLm5vZGUoKS5hdHRycyxcbiAgKVxuXG4gIHRyLmRlbGV0ZSgkZnJvbS5wb3MsICR0by5wb3MpXG5cbiAgY29uc3QgdHlwZXMgPSBuZXh0VHlwZVxuICAgID8gW1xuICAgICAgeyB0eXBlLCBhdHRyczogbmV3VHlwZUF0dHJpYnV0ZXMgfSxcbiAgICAgIHsgdHlwZTogbmV4dFR5cGUsIGF0dHJzOiBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgfSxcbiAgICBdXG4gICAgOiBbeyB0eXBlLCBhdHRyczogbmV3VHlwZUF0dHJpYnV0ZXMgfV1cblxuICBpZiAoIWNhblNwbGl0KHRyLmRvYywgJGZyb20ucG9zLCAyKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZVxuICAgIGNvbnN0IHsgc3BsaXR0YWJsZU1hcmtzIH0gPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlclxuICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKVxuXG4gICAgdHIuc3BsaXQoJGZyb20ucG9zLCAyLCB0eXBlcykuc2Nyb2xsSW50b1ZpZXcoKVxuXG4gICAgaWYgKCFtYXJrcyB8fCAhZGlzcGF0Y2gpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpXG5cbiAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBjYW5Kb2luIH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IGZpbmRQYXJlbnROb2RlIH0gZnJvbSAnLi4vaGVscGVycy9maW5kUGFyZW50Tm9kZS5qcydcbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGlzTGlzdCB9IGZyb20gJy4uL2hlbHBlcnMvaXNMaXN0LmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuY29uc3Qgam9pbkxpc3RCYWNrd2FyZHMgPSAodHI6IFRyYW5zYWN0aW9uLCBsaXN0VHlwZTogTm9kZVR5cGUpOiBib29sZWFuID0+IHtcbiAgY29uc3QgbGlzdCA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gbm9kZS50eXBlID09PSBsaXN0VHlwZSkodHIuc2VsZWN0aW9uKVxuXG4gIGlmICghbGlzdCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBiZWZvcmUgPSB0ci5kb2MucmVzb2x2ZShNYXRoLm1heCgwLCBsaXN0LnBvcyAtIDEpKS5iZWZvcmUobGlzdC5kZXB0aClcblxuICBpZiAoYmVmb3JlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3Qgbm9kZUJlZm9yZSA9IHRyLmRvYy5ub2RlQXQoYmVmb3JlKVxuICBjb25zdCBjYW5Kb2luQmFja3dhcmRzID0gbGlzdC5ub2RlLnR5cGUgPT09IG5vZGVCZWZvcmU/LnR5cGUgJiYgY2FuSm9pbih0ci5kb2MsIGxpc3QucG9zKVxuXG4gIGlmICghY2FuSm9pbkJhY2t3YXJkcykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB0ci5qb2luKGxpc3QucG9zKVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmNvbnN0IGpvaW5MaXN0Rm9yd2FyZHMgPSAodHI6IFRyYW5zYWN0aW9uLCBsaXN0VHlwZTogTm9kZVR5cGUpOiBib29sZWFuID0+IHtcbiAgY29uc3QgbGlzdCA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gbm9kZS50eXBlID09PSBsaXN0VHlwZSkodHIuc2VsZWN0aW9uKVxuXG4gIGlmICghbGlzdCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBhZnRlciA9IHRyLmRvYy5yZXNvbHZlKGxpc3Quc3RhcnQpLmFmdGVyKGxpc3QuZGVwdGgpXG5cbiAgaWYgKGFmdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3Qgbm9kZUFmdGVyID0gdHIuZG9jLm5vZGVBdChhZnRlcilcbiAgY29uc3QgY2FuSm9pbkZvcndhcmRzID0gbGlzdC5ub2RlLnR5cGUgPT09IG5vZGVBZnRlcj8udHlwZSAmJiBjYW5Kb2luKHRyLmRvYywgYWZ0ZXIpXG5cbiAgaWYgKCFjYW5Kb2luRm9yd2FyZHMpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgdHIuam9pbihhZnRlcilcblxuICByZXR1cm4gdHJ1ZVxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdG9nZ2xlTGlzdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgbGlzdCB0eXBlcy5cbiAgICAgICAqL1xuICAgICAgdG9nZ2xlTGlzdDogKGxpc3RUeXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgaXRlbVR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBrZWVwTWFya3M/OiBib29sZWFuLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRvZ2dsZUxpc3Q6IFJhd0NvbW1hbmRzWyd0b2dnbGVMaXN0J10gPSAobGlzdFR5cGVPck5hbWUsIGl0ZW1UeXBlT3JOYW1lLCBrZWVwTWFya3MsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHtcbiAgZWRpdG9yLCB0ciwgc3RhdGUsIGRpc3BhdGNoLCBjaGFpbiwgY29tbWFuZHMsIGNhbixcbn0pID0+IHtcbiAgY29uc3QgeyBleHRlbnNpb25zLCBzcGxpdHRhYmxlTWFya3MgfSA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyXG4gIGNvbnN0IGxpc3RUeXBlID0gZ2V0Tm9kZVR5cGUobGlzdFR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgaXRlbVR5cGUgPSBnZXROb2RlVHlwZShpdGVtVHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlXG4gIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc2VsZWN0aW9uXG4gIGNvbnN0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pXG5cbiAgY29uc3QgbWFya3MgPSBzdG9yZWRNYXJrcyB8fCAoc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpXG5cbiAgaWYgKCFyYW5nZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgcGFyZW50TGlzdCA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gaXNMaXN0KG5vZGUudHlwZS5uYW1lLCBleHRlbnNpb25zKSkoc2VsZWN0aW9uKVxuXG4gIGlmIChyYW5nZS5kZXB0aCA+PSAxICYmIHBhcmVudExpc3QgJiYgcmFuZ2UuZGVwdGggLSBwYXJlbnRMaXN0LmRlcHRoIDw9IDEpIHtcbiAgICAvLyByZW1vdmUgbGlzdFxuICAgIGlmIChwYXJlbnRMaXN0Lm5vZGUudHlwZSA9PT0gbGlzdFR5cGUpIHtcbiAgICAgIHJldHVybiBjb21tYW5kcy5saWZ0TGlzdEl0ZW0oaXRlbVR5cGUpXG4gICAgfVxuXG4gICAgLy8gY2hhbmdlIGxpc3QgdHlwZVxuICAgIGlmIChcbiAgICAgIGlzTGlzdChwYXJlbnRMaXN0Lm5vZGUudHlwZS5uYW1lLCBleHRlbnNpb25zKVxuICAgICAgICAmJiBsaXN0VHlwZS52YWxpZENvbnRlbnQocGFyZW50TGlzdC5ub2RlLmNvbnRlbnQpXG4gICAgICAgICYmIGRpc3BhdGNoXG4gICAgKSB7XG4gICAgICByZXR1cm4gY2hhaW4oKVxuICAgICAgICAuY29tbWFuZCgoKSA9PiB7XG4gICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwYXJlbnRMaXN0LnBvcywgbGlzdFR5cGUpXG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9KVxuICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEJhY2t3YXJkcyh0ciwgbGlzdFR5cGUpKVxuICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAgIC5ydW4oKVxuICAgIH1cbiAgfVxuICBpZiAoIWtlZXBNYXJrcyB8fCAhbWFya3MgfHwgIWRpc3BhdGNoKSB7XG5cbiAgICByZXR1cm4gY2hhaW4oKVxuICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgbm9kZSB0byBkZWZhdWx0IG5vZGUgaWYgbmVlZGVkXG4gICAgICAuY29tbWFuZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbldyYXBJbkxpc3QgPSBjYW4oKS53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKVxuXG4gICAgICAgIGlmIChjYW5XcmFwSW5MaXN0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKClcbiAgICAgIH0pXG4gICAgICAud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcylcbiAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0QmFja3dhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAucnVuKClcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgY2hhaW4oKVxuICAgIC8vIHRyeSB0byBjb252ZXJ0IG5vZGUgdG8gZGVmYXVsdCBub2RlIGlmIG5lZWRlZFxuICAgICAgLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICBjb25zdCBjYW5XcmFwSW5MaXN0ID0gY2FuKCkud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcylcblxuICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSlcblxuICAgICAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKVxuXG4gICAgICAgIGlmIChjYW5XcmFwSW5MaXN0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKClcbiAgICAgIH0pXG4gICAgICAud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcylcbiAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0QmFja3dhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAucnVuKClcbiAgKVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtUeXBlLmpzJ1xuaW1wb3J0IHsgaXNNYXJrQWN0aXZlIH0gZnJvbSAnLi4vaGVscGVycy9pc01hcmtBY3RpdmUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdG9nZ2xlTWFyazoge1xuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBtYXJrIG9uIGFuZCBvZmYuXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZU1hcms6IChcbiAgICAgICAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTWFya1R5cGUsXG4gICAgICAgIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgICAgICBvcHRpb25zPzoge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFJlbW92ZXMgdGhlIG1hcmsgZXZlbiBhY3Jvc3MgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGV4dGVuZEVtcHR5TWFya1JhbmdlPzogYm9vbGVhblxuICAgICAgICB9LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVNYXJrOiBSYXdDb21tYW5kc1sndG9nZ2xlTWFyayddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSwgb3B0aW9ucyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICBjb25zdCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlID0gZmFsc2UgfSA9IG9wdGlvbnNcbiAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgaXNBY3RpdmUgPSBpc01hcmtBY3RpdmUoc3RhdGUsIHR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgaWYgKGlzQWN0aXZlKSB7XG4gICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0eXBlLCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlIH0pXG4gIH1cblxuICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0eXBlLCBhdHRyaWJ1dGVzKVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgaXNOb2RlQWN0aXZlIH0gZnJvbSAnLi4vaGVscGVycy9pc05vZGVBY3RpdmUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdG9nZ2xlTm9kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBub2RlIHdpdGggYW5vdGhlciBub2RlLlxuICAgICAgICovXG4gICAgICB0b2dnbGVOb2RlOiAoXG4gICAgICAgIHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLFxuICAgICAgICB0b2dnbGVUeXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSxcbiAgICAgICAgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRvZ2dsZU5vZGU6IFJhd0NvbW1hbmRzWyd0b2dnbGVOb2RlJ10gPSAodHlwZU9yTmFtZSwgdG9nZ2xlVHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCB0b2dnbGVUeXBlID0gZ2V0Tm9kZVR5cGUodG9nZ2xlVHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCBpc0FjdGl2ZSA9IGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcylcblxuICBpZiAoaXNBY3RpdmUpIHtcbiAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0b2dnbGVUeXBlKVxuICB9XG5cbiAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodHlwZSwgYXR0cmlidXRlcylcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGlzTm9kZUFjdGl2ZSB9IGZyb20gJy4uL2hlbHBlcnMvaXNOb2RlQWN0aXZlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHRvZ2dsZVdyYXA6IHtcbiAgICAgIC8qKlxuICAgICAgICogV3JhcHMgbm9kZXMgaW4gYW5vdGhlciBub2RlLCBvciByZW1vdmVzIGFuIGV4aXN0aW5nIHdyYXAuXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZVdyYXA6ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRvZ2dsZVdyYXA6IFJhd0NvbW1hbmRzWyd0b2dnbGVXcmFwJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCBpc0FjdGl2ZSA9IGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcylcblxuICBpZiAoaXNBY3RpdmUpIHtcbiAgICByZXR1cm4gY29tbWFuZHMubGlmdCh0eXBlKVxuICB9XG5cbiAgcmV0dXJuIGNvbW1hbmRzLndyYXBJbih0eXBlLCBhdHRyaWJ1dGVzKVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB1bmRvSW5wdXRSdWxlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFVuZG8gYW4gaW5wdXQgcnVsZS5cbiAgICAgICAqL1xuICAgICAgdW5kb0lucHV0UnVsZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHVuZG9JbnB1dFJ1bGU6IFJhd0NvbW1hbmRzWyd1bmRvSW5wdXRSdWxlJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCBwbHVnaW5zID0gc3RhdGUucGx1Z2luc1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbaV1cbiAgICBsZXQgdW5kb2FibGVcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBpZiAocGx1Z2luLnNwZWMuaXNJbnB1dFJ1bGVzICYmICh1bmRvYWJsZSA9IHBsdWdpbi5nZXRTdGF0ZShzdGF0ZSkpKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgdHIgPSBzdGF0ZS50clxuICAgICAgICBjb25zdCB0b1VuZG8gPSB1bmRvYWJsZS50cmFuc2Zvcm1cblxuICAgICAgICBmb3IgKGxldCBqID0gdG9VbmRvLnN0ZXBzLmxlbmd0aCAtIDE7IGogPj0gMDsgaiAtPSAxKSB7XG4gICAgICAgICAgdHIuc3RlcCh0b1VuZG8uc3RlcHNbal0uaW52ZXJ0KHRvVW5kby5kb2NzW2pdKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1bmRvYWJsZS50ZXh0KSB7XG4gICAgICAgICAgY29uc3QgbWFya3MgPSB0ci5kb2MucmVzb2x2ZSh1bmRvYWJsZS5mcm9tKS5tYXJrcygpXG5cbiAgICAgICAgICB0ci5yZXBsYWNlV2l0aCh1bmRvYWJsZS5mcm9tLCB1bmRvYWJsZS50bywgc3RhdGUuc2NoZW1hLnRleHQodW5kb2FibGUudGV4dCwgbWFya3MpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyLmRlbGV0ZSh1bmRvYWJsZS5mcm9tLCB1bmRvYWJsZS50bylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB1bnNldEFsbE1hcmtzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBhbGwgbWFya3MgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICovXG4gICAgICB1bnNldEFsbE1hcmtzOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdW5zZXRBbGxNYXJrczogUmF3Q29tbWFuZHNbJ3Vuc2V0QWxsTWFya3MnXSA9ICgpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0clxuICBjb25zdCB7IGVtcHR5LCByYW5nZXMgfSA9IHNlbGVjdGlvblxuXG4gIGlmIChlbXB0eSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICB0ci5yZW1vdmVNYXJrKHJhbmdlLiRmcm9tLnBvcywgcmFuZ2UuJHRvLnBvcylcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE1hcmtSYW5nZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1JhbmdlLmpzJ1xuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtUeXBlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHVuc2V0TWFyazoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgYWxsIG1hcmtzIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgICAqL1xuICAgICAgdW5zZXRNYXJrOiAoXG4gICAgICAgIHR5cGVPck5hbWU6IHN0cmluZyB8IE1hcmtUeXBlLFxuICAgICAgICBvcHRpb25zPzoge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFJlbW92ZXMgdGhlIG1hcmsgZXZlbiBhY3Jvc3MgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGV4dGVuZEVtcHR5TWFya1JhbmdlPzogYm9vbGVhblxuICAgICAgICB9LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB1bnNldE1hcms6IFJhd0NvbW1hbmRzWyd1bnNldE1hcmsnXSA9ICh0eXBlT3JOYW1lLCBvcHRpb25zID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlID0gZmFsc2UgfSA9IG9wdGlvbnNcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyXG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgJGZyb20sIGVtcHR5LCByYW5nZXMgfSA9IHNlbGVjdGlvblxuXG4gIGlmICghZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKGVtcHR5ICYmIGV4dGVuZEVtcHR5TWFya1JhbmdlKSB7XG4gICAgbGV0IHsgZnJvbSwgdG8gfSA9IHNlbGVjdGlvblxuICAgIGNvbnN0IGF0dHJzID0gJGZyb20ubWFya3MoKS5maW5kKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKT8uYXR0cnNcbiAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkZnJvbSwgdHlwZSwgYXR0cnMpXG5cbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgIGZyb20gPSByYW5nZS5mcm9tXG4gICAgICB0byA9IHJhbmdlLnRvXG4gICAgfVxuXG4gICAgdHIucmVtb3ZlTWFyayhmcm9tLCB0bywgdHlwZSlcbiAgfSBlbHNlIHtcbiAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICB0ci5yZW1vdmVNYXJrKHJhbmdlLiRmcm9tLnBvcywgcmFuZ2UuJHRvLnBvcywgdHlwZSlcbiAgICB9KVxuICB9XG5cbiAgdHIucmVtb3ZlU3RvcmVkTWFyayh0eXBlKVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtUeXBlLmpzJ1xuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUgfSBmcm9tICcuLi9oZWxwZXJzL2dldFNjaGVtYVR5cGVOYW1lQnlOYW1lLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHVwZGF0ZUF0dHJpYnV0ZXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlIGF0dHJpYnV0ZXMgb2YgYSBub2RlIG9yIG1hcmsuXG4gICAgICAgKi9cbiAgICAgIHVwZGF0ZUF0dHJpYnV0ZXM6IChcbiAgICAgICAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUgfCBNYXJrVHlwZSxcbiAgICAgICAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PixcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdXBkYXRlQXR0cmlidXRlczogUmF3Q29tbWFuZHNbJ3VwZGF0ZUF0dHJpYnV0ZXMnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBsZXQgbm9kZVR5cGU6IE5vZGVUeXBlIHwgbnVsbCA9IG51bGxcbiAgbGV0IG1hcmtUeXBlOiBNYXJrVHlwZSB8IG51bGwgPSBudWxsXG5cbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKFxuICAgIHR5cGVvZiB0eXBlT3JOYW1lID09PSAnc3RyaW5nJyA/IHR5cGVPck5hbWUgOiB0eXBlT3JOYW1lLm5hbWUsXG4gICAgc3RhdGUuc2NoZW1hLFxuICApXG5cbiAgaWYgKCFzY2hlbWFUeXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgbm9kZVR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lIGFzIE5vZGVUeXBlLCBzdGF0ZS5zY2hlbWEpXG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgbWFya1R5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lIGFzIE1hcmtUeXBlLCBzdGF0ZS5zY2hlbWEpXG4gIH1cblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5zZWxlY3Rpb24ucmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgY29uc3QgZnJvbSA9IHJhbmdlLiRmcm9tLnBvc1xuICAgICAgY29uc3QgdG8gPSByYW5nZS4kdG8ucG9zXG5cbiAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKG5vZGVUeXBlICYmIG5vZGVUeXBlID09PSBub2RlLnR5cGUpIHtcbiAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAuLi5ub2RlLmF0dHJzLFxuICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hcmtUeXBlICYmIG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgbm9kZS5tYXJrcy5mb3JFYWNoKG1hcmsgPT4ge1xuICAgICAgICAgICAgaWYgKG1hcmtUeXBlID09PSBtYXJrLnR5cGUpIHtcbiAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZEZyb20gPSBNYXRoLm1heChwb3MsIGZyb20pXG4gICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRUbyA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKVxuXG4gICAgICAgICAgICAgIHRyLmFkZE1hcmsoXG4gICAgICAgICAgICAgICAgdHJpbW1lZEZyb20sXG4gICAgICAgICAgICAgICAgdHJpbW1lZFRvLFxuICAgICAgICAgICAgICAgIG1hcmtUeXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAuLi5tYXJrLmF0dHJzLFxuICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgd3JhcEluIGFzIG9yaWdpbmFsV3JhcEluIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcbmltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHdyYXBJbjoge1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwcyBub2RlcyBpbiBhbm90aGVyIG5vZGUuXG4gICAgICAgKi9cbiAgICAgIHdyYXBJbjogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgd3JhcEluOiBSYXdDb21tYW5kc1snd3JhcEluJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIHJldHVybiBvcmlnaW5hbFdyYXBJbih0eXBlLCBhdHRyaWJ1dGVzKShzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgd3JhcEluTGlzdCBhcyBvcmlnaW5hbFdyYXBJbkxpc3QgfSBmcm9tICdAdGlwdGFwL3BtL3NjaGVtYS1saXN0J1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgd3JhcEluTGlzdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwIGEgbm9kZSBpbiBhIGxpc3QuXG4gICAgICAgKi9cbiAgICAgIHdyYXBJbkxpc3Q6ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHdyYXBJbkxpc3Q6IFJhd0NvbW1hbmRzWyd3cmFwSW5MaXN0J10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIHJldHVybiBvcmlnaW5hbFdyYXBJbkxpc3QodHlwZSwgYXR0cmlidXRlcykoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCAqIGFzIGNvbW1hbmRzIGZyb20gJy4uL2NvbW1hbmRzL2luZGV4LmpzJ1xuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnLi4vRXh0ZW5zaW9uLmpzJ1xuXG5leHBvcnQgKiBmcm9tICcuLi9jb21tYW5kcy9pbmRleC5qcydcblxuZXhwb3J0IGNvbnN0IENvbW1hbmRzID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICdjb21tYW5kcycsXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbW1hbmRzLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5cbmV4cG9ydCBjb25zdCBFZGl0YWJsZSA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAnZWRpdGFibGUnLFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnZWRpdGFibGUnKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBlZGl0YWJsZTogKCkgPT4gdGhpcy5lZGl0b3Iub3B0aW9ucy5lZGl0YWJsZSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5cbmV4cG9ydCBjb25zdCBGb2N1c0V2ZW50cyA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAnZm9jdXNFdmVudHMnLFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpc1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2ZvY3VzRXZlbnRzJyksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICBmb2N1czogKHZpZXcsIGV2ZW50OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgICBlZGl0b3IuaXNGb2N1c2VkID0gdHJ1ZVxuXG4gICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZWRpdG9yLnN0YXRlLnRyXG4gICAgICAgICAgICAgICAgLnNldE1ldGEoJ2ZvY3VzJywgeyBldmVudCB9KVxuICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdhZGRUb0hpc3RvcnknLCBmYWxzZSlcblxuICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKVxuXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJsdXI6ICh2aWV3LCBldmVudDogRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgZWRpdG9yLmlzRm9jdXNlZCA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBlZGl0b3Iuc3RhdGUudHJcbiAgICAgICAgICAgICAgICAuc2V0TWV0YSgnYmx1cicsIHsgZXZlbnQgfSlcbiAgICAgICAgICAgICAgICAuc2V0TWV0YSgnYWRkVG9IaXN0b3J5JywgZmFsc2UpXG5cbiAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbilcblxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXksIFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IENvbW1hbmRNYW5hZ2VyIH0gZnJvbSAnLi4vQ29tbWFuZE1hbmFnZXIuanMnXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5pbXBvcnQgeyBjcmVhdGVDaGFpbmFibGVTdGF0ZSB9IGZyb20gJy4uL2hlbHBlcnMvY3JlYXRlQ2hhaW5hYmxlU3RhdGUuanMnXG5pbXBvcnQgeyBpc2lPUyB9IGZyb20gJy4uL3V0aWxpdGllcy9pc2lPUy5qcydcbmltcG9ydCB7IGlzTWFjT1MgfSBmcm9tICcuLi91dGlsaXRpZXMvaXNNYWNPUy5qcydcblxuZXhwb3J0IGNvbnN0IEtleW1hcCA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAna2V5bWFwJyxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICBjb25zdCBoYW5kbGVCYWNrc3BhY2UgPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXG4gICAgICAoKSA9PiBjb21tYW5kcy51bmRvSW5wdXRSdWxlKCksXG5cbiAgICAgIC8vIG1heWJlIGNvbnZlcnQgZmlyc3QgdGV4dCBibG9jayBub2RlIHRvIGRlZmF1bHQgbm9kZVxuICAgICAgKCkgPT4gY29tbWFuZHMuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHRyXG4gICAgICAgIGNvbnN0IHsgZW1wdHksICRhbmNob3IgfSA9IHNlbGVjdGlvblxuICAgICAgICBjb25zdCB7IHBvcywgcGFyZW50IH0gPSAkYW5jaG9yXG4gICAgICAgIGNvbnN0ICRwYXJlbnRQb3MgPSAkYW5jaG9yLnBhcmVudC5pc1RleHRibG9jayA/IHRyLmRvYy5yZXNvbHZlKHBvcyAtIDEpIDogJGFuY2hvclxuICAgICAgICBjb25zdCBwYXJlbnRJc0lzb2xhdGluZyA9ICRwYXJlbnRQb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmdcblxuICAgICAgICBjb25zdCBwYXJlbnRQb3MgPSAkYW5jaG9yLnBvcyAtICRhbmNob3IucGFyZW50T2Zmc2V0XG5cbiAgICAgICAgY29uc3QgaXNBdFN0YXJ0ID0gKHBhcmVudElzSXNvbGF0aW5nICYmICRwYXJlbnRQb3MucGFyZW50LmNoaWxkQ291bnQgPT09IDEpXG4gICAgICAgICAgPyBwYXJlbnRQb3MgPT09ICRhbmNob3IucG9zXG4gICAgICAgICAgOiBTZWxlY3Rpb24uYXRTdGFydChkb2MpLmZyb20gPT09IHBvc1xuXG4gICAgICAgIGlmICghZW1wdHkgfHwgIWlzQXRTdGFydCB8fCAhcGFyZW50LnR5cGUuaXNUZXh0YmxvY2sgfHwgcGFyZW50LnRleHRDb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKVxuICAgICAgfSksXG5cbiAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuam9pbkJhY2t3YXJkKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5zZWxlY3ROb2RlQmFja3dhcmQoKSxcbiAgICBdKVxuXG4gICAgY29uc3QgaGFuZGxlRGVsZXRlID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZmlyc3QoKHsgY29tbWFuZHMgfSkgPT4gW1xuICAgICAgKCkgPT4gY29tbWFuZHMuZGVsZXRlU2VsZWN0aW9uKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5kZWxldGVDdXJyZW50Tm9kZSgpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuam9pbkZvcndhcmQoKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLnNlbGVjdE5vZGVGb3J3YXJkKCksXG4gICAgXSlcblxuICAgIGNvbnN0IGhhbmRsZUVudGVyID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZmlyc3QoKHsgY29tbWFuZHMgfSkgPT4gW1xuICAgICAgKCkgPT4gY29tbWFuZHMubmV3bGluZUluQ29kZSgpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuY3JlYXRlUGFyYWdyYXBoTmVhcigpLFxuICAgICAgKCkgPT4gY29tbWFuZHMubGlmdEVtcHR5QmxvY2soKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLnNwbGl0QmxvY2soKSxcbiAgICBdKVxuXG4gICAgY29uc3QgYmFzZUtleW1hcCA9IHtcbiAgICAgIEVudGVyOiBoYW5kbGVFbnRlcixcbiAgICAgICdNb2QtRW50ZXInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5leGl0Q29kZSgpLFxuICAgICAgQmFja3NwYWNlOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAnTW9kLUJhY2tzcGFjZSc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICdTaGlmdC1CYWNrc3BhY2UnOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICBEZWxldGU6IGhhbmRsZURlbGV0ZSxcbiAgICAgICdNb2QtRGVsZXRlJzogaGFuZGxlRGVsZXRlLFxuICAgICAgJ01vZC1hJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0QWxsKCksXG4gICAgfVxuXG4gICAgY29uc3QgcGNLZXltYXAgPSB7XG4gICAgICAuLi5iYXNlS2V5bWFwLFxuICAgIH1cblxuICAgIGNvbnN0IG1hY0tleW1hcCA9IHtcbiAgICAgIC4uLmJhc2VLZXltYXAsXG4gICAgICAnQ3RybC1oJzogaGFuZGxlQmFja3NwYWNlLFxuICAgICAgJ0FsdC1CYWNrc3BhY2UnOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAnQ3RybC1kJzogaGFuZGxlRGVsZXRlLFxuICAgICAgJ0N0cmwtQWx0LUJhY2tzcGFjZSc6IGhhbmRsZURlbGV0ZSxcbiAgICAgICdBbHQtRGVsZXRlJzogaGFuZGxlRGVsZXRlLFxuICAgICAgJ0FsdC1kJzogaGFuZGxlRGVsZXRlLFxuICAgICAgJ0N0cmwtYSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNlbGVjdFRleHRibG9ja1N0YXJ0KCksXG4gICAgICAnQ3RybC1lJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0VGV4dGJsb2NrRW5kKCksXG4gICAgfVxuXG4gICAgaWYgKGlzaU9TKCkgfHwgaXNNYWNPUygpKSB7XG4gICAgICByZXR1cm4gbWFjS2V5bWFwXG4gICAgfVxuXG4gICAgcmV0dXJuIHBjS2V5bWFwXG4gIH0sXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICAvLyBXaXRoIHRoaXMgcGx1Z2luIHdlIGNoZWNrIGlmIHRoZSB3aG9sZSBkb2N1bWVudCB3YXMgc2VsZWN0ZWQgYW5kIGRlbGV0ZWQuXG4gICAgICAvLyBJbiB0aGlzIGNhc2Ugd2Ugd2lsbCBhZGRpdGlvbmFsbHkgY2FsbCBgY2xlYXJOb2RlcygpYCB0byBjb252ZXJ0IGUuZy4gYSBoZWFkaW5nXG4gICAgICAvLyB0byBhIHBhcmFncmFwaCBpZiBuZWNlc3NhcnkuXG4gICAgICAvLyBUaGlzIGlzIGFuIGFsdGVybmF0aXZlIHRvIFByb3NlTWlycm9yJ3MgYEFsbFNlbGVjdGlvbmAsIHdoaWNoIGRvZXNu4oCZdCB3b3JrIHdlbGxcbiAgICAgIC8vIHdpdGggbWFueSBvdGhlciBjb21tYW5kcy5cbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2NsZWFyRG9jdW1lbnQnKSxcbiAgICAgICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbnMsIG9sZFN0YXRlLCBuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRvY0NoYW5nZXMgPSB0cmFuc2FjdGlvbnMuc29tZSh0cmFuc2FjdGlvbiA9PiB0cmFuc2FjdGlvbi5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgJiYgIW9sZFN0YXRlLmRvYy5lcShuZXdTdGF0ZS5kb2MpXG5cbiAgICAgICAgICBpZiAoIWRvY0NoYW5nZXMpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHsgZW1wdHksIGZyb20sIHRvIH0gPSBvbGRTdGF0ZS5zZWxlY3Rpb25cbiAgICAgICAgICBjb25zdCBhbGxGcm9tID0gU2VsZWN0aW9uLmF0U3RhcnQob2xkU3RhdGUuZG9jKS5mcm9tXG4gICAgICAgICAgY29uc3QgYWxsRW5kID0gU2VsZWN0aW9uLmF0RW5kKG9sZFN0YXRlLmRvYykudG9cbiAgICAgICAgICBjb25zdCBhbGxXYXNTZWxlY3RlZCA9IGZyb20gPT09IGFsbEZyb20gJiYgdG8gPT09IGFsbEVuZFxuXG4gICAgICAgICAgaWYgKGVtcHR5IHx8ICFhbGxXYXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaXNFbXB0eSA9IG5ld1N0YXRlLmRvYy50ZXh0QmV0d2VlbigwLCBuZXdTdGF0ZS5kb2MuY29udGVudC5zaXplLCAnICcsICcgJykubGVuZ3RoID09PSAwXG5cbiAgICAgICAgICBpZiAoIWlzRW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHRyID0gbmV3U3RhdGUudHJcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IGNyZWF0ZUNoYWluYWJsZVN0YXRlKHtcbiAgICAgICAgICAgIHN0YXRlOiBuZXdTdGF0ZSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cixcbiAgICAgICAgICB9KVxuICAgICAgICAgIGNvbnN0IHsgY29tbWFuZHMgfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGNvbW1hbmRzLmNsZWFyTm9kZXMoKVxuXG4gICAgICAgICAgaWYgKCF0ci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0clxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcblxuZXhwb3J0IGNvbnN0IFRhYmluZGV4ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICd0YWJpbmRleCcsXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCd0YWJpbmRleCcpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuZWRpdG9yLmlzRWRpdGFibGUgPyB7IHRhYmluZGV4OiAnMCcgfSA6IHt9LFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJleHBvcnQgY29uc3Qgc3R5bGUgPSBgLlByb3NlTWlycm9yIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuXG4uUHJvc2VNaXJyb3Ige1xuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgd2hpdGUtc3BhY2U6IGJyZWFrLXNwYWNlcztcbiAgLXdlYmtpdC1mb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IFwibGlnYVwiIDA7IC8qIHRoZSBhYm92ZSBkb2Vzbid0IHNlZW0gdG8gd29yayBpbiBFZGdlICovXG59XG5cbi5Qcm9zZU1pcnJvciBbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0ge1xuICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xufVxuXG4uUHJvc2VNaXJyb3IgW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdIFtjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG4uUHJvc2VNaXJyb3IgcHJlIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG5pbWcuUHJvc2VNaXJyb3Itc2VwYXJhdG9yIHtcbiAgZGlzcGxheTogaW5saW5lICFpbXBvcnRhbnQ7XG4gIGJvcmRlcjogbm9uZSAhaW1wb3J0YW50O1xuICBtYXJnaW46IDAgIWltcG9ydGFudDtcbiAgd2lkdGg6IDFweCAhaW1wb3J0YW50O1xuICBoZWlnaHQ6IDFweCAhaW1wb3J0YW50O1xufVxuXG4uUHJvc2VNaXJyb3ItZ2FwY3Vyc29yIHtcbiAgZGlzcGxheTogbm9uZTtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgbWFyZ2luOiAwO1xufVxuXG4uUHJvc2VNaXJyb3ItZ2FwY3Vyc29yOmFmdGVyIHtcbiAgY29udGVudDogXCJcIjtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAtMnB4O1xuICB3aWR0aDogMjBweDtcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIGJsYWNrO1xuICBhbmltYXRpb246IFByb3NlTWlycm9yLWN1cnNvci1ibGluayAxLjFzIHN0ZXBzKDIsIHN0YXJ0KSBpbmZpbml0ZTtcbn1cblxuQGtleWZyYW1lcyBQcm9zZU1pcnJvci1jdXJzb3ItYmxpbmsge1xuICB0byB7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICB9XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICo6OnNlbGVjdGlvbiB7XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xufVxuXG4uUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvbiAqOjotbW96LXNlbGVjdGlvbiB7XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xufVxuXG4uUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvbiAqIHtcbiAgY2FyZXQtY29sb3I6IHRyYW5zcGFyZW50O1xufVxuXG4uUHJvc2VNaXJyb3ItZm9jdXNlZCAuUHJvc2VNaXJyb3ItZ2FwY3Vyc29yIHtcbiAgZGlzcGxheTogYmxvY2s7XG59XG5cbi50aXBweS1ib3hbZGF0YS1hbmltYXRpb249ZmFkZV1bZGF0YS1zdGF0ZT1oaWRkZW5dIHtcbiAgb3BhY2l0eTogMFxufWBcbiIsICJleHBvcnQgZnVuY3Rpb24gY3JlYXRlU3R5bGVUYWcoc3R5bGU6IHN0cmluZywgbm9uY2U/OiBzdHJpbmcsIHN1ZmZpeD86IHN0cmluZyk6IEhUTUxTdHlsZUVsZW1lbnQge1xuICBjb25zdCB0aXB0YXBTdHlsZVRhZyA9ICg8SFRNTFN0eWxlRWxlbWVudD5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzdHlsZVtkYXRhLXRpcHRhcC1zdHlsZSR7c3VmZml4ID8gYC0ke3N1ZmZpeH1gIDogJyd9XWApKVxuXG4gIGlmICh0aXB0YXBTdHlsZVRhZyAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0aXB0YXBTdHlsZVRhZ1xuICB9XG5cbiAgY29uc3Qgc3R5bGVOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuXG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlTm9kZS5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpXG4gIH1cblxuICBzdHlsZU5vZGUuc2V0QXR0cmlidXRlKGBkYXRhLXRpcHRhcC1zdHlsZSR7c3VmZml4ID8gYC0ke3N1ZmZpeH1gIDogJyd9YCwgJycpXG4gIHN0eWxlTm9kZS5pbm5lckhUTUwgPSBzdHlsZVxuICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHN0eWxlTm9kZSlcblxuICByZXR1cm4gc3R5bGVOb2RlXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUsIE5vZGVUeXBlLCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHtcbiAgRWRpdG9yU3RhdGUsIFBsdWdpbiwgUGx1Z2luS2V5LCBUcmFuc2FjdGlvbixcbn0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnXG5cbmltcG9ydCB7IENvbW1hbmRNYW5hZ2VyIH0gZnJvbSAnLi9Db21tYW5kTWFuYWdlci5qcydcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4vRXZlbnRFbWl0dGVyLmpzJ1xuaW1wb3J0IHsgRXh0ZW5zaW9uTWFuYWdlciB9IGZyb20gJy4vRXh0ZW5zaW9uTWFuYWdlci5qcydcbmltcG9ydCAqIGFzIGV4dGVuc2lvbnMgZnJvbSAnLi9leHRlbnNpb25zL2luZGV4LmpzJ1xuaW1wb3J0IHsgY3JlYXRlRG9jdW1lbnQgfSBmcm9tICcuL2hlbHBlcnMvY3JlYXRlRG9jdW1lbnQuanMnXG5pbXBvcnQgeyBnZXRBdHRyaWJ1dGVzIH0gZnJvbSAnLi9oZWxwZXJzL2dldEF0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXRIVE1MRnJvbUZyYWdtZW50IH0gZnJvbSAnLi9oZWxwZXJzL2dldEhUTUxGcm9tRnJhZ21lbnQuanMnXG5pbXBvcnQgeyBnZXRUZXh0IH0gZnJvbSAnLi9oZWxwZXJzL2dldFRleHQuanMnXG5pbXBvcnQgeyBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hIH0gZnJvbSAnLi9oZWxwZXJzL2dldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEuanMnXG5pbXBvcnQgeyBpc0FjdGl2ZSB9IGZyb20gJy4vaGVscGVycy9pc0FjdGl2ZS5qcydcbmltcG9ydCB7IGlzTm9kZUVtcHR5IH0gZnJvbSAnLi9oZWxwZXJzL2lzTm9kZUVtcHR5LmpzJ1xuaW1wb3J0IHsgcmVzb2x2ZUZvY3VzUG9zaXRpb24gfSBmcm9tICcuL2hlbHBlcnMvcmVzb2x2ZUZvY3VzUG9zaXRpb24uanMnXG5pbXBvcnQgeyBzdHlsZSB9IGZyb20gJy4vc3R5bGUuanMnXG5pbXBvcnQge1xuICBDYW5Db21tYW5kcyxcbiAgQ2hhaW5lZENvbW1hbmRzLFxuICBFZGl0b3JFdmVudHMsXG4gIEVkaXRvck9wdGlvbnMsXG4gIEpTT05Db250ZW50LFxuICBTaW5nbGVDb21tYW5kcyxcbiAgVGV4dFNlcmlhbGl6ZXIsXG59IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBjcmVhdGVTdHlsZVRhZyB9IGZyb20gJy4vdXRpbGl0aWVzL2NyZWF0ZVN0eWxlVGFnLmpzJ1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4vdXRpbGl0aWVzL2lzRnVuY3Rpb24uanMnXG5cbmV4cG9ydCB7IGV4dGVuc2lvbnMgfVxuXG5leHBvcnQgaW50ZXJmYWNlIEhUTUxFbGVtZW50IHtcbiAgZWRpdG9yPzogRWRpdG9yXG59XG5cbmV4cG9ydCBjbGFzcyBFZGl0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXI8RWRpdG9yRXZlbnRzPiB7XG4gIHByaXZhdGUgY29tbWFuZE1hbmFnZXIhOiBDb21tYW5kTWFuYWdlclxuXG4gIHB1YmxpYyBleHRlbnNpb25NYW5hZ2VyITogRXh0ZW5zaW9uTWFuYWdlclxuXG4gIHByaXZhdGUgY3NzITogSFRNTFN0eWxlRWxlbWVudFxuXG4gIHB1YmxpYyBzY2hlbWEhOiBTY2hlbWFcblxuICBwdWJsaWMgdmlldyE6IEVkaXRvclZpZXdcblxuICBwdWJsaWMgaXNGb2N1c2VkID0gZmFsc2VcblxuICBwdWJsaWMgZXh0ZW5zaW9uU3RvcmFnZTogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9XG5cbiAgcHVibGljIG9wdGlvbnM6IEVkaXRvck9wdGlvbnMgPSB7XG4gICAgZWxlbWVudDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgY29udGVudDogJycsXG4gICAgaW5qZWN0Q1NTOiB0cnVlLFxuICAgIGluamVjdE5vbmNlOiB1bmRlZmluZWQsXG4gICAgZXh0ZW5zaW9uczogW10sXG4gICAgYXV0b2ZvY3VzOiBmYWxzZSxcbiAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICBlZGl0b3JQcm9wczoge30sXG4gICAgcGFyc2VPcHRpb25zOiB7fSxcbiAgICBlbmFibGVJbnB1dFJ1bGVzOiB0cnVlLFxuICAgIGVuYWJsZVBhc3RlUnVsZXM6IHRydWUsXG4gICAgZW5hYmxlQ29yZUV4dGVuc2lvbnM6IHRydWUsXG4gICAgb25CZWZvcmVDcmVhdGU6ICgpID0+IG51bGwsXG4gICAgb25DcmVhdGU6ICgpID0+IG51bGwsXG4gICAgb25VcGRhdGU6ICgpID0+IG51bGwsXG4gICAgb25TZWxlY3Rpb25VcGRhdGU6ICgpID0+IG51bGwsXG4gICAgb25UcmFuc2FjdGlvbjogKCkgPT4gbnVsbCxcbiAgICBvbkZvY3VzOiAoKSA9PiBudWxsLFxuICAgIG9uQmx1cjogKCkgPT4gbnVsbCxcbiAgICBvbkRlc3Ryb3k6ICgpID0+IG51bGwsXG4gIH1cblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBQYXJ0aWFsPEVkaXRvck9wdGlvbnM+ID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpXG4gICAgdGhpcy5jcmVhdGVFeHRlbnNpb25NYW5hZ2VyKClcbiAgICB0aGlzLmNyZWF0ZUNvbW1hbmRNYW5hZ2VyKClcbiAgICB0aGlzLmNyZWF0ZVNjaGVtYSgpXG4gICAgdGhpcy5vbignYmVmb3JlQ3JlYXRlJywgdGhpcy5vcHRpb25zLm9uQmVmb3JlQ3JlYXRlKVxuICAgIHRoaXMuZW1pdCgnYmVmb3JlQ3JlYXRlJywgeyBlZGl0b3I6IHRoaXMgfSlcbiAgICB0aGlzLmNyZWF0ZVZpZXcoKVxuICAgIHRoaXMuaW5qZWN0Q1NTKClcbiAgICB0aGlzLm9uKCdjcmVhdGUnLCB0aGlzLm9wdGlvbnMub25DcmVhdGUpXG4gICAgdGhpcy5vbigndXBkYXRlJywgdGhpcy5vcHRpb25zLm9uVXBkYXRlKVxuICAgIHRoaXMub24oJ3NlbGVjdGlvblVwZGF0ZScsIHRoaXMub3B0aW9ucy5vblNlbGVjdGlvblVwZGF0ZSlcbiAgICB0aGlzLm9uKCd0cmFuc2FjdGlvbicsIHRoaXMub3B0aW9ucy5vblRyYW5zYWN0aW9uKVxuICAgIHRoaXMub24oJ2ZvY3VzJywgdGhpcy5vcHRpb25zLm9uRm9jdXMpXG4gICAgdGhpcy5vbignYmx1cicsIHRoaXMub3B0aW9ucy5vbkJsdXIpXG4gICAgdGhpcy5vbignZGVzdHJveScsIHRoaXMub3B0aW9ucy5vbkRlc3Ryb3kpXG5cbiAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcy5jb21tYW5kcy5mb2N1cyh0aGlzLm9wdGlvbnMuYXV0b2ZvY3VzKVxuICAgICAgdGhpcy5lbWl0KCdjcmVhdGUnLCB7IGVkaXRvcjogdGhpcyB9KVxuICAgIH0sIDApXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWRpdG9yIHN0b3JhZ2UuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0b3JhZ2UoKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uU3RvcmFnZVxuICB9XG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBvZiBhbGwgcmVnaXN0ZXJlZCBjb21tYW5kcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgY29tbWFuZHMoKTogU2luZ2xlQ29tbWFuZHMge1xuICAgIHJldHVybiB0aGlzLmNvbW1hbmRNYW5hZ2VyLmNvbW1hbmRzXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgY29tbWFuZCBjaGFpbiB0byBjYWxsIG11bHRpcGxlIGNvbW1hbmRzIGF0IG9uY2UuXG4gICAqL1xuICBwdWJsaWMgY2hhaW4oKTogQ2hhaW5lZENvbW1hbmRzIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jaGFpbigpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBjb21tYW5kIG9yIGEgY29tbWFuZCBjaGFpbiBjYW4gYmUgZXhlY3V0ZWQuIFdpdGhvdXQgZXhlY3V0aW5nIGl0LlxuICAgKi9cbiAgcHVibGljIGNhbigpOiBDYW5Db21tYW5kcyB7XG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZE1hbmFnZXIuY2FuKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmplY3QgQ1NTIHN0eWxlcy5cbiAgICovXG4gIHByaXZhdGUgaW5qZWN0Q1NTKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuaW5qZWN0Q1NTICYmIGRvY3VtZW50KSB7XG4gICAgICB0aGlzLmNzcyA9IGNyZWF0ZVN0eWxlVGFnKHN0eWxlLCB0aGlzLm9wdGlvbnMuaW5qZWN0Tm9uY2UpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBlZGl0b3Igb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgQSBsaXN0IG9mIG9wdGlvbnNcbiAgICovXG4gIHB1YmxpYyBzZXRPcHRpb25zKG9wdGlvbnM6IFBhcnRpYWw8RWRpdG9yT3B0aW9ucz4gPSB7fSk6IHZvaWQge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnZpZXcgfHwgIXRoaXMuc3RhdGUgfHwgdGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lZGl0b3JQcm9wcykge1xuICAgICAgdGhpcy52aWV3LnNldFByb3BzKHRoaXMub3B0aW9ucy5lZGl0b3JQcm9wcylcbiAgICB9XG5cbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUodGhpcy5zdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZWRpdGFibGUgc3RhdGUgb2YgdGhlIGVkaXRvci5cbiAgICovXG4gIHB1YmxpYyBzZXRFZGl0YWJsZShlZGl0YWJsZTogYm9vbGVhbiwgZW1pdFVwZGF0ZSA9IHRydWUpOiB2b2lkIHtcbiAgICB0aGlzLnNldE9wdGlvbnMoeyBlZGl0YWJsZSB9KVxuXG4gICAgaWYgKGVtaXRVcGRhdGUpIHtcbiAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgeyBlZGl0b3I6IHRoaXMsIHRyYW5zYWN0aW9uOiB0aGlzLnN0YXRlLnRyIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgZWRpdG9yIGlzIGVkaXRhYmxlLlxuICAgKi9cbiAgcHVibGljIGdldCBpc0VkaXRhYmxlKCk6IGJvb2xlYW4ge1xuICAgIC8vIHNpbmNlIHBsdWdpbnMgYXJlIGFwcGxpZWQgYWZ0ZXIgY3JlYXRpbmcgdGhlIHZpZXdcbiAgICAvLyBgZWRpdGFibGVgIGlzIGFsd2F5cyBgdHJ1ZWAgZm9yIG9uZSB0aWNrLlxuICAgIC8vIHRoYXTigJlzIHdoeSB3ZSBhbHNvIGhhdmUgdG8gY2hlY2sgZm9yIGBvcHRpb25zLmVkaXRhYmxlYFxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZWRpdGFibGUgJiYgdGhpcy52aWV3ICYmIHRoaXMudmlldy5lZGl0YWJsZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVkaXRvciBzdGF0ZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RhdGUoKTogRWRpdG9yU3RhdGUge1xuICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIFByb3NlTWlycm9yIHBsdWdpbi5cbiAgICpcbiAgICogQHBhcmFtIHBsdWdpbiBBIFByb3NlTWlycm9yIHBsdWdpblxuICAgKiBAcGFyYW0gaGFuZGxlUGx1Z2lucyBDb250cm9sIGhvdyB0byBtZXJnZSB0aGUgcGx1Z2luIGludG8gdGhlIGV4aXN0aW5nIHBsdWdpbnMuXG4gICAqL1xuICBwdWJsaWMgcmVnaXN0ZXJQbHVnaW4oXG4gICAgcGx1Z2luOiBQbHVnaW4sXG4gICAgaGFuZGxlUGx1Z2lucz86IChuZXdQbHVnaW46IFBsdWdpbiwgcGx1Z2luczogUGx1Z2luW10pID0+IFBsdWdpbltdLFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBwbHVnaW5zID0gaXNGdW5jdGlvbihoYW5kbGVQbHVnaW5zKVxuICAgICAgPyBoYW5kbGVQbHVnaW5zKHBsdWdpbiwgWy4uLnRoaXMuc3RhdGUucGx1Z2luc10pXG4gICAgICA6IFsuLi50aGlzLnN0YXRlLnBsdWdpbnMsIHBsdWdpbl1cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5yZWNvbmZpZ3VyZSh7IHBsdWdpbnMgfSlcblxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGEgUHJvc2VNaXJyb3IgcGx1Z2luLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZU9yUGx1Z2luS2V5IFRoZSBwbHVnaW5zIG5hbWVcbiAgICovXG4gIHB1YmxpYyB1bnJlZ2lzdGVyUGx1Z2luKG5hbWVPclBsdWdpbktleTogc3RyaW5nIHwgUGx1Z2luS2V5KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBuYW1lID0gdHlwZW9mIG5hbWVPclBsdWdpbktleSA9PT0gJ3N0cmluZycgPyBgJHtuYW1lT3JQbHVnaW5LZXl9JGAgOiBuYW1lT3JQbHVnaW5LZXkua2V5XG5cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUucmVjb25maWd1cmUoe1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcGx1Z2luczogdGhpcy5zdGF0ZS5wbHVnaW5zLmZpbHRlcihwbHVnaW4gPT4gIXBsdWdpbi5rZXkuc3RhcnRzV2l0aChuYW1lKSksXG4gICAgfSlcblxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGV4dGVuc2lvbiBtYW5hZ2VyLlxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVFeHRlbnNpb25NYW5hZ2VyKCk6IHZvaWQge1xuICAgIGNvbnN0IGNvcmVFeHRlbnNpb25zID0gdGhpcy5vcHRpb25zLmVuYWJsZUNvcmVFeHRlbnNpb25zID8gT2JqZWN0LnZhbHVlcyhleHRlbnNpb25zKSA6IFtdXG4gICAgY29uc3QgYWxsRXh0ZW5zaW9ucyA9IFsuLi5jb3JlRXh0ZW5zaW9ucywgLi4udGhpcy5vcHRpb25zLmV4dGVuc2lvbnNdLmZpbHRlcihleHRlbnNpb24gPT4ge1xuICAgICAgcmV0dXJuIFsnZXh0ZW5zaW9uJywgJ25vZGUnLCAnbWFyayddLmluY2x1ZGVzKGV4dGVuc2lvbj8udHlwZSlcbiAgICB9KVxuXG4gICAgdGhpcy5leHRlbnNpb25NYW5hZ2VyID0gbmV3IEV4dGVuc2lvbk1hbmFnZXIoYWxsRXh0ZW5zaW9ucywgdGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGNvbW1hbmQgbWFuYWdlci5cbiAgICovXG4gIHByaXZhdGUgY3JlYXRlQ29tbWFuZE1hbmFnZXIoKTogdm9pZCB7XG4gICAgdGhpcy5jb21tYW5kTWFuYWdlciA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgICBlZGl0b3I6IHRoaXMsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUHJvc2VNaXJyb3Igc2NoZW1hLlxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVTY2hlbWEoKTogdm9pZCB7XG4gICAgdGhpcy5zY2hlbWEgPSB0aGlzLmV4dGVuc2lvbk1hbmFnZXIuc2NoZW1hXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFByb3NlTWlycm9yIHZpZXcuXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZVZpZXcoKTogdm9pZCB7XG4gICAgY29uc3QgZG9jID0gY3JlYXRlRG9jdW1lbnQodGhpcy5vcHRpb25zLmNvbnRlbnQsIHRoaXMuc2NoZW1hLCB0aGlzLm9wdGlvbnMucGFyc2VPcHRpb25zKVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHJlc29sdmVGb2N1c1Bvc2l0aW9uKGRvYywgdGhpcy5vcHRpb25zLmF1dG9mb2N1cylcblxuICAgIHRoaXMudmlldyA9IG5ldyBFZGl0b3JWaWV3KHRoaXMub3B0aW9ucy5lbGVtZW50LCB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMsXG4gICAgICBkaXNwYXRjaFRyYW5zYWN0aW9uOiB0aGlzLmRpc3BhdGNoVHJhbnNhY3Rpb24uYmluZCh0aGlzKSxcbiAgICAgIHN0YXRlOiBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xuICAgICAgICBkb2MsXG4gICAgICAgIHNlbGVjdGlvbjogc2VsZWN0aW9uIHx8IHVuZGVmaW5lZCxcbiAgICAgIH0pLFxuICAgIH0pXG5cbiAgICAvLyBgZWRpdG9yLnZpZXdgIGlzIG5vdCB5ZXQgYXZhaWxhYmxlIGF0IHRoaXMgdGltZS5cbiAgICAvLyBUaGVyZWZvcmUgd2Ugd2lsbCBhZGQgYWxsIHBsdWdpbnMgYW5kIG5vZGUgdmlld3MgZGlyZWN0bHkgYWZ0ZXJ3YXJkcy5cbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuc3RhdGUucmVjb25maWd1cmUoe1xuICAgICAgcGx1Z2luczogdGhpcy5leHRlbnNpb25NYW5hZ2VyLnBsdWdpbnMsXG4gICAgfSlcblxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShuZXdTdGF0ZSlcblxuICAgIHRoaXMuY3JlYXRlTm9kZVZpZXdzKClcbiAgICB0aGlzLnByZXBlbmRDbGFzcygpXG5cbiAgICAvLyBMZXTigJlzIHN0b3JlIHRoZSBlZGl0b3IgaW5zdGFuY2UgaW4gdGhlIERPTSBlbGVtZW50LlxuICAgIC8vIFNvIHdl4oCZbGwgaGF2ZSBhY2Nlc3MgdG8gaXQgZm9yIHRlc3RzLlxuICAgIGNvbnN0IGRvbSA9IHRoaXMudmlldy5kb20gYXMgSFRNTEVsZW1lbnRcblxuICAgIGRvbS5lZGl0b3IgPSB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbGwgbm9kZSB2aWV3cy5cbiAgICovXG4gIHB1YmxpYyBjcmVhdGVOb2RlVmlld3MoKTogdm9pZCB7XG4gICAgdGhpcy52aWV3LnNldFByb3BzKHtcbiAgICAgIG5vZGVWaWV3czogdGhpcy5leHRlbnNpb25NYW5hZ2VyLm5vZGVWaWV3cyxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFByZXBlbmQgY2xhc3MgbmFtZSB0byBlbGVtZW50LlxuICAgKi9cbiAgcHVibGljIHByZXBlbmRDbGFzcygpOiB2b2lkIHtcbiAgICB0aGlzLnZpZXcuZG9tLmNsYXNzTmFtZSA9IGB0aXB0YXAgJHt0aGlzLnZpZXcuZG9tLmNsYXNzTmFtZX1gXG4gIH1cblxuICBwdWJsaWMgaXNDYXB0dXJpbmdUcmFuc2FjdGlvbiA9IGZhbHNlXG5cbiAgcHJpdmF0ZSBjYXB0dXJlZFRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbiB8IG51bGwgPSBudWxsXG5cbiAgcHVibGljIGNhcHR1cmVUcmFuc2FjdGlvbihmbjogRnVuY3Rpb24pIHtcbiAgICB0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSB0cnVlXG4gICAgZm4oKVxuICAgIHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbiA9IGZhbHNlXG5cbiAgICBjb25zdCB0ciA9IHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvblxuXG4gICAgdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uID0gbnVsbFxuXG4gICAgcmV0dXJuIHRyXG4gIH1cblxuICAvKipcbiAgICogVGhlIGNhbGxiYWNrIG92ZXIgd2hpY2ggdG8gc2VuZCB0cmFuc2FjdGlvbnMgKHN0YXRlIHVwZGF0ZXMpIHByb2R1Y2VkIGJ5IHRoZSB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gQW4gZWRpdG9yIHN0YXRlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBwcml2YXRlIGRpc3BhdGNoVHJhbnNhY3Rpb24odHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uKTogdm9pZCB7XG4gICAgLy8gaWYgdGhlIGVkaXRvciAvIHRoZSB2aWV3IG9mIHRoZSBlZGl0b3Igd2FzIGRlc3Ryb3llZFxuICAgIC8vIHRoZSB0cmFuc2FjdGlvbiBzaG91bGQgbm90IGJlIGRpc3BhdGNoZWQgYXMgdGhlcmUgaXMgbm8gdmlldyBhbnltb3JlLlxuICAgIGlmICh0aGlzLnZpZXcuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24pIHtcbiAgICAgIGlmICghdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uXG5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRyYW5zYWN0aW9uLnN0ZXBzLmZvckVhY2goc3RlcCA9PiB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24/LnN0ZXAoc3RlcCkpXG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5hcHBseSh0cmFuc2FjdGlvbilcbiAgICBjb25zdCBzZWxlY3Rpb25IYXNDaGFuZ2VkID0gIXRoaXMuc3RhdGUuc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbilcblxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSlcbiAgICB0aGlzLmVtaXQoJ3RyYW5zYWN0aW9uJywge1xuICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgfSlcblxuICAgIGlmIChzZWxlY3Rpb25IYXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLmVtaXQoJ3NlbGVjdGlvblVwZGF0ZScsIHtcbiAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3QgZm9jdXMgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCdmb2N1cycpXG4gICAgY29uc3QgYmx1ciA9IHRyYW5zYWN0aW9uLmdldE1ldGEoJ2JsdXInKVxuXG4gICAgaWYgKGZvY3VzKSB7XG4gICAgICB0aGlzLmVtaXQoJ2ZvY3VzJywge1xuICAgICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICAgIGV2ZW50OiBmb2N1cy5ldmVudCxcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChibHVyKSB7XG4gICAgICB0aGlzLmVtaXQoJ2JsdXInLCB7XG4gICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgZXZlbnQ6IGJsdXIuZXZlbnQsXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoIXRyYW5zYWN0aW9uLmRvY0NoYW5nZWQgfHwgdHJhbnNhY3Rpb24uZ2V0TWV0YSgncHJldmVudFVwZGF0ZScpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHtcbiAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0IGF0dHJpYnV0ZXMgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBub2RlIG9yIG1hcmsuXG4gICAqL1xuICBwdWJsaWMgZ2V0QXR0cmlidXRlcyhuYW1lT3JUeXBlOiBzdHJpbmcgfCBOb2RlVHlwZSB8IE1hcmtUeXBlKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgcmV0dXJuIGdldEF0dHJpYnV0ZXModGhpcy5zdGF0ZSwgbmFtZU9yVHlwZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZSBvciBtYXJrIGlzIGFjdGl2ZS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgbm9kZSBvciBtYXJrXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVzIEF0dHJpYnV0ZXMgb2YgdGhlIG5vZGUgb3IgbWFya1xuICAgKi9cbiAgcHVibGljIGlzQWN0aXZlKG5hbWU6IHN0cmluZywgYXR0cmlidXRlcz86IHt9KTogYm9vbGVhblxuICBwdWJsaWMgaXNBY3RpdmUoYXR0cmlidXRlczoge30pOiBib29sZWFuXG4gIHB1YmxpYyBpc0FjdGl2ZShuYW1lT3JBdHRyaWJ1dGVzOiBzdHJpbmcsIGF0dHJpYnV0ZXNPclVuZGVmaW5lZD86IHt9KTogYm9vbGVhbiB7XG4gICAgY29uc3QgbmFtZSA9IHR5cGVvZiBuYW1lT3JBdHRyaWJ1dGVzID09PSAnc3RyaW5nJyA/IG5hbWVPckF0dHJpYnV0ZXMgOiBudWxsXG5cbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gdHlwZW9mIG5hbWVPckF0dHJpYnV0ZXMgPT09ICdzdHJpbmcnID8gYXR0cmlidXRlc09yVW5kZWZpbmVkIDogbmFtZU9yQXR0cmlidXRlc1xuXG4gICAgcmV0dXJuIGlzQWN0aXZlKHRoaXMuc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkb2N1bWVudCBhcyBKU09OLlxuICAgKi9cbiAgcHVibGljIGdldEpTT04oKTogSlNPTkNvbnRlbnQge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmRvYy50b0pTT04oKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgSFRNTC5cbiAgICovXG4gIHB1YmxpYyBnZXRIVE1MKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGdldEhUTUxGcm9tRnJhZ21lbnQodGhpcy5zdGF0ZS5kb2MuY29udGVudCwgdGhpcy5zY2hlbWEpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkb2N1bWVudCBhcyB0ZXh0LlxuICAgKi9cbiAgcHVibGljIGdldFRleHQob3B0aW9ucz86IHtcbiAgICBibG9ja1NlcGFyYXRvcj86IHN0cmluZ1xuICAgIHRleHRTZXJpYWxpemVycz86IFJlY29yZDxzdHJpbmcsIFRleHRTZXJpYWxpemVyPlxuICB9KTogc3RyaW5nIHtcbiAgICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gJ1xcblxcbicsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9XG5cbiAgICByZXR1cm4gZ2V0VGV4dCh0aGlzLnN0YXRlLmRvYywge1xuICAgICAgYmxvY2tTZXBhcmF0b3IsXG4gICAgICB0ZXh0U2VyaWFsaXplcnM6IHtcbiAgICAgICAgLi4uZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSh0aGlzLnNjaGVtYSksXG4gICAgICAgIC4uLnRleHRTZXJpYWxpemVycyxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGVyZSBpcyBubyBjb250ZW50LlxuICAgKi9cbiAgcHVibGljIGdldCBpc0VtcHR5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc05vZGVFbXB0eSh0aGlzLnN0YXRlLmRvYylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGZvciB0aGUgY3VycmVudCBkb2N1bWVudC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHB1YmxpYyBnZXRDaGFyYWN0ZXJDb3VudCgpOiBudW1iZXIge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdbdGlwdGFwIHdhcm5dOiBcImVkaXRvci5nZXRDaGFyYWN0ZXJDb3VudCgpXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImVkaXRvci5zdG9yYWdlLmNoYXJhY3RlckNvdW50LmNoYXJhY3RlcnMoKVwiIGluc3RlYWQuJyxcbiAgICApXG5cbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5kb2MuY29udGVudC5zaXplIC0gMlxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIGVkaXRvci5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuZW1pdCgnZGVzdHJveScpXG5cbiAgICBpZiAodGhpcy52aWV3KSB7XG4gICAgICB0aGlzLnZpZXcuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBlZGl0b3IgaXMgYWxyZWFkeSBkZXN0cm95ZWQuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGlzRGVzdHJveWVkKCk6IGJvb2xlYW4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gIXRoaXMudmlldz8uZG9jVmlld1xuICB9XG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXRNYXJrc0JldHdlZW4gfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtzQmV0d2Vlbi5qcydcbmltcG9ydCB7IElucHV0UnVsZSwgSW5wdXRSdWxlRmluZGVyIH0gZnJvbSAnLi4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBhZGRzIGEgbWFyayB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXJrSW5wdXRSdWxlKGNvbmZpZzoge1xuICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXJcbiAgdHlwZTogTWFya1R5cGVcbiAgZ2V0QXR0cmlidXRlcz86XG4gICAgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICAgfCAoKG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkpID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgfCBmYWxzZVxuICAgIHwgbnVsbFxufSkge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKVxuXG4gICAgICBpZiAoYXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgYXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZVxuICAgICAgY29uc3QgY2FwdHVyZUdyb3VwID0gbWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV1cbiAgICAgIGNvbnN0IGZ1bGxNYXRjaCA9IG1hdGNoWzBdXG5cbiAgICAgIGlmIChjYXB0dXJlR3JvdXApIHtcbiAgICAgICAgY29uc3Qgc3RhcnRTcGFjZXMgPSBmdWxsTWF0Y2guc2VhcmNoKC9cXFMvKVxuICAgICAgICBjb25zdCB0ZXh0U3RhcnQgPSByYW5nZS5mcm9tICsgZnVsbE1hdGNoLmluZGV4T2YoY2FwdHVyZUdyb3VwKVxuICAgICAgICBjb25zdCB0ZXh0RW5kID0gdGV4dFN0YXJ0ICsgY2FwdHVyZUdyb3VwLmxlbmd0aFxuXG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVkTWFya3MgPSBnZXRNYXJrc0JldHdlZW4ocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHN0YXRlLmRvYylcbiAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgZXhjbHVkZWQgPSBpdGVtLm1hcmsudHlwZS5leGNsdWRlZCBhcyBNYXJrVHlwZVtdXG5cbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlZC5maW5kKHR5cGUgPT4gdHlwZSA9PT0gY29uZmlnLnR5cGUgJiYgdHlwZSAhPT0gaXRlbS5tYXJrLnR5cGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS50byA+IHRleHRTdGFydClcblxuICAgICAgICBpZiAoZXhjbHVkZWRNYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRFbmQgPCByYW5nZS50bykge1xuICAgICAgICAgIHRyLmRlbGV0ZSh0ZXh0RW5kLCByYW5nZS50bylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0U3RhcnQgPiByYW5nZS5mcm9tKSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgdGV4dFN0YXJ0KVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWFya0VuZCA9IHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcyArIGNhcHR1cmVHcm91cC5sZW5ndGhcblxuICAgICAgICB0ci5hZGRNYXJrKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgbWFya0VuZCwgY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMgfHwge30pKVxuXG4gICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsoY29uZmlnLnR5cGUpXG4gICAgICB9XG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IElucHV0UnVsZSwgSW5wdXRSdWxlRmluZGVyIH0gZnJvbSAnLi4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBhZGRzIGEgbm9kZSB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub2RlSW5wdXRSdWxlKGNvbmZpZzoge1xuICAvKipcbiAgICogVGhlIHJlZ2V4IHRvIG1hdGNoLlxuICAgKi9cbiAgZmluZDogSW5wdXRSdWxlRmluZGVyXG5cbiAgLyoqXG4gICAqIFRoZSBub2RlIHR5cGUgdG8gYWRkLlxuICAgKi9cbiAgdHlwZTogTm9kZVR5cGVcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGF0dHJpYnV0ZXMgZm9yIHRoZSBub2RlXG4gICAqIGNhbiBhbHNvIGJlIGFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzXG4gICAqL1xuICBnZXRBdHRyaWJ1dGVzPzpcbiAgICB8IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICB8ICgobWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICB8IGZhbHNlXG4gICAgfCBudWxsXG59KSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gpIHx8IHt9XG4gICAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZVxuICAgICAgY29uc3Qgc3RhcnQgPSByYW5nZS5mcm9tXG4gICAgICBsZXQgZW5kID0gcmFuZ2UudG9cblxuICAgICAgY29uc3QgbmV3Tm9kZSA9IGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzKVxuXG4gICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbWF0Y2hbMF0ubGFzdEluZGV4T2YobWF0Y2hbMV0pXG4gICAgICAgIGxldCBtYXRjaFN0YXJ0ID0gc3RhcnQgKyBvZmZzZXRcblxuICAgICAgICBpZiAobWF0Y2hTdGFydCA+IGVuZCkge1xuICAgICAgICAgIG1hdGNoU3RhcnQgPSBlbmRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmQgPSBtYXRjaFN0YXJ0ICsgbWF0Y2hbMV0ubGVuZ3RoXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbnNlcnQgbGFzdCB0eXBlZCBjaGFyYWN0ZXJcbiAgICAgICAgY29uc3QgbGFzdENoYXIgPSBtYXRjaFswXVttYXRjaFswXS5sZW5ndGggLSAxXVxuXG4gICAgICAgIHRyLmluc2VydFRleHQobGFzdENoYXIsIHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoIC0gMSlcblxuICAgICAgICAvLyBpbnNlcnQgbm9kZSBmcm9tIGlucHV0IHJ1bGVcbiAgICAgICAgdHIucmVwbGFjZVdpdGgobWF0Y2hTdGFydCwgZW5kLCBuZXdOb2RlKVxuICAgICAgfSBlbHNlIGlmIChtYXRjaFswXSkge1xuICAgICAgICB0ci5pbnNlcnQoc3RhcnQgLSAxLCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcykpLmRlbGV0ZShcbiAgICAgICAgICB0ci5tYXBwaW5nLm1hcChzdGFydCksXG4gICAgICAgICAgdHIubWFwcGluZy5tYXAoZW5kKSxcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB0ci5zY3JvbGxJbnRvVmlldygpXG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IElucHV0UnVsZSwgSW5wdXRSdWxlRmluZGVyIH0gZnJvbSAnLi4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBjaGFuZ2VzIHRoZSB0eXBlIG9mIGEgdGV4dGJsb2NrIHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC4gV2hlbiB1c2luZyBhIHJlZ3VsYXIgZXhwcmVzaW9uIHlvdeKAmWxsXG4gKiBwcm9iYWJseSB3YW50IHRoZSByZWdleHAgdG8gc3RhcnQgd2l0aCBgXmAsIHNvIHRoYXQgdGhlIHBhdHRlcm4gY2FuXG4gKiBvbmx5IG9jY3VyIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoY29uZmlnOiB7XG4gIGZpbmQ6IElucHV0UnVsZUZpbmRlclxuICB0eXBlOiBOb2RlVHlwZVxuICBnZXRBdHRyaWJ1dGVzPzpcbiAgICB8IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICB8ICgobWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICB8IGZhbHNlXG4gICAgfCBudWxsXG59KSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGNvbnN0ICRzdGFydCA9IHN0YXRlLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20pXG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKSB8fCB7fVxuXG4gICAgICBpZiAoISRzdGFydC5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkc3RhcnQuaW5kZXgoLTEpLCAkc3RhcnQuaW5kZXhBZnRlcigtMSksIGNvbmZpZy50eXBlKSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBzdGF0ZS50clxuICAgICAgICAuZGVsZXRlKHJhbmdlLmZyb20sIHJhbmdlLnRvKVxuICAgICAgICAuc2V0QmxvY2tUeXBlKHJhbmdlLmZyb20sIHJhbmdlLmZyb20sIGNvbmZpZy50eXBlLCBhdHRyaWJ1dGVzKVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgSW5wdXRSdWxlLCBJbnB1dFJ1bGVGaW5kZXIgfSBmcm9tICcuLi9JbnB1dFJ1bGUuanMnXG5cbi8qKlxuICogQnVpbGQgYW4gaW5wdXQgcnVsZSB0aGF0IHJlcGxhY2VzIHRleHQgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyB0eXBlZCBpbnRvIGl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGV4dElucHV0UnVsZShjb25maWc6IHtcbiAgZmluZDogSW5wdXRSdWxlRmluZGVyLFxuICByZXBsYWNlOiBzdHJpbmcsXG59KSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGxldCBpbnNlcnQgPSBjb25maWcucmVwbGFjZVxuICAgICAgbGV0IHN0YXJ0ID0gcmFuZ2UuZnJvbVxuICAgICAgY29uc3QgZW5kID0gcmFuZ2UudG9cblxuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKVxuXG4gICAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpXG4gICAgICAgIHN0YXJ0ICs9IG9mZnNldFxuXG4gICAgICAgIGNvbnN0IGN1dE9mZiA9IHN0YXJ0IC0gZW5kXG5cbiAgICAgICAgaWYgKGN1dE9mZiA+IDApIHtcbiAgICAgICAgICBpbnNlcnQgPSBtYXRjaFswXS5zbGljZShvZmZzZXQgLSBjdXRPZmYsIG9mZnNldCkgKyBpbnNlcnRcbiAgICAgICAgICBzdGFydCA9IGVuZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IGNhbkpvaW4sIGZpbmRXcmFwcGluZyB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBJbnB1dFJ1bGUsIElucHV0UnVsZUZpbmRlciB9IGZyb20gJy4uL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIGZvciBhdXRvbWF0aWNhbGx5IHdyYXBwaW5nIGEgdGV4dGJsb2NrIHdoZW4gYVxuICogZ2l2ZW4gc3RyaW5nIGlzIHR5cGVkLiBXaGVuIHVzaW5nIGEgcmVndWxhciBleHByZXNpb24geW914oCZbGxcbiAqIHByb2JhYmx5IHdhbnQgdGhlIHJlZ2V4cCB0byBzdGFydCB3aXRoIGBeYCwgc28gdGhhdCB0aGUgcGF0dGVybiBjYW5cbiAqIG9ubHkgb2NjdXIgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuICpcbiAqIGB0eXBlYCBpcyB0aGUgdHlwZSBvZiBub2RlIHRvIHdyYXAgaW4uXG4gKlxuICogQnkgZGVmYXVsdCwgaWYgdGhlcmXigJlzIGEgbm9kZSB3aXRoIHRoZSBzYW1lIHR5cGUgYWJvdmUgdGhlIG5ld2x5XG4gKiB3cmFwcGVkIG5vZGUsIHRoZSBydWxlIHdpbGwgdHJ5IHRvIGpvaW4gdGhvc2VcbiAqIHR3byBub2Rlcy4gWW91IGNhbiBwYXNzIGEgam9pbiBwcmVkaWNhdGUsIHdoaWNoIHRha2VzIGEgcmVndWxhclxuICogZXhwcmVzc2lvbiBtYXRjaCBhbmQgdGhlIG5vZGUgYmVmb3JlIHRoZSB3cmFwcGVkIG5vZGUsIGFuZCBjYW5cbiAqIHJldHVybiBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciBhIGpvaW4gc2hvdWxkIGhhcHBlbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBwaW5nSW5wdXRSdWxlKGNvbmZpZzoge1xuICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXIsXG4gIHR5cGU6IE5vZGVUeXBlLFxuICBrZWVwTWFya3M/OiBib29sZWFuLFxuICBrZWVwQXR0cmlidXRlcz86IGJvb2xlYW4sXG4gIGVkaXRvcj86IEVkaXRvclxuICBnZXRBdHRyaWJ1dGVzPzpcbiAgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIHwgKChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5KSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICB8IGZhbHNlXG4gIHwgbnVsbFxuICAsXG4gIGpvaW5QcmVkaWNhdGU/OiAobWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSwgbm9kZTogUHJvc2VNaXJyb3JOb2RlKSA9PiBib29sZWFuLFxufSkge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHtcbiAgICAgIHN0YXRlLCByYW5nZSwgbWF0Y2gsIGNoYWluLFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gpIHx8IHt9XG4gICAgICBjb25zdCB0ciA9IHN0YXRlLnRyLmRlbGV0ZShyYW5nZS5mcm9tLCByYW5nZS50bylcbiAgICAgIGNvbnN0ICRzdGFydCA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20pXG4gICAgICBjb25zdCBibG9ja1JhbmdlID0gJHN0YXJ0LmJsb2NrUmFuZ2UoKVxuICAgICAgY29uc3Qgd3JhcHBpbmcgPSBibG9ja1JhbmdlICYmIGZpbmRXcmFwcGluZyhibG9ja1JhbmdlLCBjb25maWcudHlwZSwgYXR0cmlidXRlcylcblxuICAgICAgaWYgKCF3cmFwcGluZykge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICB0ci53cmFwKGJsb2NrUmFuZ2UsIHdyYXBwaW5nKVxuXG4gICAgICBpZiAoY29uZmlnLmtlZXBNYXJrcyAmJiBjb25maWcuZWRpdG9yKSB7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGVcbiAgICAgICAgY29uc3QgeyBzcGxpdHRhYmxlTWFya3MgfSA9IGNvbmZpZy5lZGl0b3IuZXh0ZW5zaW9uTWFuYWdlclxuICAgICAgICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSlcblxuICAgICAgICBpZiAobWFya3MpIHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSlcblxuICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb25maWcua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgLyoqIElmIHRoZSBub2RlVHlwZSBpcyBgYnVsbGV0TGlzdGAgb3IgYG9yZGVyZWRMaXN0YCBzZXQgdGhlIGBub2RlVHlwZWAgYXMgYGxpc3RJdGVtYCAqL1xuICAgICAgICBjb25zdCBub2RlVHlwZSA9IGNvbmZpZy50eXBlLm5hbWUgPT09ICdidWxsZXRMaXN0JyB8fCBjb25maWcudHlwZS5uYW1lID09PSAnb3JkZXJlZExpc3QnID8gJ2xpc3RJdGVtJyA6ICd0YXNrTGlzdCdcblxuICAgICAgICBjaGFpbigpLnVwZGF0ZUF0dHJpYnV0ZXMobm9kZVR5cGUsIGF0dHJpYnV0ZXMpLnJ1bigpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJlZm9yZSA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20gLSAxKS5ub2RlQmVmb3JlXG5cbiAgICAgIGlmIChcbiAgICAgICAgYmVmb3JlXG4gICAgICAgICYmIGJlZm9yZS50eXBlID09PSBjb25maWcudHlwZVxuICAgICAgICAmJiBjYW5Kb2luKHRyLmRvYywgcmFuZ2UuZnJvbSAtIDEpXG4gICAgICAgICYmICghY29uZmlnLmpvaW5QcmVkaWNhdGUgfHwgY29uZmlnLmpvaW5QcmVkaWNhdGUobWF0Y2gsIGJlZm9yZSkpXG4gICAgICApIHtcbiAgICAgICAgdHIuam9pbihyYW5nZS5mcm9tIC0gMSlcbiAgICAgIH1cbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7XG4gIERPTU91dHB1dFNwZWMsIE1hcmsgYXMgUHJvc2VNaXJyb3JNYXJrLCBNYXJrU3BlYywgTWFya1R5cGUsXG59IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4sIFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vaGVscGVycy9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IE1hcmtDb25maWcgfSBmcm9tICcuL2luZGV4LmpzJ1xuaW1wb3J0IHsgSW5wdXRSdWxlIH0gZnJvbSAnLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi9Ob2RlLmpzJ1xuaW1wb3J0IHsgUGFzdGVSdWxlIH0gZnJvbSAnLi9QYXN0ZVJ1bGUuanMnXG5pbXBvcnQge1xuICBBbnlDb25maWcsXG4gIEF0dHJpYnV0ZXMsXG4gIEV4dGVuc2lvbnMsXG4gIEdsb2JhbEF0dHJpYnV0ZXMsXG4gIEtleWJvYXJkU2hvcnRjdXRDb21tYW5kLFxuICBQYXJlbnRDb25maWcsXG4gIFJhd0NvbW1hbmRzLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuaW1wb3J0IHsgbWVyZ2VEZWVwIH0gZnJvbSAnLi91dGlsaXRpZXMvbWVyZ2VEZWVwLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgTWFya0NvbmZpZzxPcHRpb25zID0gYW55LCBTdG9yYWdlID0gYW55PiB7XG4gICAgW2tleTogc3RyaW5nXTogYW55XG5cbiAgICAvKipcbiAgICAgKiBOYW1lXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nXG5cbiAgICAvKipcbiAgICAgKiBQcmlvcml0eVxuICAgICAqL1xuICAgIHByaW9yaXR5PzogbnVtYmVyXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IG9wdGlvbnNcbiAgICAgKi9cbiAgICBkZWZhdWx0T3B0aW9ucz86IE9wdGlvbnNcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgT3B0aW9uc1xuICAgICAqL1xuICAgIGFkZE9wdGlvbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBwYXJlbnQ6IEV4Y2x1ZGU8UGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRPcHRpb25zJ10sIHVuZGVmaW5lZD5cbiAgICB9KSA9PiBPcHRpb25zXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IFN0b3JhZ2VcbiAgICAgKi9cbiAgICBhZGRTdG9yYWdlPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgcGFyZW50OiBFeGNsdWRlPFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkU3RvcmFnZSddLCB1bmRlZmluZWQ+XG4gICAgfSkgPT4gU3RvcmFnZVxuXG4gICAgLyoqXG4gICAgICogR2xvYmFsIGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBhZGRHbG9iYWxBdHRyaWJ1dGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEdsb2JhbEF0dHJpYnV0ZXMnXVxuICAgIH0pID0+IEdsb2JhbEF0dHJpYnV0ZXMgfCB7fVxuXG4gICAgLyoqXG4gICAgICogUmF3XG4gICAgICovXG4gICAgYWRkQ29tbWFuZHM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRDb21tYW5kcyddXG4gICAgfSkgPT4gUGFydGlhbDxSYXdDb21tYW5kcz5cblxuICAgIC8qKlxuICAgICAqIEtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAqL1xuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkS2V5Ym9hcmRTaG9ydGN1dHMnXVxuICAgIH0pID0+IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IEtleWJvYXJkU2hvcnRjdXRDb21tYW5kXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5wdXQgcnVsZXNcbiAgICAgKi9cbiAgICBhZGRJbnB1dFJ1bGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkSW5wdXRSdWxlcyddXG4gICAgfSkgPT4gSW5wdXRSdWxlW11cblxuICAgIC8qKlxuICAgICAqIFBhc3RlIHJ1bGVzXG4gICAgICovXG4gICAgYWRkUGFzdGVSdWxlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFBhc3RlUnVsZXMnXVxuICAgIH0pID0+IFBhc3RlUnVsZVtdXG5cbiAgICAvKipcbiAgICAgKiBQcm9zZU1pcnJvciBwbHVnaW5zXG4gICAgICovXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkUHJvc2VNaXJyb3JQbHVnaW5zJ11cbiAgICB9KSA9PiBQbHVnaW5bXVxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5zaW9uc1xuICAgICAqL1xuICAgIGFkZEV4dGVuc2lvbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkRXh0ZW5zaW9ucyddXG4gICAgfSkgPT4gRXh0ZW5zaW9uc1xuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIE5vZGUgU2NoZW1hXG4gICAgICovXG4gICAgZXh0ZW5kTm9kZVNjaGVtYT86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZXh0ZW5kTm9kZVNjaGVtYSddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHRlbnNpb246IE5vZGUsXG4gICAgICAgICkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIE1hcmsgU2NoZW1hXG4gICAgICovXG4gICAgZXh0ZW5kTWFya1NjaGVtYT86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZXh0ZW5kTWFya1NjaGVtYSddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHRlbnNpb246IE1hcmssXG4gICAgICAgICkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBub3QgcmVhZHkgeWV0LlxuICAgICAqL1xuICAgIG9uQmVmb3JlQ3JlYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uQmVmb3JlQ3JlYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyByZWFkeS5cbiAgICAgKi9cbiAgICBvbkNyZWF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkNyZWF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZW50IGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uVXBkYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uVXBkYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdGlvbiBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblNlbGVjdGlvblVwZGF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblNlbGVjdGlvblVwZGF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3Igc3RhdGUgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25UcmFuc2FjdGlvbj86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblRyYW5zYWN0aW9uJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25cbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cbiAgICAgKi9cbiAgICBvbkZvY3VzPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uRm9jdXMnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGV2ZW50OiBGb2N1c0V2ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzbuKAmXQgZm9jdXNlZCBhbnltb3JlLlxuICAgICAqL1xuICAgIG9uQmx1cj86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkJsdXInXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGV2ZW50OiBGb2N1c0V2ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBvbkRlc3Ryb3k/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25EZXN0cm95J11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogS2VlcCBtYXJrIGFmdGVyIHNwbGl0IG5vZGVcbiAgICAgKi9cbiAgICBrZWVwT25TcGxpdD86IGJvb2xlYW4gfCAoKCkgPT4gYm9vbGVhbilcblxuICAgIC8qKlxuICAgICAqIEluY2x1c2l2ZVxuICAgICAqL1xuICAgIGluY2x1c2l2ZT86XG4gICAgICB8IE1hcmtTcGVjWydpbmNsdXNpdmUnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydpbmNsdXNpdmUnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBNYXJrU3BlY1snaW5jbHVzaXZlJ10pXG5cbiAgICAvKipcbiAgICAgKiBFeGNsdWRlc1xuICAgICAqL1xuICAgIGV4Y2x1ZGVzPzpcbiAgICAgIHwgTWFya1NwZWNbJ2V4Y2x1ZGVzJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZXhjbHVkZXMnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBNYXJrU3BlY1snZXhjbHVkZXMnXSlcblxuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoaXMgTWFyayBhcyBleGl0YWJsZVxuICAgICAqL1xuICAgIGV4aXRhYmxlPzogYm9vbGVhbiB8ICgoKSA9PiBib29sZWFuKVxuXG4gICAgLyoqXG4gICAgICogR3JvdXBcbiAgICAgKi9cbiAgICBncm91cD86XG4gICAgICB8IE1hcmtTcGVjWydncm91cCddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2dyb3VwJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTWFya1NwZWNbJ2dyb3VwJ10pXG5cbiAgICAvKipcbiAgICAgKiBTcGFubmluZ1xuICAgICAqL1xuICAgIHNwYW5uaW5nPzpcbiAgICAgIHwgTWFya1NwZWNbJ3NwYW5uaW5nJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnc3Bhbm5pbmcnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBNYXJrU3BlY1snc3Bhbm5pbmcnXSlcblxuICAgIC8qKlxuICAgICAqIENvZGVcbiAgICAgKi9cbiAgICBjb2RlPzpcbiAgICAgIHwgYm9vbGVhblxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wydjb2RlJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gYm9vbGVhbilcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIEhUTUxcbiAgICAgKi9cbiAgICBwYXJzZUhUTUw/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsncGFyc2VIVE1MJ11cbiAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgIH0pID0+IE1hcmtTcGVjWydwYXJzZURPTSddXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgSFRNTFxuICAgICAqL1xuICAgIHJlbmRlckhUTUw/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3JlbmRlckhUTUwnXVxuICAgICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgbWFyazogUHJvc2VNaXJyb3JNYXJrXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gRE9NT3V0cHV0U3BlYylcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlc1xuICAgICAqL1xuICAgIGFkZEF0dHJpYnV0ZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkQXR0cmlidXRlcyddXG4gICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICB9KSA9PiBBdHRyaWJ1dGVzIHwge31cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWFyazxPcHRpb25zID0gYW55LCBTdG9yYWdlID0gYW55PiB7XG4gIHR5cGUgPSAnbWFyaydcblxuICBuYW1lID0gJ21hcmsnXG5cbiAgcGFyZW50OiBNYXJrIHwgbnVsbCA9IG51bGxcblxuICBjaGlsZDogTWFyayB8IG51bGwgPSBudWxsXG5cbiAgb3B0aW9uczogT3B0aW9uc1xuXG4gIHN0b3JhZ2U6IFN0b3JhZ2VcblxuICBjb25maWc6IE1hcmtDb25maWcgPSB7XG4gICAgbmFtZTogdGhpcy5uYW1lLFxuICAgIGRlZmF1bHRPcHRpb25zOiB7fSxcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogUGFydGlhbDxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PiA9IHt9KSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIC4uLmNvbmZpZyxcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lXG5cbiAgICBpZiAoY29uZmlnLmRlZmF1bHRPcHRpb25zKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke3RoaXMubmFtZX1cIi5gLFxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSBgYWRkT3B0aW9uc2AgZmFsbGJhY2tcbiAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0T3B0aW9uc1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmFkZE9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IGNhbGxPclJldHVybihcbiAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRPcHRpb25zJ10+KHRoaXMsICdhZGRPcHRpb25zJywge1xuICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgfSksXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRTdG9yYWdlJ10+KHRoaXMsICdhZGRTdG9yYWdlJywge1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIH0pLFxuICAgICkgfHwge31cbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGU8TyA9IGFueSwgUyA9IGFueT4oY29uZmlnOiBQYXJ0aWFsPE1hcmtDb25maWc8TywgUz4+ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IE1hcms8TywgUz4oY29uZmlnKVxuICB9XG5cbiAgY29uZmlndXJlKG9wdGlvbnM6IFBhcnRpYWw8T3B0aW9ucz4gPSB7fSkge1xuICAgIC8vIHJldHVybiBhIG5ldyBpbnN0YW5jZSBzbyB3ZSBjYW4gdXNlIHRoZSBzYW1lIGV4dGVuc2lvblxuICAgIC8vIHdpdGggZGlmZmVyZW50IGNhbGxzIG9mIGBjb25maWd1cmVgXG4gICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5leHRlbmQoKVxuXG4gICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBtZXJnZURlZXAodGhpcy5vcHRpb25zIGFzIFJlY29yZDxzdHJpbmcsIGFueT4sIG9wdGlvbnMpIGFzIE9wdGlvbnNcblxuICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRTdG9yYWdlJ10+KGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIH0pLFxuICAgIClcblxuICAgIHJldHVybiBleHRlbnNpb25cbiAgfVxuXG4gIGV4dGVuZDxFeHRlbmRlZE9wdGlvbnMgPSBPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2UgPSBTdG9yYWdlPihcbiAgICBleHRlbmRlZENvbmZpZzogUGFydGlhbDxNYXJrQ29uZmlnPEV4dGVuZGVkT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlPj4gPSB7fSxcbiAgKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbmV3IE1hcms8RXh0ZW5kZWRPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2U+KGV4dGVuZGVkQ29uZmlnKVxuXG4gICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXNcblxuICAgIHRoaXMuY2hpbGQgPSBleHRlbnNpb25cblxuICAgIGV4dGVuc2lvbi5uYW1lID0gZXh0ZW5kZWRDb25maWcubmFtZSA/IGV4dGVuZGVkQ29uZmlnLm5hbWUgOiBleHRlbnNpb24ucGFyZW50Lm5hbWVcblxuICAgIGlmIChleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucykge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHtleHRlbnNpb24ubmFtZX1cIi5gLFxuICAgICAgKVxuICAgIH1cblxuICAgIGV4dGVuc2lvbi5vcHRpb25zID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRPcHRpb25zJ10+KGV4dGVuc2lvbiwgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4oZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG5cbiAgc3RhdGljIGhhbmRsZUV4aXQoeyBlZGl0b3IsIG1hcmsgfTogeyBlZGl0b3I6IEVkaXRvcjsgbWFyazogTWFyayB9KSB7XG4gICAgY29uc3QgeyB0ciB9ID0gZWRpdG9yLnN0YXRlXG4gICAgY29uc3QgY3VycmVudFBvcyA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uJGZyb21cbiAgICBjb25zdCBpc0F0RW5kID0gY3VycmVudFBvcy5wb3MgPT09IGN1cnJlbnRQb3MuZW5kKClcblxuICAgIGlmIChpc0F0RW5kKSB7XG4gICAgICBjb25zdCBjdXJyZW50TWFya3MgPSBjdXJyZW50UG9zLm1hcmtzKClcbiAgICAgIGNvbnN0IGlzSW5NYXJrID0gISFjdXJyZW50TWFya3MuZmluZChtID0+IG0/LnR5cGUubmFtZSA9PT0gbWFyay5uYW1lKVxuXG4gICAgICBpZiAoIWlzSW5NYXJrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZW1vdmVNYXJrID0gY3VycmVudE1hcmtzLmZpbmQobSA9PiBtPy50eXBlLm5hbWUgPT09IG1hcmsubmFtZSlcblxuICAgICAgaWYgKHJlbW92ZU1hcmspIHtcbiAgICAgICAgdHIucmVtb3ZlU3RvcmVkTWFyayhyZW1vdmVNYXJrKVxuICAgICAgfVxuICAgICAgdHIuaW5zZXJ0VGV4dCgnICcsIGN1cnJlbnRQb3MucG9zKVxuXG4gICAgICBlZGl0b3Iudmlldy5kaXNwYXRjaCh0cilcblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIERPTU91dHB1dFNwZWMsIE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLCBOb2RlU3BlYywgTm9kZVR5cGUsXG59IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4sIFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vaGVscGVycy9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IE5vZGVDb25maWcgfSBmcm9tICcuL2luZGV4LmpzJ1xuaW1wb3J0IHsgSW5wdXRSdWxlIH0gZnJvbSAnLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgeyBQYXN0ZVJ1bGUgfSBmcm9tICcuL1Bhc3RlUnVsZS5qcydcbmltcG9ydCB7XG4gIEFueUNvbmZpZyxcbiAgQXR0cmlidXRlcyxcbiAgRXh0ZW5zaW9ucyxcbiAgR2xvYmFsQXR0cmlidXRlcyxcbiAgS2V5Ym9hcmRTaG9ydGN1dENvbW1hbmQsXG4gIE5vZGVWaWV3UmVuZGVyZXIsXG4gIFBhcmVudENvbmZpZyxcbiAgUmF3Q29tbWFuZHMsXG59IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5pbXBvcnQgeyBtZXJnZURlZXAgfSBmcm9tICcuL3V0aWxpdGllcy9tZXJnZURlZXAuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIE5vZGVDb25maWc8T3B0aW9ucyA9IGFueSwgU3RvcmFnZSA9IGFueT4ge1xuICAgIFtrZXk6IHN0cmluZ106IGFueVxuXG4gICAgLyoqXG4gICAgICogTmFtZVxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZ1xuXG4gICAgLyoqXG4gICAgICogUHJpb3JpdHlcbiAgICAgKi9cbiAgICBwcmlvcml0eT86IG51bWJlclxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBvcHRpb25zXG4gICAgICovXG4gICAgZGVmYXVsdE9wdGlvbnM/OiBPcHRpb25zXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IE9wdGlvbnNcbiAgICAgKi9cbiAgICBhZGRPcHRpb25zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgcGFyZW50OiBFeGNsdWRlPFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkT3B0aW9ucyddLCB1bmRlZmluZWQ+XG4gICAgfSkgPT4gT3B0aW9uc1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBTdG9yYWdlXG4gICAgICovXG4gICAgYWRkU3RvcmFnZT86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHBhcmVudDogRXhjbHVkZTxQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFN0b3JhZ2UnXSwgdW5kZWZpbmVkPlxuICAgIH0pID0+IFN0b3JhZ2VcblxuICAgIC8qKlxuICAgICAqIEdsb2JhbCBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgYWRkR2xvYmFsQXR0cmlidXRlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRHbG9iYWxBdHRyaWJ1dGVzJ11cbiAgICB9KSA9PiBHbG9iYWxBdHRyaWJ1dGVzIHwge31cblxuICAgIC8qKlxuICAgICAqIFJhd1xuICAgICAqL1xuICAgIGFkZENvbW1hbmRzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkQ29tbWFuZHMnXVxuICAgIH0pID0+IFBhcnRpYWw8UmF3Q29tbWFuZHM+XG5cbiAgICAvKipcbiAgICAgKiBLZXlib2FyZCBzaG9ydGN1dHNcbiAgICAgKi9cbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEtleWJvYXJkU2hvcnRjdXRzJ11cbiAgICB9KSA9PiB7XG4gICAgICBba2V5OiBzdHJpbmddOiBLZXlib2FyZFNob3J0Y3V0Q29tbWFuZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElucHV0IHJ1bGVzXG4gICAgICovXG4gICAgYWRkSW5wdXRSdWxlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZElucHV0UnVsZXMnXVxuICAgIH0pID0+IElucHV0UnVsZVtdXG5cbiAgICAvKipcbiAgICAgKiBQYXN0ZSBydWxlc1xuICAgICAqL1xuICAgIGFkZFBhc3RlUnVsZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRQYXN0ZVJ1bGVzJ11cbiAgICB9KSA9PiBQYXN0ZVJ1bGVbXVxuXG4gICAgLyoqXG4gICAgICogUHJvc2VNaXJyb3IgcGx1Z2luc1xuICAgICAqL1xuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFByb3NlTWlycm9yUGx1Z2lucyddXG4gICAgfSkgPT4gUGx1Z2luW11cblxuICAgIC8qKlxuICAgICAqIEV4dGVuc2lvbnNcbiAgICAgKi9cbiAgICBhZGRFeHRlbnNpb25zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEV4dGVuc2lvbnMnXVxuICAgIH0pID0+IEV4dGVuc2lvbnNcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBOb2RlIFNjaGVtYVxuICAgICAqL1xuICAgIGV4dGVuZE5vZGVTY2hlbWE/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4dGVuZE5vZGVTY2hlbWEnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXh0ZW5zaW9uOiBOb2RlLFxuICAgICAgICApID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBNYXJrIFNjaGVtYVxuICAgICAqL1xuICAgIGV4dGVuZE1hcmtTY2hlbWE/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4dGVuZE1hcmtTY2hlbWEnXVxuICAgICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHRlbnNpb246IE5vZGUsXG4gICAgICAgICkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBub3QgcmVhZHkgeWV0LlxuICAgICAqL1xuICAgIG9uQmVmb3JlQ3JlYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uQmVmb3JlQ3JlYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyByZWFkeS5cbiAgICAgKi9cbiAgICBvbkNyZWF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkNyZWF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZW50IGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uVXBkYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uVXBkYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdGlvbiBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblNlbGVjdGlvblVwZGF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblNlbGVjdGlvblVwZGF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3Igc3RhdGUgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25UcmFuc2FjdGlvbj86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblRyYW5zYWN0aW9uJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25cbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cbiAgICAgKi9cbiAgICBvbkZvY3VzPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uRm9jdXMnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGV2ZW50OiBGb2N1c0V2ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzbuKAmXQgZm9jdXNlZCBhbnltb3JlLlxuICAgICAqL1xuICAgIG9uQmx1cj86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkJsdXInXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGV2ZW50OiBGb2N1c0V2ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBvbkRlc3Ryb3k/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25EZXN0cm95J11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogTm9kZSBWaWV3XG4gICAgICovXG4gICAgYWRkTm9kZVZpZXc/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkTm9kZVZpZXcnXVxuICAgICAgICB9KSA9PiBOb2RlVmlld1JlbmRlcmVyKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUb3BOb2RlXG4gICAgICovXG4gICAgdG9wTm9kZT86IGJvb2xlYW5cblxuICAgIC8qKlxuICAgICAqIENvbnRlbnRcbiAgICAgKi9cbiAgICBjb250ZW50PzpcbiAgICAgIHwgTm9kZVNwZWNbJ2NvbnRlbnQnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wydjb250ZW50J11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2NvbnRlbnQnXSlcblxuICAgIC8qKlxuICAgICAqIE1hcmtzXG4gICAgICovXG4gICAgbWFya3M/OlxuICAgICAgfCBOb2RlU3BlY1snbWFya3MnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydtYXJrcyddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydtYXJrcyddKVxuXG4gICAgLyoqXG4gICAgICogR3JvdXBcbiAgICAgKi9cbiAgICBncm91cD86XG4gICAgICB8IE5vZGVTcGVjWydncm91cCddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2dyb3VwJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2dyb3VwJ10pXG5cbiAgICAvKipcbiAgICAgKiBJbmxpbmVcbiAgICAgKi9cbiAgICBpbmxpbmU/OlxuICAgICAgfCBOb2RlU3BlY1snaW5saW5lJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnaW5saW5lJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2lubGluZSddKVxuXG4gICAgLyoqXG4gICAgICogQXRvbVxuICAgICAqL1xuICAgIGF0b20/OlxuICAgICAgfCBOb2RlU3BlY1snYXRvbSddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2F0b20nXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snYXRvbSddKVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0YWJsZVxuICAgICAqL1xuICAgIHNlbGVjdGFibGU/OlxuICAgICAgfCBOb2RlU3BlY1snc2VsZWN0YWJsZSddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3NlbGVjdGFibGUnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snc2VsZWN0YWJsZSddKVxuXG4gICAgLyoqXG4gICAgICogRHJhZ2dhYmxlXG4gICAgICovXG4gICAgZHJhZ2dhYmxlPzpcbiAgICAgIHwgTm9kZVNwZWNbJ2RyYWdnYWJsZSddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2RyYWdnYWJsZSddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydkcmFnZ2FibGUnXSlcblxuICAgIC8qKlxuICAgICAqIENvZGVcbiAgICAgKi9cbiAgICBjb2RlPzpcbiAgICAgIHwgTm9kZVNwZWNbJ2NvZGUnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wydjb2RlJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2NvZGUnXSlcblxuICAgIC8qKlxuICAgICAqIFdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICB3aGl0ZXNwYWNlPzpcbiAgICAgIHwgTm9kZVNwZWNbJ3doaXRlc3BhY2UnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wyd3aGl0ZXNwYWNlJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ3doaXRlc3BhY2UnXSlcblxuICAgIC8qKlxuICAgICAqIERlZmluaW5nXG4gICAgICovXG4gICAgZGVmaW5pbmc/OlxuICAgICAgfCBOb2RlU3BlY1snZGVmaW5pbmcnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydkZWZpbmluZyddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydkZWZpbmluZyddKVxuXG4gICAgLyoqXG4gICAgICogSXNvbGF0aW5nXG4gICAgICovXG4gICAgaXNvbGF0aW5nPzpcbiAgICAgIHwgTm9kZVNwZWNbJ2lzb2xhdGluZyddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2lzb2xhdGluZyddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydpc29sYXRpbmcnXSlcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIEhUTUxcbiAgICAgKi9cbiAgICBwYXJzZUhUTUw/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsncGFyc2VIVE1MJ11cbiAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgIH0pID0+IE5vZGVTcGVjWydwYXJzZURPTSddXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgSFRNTFxuICAgICAqL1xuICAgIHJlbmRlckhUTUw/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3JlbmRlckhUTUwnXVxuICAgICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgbm9kZTogUHJvc2VNaXJyb3JOb2RlXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gRE9NT3V0cHV0U3BlYylcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIFRleHRcbiAgICAgKi9cbiAgICByZW5kZXJUZXh0PzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydyZW5kZXJUZXh0J11cbiAgICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIG5vZGU6IFByb3NlTWlycm9yTm9kZVxuICAgICAgICAgICAgcG9zOiBudW1iZXJcbiAgICAgICAgICAgIHBhcmVudDogUHJvc2VNaXJyb3JOb2RlXG4gICAgICAgICAgICBpbmRleDogbnVtYmVyXG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiBzdHJpbmcpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIEFkZCBBdHRyaWJ1dGVzXG4gICAgICovXG4gICAgYWRkQXR0cmlidXRlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRBdHRyaWJ1dGVzJ11cbiAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgIH0pID0+IEF0dHJpYnV0ZXMgfCB7fVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBOb2RlPE9wdGlvbnMgPSBhbnksIFN0b3JhZ2UgPSBhbnk+IHtcbiAgdHlwZSA9ICdub2RlJ1xuXG4gIG5hbWUgPSAnbm9kZSdcblxuICBwYXJlbnQ6IE5vZGUgfCBudWxsID0gbnVsbFxuXG4gIGNoaWxkOiBOb2RlIHwgbnVsbCA9IG51bGxcblxuICBvcHRpb25zOiBPcHRpb25zXG5cbiAgc3RvcmFnZTogU3RvcmFnZVxuXG4gIGNvbmZpZzogTm9kZUNvbmZpZyA9IHtcbiAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgZGVmYXVsdE9wdGlvbnM6IHt9LFxuICB9XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBQYXJ0aWFsPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+ID0ge30pIHtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgLi4uY29uZmlnLFxuICAgIH1cblxuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uZmlnLm5hbWVcblxuICAgIGlmIChjb25maWcuZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7dGhpcy5uYW1lfVwiLmAsXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGBhZGRPcHRpb25zYCBmYWxsYmFja1xuICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuY29uZmlnLmRlZmF1bHRPcHRpb25zXG5cbiAgICBpZiAodGhpcy5jb25maWcuYWRkT3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gY2FsbE9yUmV0dXJuKFxuICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZE9wdGlvbnMnXT4odGhpcywgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4odGhpcywgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKSB8fCB7fVxuICB9XG5cbiAgc3RhdGljIGNyZWF0ZTxPID0gYW55LCBTID0gYW55Pihjb25maWc6IFBhcnRpYWw8Tm9kZUNvbmZpZzxPLCBTPj4gPSB7fSkge1xuICAgIHJldHVybiBuZXcgTm9kZTxPLCBTPihjb25maWcpXG4gIH1cblxuICBjb25maWd1cmUob3B0aW9uczogUGFydGlhbDxPcHRpb25zPiA9IHt9KSB7XG4gICAgLy8gcmV0dXJuIGEgbmV3IGluc3RhbmNlIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgZXh0ZW5zaW9uXG4gICAgLy8gd2l0aCBkaWZmZXJlbnQgY2FsbHMgb2YgYGNvbmZpZ3VyZWBcbiAgICBjb25zdCBleHRlbnNpb24gPSB0aGlzLmV4dGVuZCgpXG5cbiAgICBleHRlbnNpb24ub3B0aW9ucyA9IG1lcmdlRGVlcCh0aGlzLm9wdGlvbnMgYXMgUmVjb3JkPHN0cmluZywgYW55Piwgb3B0aW9ucykgYXMgT3B0aW9uc1xuXG4gICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4oZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG5cbiAgZXh0ZW5kPEV4dGVuZGVkT3B0aW9ucyA9IE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZSA9IFN0b3JhZ2U+KFxuICAgIGV4dGVuZGVkQ29uZmlnOiBQYXJ0aWFsPE5vZGVDb25maWc8RXh0ZW5kZWRPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2U+PiA9IHt9LFxuICApIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSBuZXcgTm9kZTxFeHRlbmRlZE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZT4oZXh0ZW5kZWRDb25maWcpXG5cbiAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpc1xuXG4gICAgdGhpcy5jaGlsZCA9IGV4dGVuc2lvblxuXG4gICAgZXh0ZW5zaW9uLm5hbWUgPSBleHRlbmRlZENvbmZpZy5uYW1lID8gZXh0ZW5kZWRDb25maWcubmFtZSA6IGV4dGVuc2lvbi5wYXJlbnQubmFtZVxuXG4gICAgaWYgKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke2V4dGVuc2lvbi5uYW1lfVwiLmAsXG4gICAgICApXG4gICAgfVxuXG4gICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZE9wdGlvbnMnXT4oZXh0ZW5zaW9uLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPihleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICByZXR1cm4gZXh0ZW5zaW9uXG4gIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNBbmRyb2lkKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gbmF2aWdhdG9yLnBsYXRmb3JtID09PSAnQW5kcm9pZCcgfHwgL2FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBOb2RlVmlldyBhcyBQcm9zZU1pcnJvck5vZGVWaWV3IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3J1xuXG5pbXBvcnQgeyBFZGl0b3IgYXMgQ29yZUVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4vTm9kZS5qcydcbmltcG9ydCB7IERlY29yYXRpb25XaXRoVHlwZSwgTm9kZVZpZXdSZW5kZXJlck9wdGlvbnMsIE5vZGVWaWV3UmVuZGVyZXJQcm9wcyB9IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBpc0FuZHJvaWQgfSBmcm9tICcuL3V0aWxpdGllcy9pc0FuZHJvaWQuanMnXG5pbXBvcnQgeyBpc2lPUyB9IGZyb20gJy4vdXRpbGl0aWVzL2lzaU9TLmpzJ1xuXG5leHBvcnQgY2xhc3MgTm9kZVZpZXc8XG4gIENvbXBvbmVudCxcbiAgTm9kZUVkaXRvciBleHRlbmRzIENvcmVFZGl0b3IgPSBDb3JlRWRpdG9yLFxuICBPcHRpb25zIGV4dGVuZHMgTm9kZVZpZXdSZW5kZXJlck9wdGlvbnMgPSBOb2RlVmlld1JlbmRlcmVyT3B0aW9ucyxcbj4gaW1wbGVtZW50cyBQcm9zZU1pcnJvck5vZGVWaWV3IHtcbiAgY29tcG9uZW50OiBDb21wb25lbnRcblxuICBlZGl0b3I6IE5vZGVFZGl0b3JcblxuICBvcHRpb25zOiBPcHRpb25zXG5cbiAgZXh0ZW5zaW9uOiBOb2RlXG5cbiAgbm9kZTogUHJvc2VNaXJyb3JOb2RlXG5cbiAgZGVjb3JhdGlvbnM6IERlY29yYXRpb25XaXRoVHlwZVtdXG5cbiAgZ2V0UG9zOiBhbnlcblxuICBpc0RyYWdnaW5nID0gZmFsc2VcblxuICBjb25zdHJ1Y3Rvcihjb21wb25lbnQ6IENvbXBvbmVudCwgcHJvcHM6IE5vZGVWaWV3UmVuZGVyZXJQcm9wcywgb3B0aW9ucz86IFBhcnRpYWw8T3B0aW9ucz4pIHtcbiAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudFxuICAgIHRoaXMuZWRpdG9yID0gcHJvcHMuZWRpdG9yIGFzIE5vZGVFZGl0b3JcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBzdG9wRXZlbnQ6IG51bGwsXG4gICAgICBpZ25vcmVNdXRhdGlvbjogbnVsbCxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSBhcyBPcHRpb25zXG4gICAgdGhpcy5leHRlbnNpb24gPSBwcm9wcy5leHRlbnNpb25cbiAgICB0aGlzLm5vZGUgPSBwcm9wcy5ub2RlXG4gICAgdGhpcy5kZWNvcmF0aW9ucyA9IHByb3BzLmRlY29yYXRpb25zIGFzIERlY29yYXRpb25XaXRoVHlwZVtdXG4gICAgdGhpcy5nZXRQb3MgPSBwcm9wcy5nZXRQb3NcbiAgICB0aGlzLm1vdW50KClcbiAgfVxuXG4gIG1vdW50KCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHJldHVyblxuICB9XG5cbiAgZ2V0IGRvbSgpOiBIVE1MRWxlbWVudCB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yLnZpZXcuZG9tIGFzIEhUTUxFbGVtZW50XG4gIH1cblxuICBnZXQgY29udGVudERPTSgpOiBIVE1MRWxlbWVudCB8IG51bGwge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBvbkRyYWdTdGFydChldmVudDogRHJhZ0V2ZW50KSB7XG4gICAgY29uc3QgeyB2aWV3IH0gPSB0aGlzLmVkaXRvclxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudFxuXG4gICAgLy8gZ2V0IHRoZSBkcmFnIGhhbmRsZSBlbGVtZW50XG4gICAgLy8gYGNsb3Nlc3RgIGlzIG5vdCBhdmFpbGFibGUgZm9yIHRleHQgbm9kZXMgc28gd2UgbWF5IGhhdmUgdG8gdXNlIGl0cyBwYXJlbnRcbiAgICBjb25zdCBkcmFnSGFuZGxlID0gdGFyZ2V0Lm5vZGVUeXBlID09PSAzXG4gICAgICA/IHRhcmdldC5wYXJlbnRFbGVtZW50Py5jbG9zZXN0KCdbZGF0YS1kcmFnLWhhbmRsZV0nKVxuICAgICAgOiB0YXJnZXQuY2xvc2VzdCgnW2RhdGEtZHJhZy1oYW5kbGVdJylcblxuICAgIGlmICghdGhpcy5kb20gfHwgdGhpcy5jb250ZW50RE9NPy5jb250YWlucyh0YXJnZXQpIHx8ICFkcmFnSGFuZGxlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgeCA9IDBcbiAgICBsZXQgeSA9IDBcblxuICAgIC8vIGNhbGN1bGF0ZSBvZmZzZXQgZm9yIGRyYWcgZWxlbWVudCBpZiB3ZSB1c2UgYSBkaWZmZXJlbnQgZHJhZyBoYW5kbGUgZWxlbWVudFxuICAgIGlmICh0aGlzLmRvbSAhPT0gZHJhZ0hhbmRsZSkge1xuICAgICAgY29uc3QgZG9tQm94ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIGNvbnN0IGhhbmRsZUJveCA9IGRyYWdIYW5kbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICAgICAgLy8gSW4gUmVhY3QsIHdlIGhhdmUgdG8gZ28gdGhyb3VnaCBuYXRpdmVFdmVudCB0byByZWFjaCBvZmZzZXRYL29mZnNldFkuXG4gICAgICBjb25zdCBvZmZzZXRYID0gZXZlbnQub2Zmc2V0WCA/PyAoZXZlbnQgYXMgYW55KS5uYXRpdmVFdmVudD8ub2Zmc2V0WFxuICAgICAgY29uc3Qgb2Zmc2V0WSA9IGV2ZW50Lm9mZnNldFkgPz8gKGV2ZW50IGFzIGFueSkubmF0aXZlRXZlbnQ/Lm9mZnNldFlcblxuICAgICAgeCA9IGhhbmRsZUJveC54IC0gZG9tQm94LnggKyBvZmZzZXRYXG4gICAgICB5ID0gaGFuZGxlQm94LnkgLSBkb21Cb3gueSArIG9mZnNldFlcbiAgICB9XG5cbiAgICBldmVudC5kYXRhVHJhbnNmZXI/LnNldERyYWdJbWFnZSh0aGlzLmRvbSwgeCwgeSlcblxuICAgIC8vIHdlIG5lZWQgdG8gdGVsbCBQcm9zZU1pcnJvciB0aGF0IHdlIHdhbnQgdG8gbW92ZSB0aGUgd2hvbGUgbm9kZVxuICAgIC8vIHNvIHdlIGNyZWF0ZSBhIE5vZGVTZWxlY3Rpb25cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgdGhpcy5nZXRQb3MoKSlcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbilcblxuICAgIHZpZXcuZGlzcGF0Y2godHJhbnNhY3Rpb24pXG4gIH1cblxuICBzdG9wRXZlbnQoZXZlbnQ6IEV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmRvbSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuc3RvcEV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnN0b3BFdmVudCh7IGV2ZW50IH0pXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50XG4gICAgY29uc3QgaXNJbkVsZW1lbnQgPSB0aGlzLmRvbS5jb250YWlucyh0YXJnZXQpICYmICF0aGlzLmNvbnRlbnRET00/LmNvbnRhaW5zKHRhcmdldClcblxuICAgIC8vIGFueSBldmVudCBmcm9tIGNoaWxkIG5vZGVzIHNob3VsZCBiZSBoYW5kbGVkIGJ5IFByb3NlTWlycm9yXG4gICAgaWYgKCFpc0luRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgaXNEcmFnRXZlbnQgPSBldmVudC50eXBlLnN0YXJ0c1dpdGgoJ2RyYWcnKVxuICAgIGNvbnN0IGlzRHJvcEV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ2Ryb3AnXG4gICAgY29uc3QgaXNJbnB1dCA9IFsnSU5QVVQnLCAnQlVUVE9OJywgJ1NFTEVDVCcsICdURVhUQVJFQSddLmluY2x1ZGVzKHRhcmdldC50YWdOYW1lKSB8fCB0YXJnZXQuaXNDb250ZW50RWRpdGFibGVcblxuICAgIC8vIGFueSBpbnB1dCBldmVudCB3aXRoaW4gbm9kZSB2aWV3cyBzaG91bGQgYmUgaWdub3JlZCBieSBQcm9zZU1pcnJvclxuICAgIGlmIChpc0lucHV0ICYmICFpc0Ryb3BFdmVudCAmJiAhaXNEcmFnRXZlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgeyBpc0VkaXRhYmxlIH0gPSB0aGlzLmVkaXRvclxuICAgIGNvbnN0IHsgaXNEcmFnZ2luZyB9ID0gdGhpc1xuICAgIGNvbnN0IGlzRHJhZ2dhYmxlID0gISF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZVxuICAgIGNvbnN0IGlzU2VsZWN0YWJsZSA9IE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKHRoaXMubm9kZSlcbiAgICBjb25zdCBpc0NvcHlFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdjb3B5J1xuICAgIGNvbnN0IGlzUGFzdGVFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdwYXN0ZSdcbiAgICBjb25zdCBpc0N1dEV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ2N1dCdcbiAgICBjb25zdCBpc0NsaWNrRXZlbnQgPSBldmVudC50eXBlID09PSAnbW91c2Vkb3duJ1xuXG4gICAgLy8gUHJvc2VNaXJyb3IgdHJpZXMgdG8gZHJhZyBzZWxlY3RhYmxlIG5vZGVzXG4gICAgLy8gZXZlbiBpZiBgZHJhZ2dhYmxlYCBpcyBzZXQgdG8gYGZhbHNlYFxuICAgIC8vIHRoaXMgZml4IHByZXZlbnRzIHRoYXRcbiAgICBpZiAoIWlzRHJhZ2dhYmxlICYmIGlzU2VsZWN0YWJsZSAmJiBpc0RyYWdFdmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIH1cblxuICAgIGlmIChpc0RyYWdnYWJsZSAmJiBpc0RyYWdFdmVudCAmJiAhaXNEcmFnZ2luZykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gd2UgaGF2ZSB0byBzdG9yZSB0aGF0IGRyYWdnaW5nIHN0YXJ0ZWRcbiAgICBpZiAoaXNEcmFnZ2FibGUgJiYgaXNFZGl0YWJsZSAmJiAhaXNEcmFnZ2luZyAmJiBpc0NsaWNrRXZlbnQpIHtcbiAgICAgIGNvbnN0IGRyYWdIYW5kbGUgPSB0YXJnZXQuY2xvc2VzdCgnW2RhdGEtZHJhZy1oYW5kbGVdJylcbiAgICAgIGNvbnN0IGlzVmFsaWREcmFnSGFuZGxlID0gZHJhZ0hhbmRsZSAmJiAodGhpcy5kb20gPT09IGRyYWdIYW5kbGUgfHwgdGhpcy5kb20uY29udGFpbnMoZHJhZ0hhbmRsZSkpXG5cbiAgICAgIGlmIChpc1ZhbGlkRHJhZ0hhbmRsZSkge1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlXG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAnZHJhZ2VuZCcsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgb25jZTogdHJ1ZSB9LFxuICAgICAgICApXG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAnZHJvcCcsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgb25jZTogdHJ1ZSB9LFxuICAgICAgICApXG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAnbW91c2V1cCcsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgb25jZTogdHJ1ZSB9LFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhlc2UgZXZlbnRzIGFyZSBoYW5kbGVkIGJ5IHByb3NlbWlycm9yXG4gICAgaWYgKFxuICAgICAgaXNEcmFnZ2luZ1xuICAgICAgfHwgaXNEcm9wRXZlbnRcbiAgICAgIHx8IGlzQ29weUV2ZW50XG4gICAgICB8fCBpc1Bhc3RlRXZlbnRcbiAgICAgIHx8IGlzQ3V0RXZlbnRcbiAgICAgIHx8IChpc0NsaWNrRXZlbnQgJiYgaXNTZWxlY3RhYmxlKVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uOiBNdXRhdGlvblJlY29yZCB8IHsgdHlwZTogJ3NlbGVjdGlvbic7IHRhcmdldDogRWxlbWVudCB9KSB7XG4gICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmlnbm9yZU11dGF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlnbm9yZU11dGF0aW9uKHsgbXV0YXRpb24gfSlcbiAgICB9XG5cbiAgICAvLyBhIGxlYWYvYXRvbSBub2RlIGlzIGxpa2UgYSBibGFjayBib3ggZm9yIFByb3NlTWlycm9yXG4gICAgLy8gYW5kIHNob3VsZCBiZSBmdWxseSBoYW5kbGVkIGJ5IHRoZSBub2RlIHZpZXdcbiAgICBpZiAodGhpcy5ub2RlLmlzTGVhZiB8fCB0aGlzLm5vZGUuaXNBdG9tKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIFByb3NlTWlycm9yIHNob3VsZCBoYW5kbGUgYW55IHNlbGVjdGlvbnNcbiAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ3NlbGVjdGlvbicpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIHRyeSB0byBwcmV2ZW50IGEgYnVnIG9uIGlPUyBhbmQgQW5kcm9pZCB0aGF0IHdpbGwgYnJlYWsgbm9kZSB2aWV3cyBvbiBlbnRlclxuICAgIC8vIHRoaXMgaXMgYmVjYXVzZSBQcm9zZU1pcnJvciBjYW7igJl0IHByZXZlbnREaXNwYXRjaCBvbiBlbnRlclxuICAgIC8vIHRoaXMgd2lsbCBsZWFkIHRvIGEgcmUtcmVuZGVyIG9mIHRoZSBub2RlIHZpZXcgb24gZW50ZXJcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMTIxNFxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8yNTM0XG4gICAgaWYgKFxuICAgICAgdGhpcy5kb20uY29udGFpbnMobXV0YXRpb24udGFyZ2V0KVxuICAgICAgJiYgbXV0YXRpb24udHlwZSA9PT0gJ2NoaWxkTGlzdCdcbiAgICAgICYmIChpc2lPUygpIHx8IGlzQW5kcm9pZCgpKVxuICAgICAgJiYgdGhpcy5lZGl0b3IuaXNGb2N1c2VkXG4gICAgKSB7XG4gICAgICBjb25zdCBjaGFuZ2VkTm9kZXMgPSBbXG4gICAgICAgIC4uLkFycmF5LmZyb20obXV0YXRpb24uYWRkZWROb2RlcyksXG4gICAgICAgIC4uLkFycmF5LmZyb20obXV0YXRpb24ucmVtb3ZlZE5vZGVzKSxcbiAgICAgIF0gYXMgSFRNTEVsZW1lbnRbXVxuXG4gICAgICAvLyB3ZeKAmWxsIGNoZWNrIGlmIGV2ZXJ5IGNoYW5nZWQgbm9kZSBpcyBjb250ZW50RWRpdGFibGVcbiAgICAgIC8vIHRvIG1ha2Ugc3VyZSBpdOKAmXMgcHJvYmFibHkgbXV0YXRlZCBieSBQcm9zZU1pcnJvclxuICAgICAgaWYgKGNoYW5nZWROb2Rlcy5ldmVyeShub2RlID0+IG5vZGUuaXNDb250ZW50RWRpdGFibGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHdlIHdpbGwgYWxsb3cgbXV0YXRpb24gY29udGVudERPTSB3aXRoIGF0dHJpYnV0ZXNcbiAgICAvLyBzbyB3ZSBjYW4gZm9yIGV4YW1wbGUgYWRkaW5nIGNsYXNzZXMgd2l0aGluIG91ciBub2RlIHZpZXdcbiAgICBpZiAodGhpcy5jb250ZW50RE9NID09PSBtdXRhdGlvbi50YXJnZXQgJiYgbXV0YXRpb24udHlwZSA9PT0gJ2F0dHJpYnV0ZXMnKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIFByb3NlTWlycm9yIHNob3VsZCBoYW5kbGUgYW55IGNoYW5nZXMgd2l0aGluIGNvbnRlbnRET01cbiAgICBpZiAodGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB1cGRhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXM6IHt9KSB7XG4gICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICBjb25zdCBwb3MgPSB0aGlzLmdldFBvcygpXG5cbiAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB1bmRlZmluZWQsIHtcbiAgICAgICAgLi4udGhpcy5ub2RlLmF0dHJzLFxuICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KVxuICB9XG5cbiAgZGVsZXRlTm9kZSgpOiB2b2lkIHtcbiAgICBjb25zdCBmcm9tID0gdGhpcy5nZXRQb3MoKVxuICAgIGNvbnN0IHRvID0gZnJvbSArIHRoaXMubm9kZS5ub2RlU2l6ZVxuXG4gICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuZGVsZXRlUmFuZ2UoeyBmcm9tLCB0byB9KVxuICB9XG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXRNYXJrc0JldHdlZW4gfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtzQmV0d2Vlbi5qcydcbmltcG9ydCB7IFBhc3RlUnVsZSwgUGFzdGVSdWxlRmluZGVyIH0gZnJvbSAnLi4vUGFzdGVSdWxlLmpzJ1xuaW1wb3J0IHsgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIHBhc3RlIHJ1bGUgdGhhdCBhZGRzIGEgbWFyayB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHBhc3RlZCBpbnRvIGl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFya1Bhc3RlUnVsZShjb25maWc6IHtcbiAgZmluZDogUGFzdGVSdWxlRmluZGVyXG4gIHR5cGU6IE1hcmtUeXBlXG4gIGdldEF0dHJpYnV0ZXM/OlxuICAgIHwgUmVjb3JkPHN0cmluZywgYW55PlxuICAgIHwgKChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5LCBldmVudDogQ2xpcGJvYXJkRXZlbnQpID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgfCBmYWxzZVxuICAgIHwgbnVsbFxufSkge1xuICByZXR1cm4gbmV3IFBhc3RlUnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHtcbiAgICAgIHN0YXRlLCByYW5nZSwgbWF0Y2gsIHBhc3RlRXZlbnQsXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCwgcGFzdGVFdmVudClcblxuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGVcbiAgICAgIGNvbnN0IGNhcHR1cmVHcm91cCA9IG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdXG4gICAgICBjb25zdCBmdWxsTWF0Y2ggPSBtYXRjaFswXVxuICAgICAgbGV0IG1hcmtFbmQgPSByYW5nZS50b1xuXG4gICAgICBpZiAoY2FwdHVyZUdyb3VwKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0U3BhY2VzID0gZnVsbE1hdGNoLnNlYXJjaCgvXFxTLylcbiAgICAgICAgY29uc3QgdGV4dFN0YXJ0ID0gcmFuZ2UuZnJvbSArIGZ1bGxNYXRjaC5pbmRleE9mKGNhcHR1cmVHcm91cClcbiAgICAgICAgY29uc3QgdGV4dEVuZCA9IHRleHRTdGFydCArIGNhcHR1cmVHcm91cC5sZW5ndGhcblxuICAgICAgICBjb25zdCBleGNsdWRlZE1hcmtzID0gZ2V0TWFya3NCZXR3ZWVuKHJhbmdlLmZyb20sIHJhbmdlLnRvLCBzdGF0ZS5kb2MpXG4gICAgICAgICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gaXRlbS5tYXJrLnR5cGUuZXhjbHVkZWQgYXMgTWFya1R5cGVbXVxuXG4gICAgICAgICAgICByZXR1cm4gZXhjbHVkZWQuZmluZCh0eXBlID0+IHR5cGUgPT09IGNvbmZpZy50eXBlICYmIHR5cGUgIT09IGl0ZW0ubWFyay50eXBlKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0udG8gPiB0ZXh0U3RhcnQpXG5cbiAgICAgICAgaWYgKGV4Y2x1ZGVkTWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0RW5kIDwgcmFuZ2UudG8pIHtcbiAgICAgICAgICB0ci5kZWxldGUodGV4dEVuZCwgcmFuZ2UudG8pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dFN0YXJ0ID4gcmFuZ2UuZnJvbSkge1xuICAgICAgICAgIHRyLmRlbGV0ZShyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIHRleHRTdGFydClcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtFbmQgPSByYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMgKyBjYXB0dXJlR3JvdXAubGVuZ3RoXG5cbiAgICAgICAgdHIuYWRkTWFyayhyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIG1hcmtFbmQsIGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzIHx8IHt9KSlcblxuICAgICAgICB0ci5yZW1vdmVTdG9yZWRNYXJrKGNvbmZpZy50eXBlKVxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG4iLCAiLy8gc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjk2OTQ4NlxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUZvclJlZ0V4KHN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJylcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWU6IGFueSk6IHZhbHVlIGlzIHN0cmluZyB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBQYXN0ZVJ1bGUsIFBhc3RlUnVsZUZpbmRlciB9IGZyb20gJy4uL1Bhc3RlUnVsZS5qcydcbmltcG9ydCB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2luZGV4LmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIHBhc3RlIHJ1bGUgdGhhdCBhZGRzIGEgbm9kZSB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHBhc3RlZCBpbnRvIGl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9kZVBhc3RlUnVsZShjb25maWc6IHtcbiAgZmluZDogUGFzdGVSdWxlRmluZGVyXG4gIHR5cGU6IE5vZGVUeXBlXG4gIGdldEF0dHJpYnV0ZXM/OlxuICAgIHwgUmVjb3JkPHN0cmluZywgYW55PlxuICAgIHwgKChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5LCBldmVudDogQ2xpcGJvYXJkRXZlbnQpID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgfCBmYWxzZVxuICAgIHwgbnVsbFxufSkge1xuICByZXR1cm4gbmV3IFBhc3RlUnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcih7XG4gICAgICBtYXRjaCwgY2hhaW4sIHJhbmdlLCBwYXN0ZUV2ZW50LFxuICAgIH0pIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gsIHBhc3RlRXZlbnQpXG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzID09PSBmYWxzZSB8fCBhdHRyaWJ1dGVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaC5pbnB1dCkge1xuICAgICAgICBjaGFpbigpLmRlbGV0ZVJhbmdlKHJhbmdlKS5pbnNlcnRDb250ZW50QXQocmFuZ2UuZnJvbSwge1xuICAgICAgICAgIHR5cGU6IGNvbmZpZy50eXBlLm5hbWUsXG4gICAgICAgICAgYXR0cnM6IGF0dHJpYnV0ZXMsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBQYXN0ZVJ1bGUsIFBhc3RlUnVsZUZpbmRlciB9IGZyb20gJy4uL1Bhc3RlUnVsZS5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBwYXN0ZSBydWxlIHRoYXQgcmVwbGFjZXMgdGV4dCB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHBhc3RlZCBpbnRvIGl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGV4dFBhc3RlUnVsZShjb25maWc6IHtcbiAgZmluZDogUGFzdGVSdWxlRmluZGVyLFxuICByZXBsYWNlOiBzdHJpbmcsXG59KSB7XG4gIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGxldCBpbnNlcnQgPSBjb25maWcucmVwbGFjZVxuICAgICAgbGV0IHN0YXJ0ID0gcmFuZ2UuZnJvbVxuICAgICAgY29uc3QgZW5kID0gcmFuZ2UudG9cblxuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKVxuXG4gICAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpXG4gICAgICAgIHN0YXJ0ICs9IG9mZnNldFxuXG4gICAgICAgIGNvbnN0IGN1dE9mZiA9IHN0YXJ0IC0gZW5kXG5cbiAgICAgICAgaWYgKGN1dE9mZiA+IDApIHtcbiAgICAgICAgICBpbnNlcnQgPSBtYXRjaFswXS5zbGljZShvZmZzZXQgLSBjdXRPZmYsIG9mZnNldCkgKyBpbnNlcnRcbiAgICAgICAgICBzdGFydCA9IGVuZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYWNrZXJSZXN1bHQge1xuICBwb3NpdGlvbjogbnVtYmVyXG4gIGRlbGV0ZWQ6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIFRyYWNrZXIge1xuICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25cblxuICBjdXJyZW50U3RlcDogbnVtYmVyXG5cbiAgY29uc3RydWN0b3IodHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uXG4gICAgdGhpcy5jdXJyZW50U3RlcCA9IHRoaXMudHJhbnNhY3Rpb24uc3RlcHMubGVuZ3RoXG4gIH1cblxuICBtYXAocG9zaXRpb246IG51bWJlcik6IFRyYWNrZXJSZXN1bHQge1xuICAgIGxldCBkZWxldGVkID0gZmFsc2VcblxuICAgIGNvbnN0IG1hcHBlZFBvc2l0aW9uID0gdGhpcy50cmFuc2FjdGlvbi5zdGVwc1xuICAgICAgLnNsaWNlKHRoaXMuY3VycmVudFN0ZXApXG4gICAgICAucmVkdWNlKChuZXdQb3NpdGlvbiwgc3RlcCkgPT4ge1xuICAgICAgICBjb25zdCBtYXBSZXN1bHQgPSBzdGVwLmdldE1hcCgpLm1hcFJlc3VsdChuZXdQb3NpdGlvbilcblxuICAgICAgICBpZiAobWFwUmVzdWx0LmRlbGV0ZWQpIHtcbiAgICAgICAgICBkZWxldGVkID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcFJlc3VsdC5wb3NcbiAgICAgIH0sIHBvc2l0aW9uKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiBtYXBwZWRQb3NpdGlvbixcbiAgICAgIGRlbGV0ZWQsXG4gICAgfVxuICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IFlPVVRVQkVfUkVHRVggPSAvXihodHRwcz86XFwvXFwvKT8od3d3XFwufG11c2ljXFwuKT8oeW91dHViZVxcLmNvbXx5b3V0dVxcLmJlKSg/IS4qXFwvY2hhbm5lbFxcLykoPyFcXC9AKSguKyk/JC9cbmV4cG9ydCBjb25zdCBZT1VUVUJFX1JFR0VYX0dMT0JBTCA9IC9eKGh0dHBzPzpcXC9cXC8pPyh3d3dcXC58bXVzaWNcXC4pPyh5b3V0dWJlXFwuY29tfHlvdXR1XFwuYmUpKD8hLipcXC9jaGFubmVsXFwvKSg/IVxcL0ApKC4rKT8kL2dcblxuZXhwb3J0IGNvbnN0IGlzVmFsaWRZb3V0dWJlVXJsID0gKHVybDogc3RyaW5nKSA9PiB7XG4gIHJldHVybiB1cmwubWF0Y2goWU9VVFVCRV9SRUdFWClcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRFbWJlZFVybE9wdGlvbnMge1xuICB1cmw6IHN0cmluZztcbiAgYWxsb3dGdWxsc2NyZWVuPzogYm9vbGVhbjtcbiAgYXV0b3BsYXk/OiBib29sZWFuO1xuICBjY0xhbmd1YWdlPzpzdHJpbmc7XG4gIGNjTG9hZFBvbGljeT86Ym9vbGVhbjtcbiAgY29udHJvbHM/OiBib29sZWFuO1xuICBkaXNhYmxlS0Jjb250cm9scz86IGJvb2xlYW4sXG4gIGVuYWJsZUlGcmFtZUFwaT86IGJvb2xlYW47XG4gIGVuZFRpbWU/OiBudW1iZXI7XG4gIGludGVyZmFjZUxhbmd1YWdlPzogc3RyaW5nO1xuICBpdkxvYWRQb2xpY3k/OiBudW1iZXI7XG4gIGxvb3A/OiBib29sZWFuO1xuICBtb2Rlc3RCcmFuZGluZz86IGJvb2xlYW47XG4gIG5vY29va2llPzogYm9vbGVhbjtcbiAgb3JpZ2luPzogc3RyaW5nO1xuICBwbGF5bGlzdD86IHN0cmluZztcbiAgcHJvZ3Jlc3NCYXJDb2xvcj86IHN0cmluZztcbiAgc3RhcnRBdD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IGdldFlvdXR1YmVFbWJlZFVybCA9IChub2Nvb2tpZT86IGJvb2xlYW4pID0+IHtcbiAgcmV0dXJuIG5vY29va2llID8gJ2h0dHBzOi8vd3d3LnlvdXR1YmUtbm9jb29raWUuY29tL2VtYmVkLycgOiAnaHR0cHM6Ly93d3cueW91dHViZS5jb20vZW1iZWQvJ1xufVxuXG5leHBvcnQgY29uc3QgZ2V0RW1iZWRVcmxGcm9tWW91dHViZVVybCA9IChvcHRpb25zOiBHZXRFbWJlZFVybE9wdGlvbnMpID0+IHtcbiAgY29uc3Qge1xuICAgIHVybCxcbiAgICBhbGxvd0Z1bGxzY3JlZW4sXG4gICAgYXV0b3BsYXksXG4gICAgY2NMYW5ndWFnZSxcbiAgICBjY0xvYWRQb2xpY3ksXG4gICAgY29udHJvbHMsXG4gICAgZGlzYWJsZUtCY29udHJvbHMsXG4gICAgZW5hYmxlSUZyYW1lQXBpLFxuICAgIGVuZFRpbWUsXG4gICAgaW50ZXJmYWNlTGFuZ3VhZ2UsXG4gICAgaXZMb2FkUG9saWN5LFxuICAgIGxvb3AsXG4gICAgbW9kZXN0QnJhbmRpbmcsXG4gICAgbm9jb29raWUsXG4gICAgb3JpZ2luLFxuICAgIHBsYXlsaXN0LFxuICAgIHByb2dyZXNzQmFyQ29sb3IsXG4gICAgc3RhcnRBdCxcbiAgfSA9IG9wdGlvbnNcblxuICAvLyBpZiBpcyBhbHJlYWR5IGFuIGVtYmVkIHVybCwgcmV0dXJuIGl0XG4gIGlmICh1cmwuaW5jbHVkZXMoJy9lbWJlZC8nKSkge1xuICAgIHJldHVybiB1cmxcbiAgfVxuXG4gIC8vIGlmIGlzIGEgeW91dHUuYmUgdXJsLCBnZXQgdGhlIGlkIGFmdGVyIHRoZSAvXG4gIGlmICh1cmwuaW5jbHVkZXMoJ3lvdXR1LmJlJykpIHtcbiAgICBjb25zdCBpZCA9IHVybC5zcGxpdCgnLycpLnBvcCgpXG5cbiAgICBpZiAoIWlkKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gYCR7Z2V0WW91dHViZUVtYmVkVXJsKG5vY29va2llKX0ke2lkfWBcbiAgfVxuXG4gIGNvbnN0IHZpZGVvSWRSZWdleCA9IC92PShbLVxcd10rKS9nbVxuICBjb25zdCBtYXRjaGVzID0gdmlkZW9JZFJlZ2V4LmV4ZWModXJsKVxuXG4gIGlmICghbWF0Y2hlcyB8fCAhbWF0Y2hlc1sxXSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBsZXQgb3V0cHV0VXJsID0gYCR7Z2V0WW91dHViZUVtYmVkVXJsKG5vY29va2llKX0ke21hdGNoZXNbMV19YFxuXG4gIGNvbnN0IHBhcmFtcyA9IFtdXG5cbiAgaWYgKGFsbG93RnVsbHNjcmVlbiA9PT0gZmFsc2UpIHtcbiAgICBwYXJhbXMucHVzaCgnZnM9MCcpXG4gIH1cblxuICBpZiAoYXV0b3BsYXkpIHtcbiAgICBwYXJhbXMucHVzaCgnYXV0b3BsYXk9MScpXG4gIH1cblxuICBpZiAoY2NMYW5ndWFnZSkge1xuICAgIHBhcmFtcy5wdXNoKGBjY19sYW5nX3ByZWY9JHtjY0xhbmd1YWdlfWApXG4gIH1cblxuICBpZiAoY2NMb2FkUG9saWN5KSB7XG4gICAgcGFyYW1zLnB1c2goJ2NjX2xvYWRfcG9saWN5PTEnKVxuICB9XG5cbiAgaWYgKCFjb250cm9scykge1xuICAgIHBhcmFtcy5wdXNoKCdjb250cm9scz0wJylcbiAgfVxuXG4gIGlmIChkaXNhYmxlS0Jjb250cm9scykge1xuICAgIHBhcmFtcy5wdXNoKCdkaXNhYmxla2I9MScpXG4gIH1cblxuICBpZiAoZW5hYmxlSUZyYW1lQXBpKSB7XG4gICAgcGFyYW1zLnB1c2goJ2VuYWJsZWpzYXBpPTEnKVxuICB9XG5cbiAgaWYgKGVuZFRpbWUpIHtcbiAgICBwYXJhbXMucHVzaChgZW5kPSR7ZW5kVGltZX1gKVxuICB9XG5cbiAgaWYgKGludGVyZmFjZUxhbmd1YWdlKSB7XG4gICAgcGFyYW1zLnB1c2goYGhsPSR7aW50ZXJmYWNlTGFuZ3VhZ2V9YClcbiAgfVxuXG4gIGlmIChpdkxvYWRQb2xpY3kpIHtcbiAgICBwYXJhbXMucHVzaChgaXZfbG9hZF9wb2xpY3k9JHtpdkxvYWRQb2xpY3l9YClcbiAgfVxuXG4gIGlmIChsb29wKSB7XG4gICAgcGFyYW1zLnB1c2goJ2xvb3A9MScpXG4gIH1cblxuICBpZiAobW9kZXN0QnJhbmRpbmcpIHtcbiAgICBwYXJhbXMucHVzaCgnbW9kZXN0YnJhbmRpbmc9MScpXG4gIH1cblxuICBpZiAob3JpZ2luKSB7XG4gICAgcGFyYW1zLnB1c2goYG9yaWdpbj0ke29yaWdpbn1gKVxuICB9XG5cbiAgaWYgKHBsYXlsaXN0KSB7XG4gICAgcGFyYW1zLnB1c2goYHBsYXlsaXN0PSR7cGxheWxpc3R9YClcbiAgfVxuXG4gIGlmIChzdGFydEF0KSB7XG4gICAgcGFyYW1zLnB1c2goYHN0YXJ0PSR7c3RhcnRBdH1gKVxuICB9XG5cbiAgaWYgKHByb2dyZXNzQmFyQ29sb3IpIHtcbiAgICBwYXJhbXMucHVzaChgY29sb3I9JHtwcm9ncmVzc0JhckNvbG9yfWApXG4gIH1cblxuICBpZiAocGFyYW1zLmxlbmd0aCkge1xuICAgIG91dHB1dFVybCArPSBgPyR7cGFyYW1zLmpvaW4oJyYnKX1gXG4gIH1cblxuICByZXR1cm4gb3V0cHV0VXJsXG59XG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCBub2RlUGFzdGVSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5pbXBvcnQgeyBnZXRFbWJlZFVybEZyb21Zb3V0dWJlVXJsLCBpc1ZhbGlkWW91dHViZVVybCwgWU9VVFVCRV9SRUdFWF9HTE9CQUwgfSBmcm9tICcuL3V0aWxzLmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFlvdXR1YmVPcHRpb25zIHtcbiAgYWRkUGFzdGVIYW5kbGVyOiBib29sZWFuO1xuICBhbGxvd0Z1bGxzY3JlZW46IGJvb2xlYW47XG4gIGF1dG9wbGF5OiBib29sZWFuO1xuICBjY0xhbmd1YWdlPzogc3RyaW5nO1xuICBjY0xvYWRQb2xpY3k/OiBib29sZWFuO1xuICBjb250cm9sczogYm9vbGVhbjtcbiAgZGlzYWJsZUtCY29udHJvbHM6IGJvb2xlYW47XG4gIGVuYWJsZUlGcmFtZUFwaTogYm9vbGVhbjtcbiAgZW5kVGltZTogbnVtYmVyO1xuICBoZWlnaHQ6IG51bWJlcjtcbiAgaW50ZXJmYWNlTGFuZ3VhZ2U/OiBzdHJpbmc7XG4gIGl2TG9hZFBvbGljeTogbnVtYmVyO1xuICBsb29wOiBib29sZWFuO1xuICBtb2Rlc3RCcmFuZGluZzogYm9vbGVhbjtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIGlubGluZTogYm9vbGVhbjtcbiAgbm9jb29raWU6IGJvb2xlYW47XG4gIG9yaWdpbjogc3RyaW5nO1xuICBwbGF5bGlzdDogc3RyaW5nO1xuICBwcm9ncmVzc0JhckNvbG9yPzogc3RyaW5nO1xuICB3aWR0aDogbnVtYmVyO1xufVxuXG50eXBlIFNldFlvdXR1YmVWaWRlb09wdGlvbnMgPSB7IHNyYzogc3RyaW5nLCB3aWR0aD86IG51bWJlciwgaGVpZ2h0PzogbnVtYmVyLCBzdGFydD86IG51bWJlciB9XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB5b3V0dWJlOiB7XG4gICAgICAvKipcbiAgICAgICAqIEluc2VydCBhIHlvdXR1YmUgdmlkZW9cbiAgICAgICAqL1xuICAgICAgc2V0WW91dHViZVZpZGVvOiAob3B0aW9uczogU2V0WW91dHViZVZpZGVvT3B0aW9ucykgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFlvdXR1YmUgPSBOb2RlLmNyZWF0ZTxZb3V0dWJlT3B0aW9ucz4oe1xuICBuYW1lOiAneW91dHViZScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkUGFzdGVIYW5kbGVyOiB0cnVlLFxuICAgICAgYWxsb3dGdWxsc2NyZWVuOiB0cnVlLFxuICAgICAgYXV0b3BsYXk6IGZhbHNlLFxuICAgICAgY2NMYW5ndWFnZTogdW5kZWZpbmVkLFxuICAgICAgY2NMb2FkUG9saWN5OiB1bmRlZmluZWQsXG4gICAgICBjb250cm9sczogdHJ1ZSxcbiAgICAgIGRpc2FibGVLQmNvbnRyb2xzOiBmYWxzZSxcbiAgICAgIGVuYWJsZUlGcmFtZUFwaTogZmFsc2UsXG4gICAgICBlbmRUaW1lOiAwLFxuICAgICAgaGVpZ2h0OiA0ODAsXG4gICAgICBpbnRlcmZhY2VMYW5ndWFnZTogdW5kZWZpbmVkLFxuICAgICAgaXZMb2FkUG9saWN5OiAwLFxuICAgICAgbG9vcDogZmFsc2UsXG4gICAgICBtb2Rlc3RCcmFuZGluZzogZmFsc2UsXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICBpbmxpbmU6IGZhbHNlLFxuICAgICAgbm9jb29raWU6IGZhbHNlLFxuICAgICAgb3JpZ2luOiAnJyxcbiAgICAgIHBsYXlsaXN0OiAnJyxcbiAgICAgIHByb2dyZXNzQmFyQ29sb3I6IHVuZGVmaW5lZCxcbiAgICAgIHdpZHRoOiA2NDAsXG4gICAgfVxuICB9LFxuXG4gIGlubGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlubGluZVxuICB9LFxuXG4gIGdyb3VwKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW5saW5lID8gJ2lubGluZScgOiAnYmxvY2snXG4gIH0sXG5cbiAgZHJhZ2dhYmxlOiB0cnVlLFxuXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNyYzoge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgfSxcbiAgICAgIHN0YXJ0OiB7XG4gICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICB9LFxuICAgICAgd2lkdGg6IHtcbiAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLndpZHRoLFxuICAgICAgfSxcbiAgICAgIGhlaWdodDoge1xuICAgICAgICBkZWZhdWx0OiB0aGlzLm9wdGlvbnMuaGVpZ2h0LFxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ2RpdltkYXRhLXlvdXR1YmUtdmlkZW9dIGlmcmFtZScsXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0WW91dHViZVZpZGVvOiAob3B0aW9uczogU2V0WW91dHViZVZpZGVvT3B0aW9ucykgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICBpZiAoIWlzVmFsaWRZb3V0dWJlVXJsKG9wdGlvbnMuc3JjKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmluc2VydENvbnRlbnQoe1xuICAgICAgICAgIHR5cGU6IHRoaXMubmFtZSxcbiAgICAgICAgICBhdHRyczogb3B0aW9ucyxcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuYWRkUGFzdGVIYW5kbGVyKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgbm9kZVBhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6IFlPVVRVQkVfUkVHRVhfR0xPQkFMLFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+IHtcbiAgICAgICAgICByZXR1cm4geyBzcmM6IG1hdGNoLmlucHV0IH1cbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIGNvbnN0IGVtYmVkVXJsID0gZ2V0RW1iZWRVcmxGcm9tWW91dHViZVVybCh7XG4gICAgICB1cmw6IEhUTUxBdHRyaWJ1dGVzLnNyYyxcbiAgICAgIGFsbG93RnVsbHNjcmVlbjogdGhpcy5vcHRpb25zLmFsbG93RnVsbHNjcmVlbixcbiAgICAgIGF1dG9wbGF5OiB0aGlzLm9wdGlvbnMuYXV0b3BsYXksXG4gICAgICBjY0xhbmd1YWdlOiB0aGlzLm9wdGlvbnMuY2NMYW5ndWFnZSxcbiAgICAgIGNjTG9hZFBvbGljeTogdGhpcy5vcHRpb25zLmNjTG9hZFBvbGljeSxcbiAgICAgIGNvbnRyb2xzOiB0aGlzLm9wdGlvbnMuY29udHJvbHMsXG4gICAgICBkaXNhYmxlS0Jjb250cm9sczogdGhpcy5vcHRpb25zLmRpc2FibGVLQmNvbnRyb2xzLFxuICAgICAgZW5hYmxlSUZyYW1lQXBpOiB0aGlzLm9wdGlvbnMuZW5hYmxlSUZyYW1lQXBpLFxuICAgICAgZW5kVGltZTogdGhpcy5vcHRpb25zLmVuZFRpbWUsXG4gICAgICBpbnRlcmZhY2VMYW5ndWFnZTogdGhpcy5vcHRpb25zLmludGVyZmFjZUxhbmd1YWdlLFxuICAgICAgaXZMb2FkUG9saWN5OiB0aGlzLm9wdGlvbnMuaXZMb2FkUG9saWN5LFxuICAgICAgbG9vcDogdGhpcy5vcHRpb25zLmxvb3AsXG4gICAgICBtb2Rlc3RCcmFuZGluZzogdGhpcy5vcHRpb25zLm1vZGVzdEJyYW5kaW5nLFxuICAgICAgbm9jb29raWU6IHRoaXMub3B0aW9ucy5ub2Nvb2tpZSxcbiAgICAgIG9yaWdpbjogdGhpcy5vcHRpb25zLm9yaWdpbixcbiAgICAgIHBsYXlsaXN0OiB0aGlzLm9wdGlvbnMucGxheWxpc3QsXG4gICAgICBwcm9ncmVzc0JhckNvbG9yOiB0aGlzLm9wdGlvbnMucHJvZ3Jlc3NCYXJDb2xvcixcbiAgICAgIHN0YXJ0QXQ6IEhUTUxBdHRyaWJ1dGVzLnN0YXJ0IHx8IDAsXG4gICAgfSlcblxuICAgIEhUTUxBdHRyaWJ1dGVzLnNyYyA9IGVtYmVkVXJsXG5cbiAgICByZXR1cm4gW1xuICAgICAgJ2RpdicsXG4gICAgICB7ICdkYXRhLXlvdXR1YmUtdmlkZW8nOiAnJyB9LFxuICAgICAgW1xuICAgICAgICAnaWZyYW1lJyxcbiAgICAgICAgbWVyZ2VBdHRyaWJ1dGVzKFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5vcHRpb25zLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLm9wdGlvbnMuaGVpZ2h0LFxuICAgICAgICAgICAgYWxsb3dmdWxsc2NyZWVuOiB0aGlzLm9wdGlvbnMuYWxsb3dGdWxsc2NyZWVuLFxuICAgICAgICAgICAgYXV0b3BsYXk6IHRoaXMub3B0aW9ucy5hdXRvcGxheSxcbiAgICAgICAgICAgIGNjTGFuZ3VhZ2U6IHRoaXMub3B0aW9ucy5jY0xhbmd1YWdlLFxuICAgICAgICAgICAgY2NMb2FkUG9saWN5OiB0aGlzLm9wdGlvbnMuY2NMb2FkUG9saWN5LFxuICAgICAgICAgICAgZGlzYWJsZUtCY29udHJvbHM6IHRoaXMub3B0aW9ucy5kaXNhYmxlS0Jjb250cm9scyxcbiAgICAgICAgICAgIGVuYWJsZUlGcmFtZUFwaTogdGhpcy5vcHRpb25zLmVuYWJsZUlGcmFtZUFwaSxcbiAgICAgICAgICAgIGVuZFRpbWU6IHRoaXMub3B0aW9ucy5lbmRUaW1lLFxuICAgICAgICAgICAgaW50ZXJmYWNlTGFuZ3VhZ2U6IHRoaXMub3B0aW9ucy5pbnRlcmZhY2VMYW5ndWFnZSxcbiAgICAgICAgICAgIGl2TG9hZFBvbGljeTogdGhpcy5vcHRpb25zLml2TG9hZFBvbGljeSxcbiAgICAgICAgICAgIGxvb3A6IHRoaXMub3B0aW9ucy5sb29wLFxuICAgICAgICAgICAgbW9kZXN0QnJhbmRpbmc6IHRoaXMub3B0aW9ucy5tb2Rlc3RCcmFuZGluZyxcbiAgICAgICAgICAgIG9yaWdpbjogdGhpcy5vcHRpb25zLm9yaWdpbixcbiAgICAgICAgICAgIHBsYXlsaXN0OiB0aGlzLm9wdGlvbnMucGxheWxpc3QsXG4gICAgICAgICAgICBwcm9ncmVzc0JhckNvbG9yOiB0aGlzLm9wdGlvbnMucHJvZ3Jlc3NCYXJDb2xvcixcbiAgICAgICAgICB9LFxuICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzLFxuICAgICAgICApLFxuICAgICAgXSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IHJlZ2lzdGVyRXh0ZW5zaW9uIH0gZnJvbSBcIi4uLy4uLy4uL3N1cHBvcnQvcmVzb3VyY2VzL2pzL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBZb3V0dWJlIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLXlvdXR1YmVcIjtcblxucmVnaXN0ZXJFeHRlbnNpb24oXCJ5b3V0dWJlXCIsICgpID0+IFtZb3V0dWJlXSk7XG4iXSwKICAibWFwcGluZ3MiOiAiOztBQUFPLFdBQVMsa0JBQWtCLElBQUksVUFBVTtBQUM5QyxRQUFJ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QixLQUFLLFFBQVE7UUFDOUIsU0FBUyxLQUFLLFFBQVE7UUFDdEIsbUJBQW1CLEtBQUssUUFBUTtRQUNoQyxjQUFjLEtBQUssUUFBUTtRQUMzQixNQUFNLEtBQUssUUFBUTtRQUNuQixnQkFBZ0IsS0FBSyxRQUFRO1FBQzdCLFVBQVUsS0FBSyxRQUFRO1FBQ3ZCLFFBQVEsS0FBSyxRQUFRO1FBQ3JCLFVBQVUsS0FBSyxRQUFRO1FBQ3ZCLGtCQUFrQixLQUFLLFFBQVE7UUFDL0IsU0FBUyxlQUFlLFNBQVM7TUFDbEMsQ0FBQTtBQUVELHFCQUFlLE1BQU07QUFFckIsYUFBTztRQUNMO1FBQ0EsRUFBRSxzQkFBc0IsR0FBRTtRQUMxQjtVQUNFO1VBQ0EsZ0JBQ0UsS0FBSyxRQUFRLGdCQUNiO1lBQ0UsT0FBTyxLQUFLLFFBQVE7WUFDcEIsUUFBUSxLQUFLLFFBQVE7WUFDckIsaUJBQWlCLEtBQUssUUFBUTtZQUM5QixVQUFVLEtBQUssUUFBUTtZQUN2QixZQUFZLEtBQUssUUFBUTtZQUN6QixjQUFjLEtBQUssUUFBUTtZQUMzQixtQkFBbUIsS0FBSyxRQUFRO1lBQ2hDLGlCQUFpQixLQUFLLFFBQVE7WUFDOUIsU0FBUyxLQUFLLFFBQVE7WUFDdEIsbUJBQW1CLEtBQUssUUFBUTtZQUNoQyxjQUFjLEtBQUssUUFBUTtZQUMzQixNQUFNLEtBQUssUUFBUTtZQUNuQixnQkFBZ0IsS0FBSyxRQUFRO1lBQzdCLFFBQVEsS0FBSyxRQUFRO1lBQ3JCLFVBQVUsS0FBSyxRQUFRO1lBQ3ZCLGtCQUFrQixLQUFLLFFBQVE7VUFDaEMsR0FDRCxjQUFjO1FBRWpCOzs7RUFHTixDQUFBOzs7QUMzTEQsb0JBQWtCLFdBQVcsTUFBTSxDQUFDLE9BQU8sQ0FBQzsiLAogICJuYW1lcyI6IFsiZmlyc3QiLCAiY29weSIsICJmb3VuZCIsICJmb3VuZCIsICJpIiwgInR5cGUiLCAibmZhIiwgImVkZ2UiLCAiZXhwciIsICJub2RlIiwgInN0YXRlcyIsICJmb3VuZCIsICJjb3B5IiwgImRlbCIsICJwYXJlbnQiLCAiaW5kZXgiLCAiam9pbmFibGUiLCAiZmlyc3QiLCAibWF0Y2hlcyIsICJtYXRjaCIsICJ0eXBlIiwgImNsb3NlIiwgIlRyYW5zZm9ybUVycm9yIiwgImZvdW5kIiwgImZpcnN0IiwgImNvbW1hbmRzIiwgImZvdW5kIiwgImZpcnN0IiwgImNvbW1hbmQiLCAicmFuZ2UiLCAiY29tbWFuZHMiLCAiY3JlYXRlUGFyYWdyYXBoTmVhciIsICJvcmlnaW5hbENyZWF0ZVBhcmFncmFwaE5lYXIiLCAiZGVsZXRlU2VsZWN0aW9uIiwgIm9yaWdpbmFsRGVsZXRlU2VsZWN0aW9uIiwgImV4aXRDb2RlIiwgIm9yaWdpbmFsRXhpdENvZGUiLCAia2V5cyIsICJzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCIsICJqb2luVXAiLCAib3JpZ2luYWxKb2luVXAiLCAiam9pbkRvd24iLCAib3JpZ2luYWxKb2luRG93biIsICJqb2luQmFja3dhcmQiLCAib3JpZ2luYWxKb2luQmFja3dhcmQiLCAiam9pbkZvcndhcmQiLCAib3JpZ2luYWxKb2luRm9yd2FyZCIsICJsaWZ0IiwgIm9yaWdpbmFsTGlmdCIsICJsaWZ0RW1wdHlCbG9jayIsICJvcmlnaW5hbExpZnRFbXB0eUJsb2NrIiwgImxpZnRMaXN0SXRlbSIsICJvcmlnaW5hbExpZnRMaXN0SXRlbSIsICJuZXdsaW5lSW5Db2RlIiwgIm9yaWdpbmFsTmV3bGluZUluQ29kZSIsICJzZWxlY3RBbGwiLCAic2VsZWN0Tm9kZUJhY2t3YXJkIiwgIm9yaWdpbmFsU2VsZWN0Tm9kZUJhY2t3YXJkIiwgInNlbGVjdE5vZGVGb3J3YXJkIiwgIm9yaWdpbmFsU2VsZWN0Tm9kZUZvcndhcmQiLCAic2VsZWN0UGFyZW50Tm9kZSIsICJvcmlnaW5hbFNlbGVjdFBhcmVudE5vZGUiLCAic2VsZWN0VGV4dGJsb2NrRW5kIiwgIm9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrRW5kIiwgInNlbGVjdFRleHRibG9ja1N0YXJ0IiwgIm9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrU3RhcnQiLCAiZG9jdW1lbnQiLCAiZGVmYXVsdEJsb2NrQXQiLCAicmFuZ2UiLCAiY29tbWFuZHMiLCAic2lua0xpc3RJdGVtIiwgIm9yaWdpbmFsU2lua0xpc3RJdGVtIiwgInNwbGl0QmxvY2siLCAiZGVmYXVsdEJsb2NrQXQiLCAiZmlyc3QiLCAibmV3TmV4dFR5cGVBdHRyaWJ1dGVzIiwgIm5leHRUeXBlIiwgIndyYXBJbiIsICJvcmlnaW5hbFdyYXBJbiIsICJ3cmFwSW5MaXN0IiwgIm9yaWdpbmFsV3JhcEluTGlzdCIsICJOb2RlIiwgIm1hdGNoZXMiLCAiTm9kZSIsICJjb21tYW5kcyJdCn0K
