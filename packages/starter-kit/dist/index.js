(() => {
  // node_modules/prosemirror-model/dist/index.js
  function findDiffStart(a, b, pos) {
    for (let i = 0; ; i++) {
      if (i == a.childCount || i == b.childCount)
        return a.childCount == b.childCount ? null : pos;
      let childA = a.child(i), childB = b.child(i);
      if (childA == childB) {
        pos += childA.nodeSize;
        continue;
      }
      if (!childA.sameMarkup(childB))
        return pos;
      if (childA.isText && childA.text != childB.text) {
        for (let j = 0; childA.text[j] == childB.text[j]; j++)
          pos++;
        return pos;
      }
      if (childA.content.size || childB.content.size) {
        let inner = findDiffStart(childA.content, childB.content, pos + 1);
        if (inner != null)
          return inner;
      }
      pos += childA.nodeSize;
    }
  }
  function findDiffEnd(a, b, posA, posB) {
    for (let iA = a.childCount, iB = b.childCount; ; ) {
      if (iA == 0 || iB == 0)
        return iA == iB ? null : { a: posA, b: posB };
      let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
      if (childA == childB) {
        posA -= size;
        posB -= size;
        continue;
      }
      if (!childA.sameMarkup(childB))
        return { a: posA, b: posB };
      if (childA.isText && childA.text != childB.text) {
        let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
        while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
          same++;
          posA--;
          posB--;
        }
        return { a: posA, b: posB };
      }
      if (childA.content.size || childB.content.size) {
        let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
        if (inner)
          return inner;
      }
      posA -= size;
      posB -= size;
    }
  }
  var Fragment = class _Fragment {
    /**
    @internal
    */
    constructor(content, size) {
      this.content = content;
      this.size = size || 0;
      if (size == null)
        for (let i = 0; i < content.length; i++)
          this.size += content[i].nodeSize;
    }
    /**
    Invoke a callback for all descendant nodes between the given two
    positions (relative to start of this fragment). Doesn't descend
    into a node when the callback returns `false`.
    */
    nodesBetween(from, to, f, nodeStart = 0, parent) {
      for (let i = 0, pos = 0; pos < to; i++) {
        let child = this.content[i], end = pos + child.nodeSize;
        if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
          let start = pos + 1;
          child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);
        }
        pos = end;
      }
    }
    /**
    Call the given callback for every descendant node. `pos` will be
    relative to the start of the fragment. The callback may return
    `false` to prevent traversal of a given node's children.
    */
    descendants(f) {
      this.nodesBetween(0, this.size, f);
    }
    /**
    Extract the text between `from` and `to`. See the same method on
    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
    */
    textBetween(from, to, blockSeparator, leafText) {
      let text = "", separated = true;
      this.nodesBetween(from, to, (node, pos) => {
        if (node.isText) {
          text += node.text.slice(Math.max(from, pos) - pos, to - pos);
          separated = !blockSeparator;
        } else if (node.isLeaf) {
          if (leafText) {
            text += typeof leafText === "function" ? leafText(node) : leafText;
          } else if (node.type.spec.leafText) {
            text += node.type.spec.leafText(node);
          }
          separated = !blockSeparator;
        } else if (!separated && node.isBlock) {
          text += blockSeparator;
          separated = true;
        }
      }, 0);
      return text;
    }
    /**
    Create a new fragment containing the combined content of this
    fragment and the other.
    */
    append(other) {
      if (!other.size)
        return this;
      if (!this.size)
        return other;
      let last = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i = 0;
      if (last.isText && last.sameMarkup(first2)) {
        content[content.length - 1] = last.withText(last.text + first2.text);
        i = 1;
      }
      for (; i < other.content.length; i++)
        content.push(other.content[i]);
      return new _Fragment(content, this.size + other.size);
    }
    /**
    Cut out the sub-fragment between the two given positions.
    */
    cut(from, to = this.size) {
      if (from == 0 && to == this.size)
        return this;
      let result = [], size = 0;
      if (to > from)
        for (let i = 0, pos = 0; pos < to; i++) {
          let child = this.content[i], end = pos + child.nodeSize;
          if (end > from) {
            if (pos < from || end > to) {
              if (child.isText)
                child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));
              else
                child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));
            }
            result.push(child);
            size += child.nodeSize;
          }
          pos = end;
        }
      return new _Fragment(result, size);
    }
    /**
    @internal
    */
    cutByIndex(from, to) {
      if (from == to)
        return _Fragment.empty;
      if (from == 0 && to == this.content.length)
        return this;
      return new _Fragment(this.content.slice(from, to));
    }
    /**
    Create a new fragment in which the node at the given index is
    replaced by the given node.
    */
    replaceChild(index, node) {
      let current = this.content[index];
      if (current == node)
        return this;
      let copy2 = this.content.slice();
      let size = this.size + node.nodeSize - current.nodeSize;
      copy2[index] = node;
      return new _Fragment(copy2, size);
    }
    /**
    Create a new fragment by prepending the given node to this
    fragment.
    */
    addToStart(node) {
      return new _Fragment([node].concat(this.content), this.size + node.nodeSize);
    }
    /**
    Create a new fragment by appending the given node to this
    fragment.
    */
    addToEnd(node) {
      return new _Fragment(this.content.concat(node), this.size + node.nodeSize);
    }
    /**
    Compare this fragment to another one.
    */
    eq(other) {
      if (this.content.length != other.content.length)
        return false;
      for (let i = 0; i < this.content.length; i++)
        if (!this.content[i].eq(other.content[i]))
          return false;
      return true;
    }
    /**
    The first child of the fragment, or `null` if it is empty.
    */
    get firstChild() {
      return this.content.length ? this.content[0] : null;
    }
    /**
    The last child of the fragment, or `null` if it is empty.
    */
    get lastChild() {
      return this.content.length ? this.content[this.content.length - 1] : null;
    }
    /**
    The number of child nodes in this fragment.
    */
    get childCount() {
      return this.content.length;
    }
    /**
    Get the child node at the given index. Raise an error when the
    index is out of range.
    */
    child(index) {
      let found2 = this.content[index];
      if (!found2)
        throw new RangeError("Index " + index + " out of range for " + this);
      return found2;
    }
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(index) {
      return this.content[index] || null;
    }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(f) {
      for (let i = 0, p = 0; i < this.content.length; i++) {
        let child = this.content[i];
        f(child, p, i);
        p += child.nodeSize;
      }
    }
    /**
    Find the first position at which this fragment and another
    fragment differ, or `null` if they are the same.
    */
    findDiffStart(other, pos = 0) {
      return findDiffStart(this, other, pos);
    }
    /**
    Find the first position, searching from the end, at which this
    fragment and the given fragment differ, or `null` if they are
    the same. Since this position will not be the same in both
    nodes, an object with two separate positions is returned.
    */
    findDiffEnd(other, pos = this.size, otherPos = other.size) {
      return findDiffEnd(this, other, pos, otherPos);
    }
    /**
    Find the index and inner offset corresponding to a given relative
    position in this fragment. The result object will be reused
    (overwritten) the next time the function is called. (Not public.)
    */
    findIndex(pos, round = -1) {
      if (pos == 0)
        return retIndex(0, pos);
      if (pos == this.size)
        return retIndex(this.content.length, pos);
      if (pos > this.size || pos < 0)
        throw new RangeError(`Position ${pos} outside of fragment (${this})`);
      for (let i = 0, curPos = 0; ; i++) {
        let cur = this.child(i), end = curPos + cur.nodeSize;
        if (end >= pos) {
          if (end == pos || round > 0)
            return retIndex(i + 1, end);
          return retIndex(i, curPos);
        }
        curPos = end;
      }
    }
    /**
    Return a debugging string that describes this fragment.
    */
    toString() {
      return "<" + this.toStringInner() + ">";
    }
    /**
    @internal
    */
    toStringInner() {
      return this.content.join(", ");
    }
    /**
    Create a JSON-serializeable representation of this fragment.
    */
    toJSON() {
      return this.content.length ? this.content.map((n) => n.toJSON()) : null;
    }
    /**
    Deserialize a fragment from its JSON representation.
    */
    static fromJSON(schema, value) {
      if (!value)
        return _Fragment.empty;
      if (!Array.isArray(value))
        throw new RangeError("Invalid input for Fragment.fromJSON");
      return new _Fragment(value.map(schema.nodeFromJSON));
    }
    /**
    Build a fragment from an array of nodes. Ensures that adjacent
    text nodes with the same marks are joined together.
    */
    static fromArray(array) {
      if (!array.length)
        return _Fragment.empty;
      let joined, size = 0;
      for (let i = 0; i < array.length; i++) {
        let node = array[i];
        size += node.nodeSize;
        if (i && node.isText && array[i - 1].sameMarkup(node)) {
          if (!joined)
            joined = array.slice(0, i);
          joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
        } else if (joined) {
          joined.push(node);
        }
      }
      return new _Fragment(joined || array, size);
    }
    /**
    Create a fragment from something that can be interpreted as a
    set of nodes. For `null`, it returns the empty fragment. For a
    fragment, the fragment itself. For a node or array of nodes, a
    fragment containing those nodes.
    */
    static from(nodes) {
      if (!nodes)
        return _Fragment.empty;
      if (nodes instanceof _Fragment)
        return nodes;
      if (Array.isArray(nodes))
        return this.fromArray(nodes);
      if (nodes.attrs)
        return new _Fragment([nodes], nodes.nodeSize);
      throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
    }
  };
  Fragment.empty = new Fragment([], 0);
  var found = { index: 0, offset: 0 };
  function retIndex(index, offset) {
    found.index = index;
    found.offset = offset;
    return found;
  }
  function compareDeep(a, b) {
    if (a === b)
      return true;
    if (!(a && typeof a == "object") || !(b && typeof b == "object"))
      return false;
    let array = Array.isArray(a);
    if (Array.isArray(b) != array)
      return false;
    if (array) {
      if (a.length != b.length)
        return false;
      for (let i = 0; i < a.length; i++)
        if (!compareDeep(a[i], b[i]))
          return false;
    } else {
      for (let p in a)
        if (!(p in b) || !compareDeep(a[p], b[p]))
          return false;
      for (let p in b)
        if (!(p in a))
          return false;
    }
    return true;
  }
  var Mark = class _Mark {
    /**
    @internal
    */
    constructor(type, attrs) {
      this.type = type;
      this.attrs = attrs;
    }
    /**
    Given a set of marks, create a new set which contains this one as
    well, in the right position. If this mark is already in the set,
    the set itself is returned. If any marks that are set to be
    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
    those are replaced by this one.
    */
    addToSet(set) {
      let copy2, placed = false;
      for (let i = 0; i < set.length; i++) {
        let other = set[i];
        if (this.eq(other))
          return set;
        if (this.type.excludes(other.type)) {
          if (!copy2)
            copy2 = set.slice(0, i);
        } else if (other.type.excludes(this.type)) {
          return set;
        } else {
          if (!placed && other.type.rank > this.type.rank) {
            if (!copy2)
              copy2 = set.slice(0, i);
            copy2.push(this);
            placed = true;
          }
          if (copy2)
            copy2.push(other);
        }
      }
      if (!copy2)
        copy2 = set.slice();
      if (!placed)
        copy2.push(this);
      return copy2;
    }
    /**
    Remove this mark from the given set, returning a new set. If this
    mark is not in the set, the set itself is returned.
    */
    removeFromSet(set) {
      for (let i = 0; i < set.length; i++)
        if (this.eq(set[i]))
          return set.slice(0, i).concat(set.slice(i + 1));
      return set;
    }
    /**
    Test whether this mark is in the given set of marks.
    */
    isInSet(set) {
      for (let i = 0; i < set.length; i++)
        if (this.eq(set[i]))
          return true;
      return false;
    }
    /**
    Test whether this mark has the same type and attributes as
    another mark.
    */
    eq(other) {
      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
    }
    /**
    Convert this mark to a JSON-serializeable representation.
    */
    toJSON() {
      let obj = { type: this.type.name };
      for (let _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      return obj;
    }
    /**
    Deserialize a mark from JSON.
    */
    static fromJSON(schema, json) {
      if (!json)
        throw new RangeError("Invalid input for Mark.fromJSON");
      let type = schema.marks[json.type];
      if (!type)
        throw new RangeError(`There is no mark type ${json.type} in this schema`);
      return type.create(json.attrs);
    }
    /**
    Test whether two sets of marks are identical.
    */
    static sameSet(a, b) {
      if (a == b)
        return true;
      if (a.length != b.length)
        return false;
      for (let i = 0; i < a.length; i++)
        if (!a[i].eq(b[i]))
          return false;
      return true;
    }
    /**
    Create a properly sorted mark set from null, a single mark, or an
    unsorted array of marks.
    */
    static setFrom(marks) {
      if (!marks || Array.isArray(marks) && marks.length == 0)
        return _Mark.none;
      if (marks instanceof _Mark)
        return [marks];
      let copy2 = marks.slice();
      copy2.sort((a, b) => a.type.rank - b.type.rank);
      return copy2;
    }
  };
  Mark.none = [];
  var ReplaceError = class extends Error {
  };
  var Slice = class _Slice {
    /**
    Create a slice. When specifying a non-zero open depth, you must
    make sure that there are nodes of at least that depth at the
    appropriate side of the fragment—i.e. if the fragment is an
    empty paragraph node, `openStart` and `openEnd` can't be greater
    than 1.
    
    It is not necessary for the content of open nodes to conform to
    the schema's content constraints, though it should be a valid
    start/end/middle for such a node, depending on which sides are
    open.
    */
    constructor(content, openStart, openEnd) {
      this.content = content;
      this.openStart = openStart;
      this.openEnd = openEnd;
    }
    /**
    The size this slice would add when inserted into a document.
    */
    get size() {
      return this.content.size - this.openStart - this.openEnd;
    }
    /**
    @internal
    */
    insertAt(pos, fragment) {
      let content = insertInto(this.content, pos + this.openStart, fragment);
      return content && new _Slice(content, this.openStart, this.openEnd);
    }
    /**
    @internal
    */
    removeBetween(from, to) {
      return new _Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);
    }
    /**
    Tests whether this slice is equal to another slice.
    */
    eq(other) {
      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
    }
    /**
    @internal
    */
    toString() {
      return this.content + "(" + this.openStart + "," + this.openEnd + ")";
    }
    /**
    Convert a slice to a JSON-serializable representation.
    */
    toJSON() {
      if (!this.content.size)
        return null;
      let json = { content: this.content.toJSON() };
      if (this.openStart > 0)
        json.openStart = this.openStart;
      if (this.openEnd > 0)
        json.openEnd = this.openEnd;
      return json;
    }
    /**
    Deserialize a slice from its JSON representation.
    */
    static fromJSON(schema, json) {
      if (!json)
        return _Slice.empty;
      let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
      if (typeof openStart != "number" || typeof openEnd != "number")
        throw new RangeError("Invalid input for Slice.fromJSON");
      return new _Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
    }
    /**
    Create a slice from a fragment by taking the maximum possible
    open value on both side of the fragment.
    */
    static maxOpen(fragment, openIsolating = true) {
      let openStart = 0, openEnd = 0;
      for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
        openStart++;
      for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
        openEnd++;
      return new _Slice(fragment, openStart, openEnd);
    }
  };
  Slice.empty = new Slice(Fragment.empty, 0, 0);
  function removeRange(content, from, to) {
    let { index, offset } = content.findIndex(from), child = content.maybeChild(index);
    let { index: indexTo, offset: offsetTo } = content.findIndex(to);
    if (offset == from || child.isText) {
      if (offsetTo != to && !content.child(indexTo).isText)
        throw new RangeError("Removing non-flat range");
      return content.cut(0, from).append(content.cut(to));
    }
    if (index != indexTo)
      throw new RangeError("Removing non-flat range");
    return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));
  }
  function insertInto(content, dist, insert, parent) {
    let { index, offset } = content.findIndex(dist), child = content.maybeChild(index);
    if (offset == dist || child.isText) {
      if (parent && !parent.canReplace(index, index, insert))
        return null;
      return content.cut(0, dist).append(insert).append(content.cut(dist));
    }
    let inner = insertInto(child.content, dist - offset - 1, insert);
    return inner && content.replaceChild(index, child.copy(inner));
  }
  function replace($from, $to, slice) {
    if (slice.openStart > $from.depth)
      throw new ReplaceError("Inserted content deeper than insertion position");
    if ($from.depth - slice.openStart != $to.depth - slice.openEnd)
      throw new ReplaceError("Inconsistent open depths");
    return replaceOuter($from, $to, slice, 0);
  }
  function replaceOuter($from, $to, slice, depth) {
    let index = $from.index(depth), node = $from.node(depth);
    if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
      let inner = replaceOuter($from, $to, slice, depth + 1);
      return node.copy(node.content.replaceChild(index, inner));
    } else if (!slice.content.size) {
      return close(node, replaceTwoWay($from, $to, depth));
    } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {
      let parent = $from.parent, content = parent.content;
      return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));
    } else {
      let { start, end } = prepareSliceForReplace(slice, $from);
      return close(node, replaceThreeWay($from, start, end, $to, depth));
    }
  }
  function checkJoin(main, sub) {
    if (!sub.type.compatibleContent(main.type))
      throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
  }
  function joinable($before, $after, depth) {
    let node = $before.node(depth);
    checkJoin(node, $after.node(depth));
    return node;
  }
  function addNode(child, target) {
    let last = target.length - 1;
    if (last >= 0 && child.isText && child.sameMarkup(target[last]))
      target[last] = child.withText(target[last].text + child.text);
    else
      target.push(child);
  }
  function addRange($start, $end, depth, target) {
    let node = ($end || $start).node(depth);
    let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
    if ($start) {
      startIndex = $start.index(depth);
      if ($start.depth > depth) {
        startIndex++;
      } else if ($start.textOffset) {
        addNode($start.nodeAfter, target);
        startIndex++;
      }
    }
    for (let i = startIndex; i < endIndex; i++)
      addNode(node.child(i), target);
    if ($end && $end.depth == depth && $end.textOffset)
      addNode($end.nodeBefore, target);
  }
  function close(node, content) {
    node.type.checkContent(content);
    return node.copy(content);
  }
  function replaceThreeWay($from, $start, $end, $to, depth) {
    let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
    let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
    let content = [];
    addRange(null, $from, depth, content);
    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
      checkJoin(openStart, openEnd);
      addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
    } else {
      if (openStart)
        addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
      addRange($start, $end, depth, content);
      if (openEnd)
        addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
    }
    addRange($to, null, depth, content);
    return new Fragment(content);
  }
  function replaceTwoWay($from, $to, depth) {
    let content = [];
    addRange(null, $from, depth, content);
    if ($from.depth > depth) {
      let type = joinable($from, $to, depth + 1);
      addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
    }
    addRange($to, null, depth, content);
    return new Fragment(content);
  }
  function prepareSliceForReplace(slice, $along) {
    let extra = $along.depth - slice.openStart, parent = $along.node(extra);
    let node = parent.copy(slice.content);
    for (let i = extra - 1; i >= 0; i--)
      node = $along.node(i).copy(Fragment.from(node));
    return {
      start: node.resolveNoCache(slice.openStart + extra),
      end: node.resolveNoCache(node.content.size - slice.openEnd - extra)
    };
  }
  var ResolvedPos = class _ResolvedPos {
    /**
    @internal
    */
    constructor(pos, path, parentOffset) {
      this.pos = pos;
      this.path = path;
      this.parentOffset = parentOffset;
      this.depth = path.length / 3 - 1;
    }
    /**
    @internal
    */
    resolveDepth(val) {
      if (val == null)
        return this.depth;
      if (val < 0)
        return this.depth + val;
      return val;
    }
    /**
    The parent node that the position points into. Note that even if
    a position points into a text node, that node is not considered
    the parent—text nodes are ‘flat’ in this model, and have no content.
    */
    get parent() {
      return this.node(this.depth);
    }
    /**
    The root node in which the position was resolved.
    */
    get doc() {
      return this.node(0);
    }
    /**
    The ancestor node at the given level. `p.node(p.depth)` is the
    same as `p.parent`.
    */
    node(depth) {
      return this.path[this.resolveDepth(depth) * 3];
    }
    /**
    The index into the ancestor at the given level. If this points
    at the 3rd node in the 2nd paragraph on the top level, for
    example, `p.index(0)` is 1 and `p.index(1)` is 2.
    */
    index(depth) {
      return this.path[this.resolveDepth(depth) * 3 + 1];
    }
    /**
    The index pointing after this position into the ancestor at the
    given level.
    */
    indexAfter(depth) {
      depth = this.resolveDepth(depth);
      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
    }
    /**
    The (absolute) position at the start of the node at the given
    level.
    */
    start(depth) {
      depth = this.resolveDepth(depth);
      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    }
    /**
    The (absolute) position at the end of the node at the given
    level.
    */
    end(depth) {
      depth = this.resolveDepth(depth);
      return this.start(depth) + this.node(depth).content.size;
    }
    /**
    The (absolute) position directly before the wrapping node at the
    given level, or, when `depth` is `this.depth + 1`, the original
    position.
    */
    before(depth) {
      depth = this.resolveDepth(depth);
      if (!depth)
        throw new RangeError("There is no position before the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
    }
    /**
    The (absolute) position directly after the wrapping node at the
    given level, or the original position when `depth` is `this.depth + 1`.
    */
    after(depth) {
      depth = this.resolveDepth(depth);
      if (!depth)
        throw new RangeError("There is no position after the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
    }
    /**
    When this position points into a text node, this returns the
    distance between the position and the start of the text node.
    Will be zero for positions that point between nodes.
    */
    get textOffset() {
      return this.pos - this.path[this.path.length - 1];
    }
    /**
    Get the node directly after the position, if any. If the position
    points into a text node, only the part of that node after the
    position is returned.
    */
    get nodeAfter() {
      let parent = this.parent, index = this.index(this.depth);
      if (index == parent.childCount)
        return null;
      let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
      return dOff ? parent.child(index).cut(dOff) : child;
    }
    /**
    Get the node directly before the position, if any. If the
    position points into a text node, only the part of that node
    before the position is returned.
    */
    get nodeBefore() {
      let index = this.index(this.depth);
      let dOff = this.pos - this.path[this.path.length - 1];
      if (dOff)
        return this.parent.child(index).cut(0, dOff);
      return index == 0 ? null : this.parent.child(index - 1);
    }
    /**
    Get the position at the given index in the parent node at the
    given depth (which defaults to `this.depth`).
    */
    posAtIndex(index, depth) {
      depth = this.resolveDepth(depth);
      let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
      for (let i = 0; i < index; i++)
        pos += node.child(i).nodeSize;
      return pos;
    }
    /**
    Get the marks at this position, factoring in the surrounding
    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
    position is at the start of a non-empty node, the marks of the
    node after it (if any) are returned.
    */
    marks() {
      let parent = this.parent, index = this.index();
      if (parent.content.size == 0)
        return Mark.none;
      if (this.textOffset)
        return parent.child(index).marks;
      let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);
      if (!main) {
        let tmp = main;
        main = other;
        other = tmp;
      }
      let marks = main.marks;
      for (var i = 0; i < marks.length; i++)
        if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
          marks = marks[i--].removeFromSet(marks);
      return marks;
    }
    /**
    Get the marks after the current position, if any, except those
    that are non-inclusive and not present at position `$end`. This
    is mostly useful for getting the set of marks to preserve after a
    deletion. Will return `null` if this position is at the end of
    its parent node or its parent node isn't a textblock (in which
    case no marks should be preserved).
    */
    marksAcross($end) {
      let after = this.parent.maybeChild(this.index());
      if (!after || !after.isInline)
        return null;
      let marks = after.marks, next = $end.parent.maybeChild($end.index());
      for (var i = 0; i < marks.length; i++)
        if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
          marks = marks[i--].removeFromSet(marks);
      return marks;
    }
    /**
    The depth up to which this position and the given (non-resolved)
    position share the same parent nodes.
    */
    sharedDepth(pos) {
      for (let depth = this.depth; depth > 0; depth--)
        if (this.start(depth) <= pos && this.end(depth) >= pos)
          return depth;
      return 0;
    }
    /**
    Returns a range based on the place where this position and the
    given position diverge around block content. If both point into
    the same textblock, for example, a range around that textblock
    will be returned. If they point into different blocks, the range
    around those blocks in their shared ancestor is returned. You can
    pass in an optional predicate that will be called with a parent
    node to see if a range into that parent is acceptable.
    */
    blockRange(other = this, pred) {
      if (other.pos < this.pos)
        return other.blockRange(this);
      for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
        if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
          return new NodeRange(this, other, d);
      return null;
    }
    /**
    Query whether the given position shares the same parent node.
    */
    sameParent(other) {
      return this.pos - this.parentOffset == other.pos - other.parentOffset;
    }
    /**
    Return the greater of this and the given position.
    */
    max(other) {
      return other.pos > this.pos ? other : this;
    }
    /**
    Return the smaller of this and the given position.
    */
    min(other) {
      return other.pos < this.pos ? other : this;
    }
    /**
    @internal
    */
    toString() {
      let str = "";
      for (let i = 1; i <= this.depth; i++)
        str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
      return str + ":" + this.parentOffset;
    }
    /**
    @internal
    */
    static resolve(doc, pos) {
      if (!(pos >= 0 && pos <= doc.content.size))
        throw new RangeError("Position " + pos + " out of range");
      let path = [];
      let start = 0, parentOffset = pos;
      for (let node = doc; ; ) {
        let { index, offset } = node.content.findIndex(parentOffset);
        let rem = parentOffset - offset;
        path.push(node, index, start + offset);
        if (!rem)
          break;
        node = node.child(index);
        if (node.isText)
          break;
        parentOffset = rem - 1;
        start += offset + 1;
      }
      return new _ResolvedPos(pos, path, parentOffset);
    }
    /**
    @internal
    */
    static resolveCached(doc, pos) {
      for (let i = 0; i < resolveCache.length; i++) {
        let cached = resolveCache[i];
        if (cached.pos == pos && cached.doc == doc)
          return cached;
      }
      let result = resolveCache[resolveCachePos] = _ResolvedPos.resolve(doc, pos);
      resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
      return result;
    }
  };
  var resolveCache = [];
  var resolveCachePos = 0;
  var resolveCacheSize = 12;
  var NodeRange = class {
    /**
    Construct a node range. `$from` and `$to` should point into the
    same node until at least the given `depth`, since a node range
    denotes an adjacent set of nodes in a single parent node.
    */
    constructor($from, $to, depth) {
      this.$from = $from;
      this.$to = $to;
      this.depth = depth;
    }
    /**
    The position at the start of the range.
    */
    get start() {
      return this.$from.before(this.depth + 1);
    }
    /**
    The position at the end of the range.
    */
    get end() {
      return this.$to.after(this.depth + 1);
    }
    /**
    The parent node that the range points into.
    */
    get parent() {
      return this.$from.node(this.depth);
    }
    /**
    The start index of the range in the parent node.
    */
    get startIndex() {
      return this.$from.index(this.depth);
    }
    /**
    The end index of the range in the parent node.
    */
    get endIndex() {
      return this.$to.indexAfter(this.depth);
    }
  };
  var emptyAttrs = /* @__PURE__ */ Object.create(null);
  var Node = class _Node {
    /**
    @internal
    */
    constructor(type, attrs, content, marks = Mark.none) {
      this.type = type;
      this.attrs = attrs;
      this.marks = marks;
      this.content = content || Fragment.empty;
    }
    /**
    The size of this node, as defined by the integer-based [indexing
    scheme](/docs/guide/#doc.indexing). For text nodes, this is the
    amount of characters. For other leaf nodes, it is one. For
    non-leaf nodes, it is the size of the content plus two (the
    start and end token).
    */
    get nodeSize() {
      return this.isLeaf ? 1 : 2 + this.content.size;
    }
    /**
    The number of children that the node has.
    */
    get childCount() {
      return this.content.childCount;
    }
    /**
    Get the child node at the given index. Raises an error when the
    index is out of range.
    */
    child(index) {
      return this.content.child(index);
    }
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(index) {
      return this.content.maybeChild(index);
    }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(f) {
      this.content.forEach(f);
    }
    /**
    Invoke a callback for all descendant nodes recursively between
    the given two positions that are relative to start of this
    node's content. The callback is invoked with the node, its
    position relative to the original node (method receiver),
    its parent node, and its child index. When the callback returns
    false for a given node, that node's children will not be
    recursed over. The last parameter can be used to specify a
    starting position to count from.
    */
    nodesBetween(from, to, f, startPos = 0) {
      this.content.nodesBetween(from, to, f, startPos, this);
    }
    /**
    Call the given callback for every descendant node. Doesn't
    descend into a node when the callback returns `false`.
    */
    descendants(f) {
      this.nodesBetween(0, this.content.size, f);
    }
    /**
    Concatenates all the text nodes found in this fragment and its
    children.
    */
    get textContent() {
      return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
    }
    /**
    Get all text between positions `from` and `to`. When
    `blockSeparator` is given, it will be inserted to separate text
    from different block nodes. If `leafText` is given, it'll be
    inserted for every non-text leaf node encountered, otherwise
    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
    */
    textBetween(from, to, blockSeparator, leafText) {
      return this.content.textBetween(from, to, blockSeparator, leafText);
    }
    /**
    Returns this node's first child, or `null` if there are no
    children.
    */
    get firstChild() {
      return this.content.firstChild;
    }
    /**
    Returns this node's last child, or `null` if there are no
    children.
    */
    get lastChild() {
      return this.content.lastChild;
    }
    /**
    Test whether two nodes represent the same piece of document.
    */
    eq(other) {
      return this == other || this.sameMarkup(other) && this.content.eq(other.content);
    }
    /**
    Compare the markup (type, attributes, and marks) of this node to
    those of another. Returns `true` if both have the same markup.
    */
    sameMarkup(other) {
      return this.hasMarkup(other.type, other.attrs, other.marks);
    }
    /**
    Check whether this node's markup correspond to the given type,
    attributes, and marks.
    */
    hasMarkup(type, attrs, marks) {
      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
    }
    /**
    Create a new node with the same markup as this node, containing
    the given content (or empty, if no content is given).
    */
    copy(content = null) {
      if (content == this.content)
        return this;
      return new _Node(this.type, this.attrs, content, this.marks);
    }
    /**
    Create a copy of this node, with the given set of marks instead
    of the node's own marks.
    */
    mark(marks) {
      return marks == this.marks ? this : new _Node(this.type, this.attrs, this.content, marks);
    }
    /**
    Create a copy of this node with only the content between the
    given positions. If `to` is not given, it defaults to the end of
    the node.
    */
    cut(from, to = this.content.size) {
      if (from == 0 && to == this.content.size)
        return this;
      return this.copy(this.content.cut(from, to));
    }
    /**
    Cut out the part of the document between the given positions, and
    return it as a `Slice` object.
    */
    slice(from, to = this.content.size, includeParents = false) {
      if (from == to)
        return Slice.empty;
      let $from = this.resolve(from), $to = this.resolve(to);
      let depth = includeParents ? 0 : $from.sharedDepth(to);
      let start = $from.start(depth), node = $from.node(depth);
      let content = node.content.cut($from.pos - start, $to.pos - start);
      return new Slice(content, $from.depth - depth, $to.depth - depth);
    }
    /**
    Replace the part of the document between the given positions with
    the given slice. The slice must 'fit', meaning its open sides
    must be able to connect to the surrounding content, and its
    content nodes must be valid children for the node they are placed
    into. If any of this is violated, an error of type
    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
    */
    replace(from, to, slice) {
      return replace(this.resolve(from), this.resolve(to), slice);
    }
    /**
    Find the node directly after the given position.
    */
    nodeAt(pos) {
      for (let node = this; ; ) {
        let { index, offset } = node.content.findIndex(pos);
        node = node.maybeChild(index);
        if (!node)
          return null;
        if (offset == pos || node.isText)
          return node;
        pos -= offset + 1;
      }
    }
    /**
    Find the (direct) child node after the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childAfter(pos) {
      let { index, offset } = this.content.findIndex(pos);
      return { node: this.content.maybeChild(index), index, offset };
    }
    /**
    Find the (direct) child node before the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childBefore(pos) {
      if (pos == 0)
        return { node: null, index: 0, offset: 0 };
      let { index, offset } = this.content.findIndex(pos);
      if (offset < pos)
        return { node: this.content.child(index), index, offset };
      let node = this.content.child(index - 1);
      return { node, index: index - 1, offset: offset - node.nodeSize };
    }
    /**
    Resolve the given position in the document, returning an
    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
    */
    resolve(pos) {
      return ResolvedPos.resolveCached(this, pos);
    }
    /**
    @internal
    */
    resolveNoCache(pos) {
      return ResolvedPos.resolve(this, pos);
    }
    /**
    Test whether a given mark or mark type occurs in this document
    between the two given positions.
    */
    rangeHasMark(from, to, type) {
      let found2 = false;
      if (to > from)
        this.nodesBetween(from, to, (node) => {
          if (type.isInSet(node.marks))
            found2 = true;
          return !found2;
        });
      return found2;
    }
    /**
    True when this is a block (non-inline node)
    */
    get isBlock() {
      return this.type.isBlock;
    }
    /**
    True when this is a textblock node, a block node with inline
    content.
    */
    get isTextblock() {
      return this.type.isTextblock;
    }
    /**
    True when this node allows inline content.
    */
    get inlineContent() {
      return this.type.inlineContent;
    }
    /**
    True when this is an inline node (a text node or a node that can
    appear among text).
    */
    get isInline() {
      return this.type.isInline;
    }
    /**
    True when this is a text node.
    */
    get isText() {
      return this.type.isText;
    }
    /**
    True when this is a leaf node.
    */
    get isLeaf() {
      return this.type.isLeaf;
    }
    /**
    True when this is an atom, i.e. when it does not have directly
    editable content. This is usually the same as `isLeaf`, but can
    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
    on a node's spec (typically used when the node is displayed as
    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
    */
    get isAtom() {
      return this.type.isAtom;
    }
    /**
    Return a string representation of this node for debugging
    purposes.
    */
    toString() {
      if (this.type.spec.toDebugString)
        return this.type.spec.toDebugString(this);
      let name = this.type.name;
      if (this.content.size)
        name += "(" + this.content.toStringInner() + ")";
      return wrapMarks(this.marks, name);
    }
    /**
    Get the content match in this node at the given index.
    */
    contentMatchAt(index) {
      let match = this.type.contentMatch.matchFragment(this.content, 0, index);
      if (!match)
        throw new Error("Called contentMatchAt on a node with invalid content");
      return match;
    }
    /**
    Test whether replacing the range between `from` and `to` (by
    child index) with the given replacement fragment (which defaults
    to the empty fragment) would leave the node's content valid. You
    can optionally pass `start` and `end` indices into the
    replacement fragment.
    */
    canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {
      let one = this.contentMatchAt(from).matchFragment(replacement, start, end);
      let two = one && one.matchFragment(this.content, to);
      if (!two || !two.validEnd)
        return false;
      for (let i = start; i < end; i++)
        if (!this.type.allowsMarks(replacement.child(i).marks))
          return false;
      return true;
    }
    /**
    Test whether replacing the range `from` to `to` (by index) with
    a node of the given type would leave the node's content valid.
    */
    canReplaceWith(from, to, type, marks) {
      if (marks && !this.type.allowsMarks(marks))
        return false;
      let start = this.contentMatchAt(from).matchType(type);
      let end = start && start.matchFragment(this.content, to);
      return end ? end.validEnd : false;
    }
    /**
    Test whether the given node's content could be appended to this
    node. If that node is empty, this will only return true if there
    is at least one node type that can appear in both nodes (to avoid
    merging completely incompatible nodes).
    */
    canAppend(other) {
      if (other.content.size)
        return this.canReplace(this.childCount, this.childCount, other.content);
      else
        return this.type.compatibleContent(other.type);
    }
    /**
    Check whether this node and its descendants conform to the
    schema, and raise error when they do not.
    */
    check() {
      this.type.checkContent(this.content);
      let copy2 = Mark.none;
      for (let i = 0; i < this.marks.length; i++)
        copy2 = this.marks[i].addToSet(copy2);
      if (!Mark.sameSet(copy2, this.marks))
        throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
      this.content.forEach((node) => node.check());
    }
    /**
    Return a JSON-serializeable representation of this node.
    */
    toJSON() {
      let obj = { type: this.type.name };
      for (let _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      if (this.content.size)
        obj.content = this.content.toJSON();
      if (this.marks.length)
        obj.marks = this.marks.map((n) => n.toJSON());
      return obj;
    }
    /**
    Deserialize a node from its JSON representation.
    */
    static fromJSON(schema, json) {
      if (!json)
        throw new RangeError("Invalid input for Node.fromJSON");
      let marks = null;
      if (json.marks) {
        if (!Array.isArray(json.marks))
          throw new RangeError("Invalid mark data for Node.fromJSON");
        marks = json.marks.map(schema.markFromJSON);
      }
      if (json.type == "text") {
        if (typeof json.text != "string")
          throw new RangeError("Invalid text node in JSON");
        return schema.text(json.text, marks);
      }
      let content = Fragment.fromJSON(schema, json.content);
      return schema.nodeType(json.type).create(json.attrs, content, marks);
    }
  };
  Node.prototype.text = void 0;
  function wrapMarks(marks, str) {
    for (let i = marks.length - 1; i >= 0; i--)
      str = marks[i].type.name + "(" + str + ")";
    return str;
  }
  var ContentMatch = class _ContentMatch {
    /**
    @internal
    */
    constructor(validEnd) {
      this.validEnd = validEnd;
      this.next = [];
      this.wrapCache = [];
    }
    /**
    @internal
    */
    static parse(string, nodeTypes) {
      let stream = new TokenStream(string, nodeTypes);
      if (stream.next == null)
        return _ContentMatch.empty;
      let expr = parseExpr(stream);
      if (stream.next)
        stream.err("Unexpected trailing text");
      let match = dfa(nfa(expr));
      checkForDeadEnds(match, stream);
      return match;
    }
    /**
    Match a node type, returning a match after that node if
    successful.
    */
    matchType(type) {
      for (let i = 0; i < this.next.length; i++)
        if (this.next[i].type == type)
          return this.next[i].next;
      return null;
    }
    /**
    Try to match a fragment. Returns the resulting match when
    successful.
    */
    matchFragment(frag, start = 0, end = frag.childCount) {
      let cur = this;
      for (let i = start; cur && i < end; i++)
        cur = cur.matchType(frag.child(i).type);
      return cur;
    }
    /**
    @internal
    */
    get inlineContent() {
      return this.next.length != 0 && this.next[0].type.isInline;
    }
    /**
    Get the first matching node type at this match position that can
    be generated.
    */
    get defaultType() {
      for (let i = 0; i < this.next.length; i++) {
        let { type } = this.next[i];
        if (!(type.isText || type.hasRequiredAttrs()))
          return type;
      }
      return null;
    }
    /**
    @internal
    */
    compatible(other) {
      for (let i = 0; i < this.next.length; i++)
        for (let j = 0; j < other.next.length; j++)
          if (this.next[i].type == other.next[j].type)
            return true;
      return false;
    }
    /**
    Try to match the given fragment, and if that fails, see if it can
    be made to match by inserting nodes in front of it. When
    successful, return a fragment of inserted nodes (which may be
    empty if nothing had to be inserted). When `toEnd` is true, only
    return a fragment if the resulting match goes to the end of the
    content expression.
    */
    fillBefore(after, toEnd = false, startIndex = 0) {
      let seen = [this];
      function search(match, types) {
        let finished = match.matchFragment(after, startIndex);
        if (finished && (!toEnd || finished.validEnd))
          return Fragment.from(types.map((tp) => tp.createAndFill()));
        for (let i = 0; i < match.next.length; i++) {
          let { type, next } = match.next[i];
          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
            seen.push(next);
            let found2 = search(next, types.concat(type));
            if (found2)
              return found2;
          }
        }
        return null;
      }
      return search(this, []);
    }
    /**
    Find a set of wrapping node types that would allow a node of the
    given type to appear at this position. The result may be empty
    (when it fits directly) and will be null when no such wrapping
    exists.
    */
    findWrapping(target) {
      for (let i = 0; i < this.wrapCache.length; i += 2)
        if (this.wrapCache[i] == target)
          return this.wrapCache[i + 1];
      let computed = this.computeWrapping(target);
      this.wrapCache.push(target, computed);
      return computed;
    }
    /**
    @internal
    */
    computeWrapping(target) {
      let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
      while (active.length) {
        let current = active.shift(), match = current.match;
        if (match.matchType(target)) {
          let result = [];
          for (let obj = current; obj.type; obj = obj.via)
            result.push(obj.type);
          return result.reverse();
        }
        for (let i = 0; i < match.next.length; i++) {
          let { type, next } = match.next[i];
          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
            active.push({ match: type.contentMatch, type, via: current });
            seen[type.name] = true;
          }
        }
      }
      return null;
    }
    /**
    The number of outgoing edges this node has in the finite
    automaton that describes the content expression.
    */
    get edgeCount() {
      return this.next.length;
    }
    /**
    Get the _n_​th outgoing edge from this node in the finite
    automaton that describes the content expression.
    */
    edge(n) {
      if (n >= this.next.length)
        throw new RangeError(`There's no ${n}th edge in this content match`);
      return this.next[n];
    }
    /**
    @internal
    */
    toString() {
      let seen = [];
      function scan(m) {
        seen.push(m);
        for (let i = 0; i < m.next.length; i++)
          if (seen.indexOf(m.next[i].next) == -1)
            scan(m.next[i].next);
      }
      scan(this);
      return seen.map((m, i) => {
        let out = i + (m.validEnd ? "*" : " ") + " ";
        for (let i2 = 0; i2 < m.next.length; i2++)
          out += (i2 ? ", " : "") + m.next[i2].type.name + "->" + seen.indexOf(m.next[i2].next);
        return out;
      }).join("\n");
    }
  };
  ContentMatch.empty = new ContentMatch(true);
  var TokenStream = class {
    constructor(string, nodeTypes) {
      this.string = string;
      this.nodeTypes = nodeTypes;
      this.inline = null;
      this.pos = 0;
      this.tokens = string.split(/\s*(?=\b|\W|$)/);
      if (this.tokens[this.tokens.length - 1] == "")
        this.tokens.pop();
      if (this.tokens[0] == "")
        this.tokens.shift();
    }
    get next() {
      return this.tokens[this.pos];
    }
    eat(tok) {
      return this.next == tok && (this.pos++ || true);
    }
    err(str) {
      throw new SyntaxError(str + " (in content expression '" + this.string + "')");
    }
  };
  function parseExpr(stream) {
    let exprs = [];
    do {
      exprs.push(parseExprSeq(stream));
    } while (stream.eat("|"));
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  }
  function parseExprSeq(stream) {
    let exprs = [];
    do {
      exprs.push(parseExprSubscript(stream));
    } while (stream.next && stream.next != ")" && stream.next != "|");
    return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
  }
  function parseExprSubscript(stream) {
    let expr = parseExprAtom(stream);
    for (; ; ) {
      if (stream.eat("+"))
        expr = { type: "plus", expr };
      else if (stream.eat("*"))
        expr = { type: "star", expr };
      else if (stream.eat("?"))
        expr = { type: "opt", expr };
      else if (stream.eat("{"))
        expr = parseExprRange(stream, expr);
      else
        break;
    }
    return expr;
  }
  function parseNum(stream) {
    if (/\D/.test(stream.next))
      stream.err("Expected number, got '" + stream.next + "'");
    let result = Number(stream.next);
    stream.pos++;
    return result;
  }
  function parseExprRange(stream, expr) {
    let min = parseNum(stream), max = min;
    if (stream.eat(",")) {
      if (stream.next != "}")
        max = parseNum(stream);
      else
        max = -1;
    }
    if (!stream.eat("}"))
      stream.err("Unclosed braced range");
    return { type: "range", min, max, expr };
  }
  function resolveName(stream, name) {
    let types = stream.nodeTypes, type = types[name];
    if (type)
      return [type];
    let result = [];
    for (let typeName in types) {
      let type2 = types[typeName];
      if (type2.groups.indexOf(name) > -1)
        result.push(type2);
    }
    if (result.length == 0)
      stream.err("No node type or group '" + name + "' found");
    return result;
  }
  function parseExprAtom(stream) {
    if (stream.eat("(")) {
      let expr = parseExpr(stream);
      if (!stream.eat(")"))
        stream.err("Missing closing paren");
      return expr;
    } else if (!/\W/.test(stream.next)) {
      let exprs = resolveName(stream, stream.next).map((type) => {
        if (stream.inline == null)
          stream.inline = type.isInline;
        else if (stream.inline != type.isInline)
          stream.err("Mixing inline and block content");
        return { type: "name", value: type };
      });
      stream.pos++;
      return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
    } else {
      stream.err("Unexpected token '" + stream.next + "'");
    }
  }
  function nfa(expr) {
    let nfa2 = [[]];
    connect(compile(expr, 0), node());
    return nfa2;
    function node() {
      return nfa2.push([]) - 1;
    }
    function edge(from, to, term) {
      let edge2 = { term, to };
      nfa2[from].push(edge2);
      return edge2;
    }
    function connect(edges, to) {
      edges.forEach((edge2) => edge2.to = to);
    }
    function compile(expr2, from) {
      if (expr2.type == "choice") {
        return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from)), []);
      } else if (expr2.type == "seq") {
        for (let i = 0; ; i++) {
          let next = compile(expr2.exprs[i], from);
          if (i == expr2.exprs.length - 1)
            return next;
          connect(next, from = node());
        }
      } else if (expr2.type == "star") {
        let loop = node();
        edge(from, loop);
        connect(compile(expr2.expr, loop), loop);
        return [edge(loop)];
      } else if (expr2.type == "plus") {
        let loop = node();
        connect(compile(expr2.expr, from), loop);
        connect(compile(expr2.expr, loop), loop);
        return [edge(loop)];
      } else if (expr2.type == "opt") {
        return [edge(from)].concat(compile(expr2.expr, from));
      } else if (expr2.type == "range") {
        let cur = from;
        for (let i = 0; i < expr2.min; i++) {
          let next = node();
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
        if (expr2.max == -1) {
          connect(compile(expr2.expr, cur), cur);
        } else {
          for (let i = expr2.min; i < expr2.max; i++) {
            let next = node();
            edge(cur, next);
            connect(compile(expr2.expr, cur), next);
            cur = next;
          }
        }
        return [edge(cur)];
      } else if (expr2.type == "name") {
        return [edge(from, void 0, expr2.value)];
      } else {
        throw new Error("Unknown expr type");
      }
    }
  }
  function cmp(a, b) {
    return b - a;
  }
  function nullFrom(nfa2, node) {
    let result = [];
    scan(node);
    return result.sort(cmp);
    function scan(node2) {
      let edges = nfa2[node2];
      if (edges.length == 1 && !edges[0].term)
        return scan(edges[0].to);
      result.push(node2);
      for (let i = 0; i < edges.length; i++) {
        let { term, to } = edges[i];
        if (!term && result.indexOf(to) == -1)
          scan(to);
      }
    }
  }
  function dfa(nfa2) {
    let labeled = /* @__PURE__ */ Object.create(null);
    return explore(nullFrom(nfa2, 0));
    function explore(states) {
      let out = [];
      states.forEach((node) => {
        nfa2[node].forEach(({ term, to }) => {
          if (!term)
            return;
          let set;
          for (let i = 0; i < out.length; i++)
            if (out[i][0] == term)
              set = out[i][1];
          nullFrom(nfa2, to).forEach((node2) => {
            if (!set)
              out.push([term, set = []]);
            if (set.indexOf(node2) == -1)
              set.push(node2);
          });
        });
      });
      let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
      for (let i = 0; i < out.length; i++) {
        let states2 = out[i][1].sort(cmp);
        state.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
      }
      return state;
    }
  }
  function checkForDeadEnds(match, stream) {
    for (let i = 0, work = [match]; i < work.length; i++) {
      let state = work[i], dead = !state.validEnd, nodes = [];
      for (let j = 0; j < state.next.length; j++) {
        let { type, next } = state.next[j];
        nodes.push(type.name);
        if (dead && !(type.isText || type.hasRequiredAttrs()))
          dead = false;
        if (work.indexOf(next) == -1)
          work.push(next);
      }
      if (dead)
        stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
  var DOMParser = class _DOMParser {
    /**
    Create a parser that targets the given schema, using the given
    parsing rules.
    */
    constructor(schema, rules) {
      this.schema = schema;
      this.rules = rules;
      this.tags = [];
      this.styles = [];
      rules.forEach((rule) => {
        if (rule.tag)
          this.tags.push(rule);
        else if (rule.style)
          this.styles.push(rule);
      });
      this.normalizeLists = !this.tags.some((r) => {
        if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
          return false;
        let node = schema.nodes[r.node];
        return node.contentMatch.matchType(node);
      });
    }
    /**
    Parse a document from the content of a DOM node.
    */
    parse(dom, options = {}) {
      let context = new ParseContext(this, options, false);
      context.addAll(dom, options.from, options.to);
      return context.finish();
    }
    /**
    Parses the content of the given DOM node, like
    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
    options. But unlike that method, which produces a whole node,
    this one returns a slice that is open at the sides, meaning that
    the schema constraints aren't applied to the start of nodes to
    the left of the input and the end of nodes at the end.
    */
    parseSlice(dom, options = {}) {
      let context = new ParseContext(this, options, true);
      context.addAll(dom, options.from, options.to);
      return Slice.maxOpen(context.finish());
    }
    /**
    @internal
    */
    matchTag(dom, context, after) {
      for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
        let rule = this.tags[i];
        if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
          if (rule.getAttrs) {
            let result = rule.getAttrs(dom);
            if (result === false)
              continue;
            rule.attrs = result || void 0;
          }
          return rule;
        }
      }
    }
    /**
    @internal
    */
    matchStyle(prop, value, context, after) {
      for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
        let rule = this.styles[i], style = rule.style;
        if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
        // or has an '=' sign after the prop, followed by the given
        // value.
        style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value))
          continue;
        if (rule.getAttrs) {
          let result = rule.getAttrs(value);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
    /**
    @internal
    */
    static schemaRules(schema) {
      let result = [];
      function insert(rule) {
        let priority = rule.priority == null ? 50 : rule.priority, i = 0;
        for (; i < result.length; i++) {
          let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
          if (nextPriority < priority)
            break;
        }
        result.splice(i, 0, rule);
      }
      for (let name in schema.marks) {
        let rules = schema.marks[name].spec.parseDOM;
        if (rules)
          rules.forEach((rule) => {
            insert(rule = copy(rule));
            if (!(rule.mark || rule.ignore || rule.clearMark))
              rule.mark = name;
          });
      }
      for (let name in schema.nodes) {
        let rules = schema.nodes[name].spec.parseDOM;
        if (rules)
          rules.forEach((rule) => {
            insert(rule = copy(rule));
            if (!(rule.node || rule.ignore || rule.mark))
              rule.node = name;
          });
      }
      return result;
    }
    /**
    Construct a DOM parser using the parsing rules listed in a
    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
    [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
    */
    static fromSchema(schema) {
      return schema.cached.domParser || (schema.cached.domParser = new _DOMParser(schema, _DOMParser.schemaRules(schema)));
    }
  };
  var blockTags = {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    canvas: true,
    dd: true,
    div: true,
    dl: true,
    fieldset: true,
    figcaption: true,
    figure: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    li: true,
    noscript: true,
    ol: true,
    output: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    tfoot: true,
    ul: true
  };
  var ignoreTags = {
    head: true,
    noscript: true,
    object: true,
    script: true,
    style: true,
    title: true
  };
  var listTags = { ol: true, ul: true };
  var OPT_PRESERVE_WS = 1;
  var OPT_PRESERVE_WS_FULL = 2;
  var OPT_OPEN_LEFT = 4;
  function wsOptionsFor(type, preserveWhitespace, base) {
    if (preserveWhitespace != null)
      return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
    return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;
  }
  var NodeContext = class {
    constructor(type, attrs, marks, pendingMarks, solid, match, options) {
      this.type = type;
      this.attrs = attrs;
      this.marks = marks;
      this.pendingMarks = pendingMarks;
      this.solid = solid;
      this.options = options;
      this.content = [];
      this.activeMarks = Mark.none;
      this.stashMarks = [];
      this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
    }
    findWrapping(node) {
      if (!this.match) {
        if (!this.type)
          return [];
        let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
        if (fill) {
          this.match = this.type.contentMatch.matchFragment(fill);
        } else {
          let start = this.type.contentMatch, wrap;
          if (wrap = start.findWrapping(node.type)) {
            this.match = start;
            return wrap;
          } else {
            return null;
          }
        }
      }
      return this.match.findWrapping(node.type);
    }
    finish(openEnd) {
      if (!(this.options & OPT_PRESERVE_WS)) {
        let last = this.content[this.content.length - 1], m;
        if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
          let text = last;
          if (last.text.length == m[0].length)
            this.content.pop();
          else
            this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
        }
      }
      let content = Fragment.from(this.content);
      if (!openEnd && this.match)
        content = content.append(this.match.fillBefore(Fragment.empty, true));
      return this.type ? this.type.create(this.attrs, content, this.marks) : content;
    }
    popFromStashMark(mark) {
      for (let i = this.stashMarks.length - 1; i >= 0; i--)
        if (mark.eq(this.stashMarks[i]))
          return this.stashMarks.splice(i, 1)[0];
    }
    applyPending(nextType) {
      for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {
        let mark = pending[i];
        if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {
          this.activeMarks = mark.addToSet(this.activeMarks);
          this.pendingMarks = mark.removeFromSet(this.pendingMarks);
        }
      }
    }
    inlineContext(node) {
      if (this.type)
        return this.type.inlineContent;
      if (this.content.length)
        return this.content[0].isInline;
      return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
    }
  };
  var ParseContext = class {
    constructor(parser, options, isOpen) {
      this.parser = parser;
      this.options = options;
      this.isOpen = isOpen;
      this.open = 0;
      let topNode = options.topNode, topContext;
      let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
      if (topNode)
        topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
      else if (isOpen)
        topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);
      else
        topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
      this.nodes = [topContext];
      this.find = options.findPositions;
      this.needsBlock = false;
    }
    get top() {
      return this.nodes[this.open];
    }
    // Add a DOM node to the content. Text is inserted as text node,
    // otherwise, the node is passed to `addElement` or, if it has a
    // `style` attribute, `addElementWithStyles`.
    addDOM(dom) {
      if (dom.nodeType == 3)
        this.addTextNode(dom);
      else if (dom.nodeType == 1)
        this.addElement(dom);
    }
    withStyleRules(dom, f) {
      let style = dom.getAttribute("style");
      if (!style)
        return f();
      let marks = this.readStyles(parseStyles(style));
      if (!marks)
        return;
      let [addMarks, removeMarks] = marks, top = this.top;
      for (let i = 0; i < removeMarks.length; i++)
        this.removePendingMark(removeMarks[i], top);
      for (let i = 0; i < addMarks.length; i++)
        this.addPendingMark(addMarks[i]);
      f();
      for (let i = 0; i < addMarks.length; i++)
        this.removePendingMark(addMarks[i], top);
      for (let i = 0; i < removeMarks.length; i++)
        this.addPendingMark(removeMarks[i]);
    }
    addTextNode(dom) {
      let value = dom.nodeValue;
      let top = this.top;
      if (top.options & OPT_PRESERVE_WS_FULL || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
        if (!(top.options & OPT_PRESERVE_WS)) {
          value = value.replace(/[ \t\r\n\u000c]+/g, " ");
          if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
            let nodeBefore = top.content[top.content.length - 1];
            let domNodeBefore = dom.previousSibling;
            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
              value = value.slice(1);
          }
        } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
          value = value.replace(/\r?\n|\r/g, " ");
        } else {
          value = value.replace(/\r\n?/g, "\n");
        }
        if (value)
          this.insertNode(this.parser.schema.text(value));
        this.findInText(dom);
      } else {
        this.findInside(dom);
      }
    }
    // Try to find a handler for the given tag and use that to parse. If
    // none is found, the element's content nodes are added directly.
    addElement(dom, matchAfter) {
      let name = dom.nodeName.toLowerCase(), ruleID;
      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
        normalizeList(dom);
      let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
      if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
        this.findInside(dom);
        this.ignoreFallback(dom);
      } else if (!rule || rule.skip || rule.closeParent) {
        if (rule && rule.closeParent)
          this.open = Math.max(0, this.open - 1);
        else if (rule && rule.skip.nodeType)
          dom = rule.skip;
        let sync, top = this.top, oldNeedsBlock = this.needsBlock;
        if (blockTags.hasOwnProperty(name)) {
          if (top.content.length && top.content[0].isInline && this.open) {
            this.open--;
            top = this.top;
          }
          sync = true;
          if (!top.type)
            this.needsBlock = true;
        } else if (!dom.firstChild) {
          this.leafFallback(dom);
          return;
        }
        if (rule && rule.skip)
          this.addAll(dom);
        else
          this.withStyleRules(dom, () => this.addAll(dom));
        if (sync)
          this.sync(top);
        this.needsBlock = oldNeedsBlock;
      } else {
        this.withStyleRules(dom, () => {
          this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : void 0);
        });
      }
    }
    // Called for leaf DOM nodes that would otherwise be ignored
    leafFallback(dom) {
      if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
        this.addTextNode(dom.ownerDocument.createTextNode("\n"));
    }
    // Called for ignored nodes
    ignoreFallback(dom) {
      if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
        this.findPlace(this.parser.schema.text("-"));
    }
    // Run any style parser associated with the node's styles. Either
    // return an array of marks, or null to indicate some of the styles
    // had a rule with `ignore` set.
    readStyles(styles) {
      let add = Mark.none, remove = Mark.none;
      for (let i = 0; i < styles.length; i += 2) {
        for (let after = void 0; ; ) {
          let rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);
          if (!rule)
            break;
          if (rule.ignore)
            return null;
          if (rule.clearMark) {
            this.top.pendingMarks.concat(this.top.activeMarks).forEach((m) => {
              if (rule.clearMark(m))
                remove = m.addToSet(remove);
            });
          } else {
            add = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(add);
          }
          if (rule.consuming === false)
            after = rule;
          else
            break;
        }
      }
      return [add, remove];
    }
    // Look up a handler for the given node. If none are found, return
    // false. Otherwise, apply it, use its return value to drive the way
    // the node's content is wrapped, and return true.
    addElementByRule(dom, rule, continueAfter) {
      let sync, nodeType, mark;
      if (rule.node) {
        nodeType = this.parser.schema.nodes[rule.node];
        if (!nodeType.isLeaf) {
          sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);
        } else if (!this.insertNode(nodeType.create(rule.attrs))) {
          this.leafFallback(dom);
        }
      } else {
        let markType = this.parser.schema.marks[rule.mark];
        mark = markType.create(rule.attrs);
        this.addPendingMark(mark);
      }
      let startIn = this.top;
      if (nodeType && nodeType.isLeaf) {
        this.findInside(dom);
      } else if (continueAfter) {
        this.addElement(dom, continueAfter);
      } else if (rule.getContent) {
        this.findInside(dom);
        rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node));
      } else {
        let contentDOM = dom;
        if (typeof rule.contentElement == "string")
          contentDOM = dom.querySelector(rule.contentElement);
        else if (typeof rule.contentElement == "function")
          contentDOM = rule.contentElement(dom);
        else if (rule.contentElement)
          contentDOM = rule.contentElement;
        this.findAround(dom, contentDOM, true);
        this.addAll(contentDOM);
      }
      if (sync && this.sync(startIn))
        this.open--;
      if (mark)
        this.removePendingMark(mark, startIn);
    }
    // Add all child nodes between `startIndex` and `endIndex` (or the
    // whole node, if not given). If `sync` is passed, use it to
    // synchronize after every block element.
    addAll(parent, startIndex, endIndex) {
      let index = startIndex || 0;
      for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {
        this.findAtPoint(parent, index);
        this.addDOM(dom);
      }
      this.findAtPoint(parent, index);
    }
    // Try to find a way to fit the given node type into the current
    // context. May add intermediate wrappers and/or leave non-solid
    // nodes that we're in.
    findPlace(node) {
      let route, sync;
      for (let depth = this.open; depth >= 0; depth--) {
        let cx = this.nodes[depth];
        let found2 = cx.findWrapping(node);
        if (found2 && (!route || route.length > found2.length)) {
          route = found2;
          sync = cx;
          if (!found2.length)
            break;
        }
        if (cx.solid)
          break;
      }
      if (!route)
        return false;
      this.sync(sync);
      for (let i = 0; i < route.length; i++)
        this.enterInner(route[i], null, false);
      return true;
    }
    // Try to insert the given node, adjusting the context when needed.
    insertNode(node) {
      if (node.isInline && this.needsBlock && !this.top.type) {
        let block = this.textblockFromContext();
        if (block)
          this.enterInner(block);
      }
      if (this.findPlace(node)) {
        this.closeExtra();
        let top = this.top;
        top.applyPending(node.type);
        if (top.match)
          top.match = top.match.matchType(node.type);
        let marks = top.activeMarks;
        for (let i = 0; i < node.marks.length; i++)
          if (!top.type || top.type.allowsMarkType(node.marks[i].type))
            marks = node.marks[i].addToSet(marks);
        top.content.push(node.mark(marks));
        return true;
      }
      return false;
    }
    // Try to start a node of the given type, adjusting the context when
    // necessary.
    enter(type, attrs, preserveWS) {
      let ok = this.findPlace(type.create(attrs));
      if (ok)
        this.enterInner(type, attrs, true, preserveWS);
      return ok;
    }
    // Open a node of the given type
    enterInner(type, attrs = null, solid = false, preserveWS) {
      this.closeExtra();
      let top = this.top;
      top.applyPending(type);
      top.match = top.match && top.match.matchType(type);
      let options = wsOptionsFor(type, preserveWS, top.options);
      if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
        options |= OPT_OPEN_LEFT;
      this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));
      this.open++;
    }
    // Make sure all nodes above this.open are finished and added to
    // their parents
    closeExtra(openEnd = false) {
      let i = this.nodes.length - 1;
      if (i > this.open) {
        for (; i > this.open; i--)
          this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
        this.nodes.length = this.open + 1;
      }
    }
    finish() {
      this.open = 0;
      this.closeExtra(this.isOpen);
      return this.nodes[0].finish(this.isOpen || this.options.topOpen);
    }
    sync(to) {
      for (let i = this.open; i >= 0; i--)
        if (this.nodes[i] == to) {
          this.open = i;
          return true;
        }
      return false;
    }
    get currentPos() {
      this.closeExtra();
      let pos = 0;
      for (let i = this.open; i >= 0; i--) {
        let content = this.nodes[i].content;
        for (let j = content.length - 1; j >= 0; j--)
          pos += content[j].nodeSize;
        if (i)
          pos++;
      }
      return pos;
    }
    findAtPoint(parent, offset) {
      if (this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (this.find[i].node == parent && this.find[i].offset == offset)
            this.find[i].pos = this.currentPos;
        }
    }
    findInside(parent) {
      if (this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
            this.find[i].pos = this.currentPos;
        }
    }
    findAround(parent, content, before) {
      if (parent != content && this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
            let pos = content.compareDocumentPosition(this.find[i].node);
            if (pos & (before ? 2 : 4))
              this.find[i].pos = this.currentPos;
          }
        }
    }
    findInText(textNode) {
      if (this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (this.find[i].node == textNode)
            this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
        }
    }
    // Determines whether the given context string matches this context.
    matchesContext(context) {
      if (context.indexOf("|") > -1)
        return context.split(/\s*\|\s*/).some(this.matchesContext, this);
      let parts = context.split("/");
      let option = this.options.context;
      let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
      let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
      let match = (i, depth) => {
        for (; i >= 0; i--) {
          let part = parts[i];
          if (part == "") {
            if (i == parts.length - 1 || i == 0)
              continue;
            for (; depth >= minDepth; depth--)
              if (match(i - 1, depth))
                return true;
            return false;
          } else {
            let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
            if (!next || next.name != part && next.groups.indexOf(part) == -1)
              return false;
            depth--;
          }
        }
        return true;
      };
      return match(parts.length - 1, this.open);
    }
    textblockFromContext() {
      let $context = this.options.context;
      if ($context)
        for (let d = $context.depth; d >= 0; d--) {
          let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
          if (deflt && deflt.isTextblock && deflt.defaultAttrs)
            return deflt;
        }
      for (let name in this.parser.schema.nodes) {
        let type = this.parser.schema.nodes[name];
        if (type.isTextblock && type.defaultAttrs)
          return type;
      }
    }
    addPendingMark(mark) {
      let found2 = findSameMarkInSet(mark, this.top.pendingMarks);
      if (found2)
        this.top.stashMarks.push(found2);
      this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
    }
    removePendingMark(mark, upto) {
      for (let depth = this.open; depth >= 0; depth--) {
        let level = this.nodes[depth];
        let found2 = level.pendingMarks.lastIndexOf(mark);
        if (found2 > -1) {
          level.pendingMarks = mark.removeFromSet(level.pendingMarks);
        } else {
          level.activeMarks = mark.removeFromSet(level.activeMarks);
          let stashMark = level.popFromStashMark(mark);
          if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
            level.activeMarks = stashMark.addToSet(level.activeMarks);
        }
        if (level == upto)
          break;
      }
    }
  };
  function normalizeList(dom) {
    for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
      let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
      if (name && listTags.hasOwnProperty(name) && prevItem) {
        prevItem.appendChild(child);
        child = prevItem;
      } else if (name == "li") {
        prevItem = child;
      } else if (name) {
        prevItem = null;
      }
    }
  }
  function matches(dom, selector) {
    return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
  }
  function parseStyles(style) {
    let re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
    while (m = re.exec(style))
      result.push(m[1], m[2].trim());
    return result;
  }
  function copy(obj) {
    let copy2 = {};
    for (let prop in obj)
      copy2[prop] = obj[prop];
    return copy2;
  }
  function markMayApply(markType, nodeType) {
    let nodes = nodeType.schema.nodes;
    for (let name in nodes) {
      let parent = nodes[name];
      if (!parent.allowsMarkType(markType))
        continue;
      let seen = [], scan = (match) => {
        seen.push(match);
        for (let i = 0; i < match.edgeCount; i++) {
          let { type, next } = match.edge(i);
          if (type == nodeType)
            return true;
          if (seen.indexOf(next) < 0 && scan(next))
            return true;
        }
      };
      if (scan(parent.contentMatch))
        return true;
    }
  }
  function findSameMarkInSet(mark, set) {
    for (let i = 0; i < set.length; i++) {
      if (mark.eq(set[i]))
        return set[i];
    }
  }

  // node_modules/prosemirror-transform/dist/index.js
  var lower16 = 65535;
  var factor16 = Math.pow(2, 16);
  function makeRecover(index, offset) {
    return index + offset * factor16;
  }
  function recoverIndex(value) {
    return value & lower16;
  }
  function recoverOffset(value) {
    return (value - (value & lower16)) / factor16;
  }
  var DEL_BEFORE = 1;
  var DEL_AFTER = 2;
  var DEL_ACROSS = 4;
  var DEL_SIDE = 8;
  var MapResult = class {
    /**
    @internal
    */
    constructor(pos, delInfo, recover) {
      this.pos = pos;
      this.delInfo = delInfo;
      this.recover = recover;
    }
    /**
    Tells you whether the position was deleted, that is, whether the
    step removed the token on the side queried (via the `assoc`)
    argument from the document.
    */
    get deleted() {
      return (this.delInfo & DEL_SIDE) > 0;
    }
    /**
    Tells you whether the token before the mapped position was deleted.
    */
    get deletedBefore() {
      return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
    }
    /**
    True when the token after the mapped position was deleted.
    */
    get deletedAfter() {
      return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
    }
    /**
    Tells whether any of the steps mapped through deletes across the
    position (including both the token before and after the
    position).
    */
    get deletedAcross() {
      return (this.delInfo & DEL_ACROSS) > 0;
    }
  };
  var StepMap = class _StepMap {
    /**
    Create a position map. The modifications to the document are
    represented as an array of numbers, in which each group of three
    represents a modified chunk as `[start, oldSize, newSize]`.
    */
    constructor(ranges, inverted = false) {
      this.ranges = ranges;
      this.inverted = inverted;
      if (!ranges.length && _StepMap.empty)
        return _StepMap.empty;
    }
    /**
    @internal
    */
    recover(value) {
      let diff = 0, index = recoverIndex(value);
      if (!this.inverted)
        for (let i = 0; i < index; i++)
          diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
      return this.ranges[index * 3] + diff + recoverOffset(value);
    }
    mapResult(pos, assoc = 1) {
      return this._map(pos, assoc, false);
    }
    map(pos, assoc = 1) {
      return this._map(pos, assoc, true);
    }
    /**
    @internal
    */
    _map(pos, assoc, simple) {
      let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (let i = 0; i < this.ranges.length; i += 3) {
        let start = this.ranges[i] - (this.inverted ? diff : 0);
        if (start > pos)
          break;
        let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
        if (pos <= end) {
          let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
          let result = start + diff + (side < 0 ? 0 : newSize);
          if (simple)
            return result;
          let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
          let del2 = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
          if (assoc < 0 ? pos != start : pos != end)
            del2 |= DEL_SIDE;
          return new MapResult(result, del2, recover);
        }
        diff += newSize - oldSize;
      }
      return simple ? pos + diff : new MapResult(pos + diff, 0, null);
    }
    /**
    @internal
    */
    touches(pos, recover) {
      let diff = 0, index = recoverIndex(recover);
      let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (let i = 0; i < this.ranges.length; i += 3) {
        let start = this.ranges[i] - (this.inverted ? diff : 0);
        if (start > pos)
          break;
        let oldSize = this.ranges[i + oldIndex], end = start + oldSize;
        if (pos <= end && i == index * 3)
          return true;
        diff += this.ranges[i + newIndex] - oldSize;
      }
      return false;
    }
    /**
    Calls the given function on each of the changed ranges included in
    this map.
    */
    forEach(f) {
      let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
        let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
        let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
        diff += newSize - oldSize;
      }
    }
    /**
    Create an inverted version of this map. The result can be used to
    map positions in the post-step document to the pre-step document.
    */
    invert() {
      return new _StepMap(this.ranges, !this.inverted);
    }
    /**
    @internal
    */
    toString() {
      return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
    }
    /**
    Create a map that moves all positions by offset `n` (which may be
    negative). This can be useful when applying steps meant for a
    sub-document to a larger document, or vice-versa.
    */
    static offset(n) {
      return n == 0 ? _StepMap.empty : new _StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
    }
  };
  StepMap.empty = new StepMap([]);
  var stepsByID = /* @__PURE__ */ Object.create(null);
  var Step = class {
    /**
    Get the step map that represents the changes made by this step,
    and which can be used to transform between positions in the old
    and the new document.
    */
    getMap() {
      return StepMap.empty;
    }
    /**
    Try to merge this step with another one, to be applied directly
    after it. Returns the merged step when possible, null if the
    steps can't be merged.
    */
    merge(other) {
      return null;
    }
    /**
    Deserialize a step from its JSON representation. Will call
    through to the step class' own implementation of this method.
    */
    static fromJSON(schema, json) {
      if (!json || !json.stepType)
        throw new RangeError("Invalid input for Step.fromJSON");
      let type = stepsByID[json.stepType];
      if (!type)
        throw new RangeError(`No step type ${json.stepType} defined`);
      return type.fromJSON(schema, json);
    }
    /**
    To be able to serialize steps to JSON, each step needs a string
    ID to attach to its JSON representation. Use this method to
    register an ID for your step classes. Try to pick something
    that's unlikely to clash with steps from other modules.
    */
    static jsonID(id, stepClass) {
      if (id in stepsByID)
        throw new RangeError("Duplicate use of step JSON ID " + id);
      stepsByID[id] = stepClass;
      stepClass.prototype.jsonID = id;
      return stepClass;
    }
  };
  var StepResult = class _StepResult {
    /**
    @internal
    */
    constructor(doc, failed) {
      this.doc = doc;
      this.failed = failed;
    }
    /**
    Create a successful step result.
    */
    static ok(doc) {
      return new _StepResult(doc, null);
    }
    /**
    Create a failed step result.
    */
    static fail(message) {
      return new _StepResult(null, message);
    }
    /**
    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
    arguments. Create a successful result if it succeeds, and a
    failed one if it throws a `ReplaceError`.
    */
    static fromReplace(doc, from, to, slice) {
      try {
        return _StepResult.ok(doc.replace(from, to, slice));
      } catch (e) {
        if (e instanceof ReplaceError)
          return _StepResult.fail(e.message);
        throw e;
      }
    }
  };
  function mapFragment(fragment, f, parent) {
    let mapped = [];
    for (let i = 0; i < fragment.childCount; i++) {
      let child = fragment.child(i);
      if (child.content.size)
        child = child.copy(mapFragment(child.content, f, child));
      if (child.isInline)
        child = f(child, parent, i);
      mapped.push(child);
    }
    return Fragment.fromArray(mapped);
  }
  var AddMarkStep = class _AddMarkStep extends Step {
    /**
    Create a mark step.
    */
    constructor(from, to, mark) {
      super();
      this.from = from;
      this.to = to;
      this.mark = mark;
    }
    apply(doc) {
      let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);
      let parent = $from.node($from.sharedDepth(this.to));
      let slice = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
        if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
          return node;
        return node.mark(this.mark.addToSet(node.marks));
      }, parent), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc, this.from, this.to, slice);
    }
    invert() {
      return new RemoveMarkStep(this.from, this.to, this.mark);
    }
    map(mapping) {
      let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from.deleted && to.deleted || from.pos >= to.pos)
        return null;
      return new _AddMarkStep(from.pos, to.pos, this.mark);
    }
    merge(other) {
      if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
        return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
    toJSON() {
      return {
        stepType: "addMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for AddMarkStep.fromJSON");
      return new _AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
  };
  Step.jsonID("addMark", AddMarkStep);
  var RemoveMarkStep = class _RemoveMarkStep extends Step {
    /**
    Create a mark-removing step.
    */
    constructor(from, to, mark) {
      super();
      this.from = from;
      this.to = to;
      this.mark = mark;
    }
    apply(doc) {
      let oldSlice = doc.slice(this.from, this.to);
      let slice = new Slice(mapFragment(oldSlice.content, (node) => {
        return node.mark(this.mark.removeFromSet(node.marks));
      }, doc), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc, this.from, this.to, slice);
    }
    invert() {
      return new AddMarkStep(this.from, this.to, this.mark);
    }
    map(mapping) {
      let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from.deleted && to.deleted || from.pos >= to.pos)
        return null;
      return new _RemoveMarkStep(from.pos, to.pos, this.mark);
    }
    merge(other) {
      if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
        return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
    toJSON() {
      return {
        stepType: "removeMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
      return new _RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
  };
  Step.jsonID("removeMark", RemoveMarkStep);
  var AddNodeMarkStep = class _AddNodeMarkStep extends Step {
    /**
    Create a node mark step.
    */
    constructor(pos, mark) {
      super();
      this.pos = pos;
      this.mark = mark;
    }
    apply(doc) {
      let node = doc.nodeAt(this.pos);
      if (!node)
        return StepResult.fail("No node at mark step's position");
      let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
      return StepResult.fromReplace(doc, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
    }
    invert(doc) {
      let node = doc.nodeAt(this.pos);
      if (node) {
        let newSet = this.mark.addToSet(node.marks);
        if (newSet.length == node.marks.length) {
          for (let i = 0; i < node.marks.length; i++)
            if (!node.marks[i].isInSet(newSet))
              return new _AddNodeMarkStep(this.pos, node.marks[i]);
          return new _AddNodeMarkStep(this.pos, this.mark);
        }
      }
      return new RemoveNodeMarkStep(this.pos, this.mark);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);
    }
    toJSON() {
      return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.pos != "number")
        throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
      return new _AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
    }
  };
  Step.jsonID("addNodeMark", AddNodeMarkStep);
  var RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {
    /**
    Create a mark-removing step.
    */
    constructor(pos, mark) {
      super();
      this.pos = pos;
      this.mark = mark;
    }
    apply(doc) {
      let node = doc.nodeAt(this.pos);
      if (!node)
        return StepResult.fail("No node at mark step's position");
      let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
      return StepResult.fromReplace(doc, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
    }
    invert(doc) {
      let node = doc.nodeAt(this.pos);
      if (!node || !this.mark.isInSet(node.marks))
        return this;
      return new AddNodeMarkStep(this.pos, this.mark);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);
    }
    toJSON() {
      return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.pos != "number")
        throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
      return new _RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
    }
  };
  Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
  var ReplaceStep = class _ReplaceStep extends Step {
    /**
    The given `slice` should fit the 'gap' between `from` and
    `to`—the depths must line up, and the surrounding nodes must be
    able to be joined with the open sides of the slice. When
    `structure` is true, the step will fail if the content between
    from and to is not just a sequence of closing and then opening
    tokens (this is to guard against rebased replace steps
    overwriting something they weren't supposed to).
    */
    constructor(from, to, slice, structure = false) {
      super();
      this.from = from;
      this.to = to;
      this.slice = slice;
      this.structure = structure;
    }
    apply(doc) {
      if (this.structure && contentBetween(doc, this.from, this.to))
        return StepResult.fail("Structure replace would overwrite content");
      return StepResult.fromReplace(doc, this.from, this.to, this.slice);
    }
    getMap() {
      return new StepMap([this.from, this.to - this.from, this.slice.size]);
    }
    invert(doc) {
      return new _ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));
    }
    map(mapping) {
      let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from.deletedAcross && to.deletedAcross)
        return null;
      return new _ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);
    }
    merge(other) {
      if (!(other instanceof _ReplaceStep) || other.structure || this.structure)
        return null;
      if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
        let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
        return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);
      } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
        let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
        return new _ReplaceStep(other.from, this.to, slice, this.structure);
      } else {
        return null;
      }
    }
    toJSON() {
      let json = { stepType: "replace", from: this.from, to: this.to };
      if (this.slice.size)
        json.slice = this.slice.toJSON();
      if (this.structure)
        json.structure = true;
      return json;
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for ReplaceStep.fromJSON");
      return new _ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
    }
  };
  Step.jsonID("replace", ReplaceStep);
  var ReplaceAroundStep = class _ReplaceAroundStep extends Step {
    /**
    Create a replace-around step with the given range and gap.
    `insert` should be the point in the slice into which the content
    of the gap should be moved. `structure` has the same meaning as
    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
    */
    constructor(from, to, gapFrom, gapTo, slice, insert, structure = false) {
      super();
      this.from = from;
      this.to = to;
      this.gapFrom = gapFrom;
      this.gapTo = gapTo;
      this.slice = slice;
      this.insert = insert;
      this.structure = structure;
    }
    apply(doc) {
      if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to)))
        return StepResult.fail("Structure gap-replace would overwrite content");
      let gap = doc.slice(this.gapFrom, this.gapTo);
      if (gap.openStart || gap.openEnd)
        return StepResult.fail("Gap is not a flat range");
      let inserted = this.slice.insertAt(this.insert, gap.content);
      if (!inserted)
        return StepResult.fail("Content does not fit in gap");
      return StepResult.fromReplace(doc, this.from, this.to, inserted);
    }
    getMap() {
      return new StepMap([
        this.from,
        this.gapFrom - this.from,
        this.insert,
        this.gapTo,
        this.to - this.gapTo,
        this.slice.size - this.insert
      ]);
    }
    invert(doc) {
      let gap = this.gapTo - this.gapFrom;
      return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
    }
    map(mapping) {
      let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
      if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos)
        return null;
      return new _ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
    }
    toJSON() {
      let json = {
        stepType: "replaceAround",
        from: this.from,
        to: this.to,
        gapFrom: this.gapFrom,
        gapTo: this.gapTo,
        insert: this.insert
      };
      if (this.slice.size)
        json.slice = this.slice.toJSON();
      if (this.structure)
        json.structure = true;
      return json;
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
        throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
      return new _ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
    }
  };
  Step.jsonID("replaceAround", ReplaceAroundStep);
  function contentBetween(doc, from, to) {
    let $from = doc.resolve(from), dist = to - from, depth = $from.depth;
    while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
      depth--;
      dist--;
    }
    if (dist > 0) {
      let next = $from.node(depth).maybeChild($from.indexAfter(depth));
      while (dist > 0) {
        if (!next || next.isLeaf)
          return true;
        next = next.firstChild;
        dist--;
      }
    }
    return false;
  }
  function canCut(node, start, end) {
    return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
  }
  function liftTarget(range) {
    let parent = range.parent;
    let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
    for (let depth = range.depth; ; --depth) {
      let node = range.$from.node(depth);
      let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
      if (depth < range.depth && node.canReplace(index, endIndex, content))
        return depth;
      if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))
        break;
    }
    return null;
  }
  function findWrapping(range, nodeType, attrs = null, innerRange = range) {
    let around = findWrappingOutside(range, nodeType);
    let inner = around && findWrappingInside(innerRange, nodeType);
    if (!inner)
      return null;
    return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
  }
  function withAttrs(type) {
    return { type, attrs: null };
  }
  function findWrappingOutside(range, type) {
    let { parent, startIndex, endIndex } = range;
    let around = parent.contentMatchAt(startIndex).findWrapping(type);
    if (!around)
      return null;
    let outer = around.length ? around[0] : type;
    return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
  }
  function findWrappingInside(range, type) {
    let { parent, startIndex, endIndex } = range;
    let inner = parent.child(startIndex);
    let inside = type.contentMatch.findWrapping(inner.type);
    if (!inside)
      return null;
    let lastType = inside.length ? inside[inside.length - 1] : type;
    let innerMatch = lastType.contentMatch;
    for (let i = startIndex; innerMatch && i < endIndex; i++)
      innerMatch = innerMatch.matchType(parent.child(i).type);
    if (!innerMatch || !innerMatch.validEnd)
      return null;
    return inside;
  }
  function canSplit(doc, pos, depth = 1, typesAfter) {
    let $pos = doc.resolve(pos), base = $pos.depth - depth;
    let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
    if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
      return false;
    for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {
      let node = $pos.node(d), index2 = $pos.index(d);
      if (node.type.spec.isolating)
        return false;
      let rest = node.content.cutByIndex(index2, node.childCount);
      let overrideChild = typesAfter && typesAfter[i + 1];
      if (overrideChild)
        rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
      let after = typesAfter && typesAfter[i] || node;
      if (!node.canReplace(index2 + 1, node.childCount) || !after.type.validContent(rest))
        return false;
    }
    let index = $pos.indexAfter(base);
    let baseType = typesAfter && typesAfter[0];
    return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);
  }
  function canJoin(doc, pos) {
    let $pos = doc.resolve(pos), index = $pos.index();
    return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
  }
  function joinable2(a, b) {
    return !!(a && b && !a.isLeaf && a.canAppend(b));
  }
  function joinPoint(doc, pos, dir = -1) {
    let $pos = doc.resolve(pos);
    for (let d = $pos.depth; ; d--) {
      let before, after, index = $pos.index(d);
      if (d == $pos.depth) {
        before = $pos.nodeBefore;
        after = $pos.nodeAfter;
      } else if (dir > 0) {
        before = $pos.node(d + 1);
        index++;
        after = $pos.node(d).maybeChild(index);
      } else {
        before = $pos.node(d).maybeChild(index - 1);
        after = $pos.node(d + 1);
      }
      if (before && !before.isTextblock && joinable2(before, after) && $pos.node(d).canReplace(index, index + 1))
        return pos;
      if (d == 0)
        break;
      pos = dir < 0 ? $pos.before(d) : $pos.after(d);
    }
  }
  function replaceStep(doc, from, to = from, slice = Slice.empty) {
    if (from == to && !slice.size)
      return null;
    let $from = doc.resolve(from), $to = doc.resolve(to);
    if (fitsTrivially($from, $to, slice))
      return new ReplaceStep(from, to, slice);
    return new Fitter($from, $to, slice).fit();
  }
  function fitsTrivially($from, $to, slice) {
    return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);
  }
  var Fitter = class {
    constructor($from, $to, unplaced) {
      this.$from = $from;
      this.$to = $to;
      this.unplaced = unplaced;
      this.frontier = [];
      this.placed = Fragment.empty;
      for (let i = 0; i <= $from.depth; i++) {
        let node = $from.node(i);
        this.frontier.push({
          type: node.type,
          match: node.contentMatchAt($from.indexAfter(i))
        });
      }
      for (let i = $from.depth; i > 0; i--)
        this.placed = Fragment.from($from.node(i).copy(this.placed));
    }
    get depth() {
      return this.frontier.length - 1;
    }
    fit() {
      while (this.unplaced.size) {
        let fit = this.findFittable();
        if (fit)
          this.placeNodes(fit);
        else
          this.openMore() || this.dropNode();
      }
      let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
      let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
      if (!$to)
        return null;
      let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
      while (openStart && openEnd && content.childCount == 1) {
        content = content.firstChild.content;
        openStart--;
        openEnd--;
      }
      let slice = new Slice(content, openStart, openEnd);
      if (moveInline > -1)
        return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);
      if (slice.size || $from.pos != this.$to.pos)
        return new ReplaceStep($from.pos, $to.pos, slice);
      return null;
    }
    // Find a position on the start spine of `this.unplaced` that has
    // content that can be moved somewhere on the frontier. Returns two
    // depths, one for the slice and one for the frontier.
    findFittable() {
      let startDepth = this.unplaced.openStart;
      for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
        let node = cur.firstChild;
        if (cur.childCount > 1)
          openEnd = 0;
        if (node.type.spec.isolating && openEnd <= d) {
          startDepth = d;
          break;
        }
        cur = node.content;
      }
      for (let pass = 1; pass <= 2; pass++) {
        for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
          let fragment, parent = null;
          if (sliceDepth) {
            parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
            fragment = parent.content;
          } else {
            fragment = this.unplaced.content;
          }
          let first2 = fragment.firstChild;
          for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
            let { type, match } = this.frontier[frontierDepth], wrap, inject = null;
            if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type)))
              return { sliceDepth, frontierDepth, parent, inject };
            else if (pass == 2 && first2 && (wrap = match.findWrapping(first2.type)))
              return { sliceDepth, frontierDepth, parent, wrap };
            if (parent && match.matchType(parent.type))
              break;
          }
        }
      }
    }
    openMore() {
      let { content, openStart, openEnd } = this.unplaced;
      let inner = contentAt(content, openStart);
      if (!inner.childCount || inner.firstChild.isLeaf)
        return false;
      this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
      return true;
    }
    dropNode() {
      let { content, openStart, openEnd } = this.unplaced;
      let inner = contentAt(content, openStart);
      if (inner.childCount <= 1 && openStart > 0) {
        let openAtEnd = content.size - openStart <= openStart + inner.size;
        this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
      } else {
        this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
      }
    }
    // Move content from the unplaced slice at `sliceDepth` to the
    // frontier node at `frontierDepth`. Close that frontier node when
    // applicable.
    placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap }) {
      while (this.depth > frontierDepth)
        this.closeFrontierNode();
      if (wrap)
        for (let i = 0; i < wrap.length; i++)
          this.openFrontierNode(wrap[i]);
      let slice = this.unplaced, fragment = parent ? parent.content : slice.content;
      let openStart = slice.openStart - sliceDepth;
      let taken = 0, add = [];
      let { match, type } = this.frontier[frontierDepth];
      if (inject) {
        for (let i = 0; i < inject.childCount; i++)
          add.push(inject.child(i));
        match = match.matchFragment(inject);
      }
      let openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);
      while (taken < fragment.childCount) {
        let next = fragment.child(taken), matches2 = match.matchType(next.type);
        if (!matches2)
          break;
        taken++;
        if (taken > 1 || openStart == 0 || next.content.size) {
          match = matches2;
          add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
        }
      }
      let toEnd = taken == fragment.childCount;
      if (!toEnd)
        openEndCount = -1;
      this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
      this.frontier[frontierDepth].match = match;
      if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
        this.closeFrontierNode();
      for (let i = 0, cur = fragment; i < openEndCount; i++) {
        let node = cur.lastChild;
        this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
        cur = node.content;
      }
      this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
    }
    mustMoveInline() {
      if (!this.$to.parent.isTextblock)
        return -1;
      let top = this.frontier[this.depth], level;
      if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
        return -1;
      let { depth } = this.$to, after = this.$to.after(depth);
      while (depth > 1 && after == this.$to.end(--depth))
        ++after;
      return after;
    }
    findCloseLevel($to) {
      scan:
        for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
          let { match, type } = this.frontier[i];
          let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
          let fit = contentAfterFits($to, i, type, match, dropInner);
          if (!fit)
            continue;
          for (let d = i - 1; d >= 0; d--) {
            let { match: match2, type: type2 } = this.frontier[d];
            let matches2 = contentAfterFits($to, d, type2, match2, true);
            if (!matches2 || matches2.childCount)
              continue scan;
          }
          return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
        }
    }
    close($to) {
      let close2 = this.findCloseLevel($to);
      if (!close2)
        return null;
      while (this.depth > close2.depth)
        this.closeFrontierNode();
      if (close2.fit.childCount)
        this.placed = addToFragment(this.placed, close2.depth, close2.fit);
      $to = close2.move;
      for (let d = close2.depth + 1; d <= $to.depth; d++) {
        let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
        this.openFrontierNode(node.type, node.attrs, add);
      }
      return $to;
    }
    openFrontierNode(type, attrs = null, content) {
      let top = this.frontier[this.depth];
      top.match = top.match.matchType(type);
      this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
      this.frontier.push({ type, match: type.contentMatch });
    }
    closeFrontierNode() {
      let open = this.frontier.pop();
      let add = open.match.fillBefore(Fragment.empty, true);
      if (add.childCount)
        this.placed = addToFragment(this.placed, this.frontier.length, add);
    }
  };
  function dropFromFragment(fragment, depth, count) {
    if (depth == 0)
      return fragment.cutByIndex(count, fragment.childCount);
    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
  }
  function addToFragment(fragment, depth, content) {
    if (depth == 0)
      return fragment.append(content);
    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
  }
  function contentAt(fragment, depth) {
    for (let i = 0; i < depth; i++)
      fragment = fragment.firstChild.content;
    return fragment;
  }
  function closeNodeStart(node, openStart, openEnd) {
    if (openStart <= 0)
      return node;
    let frag = node.content;
    if (openStart > 1)
      frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
    if (openStart > 0) {
      frag = node.type.contentMatch.fillBefore(frag).append(frag);
      if (openEnd <= 0)
        frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
    }
    return node.copy(frag);
  }
  function contentAfterFits($to, depth, type, match, open) {
    let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
    if (index == node.childCount && !type.compatibleContent(node.type))
      return null;
    let fit = match.fillBefore(node.content, true, index);
    return fit && !invalidMarks(type, node.content, index) ? fit : null;
  }
  function invalidMarks(type, fragment, start) {
    for (let i = start; i < fragment.childCount; i++)
      if (!type.allowsMarks(fragment.child(i).marks))
        return true;
    return false;
  }
  var AttrStep = class _AttrStep extends Step {
    /**
    Construct an attribute step.
    */
    constructor(pos, attr, value) {
      super();
      this.pos = pos;
      this.attr = attr;
      this.value = value;
    }
    apply(doc) {
      let node = doc.nodeAt(this.pos);
      if (!node)
        return StepResult.fail("No node at attribute step's position");
      let attrs = /* @__PURE__ */ Object.create(null);
      for (let name in node.attrs)
        attrs[name] = node.attrs[name];
      attrs[this.attr] = this.value;
      let updated = node.type.create(attrs, null, node.marks);
      return StepResult.fromReplace(doc, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
    }
    getMap() {
      return StepMap.empty;
    }
    invert(doc) {
      return new _AttrStep(this.pos, this.attr, doc.nodeAt(this.pos).attrs[this.attr]);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);
    }
    toJSON() {
      return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
    }
    static fromJSON(schema, json) {
      if (typeof json.pos != "number" || typeof json.attr != "string")
        throw new RangeError("Invalid input for AttrStep.fromJSON");
      return new _AttrStep(json.pos, json.attr, json.value);
    }
  };
  Step.jsonID("attr", AttrStep);
  var DocAttrStep = class _DocAttrStep extends Step {
    /**
    Construct an attribute step.
    */
    constructor(attr, value) {
      super();
      this.attr = attr;
      this.value = value;
    }
    apply(doc) {
      let attrs = /* @__PURE__ */ Object.create(null);
      for (let name in doc.attrs)
        attrs[name] = doc.attrs[name];
      attrs[this.attr] = this.value;
      let updated = doc.type.create(attrs, doc.content, doc.marks);
      return StepResult.ok(updated);
    }
    getMap() {
      return StepMap.empty;
    }
    invert(doc) {
      return new _DocAttrStep(this.attr, doc.attrs[this.attr]);
    }
    map(mapping) {
      return this;
    }
    toJSON() {
      return { stepType: "docAttr", attr: this.attr, value: this.value };
    }
    static fromJSON(schema, json) {
      if (typeof json.attr != "string")
        throw new RangeError("Invalid input for DocAttrStep.fromJSON");
      return new _DocAttrStep(json.attr, json.value);
    }
  };
  Step.jsonID("docAttr", DocAttrStep);
  var TransformError = class extends Error {
  };
  TransformError = function TransformError2(message) {
    let err = Error.call(this, message);
    err.__proto__ = TransformError2.prototype;
    return err;
  };
  TransformError.prototype = Object.create(Error.prototype);
  TransformError.prototype.constructor = TransformError;
  TransformError.prototype.name = "TransformError";

  // node_modules/prosemirror-state/dist/index.js
  var classesById = /* @__PURE__ */ Object.create(null);
  var Selection = class {
    /**
    Initialize a selection with the head and anchor and ranges. If no
    ranges are given, constructs a single range across `$anchor` and
    `$head`.
    */
    constructor($anchor, $head, ranges) {
      this.$anchor = $anchor;
      this.$head = $head;
      this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
    }
    /**
    The selection's anchor, as an unresolved position.
    */
    get anchor() {
      return this.$anchor.pos;
    }
    /**
    The selection's head.
    */
    get head() {
      return this.$head.pos;
    }
    /**
    The lower bound of the selection's main range.
    */
    get from() {
      return this.$from.pos;
    }
    /**
    The upper bound of the selection's main range.
    */
    get to() {
      return this.$to.pos;
    }
    /**
    The resolved lower  bound of the selection's main range.
    */
    get $from() {
      return this.ranges[0].$from;
    }
    /**
    The resolved upper bound of the selection's main range.
    */
    get $to() {
      return this.ranges[0].$to;
    }
    /**
    Indicates whether the selection contains any content.
    */
    get empty() {
      let ranges = this.ranges;
      for (let i = 0; i < ranges.length; i++)
        if (ranges[i].$from.pos != ranges[i].$to.pos)
          return false;
      return true;
    }
    /**
    Get the content of this selection as a slice.
    */
    content() {
      return this.$from.doc.slice(this.from, this.to, true);
    }
    /**
    Replace the selection with a slice or, if no slice is given,
    delete the selection. Will append to the given transaction.
    */
    replace(tr, content = Slice.empty) {
      let lastNode = content.content.lastChild, lastParent = null;
      for (let i = 0; i < content.openEnd; i++) {
        lastParent = lastNode;
        lastNode = lastNode.lastChild;
      }
      let mapFrom = tr.steps.length, ranges = this.ranges;
      for (let i = 0; i < ranges.length; i++) {
        let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
        tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
        if (i == 0)
          selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
      }
    }
    /**
    Replace the selection with the given node, appending the changes
    to the given transaction.
    */
    replaceWith(tr, node) {
      let mapFrom = tr.steps.length, ranges = this.ranges;
      for (let i = 0; i < ranges.length; i++) {
        let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
        let from = mapping.map($from.pos), to = mapping.map($to.pos);
        if (i) {
          tr.deleteRange(from, to);
        } else {
          tr.replaceRangeWith(from, to, node);
          selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
        }
      }
    }
    /**
    Find a valid cursor or leaf node selection starting at the given
    position and searching back if `dir` is negative, and forward if
    positive. When `textOnly` is true, only consider cursor
    selections. Will return null when no valid selection position is
    found.
    */
    static findFrom($pos, dir, textOnly = false) {
      let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
      if (inner)
        return inner;
      for (let depth = $pos.depth - 1; depth >= 0; depth--) {
        let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
        if (found2)
          return found2;
      }
      return null;
    }
    /**
    Find a valid cursor or leaf node selection near the given
    position. Searches forward first by default, but if `bias` is
    negative, it will search backwards first.
    */
    static near($pos, bias = 1) {
      return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
    }
    /**
    Find the cursor or leaf node selection closest to the start of
    the given document. Will return an
    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
    exists.
    */
    static atStart(doc) {
      return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);
    }
    /**
    Find the cursor or leaf node selection closest to the end of the
    given document.
    */
    static atEnd(doc) {
      return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);
    }
    /**
    Deserialize the JSON representation of a selection. Must be
    implemented for custom classes (as a static class method).
    */
    static fromJSON(doc, json) {
      if (!json || !json.type)
        throw new RangeError("Invalid input for Selection.fromJSON");
      let cls = classesById[json.type];
      if (!cls)
        throw new RangeError(`No selection type ${json.type} defined`);
      return cls.fromJSON(doc, json);
    }
    /**
    To be able to deserialize selections from JSON, custom selection
    classes must register themselves with an ID string, so that they
    can be disambiguated. Try to pick something that's unlikely to
    clash with classes from other modules.
    */
    static jsonID(id, selectionClass) {
      if (id in classesById)
        throw new RangeError("Duplicate use of selection JSON ID " + id);
      classesById[id] = selectionClass;
      selectionClass.prototype.jsonID = id;
      return selectionClass;
    }
    /**
    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
    which is a value that can be mapped without having access to a
    current document, and later resolved to a real selection for a
    given document again. (This is used mostly by the history to
    track and restore old selections.) The default implementation of
    this method just converts the selection to a text selection and
    returns the bookmark for that.
    */
    getBookmark() {
      return TextSelection.between(this.$anchor, this.$head).getBookmark();
    }
  };
  Selection.prototype.visible = true;
  var SelectionRange = class {
    /**
    Create a range.
    */
    constructor($from, $to) {
      this.$from = $from;
      this.$to = $to;
    }
  };
  var warnedAboutTextSelection = false;
  function checkTextSelection($pos) {
    if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
      warnedAboutTextSelection = true;
      console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
    }
  }
  var TextSelection = class _TextSelection extends Selection {
    /**
    Construct a text selection between the given points.
    */
    constructor($anchor, $head = $anchor) {
      checkTextSelection($anchor);
      checkTextSelection($head);
      super($anchor, $head);
    }
    /**
    Returns a resolved position if this is a cursor selection (an
    empty text selection), and null otherwise.
    */
    get $cursor() {
      return this.$anchor.pos == this.$head.pos ? this.$head : null;
    }
    map(doc, mapping) {
      let $head = doc.resolve(mapping.map(this.head));
      if (!$head.parent.inlineContent)
        return Selection.near($head);
      let $anchor = doc.resolve(mapping.map(this.anchor));
      return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
    }
    replace(tr, content = Slice.empty) {
      super.replace(tr, content);
      if (content == Slice.empty) {
        let marks = this.$from.marksAcross(this.$to);
        if (marks)
          tr.ensureMarks(marks);
      }
    }
    eq(other) {
      return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;
    }
    getBookmark() {
      return new TextBookmark(this.anchor, this.head);
    }
    toJSON() {
      return { type: "text", anchor: this.anchor, head: this.head };
    }
    /**
    @internal
    */
    static fromJSON(doc, json) {
      if (typeof json.anchor != "number" || typeof json.head != "number")
        throw new RangeError("Invalid input for TextSelection.fromJSON");
      return new _TextSelection(doc.resolve(json.anchor), doc.resolve(json.head));
    }
    /**
    Create a text selection from non-resolved positions.
    */
    static create(doc, anchor, head = anchor) {
      let $anchor = doc.resolve(anchor);
      return new this($anchor, head == anchor ? $anchor : doc.resolve(head));
    }
    /**
    Return a text selection that spans the given positions or, if
    they aren't text positions, find a text selection near them.
    `bias` determines whether the method searches forward (default)
    or backwards (negative number) first. Will fall back to calling
    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
    doesn't contain a valid text position.
    */
    static between($anchor, $head, bias) {
      let dPos = $anchor.pos - $head.pos;
      if (!bias || dPos)
        bias = dPos >= 0 ? 1 : -1;
      if (!$head.parent.inlineContent) {
        let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
        if (found2)
          $head = found2.$head;
        else
          return Selection.near($head, bias);
      }
      if (!$anchor.parent.inlineContent) {
        if (dPos == 0) {
          $anchor = $head;
        } else {
          $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
          if ($anchor.pos < $head.pos != dPos < 0)
            $anchor = $head;
        }
      }
      return new _TextSelection($anchor, $head);
    }
  };
  Selection.jsonID("text", TextSelection);
  var TextBookmark = class _TextBookmark {
    constructor(anchor, head) {
      this.anchor = anchor;
      this.head = head;
    }
    map(mapping) {
      return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
    }
    resolve(doc) {
      return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));
    }
  };
  var NodeSelection = class _NodeSelection extends Selection {
    /**
    Create a node selection. Does not verify the validity of its
    argument.
    */
    constructor($pos) {
      let node = $pos.nodeAfter;
      let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
      super($pos, $end);
      this.node = node;
    }
    map(doc, mapping) {
      let { deleted, pos } = mapping.mapResult(this.anchor);
      let $pos = doc.resolve(pos);
      if (deleted)
        return Selection.near($pos);
      return new _NodeSelection($pos);
    }
    content() {
      return new Slice(Fragment.from(this.node), 0, 0);
    }
    eq(other) {
      return other instanceof _NodeSelection && other.anchor == this.anchor;
    }
    toJSON() {
      return { type: "node", anchor: this.anchor };
    }
    getBookmark() {
      return new NodeBookmark(this.anchor);
    }
    /**
    @internal
    */
    static fromJSON(doc, json) {
      if (typeof json.anchor != "number")
        throw new RangeError("Invalid input for NodeSelection.fromJSON");
      return new _NodeSelection(doc.resolve(json.anchor));
    }
    /**
    Create a node selection from non-resolved positions.
    */
    static create(doc, from) {
      return new _NodeSelection(doc.resolve(from));
    }
    /**
    Determines whether the given node may be selected as a node
    selection.
    */
    static isSelectable(node) {
      return !node.isText && node.type.spec.selectable !== false;
    }
  };
  NodeSelection.prototype.visible = false;
  Selection.jsonID("node", NodeSelection);
  var NodeBookmark = class _NodeBookmark {
    constructor(anchor) {
      this.anchor = anchor;
    }
    map(mapping) {
      let { deleted, pos } = mapping.mapResult(this.anchor);
      return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);
    }
    resolve(doc) {
      let $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;
      if (node && NodeSelection.isSelectable(node))
        return new NodeSelection($pos);
      return Selection.near($pos);
    }
  };
  var AllSelection = class _AllSelection extends Selection {
    /**
    Create an all-selection over the given document.
    */
    constructor(doc) {
      super(doc.resolve(0), doc.resolve(doc.content.size));
    }
    replace(tr, content = Slice.empty) {
      if (content == Slice.empty) {
        tr.delete(0, tr.doc.content.size);
        let sel = Selection.atStart(tr.doc);
        if (!sel.eq(tr.selection))
          tr.setSelection(sel);
      } else {
        super.replace(tr, content);
      }
    }
    toJSON() {
      return { type: "all" };
    }
    /**
    @internal
    */
    static fromJSON(doc) {
      return new _AllSelection(doc);
    }
    map(doc) {
      return new _AllSelection(doc);
    }
    eq(other) {
      return other instanceof _AllSelection;
    }
    getBookmark() {
      return AllBookmark;
    }
  };
  Selection.jsonID("all", AllSelection);
  var AllBookmark = {
    map() {
      return this;
    },
    resolve(doc) {
      return new AllSelection(doc);
    }
  };
  function findSelectionIn(doc, node, pos, index, dir, text = false) {
    if (node.inlineContent)
      return TextSelection.create(doc, pos);
    for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
      let child = node.child(i);
      if (!child.isAtom) {
        let inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
        if (inner)
          return inner;
      } else if (!text && NodeSelection.isSelectable(child)) {
        return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));
      }
      pos += child.nodeSize * dir;
    }
    return null;
  }
  function selectionToInsertionEnd(tr, startLen, bias) {
    let last = tr.steps.length - 1;
    if (last < startLen)
      return;
    let step = tr.steps[last];
    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
      return;
    let map = tr.mapping.maps[last], end;
    map.forEach((_from, _to, _newFrom, newTo) => {
      if (end == null)
        end = newTo;
    });
    tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
  }
  function bind(f, self) {
    return !self || !f ? f : f.bind(self);
  }
  var FieldDesc = class {
    constructor(name, desc, self) {
      this.name = name;
      this.init = bind(desc.init, self);
      this.apply = bind(desc.apply, self);
    }
  };
  var baseFields = [
    new FieldDesc("doc", {
      init(config) {
        return config.doc || config.schema.topNodeType.createAndFill();
      },
      apply(tr) {
        return tr.doc;
      }
    }),
    new FieldDesc("selection", {
      init(config, instance) {
        return config.selection || Selection.atStart(instance.doc);
      },
      apply(tr) {
        return tr.selection;
      }
    }),
    new FieldDesc("storedMarks", {
      init(config) {
        return config.storedMarks || null;
      },
      apply(tr, _marks, _old, state) {
        return state.selection.$cursor ? tr.storedMarks : null;
      }
    }),
    new FieldDesc("scrollToSelection", {
      init() {
        return 0;
      },
      apply(tr, prev) {
        return tr.scrolledIntoView ? prev + 1 : prev;
      }
    })
  ];
  function bindProps(obj, self, target) {
    for (let prop in obj) {
      let val = obj[prop];
      if (val instanceof Function)
        val = val.bind(self);
      else if (prop == "handleDOMEvents")
        val = bindProps(val, self, {});
      target[prop] = val;
    }
    return target;
  }
  var Plugin = class {
    /**
    Create a plugin.
    */
    constructor(spec) {
      this.spec = spec;
      this.props = {};
      if (spec.props)
        bindProps(spec.props, this, this.props);
      this.key = spec.key ? spec.key.key : createKey("plugin");
    }
    /**
    Extract the plugin's state field from an editor state.
    */
    getState(state) {
      return state[this.key];
    }
  };
  var keys = /* @__PURE__ */ Object.create(null);
  function createKey(name) {
    if (name in keys)
      return name + "$" + ++keys[name];
    keys[name] = 0;
    return name + "$";
  }
  var PluginKey = class {
    /**
    Create a plugin key.
    */
    constructor(name = "key") {
      this.key = createKey(name);
    }
    /**
    Get the active plugin with this key, if any, from an editor
    state.
    */
    get(state) {
      return state.config.pluginsByKey[this.key];
    }
    /**
    Get the plugin's state from an editor state.
    */
    getState(state) {
      return state[this.key];
    }
  };

  // node_modules/prosemirror-commands/dist/index.js
  var deleteSelection = (state, dispatch) => {
    if (state.selection.empty)
      return false;
    if (dispatch)
      dispatch(state.tr.deleteSelection().scrollIntoView());
    return true;
  };
  function atBlockStart(state, view) {
    let { $cursor } = state.selection;
    if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
      return null;
    return $cursor;
  }
  var joinBackward = (state, dispatch, view) => {
    let $cursor = atBlockStart(state, view);
    if (!$cursor)
      return false;
    let $cut = findCutBefore($cursor);
    if (!$cut) {
      let range = $cursor.blockRange(), target = range && liftTarget(range);
      if (target == null)
        return false;
      if (dispatch)
        dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    }
    let before = $cut.nodeBefore;
    if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))
      return true;
    if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
      let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          let tr = state.tr.step(delStep);
          tr.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
    }
    if (before.isAtom && $cut.depth == $cursor.depth - 1) {
      if (dispatch)
        dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
      return true;
    }
    return false;
  };
  function textblockAt(node, side, only = false) {
    for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
      if (scan.isTextblock)
        return true;
      if (only && scan.childCount != 1)
        return false;
    }
    return false;
  }
  var selectNodeBackward = (state, dispatch, view) => {
    let { $head, empty } = state.selection, $cut = $head;
    if (!empty)
      return false;
    if ($head.parent.isTextblock) {
      if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
        return false;
      $cut = findCutBefore($head);
    }
    let node = $cut && $cut.nodeBefore;
    if (!node || !NodeSelection.isSelectable(node))
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
    return true;
  };
  function findCutBefore($pos) {
    if (!$pos.parent.type.spec.isolating)
      for (let i = $pos.depth - 1; i >= 0; i--) {
        if ($pos.index(i) > 0)
          return $pos.doc.resolve($pos.before(i + 1));
        if ($pos.node(i).type.spec.isolating)
          break;
      }
    return null;
  }
  function atBlockEnd(state, view) {
    let { $cursor } = state.selection;
    if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
      return null;
    return $cursor;
  }
  var joinForward = (state, dispatch, view) => {
    let $cursor = atBlockEnd(state, view);
    if (!$cursor)
      return false;
    let $cut = findCutAfter($cursor);
    if (!$cut)
      return false;
    let after = $cut.nodeAfter;
    if (deleteBarrier(state, $cut, dispatch))
      return true;
    if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
      let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          let tr = state.tr.step(delStep);
          tr.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
    }
    if (after.isAtom && $cut.depth == $cursor.depth - 1) {
      if (dispatch)
        dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
      return true;
    }
    return false;
  };
  var selectNodeForward = (state, dispatch, view) => {
    let { $head, empty } = state.selection, $cut = $head;
    if (!empty)
      return false;
    if ($head.parent.isTextblock) {
      if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
        return false;
      $cut = findCutAfter($head);
    }
    let node = $cut && $cut.nodeAfter;
    if (!node || !NodeSelection.isSelectable(node))
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
    return true;
  };
  function findCutAfter($pos) {
    if (!$pos.parent.type.spec.isolating)
      for (let i = $pos.depth - 1; i >= 0; i--) {
        let parent = $pos.node(i);
        if ($pos.index(i) + 1 < parent.childCount)
          return $pos.doc.resolve($pos.after(i + 1));
        if (parent.type.spec.isolating)
          break;
      }
    return null;
  }
  var joinUp = (state, dispatch) => {
    let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
    if (nodeSel) {
      if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
        return false;
      point = sel.from;
    } else {
      point = joinPoint(state.doc, sel.from, -1);
      if (point == null)
        return false;
    }
    if (dispatch) {
      let tr = state.tr.join(point);
      if (nodeSel)
        tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
  var joinDown = (state, dispatch) => {
    let sel = state.selection, point;
    if (sel instanceof NodeSelection) {
      if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
        return false;
      point = sel.to;
    } else {
      point = joinPoint(state.doc, sel.to, 1);
      if (point == null)
        return false;
    }
    if (dispatch)
      dispatch(state.tr.join(point).scrollIntoView());
    return true;
  };
  var lift = (state, dispatch) => {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  };
  var newlineInCode = (state, dispatch) => {
    let { $head, $anchor } = state.selection;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
      return false;
    if (dispatch)
      dispatch(state.tr.insertText("\n").scrollIntoView());
    return true;
  };
  function defaultBlockAt(match) {
    for (let i = 0; i < match.edgeCount; i++) {
      let { type } = match.edge(i);
      if (type.isTextblock && !type.hasRequiredAttrs())
        return type;
    }
    return null;
  }
  var exitCode = (state, dispatch) => {
    let { $head, $anchor } = state.selection;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
      return false;
    let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
    if (!type || !above.canReplaceWith(after, after, type))
      return false;
    if (dispatch) {
      let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
      tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
  var createParagraphNear = (state, dispatch) => {
    let sel = state.selection, { $from, $to } = sel;
    if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
      return false;
    let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
    if (!type || !type.isTextblock)
      return false;
    if (dispatch) {
      let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
      let tr = state.tr.insert(side, type.createAndFill());
      tr.setSelection(TextSelection.create(tr.doc, side + 1));
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
  var liftEmptyBlock = (state, dispatch) => {
    let { $cursor } = state.selection;
    if (!$cursor || $cursor.parent.content.size)
      return false;
    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
      let before = $cursor.before();
      if (canSplit(state.doc, before)) {
        if (dispatch)
          dispatch(state.tr.split(before).scrollIntoView());
        return true;
      }
    }
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  };
  function splitBlockAs(splitNode) {
    return (state, dispatch) => {
      let { $from, $to } = state.selection;
      if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
        if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
          return false;
        if (dispatch)
          dispatch(state.tr.split($from.pos).scrollIntoView());
        return true;
      }
      if (!$from.parent.isBlock)
        return false;
      if (dispatch) {
        let atEnd = $to.parentOffset == $to.parent.content.size;
        let tr = state.tr;
        if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
          tr.deleteSelection();
        let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
        let splitType = splitNode && splitNode($to.parent, atEnd);
        let types = splitType ? [splitType] : atEnd && deflt ? [{ type: deflt }] : void 0;
        let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
        if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
          if (deflt)
            types = [{ type: deflt }];
          can = true;
        }
        if (can) {
          tr.split(tr.mapping.map($from.pos), 1, types);
          if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {
            let first2 = tr.mapping.map($from.before()), $first = tr.doc.resolve(first2);
            if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))
              tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
          }
        }
        dispatch(tr.scrollIntoView());
      }
      return true;
    };
  }
  var splitBlock = splitBlockAs();
  var selectParentNode = (state, dispatch) => {
    let { $from, to } = state.selection, pos;
    let same = $from.sharedDepth(to);
    if (same == 0)
      return false;
    pos = $from.before(same);
    if (dispatch)
      dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
    return true;
  };
  var selectAll = (state, dispatch) => {
    if (dispatch)
      dispatch(state.tr.setSelection(new AllSelection(state.doc)));
    return true;
  };
  function joinMaybeClear(state, $pos, dispatch) {
    let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
    if (!before || !after || !before.type.compatibleContent(after.type))
      return false;
    if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
      if (dispatch)
        dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
      return true;
    }
    if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
      return false;
    if (dispatch)
      dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());
    return true;
  }
  function deleteBarrier(state, $cut, dispatch) {
    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
    if (before.type.spec.isolating || after.type.spec.isolating)
      return false;
    if (joinMaybeClear(state, $cut, dispatch))
      return true;
    let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
    if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
      if (dispatch) {
        let end = $cut.pos + after.nodeSize, wrap = Fragment.empty;
        for (let i = conn.length - 1; i >= 0; i--)
          wrap = Fragment.from(conn[i].create(null, wrap));
        wrap = Fragment.from(before.copy(wrap));
        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true));
        let joinAt = end + 2 * conn.length;
        if (canJoin(tr.doc, joinAt))
          tr.join(joinAt);
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
    let selAfter = Selection.findFrom($cut, 1);
    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
    if (target != null && target >= $cut.depth) {
      if (dispatch)
        dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    }
    if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
      let at = before, wrap = [];
      for (; ; ) {
        wrap.push(at);
        if (at.isTextblock)
          break;
        at = at.lastChild;
      }
      let afterText = after, afterDepth = 1;
      for (; !afterText.isTextblock; afterText = afterText.firstChild)
        afterDepth++;
      if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
        if (dispatch) {
          let end = Fragment.empty;
          for (let i = wrap.length - 1; i >= 0; i--)
            end = Fragment.from(wrap[i].copy(end));
          let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap.length, 0), 0, true));
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
    }
    return false;
  }
  function selectTextblockSide(side) {
    return function(state, dispatch) {
      let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
      let depth = $pos.depth;
      while ($pos.node(depth).isInline) {
        if (!depth)
          return false;
        depth--;
      }
      if (!$pos.node(depth).isTextblock)
        return false;
      if (dispatch)
        dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
      return true;
    };
  }
  var selectTextblockStart = selectTextblockSide(-1);
  var selectTextblockEnd = selectTextblockSide(1);
  function wrapIn(nodeType, attrs = null) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
      if (!wrapping)
        return false;
      if (dispatch)
        dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
      return true;
    };
  }
  function setBlockType(nodeType, attrs = null) {
    return function(state, dispatch) {
      let applicable = false;
      for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {
        let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];
        state.doc.nodesBetween(from, to, (node, pos) => {
          if (applicable)
            return false;
          if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
            return;
          if (node.type == nodeType) {
            applicable = true;
          } else {
            let $pos = state.doc.resolve(pos), index = $pos.index();
            applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
          }
        });
      }
      if (!applicable)
        return false;
      if (dispatch) {
        let tr = state.tr;
        for (let i = 0; i < state.selection.ranges.length; i++) {
          let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];
          tr.setBlockType(from, to, nodeType, attrs);
        }
        dispatch(tr.scrollIntoView());
      }
      return true;
    };
  }
  function chainCommands(...commands2) {
    return function(state, dispatch, view) {
      for (let i = 0; i < commands2.length; i++)
        if (commands2[i](state, dispatch, view))
          return true;
      return false;
    };
  }
  var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
  var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
  var pcBaseKeymap = {
    "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
    "Mod-Enter": exitCode,
    "Backspace": backspace,
    "Mod-Backspace": backspace,
    "Shift-Backspace": backspace,
    "Delete": del,
    "Mod-Delete": del,
    "Mod-a": selectAll
  };
  var macBaseKeymap = {
    "Ctrl-h": pcBaseKeymap["Backspace"],
    "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
    "Ctrl-d": pcBaseKeymap["Delete"],
    "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
    "Alt-Delete": pcBaseKeymap["Mod-Delete"],
    "Alt-d": pcBaseKeymap["Mod-Delete"],
    "Ctrl-a": selectTextblockStart,
    "Ctrl-e": selectTextblockEnd
  };
  for (let key in pcBaseKeymap)
    macBaseKeymap[key] = pcBaseKeymap[key];
  var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;

  // node_modules/prosemirror-schema-list/dist/index.js
  function wrapInList(listType, attrs = null) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to), doJoin = false, outerRange = range;
      if (!range)
        return false;
      if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
        if ($from.index(range.depth - 1) == 0)
          return false;
        let $insert = state.doc.resolve(range.start - 2);
        outerRange = new NodeRange($insert, $insert, range.depth);
        if (range.endIndex < range.parent.childCount)
          range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);
        doJoin = true;
      }
      let wrap = findWrapping(outerRange, listType, attrs, range);
      if (!wrap)
        return false;
      if (dispatch)
        dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());
      return true;
    };
  }
  function doWrapInList(tr, range, wrappers, joinBefore, listType) {
    let content = Fragment.empty;
    for (let i = wrappers.length - 1; i >= 0; i--)
      content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
    tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
    let found2 = 0;
    for (let i = 0; i < wrappers.length; i++)
      if (wrappers[i].type == listType)
        found2 = i + 1;
    let splitDepth = wrappers.length - found2;
    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
    for (let i = range.startIndex, e = range.endIndex, first2 = true; i < e; i++, first2 = false) {
      if (!first2 && canSplit(tr.doc, splitPos, splitDepth)) {
        tr.split(splitPos, splitDepth);
        splitPos += 2 * splitDepth;
      }
      splitPos += parent.child(i).nodeSize;
    }
    return tr;
  }
  function liftListItem(itemType) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
      if (!range)
        return false;
      if (!dispatch)
        return true;
      if ($from.node(range.depth - 1).type == itemType)
        return liftToOuterList(state, dispatch, itemType, range);
      else
        return liftOutOfList(state, dispatch, range);
    };
  }
  function liftToOuterList(state, dispatch, itemType, range) {
    let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
    if (end < endOfList) {
      tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
      range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
    }
    const target = liftTarget(range);
    if (target == null)
      return false;
    tr.lift(range, target);
    let after = tr.mapping.map(end, -1) - 1;
    if (canJoin(tr.doc, after))
      tr.join(after);
    dispatch(tr.scrollIntoView());
    return true;
  }
  function liftOutOfList(state, dispatch, range) {
    let tr = state.tr, list = range.parent;
    for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
      pos -= list.child(i).nodeSize;
      tr.delete(pos - 1, pos + 1);
    }
    let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
      return false;
    let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
    let parent = $start.node(-1), indexBefore = $start.index(-1);
    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
      return false;
    let start = $start.pos, end = start + item.nodeSize;
    tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
    dispatch(tr.scrollIntoView());
    return true;
  }
  function sinkListItem(itemType) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
      if (!range)
        return false;
      let startIndex = range.startIndex;
      if (startIndex == 0)
        return false;
      let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
      if (nodeBefore.type != itemType)
        return false;
      if (dispatch) {
        let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
        let inner = Fragment.from(nestedBefore ? itemType.create() : null);
        let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
        let before = range.start, after = range.end;
        dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());
      }
      return true;
    };
  }

  // node_modules/@tiptap/core/dist/index.js
  function createChainableState(config) {
    const { state, transaction } = config;
    let { selection } = transaction;
    let { doc } = transaction;
    let { storedMarks } = transaction;
    return {
      ...state,
      apply: state.apply.bind(state),
      applyTransaction: state.applyTransaction.bind(state),
      filterTransaction: state.filterTransaction,
      plugins: state.plugins,
      schema: state.schema,
      reconfigure: state.reconfigure.bind(state),
      toJSON: state.toJSON.bind(state),
      get storedMarks() {
        return storedMarks;
      },
      get selection() {
        return selection;
      },
      get doc() {
        return doc;
      },
      get tr() {
        selection = transaction.selection;
        doc = transaction.doc;
        storedMarks = transaction.storedMarks;
        return transaction;
      }
    };
  }
  var CommandManager = class {
    constructor(props) {
      this.editor = props.editor;
      this.rawCommands = this.editor.extensionManager.commands;
      this.customState = props.state;
    }
    get hasCustomState() {
      return !!this.customState;
    }
    get state() {
      return this.customState || this.editor.state;
    }
    get commands() {
      const { rawCommands, editor, state } = this;
      const { view } = editor;
      const { tr } = state;
      const props = this.buildProps(tr);
      return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        const method = (...args) => {
          const callback = command2(...args)(props);
          if (!tr.getMeta("preventDispatch") && !this.hasCustomState) {
            view.dispatch(tr);
          }
          return callback;
        };
        return [name, method];
      }));
    }
    get chain() {
      return () => this.createChain();
    }
    get can() {
      return () => this.createCan();
    }
    createChain(startTr, shouldDispatch = true) {
      const { rawCommands, editor, state } = this;
      const { view } = editor;
      const callbacks = [];
      const hasStartTransaction = !!startTr;
      const tr = startTr || state.tr;
      const run = () => {
        if (!hasStartTransaction && shouldDispatch && !tr.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr);
        }
        return callbacks.every((callback) => callback === true);
      };
      const chain = {
        ...Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          const chainedCommand = (...args) => {
            const props = this.buildProps(tr, shouldDispatch);
            const callback = command2(...args)(props);
            callbacks.push(callback);
            return chain;
          };
          return [name, chainedCommand];
        })),
        run
      };
      return chain;
    }
    createCan(startTr) {
      const { rawCommands, state } = this;
      const dispatch = false;
      const tr = startTr || state.tr;
      const props = this.buildProps(tr, dispatch);
      const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
      }));
      return {
        ...formattedCommands,
        chain: () => this.createChain(tr, dispatch)
      };
    }
    buildProps(tr, shouldDispatch = true) {
      const { rawCommands, editor, state } = this;
      const { view } = editor;
      const props = {
        tr,
        editor,
        view,
        state: createChainableState({
          state,
          transaction: tr
        }),
        dispatch: shouldDispatch ? () => void 0 : void 0,
        chain: () => this.createChain(tr, shouldDispatch),
        can: () => this.createCan(tr),
        get commands() {
          return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
            return [name, (...args) => command2(...args)(props)];
          }));
        }
      };
      return props;
    }
  };
  function getExtensionField(extension, field, context) {
    if (extension.config[field] === void 0 && extension.parent) {
      return getExtensionField(extension.parent, field, context);
    }
    if (typeof extension.config[field] === "function") {
      const value = extension.config[field].bind({
        ...context,
        parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
      });
      return value;
    }
    return extension.config[field];
  }
  function splitExtensions(extensions) {
    const baseExtensions = extensions.filter((extension) => extension.type === "extension");
    const nodeExtensions = extensions.filter((extension) => extension.type === "node");
    const markExtensions = extensions.filter((extension) => extension.type === "mark");
    return {
      baseExtensions,
      nodeExtensions,
      markExtensions
    };
  }
  function getNodeType(nameOrType, schema) {
    if (typeof nameOrType === "string") {
      if (!schema.nodes[nameOrType]) {
        throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
      }
      return schema.nodes[nameOrType];
    }
    return nameOrType;
  }
  function mergeAttributes(...objects) {
    return objects.filter((item) => !!item).reduce((items, item) => {
      const mergedAttributes = { ...items };
      Object.entries(item).forEach(([key, value]) => {
        const exists = mergedAttributes[key];
        if (!exists) {
          mergedAttributes[key] = value;
          return;
        }
        if (key === "class") {
          const valueClasses = value ? value.split(" ") : [];
          const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
          const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
          mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
        } else if (key === "style") {
          mergedAttributes[key] = [mergedAttributes[key], value].join("; ");
        } else {
          mergedAttributes[key] = value;
        }
      });
      return mergedAttributes;
    }, {});
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function callOrReturn(value, context = void 0, ...props) {
    if (isFunction(value)) {
      if (context) {
        return value.bind(context)(...props);
      }
      return value(...props);
    }
    return value;
  }
  function isRegExp(value) {
    return Object.prototype.toString.call(value) === "[object RegExp]";
  }
  var InputRule = class {
    constructor(config) {
      this.find = config.find;
      this.handler = config.handler;
    }
  };
  function getType(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
  }
  function isPlainObject(value) {
    if (getType(value) !== "Object") {
      return false;
    }
    return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
  }
  function mergeDeep(target, source) {
    const output = { ...target };
    if (isPlainObject(target) && isPlainObject(source)) {
      Object.keys(source).forEach((key) => {
        if (isPlainObject(source[key])) {
          if (!(key in target)) {
            Object.assign(output, { [key]: source[key] });
          } else {
            output[key] = mergeDeep(target[key], source[key]);
          }
        } else {
          Object.assign(output, { [key]: source[key] });
        }
      });
    }
    return output;
  }
  var Extension = class _Extension {
    constructor(config = {}) {
      this.type = "extension";
      this.name = "extension";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = {
        ...this.config,
        ...config
      };
      this.name = this.config.name;
      if (config.defaultOptions) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(config = {}) {
      return new _Extension(config);
    }
    configure(options = {}) {
      const extension = this.extend();
      extension.options = mergeDeep(this.options, options);
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
    extend(extendedConfig = {}) {
      const extension = new _Extension(extendedConfig);
      extension.parent = this;
      this.child = extension;
      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
      if (extendedConfig.defaultOptions) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
      }
      extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
        name: extension.name
      }));
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
  };
  function getTextBetween(startNode, range, options) {
    const { from, to } = range;
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    let text = "";
    let separated = true;
    startNode.nodesBetween(from, to, (node, pos, parent, index) => {
      var _a;
      const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
      if (textSerializer) {
        if (node.isBlock && !separated) {
          text += blockSeparator;
          separated = true;
        }
        if (parent) {
          text += textSerializer({
            node,
            pos,
            parent,
            index,
            range
          });
        }
      } else if (node.isText) {
        text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos);
        separated = false;
      } else if (node.isBlock && !separated) {
        text += blockSeparator;
        separated = true;
      }
    });
    return text;
  }
  function getTextSerializersFromSchema(schema) {
    return Object.fromEntries(Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));
  }
  var ClipboardTextSerializer = Extension.create({
    name: "clipboardTextSerializer",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("clipboardTextSerializer"),
          props: {
            clipboardTextSerializer: () => {
              const { editor } = this;
              const { state, schema } = editor;
              const { doc, selection } = state;
              const { ranges } = selection;
              const from = Math.min(...ranges.map((range2) => range2.$from.pos));
              const to = Math.max(...ranges.map((range2) => range2.$to.pos));
              const textSerializers = getTextSerializersFromSchema(schema);
              const range = { from, to };
              return getTextBetween(doc, range, {
                textSerializers
              });
            }
          }
        })
      ];
    }
  });
  var blur = () => ({ editor, view }) => {
    requestAnimationFrame(() => {
      var _a;
      if (!editor.isDestroyed) {
        view.dom.blur();
        (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
      }
    });
    return true;
  };
  var clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
    return commands2.setContent("", emitUpdate);
  };
  var clearNodes = () => ({ state, tr, dispatch }) => {
    const { selection } = tr;
    const { ranges } = selection;
    if (!dispatch) {
      return true;
    }
    ranges.forEach(({ $from, $to }) => {
      state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
        if (node.type.isText) {
          return;
        }
        const { doc, mapping } = tr;
        const $mappedFrom = doc.resolve(mapping.map(pos));
        const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));
        const nodeRange = $mappedFrom.blockRange($mappedTo);
        if (!nodeRange) {
          return;
        }
        const targetLiftDepth = liftTarget(nodeRange);
        if (node.type.isTextblock) {
          const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
          tr.setNodeMarkup(nodeRange.start, defaultType);
        }
        if (targetLiftDepth || targetLiftDepth === 0) {
          tr.lift(nodeRange, targetLiftDepth);
        }
      });
    });
    return true;
  };
  var command = (fn) => (props) => {
    return fn(props);
  };
  var createParagraphNear2 = () => ({ state, dispatch }) => {
    return createParagraphNear(state, dispatch);
  };
  var cut = (originRange, targetPos) => ({ editor, tr }) => {
    const { state } = editor;
    const contentSlice = state.doc.slice(originRange.from, originRange.to);
    tr.deleteRange(originRange.from, originRange.to);
    const newPos = tr.mapping.map(targetPos);
    tr.insert(newPos, contentSlice.content);
    tr.setSelection(new TextSelection(tr.doc.resolve(newPos - 1)));
    return true;
  };
  var deleteCurrentNode = () => ({ tr, dispatch }) => {
    const { selection } = tr;
    const currentNode = selection.$anchor.node();
    if (currentNode.content.size > 0) {
      return false;
    }
    const $pos = tr.selection.$anchor;
    for (let depth = $pos.depth; depth > 0; depth -= 1) {
      const node = $pos.node(depth);
      if (node.type === currentNode.type) {
        if (dispatch) {
          const from = $pos.before(depth);
          const to = $pos.after(depth);
          tr.delete(from, to).scrollIntoView();
        }
        return true;
      }
    }
    return false;
  };
  var deleteNode = (typeOrName) => ({ tr, state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    const $pos = tr.selection.$anchor;
    for (let depth = $pos.depth; depth > 0; depth -= 1) {
      const node = $pos.node(depth);
      if (node.type === type) {
        if (dispatch) {
          const from = $pos.before(depth);
          const to = $pos.after(depth);
          tr.delete(from, to).scrollIntoView();
        }
        return true;
      }
    }
    return false;
  };
  var deleteRange = (range) => ({ tr, dispatch }) => {
    const { from, to } = range;
    if (dispatch) {
      tr.delete(from, to);
    }
    return true;
  };
  var deleteSelection2 = () => ({ state, dispatch }) => {
    return deleteSelection(state, dispatch);
  };
  var enter = () => ({ commands: commands2 }) => {
    return commands2.keyboardShortcut("Enter");
  };
  var exitCode2 = () => ({ state, dispatch }) => {
    return exitCode(state, dispatch);
  };
  function objectIncludes(object1, object2, options = { strict: true }) {
    const keys2 = Object.keys(object2);
    if (!keys2.length) {
      return true;
    }
    return keys2.every((key) => {
      if (options.strict) {
        return object2[key] === object1[key];
      }
      if (isRegExp(object2[key])) {
        return object2[key].test(object1[key]);
      }
      return object2[key] === object1[key];
    });
  }
  function findMarkInSet(marks, type, attributes = {}) {
    return marks.find((item) => {
      return item.type === type && objectIncludes(item.attrs, attributes);
    });
  }
  function isMarkInSet(marks, type, attributes = {}) {
    return !!findMarkInSet(marks, type, attributes);
  }
  function getMarkRange($pos, type, attributes = {}) {
    if (!$pos || !type) {
      return;
    }
    let start = $pos.parent.childAfter($pos.parentOffset);
    if ($pos.parentOffset === start.offset && start.offset !== 0) {
      start = $pos.parent.childBefore($pos.parentOffset);
    }
    if (!start.node) {
      return;
    }
    const mark = findMarkInSet([...start.node.marks], type, attributes);
    if (!mark) {
      return;
    }
    let startIndex = start.index;
    let startPos = $pos.start() + start.offset;
    let endIndex = startIndex + 1;
    let endPos = startPos + start.node.nodeSize;
    findMarkInSet([...start.node.marks], type, attributes);
    while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
      startIndex -= 1;
      startPos -= $pos.parent.child(startIndex).nodeSize;
    }
    while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
      endPos += $pos.parent.child(endIndex).nodeSize;
      endIndex += 1;
    }
    return {
      from: startPos,
      to: endPos
    };
  }
  function getMarkType(nameOrType, schema) {
    if (typeof nameOrType === "string") {
      if (!schema.marks[nameOrType]) {
        throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
      }
      return schema.marks[nameOrType];
    }
    return nameOrType;
  }
  var extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
    const type = getMarkType(typeOrName, state.schema);
    const { doc, selection } = tr;
    const { $from, from, to } = selection;
    if (dispatch) {
      const range = getMarkRange($from, type, attributes);
      if (range && range.from <= from && range.to >= to) {
        const newSelection = TextSelection.create(doc, range.from, range.to);
        tr.setSelection(newSelection);
      }
    }
    return true;
  };
  var first = (commands2) => (props) => {
    const items = typeof commands2 === "function" ? commands2(props) : commands2;
    for (let i = 0; i < items.length; i += 1) {
      if (items[i](props)) {
        return true;
      }
    }
    return false;
  };
  function isTextSelection(value) {
    return value instanceof TextSelection;
  }
  function minMax(value = 0, min = 0, max = 0) {
    return Math.min(Math.max(value, min), max);
  }
  function resolveFocusPosition(doc, position = null) {
    if (!position) {
      return null;
    }
    const selectionAtStart = Selection.atStart(doc);
    const selectionAtEnd = Selection.atEnd(doc);
    if (position === "start" || position === true) {
      return selectionAtStart;
    }
    if (position === "end") {
      return selectionAtEnd;
    }
    const minPos = selectionAtStart.from;
    const maxPos = selectionAtEnd.to;
    if (position === "all") {
      return TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));
    }
    return TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
  }
  function isiOS() {
    return [
      "iPad Simulator",
      "iPhone Simulator",
      "iPod Simulator",
      "iPad",
      "iPhone",
      "iPod"
    ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
  }
  var focus = (position = null, options = {}) => ({ editor, view, tr, dispatch }) => {
    options = {
      scrollIntoView: true,
      ...options
    };
    const delayedFocus = () => {
      if (isiOS()) {
        view.dom.focus();
      }
      requestAnimationFrame(() => {
        if (!editor.isDestroyed) {
          view.focus();
          if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
            editor.commands.scrollIntoView();
          }
        }
      });
    };
    if (view.hasFocus() && position === null || position === false) {
      return true;
    }
    if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
      delayedFocus();
      return true;
    }
    const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;
    const isSameSelection = editor.state.selection.eq(selection);
    if (dispatch) {
      if (!isSameSelection) {
        tr.setSelection(selection);
      }
      if (isSameSelection && tr.storedMarks) {
        tr.setStoredMarks(tr.storedMarks);
      }
      delayedFocus();
    }
    return true;
  };
  var forEach = (items, fn) => (props) => {
    return items.every((item, index) => fn(item, { ...props, index }));
  };
  var insertContent = (value, options) => ({ tr, commands: commands2 }) => {
    return commands2.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);
  };
  function elementFromString(value) {
    const wrappedValue = `<body>${value}</body>`;
    return new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  }
  function createNodeFromContent(content, schema, options) {
    options = {
      slice: true,
      parseOptions: {},
      ...options
    };
    if (typeof content === "object" && content !== null) {
      try {
        if (Array.isArray(content) && content.length > 0) {
          return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
        }
        return schema.nodeFromJSON(content);
      } catch (error) {
        console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
        return createNodeFromContent("", schema, options);
      }
    }
    if (typeof content === "string") {
      const parser = DOMParser.fromSchema(schema);
      return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);
    }
    return createNodeFromContent("", schema, options);
  }
  function selectionToInsertionEnd2(tr, startLen, bias) {
    const last = tr.steps.length - 1;
    if (last < startLen) {
      return;
    }
    const step = tr.steps[last];
    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
      return;
    }
    const map = tr.mapping.maps[last];
    let end = 0;
    map.forEach((_from, _to, _newFrom, newTo) => {
      if (end === 0) {
        end = newTo;
      }
    });
    tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
  }
  var isFragment = (nodeOrFragment) => {
    return nodeOrFragment.toString().startsWith("<");
  };
  var insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {
    if (dispatch) {
      options = {
        parseOptions: {},
        updateSelection: true,
        ...options
      };
      const content = createNodeFromContent(value, editor.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...options.parseOptions
        }
      });
      if (content.toString() === "<>") {
        return true;
      }
      let { from, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
      let isOnlyTextContent = true;
      let isOnlyBlockContent = true;
      const nodes = isFragment(content) ? content : [content];
      nodes.forEach((node) => {
        node.check();
        isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
        isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
      });
      if (from === to && isOnlyBlockContent) {
        const { parent } = tr.doc.resolve(from);
        const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
        if (isEmptyTextBlock) {
          from -= 1;
          to += 1;
        }
      }
      if (isOnlyTextContent) {
        if (Array.isArray(value)) {
          tr.insertText(value.map((v) => v.text || "").join(""), from, to);
        } else if (typeof value === "object" && !!value && !!value.text) {
          tr.insertText(value.text, from, to);
        } else {
          tr.insertText(value, from, to);
        }
      } else {
        tr.replaceWith(from, to, content);
      }
      if (options.updateSelection) {
        selectionToInsertionEnd2(tr, tr.steps.length - 1, -1);
      }
    }
    return true;
  };
  var joinUp2 = () => ({ state, dispatch }) => {
    return joinUp(state, dispatch);
  };
  var joinDown2 = () => ({ state, dispatch }) => {
    return joinDown(state, dispatch);
  };
  var joinBackward2 = () => ({ state, dispatch }) => {
    return joinBackward(state, dispatch);
  };
  var joinForward2 = () => ({ state, dispatch }) => {
    return joinForward(state, dispatch);
  };
  var joinItemBackward = () => ({ tr, state, dispatch }) => {
    try {
      const point = joinPoint(state.doc, state.selection.$from.pos, -1);
      if (point === null || point === void 0) {
        return false;
      }
      tr.join(point, 2);
      if (dispatch) {
        dispatch(tr);
      }
      return true;
    } catch {
      return false;
    }
  };
  var joinItemForward = () => ({ state, dispatch, tr }) => {
    try {
      const point = joinPoint(state.doc, state.selection.$from.pos, 1);
      if (point === null || point === void 0) {
        return false;
      }
      tr.join(point, 2);
      if (dispatch) {
        dispatch(tr);
      }
      return true;
    } catch (e) {
      return false;
    }
  };
  function isMacOS() {
    return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
  }
  function normalizeKeyName(name) {
    const parts = name.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result === "Space") {
      result = " ";
    }
    let alt;
    let ctrl;
    let shift;
    let meta;
    for (let i = 0; i < parts.length - 1; i += 1) {
      const mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) {
        meta = true;
      } else if (/^a(lt)?$/i.test(mod)) {
        alt = true;
      } else if (/^(c|ctrl|control)$/i.test(mod)) {
        ctrl = true;
      } else if (/^s(hift)?$/i.test(mod)) {
        shift = true;
      } else if (/^mod$/i.test(mod)) {
        if (isiOS() || isMacOS()) {
          meta = true;
        } else {
          ctrl = true;
        }
      } else {
        throw new Error(`Unrecognized modifier name: ${mod}`);
      }
    }
    if (alt) {
      result = `Alt-${result}`;
    }
    if (ctrl) {
      result = `Ctrl-${result}`;
    }
    if (meta) {
      result = `Meta-${result}`;
    }
    if (shift) {
      result = `Shift-${result}`;
    }
    return result;
  }
  var keyboardShortcut = (name) => ({ editor, view, tr, dispatch }) => {
    const keys2 = normalizeKeyName(name).split(/-(?!$)/);
    const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
    const event = new KeyboardEvent("keydown", {
      key: key === "Space" ? " " : key,
      altKey: keys2.includes("Alt"),
      ctrlKey: keys2.includes("Ctrl"),
      metaKey: keys2.includes("Meta"),
      shiftKey: keys2.includes("Shift"),
      bubbles: true,
      cancelable: true
    });
    const capturedTransaction = editor.captureTransaction(() => {
      view.someProp("handleKeyDown", (f) => f(view, event));
    });
    capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
      const newStep = step.map(tr.mapping);
      if (newStep && dispatch) {
        tr.maybeStep(newStep);
      }
    });
    return true;
  };
  function isNodeActive(state, typeOrName, attributes = {}) {
    const { from, to, empty } = state.selection;
    const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
    const nodeRanges = [];
    state.doc.nodesBetween(from, to, (node, pos) => {
      if (node.isText) {
        return;
      }
      const relativeFrom = Math.max(from, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      nodeRanges.push({
        node,
        from: relativeFrom,
        to: relativeTo
      });
    });
    const selectionRange = to - from;
    const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
      if (!type) {
        return true;
      }
      return type.name === nodeRange.node.type.name;
    }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
    if (empty) {
      return !!matchedNodeRanges.length;
    }
    const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
    return range >= selectionRange;
  }
  var lift2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    const isActive = isNodeActive(state, type, attributes);
    if (!isActive) {
      return false;
    }
    return lift(state, dispatch);
  };
  var liftEmptyBlock2 = () => ({ state, dispatch }) => {
    return liftEmptyBlock(state, dispatch);
  };
  var liftListItem2 = (typeOrName) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return liftListItem(type)(state, dispatch);
  };
  var newlineInCode2 = () => ({ state, dispatch }) => {
    return newlineInCode(state, dispatch);
  };
  function getSchemaTypeNameByName(name, schema) {
    if (schema.nodes[name]) {
      return "node";
    }
    if (schema.marks[name]) {
      return "mark";
    }
    return null;
  }
  function deleteProps(obj, propOrProps) {
    const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
    return Object.keys(obj).reduce((newObj, prop) => {
      if (!props.includes(prop)) {
        newObj[prop] = obj[prop];
      }
      return newObj;
    }, {});
  }
  var resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {
    let nodeType = null;
    let markType = null;
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (!schemaType) {
      return false;
    }
    if (schemaType === "node") {
      nodeType = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === "mark") {
      markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch) {
      tr.selection.ranges.forEach((range) => {
        state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
          if (nodeType && nodeType === node.type) {
            tr.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
          }
          if (markType && node.marks.length) {
            node.marks.forEach((mark) => {
              if (markType === mark.type) {
                tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
              }
            });
          }
        });
      });
    }
    return true;
  };
  var scrollIntoView = () => ({ tr, dispatch }) => {
    if (dispatch) {
      tr.scrollIntoView();
    }
    return true;
  };
  var selectAll2 = () => ({ tr, commands: commands2 }) => {
    return commands2.setTextSelection({
      from: 0,
      to: tr.doc.content.size
    });
  };
  var selectNodeBackward2 = () => ({ state, dispatch }) => {
    return selectNodeBackward(state, dispatch);
  };
  var selectNodeForward2 = () => ({ state, dispatch }) => {
    return selectNodeForward(state, dispatch);
  };
  var selectParentNode2 = () => ({ state, dispatch }) => {
    return selectParentNode(state, dispatch);
  };
  var selectTextblockEnd2 = () => ({ state, dispatch }) => {
    return selectTextblockEnd(state, dispatch);
  };
  var selectTextblockStart2 = () => ({ state, dispatch }) => {
    return selectTextblockStart(state, dispatch);
  };
  function createDocument(content, schema, parseOptions = {}) {
    return createNodeFromContent(content, schema, { slice: false, parseOptions });
  }
  var setContent = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch }) => {
    const { doc } = tr;
    const document2 = createDocument(content, editor.schema, parseOptions);
    if (dispatch) {
      tr.replaceWith(0, doc.content.size, document2).setMeta("preventUpdate", !emitUpdate);
    }
    return true;
  };
  function getMarkAttributes(state, typeOrName) {
    const type = getMarkType(typeOrName, state.schema);
    const { from, to, empty } = state.selection;
    const marks = [];
    if (empty) {
      if (state.storedMarks) {
        marks.push(...state.storedMarks);
      }
      marks.push(...state.selection.$head.marks());
    } else {
      state.doc.nodesBetween(from, to, (node) => {
        marks.push(...node.marks);
      });
    }
    const mark = marks.find((markItem) => markItem.type.name === type.name);
    if (!mark) {
      return {};
    }
    return { ...mark.attrs };
  }
  function defaultBlockAt2(match) {
    for (let i = 0; i < match.edgeCount; i += 1) {
      const { type } = match.edge(i);
      if (type.isTextblock && !type.hasRequiredAttrs()) {
        return type;
      }
    }
    return null;
  }
  function findParentNodeClosestToPos($pos, predicate) {
    for (let i = $pos.depth; i > 0; i -= 1) {
      const node = $pos.node(i);
      if (predicate(node)) {
        return {
          pos: i > 0 ? $pos.before(i) : 0,
          start: $pos.start(i),
          depth: i,
          node
        };
      }
    }
  }
  function findParentNode(predicate) {
    return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
  }
  function getSplittedAttributes(extensionAttributes, typeName, attributes) {
    return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
      const extensionAttribute = extensionAttributes.find((item) => {
        return item.type === typeName && item.name === name;
      });
      if (!extensionAttribute) {
        return false;
      }
      return extensionAttribute.attribute.keepOnSplit;
    }));
  }
  function isMarkActive(state, typeOrName, attributes = {}) {
    const { empty, ranges } = state.selection;
    const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
    if (empty) {
      return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
        if (!type) {
          return true;
        }
        return type.name === mark.type.name;
      }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
    }
    let selectionRange = 0;
    const markRanges = [];
    ranges.forEach(({ $from, $to }) => {
      const from = $from.pos;
      const to = $to.pos;
      state.doc.nodesBetween(from, to, (node, pos) => {
        if (!node.isText && !node.marks.length) {
          return;
        }
        const relativeFrom = Math.max(from, pos);
        const relativeTo = Math.min(to, pos + node.nodeSize);
        const range2 = relativeTo - relativeFrom;
        selectionRange += range2;
        markRanges.push(...node.marks.map((mark) => ({
          mark,
          from: relativeFrom,
          to: relativeTo
        })));
      });
    });
    if (selectionRange === 0) {
      return false;
    }
    const matchedRange = markRanges.filter((markRange) => {
      if (!type) {
        return true;
      }
      return type.name === markRange.mark.type.name;
    }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
    const excludedRange = markRanges.filter((markRange) => {
      if (!type) {
        return true;
      }
      return markRange.mark.type !== type && markRange.mark.type.excludes(type);
    }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
    const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
    return range >= selectionRange;
  }
  function isList(name, extensions) {
    const { nodeExtensions } = splitExtensions(extensions);
    const extension = nodeExtensions.find((item) => item.name === name);
    if (!extension) {
      return false;
    }
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const group = callOrReturn(getExtensionField(extension, "group", context));
    if (typeof group !== "string") {
      return false;
    }
    return group.split(" ").includes("list");
  }
  function canSetMark(state, tr, newMarkType) {
    var _a;
    const { selection } = tr;
    let cursor = null;
    if (isTextSelection(selection)) {
      cursor = selection.$cursor;
    }
    if (cursor) {
      const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();
      return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
    }
    const { ranges } = selection;
    return ranges.some(({ $from, $to }) => {
      let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
      state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
        if (someNodeSupportsMark) {
          return false;
        }
        if (node.isInline) {
          const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
          const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
          someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
        }
        return !someNodeSupportsMark;
      });
      return someNodeSupportsMark;
    });
  }
  var setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
    const { selection } = tr;
    const { empty, ranges } = selection;
    const type = getMarkType(typeOrName, state.schema);
    if (dispatch) {
      if (empty) {
        const oldAttributes = getMarkAttributes(state, type);
        tr.addStoredMark(type.create({
          ...oldAttributes,
          ...attributes
        }));
      } else {
        ranges.forEach((range) => {
          const from = range.$from.pos;
          const to = range.$to.pos;
          state.doc.nodesBetween(from, to, (node, pos) => {
            const trimmedFrom = Math.max(pos, from);
            const trimmedTo = Math.min(pos + node.nodeSize, to);
            const someHasMark = node.marks.find((mark) => mark.type === type);
            if (someHasMark) {
              node.marks.forEach((mark) => {
                if (type === mark.type) {
                  tr.addMark(trimmedFrom, trimmedTo, type.create({
                    ...mark.attrs,
                    ...attributes
                  }));
                }
              });
            } else {
              tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
            }
          });
        });
      }
    }
    return canSetMark(state, tr, type);
  };
  var setMeta = (key, value) => ({ tr }) => {
    tr.setMeta(key, value);
    return true;
  };
  var setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
    const type = getNodeType(typeOrName, state.schema);
    if (!type.isTextblock) {
      console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
      return false;
    }
    return chain().command(({ commands: commands2 }) => {
      const canSetBlock = setBlockType(type, attributes)(state);
      if (canSetBlock) {
        return true;
      }
      return commands2.clearNodes();
    }).command(({ state: updatedState }) => {
      return setBlockType(type, attributes)(updatedState, dispatch);
    }).run();
  };
  var setNodeSelection = (position) => ({ tr, dispatch }) => {
    if (dispatch) {
      const { doc } = tr;
      const from = minMax(position, 0, doc.content.size);
      const selection = NodeSelection.create(doc, from);
      tr.setSelection(selection);
    }
    return true;
  };
  var setTextSelection = (position) => ({ tr, dispatch }) => {
    if (dispatch) {
      const { doc } = tr;
      const { from, to } = typeof position === "number" ? { from: position, to: position } : position;
      const minPos = TextSelection.atStart(doc).from;
      const maxPos = TextSelection.atEnd(doc).to;
      const resolvedFrom = minMax(from, minPos, maxPos);
      const resolvedEnd = minMax(to, minPos, maxPos);
      const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd);
      tr.setSelection(selection);
    }
    return true;
  };
  var sinkListItem2 = (typeOrName) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return sinkListItem(type)(state, dispatch);
  };
  function ensureMarks(state, splittableMarks) {
    const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
    if (marks) {
      const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
      state.tr.ensureMarks(filteredMarks);
    }
  }
  var splitBlock2 = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor }) => {
    const { selection, doc } = tr;
    const { $from, $to } = selection;
    const extensionAttributes = editor.extensionManager.attributes;
    const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
    if (selection instanceof NodeSelection && selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(doc, $from.pos)) {
        return false;
      }
      if (dispatch) {
        if (keepMarks) {
          ensureMarks(state, editor.extensionManager.splittableMarks);
        }
        tr.split($from.pos).scrollIntoView();
      }
      return true;
    }
    if (!$from.parent.isBlock) {
      return false;
    }
    if (dispatch) {
      const atEnd = $to.parentOffset === $to.parent.content.size;
      if (selection instanceof TextSelection) {
        tr.deleteSelection();
      }
      const deflt = $from.depth === 0 ? void 0 : defaultBlockAt2($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      let types = atEnd && deflt ? [
        {
          type: deflt,
          attrs: newAttributes
        }
      ] : void 0;
      let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
      if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
        can = true;
        types = deflt ? [
          {
            type: deflt,
            attrs: newAttributes
          }
        ] : void 0;
      }
      if (can) {
        tr.split(tr.mapping.map($from.pos), 1, types);
        if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
          const first2 = tr.mapping.map($from.before());
          const $first = tr.doc.resolve(first2);
          if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
            tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
          }
        }
      }
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr.scrollIntoView();
    }
    return true;
  };
  var splitListItem = (typeOrName) => ({ tr, state, dispatch, editor }) => {
    var _a;
    const type = getNodeType(typeOrName, state.schema);
    const { $from, $to } = state.selection;
    const node = state.selection.node;
    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
      return false;
    }
    const grandParent = $from.node(-1);
    if (grandParent.type !== type) {
      return false;
    }
    const extensionAttributes = editor.extensionManager.attributes;
    if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
      if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
        return false;
      }
      if (dispatch) {
        let wrap = Fragment.empty;
        const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
        for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
          wrap = Fragment.from($from.node(d).copy(wrap));
        }
        const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
        const newNextTypeAttributes2 = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
        const nextType2 = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
        wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
        const start = $from.before($from.depth - (depthBefore - 1));
        tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));
        let sel = -1;
        tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {
          if (sel > -1) {
            return false;
          }
          if (n.isTextblock && n.content.size === 0) {
            sel = pos + 1;
          }
        });
        if (sel > -1) {
          tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));
        }
        tr.scrollIntoView();
      }
      return true;
    }
    const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);
    const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
    tr.delete($from.pos, $to.pos);
    const types = nextType ? [
      { type, attrs: newTypeAttributes },
      { type: nextType, attrs: newNextTypeAttributes }
    ] : [{ type, attrs: newTypeAttributes }];
    if (!canSplit(tr.doc, $from.pos, 2)) {
      return false;
    }
    if (dispatch) {
      const { selection, storedMarks } = state;
      const { splittableMarks } = editor.extensionManager;
      const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
      tr.split($from.pos, 2, types).scrollIntoView();
      if (!marks || !dispatch) {
        return true;
      }
      const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
      tr.ensureMarks(filteredMarks);
    }
    return true;
  };
  var joinListBackwards = (tr, listType) => {
    const list = findParentNode((node) => node.type === listType)(tr.selection);
    if (!list) {
      return true;
    }
    const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
    if (before === void 0) {
      return true;
    }
    const nodeBefore = tr.doc.nodeAt(before);
    const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr.doc, list.pos);
    if (!canJoinBackwards) {
      return true;
    }
    tr.join(list.pos);
    return true;
  };
  var joinListForwards = (tr, listType) => {
    const list = findParentNode((node) => node.type === listType)(tr.selection);
    if (!list) {
      return true;
    }
    const after = tr.doc.resolve(list.start).after(list.depth);
    if (after === void 0) {
      return true;
    }
    const nodeAfter = tr.doc.nodeAt(after);
    const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr.doc, after);
    if (!canJoinForwards) {
      return true;
    }
    tr.join(after);
    return true;
  };
  var toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr, state, dispatch, chain, commands: commands2, can }) => {
    const { extensions, splittableMarks } = editor.extensionManager;
    const listType = getNodeType(listTypeOrName, state.schema);
    const itemType = getNodeType(itemTypeOrName, state.schema);
    const { selection, storedMarks } = state;
    const { $from, $to } = selection;
    const range = $from.blockRange($to);
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    if (!range) {
      return false;
    }
    const parentList = findParentNode((node) => isList(node.type.name, extensions))(selection);
    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
      if (parentList.node.type === listType) {
        return commands2.liftListItem(itemType);
      }
      if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {
        return chain().command(() => {
          tr.setNodeMarkup(parentList.pos, listType);
          return true;
        }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
      }
    }
    if (!keepMarks || !marks || !dispatch) {
      return chain().command(() => {
        const canWrapInList = can().wrapInList(listType, attributes);
        if (canWrapInList) {
          return true;
        }
        return commands2.clearNodes();
      }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
    }
    return chain().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
      tr.ensureMarks(filteredMarks);
      if (canWrapInList) {
        return true;
      }
      return commands2.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
  };
  var toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands: commands2 }) => {
    const { extendEmptyMarkRange = false } = options;
    const type = getMarkType(typeOrName, state.schema);
    const isActive = isMarkActive(state, type, attributes);
    if (isActive) {
      return commands2.unsetMark(type, { extendEmptyMarkRange });
    }
    return commands2.setMark(type, attributes);
  };
  var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
    const type = getNodeType(typeOrName, state.schema);
    const toggleType = getNodeType(toggleTypeOrName, state.schema);
    const isActive = isNodeActive(state, type, attributes);
    if (isActive) {
      return commands2.setNode(toggleType);
    }
    return commands2.setNode(type, attributes);
  };
  var toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
    const type = getNodeType(typeOrName, state.schema);
    const isActive = isNodeActive(state, type, attributes);
    if (isActive) {
      return commands2.lift(type);
    }
    return commands2.wrapIn(type, attributes);
  };
  var undoInputRule = () => ({ state, dispatch }) => {
    const plugins = state.plugins;
    for (let i = 0; i < plugins.length; i += 1) {
      const plugin = plugins[i];
      let undoable;
      if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
        if (dispatch) {
          const tr = state.tr;
          const toUndo = undoable.transform;
          for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
            tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
          }
          if (undoable.text) {
            const marks = tr.doc.resolve(undoable.from).marks();
            tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
          } else {
            tr.delete(undoable.from, undoable.to);
          }
        }
        return true;
      }
    }
    return false;
  };
  var unsetAllMarks = () => ({ tr, dispatch }) => {
    const { selection } = tr;
    const { empty, ranges } = selection;
    if (empty) {
      return true;
    }
    if (dispatch) {
      ranges.forEach((range) => {
        tr.removeMark(range.$from.pos, range.$to.pos);
      });
    }
    return true;
  };
  var unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {
    var _a;
    const { extendEmptyMarkRange = false } = options;
    const { selection } = tr;
    const type = getMarkType(typeOrName, state.schema);
    const { $from, empty, ranges } = selection;
    if (!dispatch) {
      return true;
    }
    if (empty && extendEmptyMarkRange) {
      let { from, to } = selection;
      const attrs = (_a = $from.marks().find((mark) => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;
      const range = getMarkRange($from, type, attrs);
      if (range) {
        from = range.from;
        to = range.to;
      }
      tr.removeMark(from, to, type);
    } else {
      ranges.forEach((range) => {
        tr.removeMark(range.$from.pos, range.$to.pos, type);
      });
    }
    tr.removeStoredMark(type);
    return true;
  };
  var updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
    let nodeType = null;
    let markType = null;
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (!schemaType) {
      return false;
    }
    if (schemaType === "node") {
      nodeType = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === "mark") {
      markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch) {
      tr.selection.ranges.forEach((range) => {
        const from = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from, to, (node, pos) => {
          if (nodeType && nodeType === node.type) {
            tr.setNodeMarkup(pos, void 0, {
              ...node.attrs,
              ...attributes
            });
          }
          if (markType && node.marks.length) {
            node.marks.forEach((mark) => {
              if (markType === mark.type) {
                const trimmedFrom = Math.max(pos, from);
                const trimmedTo = Math.min(pos + node.nodeSize, to);
                tr.addMark(trimmedFrom, trimmedTo, markType.create({
                  ...mark.attrs,
                  ...attributes
                }));
              }
            });
          }
        });
      });
    }
    return true;
  };
  var wrapIn2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return wrapIn(type, attributes)(state, dispatch);
  };
  var wrapInList2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return wrapInList(type, attributes)(state, dispatch);
  };
  var commands = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    blur,
    clearContent,
    clearNodes,
    command,
    createParagraphNear: createParagraphNear2,
    cut,
    deleteCurrentNode,
    deleteNode,
    deleteRange,
    deleteSelection: deleteSelection2,
    enter,
    exitCode: exitCode2,
    extendMarkRange,
    first,
    focus,
    forEach,
    insertContent,
    insertContentAt,
    joinUp: joinUp2,
    joinDown: joinDown2,
    joinBackward: joinBackward2,
    joinForward: joinForward2,
    joinItemBackward,
    joinItemForward,
    keyboardShortcut,
    lift: lift2,
    liftEmptyBlock: liftEmptyBlock2,
    liftListItem: liftListItem2,
    newlineInCode: newlineInCode2,
    resetAttributes,
    scrollIntoView,
    selectAll: selectAll2,
    selectNodeBackward: selectNodeBackward2,
    selectNodeForward: selectNodeForward2,
    selectParentNode: selectParentNode2,
    selectTextblockEnd: selectTextblockEnd2,
    selectTextblockStart: selectTextblockStart2,
    setContent,
    setMark,
    setMeta,
    setNode,
    setNodeSelection,
    setTextSelection,
    sinkListItem: sinkListItem2,
    splitBlock: splitBlock2,
    splitListItem,
    toggleList,
    toggleMark,
    toggleNode,
    toggleWrap,
    undoInputRule,
    unsetAllMarks,
    unsetMark,
    updateAttributes,
    wrapIn: wrapIn2,
    wrapInList: wrapInList2
  });
  var Commands = Extension.create({
    name: "commands",
    addCommands() {
      return {
        ...commands
      };
    }
  });
  var Editable = Extension.create({
    name: "editable",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("editable"),
          props: {
            editable: () => this.editor.options.editable
          }
        })
      ];
    }
  });
  var FocusEvents = Extension.create({
    name: "focusEvents",
    addProseMirrorPlugins() {
      const { editor } = this;
      return [
        new Plugin({
          key: new PluginKey("focusEvents"),
          props: {
            handleDOMEvents: {
              focus: (view, event) => {
                editor.isFocused = true;
                const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
                view.dispatch(transaction);
                return false;
              },
              blur: (view, event) => {
                editor.isFocused = false;
                const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
                view.dispatch(transaction);
                return false;
              }
            }
          }
        })
      ];
    }
  });
  var Keymap = Extension.create({
    name: "keymap",
    addKeyboardShortcuts() {
      const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
        () => commands2.undoInputRule(),
        // maybe convert first text block node to default node
        () => commands2.command(({ tr }) => {
          const { selection, doc } = tr;
          const { empty, $anchor } = selection;
          const { pos, parent } = $anchor;
          const $parentPos = $anchor.parent.isTextblock ? tr.doc.resolve(pos - 1) : $anchor;
          const parentIsIsolating = $parentPos.parent.type.spec.isolating;
          const parentPos = $anchor.pos - $anchor.parentOffset;
          const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc).from === pos;
          if (!empty || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {
            return false;
          }
          return commands2.clearNodes();
        }),
        () => commands2.deleteSelection(),
        () => commands2.joinBackward(),
        () => commands2.selectNodeBackward()
      ]);
      const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
        () => commands2.deleteSelection(),
        () => commands2.deleteCurrentNode(),
        () => commands2.joinForward(),
        () => commands2.selectNodeForward()
      ]);
      const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
        () => commands2.newlineInCode(),
        () => commands2.createParagraphNear(),
        () => commands2.liftEmptyBlock(),
        () => commands2.splitBlock()
      ]);
      const baseKeymap = {
        Enter: handleEnter,
        "Mod-Enter": () => this.editor.commands.exitCode(),
        Backspace: handleBackspace,
        "Mod-Backspace": handleBackspace,
        "Shift-Backspace": handleBackspace,
        Delete: handleDelete,
        "Mod-Delete": handleDelete,
        "Mod-a": () => this.editor.commands.selectAll()
      };
      const pcKeymap = {
        ...baseKeymap
      };
      const macKeymap = {
        ...baseKeymap,
        "Ctrl-h": handleBackspace,
        "Alt-Backspace": handleBackspace,
        "Ctrl-d": handleDelete,
        "Ctrl-Alt-Backspace": handleDelete,
        "Alt-Delete": handleDelete,
        "Alt-d": handleDelete,
        "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
        "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
      };
      if (isiOS() || isMacOS()) {
        return macKeymap;
      }
      return pcKeymap;
    },
    addProseMirrorPlugins() {
      return [
        // With this plugin we check if the whole document was selected and deleted.
        // In this case we will additionally call `clearNodes()` to convert e.g. a heading
        // to a paragraph if necessary.
        // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
        // with many other commands.
        new Plugin({
          key: new PluginKey("clearDocument"),
          appendTransaction: (transactions, oldState, newState) => {
            const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
            if (!docChanges) {
              return;
            }
            const { empty, from, to } = oldState.selection;
            const allFrom = Selection.atStart(oldState.doc).from;
            const allEnd = Selection.atEnd(oldState.doc).to;
            const allWasSelected = from === allFrom && to === allEnd;
            if (empty || !allWasSelected) {
              return;
            }
            const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, " ", " ").length === 0;
            if (!isEmpty) {
              return;
            }
            const tr = newState.tr;
            const state = createChainableState({
              state: newState,
              transaction: tr
            });
            const { commands: commands2 } = new CommandManager({
              editor: this.editor,
              state
            });
            commands2.clearNodes();
            if (!tr.steps.length) {
              return;
            }
            return tr;
          }
        })
      ];
    }
  });
  var Tabindex = Extension.create({
    name: "tabindex",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("tabindex"),
          props: {
            attributes: this.editor.isEditable ? { tabindex: "0" } : {}
          }
        })
      ];
    }
  });
  function textInputRule(config) {
    return new InputRule({
      find: config.find,
      handler: ({ state, range, match }) => {
        let insert = config.replace;
        let start = range.from;
        const end = range.to;
        if (match[1]) {
          const offset = match[0].lastIndexOf(match[1]);
          insert += match[0].slice(offset + match[1].length);
          start += offset;
          const cutOff = start - end;
          if (cutOff > 0) {
            insert = match[0].slice(offset - cutOff, offset) + insert;
            start = end;
          }
        }
        state.tr.insertText(insert, start, end);
      }
    });
  }
  var Mark2 = class _Mark {
    constructor(config = {}) {
      this.type = "mark";
      this.name = "mark";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = {
        ...this.config,
        ...config
      };
      this.name = this.config.name;
      if (config.defaultOptions) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(config = {}) {
      return new _Mark(config);
    }
    configure(options = {}) {
      const extension = this.extend();
      extension.options = mergeDeep(this.options, options);
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
    extend(extendedConfig = {}) {
      const extension = new _Mark(extendedConfig);
      extension.parent = this;
      this.child = extension;
      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
      if (extendedConfig.defaultOptions) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
      }
      extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
        name: extension.name
      }));
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
    static handleExit({ editor, mark }) {
      const { tr } = editor.state;
      const currentPos = editor.state.selection.$from;
      const isAtEnd = currentPos.pos === currentPos.end();
      if (isAtEnd) {
        const currentMarks = currentPos.marks();
        const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
        if (!isInMark) {
          return false;
        }
        const removeMark = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
        if (removeMark) {
          tr.removeStoredMark(removeMark);
        }
        tr.insertText(" ", currentPos.pos);
        editor.view.dispatch(tr);
        return true;
      }
      return false;
    }
  };

  // node_modules/@tiptap/extension-text-align/dist/index.js
  var TextAlign = Extension.create({
    name: "textAlign",
    addOptions() {
      return {
        types: [],
        alignments: ["left", "center", "right", "justify"],
        defaultAlignment: "left"
      };
    },
    addGlobalAttributes() {
      return [
        {
          types: this.options.types,
          attributes: {
            textAlign: {
              default: this.options.defaultAlignment,
              parseHTML: (element) => element.style.textAlign || this.options.defaultAlignment,
              renderHTML: (attributes) => {
                if (attributes.textAlign === this.options.defaultAlignment) {
                  return {};
                }
                return { style: `text-align: ${attributes.textAlign}` };
              }
            }
          }
        }
      ];
    },
    addCommands() {
      return {
        setTextAlign: (alignment) => ({ commands: commands2 }) => {
          if (!this.options.alignments.includes(alignment)) {
            return false;
          }
          return this.options.types.every((type) => commands2.updateAttributes(type, { textAlign: alignment }));
        },
        unsetTextAlign: () => ({ commands: commands2 }) => {
          return this.options.types.every((type) => commands2.resetAttributes(type, "textAlign"));
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
        "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
        "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
        "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
      };
    }
  });

  // node_modules/@tiptap/extension-underline/dist/index.js
  var Underline = Mark2.create({
    name: "underline",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "u"
        },
        {
          style: "text-decoration",
          consuming: false,
          getAttrs: (style) => style.includes("underline") ? {} : false
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setUnderline: () => ({ commands: commands2 }) => {
          return commands2.setMark(this.name);
        },
        toggleUnderline: () => ({ commands: commands2 }) => {
          return commands2.toggleMark(this.name);
        },
        unsetUnderline: () => ({ commands: commands2 }) => {
          return commands2.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-u": () => this.editor.commands.toggleUnderline(),
        "Mod-U": () => this.editor.commands.toggleUnderline()
      };
    }
  });

  // node_modules/@tiptap/extension-typography/dist/index.js
  var emDash = (override) => textInputRule({
    find: /--$/,
    replace: override !== null && override !== void 0 ? override : "\u2014"
  });
  var ellipsis = (override) => textInputRule({
    find: /\.\.\.$/,
    replace: override !== null && override !== void 0 ? override : "\u2026"
  });
  var openDoubleQuote = (override) => textInputRule({
    find: /(?:^|[\s{[(<'"\u2018\u201C])(")$/,
    replace: override !== null && override !== void 0 ? override : "\u201C"
  });
  var closeDoubleQuote = (override) => textInputRule({
    find: /"$/,
    replace: override !== null && override !== void 0 ? override : "\u201D"
  });
  var openSingleQuote = (override) => textInputRule({
    find: /(?:^|[\s{[(<'"\u2018\u201C])(')$/,
    replace: override !== null && override !== void 0 ? override : "\u2018"
  });
  var closeSingleQuote = (override) => textInputRule({
    find: /'$/,
    replace: override !== null && override !== void 0 ? override : "\u2019"
  });
  var leftArrow = (override) => textInputRule({
    find: /<-$/,
    replace: override !== null && override !== void 0 ? override : "\u2190"
  });
  var rightArrow = (override) => textInputRule({
    find: /->$/,
    replace: override !== null && override !== void 0 ? override : "\u2192"
  });
  var copyright = (override) => textInputRule({
    find: /\(c\)$/,
    replace: override !== null && override !== void 0 ? override : "\xA9"
  });
  var trademark = (override) => textInputRule({
    find: /\(tm\)$/,
    replace: override !== null && override !== void 0 ? override : "\u2122"
  });
  var servicemark = (override) => textInputRule({
    find: /\(sm\)$/,
    replace: override !== null && override !== void 0 ? override : "\u2120"
  });
  var registeredTrademark = (override) => textInputRule({
    find: /\(r\)$/,
    replace: override !== null && override !== void 0 ? override : "\xAE"
  });
  var oneHalf = (override) => textInputRule({
    find: /(?:^|\s)(1\/2)$/,
    replace: override !== null && override !== void 0 ? override : "\xBD"
  });
  var plusMinus = (override) => textInputRule({
    find: /\+\/-$/,
    replace: override !== null && override !== void 0 ? override : "\xB1"
  });
  var notEqual = (override) => textInputRule({
    find: /!=$/,
    replace: override !== null && override !== void 0 ? override : "\u2260"
  });
  var laquo = (override) => textInputRule({
    find: /<<$/,
    replace: override !== null && override !== void 0 ? override : "\xAB"
  });
  var raquo = (override) => textInputRule({
    find: />>$/,
    replace: override !== null && override !== void 0 ? override : "\xBB"
  });
  var multiplication = (override) => textInputRule({
    find: /\d+\s?([*x])\s?\d+$/,
    replace: override !== null && override !== void 0 ? override : "\xD7"
  });
  var superscriptTwo = (override) => textInputRule({
    find: /\^2$/,
    replace: override !== null && override !== void 0 ? override : "\xB2"
  });
  var superscriptThree = (override) => textInputRule({
    find: /\^3$/,
    replace: override !== null && override !== void 0 ? override : "\xB3"
  });
  var oneQuarter = (override) => textInputRule({
    find: /(?:^|\s)(1\/4)$/,
    replace: override !== null && override !== void 0 ? override : "\xBC"
  });
  var threeQuarters = (override) => textInputRule({
    find: /(?:^|\s)(3\/4)$/,
    replace: override !== null && override !== void 0 ? override : "\xBE"
  });
  var Typography = Extension.create({
    name: "typography",
    addInputRules() {
      const rules = [];
      if (this.options.emDash !== false) {
        rules.push(emDash(this.options.emDash));
      }
      if (this.options.ellipsis !== false) {
        rules.push(ellipsis(this.options.ellipsis));
      }
      if (this.options.openDoubleQuote !== false) {
        rules.push(openDoubleQuote(this.options.openDoubleQuote));
      }
      if (this.options.closeDoubleQuote !== false) {
        rules.push(closeDoubleQuote(this.options.closeDoubleQuote));
      }
      if (this.options.openSingleQuote !== false) {
        rules.push(openSingleQuote(this.options.openSingleQuote));
      }
      if (this.options.closeSingleQuote !== false) {
        rules.push(closeSingleQuote(this.options.closeSingleQuote));
      }
      if (this.options.leftArrow !== false) {
        rules.push(leftArrow(this.options.leftArrow));
      }
      if (this.options.rightArrow !== false) {
        rules.push(rightArrow(this.options.rightArrow));
      }
      if (this.options.copyright !== false) {
        rules.push(copyright(this.options.copyright));
      }
      if (this.options.trademark !== false) {
        rules.push(trademark(this.options.trademark));
      }
      if (this.options.servicemark !== false) {
        rules.push(servicemark(this.options.servicemark));
      }
      if (this.options.registeredTrademark !== false) {
        rules.push(registeredTrademark(this.options.registeredTrademark));
      }
      if (this.options.oneHalf !== false) {
        rules.push(oneHalf(this.options.oneHalf));
      }
      if (this.options.plusMinus !== false) {
        rules.push(plusMinus(this.options.plusMinus));
      }
      if (this.options.notEqual !== false) {
        rules.push(notEqual(this.options.notEqual));
      }
      if (this.options.laquo !== false) {
        rules.push(laquo(this.options.laquo));
      }
      if (this.options.raquo !== false) {
        rules.push(raquo(this.options.raquo));
      }
      if (this.options.multiplication !== false) {
        rules.push(multiplication(this.options.multiplication));
      }
      if (this.options.superscriptTwo !== false) {
        rules.push(superscriptTwo(this.options.superscriptTwo));
      }
      if (this.options.superscriptThree !== false) {
        rules.push(superscriptThree(this.options.superscriptThree));
      }
      if (this.options.oneQuarter !== false) {
        rules.push(oneQuarter(this.options.oneQuarter));
      }
      if (this.options.threeQuarters !== false) {
        rules.push(threeQuarters(this.options.threeQuarters));
      }
      return rules;
    }
  });

  // packages/support/resources/js/utils.js
  function registerExtension(id, callback) {
    if (id === void 0) {
      throw new Error("id can't be undefined when registering an extension");
    }
    if (callback === void 0) {
      throw new Error("callback can't be undefined when registering an extension");
    }
    document.addEventListener("alpine:init", () => {
      const ext = callback(window.talltapRegistry.getConfig(id));
      if (Array.isArray(ext)) {
        for (const extElement of ext) {
          window.talltapRegistry.register(extElement);
        }
      } else {
        window.talltapRegistry.register(ext);
      }
    });
  }

  // packages/starter-kit/resources/js/index.js
  registerExtension("starter-kit", () => [
    TextAlign.configure({ types: ["heading", "paragraph"] }),
    Underline,
    Typography
  ]);
})();
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLW1vZGVsL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXRyYW5zZm9ybS9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1zdGF0ZS9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1jb21tYW5kcy9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1zY2hlbWEtbGlzdC9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY3JlYXRlQ2hhaW5hYmxlU3RhdGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvQ29tbWFuZE1hbmFnZXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvRXZlbnRFbWl0dGVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9zcGxpdEV4dGVuc2lvbnMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXROb2RlVHlwZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvbWVyZ2VBdHRyaWJ1dGVzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc0Z1bmN0aW9uLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzRW1wdHlPYmplY3QudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2Zyb21TdHJpbmcudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFNjaGVtYVR5cGVCeU5hbWUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0V4dGVuc2lvblJ1bGVzRW5hYmxlZC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFRleHRDb250ZW50RnJvbU5vZGVzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc1JlZ0V4cC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9JbnB1dFJ1bGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzTnVtYmVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL1Bhc3RlUnVsZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvZmluZER1cGxpY2F0ZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvRXh0ZW5zaW9uTWFuYWdlci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvaXNQbGFpbk9iamVjdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvbWVyZ2VEZWVwLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL0V4dGVuc2lvbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFRleHRCZXR3ZWVuLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2NsaXBib2FyZFRleHRTZXJpYWxpemVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2JsdXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvY2xlYXJDb250ZW50LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2NsZWFyTm9kZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvY29tbWFuZC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9jcmVhdGVQYXJhZ3JhcGhOZWFyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2N1dC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9kZWxldGVDdXJyZW50Tm9kZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9kZWxldGVOb2RlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2RlbGV0ZVJhbmdlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2RlbGV0ZVNlbGVjdGlvbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9lbnRlci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9leGl0Q29kZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvb2JqZWN0SW5jbHVkZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRNYXJrUmFuZ2UudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRNYXJrVHlwZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9leHRlbmRNYXJrUmFuZ2UudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvZmlyc3QudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc1RleHRTZWxlY3Rpb24udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL21pbk1heC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL3Jlc29sdmVGb2N1c1Bvc2l0aW9uLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc2lPUy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9mb2N1cy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9mb3JFYWNoLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2luc2VydENvbnRlbnQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2VsZW1lbnRGcm9tU3RyaW5nLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY3JlYXRlTm9kZUZyb21Db250ZW50LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvaW5zZXJ0Q29udGVudEF0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2pvaW4udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvam9pbkl0ZW1CYWNrd2FyZC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9qb2luSXRlbUZvcndhcmQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzTWFjT1MudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMva2V5Ym9hcmRTaG9ydGN1dC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzTm9kZUFjdGl2ZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9saWZ0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2xpZnRFbXB0eUJsb2NrLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2xpZnRMaXN0SXRlbS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9uZXdsaW5lSW5Db2RlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2RlbGV0ZVByb3BzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3Jlc2V0QXR0cmlidXRlcy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zY3JvbGxJbnRvVmlldy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZWxlY3RBbGwudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2VsZWN0Tm9kZUJhY2t3YXJkLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdE5vZGVGb3J3YXJkLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdFBhcmVudE5vZGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2VsZWN0VGV4dGJsb2NrRW5kLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdFRleHRibG9ja1N0YXJ0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY3JlYXRlRG9jdW1lbnQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2V0Q29udGVudC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldE1hcmtBdHRyaWJ1dGVzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY29tYmluZVRyYW5zYWN0aW9uU3RlcHMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9kZWZhdWx0QmxvY2tBdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2ZpbmRDaGlsZHJlbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2ZpbmRDaGlsZHJlbkluUmFuZ2UudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9maW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1Bvcy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2ZpbmRQYXJlbnROb2RlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0SFRNTEZyb21GcmFnbWVudC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFNjaGVtYS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dlbmVyYXRlSFRNTC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dlbmVyYXRlSlNPTi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFRleHQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZW5lcmF0ZVRleHQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXROb2RlQXR0cmlidXRlcy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldEF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL3JlbW92ZUR1cGxpY2F0ZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRDaGFuZ2VkUmFuZ2VzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0RGVidWdKU09OLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0TWFya3NCZXR3ZWVuLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0Tm9kZUF0UG9zaXRpb24udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRTcGxpdHRlZEF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc01hcmtBY3RpdmUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0FjdGl2ZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzQXRFbmRPZk5vZGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0F0U3RhcnRPZk5vZGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0xpc3QudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc05vZGVFbXB0eS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzTm9kZVNlbGVjdGlvbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL3Bvc1RvRE9NUmVjdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZXRNYXJrLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NldE1ldGEudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2V0Tm9kZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZXROb2RlU2VsZWN0aW9uLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NldFRleHRTZWxlY3Rpb24udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2lua0xpc3RJdGVtLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NwbGl0QmxvY2sudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc3BsaXRMaXN0SXRlbS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy90b2dnbGVMaXN0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3RvZ2dsZU1hcmsudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdG9nZ2xlTm9kZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy90b2dnbGVXcmFwLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3VuZG9JbnB1dFJ1bGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdW5zZXRBbGxNYXJrcy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy91bnNldE1hcmsudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdXBkYXRlQXR0cmlidXRlcy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy93cmFwSW4udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvd3JhcEluTGlzdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2NvbW1hbmRzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2V4dGVuc2lvbnMvZWRpdGFibGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvZXh0ZW5zaW9ucy9mb2N1c0V2ZW50cy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2tleW1hcC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL3RhYmluZGV4LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3N0eWxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9jcmVhdGVTdHlsZVRhZy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9FZGl0b3IudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaW5wdXRSdWxlcy9tYXJrSW5wdXRSdWxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2lucHV0UnVsZXMvbm9kZUlucHV0UnVsZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9pbnB1dFJ1bGVzL3RleHRibG9ja1R5cGVJbnB1dFJ1bGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaW5wdXRSdWxlcy90ZXh0SW5wdXRSdWxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2lucHV0UnVsZXMvd3JhcHBpbmdJbnB1dFJ1bGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvTWFyay50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9Ob2RlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc0FuZHJvaWQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvTm9kZVZpZXcudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvcGFzdGVSdWxlcy9tYXJrUGFzdGVSdWxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9lc2NhcGVGb3JSZWdFeC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvaXNTdHJpbmcudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvcGFzdGVSdWxlcy9ub2RlUGFzdGVSdWxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3Bhc3RlUnVsZXMvdGV4dFBhc3RlUnVsZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9UcmFja2VyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10ZXh0LWFsaWduL3NyYy90ZXh0LWFsaWduLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi11bmRlcmxpbmUvc3JjL3VuZGVybGluZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdHlwb2dyYXBoeS9zcmMvdHlwb2dyYXBoeS50cyIsICIuLi8uLi9zdXBwb3J0L3Jlc291cmNlcy9qcy91dGlscy5qcyIsICIuLi9yZXNvdXJjZXMvanMvaW5kZXguanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCBPcmRlcmVkTWFwIGZyb20gJ29yZGVyZWRtYXAnO1xuXG5mdW5jdGlvbiBmaW5kRGlmZlN0YXJ0KGEsIGIsIHBvcykge1xuICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIGlmIChpID09IGEuY2hpbGRDb3VudCB8fCBpID09IGIuY2hpbGRDb3VudClcbiAgICAgICAgICAgIHJldHVybiBhLmNoaWxkQ291bnQgPT0gYi5jaGlsZENvdW50ID8gbnVsbCA6IHBvcztcbiAgICAgICAgbGV0IGNoaWxkQSA9IGEuY2hpbGQoaSksIGNoaWxkQiA9IGIuY2hpbGQoaSk7XG4gICAgICAgIGlmIChjaGlsZEEgPT0gY2hpbGRCKSB7XG4gICAgICAgICAgICBwb3MgKz0gY2hpbGRBLm5vZGVTaXplO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGlsZEEuc2FtZU1hcmt1cChjaGlsZEIpKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgaWYgKGNoaWxkQS5pc1RleHQgJiYgY2hpbGRBLnRleHQgIT0gY2hpbGRCLnRleHQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBjaGlsZEEudGV4dFtqXSA9PSBjaGlsZEIudGV4dFtqXTsgaisrKVxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRBLmNvbnRlbnQuc2l6ZSB8fCBjaGlsZEIuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgaW5uZXIgPSBmaW5kRGlmZlN0YXJ0KGNoaWxkQS5jb250ZW50LCBjaGlsZEIuY29udGVudCwgcG9zICsgMSk7XG4gICAgICAgICAgICBpZiAoaW5uZXIgIT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXI7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGNoaWxkQS5ub2RlU2l6ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kRGlmZkVuZChhLCBiLCBwb3NBLCBwb3NCKSB7XG4gICAgZm9yIChsZXQgaUEgPSBhLmNoaWxkQ291bnQsIGlCID0gYi5jaGlsZENvdW50OzspIHtcbiAgICAgICAgaWYgKGlBID09IDAgfHwgaUIgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBpQSA9PSBpQiA/IG51bGwgOiB7IGE6IHBvc0EsIGI6IHBvc0IgfTtcbiAgICAgICAgbGV0IGNoaWxkQSA9IGEuY2hpbGQoLS1pQSksIGNoaWxkQiA9IGIuY2hpbGQoLS1pQiksIHNpemUgPSBjaGlsZEEubm9kZVNpemU7XG4gICAgICAgIGlmIChjaGlsZEEgPT0gY2hpbGRCKSB7XG4gICAgICAgICAgICBwb3NBIC09IHNpemU7XG4gICAgICAgICAgICBwb3NCIC09IHNpemU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoaWxkQS5zYW1lTWFya3VwKGNoaWxkQikpXG4gICAgICAgICAgICByZXR1cm4geyBhOiBwb3NBLCBiOiBwb3NCIH07XG4gICAgICAgIGlmIChjaGlsZEEuaXNUZXh0ICYmIGNoaWxkQS50ZXh0ICE9IGNoaWxkQi50ZXh0KSB7XG4gICAgICAgICAgICBsZXQgc2FtZSA9IDAsIG1pblNpemUgPSBNYXRoLm1pbihjaGlsZEEudGV4dC5sZW5ndGgsIGNoaWxkQi50ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB3aGlsZSAoc2FtZSA8IG1pblNpemUgJiYgY2hpbGRBLnRleHRbY2hpbGRBLnRleHQubGVuZ3RoIC0gc2FtZSAtIDFdID09IGNoaWxkQi50ZXh0W2NoaWxkQi50ZXh0Lmxlbmd0aCAtIHNhbWUgLSAxXSkge1xuICAgICAgICAgICAgICAgIHNhbWUrKztcbiAgICAgICAgICAgICAgICBwb3NBLS07XG4gICAgICAgICAgICAgICAgcG9zQi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgYTogcG9zQSwgYjogcG9zQiB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEEuY29udGVudC5zaXplIHx8IGNoaWxkQi5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGZpbmREaWZmRW5kKGNoaWxkQS5jb250ZW50LCBjaGlsZEIuY29udGVudCwgcG9zQSAtIDEsIHBvc0IgLSAxKTtcbiAgICAgICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXI7XG4gICAgICAgIH1cbiAgICAgICAgcG9zQSAtPSBzaXplO1xuICAgICAgICBwb3NCIC09IHNpemU7XG4gICAgfVxufVxuXG4vKipcbkEgZnJhZ21lbnQgcmVwcmVzZW50cyBhIG5vZGUncyBjb2xsZWN0aW9uIG9mIGNoaWxkIG5vZGVzLlxuXG5MaWtlIG5vZGVzLCBmcmFnbWVudHMgYXJlIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmVzLCBhbmQgeW91XG5zaG91bGQgbm90IG11dGF0ZSB0aGVtIG9yIHRoZWlyIGNvbnRlbnQuIFJhdGhlciwgeW91IGNyZWF0ZSBuZXdcbmluc3RhbmNlcyB3aGVuZXZlciBuZWVkZWQuIFRoZSBBUEkgdHJpZXMgdG8gbWFrZSB0aGlzIGVhc3kuXG4qL1xuY2xhc3MgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb250ZW50LCBzaXplKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemUgfHwgMDtcbiAgICAgICAgaWYgKHNpemUgPT0gbnVsbClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUgKz0gY29udGVudFtpXS5ub2RlU2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW52b2tlIGEgY2FsbGJhY2sgZm9yIGFsbCBkZXNjZW5kYW50IG5vZGVzIGJldHdlZW4gdGhlIGdpdmVuIHR3b1xuICAgIHBvc2l0aW9ucyAocmVsYXRpdmUgdG8gc3RhcnQgb2YgdGhpcyBmcmFnbWVudCkuIERvZXNuJ3QgZGVzY2VuZFxuICAgIGludG8gYSBub2RlIHdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYC5cbiAgICAqL1xuICAgIG5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZiwgbm9kZVN0YXJ0ID0gMCwgcGFyZW50KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBwb3MgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV0sIGVuZCA9IHBvcyArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGVuZCA+IGZyb20gJiYgZihjaGlsZCwgbm9kZVN0YXJ0ICsgcG9zLCBwYXJlbnQgfHwgbnVsbCwgaSkgIT09IGZhbHNlICYmIGNoaWxkLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgY2hpbGQubm9kZXNCZXR3ZWVuKE1hdGgubWF4KDAsIGZyb20gLSBzdGFydCksIE1hdGgubWluKGNoaWxkLmNvbnRlbnQuc2l6ZSwgdG8gLSBzdGFydCksIGYsIG5vZGVTdGFydCArIHN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDYWxsIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgZXZlcnkgZGVzY2VuZGFudCBub2RlLiBgcG9zYCB3aWxsIGJlXG4gICAgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudC4gVGhlIGNhbGxiYWNrIG1heSByZXR1cm5cbiAgICBgZmFsc2VgIHRvIHByZXZlbnQgdHJhdmVyc2FsIG9mIGEgZ2l2ZW4gbm9kZSdzIGNoaWxkcmVuLlxuICAgICovXG4gICAgZGVzY2VuZGFudHMoZikge1xuICAgICAgICB0aGlzLm5vZGVzQmV0d2VlbigwLCB0aGlzLnNpemUsIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICBFeHRyYWN0IHRoZSB0ZXh0IGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLiBTZWUgdGhlIHNhbWUgbWV0aG9kIG9uXG4gICAgW2BOb2RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUudGV4dEJldHdlZW4pLlxuICAgICovXG4gICAgdGV4dEJldHdlZW4oZnJvbSwgdG8sIGJsb2NrU2VwYXJhdG9yLCBsZWFmVGV4dCkge1xuICAgICAgICBsZXQgdGV4dCA9IFwiXCIsIHNlcGFyYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IG5vZGUudGV4dC5zbGljZShNYXRoLm1heChmcm9tLCBwb3MpIC0gcG9zLCB0byAtIHBvcyk7XG4gICAgICAgICAgICAgICAgc2VwYXJhdGVkID0gIWJsb2NrU2VwYXJhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVhZlRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSB0eXBlb2YgbGVhZlRleHQgPT09IFwiZnVuY3Rpb25cIiA/IGxlYWZUZXh0KG5vZGUpIDogbGVhZlRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZS5zcGVjLmxlYWZUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gbm9kZS50eXBlLnNwZWMubGVhZlRleHQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlcGFyYXRlZCA9ICFibG9ja1NlcGFyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFzZXBhcmF0ZWQgJiYgbm9kZS5pc0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBibG9ja1NlcGFyYXRvcjtcbiAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBjb250YWluaW5nIHRoZSBjb21iaW5lZCBjb250ZW50IG9mIHRoaXNcbiAgICBmcmFnbWVudCBhbmQgdGhlIG90aGVyLlxuICAgICovXG4gICAgYXBwZW5kKG90aGVyKSB7XG4gICAgICAgIGlmICghb3RoZXIuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmxhc3RDaGlsZCwgZmlyc3QgPSBvdGhlci5maXJzdENoaWxkLCBjb250ZW50ID0gdGhpcy5jb250ZW50LnNsaWNlKCksIGkgPSAwO1xuICAgICAgICBpZiAobGFzdC5pc1RleHQgJiYgbGFzdC5zYW1lTWFya3VwKGZpcnN0KSkge1xuICAgICAgICAgICAgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdID0gbGFzdC53aXRoVGV4dChsYXN0LnRleHQgKyBmaXJzdC50ZXh0KTtcbiAgICAgICAgICAgIGkgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpIDwgb3RoZXIuY29udGVudC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaChvdGhlci5jb250ZW50W2ldKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50LCB0aGlzLnNpemUgKyBvdGhlci5zaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3V0IG91dCB0aGUgc3ViLWZyYWdtZW50IGJldHdlZW4gdGhlIHR3byBnaXZlbiBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBjdXQoZnJvbSwgdG8gPSB0aGlzLnNpemUpIHtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBzaXplID0gMDtcbiAgICAgICAgaWYgKHRvID4gZnJvbSlcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBwb3MgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jb250ZW50W2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zIDwgZnJvbSB8fCBlbmQgPiB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmlzVGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmN1dChNYXRoLm1heCgwLCBmcm9tIC0gcG9zKSwgTWF0aC5taW4oY2hpbGQudGV4dC5sZW5ndGgsIHRvIC0gcG9zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jdXQoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyAtIDEpLCBNYXRoLm1pbihjaGlsZC5jb250ZW50LnNpemUsIHRvIC0gcG9zIC0gMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHJlc3VsdCwgc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3V0QnlJbmRleChmcm9tLCB0bykge1xuICAgICAgICBpZiAoZnJvbSA9PSB0bylcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQodGhpcy5jb250ZW50LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBpbiB3aGljaCB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXggaXNcbiAgICByZXBsYWNlZCBieSB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAqL1xuICAgIHJlcGxhY2VDaGlsZChpbmRleCwgbm9kZSkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuY29udGVudFtpbmRleF07XG4gICAgICAgIGlmIChjdXJyZW50ID09IG5vZGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IGNvcHkgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKTtcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplIC0gY3VycmVudC5ub2RlU2l6ZTtcbiAgICAgICAgY29weVtpbmRleF0gPSBub2RlO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvcHksIHNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgYnkgcHJlcGVuZGluZyB0aGUgZ2l2ZW4gbm9kZSB0byB0aGlzXG4gICAgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBhZGRUb1N0YXJ0KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZV0uY29uY2F0KHRoaXMuY29udGVudCksIHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgYnkgYXBwZW5kaW5nIHRoZSBnaXZlbiBub2RlIHRvIHRoaXNcbiAgICBmcmFnbWVudC5cbiAgICAqL1xuICAgIGFkZFRvRW5kKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmNvbnRlbnQuY29uY2F0KG5vZGUpLCB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIGZyYWdtZW50IHRvIGFub3RoZXIgb25lLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggIT0gb3RoZXIuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRbaV0uZXEob3RoZXIuY29udGVudFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBmcmFnbWVudCwgb3IgYG51bGxgIGlmIGl0IGlzIGVtcHR5LlxuICAgICovXG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50WzBdIDogbnVsbDsgfVxuICAgIC8qKlxuICAgIFRoZSBsYXN0IGNoaWxkIG9mIHRoZSBmcmFnbWVudCwgb3IgYG51bGxgIGlmIGl0IGlzIGVtcHR5LlxuICAgICovXG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdIDogbnVsbDsgfVxuICAgIC8qKlxuICAgIFRoZSBudW1iZXIgb2YgY2hpbGQgbm9kZXMgaW4gdGhpcyBmcmFnbWVudC5cbiAgICAqL1xuICAgIGdldCBjaGlsZENvdW50KCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aDsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguIFJhaXNlIGFuIGVycm9yIHdoZW4gdGhlXG4gICAgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgICovXG4gICAgY2hpbGQoaW5kZXgpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5jb250ZW50W2luZGV4XTtcbiAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggXCIgKyBpbmRleCArIFwiIG91dCBvZiByYW5nZSBmb3IgXCIgKyB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LCBpZiBpdCBleGlzdHMuXG4gICAgKi9cbiAgICBtYXliZUNoaWxkKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRbaW5kZXhdIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGwgYGZgIGZvciBldmVyeSBjaGlsZCBub2RlLCBwYXNzaW5nIHRoZSBub2RlLCBpdHMgb2Zmc2V0XG4gICAgaW50byB0aGlzIHBhcmVudCBub2RlLCBhbmQgaXRzIGluZGV4LlxuICAgICovXG4gICAgZm9yRWFjaChmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jb250ZW50W2ldO1xuICAgICAgICAgICAgZihjaGlsZCwgcCwgaSk7XG4gICAgICAgICAgICBwICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGZpcnN0IHBvc2l0aW9uIGF0IHdoaWNoIHRoaXMgZnJhZ21lbnQgYW5kIGFub3RoZXJcbiAgICBmcmFnbWVudCBkaWZmZXIsIG9yIGBudWxsYCBpZiB0aGV5IGFyZSB0aGUgc2FtZS5cbiAgICAqL1xuICAgIGZpbmREaWZmU3RhcnQob3RoZXIsIHBvcyA9IDApIHtcbiAgICAgICAgcmV0dXJuIGZpbmREaWZmU3RhcnQodGhpcywgb3RoZXIsIHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGZpcnN0IHBvc2l0aW9uLCBzZWFyY2hpbmcgZnJvbSB0aGUgZW5kLCBhdCB3aGljaCB0aGlzXG4gICAgZnJhZ21lbnQgYW5kIHRoZSBnaXZlbiBmcmFnbWVudCBkaWZmZXIsIG9yIGBudWxsYCBpZiB0aGV5IGFyZVxuICAgIHRoZSBzYW1lLiBTaW5jZSB0aGlzIHBvc2l0aW9uIHdpbGwgbm90IGJlIHRoZSBzYW1lIGluIGJvdGhcbiAgICBub2RlcywgYW4gb2JqZWN0IHdpdGggdHdvIHNlcGFyYXRlIHBvc2l0aW9ucyBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIGZpbmREaWZmRW5kKG90aGVyLCBwb3MgPSB0aGlzLnNpemUsIG90aGVyUG9zID0gb3RoZXIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmluZERpZmZFbmQodGhpcywgb3RoZXIsIHBvcywgb3RoZXJQb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBpbmRleCBhbmQgaW5uZXIgb2Zmc2V0IGNvcnJlc3BvbmRpbmcgdG8gYSBnaXZlbiByZWxhdGl2ZVxuICAgIHBvc2l0aW9uIGluIHRoaXMgZnJhZ21lbnQuIFRoZSByZXN1bHQgb2JqZWN0IHdpbGwgYmUgcmV1c2VkXG4gICAgKG92ZXJ3cml0dGVuKSB0aGUgbmV4dCB0aW1lIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQuIChOb3QgcHVibGljLilcbiAgICAqL1xuICAgIGZpbmRJbmRleChwb3MsIHJvdW5kID0gLTEpIHtcbiAgICAgICAgaWYgKHBvcyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KDAsIHBvcyk7XG4gICAgICAgIGlmIChwb3MgPT0gdGhpcy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KHRoaXMuY29udGVudC5sZW5ndGgsIHBvcyk7XG4gICAgICAgIGlmIChwb3MgPiB0aGlzLnNpemUgfHwgcG9zIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQb3NpdGlvbiAke3Bvc30gb3V0c2lkZSBvZiBmcmFnbWVudCAoJHt0aGlzfSlgKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGN1clBvcyA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLmNoaWxkKGkpLCBlbmQgPSBjdXJQb3MgKyBjdXIubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoZW5kID49IHBvcykge1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPT0gcG9zIHx8IHJvdW5kID4gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KGkgKyAxLCBlbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXRJbmRleChpLCBjdXJQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyUG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIGRlYnVnZ2luZyBzdHJpbmcgdGhhdCBkZXNjcmliZXMgdGhpcyBmcmFnbWVudC5cbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gXCI8XCIgKyB0aGlzLnRvU3RyaW5nSW5uZXIoKSArIFwiPlwiOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZ0lubmVyKCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmpvaW4oXCIsIFwiKTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIEpTT04tc2VyaWFsaXplYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZyYWdtZW50LlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudC5tYXAobiA9PiBuLnRvSlNPTigpKSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgZnJhZ21lbnQgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEZyYWdtZW50LmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHZhbHVlLm1hcChzY2hlbWEubm9kZUZyb21KU09OKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgZnJhZ21lbnQgZnJvbSBhbiBhcnJheSBvZiBub2Rlcy4gRW5zdXJlcyB0aGF0IGFkamFjZW50XG4gICAgdGV4dCBub2RlcyB3aXRoIHRoZSBzYW1lIG1hcmtzIGFyZSBqb2luZWQgdG9nZXRoZXIuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUFycmF5KGFycmF5KSB7XG4gICAgICAgIGlmICghYXJyYXkubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBsZXQgam9pbmVkLCBzaXplID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBhcnJheVtpXTtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChpICYmIG5vZGUuaXNUZXh0ICYmIGFycmF5W2kgLSAxXS5zYW1lTWFya3VwKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFqb2luZWQpXG4gICAgICAgICAgICAgICAgICAgIGpvaW5lZCA9IGFycmF5LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGpvaW5lZFtqb2luZWQubGVuZ3RoIC0gMV0gPSBub2RlXG4gICAgICAgICAgICAgICAgICAgIC53aXRoVGV4dChqb2luZWRbam9pbmVkLmxlbmd0aCAtIDFdLnRleHQgKyBub2RlLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoam9pbmVkKSB7XG4gICAgICAgICAgICAgICAgam9pbmVkLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChqb2luZWQgfHwgYXJyYXksIHNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmcmFnbWVudCBmcm9tIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBpbnRlcnByZXRlZCBhcyBhXG4gICAgc2V0IG9mIG5vZGVzLiBGb3IgYG51bGxgLCBpdCByZXR1cm5zIHRoZSBlbXB0eSBmcmFnbWVudC4gRm9yIGFcbiAgICBmcmFnbWVudCwgdGhlIGZyYWdtZW50IGl0c2VsZi4gRm9yIGEgbm9kZSBvciBhcnJheSBvZiBub2RlcywgYVxuICAgIGZyYWdtZW50IGNvbnRhaW5pbmcgdGhvc2Ugbm9kZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbShub2Rlcykge1xuICAgICAgICBpZiAoIW5vZGVzKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBpZiAobm9kZXMgaW5zdGFuY2VvZiBGcmFnbWVudClcbiAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUFycmF5KG5vZGVzKTtcbiAgICAgICAgaWYgKG5vZGVzLmF0dHJzKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZXNdLCBub2Rlcy5ub2RlU2l6ZSk7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuIG5vdCBjb252ZXJ0IFwiICsgbm9kZXMgKyBcIiB0byBhIEZyYWdtZW50XCIgK1xuICAgICAgICAgICAgKG5vZGVzLm5vZGVzQmV0d2VlbiA/IFwiIChsb29rcyBsaWtlIG11bHRpcGxlIHZlcnNpb25zIG9mIHByb3NlbWlycm9yLW1vZGVsIHdlcmUgbG9hZGVkKVwiIDogXCJcIikpO1xuICAgIH1cbn1cbi8qKlxuQW4gZW1wdHkgZnJhZ21lbnQuIEludGVuZGVkIHRvIGJlIHJldXNlZCB3aGVuZXZlciBhIG5vZGUgZG9lc24ndFxuY29udGFpbiBhbnl0aGluZyAocmF0aGVyIHRoYW4gYWxsb2NhdGluZyBhIG5ldyBlbXB0eSBmcmFnbWVudCBmb3JcbmVhY2ggbGVhZiBub2RlKS5cbiovXG5GcmFnbWVudC5lbXB0eSA9IG5ldyBGcmFnbWVudChbXSwgMCk7XG5jb25zdCBmb3VuZCA9IHsgaW5kZXg6IDAsIG9mZnNldDogMCB9O1xuZnVuY3Rpb24gcmV0SW5kZXgoaW5kZXgsIG9mZnNldCkge1xuICAgIGZvdW5kLmluZGV4ID0gaW5kZXg7XG4gICAgZm91bmQub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiBmb3VuZDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZURlZXAoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIShhICYmIHR5cGVvZiBhID09IFwib2JqZWN0XCIpIHx8XG4gICAgICAgICEoYiAmJiB0eXBlb2YgYiA9PSBcIm9iamVjdFwiKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhcnJheSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYikgIT0gYXJyYXkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWNvbXBhcmVEZWVwKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IHAgaW4gYSlcbiAgICAgICAgICAgIGlmICghKHAgaW4gYikgfHwgIWNvbXBhcmVEZWVwKGFbcF0sIGJbcF0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgcCBpbiBiKVxuICAgICAgICAgICAgaWYgKCEocCBpbiBhKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbkEgbWFyayBpcyBhIHBpZWNlIG9mIGluZm9ybWF0aW9uIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgbm9kZSxcbnN1Y2ggYXMgaXQgYmVpbmcgZW1waGFzaXplZCwgaW4gY29kZSBmb250LCBvciBhIGxpbmsuIEl0IGhhcyBhXG50eXBlIGFuZCBvcHRpb25hbGx5IGEgc2V0IG9mIGF0dHJpYnV0ZXMgdGhhdCBwcm92aWRlIGZ1cnRoZXJcbmluZm9ybWF0aW9uIChzdWNoIGFzIHRoZSB0YXJnZXQgb2YgdGhlIGxpbmspLiBNYXJrcyBhcmUgY3JlYXRlZFxudGhyb3VnaCBhIGBTY2hlbWFgLCB3aGljaCBjb250cm9scyB3aGljaCB0eXBlcyBleGlzdCBhbmQgd2hpY2hcbmF0dHJpYnV0ZXMgdGhleSBoYXZlLlxuKi9cbmNsYXNzIE1hcmsge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgdGhpcyBtYXJrLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIGF0dHJpYnV0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWFyay5cbiAgICAqL1xuICAgIGF0dHJzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICB9XG4gICAgLyoqXG4gICAgR2l2ZW4gYSBzZXQgb2YgbWFya3MsIGNyZWF0ZSBhIG5ldyBzZXQgd2hpY2ggY29udGFpbnMgdGhpcyBvbmUgYXNcbiAgICB3ZWxsLCBpbiB0aGUgcmlnaHQgcG9zaXRpb24uIElmIHRoaXMgbWFyayBpcyBhbHJlYWR5IGluIHRoZSBzZXQsXG4gICAgdGhlIHNldCBpdHNlbGYgaXMgcmV0dXJuZWQuIElmIGFueSBtYXJrcyB0aGF0IGFyZSBzZXQgdG8gYmVcbiAgICBbZXhjbHVzaXZlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1NwZWMuZXhjbHVkZXMpIHdpdGggdGhpcyBtYXJrIGFyZSBwcmVzZW50LFxuICAgIHRob3NlIGFyZSByZXBsYWNlZCBieSB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFkZFRvU2V0KHNldCkge1xuICAgICAgICBsZXQgY29weSwgcGxhY2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgb3RoZXIgPSBzZXRbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5lcShvdGhlcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUuZXhjbHVkZXMob3RoZXIudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBzZXQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdGhlci50eXBlLmV4Y2x1ZGVzKHRoaXMudHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwbGFjZWQgJiYgb3RoZXIudHlwZS5yYW5rID4gdGhpcy50eXBlLnJhbmspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29weSA9IHNldC5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgY29weS5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwbGFjZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29weSlcbiAgICAgICAgICAgICAgICAgICAgY29weS5wdXNoKG90aGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICBjb3B5ID0gc2V0LnNsaWNlKCk7XG4gICAgICAgIGlmICghcGxhY2VkKVxuICAgICAgICAgICAgY29weS5wdXNoKHRoaXMpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIHRoaXMgbWFyayBmcm9tIHRoZSBnaXZlbiBzZXQsIHJldHVybmluZyBhIG5ldyBzZXQuIElmIHRoaXNcbiAgICBtYXJrIGlzIG5vdCBpbiB0aGUgc2V0LCB0aGUgc2V0IGl0c2VsZiBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIHJlbW92ZUZyb21TZXQoc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMuZXEoc2V0W2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0LnNsaWNlKDAsIGkpLmNvbmNhdChzZXQuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoaXMgbWFyayBpcyBpbiB0aGUgZ2l2ZW4gc2V0IG9mIG1hcmtzLlxuICAgICovXG4gICAgaXNJblNldChzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5lcShzZXRbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGlzIG1hcmsgaGFzIHRoZSBzYW1lIHR5cGUgYW5kIGF0dHJpYnV0ZXMgYXNcbiAgICBhbm90aGVyIG1hcmsuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgKHRoaXMudHlwZSA9PSBvdGhlci50eXBlICYmIGNvbXBhcmVEZWVwKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBtYXJrIHRvIGEgSlNPTi1zZXJpYWxpemVhYmxlIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgb2JqID0geyB0eXBlOiB0aGlzLnR5cGUubmFtZSB9O1xuICAgICAgICBmb3IgKGxldCBfIGluIHRoaXMuYXR0cnMpIHtcbiAgICAgICAgICAgIG9iai5hdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG1hcmsgZnJvbSBKU09OLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE1hcmsuZnJvbUpTT05cIik7XG4gICAgICAgIGxldCB0eXBlID0gc2NoZW1hLm1hcmtzW2pzb24udHlwZV07XG4gICAgICAgIGlmICghdHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGVyZSBpcyBubyBtYXJrIHR5cGUgJHtqc29uLnR5cGV9IGluIHRoaXMgc2NoZW1hYCk7XG4gICAgICAgIHJldHVybiB0eXBlLmNyZWF0ZShqc29uLmF0dHJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHR3byBzZXRzIG9mIG1hcmtzIGFyZSBpZGVudGljYWwuXG4gICAgKi9cbiAgICBzdGF0aWMgc2FtZVNldChhLCBiKSB7XG4gICAgICAgIGlmIChhID09IGIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWFbaV0uZXEoYltpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcHJvcGVybHkgc29ydGVkIG1hcmsgc2V0IGZyb20gbnVsbCwgYSBzaW5nbGUgbWFyaywgb3IgYW5cbiAgICB1bnNvcnRlZCBhcnJheSBvZiBtYXJrcy5cbiAgICAqL1xuICAgIHN0YXRpYyBzZXRGcm9tKG1hcmtzKSB7XG4gICAgICAgIGlmICghbWFya3MgfHwgQXJyYXkuaXNBcnJheShtYXJrcykgJiYgbWFya3MubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gTWFyay5ub25lO1xuICAgICAgICBpZiAobWFya3MgaW5zdGFuY2VvZiBNYXJrKVxuICAgICAgICAgICAgcmV0dXJuIFttYXJrc107XG4gICAgICAgIGxldCBjb3B5ID0gbWFya3Muc2xpY2UoKTtcbiAgICAgICAgY29weS5zb3J0KChhLCBiKSA9PiBhLnR5cGUucmFuayAtIGIudHlwZS5yYW5rKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIG1hcmtzLlxuKi9cbk1hcmsubm9uZSA9IFtdO1xuXG4vKipcbkVycm9yIHR5cGUgcmFpc2VkIGJ5IFtgTm9kZS5yZXBsYWNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUucmVwbGFjZSkgd2hlblxuZ2l2ZW4gYW4gaW52YWxpZCByZXBsYWNlbWVudC5cbiovXG5jbGFzcyBSZXBsYWNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG4vKlxuUmVwbGFjZUVycm9yID0gZnVuY3Rpb24odGhpczogYW55LCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgbGV0IGVyciA9IEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSlcbiAgOyhlcnIgYXMgYW55KS5fX3Byb3RvX18gPSBSZXBsYWNlRXJyb3IucHJvdG90eXBlXG4gIHJldHVybiBlcnJcbn0gYXMgYW55XG5cblJlcGxhY2VFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSlcblJlcGxhY2VFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXBsYWNlRXJyb3JcblJlcGxhY2VFcnJvci5wcm90b3R5cGUubmFtZSA9IFwiUmVwbGFjZUVycm9yXCJcbiovXG4vKipcbkEgc2xpY2UgcmVwcmVzZW50cyBhIHBpZWNlIGN1dCBvdXQgb2YgYSBsYXJnZXIgZG9jdW1lbnQuIEl0XG5zdG9yZXMgbm90IG9ubHkgYSBmcmFnbWVudCwgYnV0IGFsc28gdGhlIGRlcHRoIHVwIHRvIHdoaWNoIG5vZGVzIG9uXG5ib3RoIHNpZGUgYXJlIFx1MjAxOG9wZW5cdTIwMTkgKGN1dCB0aHJvdWdoKS5cbiovXG5jbGFzcyBTbGljZSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2xpY2UuIFdoZW4gc3BlY2lmeWluZyBhIG5vbi16ZXJvIG9wZW4gZGVwdGgsIHlvdSBtdXN0XG4gICAgbWFrZSBzdXJlIHRoYXQgdGhlcmUgYXJlIG5vZGVzIG9mIGF0IGxlYXN0IHRoYXQgZGVwdGggYXQgdGhlXG4gICAgYXBwcm9wcmlhdGUgc2lkZSBvZiB0aGUgZnJhZ21lbnRcdTIwMTRpLmUuIGlmIHRoZSBmcmFnbWVudCBpcyBhblxuICAgIGVtcHR5IHBhcmFncmFwaCBub2RlLCBgb3BlblN0YXJ0YCBhbmQgYG9wZW5FbmRgIGNhbid0IGJlIGdyZWF0ZXJcbiAgICB0aGFuIDEuXG4gICAgXG4gICAgSXQgaXMgbm90IG5lY2Vzc2FyeSBmb3IgdGhlIGNvbnRlbnQgb2Ygb3BlbiBub2RlcyB0byBjb25mb3JtIHRvXG4gICAgdGhlIHNjaGVtYSdzIGNvbnRlbnQgY29uc3RyYWludHMsIHRob3VnaCBpdCBzaG91bGQgYmUgYSB2YWxpZFxuICAgIHN0YXJ0L2VuZC9taWRkbGUgZm9yIHN1Y2ggYSBub2RlLCBkZXBlbmRpbmcgb24gd2hpY2ggc2lkZXMgYXJlXG4gICAgb3Blbi5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzbGljZSdzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBjb250ZW50LCBcbiAgICAvKipcbiAgICBUaGUgb3BlbiBkZXB0aCBhdCB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50LlxuICAgICovXG4gICAgb3BlblN0YXJ0LCBcbiAgICAvKipcbiAgICBUaGUgb3BlbiBkZXB0aCBhdCB0aGUgZW5kLlxuICAgICovXG4gICAgb3BlbkVuZCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICAgICAgdGhpcy5vcGVuRW5kID0gb3BlbkVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNpemUgdGhpcyBzbGljZSB3b3VsZCBhZGQgd2hlbiBpbnNlcnRlZCBpbnRvIGEgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5zaXplIC0gdGhpcy5vcGVuU3RhcnQgLSB0aGlzLm9wZW5FbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW5zZXJ0QXQocG9zLCBmcmFnbWVudCkge1xuICAgICAgICBsZXQgY29udGVudCA9IGluc2VydEludG8odGhpcy5jb250ZW50LCBwb3MgKyB0aGlzLm9wZW5TdGFydCwgZnJhZ21lbnQpO1xuICAgICAgICByZXR1cm4gY29udGVudCAmJiBuZXcgU2xpY2UoY29udGVudCwgdGhpcy5vcGVuU3RhcnQsIHRoaXMub3BlbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVtb3ZlQmV0d2Vlbihmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKHJlbW92ZVJhbmdlKHRoaXMuY29udGVudCwgZnJvbSArIHRoaXMub3BlblN0YXJ0LCB0byArIHRoaXMub3BlblN0YXJ0KSwgdGhpcy5vcGVuU3RhcnQsIHRoaXMub3BlbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3RzIHdoZXRoZXIgdGhpcyBzbGljZSBpcyBlcXVhbCB0byBhbm90aGVyIHNsaWNlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5lcShvdGhlci5jb250ZW50KSAmJiB0aGlzLm9wZW5TdGFydCA9PSBvdGhlci5vcGVuU3RhcnQgJiYgdGhpcy5vcGVuRW5kID09IG90aGVyLm9wZW5FbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQgKyBcIihcIiArIHRoaXMub3BlblN0YXJ0ICsgXCIsXCIgKyB0aGlzLm9wZW5FbmQgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCBhIHNsaWNlIHRvIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGpzb24gPSB7IGNvbnRlbnQ6IHRoaXMuY29udGVudC50b0pTT04oKSB9O1xuICAgICAgICBpZiAodGhpcy5vcGVuU3RhcnQgPiAwKVxuICAgICAgICAgICAganNvbi5vcGVuU3RhcnQgPSB0aGlzLm9wZW5TdGFydDtcbiAgICAgICAgaWYgKHRoaXMub3BlbkVuZCA+IDApXG4gICAgICAgICAgICBqc29uLm9wZW5FbmQgPSB0aGlzLm9wZW5FbmQ7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIHNsaWNlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHJldHVybiBTbGljZS5lbXB0eTtcbiAgICAgICAgbGV0IG9wZW5TdGFydCA9IGpzb24ub3BlblN0YXJ0IHx8IDAsIG9wZW5FbmQgPSBqc29uLm9wZW5FbmQgfHwgMDtcbiAgICAgICAgaWYgKHR5cGVvZiBvcGVuU3RhcnQgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygb3BlbkVuZCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTbGljZS5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShGcmFnbWVudC5mcm9tSlNPTihzY2hlbWEsIGpzb24uY29udGVudCksIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNsaWNlIGZyb20gYSBmcmFnbWVudCBieSB0YWtpbmcgdGhlIG1heGltdW0gcG9zc2libGVcbiAgICBvcGVuIHZhbHVlIG9uIGJvdGggc2lkZSBvZiB0aGUgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgbWF4T3BlbihmcmFnbWVudCwgb3Blbklzb2xhdGluZyA9IHRydWUpIHtcbiAgICAgICAgbGV0IG9wZW5TdGFydCA9IDAsIG9wZW5FbmQgPSAwO1xuICAgICAgICBmb3IgKGxldCBuID0gZnJhZ21lbnQuZmlyc3RDaGlsZDsgbiAmJiAhbi5pc0xlYWYgJiYgKG9wZW5Jc29sYXRpbmcgfHwgIW4udHlwZS5zcGVjLmlzb2xhdGluZyk7IG4gPSBuLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgZm9yIChsZXQgbiA9IGZyYWdtZW50Lmxhc3RDaGlsZDsgbiAmJiAhbi5pc0xlYWYgJiYgKG9wZW5Jc29sYXRpbmcgfHwgIW4udHlwZS5zcGVjLmlzb2xhdGluZyk7IG4gPSBuLmxhc3RDaGlsZClcbiAgICAgICAgICAgIG9wZW5FbmQrKztcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShmcmFnbWVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICB9XG59XG4vKipcblRoZSBlbXB0eSBzbGljZS5cbiovXG5TbGljZS5lbXB0eSA9IG5ldyBTbGljZShGcmFnbWVudC5lbXB0eSwgMCwgMCk7XG5mdW5jdGlvbiByZW1vdmVSYW5nZShjb250ZW50LCBmcm9tLCB0bykge1xuICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IGNvbnRlbnQuZmluZEluZGV4KGZyb20pLCBjaGlsZCA9IGNvbnRlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgbGV0IHsgaW5kZXg6IGluZGV4VG8sIG9mZnNldDogb2Zmc2V0VG8gfSA9IGNvbnRlbnQuZmluZEluZGV4KHRvKTtcbiAgICBpZiAob2Zmc2V0ID09IGZyb20gfHwgY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgIGlmIChvZmZzZXRUbyAhPSB0byAmJiAhY29udGVudC5jaGlsZChpbmRleFRvKS5pc1RleHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJlbW92aW5nIG5vbi1mbGF0IHJhbmdlXCIpO1xuICAgICAgICByZXR1cm4gY29udGVudC5jdXQoMCwgZnJvbSkuYXBwZW5kKGNvbnRlbnQuY3V0KHRvKSk7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPSBpbmRleFRvKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJlbW92aW5nIG5vbi1mbGF0IHJhbmdlXCIpO1xuICAgIHJldHVybiBjb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgY2hpbGQuY29weShyZW1vdmVSYW5nZShjaGlsZC5jb250ZW50LCBmcm9tIC0gb2Zmc2V0IC0gMSwgdG8gLSBvZmZzZXQgLSAxKSkpO1xufVxuZnVuY3Rpb24gaW5zZXJ0SW50byhjb250ZW50LCBkaXN0LCBpbnNlcnQsIHBhcmVudCkge1xuICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IGNvbnRlbnQuZmluZEluZGV4KGRpc3QpLCBjaGlsZCA9IGNvbnRlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgaWYgKG9mZnNldCA9PSBkaXN0IHx8IGNoaWxkLmlzVGV4dCkge1xuICAgICAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXgsIGluc2VydCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQuY3V0KDAsIGRpc3QpLmFwcGVuZChpbnNlcnQpLmFwcGVuZChjb250ZW50LmN1dChkaXN0KSk7XG4gICAgfVxuICAgIGxldCBpbm5lciA9IGluc2VydEludG8oY2hpbGQuY29udGVudCwgZGlzdCAtIG9mZnNldCAtIDEsIGluc2VydCk7XG4gICAgcmV0dXJuIGlubmVyICYmIGNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBjaGlsZC5jb3B5KGlubmVyKSk7XG59XG5mdW5jdGlvbiByZXBsYWNlKCRmcm9tLCAkdG8sIHNsaWNlKSB7XG4gICAgaWYgKHNsaWNlLm9wZW5TdGFydCA+ICRmcm9tLmRlcHRoKVxuICAgICAgICB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiSW5zZXJ0ZWQgY29udGVudCBkZWVwZXIgdGhhbiBpbnNlcnRpb24gcG9zaXRpb25cIik7XG4gICAgaWYgKCRmcm9tLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0ICE9ICR0by5kZXB0aCAtIHNsaWNlLm9wZW5FbmQpXG4gICAgICAgIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbmNvbnNpc3RlbnQgb3BlbiBkZXB0aHNcIik7XG4gICAgcmV0dXJuIHJlcGxhY2VPdXRlcigkZnJvbSwgJHRvLCBzbGljZSwgMCk7XG59XG5mdW5jdGlvbiByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIGRlcHRoKSB7XG4gICAgbGV0IGluZGV4ID0gJGZyb20uaW5kZXgoZGVwdGgpLCBub2RlID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgaWYgKGluZGV4ID09ICR0by5pbmRleChkZXB0aCkgJiYgZGVwdGggPCAkZnJvbS5kZXB0aCAtIHNsaWNlLm9wZW5TdGFydCkge1xuICAgICAgICBsZXQgaW5uZXIgPSByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIGRlcHRoICsgMSk7XG4gICAgICAgIHJldHVybiBub2RlLmNvcHkobm9kZS5jb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgaW5uZXIpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXNsaWNlLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICByZXR1cm4gY2xvc2Uobm9kZSwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICghc2xpY2Uub3BlblN0YXJ0ICYmICFzbGljZS5vcGVuRW5kICYmICRmcm9tLmRlcHRoID09IGRlcHRoICYmICR0by5kZXB0aCA9PSBkZXB0aCkgeyAvLyBTaW1wbGUsIGZsYXQgY2FzZVxuICAgICAgICBsZXQgcGFyZW50ID0gJGZyb20ucGFyZW50LCBjb250ZW50ID0gcGFyZW50LmNvbnRlbnQ7XG4gICAgICAgIHJldHVybiBjbG9zZShwYXJlbnQsIGNvbnRlbnQuY3V0KDAsICRmcm9tLnBhcmVudE9mZnNldCkuYXBwZW5kKHNsaWNlLmNvbnRlbnQpLmFwcGVuZChjb250ZW50LmN1dCgkdG8ucGFyZW50T2Zmc2V0KSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcHJlcGFyZVNsaWNlRm9yUmVwbGFjZShzbGljZSwgJGZyb20pO1xuICAgICAgICByZXR1cm4gY2xvc2Uobm9kZSwgcmVwbGFjZVRocmVlV2F5KCRmcm9tLCBzdGFydCwgZW5kLCAkdG8sIGRlcHRoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tKb2luKG1haW4sIHN1Yikge1xuICAgIGlmICghc3ViLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQobWFpbi50eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkNhbm5vdCBqb2luIFwiICsgc3ViLnR5cGUubmFtZSArIFwiIG9udG8gXCIgKyBtYWluLnR5cGUubmFtZSk7XG59XG5mdW5jdGlvbiBqb2luYWJsZSgkYmVmb3JlLCAkYWZ0ZXIsIGRlcHRoKSB7XG4gICAgbGV0IG5vZGUgPSAkYmVmb3JlLm5vZGUoZGVwdGgpO1xuICAgIGNoZWNrSm9pbihub2RlLCAkYWZ0ZXIubm9kZShkZXB0aCkpO1xuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gYWRkTm9kZShjaGlsZCwgdGFyZ2V0KSB7XG4gICAgbGV0IGxhc3QgPSB0YXJnZXQubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA+PSAwICYmIGNoaWxkLmlzVGV4dCAmJiBjaGlsZC5zYW1lTWFya3VwKHRhcmdldFtsYXN0XSkpXG4gICAgICAgIHRhcmdldFtsYXN0XSA9IGNoaWxkLndpdGhUZXh0KHRhcmdldFtsYXN0XS50ZXh0ICsgY2hpbGQudGV4dCk7XG4gICAgZWxzZVxuICAgICAgICB0YXJnZXQucHVzaChjaGlsZCk7XG59XG5mdW5jdGlvbiBhZGRSYW5nZSgkc3RhcnQsICRlbmQsIGRlcHRoLCB0YXJnZXQpIHtcbiAgICBsZXQgbm9kZSA9ICgkZW5kIHx8ICRzdGFydCkubm9kZShkZXB0aCk7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSAwLCBlbmRJbmRleCA9ICRlbmQgPyAkZW5kLmluZGV4KGRlcHRoKSA6IG5vZGUuY2hpbGRDb3VudDtcbiAgICBpZiAoJHN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSAkc3RhcnQuaW5kZXgoZGVwdGgpO1xuICAgICAgICBpZiAoJHN0YXJ0LmRlcHRoID4gZGVwdGgpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgkc3RhcnQudGV4dE9mZnNldCkge1xuICAgICAgICAgICAgYWRkTm9kZSgkc3RhcnQubm9kZUFmdGVyLCB0YXJnZXQpO1xuICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKylcbiAgICAgICAgYWRkTm9kZShub2RlLmNoaWxkKGkpLCB0YXJnZXQpO1xuICAgIGlmICgkZW5kICYmICRlbmQuZGVwdGggPT0gZGVwdGggJiYgJGVuZC50ZXh0T2Zmc2V0KVxuICAgICAgICBhZGROb2RlKCRlbmQubm9kZUJlZm9yZSwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGNsb3NlKG5vZGUsIGNvbnRlbnQpIHtcbiAgICBub2RlLnR5cGUuY2hlY2tDb250ZW50KGNvbnRlbnQpO1xuICAgIHJldHVybiBub2RlLmNvcHkoY29udGVudCk7XG59XG5mdW5jdGlvbiByZXBsYWNlVGhyZWVXYXkoJGZyb20sICRzdGFydCwgJGVuZCwgJHRvLCBkZXB0aCkge1xuICAgIGxldCBvcGVuU3RhcnQgPSAkZnJvbS5kZXB0aCA+IGRlcHRoICYmIGpvaW5hYmxlKCRmcm9tLCAkc3RhcnQsIGRlcHRoICsgMSk7XG4gICAgbGV0IG9wZW5FbmQgPSAkdG8uZGVwdGggPiBkZXB0aCAmJiBqb2luYWJsZSgkZW5kLCAkdG8sIGRlcHRoICsgMSk7XG4gICAgbGV0IGNvbnRlbnQgPSBbXTtcbiAgICBhZGRSYW5nZShudWxsLCAkZnJvbSwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIGlmIChvcGVuU3RhcnQgJiYgb3BlbkVuZCAmJiAkc3RhcnQuaW5kZXgoZGVwdGgpID09ICRlbmQuaW5kZXgoZGVwdGgpKSB7XG4gICAgICAgIGNoZWNrSm9pbihvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICBhZGROb2RlKGNsb3NlKG9wZW5TdGFydCwgcmVwbGFjZVRocmVlV2F5KCRmcm9tLCAkc3RhcnQsICRlbmQsICR0bywgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9wZW5TdGFydClcbiAgICAgICAgICAgIGFkZE5vZGUoY2xvc2Uob3BlblN0YXJ0LCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkc3RhcnQsIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgICAgICAgYWRkUmFuZ2UoJHN0YXJ0LCAkZW5kLCBkZXB0aCwgY29udGVudCk7XG4gICAgICAgIGlmIChvcGVuRW5kKVxuICAgICAgICAgICAgYWRkTm9kZShjbG9zZShvcGVuRW5kLCByZXBsYWNlVHdvV2F5KCRlbmQsICR0bywgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgIH1cbiAgICBhZGRSYW5nZSgkdG8sIG51bGwsIGRlcHRoLCBjb250ZW50KTtcbiAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCkge1xuICAgIGxldCBjb250ZW50ID0gW107XG4gICAgYWRkUmFuZ2UobnVsbCwgJGZyb20sIGRlcHRoLCBjb250ZW50KTtcbiAgICBpZiAoJGZyb20uZGVwdGggPiBkZXB0aCkge1xuICAgICAgICBsZXQgdHlwZSA9IGpvaW5hYmxlKCRmcm9tLCAkdG8sIGRlcHRoICsgMSk7XG4gICAgICAgIGFkZE5vZGUoY2xvc2UodHlwZSwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgfVxuICAgIGFkZFJhbmdlKCR0bywgbnVsbCwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29udGVudCk7XG59XG5mdW5jdGlvbiBwcmVwYXJlU2xpY2VGb3JSZXBsYWNlKHNsaWNlLCAkYWxvbmcpIHtcbiAgICBsZXQgZXh0cmEgPSAkYWxvbmcuZGVwdGggLSBzbGljZS5vcGVuU3RhcnQsIHBhcmVudCA9ICRhbG9uZy5ub2RlKGV4dHJhKTtcbiAgICBsZXQgbm9kZSA9IHBhcmVudC5jb3B5KHNsaWNlLmNvbnRlbnQpO1xuICAgIGZvciAobGV0IGkgPSBleHRyYSAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBub2RlID0gJGFsb25nLm5vZGUoaSkuY29weShGcmFnbWVudC5mcm9tKG5vZGUpKTtcbiAgICByZXR1cm4geyBzdGFydDogbm9kZS5yZXNvbHZlTm9DYWNoZShzbGljZS5vcGVuU3RhcnQgKyBleHRyYSksXG4gICAgICAgIGVuZDogbm9kZS5yZXNvbHZlTm9DYWNoZShub2RlLmNvbnRlbnQuc2l6ZSAtIHNsaWNlLm9wZW5FbmQgLSBleHRyYSkgfTtcbn1cblxuLyoqXG5Zb3UgY2FuIFtfcmVzb2x2ZV9dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnJlc29sdmUpIGEgcG9zaXRpb24gdG8gZ2V0IG1vcmVcbmluZm9ybWF0aW9uIGFib3V0IGl0LiBPYmplY3RzIG9mIHRoaXMgY2xhc3MgcmVwcmVzZW50IHN1Y2ggYVxucmVzb2x2ZWQgcG9zaXRpb24sIHByb3ZpZGluZyB2YXJpb3VzIHBpZWNlcyBvZiBjb250ZXh0XG5pbmZvcm1hdGlvbiwgYW5kIHNvbWUgaGVscGVyIG1ldGhvZHMuXG5cblRocm91Z2hvdXQgdGhpcyBpbnRlcmZhY2UsIG1ldGhvZHMgdGhhdCB0YWtlIGFuIG9wdGlvbmFsIGBkZXB0aGBcbnBhcmFtZXRlciB3aWxsIGludGVycHJldCB1bmRlZmluZWQgYXMgYHRoaXMuZGVwdGhgIGFuZCBuZWdhdGl2ZVxubnVtYmVycyBhcyBgdGhpcy5kZXB0aCArIHZhbHVlYC5cbiovXG5jbGFzcyBSZXNvbHZlZFBvcyB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gdGhhdCB3YXMgcmVzb2x2ZWQuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcGF0aCwgXG4gICAgLyoqXG4gICAgVGhlIG9mZnNldCB0aGlzIHBvc2l0aW9uIGhhcyBpbnRvIGl0cyBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIHBhcmVudE9mZnNldCkge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5wYXJlbnRPZmZzZXQgPSBwYXJlbnRPZmZzZXQ7XG4gICAgICAgIHRoaXMuZGVwdGggPSBwYXRoLmxlbmd0aCAvIDMgLSAxO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc29sdmVEZXB0aCh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVwdGg7XG4gICAgICAgIGlmICh2YWwgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVwdGggKyB2YWw7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBwYXJlbnQgbm9kZSB0aGF0IHRoZSBwb3NpdGlvbiBwb2ludHMgaW50by4gTm90ZSB0aGF0IGV2ZW4gaWZcbiAgICBhIHBvc2l0aW9uIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCB0aGF0IG5vZGUgaXMgbm90IGNvbnNpZGVyZWRcbiAgICB0aGUgcGFyZW50XHUyMDE0dGV4dCBub2RlcyBhcmUgXHUyMDE4ZmxhdFx1MjAxOSBpbiB0aGlzIG1vZGVsLCBhbmQgaGF2ZSBubyBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHsgcmV0dXJuIHRoaXMubm9kZSh0aGlzLmRlcHRoKTsgfVxuICAgIC8qKlxuICAgIFRoZSByb290IG5vZGUgaW4gd2hpY2ggdGhlIHBvc2l0aW9uIHdhcyByZXNvbHZlZC5cbiAgICAqL1xuICAgIGdldCBkb2MoKSB7IHJldHVybiB0aGlzLm5vZGUoMCk7IH1cbiAgICAvKipcbiAgICBUaGUgYW5jZXN0b3Igbm9kZSBhdCB0aGUgZ2l2ZW4gbGV2ZWwuIGBwLm5vZGUocC5kZXB0aClgIGlzIHRoZVxuICAgIHNhbWUgYXMgYHAucGFyZW50YC5cbiAgICAqL1xuICAgIG5vZGUoZGVwdGgpIHsgcmV0dXJuIHRoaXMucGF0aFt0aGlzLnJlc29sdmVEZXB0aChkZXB0aCkgKiAzXTsgfVxuICAgIC8qKlxuICAgIFRoZSBpbmRleCBpbnRvIHRoZSBhbmNlc3RvciBhdCB0aGUgZ2l2ZW4gbGV2ZWwuIElmIHRoaXMgcG9pbnRzXG4gICAgYXQgdGhlIDNyZCBub2RlIGluIHRoZSAybmQgcGFyYWdyYXBoIG9uIHRoZSB0b3AgbGV2ZWwsIGZvclxuICAgIGV4YW1wbGUsIGBwLmluZGV4KDApYCBpcyAxIGFuZCBgcC5pbmRleCgxKWAgaXMgMi5cbiAgICAqL1xuICAgIGluZGV4KGRlcHRoKSB7IHJldHVybiB0aGlzLnBhdGhbdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpICogMyArIDFdOyB9XG4gICAgLyoqXG4gICAgVGhlIGluZGV4IHBvaW50aW5nIGFmdGVyIHRoaXMgcG9zaXRpb24gaW50byB0aGUgYW5jZXN0b3IgYXQgdGhlXG4gICAgZ2l2ZW4gbGV2ZWwuXG4gICAgKi9cbiAgICBpbmRleEFmdGVyKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleChkZXB0aCkgKyAoZGVwdGggPT0gdGhpcy5kZXB0aCAmJiAhdGhpcy50ZXh0T2Zmc2V0ID8gMCA6IDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuXG4gICAgbGV2ZWwuXG4gICAgKi9cbiAgICBzdGFydChkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIGRlcHRoID09IDAgPyAwIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW5cbiAgICBsZXZlbC5cbiAgICAqL1xuICAgIGVuZChkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQoZGVwdGgpICsgdGhpcy5ub2RlKGRlcHRoKS5jb250ZW50LnNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGRpcmVjdGx5IGJlZm9yZSB0aGUgd3JhcHBpbmcgbm9kZSBhdCB0aGVcbiAgICBnaXZlbiBsZXZlbCwgb3IsIHdoZW4gYGRlcHRoYCBpcyBgdGhpcy5kZXB0aCArIDFgLCB0aGUgb3JpZ2luYWxcbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGJlZm9yZShkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlcmUgaXMgbm8gcG9zaXRpb24gYmVmb3JlIHRoZSB0b3AtbGV2ZWwgbm9kZVwiKTtcbiAgICAgICAgcmV0dXJuIGRlcHRoID09IHRoaXMuZGVwdGggKyAxID8gdGhpcy5wb3MgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV07XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGRpcmVjdGx5IGFmdGVyIHRoZSB3cmFwcGluZyBub2RlIGF0IHRoZVxuICAgIGdpdmVuIGxldmVsLCBvciB0aGUgb3JpZ2luYWwgcG9zaXRpb24gd2hlbiBgZGVwdGhgIGlzIGB0aGlzLmRlcHRoICsgMWAuXG4gICAgKi9cbiAgICBhZnRlcihkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlcmUgaXMgbm8gcG9zaXRpb24gYWZ0ZXIgdGhlIHRvcC1sZXZlbCBub2RlXCIpO1xuICAgICAgICByZXR1cm4gZGVwdGggPT0gdGhpcy5kZXB0aCArIDEgPyB0aGlzLnBvcyA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIHRoaXMucGF0aFtkZXB0aCAqIDNdLm5vZGVTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGVuIHRoaXMgcG9zaXRpb24gcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIHRoaXMgcmV0dXJucyB0aGVcbiAgICBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb3NpdGlvbiBhbmQgdGhlIHN0YXJ0IG9mIHRoZSB0ZXh0IG5vZGUuXG4gICAgV2lsbCBiZSB6ZXJvIGZvciBwb3NpdGlvbnMgdGhhdCBwb2ludCBiZXR3ZWVuIG5vZGVzLlxuICAgICovXG4gICAgZ2V0IHRleHRPZmZzZXQoKSB7IHJldHVybiB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG5vZGUgZGlyZWN0bHkgYWZ0ZXIgdGhlIHBvc2l0aW9uLCBpZiBhbnkuIElmIHRoZSBwb3NpdGlvblxuICAgIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCBvbmx5IHRoZSBwYXJ0IG9mIHRoYXQgbm9kZSBhZnRlciB0aGVcbiAgICBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIGdldCBub2RlQWZ0ZXIoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudCwgaW5kZXggPSB0aGlzLmluZGV4KHRoaXMuZGVwdGgpO1xuICAgICAgICBpZiAoaW5kZXggPT0gcGFyZW50LmNoaWxkQ291bnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGRPZmYgPSB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV0sIGNoaWxkID0gcGFyZW50LmNoaWxkKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGRPZmYgPyBwYXJlbnQuY2hpbGQoaW5kZXgpLmN1dChkT2ZmKSA6IGNoaWxkO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG5vZGUgZGlyZWN0bHkgYmVmb3JlIHRoZSBwb3NpdGlvbiwgaWYgYW55LiBJZiB0aGVcbiAgICBwb3NpdGlvbiBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgb25seSB0aGUgcGFydCBvZiB0aGF0IG5vZGVcbiAgICBiZWZvcmUgdGhlIHBvc2l0aW9uIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgZ2V0IG5vZGVCZWZvcmUoKSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuaW5kZXgodGhpcy5kZXB0aCk7XG4gICAgICAgIGxldCBkT2ZmID0gdGhpcy5wb3MgLSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoZE9mZilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGlsZChpbmRleCkuY3V0KDAsIGRPZmYpO1xuICAgICAgICByZXR1cm4gaW5kZXggPT0gMCA/IG51bGwgOiB0aGlzLnBhcmVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBpbmRleCBpbiB0aGUgcGFyZW50IG5vZGUgYXQgdGhlXG4gICAgZ2l2ZW4gZGVwdGggKHdoaWNoIGRlZmF1bHRzIHRvIGB0aGlzLmRlcHRoYCkuXG4gICAgKi9cbiAgICBwb3NBdEluZGV4KGluZGV4LCBkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnBhdGhbZGVwdGggKiAzXSwgcG9zID0gZGVwdGggPT0gMCA/IDAgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV0gKyAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspXG4gICAgICAgICAgICBwb3MgKz0gbm9kZS5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBtYXJrcyBhdCB0aGlzIHBvc2l0aW9uLCBmYWN0b3JpbmcgaW4gdGhlIHN1cnJvdW5kaW5nXG4gICAgbWFya3MnIFtgaW5jbHVzaXZlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtTcGVjLmluY2x1c2l2ZSkgcHJvcGVydHkuIElmIHRoZVxuICAgIHBvc2l0aW9uIGlzIGF0IHRoZSBzdGFydCBvZiBhIG5vbi1lbXB0eSBub2RlLCB0aGUgbWFya3Mgb2YgdGhlXG4gICAgbm9kZSBhZnRlciBpdCAoaWYgYW55KSBhcmUgcmV0dXJuZWQuXG4gICAgKi9cbiAgICBtYXJrcygpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50LCBpbmRleCA9IHRoaXMuaW5kZXgoKTtcbiAgICAgICAgLy8gSW4gYW4gZW1wdHkgcGFyZW50LCByZXR1cm4gdGhlIGVtcHR5IGFycmF5XG4gICAgICAgIGlmIChwYXJlbnQuY29udGVudC5zaXplID09IDApXG4gICAgICAgICAgICByZXR1cm4gTWFyay5ub25lO1xuICAgICAgICAvLyBXaGVuIGluc2lkZSBhIHRleHQgbm9kZSwganVzdCByZXR1cm4gdGhlIHRleHQgbm9kZSdzIG1hcmtzXG4gICAgICAgIGlmICh0aGlzLnRleHRPZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LmNoaWxkKGluZGV4KS5tYXJrcztcbiAgICAgICAgbGV0IG1haW4gPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCAtIDEpLCBvdGhlciA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgLy8gSWYgdGhlIGBhZnRlcmAgZmxhZyBpcyB0cnVlIG9mIHRoZXJlIGlzIG5vIG5vZGUgYmVmb3JlLCBtYWtlXG4gICAgICAgIC8vIHRoZSBub2RlIGFmdGVyIHRoaXMgcG9zaXRpb24gdGhlIG1haW4gcmVmZXJlbmNlLlxuICAgICAgICBpZiAoIW1haW4pIHtcbiAgICAgICAgICAgIGxldCB0bXAgPSBtYWluO1xuICAgICAgICAgICAgbWFpbiA9IG90aGVyO1xuICAgICAgICAgICAgb3RoZXIgPSB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGFsbCBtYXJrcyBpbiB0aGUgbWFpbiBub2RlLCBleGNlcHQgdGhvc2UgdGhhdCBoYXZlXG4gICAgICAgIC8vIGBpbmNsdXNpdmVgIHNldCB0byBmYWxzZSBhbmQgYXJlIG5vdCBwcmVzZW50IGluIHRoZSBvdGhlciBub2RlLlxuICAgICAgICBsZXQgbWFya3MgPSBtYWluLm1hcmtzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG1hcmtzW2ldLnR5cGUuc3BlYy5pbmNsdXNpdmUgPT09IGZhbHNlICYmICghb3RoZXIgfHwgIW1hcmtzW2ldLmlzSW5TZXQob3RoZXIubWFya3MpKSlcbiAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzW2ktLV0ucmVtb3ZlRnJvbVNldChtYXJrcyk7XG4gICAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBtYXJrcyBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbiwgaWYgYW55LCBleGNlcHQgdGhvc2VcbiAgICB0aGF0IGFyZSBub24taW5jbHVzaXZlIGFuZCBub3QgcHJlc2VudCBhdCBwb3NpdGlvbiBgJGVuZGAuIFRoaXNcbiAgICBpcyBtb3N0bHkgdXNlZnVsIGZvciBnZXR0aW5nIHRoZSBzZXQgb2YgbWFya3MgdG8gcHJlc2VydmUgYWZ0ZXIgYVxuICAgIGRlbGV0aW9uLiBXaWxsIHJldHVybiBgbnVsbGAgaWYgdGhpcyBwb3NpdGlvbiBpcyBhdCB0aGUgZW5kIG9mXG4gICAgaXRzIHBhcmVudCBub2RlIG9yIGl0cyBwYXJlbnQgbm9kZSBpc24ndCBhIHRleHRibG9jayAoaW4gd2hpY2hcbiAgICBjYXNlIG5vIG1hcmtzIHNob3VsZCBiZSBwcmVzZXJ2ZWQpLlxuICAgICovXG4gICAgbWFya3NBY3Jvc3MoJGVuZCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLnBhcmVudC5tYXliZUNoaWxkKHRoaXMuaW5kZXgoKSk7XG4gICAgICAgIGlmICghYWZ0ZXIgfHwgIWFmdGVyLmlzSW5saW5lKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBtYXJrcyA9IGFmdGVyLm1hcmtzLCBuZXh0ID0gJGVuZC5wYXJlbnQubWF5YmVDaGlsZCgkZW5kLmluZGV4KCkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG1hcmtzW2ldLnR5cGUuc3BlYy5pbmNsdXNpdmUgPT09IGZhbHNlICYmICghbmV4dCB8fCAhbWFya3NbaV0uaXNJblNldChuZXh0Lm1hcmtzKSkpXG4gICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrc1tpLS1dLnJlbW92ZUZyb21TZXQobWFya3MpO1xuICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBkZXB0aCB1cCB0byB3aGljaCB0aGlzIHBvc2l0aW9uIGFuZCB0aGUgZ2l2ZW4gKG5vbi1yZXNvbHZlZClcbiAgICBwb3NpdGlvbiBzaGFyZSB0aGUgc2FtZSBwYXJlbnQgbm9kZXMuXG4gICAgKi9cbiAgICBzaGFyZWREZXB0aChwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSB0aGlzLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoLS0pXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydChkZXB0aCkgPD0gcG9zICYmIHRoaXMuZW5kKGRlcHRoKSA+PSBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIHJhbmdlIGJhc2VkIG9uIHRoZSBwbGFjZSB3aGVyZSB0aGlzIHBvc2l0aW9uIGFuZCB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbiBkaXZlcmdlIGFyb3VuZCBibG9jayBjb250ZW50LiBJZiBib3RoIHBvaW50IGludG9cbiAgICB0aGUgc2FtZSB0ZXh0YmxvY2ssIGZvciBleGFtcGxlLCBhIHJhbmdlIGFyb3VuZCB0aGF0IHRleHRibG9ja1xuICAgIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZXkgcG9pbnQgaW50byBkaWZmZXJlbnQgYmxvY2tzLCB0aGUgcmFuZ2VcbiAgICBhcm91bmQgdGhvc2UgYmxvY2tzIGluIHRoZWlyIHNoYXJlZCBhbmNlc3RvciBpcyByZXR1cm5lZC4gWW91IGNhblxuICAgIHBhc3MgaW4gYW4gb3B0aW9uYWwgcHJlZGljYXRlIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHBhcmVudFxuICAgIG5vZGUgdG8gc2VlIGlmIGEgcmFuZ2UgaW50byB0aGF0IHBhcmVudCBpcyBhY2NlcHRhYmxlLlxuICAgICovXG4gICAgYmxvY2tSYW5nZShvdGhlciA9IHRoaXMsIHByZWQpIHtcbiAgICAgICAgaWYgKG90aGVyLnBvcyA8IHRoaXMucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG90aGVyLmJsb2NrUmFuZ2UodGhpcyk7XG4gICAgICAgIGZvciAobGV0IGQgPSB0aGlzLmRlcHRoIC0gKHRoaXMucGFyZW50LmlubGluZUNvbnRlbnQgfHwgdGhpcy5wb3MgPT0gb3RoZXIucG9zID8gMSA6IDApOyBkID49IDA7IGQtLSlcbiAgICAgICAgICAgIGlmIChvdGhlci5wb3MgPD0gdGhpcy5lbmQoZCkgJiYgKCFwcmVkIHx8IHByZWQodGhpcy5ub2RlKGQpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2RlUmFuZ2UodGhpcywgb3RoZXIsIGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgUXVlcnkgd2hldGhlciB0aGUgZ2l2ZW4gcG9zaXRpb24gc2hhcmVzIHRoZSBzYW1lIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgc2FtZVBhcmVudChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgLSB0aGlzLnBhcmVudE9mZnNldCA9PSBvdGhlci5wb3MgLSBvdGhlci5wYXJlbnRPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgZ3JlYXRlciBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBtYXgob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLnBvcyA+IHRoaXMucG9zID8gb3RoZXIgOiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIHNtYWxsZXIgb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbWluKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlci5wb3MgPCB0aGlzLnBvcyA/IG90aGVyIDogdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHRoaXMuZGVwdGg7IGkrKylcbiAgICAgICAgICAgIHN0ciArPSAoc3RyID8gXCIvXCIgOiBcIlwiKSArIHRoaXMubm9kZShpKS50eXBlLm5hbWUgKyBcIl9cIiArIHRoaXMuaW5kZXgoaSAtIDEpO1xuICAgICAgICByZXR1cm4gc3RyICsgXCI6XCIgKyB0aGlzLnBhcmVudE9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgcmVzb2x2ZShkb2MsIHBvcykge1xuICAgICAgICBpZiAoIShwb3MgPj0gMCAmJiBwb3MgPD0gZG9jLmNvbnRlbnQuc2l6ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlBvc2l0aW9uIFwiICsgcG9zICsgXCIgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICBsZXQgcGF0aCA9IFtdO1xuICAgICAgICBsZXQgc3RhcnQgPSAwLCBwYXJlbnRPZmZzZXQgPSBwb3M7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSBkb2M7Oykge1xuICAgICAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChwYXJlbnRPZmZzZXQpO1xuICAgICAgICAgICAgbGV0IHJlbSA9IHBhcmVudE9mZnNldCAtIG9mZnNldDtcbiAgICAgICAgICAgIHBhdGgucHVzaChub2RlLCBpbmRleCwgc3RhcnQgKyBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCFyZW0pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZChpbmRleCk7XG4gICAgICAgICAgICBpZiAobm9kZS5pc1RleHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwYXJlbnRPZmZzZXQgPSByZW0gLSAxO1xuICAgICAgICAgICAgc3RhcnQgKz0gb2Zmc2V0ICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkUG9zKHBvcywgcGF0aCwgcGFyZW50T2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgcmVzb2x2ZUNhY2hlZChkb2MsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc29sdmVDYWNoZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNhY2hlZCA9IHJlc29sdmVDYWNoZVtpXTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQucG9zID09IHBvcyAmJiBjYWNoZWQuZG9jID09IGRvYylcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSByZXNvbHZlQ2FjaGVbcmVzb2x2ZUNhY2hlUG9zXSA9IFJlc29sdmVkUG9zLnJlc29sdmUoZG9jLCBwb3MpO1xuICAgICAgICByZXNvbHZlQ2FjaGVQb3MgPSAocmVzb2x2ZUNhY2hlUG9zICsgMSkgJSByZXNvbHZlQ2FjaGVTaXplO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmxldCByZXNvbHZlQ2FjaGUgPSBbXSwgcmVzb2x2ZUNhY2hlUG9zID0gMCwgcmVzb2x2ZUNhY2hlU2l6ZSA9IDEyO1xuLyoqXG5SZXByZXNlbnRzIGEgZmxhdCByYW5nZSBvZiBjb250ZW50LCBpLmUuIG9uZSB0aGF0IHN0YXJ0cyBhbmRcbmVuZHMgaW4gdGhlIHNhbWUgbm9kZS5cbiovXG5jbGFzcyBOb2RlUmFuZ2Uge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIG5vZGUgcmFuZ2UuIGAkZnJvbWAgYW5kIGAkdG9gIHNob3VsZCBwb2ludCBpbnRvIHRoZVxuICAgIHNhbWUgbm9kZSB1bnRpbCBhdCBsZWFzdCB0aGUgZ2l2ZW4gYGRlcHRoYCwgc2luY2UgYSBub2RlIHJhbmdlXG4gICAgZGVub3RlcyBhbiBhZGphY2VudCBzZXQgb2Ygbm9kZXMgaW4gYSBzaW5nbGUgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBBIHJlc29sdmVkIHBvc2l0aW9uIGFsb25nIHRoZSBzdGFydCBvZiB0aGUgY29udGVudC4gTWF5IGhhdmUgYVxuICAgIGBkZXB0aGAgZ3JlYXRlciB0aGFuIHRoaXMgb2JqZWN0J3MgYGRlcHRoYCBwcm9wZXJ0eSwgc2luY2VcbiAgICB0aGVzZSBhcmUgdGhlIHBvc2l0aW9ucyB0aGF0IHdlcmUgdXNlZCB0byBjb21wdXRlIHRoZSByYW5nZSxcbiAgICBub3QgcmUtcmVzb2x2ZWQgcG9zaXRpb25zIGRpcmVjdGx5IGF0IGl0cyBib3VuZGFyaWVzLlxuICAgICovXG4gICAgJGZyb20sIFxuICAgIC8qKlxuICAgIEEgcG9zaXRpb24gYWxvbmcgdGhlIGVuZCBvZiB0aGUgY29udGVudC4gU2VlXG4gICAgY2F2ZWF0IGZvciBbYCRmcm9tYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVSYW5nZS4kZnJvbSkuXG4gICAgKi9cbiAgICAkdG8sIFxuICAgIC8qKlxuICAgIFRoZSBkZXB0aCBvZiB0aGUgbm9kZSB0aGF0IHRoaXMgcmFuZ2UgcG9pbnRzIGludG8uXG4gICAgKi9cbiAgICBkZXB0aCkge1xuICAgICAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgICAgIHRoaXMuJHRvID0gJHRvO1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy4kZnJvbS5iZWZvcmUodGhpcy5kZXB0aCArIDEpOyB9XG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuJHRvLmFmdGVyKHRoaXMuZGVwdGggKyAxKTsgfVxuICAgIC8qKlxuICAgIFRoZSBwYXJlbnQgbm9kZSB0aGF0IHRoZSByYW5nZSBwb2ludHMgaW50by5cbiAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7IHJldHVybiB0aGlzLiRmcm9tLm5vZGUodGhpcy5kZXB0aCk7IH1cbiAgICAvKipcbiAgICBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIHJhbmdlIGluIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBzdGFydEluZGV4KCkgeyByZXR1cm4gdGhpcy4kZnJvbS5pbmRleCh0aGlzLmRlcHRoKTsgfVxuICAgIC8qKlxuICAgIFRoZSBlbmQgaW5kZXggb2YgdGhlIHJhbmdlIGluIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBlbmRJbmRleCgpIHsgcmV0dXJuIHRoaXMuJHRvLmluZGV4QWZ0ZXIodGhpcy5kZXB0aCk7IH1cbn1cblxuY29uc3QgZW1wdHlBdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcblRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIG5vZGUgaW4gdGhlIHRyZWUgdGhhdCBtYWtlcyB1cCBhXG5Qcm9zZU1pcnJvciBkb2N1bWVudC4gU28gYSBkb2N1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBgTm9kZWAsIHdpdGhcbmNoaWxkcmVuIHRoYXQgYXJlIGFsc28gaW5zdGFuY2VzIG9mIGBOb2RlYC5cblxuTm9kZXMgYXJlIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmVzLiBJbnN0ZWFkIG9mIGNoYW5naW5nIHRoZW0sIHlvdVxuY3JlYXRlIG5ldyBvbmVzIHdpdGggdGhlIGNvbnRlbnQgeW91IHdhbnQuIE9sZCBvbmVzIGtlZXAgcG9pbnRpbmdcbmF0IHRoZSBvbGQgZG9jdW1lbnQgc2hhcGUuIFRoaXMgaXMgbWFkZSBjaGVhcGVyIGJ5IHNoYXJpbmdcbnN0cnVjdHVyZSBiZXR3ZWVuIHRoZSBvbGQgYW5kIG5ldyBkYXRhIGFzIG11Y2ggYXMgcG9zc2libGUsIHdoaWNoIGFcbnRyZWUgc2hhcGUgbGlrZSB0aGlzICh3aXRob3V0IGJhY2sgcG9pbnRlcnMpIG1ha2VzIGVhc3kuXG5cbioqRG8gbm90KiogZGlyZWN0bHkgbXV0YXRlIHRoZSBwcm9wZXJ0aWVzIG9mIGEgYE5vZGVgIG9iamVjdC4gU2VlXG5bdGhlIGd1aWRlXSgvZG9jcy9ndWlkZS8jZG9jKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiovXG5jbGFzcyBOb2RlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIG5vZGUgdGhhdCB0aGlzIGlzLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgQW4gb2JqZWN0IG1hcHBpbmcgYXR0cmlidXRlIG5hbWVzIHRvIHZhbHVlcy4gVGhlIGtpbmQgb2ZcbiAgICBhdHRyaWJ1dGVzIGFsbG93ZWQgYW5kIHJlcXVpcmVkIGFyZVxuICAgIFtkZXRlcm1pbmVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuYXR0cnMpIGJ5IHRoZSBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBhdHRycywgXG4gICAgLy8gQSBmcmFnbWVudCBob2xkaW5nIHRoZSBub2RlJ3MgY2hpbGRyZW4uXG4gICAgY29udGVudCwgXG4gICAgLyoqXG4gICAgVGhlIG1hcmtzICh0aGluZ3MgbGlrZSB3aGV0aGVyIGl0IGlzIGVtcGhhc2l6ZWQgb3IgcGFydCBvZiBhXG4gICAgbGluaykgYXBwbGllZCB0byB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBtYXJrcyA9IE1hcmsubm9uZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudCB8fCBGcmFnbWVudC5lbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNpemUgb2YgdGhpcyBub2RlLCBhcyBkZWZpbmVkIGJ5IHRoZSBpbnRlZ2VyLWJhc2VkIFtpbmRleGluZ1xuICAgIHNjaGVtZV0oL2RvY3MvZ3VpZGUvI2RvYy5pbmRleGluZykuIEZvciB0ZXh0IG5vZGVzLCB0aGlzIGlzIHRoZVxuICAgIGFtb3VudCBvZiBjaGFyYWN0ZXJzLiBGb3Igb3RoZXIgbGVhZiBub2RlcywgaXQgaXMgb25lLiBGb3JcbiAgICBub24tbGVhZiBub2RlcywgaXQgaXMgdGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgcGx1cyB0d28gKHRoZVxuICAgIHN0YXJ0IGFuZCBlbmQgdG9rZW4pLlxuICAgICovXG4gICAgZ2V0IG5vZGVTaXplKCkgeyByZXR1cm4gdGhpcy5pc0xlYWYgPyAxIDogMiArIHRoaXMuY29udGVudC5zaXplOyB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IHRoZSBub2RlIGhhcy5cbiAgICAqL1xuICAgIGdldCBjaGlsZENvdW50KCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmNoaWxkQ291bnQ7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LiBSYWlzZXMgYW4gZXJyb3Igd2hlbiB0aGVcbiAgICBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgKi9cbiAgICBjaGlsZChpbmRleCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmNoaWxkKGluZGV4KTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIGl0IGV4aXN0cy5cbiAgICAqL1xuICAgIG1heWJlQ2hpbGQoaW5kZXgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5tYXliZUNoaWxkKGluZGV4KTsgfVxuICAgIC8qKlxuICAgIENhbGwgYGZgIGZvciBldmVyeSBjaGlsZCBub2RlLCBwYXNzaW5nIHRoZSBub2RlLCBpdHMgb2Zmc2V0XG4gICAgaW50byB0aGlzIHBhcmVudCBub2RlLCBhbmQgaXRzIGluZGV4LlxuICAgICovXG4gICAgZm9yRWFjaChmKSB7IHRoaXMuY29udGVudC5mb3JFYWNoKGYpOyB9XG4gICAgLyoqXG4gICAgSW52b2tlIGEgY2FsbGJhY2sgZm9yIGFsbCBkZXNjZW5kYW50IG5vZGVzIHJlY3Vyc2l2ZWx5IGJldHdlZW5cbiAgICB0aGUgZ2l2ZW4gdHdvIHBvc2l0aW9ucyB0aGF0IGFyZSByZWxhdGl2ZSB0byBzdGFydCBvZiB0aGlzXG4gICAgbm9kZSdzIGNvbnRlbnQuIFRoZSBjYWxsYmFjayBpcyBpbnZva2VkIHdpdGggdGhlIG5vZGUsIGl0c1xuICAgIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW5hbCBub2RlIChtZXRob2QgcmVjZWl2ZXIpLFxuICAgIGl0cyBwYXJlbnQgbm9kZSwgYW5kIGl0cyBjaGlsZCBpbmRleC4gV2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJuc1xuICAgIGZhbHNlIGZvciBhIGdpdmVuIG5vZGUsIHRoYXQgbm9kZSdzIGNoaWxkcmVuIHdpbGwgbm90IGJlXG4gICAgcmVjdXJzZWQgb3Zlci4gVGhlIGxhc3QgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgYVxuICAgIHN0YXJ0aW5nIHBvc2l0aW9uIHRvIGNvdW50IGZyb20uXG4gICAgKi9cbiAgICBub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYsIHN0YXJ0UG9zID0gMCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmLCBzdGFydFBvcywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBldmVyeSBkZXNjZW5kYW50IG5vZGUuIERvZXNuJ3RcbiAgICBkZXNjZW5kIGludG8gYSBub2RlIHdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYC5cbiAgICAqL1xuICAgIGRlc2NlbmRhbnRzKGYpIHtcbiAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oMCwgdGhpcy5jb250ZW50LnNpemUsIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb25jYXRlbmF0ZXMgYWxsIHRoZSB0ZXh0IG5vZGVzIGZvdW5kIGluIHRoaXMgZnJhZ21lbnQgYW5kIGl0c1xuICAgIGNoaWxkcmVuLlxuICAgICovXG4gICAgZ2V0IHRleHRDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaXNMZWFmICYmIHRoaXMudHlwZS5zcGVjLmxlYWZUZXh0KVxuICAgICAgICAgICAgPyB0aGlzLnR5cGUuc3BlYy5sZWFmVGV4dCh0aGlzKVxuICAgICAgICAgICAgOiB0aGlzLnRleHRCZXR3ZWVuKDAsIHRoaXMuY29udGVudC5zaXplLCBcIlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGFsbCB0ZXh0IGJldHdlZW4gcG9zaXRpb25zIGBmcm9tYCBhbmQgYHRvYC4gV2hlblxuICAgIGBibG9ja1NlcGFyYXRvcmAgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgaW5zZXJ0ZWQgdG8gc2VwYXJhdGUgdGV4dFxuICAgIGZyb20gZGlmZmVyZW50IGJsb2NrIG5vZGVzLiBJZiBgbGVhZlRleHRgIGlzIGdpdmVuLCBpdCdsbCBiZVxuICAgIGluc2VydGVkIGZvciBldmVyeSBub24tdGV4dCBsZWFmIG5vZGUgZW5jb3VudGVyZWQsIG90aGVyd2lzZVxuICAgIFtgbGVhZlRleHRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWNebGVhZlRleHQpIHdpbGwgYmUgdXNlZC5cbiAgICAqL1xuICAgIHRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC50ZXh0QmV0d2Vlbihmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGlzIG5vZGUncyBmaXJzdCBjaGlsZCwgb3IgYG51bGxgIGlmIHRoZXJlIGFyZSBub1xuICAgIGNoaWxkcmVuLlxuICAgICovXG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuZmlyc3RDaGlsZDsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhpcyBub2RlJ3MgbGFzdCBjaGlsZCwgb3IgYG51bGxgIGlmIHRoZXJlIGFyZSBub1xuICAgIGNoaWxkcmVuLlxuICAgICovXG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sYXN0Q2hpbGQ7IH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdHdvIG5vZGVzIHJlcHJlc2VudCB0aGUgc2FtZSBwaWVjZSBvZiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8ICh0aGlzLnNhbWVNYXJrdXAob3RoZXIpICYmIHRoaXMuY29udGVudC5lcShvdGhlci5jb250ZW50KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhlIG1hcmt1cCAodHlwZSwgYXR0cmlidXRlcywgYW5kIG1hcmtzKSBvZiB0aGlzIG5vZGUgdG9cbiAgICB0aG9zZSBvZiBhbm90aGVyLiBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGhhdmUgdGhlIHNhbWUgbWFya3VwLlxuICAgICovXG4gICAgc2FtZU1hcmt1cChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNNYXJrdXAob3RoZXIudHlwZSwgb3RoZXIuYXR0cnMsIG90aGVyLm1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGlzIG5vZGUncyBtYXJrdXAgY29ycmVzcG9uZCB0byB0aGUgZ2l2ZW4gdHlwZSxcbiAgICBhdHRyaWJ1dGVzLCBhbmQgbWFya3MuXG4gICAgKi9cbiAgICBoYXNNYXJrdXAodHlwZSwgYXR0cnMsIG1hcmtzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gdHlwZSAmJlxuICAgICAgICAgICAgY29tcGFyZURlZXAodGhpcy5hdHRycywgYXR0cnMgfHwgdHlwZS5kZWZhdWx0QXR0cnMgfHwgZW1wdHlBdHRycykgJiZcbiAgICAgICAgICAgIE1hcmsuc2FtZVNldCh0aGlzLm1hcmtzLCBtYXJrcyB8fCBNYXJrLm5vbmUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgbm9kZSB3aXRoIHRoZSBzYW1lIG1hcmt1cCBhcyB0aGlzIG5vZGUsIGNvbnRhaW5pbmdcbiAgICB0aGUgZ2l2ZW4gY29udGVudCAob3IgZW1wdHksIGlmIG5vIGNvbnRlbnQgaXMgZ2l2ZW4pLlxuICAgICovXG4gICAgY29weShjb250ZW50ID0gbnVsbCkge1xuICAgICAgICBpZiAoY29udGVudCA9PSB0aGlzLmNvbnRlbnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgY29udGVudCwgdGhpcy5tYXJrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBub2RlLCB3aXRoIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MgaW5zdGVhZFxuICAgIG9mIHRoZSBub2RlJ3Mgb3duIG1hcmtzLlxuICAgICovXG4gICAgbWFyayhtYXJrcykge1xuICAgICAgICByZXR1cm4gbWFya3MgPT0gdGhpcy5tYXJrcyA/IHRoaXMgOiBuZXcgTm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRoaXMuY29udGVudCwgbWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgbm9kZSB3aXRoIG9ubHkgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbnMuIElmIGB0b2AgaXMgbm90IGdpdmVuLCBpdCBkZWZhdWx0cyB0byB0aGUgZW5kIG9mXG4gICAgdGhlIG5vZGUuXG4gICAgKi9cbiAgICBjdXQoZnJvbSwgdG8gPSB0aGlzLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkodGhpcy5jb250ZW50LmN1dChmcm9tLCB0bykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDdXQgb3V0IHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMsIGFuZFxuICAgIHJldHVybiBpdCBhcyBhIGBTbGljZWAgb2JqZWN0LlxuICAgICovXG4gICAgc2xpY2UoZnJvbSwgdG8gPSB0aGlzLmNvbnRlbnQuc2l6ZSwgaW5jbHVkZVBhcmVudHMgPSBmYWxzZSkge1xuICAgICAgICBpZiAoZnJvbSA9PSB0bylcbiAgICAgICAgICAgIHJldHVybiBTbGljZS5lbXB0eTtcbiAgICAgICAgbGV0ICRmcm9tID0gdGhpcy5yZXNvbHZlKGZyb20pLCAkdG8gPSB0aGlzLnJlc29sdmUodG8pO1xuICAgICAgICBsZXQgZGVwdGggPSBpbmNsdWRlUGFyZW50cyA/IDAgOiAkZnJvbS5zaGFyZWREZXB0aCh0byk7XG4gICAgICAgIGxldCBzdGFydCA9ICRmcm9tLnN0YXJ0KGRlcHRoKSwgbm9kZSA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgICAgICBsZXQgY29udGVudCA9IG5vZGUuY29udGVudC5jdXQoJGZyb20ucG9zIC0gc3RhcnQsICR0by5wb3MgLSBzdGFydCk7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoY29udGVudCwgJGZyb20uZGVwdGggLSBkZXB0aCwgJHRvLmRlcHRoIC0gZGVwdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMgd2l0aFxuICAgIHRoZSBnaXZlbiBzbGljZS4gVGhlIHNsaWNlIG11c3QgJ2ZpdCcsIG1lYW5pbmcgaXRzIG9wZW4gc2lkZXNcbiAgICBtdXN0IGJlIGFibGUgdG8gY29ubmVjdCB0byB0aGUgc3Vycm91bmRpbmcgY29udGVudCwgYW5kIGl0c1xuICAgIGNvbnRlbnQgbm9kZXMgbXVzdCBiZSB2YWxpZCBjaGlsZHJlbiBmb3IgdGhlIG5vZGUgdGhleSBhcmUgcGxhY2VkXG4gICAgaW50by4gSWYgYW55IG9mIHRoaXMgaXMgdmlvbGF0ZWQsIGFuIGVycm9yIG9mIHR5cGVcbiAgICBbYFJlcGxhY2VFcnJvcmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5SZXBsYWNlRXJyb3IpIGlzIHRocm93bi5cbiAgICAqL1xuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlKHRoaXMucmVzb2x2ZShmcm9tKSwgdGhpcy5yZXNvbHZlKHRvKSwgc2xpY2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBub2RlIGRpcmVjdGx5IGFmdGVyIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIG5vZGVBdChwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHRoaXM7Oykge1xuICAgICAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChwb3MpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IHBvcyB8fCBub2RlLmlzVGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIHBvcyAtPSBvZmZzZXQgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIChkaXJlY3QpIGNoaWxkIG5vZGUgYWZ0ZXIgdGhlIGdpdmVuIG9mZnNldCwgaWYgYW55LFxuICAgIGFuZCByZXR1cm4gaXQgYWxvbmcgd2l0aCBpdHMgaW5kZXggYW5kIG9mZnNldCByZWxhdGl2ZSB0byB0aGlzXG4gICAgbm9kZS5cbiAgICAqL1xuICAgIGNoaWxkQWZ0ZXIocG9zKSB7XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IHRoaXMuY29udGVudC5maW5kSW5kZXgocG9zKTtcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpLCBpbmRleCwgb2Zmc2V0IH07XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIChkaXJlY3QpIGNoaWxkIG5vZGUgYmVmb3JlIHRoZSBnaXZlbiBvZmZzZXQsIGlmIGFueSxcbiAgICBhbmQgcmV0dXJuIGl0IGFsb25nIHdpdGggaXRzIGluZGV4IGFuZCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhpc1xuICAgIG5vZGUuXG4gICAgKi9cbiAgICBjaGlsZEJlZm9yZShwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogbnVsbCwgaW5kZXg6IDAsIG9mZnNldDogMCB9O1xuICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSB0aGlzLmNvbnRlbnQuZmluZEluZGV4KHBvcyk7XG4gICAgICAgIGlmIChvZmZzZXQgPCBwb3MpXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnQuY2hpbGQoaW5kZXgpLCBpbmRleCwgb2Zmc2V0IH07XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5jb250ZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgIHJldHVybiB7IG5vZGUsIGluZGV4OiBpbmRleCAtIDEsIG9mZnNldDogb2Zmc2V0IC0gbm9kZS5ub2RlU2l6ZSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBSZXNvbHZlIHRoZSBnaXZlbiBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQsIHJldHVybmluZyBhblxuICAgIFtvYmplY3RdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5SZXNvbHZlZFBvcykgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCBpdHMgY29udGV4dC5cbiAgICAqL1xuICAgIHJlc29sdmUocG9zKSB7IHJldHVybiBSZXNvbHZlZFBvcy5yZXNvbHZlQ2FjaGVkKHRoaXMsIHBvcyk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc29sdmVOb0NhY2hlKHBvcykgeyByZXR1cm4gUmVzb2x2ZWRQb3MucmVzb2x2ZSh0aGlzLCBwb3MpOyB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gbWFyayBvciBtYXJrIHR5cGUgb2NjdXJzIGluIHRoaXMgZG9jdW1lbnRcbiAgICBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gcG9zaXRpb25zLlxuICAgICovXG4gICAgcmFuZ2VIYXNNYXJrKGZyb20sIHRvLCB0eXBlKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBpZiAodG8gPiBmcm9tKVxuICAgICAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLmlzSW5TZXQobm9kZS5tYXJrcykpXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWZvdW5kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSBibG9jayAobm9uLWlubGluZSBub2RlKVxuICAgICovXG4gICAgZ2V0IGlzQmxvY2soKSB7IHJldHVybiB0aGlzLnR5cGUuaXNCbG9jazsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGEgdGV4dGJsb2NrIG5vZGUsIGEgYmxvY2sgbm9kZSB3aXRoIGlubGluZVxuICAgIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaXNUZXh0YmxvY2soKSB7IHJldHVybiB0aGlzLnR5cGUuaXNUZXh0YmxvY2s7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBub2RlIGFsbG93cyBpbmxpbmUgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpbmxpbmVDb250ZW50KCkgeyByZXR1cm4gdGhpcy50eXBlLmlubGluZUNvbnRlbnQ7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhbiBpbmxpbmUgbm9kZSAoYSB0ZXh0IG5vZGUgb3IgYSBub2RlIHRoYXQgY2FuXG4gICAgYXBwZWFyIGFtb25nIHRleHQpLlxuICAgICovXG4gICAgZ2V0IGlzSW5saW5lKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzSW5saW5lOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSB0ZXh0IG5vZGUuXG4gICAgKi9cbiAgICBnZXQgaXNUZXh0KCkgeyByZXR1cm4gdGhpcy50eXBlLmlzVGV4dDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGEgbGVhZiBub2RlLlxuICAgICovXG4gICAgZ2V0IGlzTGVhZigpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0xlYWY7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhbiBhdG9tLCBpLmUuIHdoZW4gaXQgZG9lcyBub3QgaGF2ZSBkaXJlY3RseVxuICAgIGVkaXRhYmxlIGNvbnRlbnQuIFRoaXMgaXMgdXN1YWxseSB0aGUgc2FtZSBhcyBgaXNMZWFmYCwgYnV0IGNhblxuICAgIGJlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgW2BhdG9tYCBwcm9wZXJ0eV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmF0b20pXG4gICAgb24gYSBub2RlJ3Mgc3BlYyAodHlwaWNhbGx5IHVzZWQgd2hlbiB0aGUgbm9kZSBpcyBkaXNwbGF5ZWQgYXNcbiAgICBhbiB1bmVkaXRhYmxlIFtub2RlIHZpZXddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3Lk5vZGVWaWV3KSkuXG4gICAgKi9cbiAgICBnZXQgaXNBdG9tKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzQXRvbTsgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUgZm9yIGRlYnVnZ2luZ1xuICAgIHB1cnBvc2VzLlxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcodGhpcyk7XG4gICAgICAgIGxldCBuYW1lID0gdGhpcy50eXBlLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIG5hbWUgKz0gXCIoXCIgKyB0aGlzLmNvbnRlbnQudG9TdHJpbmdJbm5lcigpICsgXCIpXCI7XG4gICAgICAgIHJldHVybiB3cmFwTWFya3ModGhpcy5tYXJrcywgbmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY29udGVudCBtYXRjaCBpbiB0aGlzIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICovXG4gICAgY29udGVudE1hdGNoQXQoaW5kZXgpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgMCwgaW5kZXgpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGVkIGNvbnRlbnRNYXRjaEF0IG9uIGEgbm9kZSB3aXRoIGludmFsaWQgY29udGVudFwiKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgcmVwbGFjaW5nIHRoZSByYW5nZSBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYCAoYnlcbiAgICBjaGlsZCBpbmRleCkgd2l0aCB0aGUgZ2l2ZW4gcmVwbGFjZW1lbnQgZnJhZ21lbnQgKHdoaWNoIGRlZmF1bHRzXG4gICAgdG8gdGhlIGVtcHR5IGZyYWdtZW50KSB3b3VsZCBsZWF2ZSB0aGUgbm9kZSdzIGNvbnRlbnQgdmFsaWQuIFlvdVxuICAgIGNhbiBvcHRpb25hbGx5IHBhc3MgYHN0YXJ0YCBhbmQgYGVuZGAgaW5kaWNlcyBpbnRvIHRoZVxuICAgIHJlcGxhY2VtZW50IGZyYWdtZW50LlxuICAgICovXG4gICAgY2FuUmVwbGFjZShmcm9tLCB0bywgcmVwbGFjZW1lbnQgPSBGcmFnbWVudC5lbXB0eSwgc3RhcnQgPSAwLCBlbmQgPSByZXBsYWNlbWVudC5jaGlsZENvdW50KSB7XG4gICAgICAgIGxldCBvbmUgPSB0aGlzLmNvbnRlbnRNYXRjaEF0KGZyb20pLm1hdGNoRnJhZ21lbnQocmVwbGFjZW1lbnQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICBsZXQgdHdvID0gb25lICYmIG9uZS5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICAgICAgICBpZiAoIXR3byB8fCAhdHdvLnZhbGlkRW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy50eXBlLmFsbG93c01hcmtzKHJlcGxhY2VtZW50LmNoaWxkKGkpLm1hcmtzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgcmVwbGFjaW5nIHRoZSByYW5nZSBgZnJvbWAgdG8gYHRvYCAoYnkgaW5kZXgpIHdpdGhcbiAgICBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUgd291bGQgbGVhdmUgdGhlIG5vZGUncyBjb250ZW50IHZhbGlkLlxuICAgICovXG4gICAgY2FuUmVwbGFjZVdpdGgoZnJvbSwgdG8sIHR5cGUsIG1hcmtzKSB7XG4gICAgICAgIGlmIChtYXJrcyAmJiAhdGhpcy50eXBlLmFsbG93c01hcmtzKG1hcmtzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jb250ZW50TWF0Y2hBdChmcm9tKS5tYXRjaFR5cGUodHlwZSk7XG4gICAgICAgIGxldCBlbmQgPSBzdGFydCAmJiBzdGFydC5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICAgICAgICByZXR1cm4gZW5kID8gZW5kLnZhbGlkRW5kIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGUgZ2l2ZW4gbm9kZSdzIGNvbnRlbnQgY291bGQgYmUgYXBwZW5kZWQgdG8gdGhpc1xuICAgIG5vZGUuIElmIHRoYXQgbm9kZSBpcyBlbXB0eSwgdGhpcyB3aWxsIG9ubHkgcmV0dXJuIHRydWUgaWYgdGhlcmVcbiAgICBpcyBhdCBsZWFzdCBvbmUgbm9kZSB0eXBlIHRoYXQgY2FuIGFwcGVhciBpbiBib3RoIG5vZGVzICh0byBhdm9pZFxuICAgIG1lcmdpbmcgY29tcGxldGVseSBpbmNvbXBhdGlibGUgbm9kZXMpLlxuICAgICovXG4gICAgY2FuQXBwZW5kKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYW5SZXBsYWNlKHRoaXMuY2hpbGRDb3VudCwgdGhpcy5jaGlsZENvdW50LCBvdGhlci5jb250ZW50KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5jb21wYXRpYmxlQ29udGVudChvdGhlci50eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGlzIG5vZGUgYW5kIGl0cyBkZXNjZW5kYW50cyBjb25mb3JtIHRvIHRoZVxuICAgIHNjaGVtYSwgYW5kIHJhaXNlIGVycm9yIHdoZW4gdGhleSBkbyBub3QuXG4gICAgKi9cbiAgICBjaGVjaygpIHtcbiAgICAgICAgdGhpcy50eXBlLmNoZWNrQ29udGVudCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICBsZXQgY29weSA9IE1hcmsubm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgY29weSA9IHRoaXMubWFya3NbaV0uYWRkVG9TZXQoY29weSk7XG4gICAgICAgIGlmICghTWFyay5zYW1lU2V0KGNvcHksIHRoaXMubWFya3MpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgY29sbGVjdGlvbiBvZiBtYXJrcyBmb3Igbm9kZSAke3RoaXMudHlwZS5uYW1lfTogJHt0aGlzLm1hcmtzLm1hcChtID0+IG0udHlwZS5uYW1lKX1gKTtcbiAgICAgICAgdGhpcy5jb250ZW50LmZvckVhY2gobm9kZSA9PiBub2RlLmNoZWNrKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBKU09OLXNlcmlhbGl6ZWFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBub2RlLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgb2JqID0geyB0eXBlOiB0aGlzLnR5cGUubmFtZSB9O1xuICAgICAgICBmb3IgKGxldCBfIGluIHRoaXMuYXR0cnMpIHtcbiAgICAgICAgICAgIG9iai5hdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICBvYmouY29udGVudCA9IHRoaXMuY29udGVudC50b0pTT04oKTtcbiAgICAgICAgaWYgKHRoaXMubWFya3MubGVuZ3RoKVxuICAgICAgICAgICAgb2JqLm1hcmtzID0gdGhpcy5tYXJrcy5tYXAobiA9PiBuLnRvSlNPTigpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBub2RlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgTm9kZS5mcm9tSlNPTlwiKTtcbiAgICAgICAgbGV0IG1hcmtzID0gbnVsbDtcbiAgICAgICAgaWYgKGpzb24ubWFya3MpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uLm1hcmtzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbWFyayBkYXRhIGZvciBOb2RlLmZyb21KU09OXCIpO1xuICAgICAgICAgICAgbWFya3MgPSBqc29uLm1hcmtzLm1hcChzY2hlbWEubWFya0Zyb21KU09OKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbi50eXBlID09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24udGV4dCAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB0ZXh0IG5vZGUgaW4gSlNPTlwiKTtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEudGV4dChqc29uLnRleHQsIG1hcmtzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmZyb21KU09OKHNjaGVtYSwganNvbi5jb250ZW50KTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5ub2RlVHlwZShqc29uLnR5cGUpLmNyZWF0ZShqc29uLmF0dHJzLCBjb250ZW50LCBtYXJrcyk7XG4gICAgfVxufVxuTm9kZS5wcm90b3R5cGUudGV4dCA9IHVuZGVmaW5lZDtcbmNsYXNzIFRleHROb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBhdHRycywgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgc3VwZXIodHlwZSwgYXR0cnMsIG51bGwsIG1hcmtzKTtcbiAgICAgICAgaWYgKCFjb250ZW50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFbXB0eSB0ZXh0IG5vZGVzIGFyZSBub3QgYWxsb3dlZFwiKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gY29udGVudDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcodGhpcyk7XG4gICAgICAgIHJldHVybiB3cmFwTWFya3ModGhpcy5tYXJrcywgSlNPTi5zdHJpbmdpZnkodGhpcy50ZXh0KSk7XG4gICAgfVxuICAgIGdldCB0ZXh0Q29udGVudCgpIHsgcmV0dXJuIHRoaXMudGV4dDsgfVxuICAgIHRleHRCZXR3ZWVuKGZyb20sIHRvKSB7IHJldHVybiB0aGlzLnRleHQuc2xpY2UoZnJvbSwgdG8pOyB9XG4gICAgZ2V0IG5vZGVTaXplKCkgeyByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIG1hcmsobWFya3MpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtzID09IHRoaXMubWFya3MgPyB0aGlzIDogbmV3IFRleHROb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGhpcy50ZXh0LCBtYXJrcyk7XG4gICAgfVxuICAgIHdpdGhUZXh0KHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQgPT0gdGhpcy50ZXh0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCB0ZXh0LCB0aGlzLm1hcmtzKTtcbiAgICB9XG4gICAgY3V0KGZyb20gPSAwLCB0byA9IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhUZXh0KHRoaXMudGV4dC5zbGljZShmcm9tLCB0bykpO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zYW1lTWFya3VwKG90aGVyKSAmJiB0aGlzLnRleHQgPT0gb3RoZXIudGV4dDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgYmFzZSA9IHN1cGVyLnRvSlNPTigpO1xuICAgICAgICBiYXNlLnRleHQgPSB0aGlzLnRleHQ7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdyYXBNYXJrcyhtYXJrcywgc3RyKSB7XG4gICAgZm9yIChsZXQgaSA9IG1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBzdHIgPSBtYXJrc1tpXS50eXBlLm5hbWUgKyBcIihcIiArIHN0ciArIFwiKVwiO1xuICAgIHJldHVybiBzdHI7XG59XG5cbi8qKlxuSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgcmVwcmVzZW50IGEgbWF0Y2ggc3RhdGUgb2YgYSBub2RlIHR5cGUnc1xuW2NvbnRlbnQgZXhwcmVzc2lvbl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmNvbnRlbnQpLCBhbmQgY2FuIGJlIHVzZWQgdG9cbmZpbmQgb3V0IHdoZXRoZXIgZnVydGhlciBjb250ZW50IG1hdGNoZXMgaGVyZSwgYW5kIHdoZXRoZXIgYSBnaXZlblxucG9zaXRpb24gaXMgYSB2YWxpZCBlbmQgb2YgdGhlIG5vZGUuXG4qL1xuY2xhc3MgQ29udGVudE1hdGNoIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG1hdGNoIHN0YXRlIHJlcHJlc2VudHMgYSB2YWxpZCBlbmQgb2YgdGhlIG5vZGUuXG4gICAgKi9cbiAgICB2YWxpZEVuZCkge1xuICAgICAgICB0aGlzLnZhbGlkRW5kID0gdmFsaWRFbmQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cmFwQ2FjaGUgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgcGFyc2Uoc3RyaW5nLCBub2RlVHlwZXMpIHtcbiAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyBUb2tlblN0cmVhbShzdHJpbmcsIG5vZGVUeXBlcyk7XG4gICAgICAgIGlmIChzdHJlYW0ubmV4dCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIENvbnRlbnRNYXRjaC5lbXB0eTtcbiAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyZWFtKTtcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0KVxuICAgICAgICAgICAgc3RyZWFtLmVycihcIlVuZXhwZWN0ZWQgdHJhaWxpbmcgdGV4dFwiKTtcbiAgICAgICAgbGV0IG1hdGNoID0gZGZhKG5mYShleHByKSk7XG4gICAgICAgIGNoZWNrRm9yRGVhZEVuZHMobWF0Y2gsIHN0cmVhbSk7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gICAgLyoqXG4gICAgTWF0Y2ggYSBub2RlIHR5cGUsIHJldHVybmluZyBhIG1hdGNoIGFmdGVyIHRoYXQgbm9kZSBpZlxuICAgIHN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBtYXRjaFR5cGUodHlwZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRbaV0udHlwZSA9PSB0eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRbaV0ubmV4dDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBtYXRjaCBhIGZyYWdtZW50LiBSZXR1cm5zIHRoZSByZXN1bHRpbmcgbWF0Y2ggd2hlblxuICAgIHN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBtYXRjaEZyYWdtZW50KGZyYWcsIHN0YXJ0ID0gMCwgZW5kID0gZnJhZy5jaGlsZENvdW50KSB7XG4gICAgICAgIGxldCBjdXIgPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGN1ciAmJiBpIDwgZW5kOyBpKyspXG4gICAgICAgICAgICBjdXIgPSBjdXIubWF0Y2hUeXBlKGZyYWcuY2hpbGQoaSkudHlwZSk7XG4gICAgICAgIHJldHVybiBjdXI7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGlubGluZUNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQubGVuZ3RoICE9IDAgJiYgdGhpcy5uZXh0WzBdLnR5cGUuaXNJbmxpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZmlyc3QgbWF0Y2hpbmcgbm9kZSB0eXBlIGF0IHRoaXMgbWF0Y2ggcG9zaXRpb24gdGhhdCBjYW5cbiAgICBiZSBnZW5lcmF0ZWQuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdFR5cGUoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyB0eXBlIH0gPSB0aGlzLm5leHRbaV07XG4gICAgICAgICAgICBpZiAoISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGF0aWJsZShvdGhlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3RoZXIubmV4dC5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXh0W2ldLnR5cGUgPT0gb3RoZXIubmV4dFtqXS50eXBlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnkgdG8gbWF0Y2ggdGhlIGdpdmVuIGZyYWdtZW50LCBhbmQgaWYgdGhhdCBmYWlscywgc2VlIGlmIGl0IGNhblxuICAgIGJlIG1hZGUgdG8gbWF0Y2ggYnkgaW5zZXJ0aW5nIG5vZGVzIGluIGZyb250IG9mIGl0LiBXaGVuXG4gICAgc3VjY2Vzc2Z1bCwgcmV0dXJuIGEgZnJhZ21lbnQgb2YgaW5zZXJ0ZWQgbm9kZXMgKHdoaWNoIG1heSBiZVxuICAgIGVtcHR5IGlmIG5vdGhpbmcgaGFkIHRvIGJlIGluc2VydGVkKS4gV2hlbiBgdG9FbmRgIGlzIHRydWUsIG9ubHlcbiAgICByZXR1cm4gYSBmcmFnbWVudCBpZiB0aGUgcmVzdWx0aW5nIG1hdGNoIGdvZXMgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICBjb250ZW50IGV4cHJlc3Npb24uXG4gICAgKi9cbiAgICBmaWxsQmVmb3JlKGFmdGVyLCB0b0VuZCA9IGZhbHNlLCBzdGFydEluZGV4ID0gMCkge1xuICAgICAgICBsZXQgc2VlbiA9IFt0aGlzXTtcbiAgICAgICAgZnVuY3Rpb24gc2VhcmNoKG1hdGNoLCB0eXBlcykge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gbWF0Y2gubWF0Y2hGcmFnbWVudChhZnRlciwgc3RhcnRJbmRleCk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQgJiYgKCF0b0VuZCB8fCBmaW5pc2hlZC52YWxpZEVuZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb20odHlwZXMubWFwKHRwID0+IHRwLmNyZWF0ZUFuZEZpbGwoKSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gbWF0Y2gubmV4dFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkgJiYgc2Vlbi5pbmRleE9mKG5leHQpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZW4ucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gc2VhcmNoKG5leHQsIHR5cGVzLmNvbmNhdCh0eXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VhcmNoKHRoaXMsIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBhIHNldCBvZiB3cmFwcGluZyBub2RlIHR5cGVzIHRoYXQgd291bGQgYWxsb3cgYSBub2RlIG9mIHRoZVxuICAgIGdpdmVuIHR5cGUgdG8gYXBwZWFyIGF0IHRoaXMgcG9zaXRpb24uIFRoZSByZXN1bHQgbWF5IGJlIGVtcHR5XG4gICAgKHdoZW4gaXQgZml0cyBkaXJlY3RseSkgYW5kIHdpbGwgYmUgbnVsbCB3aGVuIG5vIHN1Y2ggd3JhcHBpbmdcbiAgICBleGlzdHMuXG4gICAgKi9cbiAgICBmaW5kV3JhcHBpbmcodGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy53cmFwQ2FjaGUubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgICAgICBpZiAodGhpcy53cmFwQ2FjaGVbaV0gPT0gdGFyZ2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBDYWNoZVtpICsgMV07XG4gICAgICAgIGxldCBjb21wdXRlZCA9IHRoaXMuY29tcHV0ZVdyYXBwaW5nKHRhcmdldCk7XG4gICAgICAgIHRoaXMud3JhcENhY2hlLnB1c2godGFyZ2V0LCBjb21wdXRlZCk7XG4gICAgICAgIHJldHVybiBjb21wdXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wdXRlV3JhcHBpbmcodGFyZ2V0KSB7XG4gICAgICAgIGxldCBzZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgYWN0aXZlID0gW3sgbWF0Y2g6IHRoaXMsIHR5cGU6IG51bGwsIHZpYTogbnVsbCB9XTtcbiAgICAgICAgd2hpbGUgKGFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gYWN0aXZlLnNoaWZ0KCksIG1hdGNoID0gY3VycmVudC5tYXRjaDtcbiAgICAgICAgICAgIGlmIChtYXRjaC5tYXRjaFR5cGUodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvYmogPSBjdXJyZW50OyBvYmoudHlwZTsgb2JqID0gb2JqLnZpYSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqLnR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gbWF0Y2gubmV4dFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUuaXNMZWFmICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSAmJiAhKHR5cGUubmFtZSBpbiBzZWVuKSAmJiAoIWN1cnJlbnQudHlwZSB8fCBuZXh0LnZhbGlkRW5kKSkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmUucHVzaCh7IG1hdGNoOiB0eXBlLmNvbnRlbnRNYXRjaCwgdHlwZSwgdmlhOiBjdXJyZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICBzZWVuW3R5cGUubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiBvdXRnb2luZyBlZGdlcyB0aGlzIG5vZGUgaGFzIGluIHRoZSBmaW5pdGVcbiAgICBhdXRvbWF0b24gdGhhdCBkZXNjcmliZXMgdGhlIGNvbnRlbnQgZXhwcmVzc2lvbi5cbiAgICAqL1xuICAgIGdldCBlZGdlQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIF9uX1x1MjAwQnRoIG91dGdvaW5nIGVkZ2UgZnJvbSB0aGlzIG5vZGUgaW4gdGhlIGZpbml0ZVxuICAgIGF1dG9tYXRvbiB0aGF0IGRlc2NyaWJlcyB0aGUgY29udGVudCBleHByZXNzaW9uLlxuICAgICovXG4gICAgZWRnZShuKSB7XG4gICAgICAgIGlmIChuID49IHRoaXMubmV4dC5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVGhlcmUncyBubyAke259dGggZWRnZSBpbiB0aGlzIGNvbnRlbnQgbWF0Y2hgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFtuXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHNlZW4gPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gc2NhbihtKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2gobSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG0ubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG0ubmV4dFtpXS5uZXh0KSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgc2NhbihtLm5leHRbaV0ubmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgc2Nhbih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHNlZW4ubWFwKChtLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgb3V0ID0gaSArIChtLnZhbGlkRW5kID8gXCIqXCIgOiBcIiBcIikgKyBcIiBcIjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbS5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIG91dCArPSAoaSA/IFwiLCBcIiA6IFwiXCIpICsgbS5uZXh0W2ldLnR5cGUubmFtZSArIFwiLT5cIiArIHNlZW4uaW5kZXhPZihtLm5leHRbaV0ubmV4dCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgIH1cbn1cbi8qKlxuQGludGVybmFsXG4qL1xuQ29udGVudE1hdGNoLmVtcHR5ID0gbmV3IENvbnRlbnRNYXRjaCh0cnVlKTtcbmNsYXNzIFRva2VuU3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmcsIG5vZGVUeXBlcykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICAgICAgdGhpcy5ub2RlVHlwZXMgPSBub2RlVHlwZXM7XG4gICAgICAgIHRoaXMuaW5saW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnRva2VucyA9IHN0cmluZy5zcGxpdCgvXFxzKig/PVxcYnxcXFd8JCkvKTtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdID09IFwiXCIpXG4gICAgICAgICAgICB0aGlzLnRva2Vucy5wb3AoKTtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zWzBdID09IFwiXCIpXG4gICAgICAgICAgICB0aGlzLnRva2Vucy5zaGlmdCgpO1xuICAgIH1cbiAgICBnZXQgbmV4dCgpIHsgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMucG9zXTsgfVxuICAgIGVhdCh0b2spIHsgcmV0dXJuIHRoaXMubmV4dCA9PSB0b2sgJiYgKHRoaXMucG9zKysgfHwgdHJ1ZSk7IH1cbiAgICBlcnIoc3RyKSB7IHRocm93IG5ldyBTeW50YXhFcnJvcihzdHIgKyBcIiAoaW4gY29udGVudCBleHByZXNzaW9uICdcIiArIHRoaXMuc3RyaW5nICsgXCInKVwiKTsgfVxufVxuZnVuY3Rpb24gcGFyc2VFeHByKHN0cmVhbSkge1xuICAgIGxldCBleHBycyA9IFtdO1xuICAgIGRvIHtcbiAgICAgICAgZXhwcnMucHVzaChwYXJzZUV4cHJTZXEoc3RyZWFtKSk7XG4gICAgfSB3aGlsZSAoc3RyZWFtLmVhdChcInxcIikpO1xuICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogeyB0eXBlOiBcImNob2ljZVwiLCBleHBycyB9O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByU2VxKHN0cmVhbSkge1xuICAgIGxldCBleHBycyA9IFtdO1xuICAgIGRvIHtcbiAgICAgICAgZXhwcnMucHVzaChwYXJzZUV4cHJTdWJzY3JpcHQoc3RyZWFtKSk7XG4gICAgfSB3aGlsZSAoc3RyZWFtLm5leHQgJiYgc3RyZWFtLm5leHQgIT0gXCIpXCIgJiYgc3RyZWFtLm5leHQgIT0gXCJ8XCIpO1xuICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogeyB0eXBlOiBcInNlcVwiLCBleHBycyB9O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByU3Vic2NyaXB0KHN0cmVhbSkge1xuICAgIGxldCBleHByID0gcGFyc2VFeHByQXRvbShzdHJlYW0pO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIrXCIpKVxuICAgICAgICAgICAgZXhwciA9IHsgdHlwZTogXCJwbHVzXCIsIGV4cHIgfTtcbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIipcIikpXG4gICAgICAgICAgICBleHByID0geyB0eXBlOiBcInN0YXJcIiwgZXhwciB9O1xuICAgICAgICBlbHNlIGlmIChzdHJlYW0uZWF0KFwiP1wiKSlcbiAgICAgICAgICAgIGV4cHIgPSB7IHR5cGU6IFwib3B0XCIsIGV4cHIgfTtcbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIntcIikpXG4gICAgICAgICAgICBleHByID0gcGFyc2VFeHByUmFuZ2Uoc3RyZWFtLCBleHByKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBleHByO1xufVxuZnVuY3Rpb24gcGFyc2VOdW0oc3RyZWFtKSB7XG4gICAgaWYgKC9cXEQvLnRlc3Qoc3RyZWFtLm5leHQpKVxuICAgICAgICBzdHJlYW0uZXJyKFwiRXhwZWN0ZWQgbnVtYmVyLCBnb3QgJ1wiICsgc3RyZWFtLm5leHQgKyBcIidcIik7XG4gICAgbGV0IHJlc3VsdCA9IE51bWJlcihzdHJlYW0ubmV4dCk7XG4gICAgc3RyZWFtLnBvcysrO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJSYW5nZShzdHJlYW0sIGV4cHIpIHtcbiAgICBsZXQgbWluID0gcGFyc2VOdW0oc3RyZWFtKSwgbWF4ID0gbWluO1xuICAgIGlmIChzdHJlYW0uZWF0KFwiLFwiKSkge1xuICAgICAgICBpZiAoc3RyZWFtLm5leHQgIT0gXCJ9XCIpXG4gICAgICAgICAgICBtYXggPSBwYXJzZU51bShzdHJlYW0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXggPSAtMTtcbiAgICB9XG4gICAgaWYgKCFzdHJlYW0uZWF0KFwifVwiKSlcbiAgICAgICAgc3RyZWFtLmVycihcIlVuY2xvc2VkIGJyYWNlZCByYW5nZVwiKTtcbiAgICByZXR1cm4geyB0eXBlOiBcInJhbmdlXCIsIG1pbiwgbWF4LCBleHByIH07XG59XG5mdW5jdGlvbiByZXNvbHZlTmFtZShzdHJlYW0sIG5hbWUpIHtcbiAgICBsZXQgdHlwZXMgPSBzdHJlYW0ubm9kZVR5cGVzLCB0eXBlID0gdHlwZXNbbmFtZV07XG4gICAgaWYgKHR5cGUpXG4gICAgICAgIHJldHVybiBbdHlwZV07XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHR5cGVOYW1lIGluIHR5cGVzKSB7XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbdHlwZU5hbWVdO1xuICAgICAgICBpZiAodHlwZS5ncm91cHMuaW5kZXhPZihuYW1lKSA+IC0xKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godHlwZSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQubGVuZ3RoID09IDApXG4gICAgICAgIHN0cmVhbS5lcnIoXCJObyBub2RlIHR5cGUgb3IgZ3JvdXAgJ1wiICsgbmFtZSArIFwiJyBmb3VuZFwiKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByQXRvbShzdHJlYW0pIHtcbiAgICBpZiAoc3RyZWFtLmVhdChcIihcIikpIHtcbiAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyZWFtKTtcbiAgICAgICAgaWYgKCFzdHJlYW0uZWF0KFwiKVwiKSlcbiAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJNaXNzaW5nIGNsb3NpbmcgcGFyZW5cIik7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgICBlbHNlIGlmICghL1xcVy8udGVzdChzdHJlYW0ubmV4dCkpIHtcbiAgICAgICAgbGV0IGV4cHJzID0gcmVzb2x2ZU5hbWUoc3RyZWFtLCBzdHJlYW0ubmV4dCkubWFwKHR5cGUgPT4ge1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5pbmxpbmUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBzdHJlYW0uaW5saW5lID0gdHlwZS5pc0lubGluZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmVhbS5pbmxpbmUgIT0gdHlwZS5pc0lubGluZSlcbiAgICAgICAgICAgICAgICBzdHJlYW0uZXJyKFwiTWl4aW5nIGlubGluZSBhbmQgYmxvY2sgY29udGVudFwiKTtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibmFtZVwiLCB2YWx1ZTogdHlwZSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtLnBvcysrO1xuICAgICAgICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHsgdHlwZTogXCJjaG9pY2VcIiwgZXhwcnMgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lcnIoXCJVbmV4cGVjdGVkIHRva2VuICdcIiArIHN0cmVhbS5uZXh0ICsgXCInXCIpO1xuICAgIH1cbn1cbi8qKlxuQ29uc3RydWN0IGFuIE5GQSBmcm9tIGFuIGV4cHJlc3Npb24gYXMgcmV0dXJuZWQgYnkgdGhlIHBhcnNlci4gVGhlXG5ORkEgaXMgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2Ygc3RhdGVzLCB3aGljaCBhcmUgdGhlbXNlbHZlc1xuYXJyYXlzIG9mIGVkZ2VzLCB3aGljaCBhcmUgYHt0ZXJtLCB0b31gIG9iamVjdHMuIFRoZSBmaXJzdCBzdGF0ZSBpc1xudGhlIGVudHJ5IHN0YXRlIGFuZCB0aGUgbGFzdCBub2RlIGlzIHRoZSBzdWNjZXNzIHN0YXRlLlxuXG5Ob3RlIHRoYXQgdW5saWtlIHR5cGljYWwgTkZBcywgdGhlIGVkZ2Ugb3JkZXJpbmcgaW4gdGhpcyBvbmUgaXNcbnNpZ25pZmljYW50LCBpbiB0aGF0IGl0IGlzIHVzZWQgdG8gY29udHJ1Y3QgZmlsbGVyIGNvbnRlbnQgd2hlblxubmVjZXNzYXJ5LlxuKi9cbmZ1bmN0aW9uIG5mYShleHByKSB7XG4gICAgbGV0IG5mYSA9IFtbXV07XG4gICAgY29ubmVjdChjb21waWxlKGV4cHIsIDApLCBub2RlKCkpO1xuICAgIHJldHVybiBuZmE7XG4gICAgZnVuY3Rpb24gbm9kZSgpIHsgcmV0dXJuIG5mYS5wdXNoKFtdKSAtIDE7IH1cbiAgICBmdW5jdGlvbiBlZGdlKGZyb20sIHRvLCB0ZXJtKSB7XG4gICAgICAgIGxldCBlZGdlID0geyB0ZXJtLCB0byB9O1xuICAgICAgICBuZmFbZnJvbV0ucHVzaChlZGdlKTtcbiAgICAgICAgcmV0dXJuIGVkZ2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbm5lY3QoZWRnZXMsIHRvKSB7XG4gICAgICAgIGVkZ2VzLmZvckVhY2goZWRnZSA9PiBlZGdlLnRvID0gdG8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21waWxlKGV4cHIsIGZyb20pIHtcbiAgICAgICAgaWYgKGV4cHIudHlwZSA9PSBcImNob2ljZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwci5leHBycy5yZWR1Y2UoKG91dCwgZXhwcikgPT4gb3V0LmNvbmNhdChjb21waWxlKGV4cHIsIGZyb20pKSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInNlcVwiKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY29tcGlsZShleHByLmV4cHJzW2ldLCBmcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBleHByLmV4cHJzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgIGNvbm5lY3QobmV4dCwgZnJvbSA9IG5vZGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwic3RhclwiKSB7XG4gICAgICAgICAgICBsZXQgbG9vcCA9IG5vZGUoKTtcbiAgICAgICAgICAgIGVkZ2UoZnJvbSwgbG9vcCk7XG4gICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBsb29wKSwgbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UobG9vcCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInBsdXNcIikge1xuICAgICAgICAgICAgbGV0IGxvb3AgPSBub2RlKCk7XG4gICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBmcm9tKSwgbG9vcCk7XG4gICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBsb29wKSwgbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UobG9vcCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcIm9wdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UoZnJvbSldLmNvbmNhdChjb21waWxlKGV4cHIuZXhwciwgZnJvbSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInJhbmdlXCIpIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSBmcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHByLm1pbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlKCk7XG4gICAgICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHByLm1heCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGN1ciksIGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gZXhwci5taW47IGkgPCBleHByLm1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICBlZGdlKGN1ciwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGN1ciksIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbZWRnZShjdXIpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShmcm9tLCB1bmRlZmluZWQsIGV4cHIudmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZXhwciB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY21wKGEsIGIpIHsgcmV0dXJuIGIgLSBhOyB9XG4vLyBHZXQgdGhlIHNldCBvZiBub2RlcyByZWFjaGFibGUgYnkgbnVsbCBlZGdlcyBmcm9tIGBub2RlYC4gT21pdFxuLy8gbm9kZXMgd2l0aCBvbmx5IGEgc2luZ2xlIG51bGwtb3V0LWVkZ2UsIHNpbmNlIHRoZXkgbWF5IGxlYWQgdG9cbi8vIG5lZWRsZXNzIGR1cGxpY2F0ZWQgbm9kZXMuXG5mdW5jdGlvbiBudWxsRnJvbShuZmEsIG5vZGUpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgc2Nhbihub2RlKTtcbiAgICByZXR1cm4gcmVzdWx0LnNvcnQoY21wKTtcbiAgICBmdW5jdGlvbiBzY2FuKG5vZGUpIHtcbiAgICAgICAgbGV0IGVkZ2VzID0gbmZhW25vZGVdO1xuICAgICAgICBpZiAoZWRnZXMubGVuZ3RoID09IDEgJiYgIWVkZ2VzWzBdLnRlcm0pXG4gICAgICAgICAgICByZXR1cm4gc2NhbihlZGdlc1swXS50byk7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyB0ZXJtLCB0byB9ID0gZWRnZXNbaV07XG4gICAgICAgICAgICBpZiAoIXRlcm0gJiYgcmVzdWx0LmluZGV4T2YodG8pID09IC0xKVxuICAgICAgICAgICAgICAgIHNjYW4odG8pO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gQ29tcGlsZXMgYW4gTkZBIGFzIHByb2R1Y2VkIGJ5IGBuZmFgIGludG8gYSBERkEsIG1vZGVsZWQgYXMgYSBzZXRcbi8vIG9mIHN0YXRlIG9iamVjdHMgKGBDb250ZW50TWF0Y2hgIGluc3RhbmNlcykgd2l0aCB0cmFuc2l0aW9uc1xuLy8gYmV0d2VlbiB0aGVtLlxuZnVuY3Rpb24gZGZhKG5mYSkge1xuICAgIGxldCBsYWJlbGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gZXhwbG9yZShudWxsRnJvbShuZmEsIDApKTtcbiAgICBmdW5jdGlvbiBleHBsb3JlKHN0YXRlcykge1xuICAgICAgICBsZXQgb3V0ID0gW107XG4gICAgICAgIHN0YXRlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgbmZhW25vZGVdLmZvckVhY2goKHsgdGVybSwgdG8gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGVybSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxldCBzZXQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRbaV1bMF0gPT0gdGVybSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldCA9IG91dFtpXVsxXTtcbiAgICAgICAgICAgICAgICBudWxsRnJvbShuZmEsIHRvKS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldClcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKFt0ZXJtLCBzZXQgPSBbXV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0LmluZGV4T2Yobm9kZSkgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHN0YXRlID0gbGFiZWxlZFtzdGF0ZXMuam9pbihcIixcIildID0gbmV3IENvbnRlbnRNYXRjaChzdGF0ZXMuaW5kZXhPZihuZmEubGVuZ3RoIC0gMSkgPiAtMSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhdGVzID0gb3V0W2ldWzFdLnNvcnQoY21wKTtcbiAgICAgICAgICAgIHN0YXRlLm5leHQucHVzaCh7IHR5cGU6IG91dFtpXVswXSwgbmV4dDogbGFiZWxlZFtzdGF0ZXMuam9pbihcIixcIildIHx8IGV4cGxvcmUoc3RhdGVzKSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tGb3JEZWFkRW5kcyhtYXRjaCwgc3RyZWFtKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIHdvcmsgPSBbbWF0Y2hdOyBpIDwgd29yay5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc3RhdGUgPSB3b3JrW2ldLCBkZWFkID0gIXN0YXRlLnZhbGlkRW5kLCBub2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0YXRlLm5leHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCB7IHR5cGUsIG5leHQgfSA9IHN0YXRlLm5leHRbal07XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHR5cGUubmFtZSk7XG4gICAgICAgICAgICBpZiAoZGVhZCAmJiAhKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSlcbiAgICAgICAgICAgICAgICBkZWFkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAod29yay5pbmRleE9mKG5leHQpID09IC0xKVxuICAgICAgICAgICAgICAgIHdvcmsucHVzaChuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVhZClcbiAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJPbmx5IG5vbi1nZW5lcmF0YWJsZSBub2RlcyAoXCIgKyBub2Rlcy5qb2luKFwiLCBcIikgKyBcIikgaW4gYSByZXF1aXJlZCBwb3NpdGlvbiAoc2VlIGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvZ3VpZGUvI2dlbmVyYXRhYmxlKVwiKTtcbiAgICB9XG59XG5cbi8vIEZvciBub2RlIHR5cGVzIHdoZXJlIGFsbCBhdHRycyBoYXZlIGEgZGVmYXVsdCB2YWx1ZSAob3Igd2hpY2ggZG9uJ3Rcbi8vIGhhdmUgYW55IGF0dHJpYnV0ZXMpLCBidWlsZCB1cCBhIHNpbmdsZSByZXVzYWJsZSBkZWZhdWx0IGF0dHJpYnV0ZVxuLy8gb2JqZWN0LCBhbmQgdXNlIGl0IGZvciBhbGwgbm9kZXMgdGhhdCBkb24ndCBzcGVjaWZ5IHNwZWNpZmljXG4vLyBhdHRyaWJ1dGVzLlxuZnVuY3Rpb24gZGVmYXVsdEF0dHJzKGF0dHJzKSB7XG4gICAgbGV0IGRlZmF1bHRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBhdHRyTmFtZSBpbiBhdHRycykge1xuICAgICAgICBsZXQgYXR0ciA9IGF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgaWYgKCFhdHRyLmhhc0RlZmF1bHQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZGVmYXVsdHNbYXR0ck5hbWVdID0gYXR0ci5kZWZhdWx0O1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdHM7XG59XG5mdW5jdGlvbiBjb21wdXRlQXR0cnMoYXR0cnMsIHZhbHVlKSB7XG4gICAgbGV0IGJ1aWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKSB7XG4gICAgICAgIGxldCBnaXZlbiA9IHZhbHVlICYmIHZhbHVlW25hbWVdO1xuICAgICAgICBpZiAoZ2l2ZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGF0dHIgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChhdHRyLmhhc0RlZmF1bHQpXG4gICAgICAgICAgICAgICAgZ2l2ZW4gPSBhdHRyLmRlZmF1bHQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyB2YWx1ZSBzdXBwbGllZCBmb3IgYXR0cmlidXRlIFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbHRbbmFtZV0gPSBnaXZlbjtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWx0O1xufVxuZnVuY3Rpb24gaW5pdEF0dHJzKGF0dHJzKSB7XG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGF0dHJzKVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKVxuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gbmV3IEF0dHJpYnV0ZShhdHRyc1tuYW1lXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuTm9kZSB0eXBlcyBhcmUgb2JqZWN0cyBhbGxvY2F0ZWQgb25jZSBwZXIgYFNjaGVtYWAgYW5kIHVzZWQgdG9cblt0YWddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnR5cGUpIGBOb2RlYCBpbnN0YW5jZXMuIFRoZXkgY29udGFpbiBpbmZvcm1hdGlvblxuYWJvdXQgdGhlIG5vZGUgdHlwZSwgc3VjaCBhcyBpdHMgbmFtZSBhbmQgd2hhdCBraW5kIG9mIG5vZGUgaXRcbnJlcHJlc2VudHMuXG4qL1xuY2xhc3MgTm9kZVR5cGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5hbWUgdGhlIG5vZGUgdHlwZSBoYXMgaW4gdGhpcyBzY2hlbWEuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBBIGxpbmsgYmFjayB0byB0aGUgYFNjaGVtYWAgdGhlIG5vZGUgdHlwZSBiZWxvbmdzIHRvLlxuICAgICovXG4gICAgc2NoZW1hLCBcbiAgICAvKipcbiAgICBUaGUgc3BlYyB0aGF0IHRoaXMgdHlwZSBpcyBiYXNlZCBvblxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBzZXQgb2YgbWFya3MgYWxsb3dlZCBpbiB0aGlzIG5vZGUuIGBudWxsYCBtZWFucyBhbGwgbWFya3NcbiAgICAgICAgYXJlIGFsbG93ZWQuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFya1NldCA9IG51bGw7XG4gICAgICAgIHRoaXMuZ3JvdXBzID0gc3BlYy5ncm91cCA/IHNwZWMuZ3JvdXAuc3BsaXQoXCIgXCIpIDogW107XG4gICAgICAgIHRoaXMuYXR0cnMgPSBpbml0QXR0cnMoc3BlYy5hdHRycyk7XG4gICAgICAgIHRoaXMuZGVmYXVsdEF0dHJzID0gZGVmYXVsdEF0dHJzKHRoaXMuYXR0cnMpO1xuICAgICAgICB0aGlzLmNvbnRlbnRNYXRjaCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5saW5lQ29udGVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNCbG9jayA9ICEoc3BlYy5pbmxpbmUgfHwgbmFtZSA9PSBcInRleHRcIik7XG4gICAgICAgIHRoaXMuaXNUZXh0ID0gbmFtZSA9PSBcInRleHRcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB0aGlzIGlzIGFuIGlubGluZSB0eXBlLlxuICAgICovXG4gICAgZ2V0IGlzSW5saW5lKCkgeyByZXR1cm4gIXRoaXMuaXNCbG9jazsgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgdGhpcyBpcyBhIHRleHRibG9jayB0eXBlLCBhIGJsb2NrIHRoYXQgY29udGFpbnMgaW5saW5lXG4gICAgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc1RleHRibG9jaygpIHsgcmV0dXJuIHRoaXMuaXNCbG9jayAmJiB0aGlzLmlubGluZUNvbnRlbnQ7IH1cbiAgICAvKipcbiAgICBUcnVlIGZvciBub2RlIHR5cGVzIHRoYXQgYWxsb3cgbm8gY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc0xlYWYoKSB7IHJldHVybiB0aGlzLmNvbnRlbnRNYXRjaCA9PSBDb250ZW50TWF0Y2guZW1wdHk7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBub2RlIGlzIGFuIGF0b20sIGkuZS4gd2hlbiBpdCBkb2VzIG5vdCBoYXZlXG4gICAgZGlyZWN0bHkgZWRpdGFibGUgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc0F0b20oKSB7IHJldHVybiB0aGlzLmlzTGVhZiB8fCAhIXRoaXMuc3BlYy5hdG9tOyB9XG4gICAgLyoqXG4gICAgVGhlIG5vZGUgdHlwZSdzIFt3aGl0ZXNwYWNlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMud2hpdGVzcGFjZSkgb3B0aW9uLlxuICAgICovXG4gICAgZ2V0IHdoaXRlc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMud2hpdGVzcGFjZSB8fCAodGhpcy5zcGVjLmNvZGUgPyBcInByZVwiIDogXCJub3JtYWxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoaXMgbm9kZSB0eXBlIGhhcyBhbnkgcmVxdWlyZWQgYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIGhhc1JlcXVpcmVkQXR0cnMoKSB7XG4gICAgICAgIGZvciAobGV0IG4gaW4gdGhpcy5hdHRycylcbiAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzW25dLmlzUmVxdWlyZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBub2RlIGFsbG93cyBzb21lIG9mIHRoZSBzYW1lIGNvbnRlbnQgYXNcbiAgICB0aGUgZ2l2ZW4gbm9kZSB0eXBlLlxuICAgICovXG4gICAgY29tcGF0aWJsZUNvbnRlbnQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb250ZW50TWF0Y2guY29tcGF0aWJsZShvdGhlci5jb250ZW50TWF0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXB1dGVBdHRycyhhdHRycykge1xuICAgICAgICBpZiAoIWF0dHJzICYmIHRoaXMuZGVmYXVsdEF0dHJzKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEF0dHJzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gY29tcHV0ZUF0dHJzKHRoaXMuYXR0cnMsIGF0dHJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgYE5vZGVgIG9mIHRoaXMgdHlwZS4gVGhlIGdpdmVuIGF0dHJpYnV0ZXMgYXJlXG4gICAgY2hlY2tlZCBhbmQgZGVmYXVsdGVkICh5b3UgY2FuIHBhc3MgYG51bGxgIHRvIHVzZSB0aGUgdHlwZSdzXG4gICAgZGVmYXVsdHMgZW50aXJlbHksIGlmIG5vIHJlcXVpcmVkIGF0dHJpYnV0ZXMgZXhpc3QpLiBgY29udGVudGBcbiAgICBtYXkgYmUgYSBgRnJhZ21lbnRgLCBhIG5vZGUsIGFuIGFycmF5IG9mIG5vZGVzLCBvclxuICAgIGBudWxsYC4gU2ltaWxhcmx5IGBtYXJrc2AgbWF5IGJlIGBudWxsYCB0byBkZWZhdWx0IHRvIHRoZSBlbXB0eVxuICAgIHNldCBvZiBtYXJrcy5cbiAgICAqL1xuICAgIGNyZWF0ZShhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVGV4dClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGVUeXBlLmNyZWF0ZSBjYW4ndCBjb25zdHJ1Y3QgdGV4dCBub2Rlc1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKSwgRnJhZ21lbnQuZnJvbShjb250ZW50KSwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIExpa2UgW2BjcmVhdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVR5cGUuY3JlYXRlKSwgYnV0IGNoZWNrIHRoZSBnaXZlbiBjb250ZW50XG4gICAgYWdhaW5zdCB0aGUgbm9kZSB0eXBlJ3MgY29udGVudCByZXN0cmljdGlvbnMsIGFuZCB0aHJvdyBhbiBlcnJvclxuICAgIGlmIGl0IGRvZXNuJ3QgbWF0Y2guXG4gICAgKi9cbiAgICBjcmVhdGVDaGVja2VkKGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20oY29udGVudCk7XG4gICAgICAgIHRoaXMuY2hlY2tDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpLCBjb250ZW50LCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTGlrZSBbYGNyZWF0ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlVHlwZS5jcmVhdGUpLCBidXQgc2VlIGlmIGl0IGlzXG4gICAgbmVjZXNzYXJ5IHRvIGFkZCBub2RlcyB0byB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBnaXZlbiBmcmFnbWVudFxuICAgIHRvIG1ha2UgaXQgZml0IHRoZSBub2RlLiBJZiBubyBmaXR0aW5nIHdyYXBwaW5nIGNhbiBiZSBmb3VuZCxcbiAgICByZXR1cm4gbnVsbC4gTm90ZSB0aGF0LCBkdWUgdG8gdGhlIGZhY3QgdGhhdCByZXF1aXJlZCBub2RlcyBjYW5cbiAgICBhbHdheXMgYmUgY3JlYXRlZCwgdGhpcyB3aWxsIGFsd2F5cyBzdWNjZWVkIGlmIHlvdSBwYXNzIG51bGwgb3JcbiAgICBgRnJhZ21lbnQuZW1wdHlgIGFzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBjcmVhdGVBbmRGaWxsKGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgYXR0cnMgPSB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyk7XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKGNvbnRlbnQpO1xuICAgICAgICBpZiAoY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gdGhpcy5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShjb250ZW50KTtcbiAgICAgICAgICAgIGlmICghYmVmb3JlKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29udGVudCA9IGJlZm9yZS5hcHBlbmQoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hdGNoZWQgPSB0aGlzLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgICBsZXQgYWZ0ZXIgPSBtYXRjaGVkICYmIG1hdGNoZWQuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgICAgIGlmICghYWZ0ZXIpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIGF0dHJzLCBjb250ZW50LmFwcGVuZChhZnRlciksIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGZyYWdtZW50IGlzIHZhbGlkIGNvbnRlbnQgZm9yIHRoaXMgbm9kZVxuICAgIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIHZhbGlkQ29udGVudChjb250ZW50KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LnZhbGlkRW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQuY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmFsbG93c01hcmtzKGNvbnRlbnQuY2hpbGQoaSkubWFya3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRocm93cyBhIFJhbmdlRXJyb3IgaWYgdGhlIGdpdmVuIGZyYWdtZW50IGlzIG5vdCB2YWxpZCBjb250ZW50IGZvciB0aGlzXG4gICAgbm9kZSB0eXBlLlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hlY2tDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkQ29udGVudChjb250ZW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGNvbnRlbnQgZm9yIG5vZGUgJHt0aGlzLm5hbWV9OiAke2NvbnRlbnQudG9TdHJpbmcoKS5zbGljZSgwLCA1MCl9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIG1hcmsgdHlwZSBpcyBhbGxvd2VkIGluIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIGFsbG93c01hcmtUeXBlKG1hcmtUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtTZXQgPT0gbnVsbCB8fCB0aGlzLm1hcmtTZXQuaW5kZXhPZihtYXJrVHlwZSkgPiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MgYXJlIGFsbG93ZWQgaW4gdGhpcyBub2RlLlxuICAgICovXG4gICAgYWxsb3dzTWFya3MobWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya1NldCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dzTWFya1R5cGUobWFya3NbaV0udHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlcyB0aGUgbWFya3MgdGhhdCBhcmUgbm90IGFsbG93ZWQgaW4gdGhpcyBub2RlIGZyb20gdGhlIGdpdmVuIHNldC5cbiAgICAqL1xuICAgIGFsbG93ZWRNYXJrcyhtYXJrcykge1xuICAgICAgICBpZiAodGhpcy5tYXJrU2V0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgICAgIGxldCBjb3B5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dzTWFya1R5cGUobWFya3NbaV0udHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBtYXJrcy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgICAgICBjb3B5LnB1c2gobWFya3NbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhY29weSA/IG1hcmtzIDogY29weS5sZW5ndGggPyBjb3B5IDogTWFyay5ub25lO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjb21waWxlKG5vZGVzLCBzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIG5vZGVzLmZvckVhY2goKG5hbWUsIHNwZWMpID0+IHJlc3VsdFtuYW1lXSA9IG5ldyBOb2RlVHlwZShuYW1lLCBzY2hlbWEsIHNwZWMpKTtcbiAgICAgICAgbGV0IHRvcFR5cGUgPSBzY2hlbWEuc3BlYy50b3BOb2RlIHx8IFwiZG9jXCI7XG4gICAgICAgIGlmICghcmVzdWx0W3RvcFR5cGVdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTY2hlbWEgaXMgbWlzc2luZyBpdHMgdG9wIG5vZGUgdHlwZSAoJ1wiICsgdG9wVHlwZSArIFwiJylcIik7XG4gICAgICAgIGlmICghcmVzdWx0LnRleHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkV2ZXJ5IHNjaGVtYSBuZWVkcyBhICd0ZXh0JyB0eXBlXCIpO1xuICAgICAgICBmb3IgKGxldCBfIGluIHJlc3VsdC50ZXh0LmF0dHJzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgdGV4dCBub2RlIHR5cGUgc2hvdWxkIG5vdCBoYXZlIGF0dHJpYnV0ZXNcIik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8gQXR0cmlidXRlIGRlc2NyaXB0b3JzXG5jbGFzcyBBdHRyaWJ1dGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5oYXNEZWZhdWx0ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwiZGVmYXVsdFwiKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gb3B0aW9ucy5kZWZhdWx0O1xuICAgIH1cbiAgICBnZXQgaXNSZXF1aXJlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmhhc0RlZmF1bHQ7XG4gICAgfVxufVxuLy8gTWFya3Ncbi8qKlxuTGlrZSBub2RlcywgbWFya3MgKHdoaWNoIGFyZSBhc3NvY2lhdGVkIHdpdGggbm9kZXMgdG8gc2lnbmlmeVxudGhpbmdzIGxpa2UgZW1waGFzaXMgb3IgYmVpbmcgcGFydCBvZiBhIGxpbmspIGFyZVxuW3RhZ2dlZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmsudHlwZSkgd2l0aCB0eXBlIG9iamVjdHMsIHdoaWNoIGFyZVxuaW5zdGFudGlhdGVkIG9uY2UgcGVyIGBTY2hlbWFgLlxuKi9cbmNsYXNzIE1hcmtUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoZSBtYXJrIHR5cGUuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJhbmssIFxuICAgIC8qKlxuICAgIFRoZSBzY2hlbWEgdGhhdCB0aGlzIG1hcmsgdHlwZSBpbnN0YW5jZSBpcyBwYXJ0IG9mLlxuICAgICovXG4gICAgc2NoZW1hLCBcbiAgICAvKipcbiAgICBUaGUgc3BlYyBvbiB3aGljaCB0aGUgdHlwZSBpcyBiYXNlZC5cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5yYW5rID0gcmFuaztcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBpbml0QXR0cnMoc3BlYy5hdHRycyk7XG4gICAgICAgIHRoaXMuZXhjbHVkZWQgPSBudWxsO1xuICAgICAgICBsZXQgZGVmYXVsdHMgPSBkZWZhdWx0QXR0cnModGhpcy5hdHRycyk7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBkZWZhdWx0cyA/IG5ldyBNYXJrKHRoaXMsIGRlZmF1bHRzKSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmsgb2YgdGhpcyB0eXBlLiBgYXR0cnNgIG1heSBiZSBgbnVsbGAgb3IgYW4gb2JqZWN0XG4gICAgY29udGFpbmluZyBvbmx5IHNvbWUgb2YgdGhlIG1hcmsncyBhdHRyaWJ1dGVzLiBUaGUgb3RoZXJzLCBpZlxuICAgIHRoZXkgaGF2ZSBkZWZhdWx0cywgd2lsbCBiZSBhZGRlZC5cbiAgICAqL1xuICAgIGNyZWF0ZShhdHRycyA9IG51bGwpIHtcbiAgICAgICAgaWYgKCFhdHRycyAmJiB0aGlzLmluc3RhbmNlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gICAgICAgIHJldHVybiBuZXcgTWFyayh0aGlzLCBjb21wdXRlQXR0cnModGhpcy5hdHRycywgYXR0cnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY29tcGlsZShtYXJrcywgc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpLCByYW5rID0gMDtcbiAgICAgICAgbWFya3MuZm9yRWFjaCgobmFtZSwgc3BlYykgPT4gcmVzdWx0W25hbWVdID0gbmV3IE1hcmtUeXBlKG5hbWUsIHJhbmsrKywgc2NoZW1hLCBzcGVjKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZW4gdGhlcmUgaXMgYSBtYXJrIG9mIHRoaXMgdHlwZSBpbiB0aGUgZ2l2ZW4gc2V0LCBhIG5ldyBzZXRcbiAgICB3aXRob3V0IGl0IGlzIHJldHVybmVkLiBPdGhlcndpc2UsIHRoZSBpbnB1dCBzZXQgaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICByZW1vdmVGcm9tU2V0KHNldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChzZXRbaV0udHlwZSA9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgc2V0ID0gc2V0LnNsaWNlKDAsIGkpLmNvbmNhdChzZXQuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3RzIHdoZXRoZXIgdGhlcmUgaXMgYSBtYXJrIG9mIHRoaXMgdHlwZSBpbiB0aGUgZ2l2ZW4gc2V0LlxuICAgICovXG4gICAgaXNJblNldChzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoc2V0W2ldLnR5cGUgPT0gdGhpcylcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0W2ldO1xuICAgIH1cbiAgICAvKipcbiAgICBRdWVyaWVzIHdoZXRoZXIgYSBnaXZlbiBtYXJrIHR5cGUgaXNcbiAgICBbZXhjbHVkZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrU3BlYy5leGNsdWRlcykgYnkgdGhpcyBvbmUuXG4gICAgKi9cbiAgICBleGNsdWRlcyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5leGNsdWRlZC5pbmRleE9mKG90aGVyKSA+IC0xO1xuICAgIH1cbn1cbi8qKlxuQSBkb2N1bWVudCBzY2hlbWEuIEhvbGRzIFtub2RlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVR5cGUpIGFuZCBbbWFya1xudHlwZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtUeXBlKSBvYmplY3RzIGZvciB0aGUgbm9kZXMgYW5kIG1hcmtzIHRoYXQgbWF5XG5vY2N1ciBpbiBjb25mb3JtaW5nIGRvY3VtZW50cywgYW5kIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yXG5jcmVhdGluZyBhbmQgZGVzZXJpYWxpemluZyBzdWNoIGRvY3VtZW50cy5cblxuV2hlbiBnaXZlbiwgdGhlIHR5cGUgcGFyYW1ldGVycyBwcm92aWRlIHRoZSBuYW1lcyBvZiB0aGUgbm9kZXMgYW5kXG5tYXJrcyBpbiB0aGlzIHNjaGVtYS5cbiovXG5jbGFzcyBTY2hlbWEge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIHNjaGVtYSBmcm9tIGEgc2NoZW1hIFtzcGVjaWZpY2F0aW9uXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuU2NoZW1hU3BlYykuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIC8qKlxuICAgICAgICBBbiBvYmplY3QgZm9yIHN0b3Jpbmcgd2hhdGV2ZXIgdmFsdWVzIG1vZHVsZXMgbWF5IHdhbnQgdG9cbiAgICAgICAgY29tcHV0ZSBhbmQgY2FjaGUgcGVyIHNjaGVtYS4gKElmIHlvdSB3YW50IHRvIHN0b3JlIHNvbWV0aGluZ1xuICAgICAgICBpbiBpdCwgdHJ5IHRvIHVzZSBwcm9wZXJ0eSBuYW1lcyB1bmxpa2VseSB0byBjbGFzaC4pXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2FjaGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IGluc3RhbmNlU3BlYyA9IHRoaXMuc3BlYyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpXG4gICAgICAgICAgICBpbnN0YW5jZVNwZWNbcHJvcF0gPSBzcGVjW3Byb3BdO1xuICAgICAgICBpbnN0YW5jZVNwZWMubm9kZXMgPSBPcmRlcmVkTWFwLmZyb20oc3BlYy5ub2RlcyksXG4gICAgICAgICAgICBpbnN0YW5jZVNwZWMubWFya3MgPSBPcmRlcmVkTWFwLmZyb20oc3BlYy5tYXJrcyB8fCB7fSksXG4gICAgICAgICAgICB0aGlzLm5vZGVzID0gTm9kZVR5cGUuY29tcGlsZSh0aGlzLnNwZWMubm9kZXMsIHRoaXMpO1xuICAgICAgICB0aGlzLm1hcmtzID0gTWFya1R5cGUuY29tcGlsZSh0aGlzLnNwZWMubWFya3MsIHRoaXMpO1xuICAgICAgICBsZXQgY29udGVudEV4cHJDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gdGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKHByb3AgaW4gdGhpcy5tYXJrcylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihwcm9wICsgXCIgY2FuIG5vdCBiZSBib3RoIGEgbm9kZSBhbmQgYSBtYXJrXCIpO1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLm5vZGVzW3Byb3BdLCBjb250ZW50RXhwciA9IHR5cGUuc3BlYy5jb250ZW50IHx8IFwiXCIsIG1hcmtFeHByID0gdHlwZS5zcGVjLm1hcmtzO1xuICAgICAgICAgICAgdHlwZS5jb250ZW50TWF0Y2ggPSBjb250ZW50RXhwckNhY2hlW2NvbnRlbnRFeHByXSB8fFxuICAgICAgICAgICAgICAgIChjb250ZW50RXhwckNhY2hlW2NvbnRlbnRFeHByXSA9IENvbnRlbnRNYXRjaC5wYXJzZShjb250ZW50RXhwciwgdGhpcy5ub2RlcykpO1xuICAgICAgICAgICAgdHlwZS5pbmxpbmVDb250ZW50ID0gdHlwZS5jb250ZW50TWF0Y2guaW5saW5lQ29udGVudDtcbiAgICAgICAgICAgIHR5cGUubWFya1NldCA9IG1hcmtFeHByID09IFwiX1wiID8gbnVsbCA6XG4gICAgICAgICAgICAgICAgbWFya0V4cHIgPyBnYXRoZXJNYXJrcyh0aGlzLCBtYXJrRXhwci5zcGxpdChcIiBcIikpIDpcbiAgICAgICAgICAgICAgICAgICAgbWFya0V4cHIgPT0gXCJcIiB8fCAhdHlwZS5pbmxpbmVDb250ZW50ID8gW10gOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gdGhpcy5tYXJrcykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLm1hcmtzW3Byb3BdLCBleGNsID0gdHlwZS5zcGVjLmV4Y2x1ZGVzO1xuICAgICAgICAgICAgdHlwZS5leGNsdWRlZCA9IGV4Y2wgPT0gbnVsbCA/IFt0eXBlXSA6IGV4Y2wgPT0gXCJcIiA/IFtdIDogZ2F0aGVyTWFya3ModGhpcywgZXhjbC5zcGxpdChcIiBcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZUZyb21KU09OID0gdGhpcy5ub2RlRnJvbUpTT04uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tYXJrRnJvbUpTT04gPSB0aGlzLm1hcmtGcm9tSlNPTi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRvcE5vZGVUeXBlID0gdGhpcy5ub2Rlc1t0aGlzLnNwZWMudG9wTm9kZSB8fCBcImRvY1wiXTtcbiAgICAgICAgdGhpcy5jYWNoZWQud3JhcHBpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBpbiB0aGlzIHNjaGVtYS4gVGhlIGB0eXBlYCBtYXkgYmUgYSBzdHJpbmcgb3IgYVxuICAgIGBOb2RlVHlwZWAgaW5zdGFuY2UuIEF0dHJpYnV0ZXMgd2lsbCBiZSBleHRlbmRlZCB3aXRoIGRlZmF1bHRzLFxuICAgIGBjb250ZW50YCBtYXkgYmUgYSBgRnJhZ21lbnRgLCBgbnVsbGAsIGEgYE5vZGVgLCBvciBhbiBhcnJheSBvZlxuICAgIG5vZGVzLlxuICAgICovXG4gICAgbm9kZSh0eXBlLCBhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdHlwZSA9IHRoaXMubm9kZVR5cGUodHlwZSk7XG4gICAgICAgIGVsc2UgaWYgKCEodHlwZSBpbnN0YW5jZW9mIE5vZGVUeXBlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBub2RlIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUuc2NoZW1hICE9IHRoaXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vZGUgdHlwZSBmcm9tIGRpZmZlcmVudCBzY2hlbWEgdXNlZCAoXCIgKyB0eXBlLm5hbWUgKyBcIilcIik7XG4gICAgICAgIHJldHVybiB0eXBlLmNyZWF0ZUNoZWNrZWQoYXR0cnMsIGNvbnRlbnQsIG1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGV4dCBub2RlIGluIHRoZSBzY2hlbWEuIEVtcHR5IHRleHQgbm9kZXMgYXJlIG5vdFxuICAgIGFsbG93ZWQuXG4gICAgKi9cbiAgICB0ZXh0KHRleHQsIG1hcmtzKSB7XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5ub2Rlcy50ZXh0O1xuICAgICAgICByZXR1cm4gbmV3IFRleHROb2RlKHR5cGUsIHR5cGUuZGVmYXVsdEF0dHJzLCB0ZXh0LCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgbWFyayh0eXBlLCBhdHRycykge1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLm1hcmtzW3R5cGVdO1xuICAgICAgICByZXR1cm4gdHlwZS5jcmVhdGUoYXR0cnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG5vZGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gVGhpcyBtZXRob2QgaXNcbiAgICBib3VuZC5cbiAgICAqL1xuICAgIG5vZGVGcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBOb2RlLmZyb21KU09OKHRoaXMsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG1hcmsgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gVGhpcyBtZXRob2QgaXNcbiAgICBib3VuZC5cbiAgICAqL1xuICAgIG1hcmtGcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBNYXJrLmZyb21KU09OKHRoaXMsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG5vZGVUeXBlKG5hbWUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5ub2Rlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5rbm93biBub2RlIHR5cGU6IFwiICsgbmFtZSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG59XG5mdW5jdGlvbiBnYXRoZXJNYXJrcyhzY2hlbWEsIG1hcmtzKSB7XG4gICAgbGV0IGZvdW5kID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbmFtZSA9IG1hcmtzW2ldLCBtYXJrID0gc2NoZW1hLm1hcmtzW25hbWVdLCBvayA9IG1hcms7XG4gICAgICAgIGlmIChtYXJrKSB7XG4gICAgICAgICAgICBmb3VuZC5wdXNoKG1hcmspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBzY2hlbWEubWFya3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFyayA9IHNjaGVtYS5tYXJrc1twcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcIl9cIiB8fCAobWFyay5zcGVjLmdyb3VwICYmIG1hcmsuc3BlYy5ncm91cC5zcGxpdChcIiBcIikuaW5kZXhPZihuYW1lKSA+IC0xKSlcbiAgICAgICAgICAgICAgICAgICAgZm91bmQucHVzaChvayA9IG1hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghb2spXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJVbmtub3duIG1hcmsgdHlwZTogJ1wiICsgbWFya3NbaV0gKyBcIidcIik7XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cblxuLyoqXG5BIERPTSBwYXJzZXIgcmVwcmVzZW50cyBhIHN0cmF0ZWd5IGZvciBwYXJzaW5nIERPTSBjb250ZW50IGludG8gYVxuUHJvc2VNaXJyb3IgZG9jdW1lbnQgY29uZm9ybWluZyB0byBhIGdpdmVuIHNjaGVtYS4gSXRzIGJlaGF2aW9yIGlzXG5kZWZpbmVkIGJ5IGFuIGFycmF5IG9mIFtydWxlc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlBhcnNlUnVsZSkuXG4qL1xuY2xhc3MgRE9NUGFyc2VyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBwYXJzZXIgdGhhdCB0YXJnZXRzIHRoZSBnaXZlbiBzY2hlbWEsIHVzaW5nIHRoZSBnaXZlblxuICAgIHBhcnNpbmcgcnVsZXMuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc2NoZW1hIGludG8gd2hpY2ggdGhlIHBhcnNlciBwYXJzZXMuXG4gICAgKi9cbiAgICBzY2hlbWEsIFxuICAgIC8qKlxuICAgIFRoZSBzZXQgb2YgW3BhcnNlIHJ1bGVzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUGFyc2VSdWxlKSB0aGF0IHRoZSBwYXJzZXJcbiAgICB1c2VzLCBpbiBvcmRlciBvZiBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgcnVsZXMpIHtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhZ3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgaWYgKHJ1bGUudGFnKVxuICAgICAgICAgICAgICAgIHRoaXMudGFncy5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAocnVsZS5zdHlsZSlcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gT25seSBub3JtYWxpemUgbGlzdCBlbGVtZW50cyB3aGVuIGxpc3RzIGluIHRoZSBzY2hlbWEgY2FuJ3QgZGlyZWN0bHkgY29udGFpbiB0aGVtc2VsdmVzXG4gICAgICAgIHRoaXMubm9ybWFsaXplTGlzdHMgPSAhdGhpcy50YWdzLnNvbWUociA9PiB7XG4gICAgICAgICAgICBpZiAoIS9eKHVsfG9sKVxcYi8udGVzdChyLnRhZykgfHwgIXIubm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHNjaGVtYS5ub2Rlc1tyLm5vZGVdO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY29udGVudE1hdGNoLm1hdGNoVHlwZShub2RlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFBhcnNlIGEgZG9jdW1lbnQgZnJvbSB0aGUgY29udGVudCBvZiBhIERPTSBub2RlLlxuICAgICovXG4gICAgcGFyc2UoZG9tLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgUGFyc2VDb250ZXh0KHRoaXMsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgY29udGV4dC5hZGRBbGwoZG9tLCBvcHRpb25zLmZyb20sIG9wdGlvbnMudG8pO1xuICAgICAgICByZXR1cm4gY29udGV4dC5maW5pc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUGFyc2VzIHRoZSBjb250ZW50IG9mIHRoZSBnaXZlbiBET00gbm9kZSwgbGlrZVxuICAgIFtgcGFyc2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuRE9NUGFyc2VyLnBhcnNlKSwgYW5kIHRha2VzIHRoZSBzYW1lIHNldCBvZlxuICAgIG9wdGlvbnMuIEJ1dCB1bmxpa2UgdGhhdCBtZXRob2QsIHdoaWNoIHByb2R1Y2VzIGEgd2hvbGUgbm9kZSxcbiAgICB0aGlzIG9uZSByZXR1cm5zIGEgc2xpY2UgdGhhdCBpcyBvcGVuIGF0IHRoZSBzaWRlcywgbWVhbmluZyB0aGF0XG4gICAgdGhlIHNjaGVtYSBjb25zdHJhaW50cyBhcmVuJ3QgYXBwbGllZCB0byB0aGUgc3RhcnQgb2Ygbm9kZXMgdG9cbiAgICB0aGUgbGVmdCBvZiB0aGUgaW5wdXQgYW5kIHRoZSBlbmQgb2Ygbm9kZXMgYXQgdGhlIGVuZC5cbiAgICAqL1xuICAgIHBhcnNlU2xpY2UoZG9tLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgUGFyc2VDb250ZXh0KHRoaXMsIG9wdGlvbnMsIHRydWUpO1xuICAgICAgICBjb250ZXh0LmFkZEFsbChkb20sIG9wdGlvbnMuZnJvbSwgb3B0aW9ucy50byk7XG4gICAgICAgIHJldHVybiBTbGljZS5tYXhPcGVuKGNvbnRleHQuZmluaXNoKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hdGNoVGFnKGRvbSwgY29udGV4dCwgYWZ0ZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFmdGVyID8gdGhpcy50YWdzLmluZGV4T2YoYWZ0ZXIpICsgMSA6IDA7IGkgPCB0aGlzLnRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBydWxlID0gdGhpcy50YWdzW2ldO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXMoZG9tLCBydWxlLnRhZykgJiZcbiAgICAgICAgICAgICAgICAocnVsZS5uYW1lc3BhY2UgPT09IHVuZGVmaW5lZCB8fCBkb20ubmFtZXNwYWNlVVJJID09IHJ1bGUubmFtZXNwYWNlKSAmJlxuICAgICAgICAgICAgICAgICghcnVsZS5jb250ZXh0IHx8IGNvbnRleHQubWF0Y2hlc0NvbnRleHQocnVsZS5jb250ZXh0KSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5nZXRBdHRycykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcnVsZS5nZXRBdHRycyhkb20pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBydWxlLmF0dHJzID0gcmVzdWx0IHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXRjaFN0eWxlKHByb3AsIHZhbHVlLCBjb250ZXh0LCBhZnRlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gYWZ0ZXIgPyB0aGlzLnN0eWxlcy5pbmRleE9mKGFmdGVyKSArIDEgOiAwOyBpIDwgdGhpcy5zdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBydWxlID0gdGhpcy5zdHlsZXNbaV0sIHN0eWxlID0gcnVsZS5zdHlsZTtcbiAgICAgICAgICAgIGlmIChzdHlsZS5pbmRleE9mKHByb3ApICE9IDAgfHxcbiAgICAgICAgICAgICAgICBydWxlLmNvbnRleHQgJiYgIWNvbnRleHQubWF0Y2hlc0NvbnRleHQocnVsZS5jb250ZXh0KSB8fFxuICAgICAgICAgICAgICAgIC8vIFRlc3QgdGhhdCB0aGUgc3R5bGUgc3RyaW5nIGVpdGhlciBwcmVjaXNlbHkgbWF0Y2hlcyB0aGUgcHJvcCxcbiAgICAgICAgICAgICAgICAvLyBvciBoYXMgYW4gJz0nIHNpZ24gYWZ0ZXIgdGhlIHByb3AsIGZvbGxvd2VkIGJ5IHRoZSBnaXZlblxuICAgICAgICAgICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAgICAgICAgIHN0eWxlLmxlbmd0aCA+IHByb3AubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIChzdHlsZS5jaGFyQ29kZUF0KHByb3AubGVuZ3RoKSAhPSA2MSB8fCBzdHlsZS5zbGljZShwcm9wLmxlbmd0aCArIDEpICE9IHZhbHVlKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChydWxlLmdldEF0dHJzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJ1bGUuZ2V0QXR0cnModmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBydWxlLmF0dHJzID0gcmVzdWx0IHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydWxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHNjaGVtYVJ1bGVzKHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGluc2VydChydWxlKSB7XG4gICAgICAgICAgICBsZXQgcHJpb3JpdHkgPSBydWxlLnByaW9yaXR5ID09IG51bGwgPyA1MCA6IHJ1bGUucHJpb3JpdHksIGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHJlc3VsdFtpXSwgbmV4dFByaW9yaXR5ID0gbmV4dC5wcmlvcml0eSA9PSBudWxsID8gNTAgOiBuZXh0LnByaW9yaXR5O1xuICAgICAgICAgICAgICAgIGlmIChuZXh0UHJpb3JpdHkgPCBwcmlvcml0eSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuc3BsaWNlKGksIDAsIHJ1bGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gc2NoZW1hLm1hcmtzKSB7XG4gICAgICAgICAgICBsZXQgcnVsZXMgPSBzY2hlbWEubWFya3NbbmFtZV0uc3BlYy5wYXJzZURPTTtcbiAgICAgICAgICAgIGlmIChydWxlcylcbiAgICAgICAgICAgICAgICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQocnVsZSA9IGNvcHkocnVsZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShydWxlLm1hcmsgfHwgcnVsZS5pZ25vcmUgfHwgcnVsZS5jbGVhck1hcmspKVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5tYXJrID0gbmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHNjaGVtYS5ub2Rlcykge1xuICAgICAgICAgICAgbGV0IHJ1bGVzID0gc2NoZW1hLm5vZGVzW25hbWVdLnNwZWMucGFyc2VET007XG4gICAgICAgICAgICBpZiAocnVsZXMpXG4gICAgICAgICAgICAgICAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0KHJ1bGUgPSBjb3B5KHJ1bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocnVsZS5ub2RlIHx8IHJ1bGUuaWdub3JlIHx8IHJ1bGUubWFyaykpXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLm5vZGUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIERPTSBwYXJzZXIgdXNpbmcgdGhlIHBhcnNpbmcgcnVsZXMgbGlzdGVkIGluIGFcbiAgICBzY2hlbWEncyBbbm9kZSBzcGVjc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLnBhcnNlRE9NKSwgcmVvcmRlcmVkIGJ5XG4gICAgW3ByaW9yaXR5XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUGFyc2VSdWxlLnByaW9yaXR5KS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmNhY2hlZC5kb21QYXJzZXIgfHxcbiAgICAgICAgICAgIChzY2hlbWEuY2FjaGVkLmRvbVBhcnNlciA9IG5ldyBET01QYXJzZXIoc2NoZW1hLCBET01QYXJzZXIuc2NoZW1hUnVsZXMoc2NoZW1hKSkpO1xuICAgIH1cbn1cbmNvbnN0IGJsb2NrVGFncyA9IHtcbiAgICBhZGRyZXNzOiB0cnVlLCBhcnRpY2xlOiB0cnVlLCBhc2lkZTogdHJ1ZSwgYmxvY2txdW90ZTogdHJ1ZSwgY2FudmFzOiB0cnVlLFxuICAgIGRkOiB0cnVlLCBkaXY6IHRydWUsIGRsOiB0cnVlLCBmaWVsZHNldDogdHJ1ZSwgZmlnY2FwdGlvbjogdHJ1ZSwgZmlndXJlOiB0cnVlLFxuICAgIGZvb3RlcjogdHJ1ZSwgZm9ybTogdHJ1ZSwgaDE6IHRydWUsIGgyOiB0cnVlLCBoMzogdHJ1ZSwgaDQ6IHRydWUsIGg1OiB0cnVlLFxuICAgIGg2OiB0cnVlLCBoZWFkZXI6IHRydWUsIGhncm91cDogdHJ1ZSwgaHI6IHRydWUsIGxpOiB0cnVlLCBub3NjcmlwdDogdHJ1ZSwgb2w6IHRydWUsXG4gICAgb3V0cHV0OiB0cnVlLCBwOiB0cnVlLCBwcmU6IHRydWUsIHNlY3Rpb246IHRydWUsIHRhYmxlOiB0cnVlLCB0Zm9vdDogdHJ1ZSwgdWw6IHRydWVcbn07XG5jb25zdCBpZ25vcmVUYWdzID0ge1xuICAgIGhlYWQ6IHRydWUsIG5vc2NyaXB0OiB0cnVlLCBvYmplY3Q6IHRydWUsIHNjcmlwdDogdHJ1ZSwgc3R5bGU6IHRydWUsIHRpdGxlOiB0cnVlXG59O1xuY29uc3QgbGlzdFRhZ3MgPSB7IG9sOiB0cnVlLCB1bDogdHJ1ZSB9O1xuLy8gVXNpbmcgYSBiaXRmaWVsZCBmb3Igbm9kZSBjb250ZXh0IG9wdGlvbnNcbmNvbnN0IE9QVF9QUkVTRVJWRV9XUyA9IDEsIE9QVF9QUkVTRVJWRV9XU19GVUxMID0gMiwgT1BUX09QRU5fTEVGVCA9IDQ7XG5mdW5jdGlvbiB3c09wdGlvbnNGb3IodHlwZSwgcHJlc2VydmVXaGl0ZXNwYWNlLCBiYXNlKSB7XG4gICAgaWYgKHByZXNlcnZlV2hpdGVzcGFjZSAhPSBudWxsKVxuICAgICAgICByZXR1cm4gKHByZXNlcnZlV2hpdGVzcGFjZSA/IE9QVF9QUkVTRVJWRV9XUyA6IDApIHxcbiAgICAgICAgICAgIChwcmVzZXJ2ZVdoaXRlc3BhY2UgPT09IFwiZnVsbFwiID8gT1BUX1BSRVNFUlZFX1dTX0ZVTEwgOiAwKTtcbiAgICByZXR1cm4gdHlwZSAmJiB0eXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIiA/IE9QVF9QUkVTRVJWRV9XUyB8IE9QVF9QUkVTRVJWRV9XU19GVUxMIDogYmFzZSAmIH5PUFRfT1BFTl9MRUZUO1xufVxuY2xhc3MgTm9kZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGF0dHJzLCBcbiAgICAvLyBNYXJrcyBhcHBsaWVkIHRvIHRoaXMgbm9kZSBpdHNlbGZcbiAgICBtYXJrcywgXG4gICAgLy8gTWFya3MgdGhhdCBjYW4ndCBhcHBseSBoZXJlLCBidXQgd2lsbCBiZSB1c2VkIGluIGNoaWxkcmVuIGlmIHBvc3NpYmxlXG4gICAgcGVuZGluZ01hcmtzLCBzb2xpZCwgbWF0Y2gsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgICAgIHRoaXMucGVuZGluZ01hcmtzID0gcGVuZGluZ01hcmtzO1xuICAgICAgICB0aGlzLnNvbGlkID0gc29saWQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29udGVudCA9IFtdO1xuICAgICAgICAvLyBNYXJrcyBhcHBsaWVkIHRvIHRoZSBub2RlJ3MgY2hpbGRyZW5cbiAgICAgICAgdGhpcy5hY3RpdmVNYXJrcyA9IE1hcmsubm9uZTtcbiAgICAgICAgLy8gTmVzdGVkIE1hcmtzIHdpdGggc2FtZSB0eXBlXG4gICAgICAgIHRoaXMuc3Rhc2hNYXJrcyA9IFtdO1xuICAgICAgICB0aGlzLm1hdGNoID0gbWF0Y2ggfHwgKG9wdGlvbnMgJiBPUFRfT1BFTl9MRUZUID8gbnVsbCA6IHR5cGUuY29udGVudE1hdGNoKTtcbiAgICB9XG4gICAgZmluZFdyYXBwaW5nKG5vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hdGNoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICBsZXQgZmlsbCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5mcm9tKG5vZGUpKTtcbiAgICAgICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChmaWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2gsIHdyYXA7XG4gICAgICAgICAgICAgICAgaWYgKHdyYXAgPSBzdGFydC5maW5kV3JhcHBpbmcobm9kZS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoLmZpbmRXcmFwcGluZyhub2RlLnR5cGUpO1xuICAgIH1cbiAgICBmaW5pc2gob3BlbkVuZCkge1xuICAgICAgICBpZiAoISh0aGlzLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1MpKSB7IC8vIFN0cmlwIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSwgbTtcbiAgICAgICAgICAgIGlmIChsYXN0ICYmIGxhc3QuaXNUZXh0ICYmIChtID0gL1sgXFx0XFxyXFxuXFx1MDAwY10rJC8uZXhlYyhsYXN0LnRleHQpKSkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gbGFzdDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdC50ZXh0Lmxlbmd0aCA9PSBtWzBdLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LnBvcCgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSA9IHRleHQud2l0aFRleHQodGV4dC50ZXh0LnNsaWNlKDAsIHRleHQudGV4dC5sZW5ndGggLSBtWzBdLmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh0aGlzLmNvbnRlbnQpO1xuICAgICAgICBpZiAoIW9wZW5FbmQgJiYgdGhpcy5tYXRjaClcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LmFwcGVuZCh0aGlzLm1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA/IHRoaXMudHlwZS5jcmVhdGUodGhpcy5hdHRycywgY29udGVudCwgdGhpcy5tYXJrcykgOiBjb250ZW50O1xuICAgIH1cbiAgICBwb3BGcm9tU3Rhc2hNYXJrKG1hcmspIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3Rhc2hNYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGlmIChtYXJrLmVxKHRoaXMuc3Rhc2hNYXJrc1tpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3Rhc2hNYXJrcy5zcGxpY2UoaSwgMSlbMF07XG4gICAgfVxuICAgIGFwcGx5UGVuZGluZyhuZXh0VHlwZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcGVuZGluZyA9IHRoaXMucGVuZGluZ01hcmtzOyBpIDwgcGVuZGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcmsgPSBwZW5kaW5nW2ldO1xuICAgICAgICAgICAgaWYgKCh0aGlzLnR5cGUgPyB0aGlzLnR5cGUuYWxsb3dzTWFya1R5cGUobWFyay50eXBlKSA6IG1hcmtNYXlBcHBseShtYXJrLnR5cGUsIG5leHRUeXBlKSkgJiZcbiAgICAgICAgICAgICAgICAhbWFyay5pc0luU2V0KHRoaXMuYWN0aXZlTWFya3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVNYXJrcyA9IG1hcmsuYWRkVG9TZXQodGhpcy5hY3RpdmVNYXJrcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWFya3MgPSBtYXJrLnJlbW92ZUZyb21TZXQodGhpcy5wZW5kaW5nTWFya3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlubGluZUNvbnRleHQobm9kZSkge1xuICAgICAgICBpZiAodGhpcy50eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5pbmxpbmVDb250ZW50O1xuICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRbMF0uaXNJbmxpbmU7XG4gICAgICAgIHJldHVybiBub2RlLnBhcmVudE5vZGUgJiYgIWJsb2NrVGFncy5oYXNPd25Qcm9wZXJ0eShub2RlLnBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxufVxuY2xhc3MgUGFyc2VDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgcGFyc2VyIHdlIGFyZSB1c2luZy5cbiAgICBwYXJzZXIsIFxuICAgIC8vIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGlzIHBhcnNlLlxuICAgIG9wdGlvbnMsIGlzT3Blbikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pc09wZW4gPSBpc09wZW47XG4gICAgICAgIHRoaXMub3BlbiA9IDA7XG4gICAgICAgIGxldCB0b3BOb2RlID0gb3B0aW9ucy50b3BOb2RlLCB0b3BDb250ZXh0O1xuICAgICAgICBsZXQgdG9wT3B0aW9ucyA9IHdzT3B0aW9uc0ZvcihudWxsLCBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSwgMCkgfCAoaXNPcGVuID8gT1BUX09QRU5fTEVGVCA6IDApO1xuICAgICAgICBpZiAodG9wTm9kZSlcbiAgICAgICAgICAgIHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQodG9wTm9kZS50eXBlLCB0b3BOb2RlLmF0dHJzLCBNYXJrLm5vbmUsIE1hcmsubm9uZSwgdHJ1ZSwgb3B0aW9ucy50b3BNYXRjaCB8fCB0b3BOb2RlLnR5cGUuY29udGVudE1hdGNoLCB0b3BPcHRpb25zKTtcbiAgICAgICAgZWxzZSBpZiAoaXNPcGVuKVxuICAgICAgICAgICAgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dChudWxsLCBudWxsLCBNYXJrLm5vbmUsIE1hcmsubm9uZSwgdHJ1ZSwgbnVsbCwgdG9wT3B0aW9ucyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQocGFyc2VyLnNjaGVtYS50b3BOb2RlVHlwZSwgbnVsbCwgTWFyay5ub25lLCBNYXJrLm5vbmUsIHRydWUsIG51bGwsIHRvcE9wdGlvbnMpO1xuICAgICAgICB0aGlzLm5vZGVzID0gW3RvcENvbnRleHRdO1xuICAgICAgICB0aGlzLmZpbmQgPSBvcHRpb25zLmZpbmRQb3NpdGlvbnM7XG4gICAgICAgIHRoaXMubmVlZHNCbG9jayA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgdG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1t0aGlzLm9wZW5dO1xuICAgIH1cbiAgICAvLyBBZGQgYSBET00gbm9kZSB0byB0aGUgY29udGVudC4gVGV4dCBpcyBpbnNlcnRlZCBhcyB0ZXh0IG5vZGUsXG4gICAgLy8gb3RoZXJ3aXNlLCB0aGUgbm9kZSBpcyBwYXNzZWQgdG8gYGFkZEVsZW1lbnRgIG9yLCBpZiBpdCBoYXMgYVxuICAgIC8vIGBzdHlsZWAgYXR0cmlidXRlLCBgYWRkRWxlbWVudFdpdGhTdHlsZXNgLlxuICAgIGFkZERPTShkb20pIHtcbiAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgdGhpcy5hZGRUZXh0Tm9kZShkb20pO1xuICAgICAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudChkb20pO1xuICAgIH1cbiAgICB3aXRoU3R5bGVSdWxlcyhkb20sIGYpIHtcbiAgICAgICAgbGV0IHN0eWxlID0gZG9tLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgICAgICBpZiAoIXN0eWxlKVxuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgbGV0IG1hcmtzID0gdGhpcy5yZWFkU3R5bGVzKHBhcnNlU3R5bGVzKHN0eWxlKSk7XG4gICAgICAgIGlmICghbWFya3MpXG4gICAgICAgICAgICByZXR1cm47IC8vIEEgc3R5bGUgd2l0aCBpZ25vcmU6IHRydWVcbiAgICAgICAgbGV0IFthZGRNYXJrcywgcmVtb3ZlTWFya3NdID0gbWFya3MsIHRvcCA9IHRoaXMudG9wO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZU1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVQZW5kaW5nTWFyayhyZW1vdmVNYXJrc1tpXSwgdG9wKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuYWRkUGVuZGluZ01hcmsoYWRkTWFya3NbaV0pO1xuICAgICAgICBmKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkTWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBlbmRpbmdNYXJrKGFkZE1hcmtzW2ldLCB0b3ApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZU1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5hZGRQZW5kaW5nTWFyayhyZW1vdmVNYXJrc1tpXSk7XG4gICAgfVxuICAgIGFkZFRleHROb2RlKGRvbSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBkb20ubm9kZVZhbHVlO1xuICAgICAgICBsZXQgdG9wID0gdGhpcy50b3A7XG4gICAgICAgIGlmICh0b3Aub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XU19GVUxMIHx8XG4gICAgICAgICAgICB0b3AuaW5saW5lQ29udGV4dChkb20pIHx8XG4gICAgICAgICAgICAvW14gXFx0XFxyXFxuXFx1MDAwY10vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoISh0b3Aub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XUykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1sgXFx0XFxyXFxuXFx1MDAwY10rL2csIFwiIFwiKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIHN0YXJ0cyB3aXRoIHdoaXRlc3BhY2UsIGFuZCB0aGVyZSBpcyBubyBub2RlIGJlZm9yZSBpdCwgb3JcbiAgICAgICAgICAgICAgICAvLyBhIGhhcmQgYnJlYWssIG9yIGEgdGV4dCBub2RlIHRoYXQgZW5kcyB3aXRoIHdoaXRlc3BhY2UsIHN0cmlwIHRoZVxuICAgICAgICAgICAgICAgIC8vIGxlYWRpbmcgc3BhY2UuXG4gICAgICAgICAgICAgICAgaWYgKC9eWyBcXHRcXHJcXG5cXHUwMDBjXS8udGVzdCh2YWx1ZSkgJiYgdGhpcy5vcGVuID09IHRoaXMubm9kZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZUJlZm9yZSA9IHRvcC5jb250ZW50W3RvcC5jb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZG9tTm9kZUJlZm9yZSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZUJlZm9yZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGRvbU5vZGVCZWZvcmUgJiYgZG9tTm9kZUJlZm9yZS5ub2RlTmFtZSA9PSAnQlInKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGVCZWZvcmUuaXNUZXh0ICYmIC9bIFxcdFxcclxcblxcdTAwMGNdJC8udGVzdChub2RlQmVmb3JlLnRleHQpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoISh0b3Aub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XU19GVUxMKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxyP1xcbnxcXHIvZywgXCIgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0Tm9kZSh0aGlzLnBhcnNlci5zY2hlbWEudGV4dCh2YWx1ZSkpO1xuICAgICAgICAgICAgdGhpcy5maW5kSW5UZXh0KGRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gZmluZCBhIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiB0YWcgYW5kIHVzZSB0aGF0IHRvIHBhcnNlLiBJZlxuICAgIC8vIG5vbmUgaXMgZm91bmQsIHRoZSBlbGVtZW50J3MgY29udGVudCBub2RlcyBhcmUgYWRkZWQgZGlyZWN0bHkuXG4gICAgYWRkRWxlbWVudChkb20sIG1hdGNoQWZ0ZXIpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBkb20ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgcnVsZUlEO1xuICAgICAgICBpZiAobGlzdFRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgdGhpcy5wYXJzZXIubm9ybWFsaXplTGlzdHMpXG4gICAgICAgICAgICBub3JtYWxpemVMaXN0KGRvbSk7XG4gICAgICAgIGxldCBydWxlID0gKHRoaXMub3B0aW9ucy5ydWxlRnJvbU5vZGUgJiYgdGhpcy5vcHRpb25zLnJ1bGVGcm9tTm9kZShkb20pKSB8fFxuICAgICAgICAgICAgKHJ1bGVJRCA9IHRoaXMucGFyc2VyLm1hdGNoVGFnKGRvbSwgdGhpcywgbWF0Y2hBZnRlcikpO1xuICAgICAgICBpZiAocnVsZSA/IHJ1bGUuaWdub3JlIDogaWdub3JlVGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZUZhbGxiYWNrKGRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXJ1bGUgfHwgcnVsZS5za2lwIHx8IHJ1bGUuY2xvc2VQYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChydWxlICYmIHJ1bGUuY2xvc2VQYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuID0gTWF0aC5tYXgoMCwgdGhpcy5vcGVuIC0gMSk7XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlICYmIHJ1bGUuc2tpcC5ub2RlVHlwZSlcbiAgICAgICAgICAgICAgICBkb20gPSBydWxlLnNraXA7XG4gICAgICAgICAgICBsZXQgc3luYywgdG9wID0gdGhpcy50b3AsIG9sZE5lZWRzQmxvY2sgPSB0aGlzLm5lZWRzQmxvY2s7XG4gICAgICAgICAgICBpZiAoYmxvY2tUYWdzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvcC5jb250ZW50Lmxlbmd0aCAmJiB0b3AuY29udGVudFswXS5pc0lubGluZSAmJiB0aGlzLm9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuLS07XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IHRoaXMudG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRvcC50eXBlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5lZWRzQmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWRvbS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWFmRmFsbGJhY2soZG9tKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnVsZSAmJiBydWxlLnNraXApXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBbGwoZG9tKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLndpdGhTdHlsZVJ1bGVzKGRvbSwgKCkgPT4gdGhpcy5hZGRBbGwoZG9tKSk7XG4gICAgICAgICAgICBpZiAoc3luYylcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmModG9wKTtcbiAgICAgICAgICAgIHRoaXMubmVlZHNCbG9jayA9IG9sZE5lZWRzQmxvY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndpdGhTdHlsZVJ1bGVzKGRvbSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudEJ5UnVsZShkb20sIHJ1bGUsIHJ1bGUuY29uc3VtaW5nID09PSBmYWxzZSA/IHJ1bGVJRCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDYWxsZWQgZm9yIGxlYWYgRE9NIG5vZGVzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGJlIGlnbm9yZWRcbiAgICBsZWFmRmFsbGJhY2soZG9tKSB7XG4gICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmIHRoaXMudG9wLnR5cGUgJiYgdGhpcy50b3AudHlwZS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgdGhpcy5hZGRUZXh0Tm9kZShkb20ub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblwiKSk7XG4gICAgfVxuICAgIC8vIENhbGxlZCBmb3IgaWdub3JlZCBub2Rlc1xuICAgIGlnbm9yZUZhbGxiYWNrKGRvbSkge1xuICAgICAgICAvLyBJZ25vcmVkIEJSIG5vZGVzIHNob3VsZCBhdCBsZWFzdCBjcmVhdGUgYW4gaW5saW5lIGNvbnRleHRcbiAgICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgKCF0aGlzLnRvcC50eXBlIHx8ICF0aGlzLnRvcC50eXBlLmlubGluZUNvbnRlbnQpKVxuICAgICAgICAgICAgdGhpcy5maW5kUGxhY2UodGhpcy5wYXJzZXIuc2NoZW1hLnRleHQoXCItXCIpKTtcbiAgICB9XG4gICAgLy8gUnVuIGFueSBzdHlsZSBwYXJzZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBub2RlJ3Mgc3R5bGVzLiBFaXRoZXJcbiAgICAvLyByZXR1cm4gYW4gYXJyYXkgb2YgbWFya3MsIG9yIG51bGwgdG8gaW5kaWNhdGUgc29tZSBvZiB0aGUgc3R5bGVzXG4gICAgLy8gaGFkIGEgcnVsZSB3aXRoIGBpZ25vcmVgIHNldC5cbiAgICByZWFkU3R5bGVzKHN0eWxlcykge1xuICAgICAgICBsZXQgYWRkID0gTWFyay5ub25lLCByZW1vdmUgPSBNYXJrLm5vbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBhZnRlciA9IHVuZGVmaW5lZDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnBhcnNlci5tYXRjaFN0eWxlKHN0eWxlc1tpXSwgc3R5bGVzW2kgKyAxXSwgdGhpcywgYWZ0ZXIpO1xuICAgICAgICAgICAgICAgIGlmICghcnVsZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuaWdub3JlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5jbGVhck1hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3AucGVuZGluZ01hcmtzLmNvbmNhdCh0aGlzLnRvcC5hY3RpdmVNYXJrcykuZm9yRWFjaChtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLmNsZWFyTWFyayhtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUgPSBtLmFkZFRvU2V0KHJlbW92ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkID0gdGhpcy5wYXJzZXIuc2NoZW1hLm1hcmtzW3J1bGUubWFya10uY3JlYXRlKHJ1bGUuYXR0cnMpLmFkZFRvU2V0KGFkZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydWxlLmNvbnN1bWluZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyID0gcnVsZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbYWRkLCByZW1vdmVdO1xuICAgIH1cbiAgICAvLyBMb29rIHVwIGEgaGFuZGxlciBmb3IgdGhlIGdpdmVuIG5vZGUuIElmIG5vbmUgYXJlIGZvdW5kLCByZXR1cm5cbiAgICAvLyBmYWxzZS4gT3RoZXJ3aXNlLCBhcHBseSBpdCwgdXNlIGl0cyByZXR1cm4gdmFsdWUgdG8gZHJpdmUgdGhlIHdheVxuICAgIC8vIHRoZSBub2RlJ3MgY29udGVudCBpcyB3cmFwcGVkLCBhbmQgcmV0dXJuIHRydWUuXG4gICAgYWRkRWxlbWVudEJ5UnVsZShkb20sIHJ1bGUsIGNvbnRpbnVlQWZ0ZXIpIHtcbiAgICAgICAgbGV0IHN5bmMsIG5vZGVUeXBlLCBtYXJrO1xuICAgICAgICBpZiAocnVsZS5ub2RlKSB7XG4gICAgICAgICAgICBub2RlVHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlc1tydWxlLm5vZGVdO1xuICAgICAgICAgICAgaWYgKCFub2RlVHlwZS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICBzeW5jID0gdGhpcy5lbnRlcihub2RlVHlwZSwgcnVsZS5hdHRycyB8fCBudWxsLCBydWxlLnByZXNlcnZlV2hpdGVzcGFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5pbnNlcnROb2RlKG5vZGVUeXBlLmNyZWF0ZShydWxlLmF0dHJzKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlYWZGYWxsYmFjayhkb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1hcmtUeXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm1hcmtzW3J1bGUubWFya107XG4gICAgICAgICAgICBtYXJrID0gbWFya1R5cGUuY3JlYXRlKHJ1bGUuYXR0cnMpO1xuICAgICAgICAgICAgdGhpcy5hZGRQZW5kaW5nTWFyayhtYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRJbiA9IHRoaXMudG9wO1xuICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUuaXNMZWFmKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250aW51ZUFmdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnQoZG9tLCBjb250aW51ZUFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydWxlLmdldENvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICAgICAgcnVsZS5nZXRDb250ZW50KGRvbSwgdGhpcy5wYXJzZXIuc2NoZW1hKS5mb3JFYWNoKG5vZGUgPT4gdGhpcy5pbnNlcnROb2RlKG5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50RE9NID0gZG9tO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBydWxlLmNvbnRlbnRFbGVtZW50ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgY29udGVudERPTSA9IGRvbS5xdWVyeVNlbGVjdG9yKHJ1bGUuY29udGVudEVsZW1lbnQpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJ1bGUuY29udGVudEVsZW1lbnQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBydWxlLmNvbnRlbnRFbGVtZW50KGRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlLmNvbnRlbnRFbGVtZW50KVxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBydWxlLmNvbnRlbnRFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5maW5kQXJvdW5kKGRvbSwgY29udGVudERPTSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmFkZEFsbChjb250ZW50RE9NKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3luYyAmJiB0aGlzLnN5bmMoc3RhcnRJbikpXG4gICAgICAgICAgICB0aGlzLm9wZW4tLTtcbiAgICAgICAgaWYgKG1hcmspXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBlbmRpbmdNYXJrKG1hcmssIHN0YXJ0SW4pO1xuICAgIH1cbiAgICAvLyBBZGQgYWxsIGNoaWxkIG5vZGVzIGJldHdlZW4gYHN0YXJ0SW5kZXhgIGFuZCBgZW5kSW5kZXhgIChvciB0aGVcbiAgICAvLyB3aG9sZSBub2RlLCBpZiBub3QgZ2l2ZW4pLiBJZiBgc3luY2AgaXMgcGFzc2VkLCB1c2UgaXQgdG9cbiAgICAvLyBzeW5jaHJvbml6ZSBhZnRlciBldmVyeSBibG9jayBlbGVtZW50LlxuICAgIGFkZEFsbChwYXJlbnQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHN0YXJ0SW5kZXggfHwgMDtcbiAgICAgICAgZm9yIChsZXQgZG9tID0gc3RhcnRJbmRleCA/IHBhcmVudC5jaGlsZE5vZGVzW3N0YXJ0SW5kZXhdIDogcGFyZW50LmZpcnN0Q2hpbGQsIGVuZCA9IGVuZEluZGV4ID09IG51bGwgPyBudWxsIDogcGFyZW50LmNoaWxkTm9kZXNbZW5kSW5kZXhdOyBkb20gIT0gZW5kOyBkb20gPSBkb20ubmV4dFNpYmxpbmcsICsraW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEF0UG9pbnQocGFyZW50LCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLmFkZERPTShkb20pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluZEF0UG9pbnQocGFyZW50LCBpbmRleCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byBmaW5kIGEgd2F5IHRvIGZpdCB0aGUgZ2l2ZW4gbm9kZSB0eXBlIGludG8gdGhlIGN1cnJlbnRcbiAgICAvLyBjb250ZXh0LiBNYXkgYWRkIGludGVybWVkaWF0ZSB3cmFwcGVycyBhbmQvb3IgbGVhdmUgbm9uLXNvbGlkXG4gICAgLy8gbm9kZXMgdGhhdCB3ZSdyZSBpbi5cbiAgICBmaW5kUGxhY2Uobm9kZSkge1xuICAgICAgICBsZXQgcm91dGUsIHN5bmM7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gdGhpcy5vcGVuOyBkZXB0aCA+PSAwOyBkZXB0aC0tKSB7XG4gICAgICAgICAgICBsZXQgY3ggPSB0aGlzLm5vZGVzW2RlcHRoXTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGN4LmZpbmRXcmFwcGluZyhub2RlKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCAmJiAoIXJvdXRlIHx8IHJvdXRlLmxlbmd0aCA+IGZvdW5kLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICByb3V0ZSA9IGZvdW5kO1xuICAgICAgICAgICAgICAgIHN5bmMgPSBjeDtcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3guc29saWQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyb3V0ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5zeW5jKHN5bmMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5lbnRlcklubmVyKHJvdXRlW2ldLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gaW5zZXJ0IHRoZSBnaXZlbiBub2RlLCBhZGp1c3RpbmcgdGhlIGNvbnRleHQgd2hlbiBuZWVkZWQuXG4gICAgaW5zZXJ0Tm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmlzSW5saW5lICYmIHRoaXMubmVlZHNCbG9jayAmJiAhdGhpcy50b3AudHlwZSkge1xuICAgICAgICAgICAgbGV0IGJsb2NrID0gdGhpcy50ZXh0YmxvY2tGcm9tQ29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKGJsb2NrKVxuICAgICAgICAgICAgICAgIHRoaXMuZW50ZXJJbm5lcihibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmluZFBsYWNlKG5vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgICAgIHRvcC5hcHBseVBlbmRpbmcobm9kZS50eXBlKTtcbiAgICAgICAgICAgIGlmICh0b3AubWF0Y2gpXG4gICAgICAgICAgICAgICAgdG9wLm1hdGNoID0gdG9wLm1hdGNoLm1hdGNoVHlwZShub2RlLnR5cGUpO1xuICAgICAgICAgICAgbGV0IG1hcmtzID0gdG9wLmFjdGl2ZU1hcmtzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLm1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmICghdG9wLnR5cGUgfHwgdG9wLnR5cGUuYWxsb3dzTWFya1R5cGUobm9kZS5tYXJrc1tpXS50eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgbWFya3MgPSBub2RlLm1hcmtzW2ldLmFkZFRvU2V0KG1hcmtzKTtcbiAgICAgICAgICAgIHRvcC5jb250ZW50LnB1c2gobm9kZS5tYXJrKG1hcmtzKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFRyeSB0byBzdGFydCBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUsIGFkanVzdGluZyB0aGUgY29udGV4dCB3aGVuXG4gICAgLy8gbmVjZXNzYXJ5LlxuICAgIGVudGVyKHR5cGUsIGF0dHJzLCBwcmVzZXJ2ZVdTKSB7XG4gICAgICAgIGxldCBvayA9IHRoaXMuZmluZFBsYWNlKHR5cGUuY3JlYXRlKGF0dHJzKSk7XG4gICAgICAgIGlmIChvaylcbiAgICAgICAgICAgIHRoaXMuZW50ZXJJbm5lcih0eXBlLCBhdHRycywgdHJ1ZSwgcHJlc2VydmVXUyk7XG4gICAgICAgIHJldHVybiBvaztcbiAgICB9XG4gICAgLy8gT3BlbiBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGVcbiAgICBlbnRlcklubmVyKHR5cGUsIGF0dHJzID0gbnVsbCwgc29saWQgPSBmYWxzZSwgcHJlc2VydmVXUykge1xuICAgICAgICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgICB0b3AuYXBwbHlQZW5kaW5nKHR5cGUpO1xuICAgICAgICB0b3AubWF0Y2ggPSB0b3AubWF0Y2ggJiYgdG9wLm1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB3c09wdGlvbnNGb3IodHlwZSwgcHJlc2VydmVXUywgdG9wLm9wdGlvbnMpO1xuICAgICAgICBpZiAoKHRvcC5vcHRpb25zICYgT1BUX09QRU5fTEVGVCkgJiYgdG9wLmNvbnRlbnQubGVuZ3RoID09IDApXG4gICAgICAgICAgICBvcHRpb25zIHw9IE9QVF9PUEVOX0xFRlQ7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgTm9kZUNvbnRleHQodHlwZSwgYXR0cnMsIHRvcC5hY3RpdmVNYXJrcywgdG9wLnBlbmRpbmdNYXJrcywgc29saWQsIG51bGwsIG9wdGlvbnMpKTtcbiAgICAgICAgdGhpcy5vcGVuKys7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBhbGwgbm9kZXMgYWJvdmUgdGhpcy5vcGVuIGFyZSBmaW5pc2hlZCBhbmQgYWRkZWQgdG9cbiAgICAvLyB0aGVpciBwYXJlbnRzXG4gICAgY2xvc2VFeHRyYShvcGVuRW5kID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpID4gdGhpcy5vcGVuKSB7XG4gICAgICAgICAgICBmb3IgKDsgaSA+IHRoaXMub3BlbjsgaS0tKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXNbaSAtIDFdLmNvbnRlbnQucHVzaCh0aGlzLm5vZGVzW2ldLmZpbmlzaChvcGVuRW5kKSk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLmxlbmd0aCA9IHRoaXMub3BlbiArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICB0aGlzLm9wZW4gPSAwO1xuICAgICAgICB0aGlzLmNsb3NlRXh0cmEodGhpcy5pc09wZW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXS5maW5pc2godGhpcy5pc09wZW4gfHwgdGhpcy5vcHRpb25zLnRvcE9wZW4pO1xuICAgIH1cbiAgICBzeW5jKHRvKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLm9wZW47IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbaV0gPT0gdG8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4gPSBpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBjdXJyZW50UG9zKCkge1xuICAgICAgICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLm9wZW47IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IHRoaXMubm9kZXNbaV0uY29udGVudDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBjb250ZW50Lmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuICAgICAgICAgICAgICAgIHBvcyArPSBjb250ZW50W2pdLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgZmluZEF0UG9pbnQocGFyZW50LCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5ub2RlID09IHBhcmVudCAmJiB0aGlzLmZpbmRbaV0ub2Zmc2V0ID09IG9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZmluZEluc2lkZShwYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5wb3MgPT0gbnVsbCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMSAmJiBwYXJlbnQuY29udGFpbnModGhpcy5maW5kW2ldLm5vZGUpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kQXJvdW5kKHBhcmVudCwgY29udGVudCwgYmVmb3JlKSB7XG4gICAgICAgIGlmIChwYXJlbnQgIT0gY29udGVudCAmJiB0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ucG9zID09IG51bGwgJiYgcGFyZW50Lm5vZGVUeXBlID09IDEgJiYgcGFyZW50LmNvbnRhaW5zKHRoaXMuZmluZFtpXS5ub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9zID0gY29udGVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0aGlzLmZpbmRbaV0ubm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgJiAoYmVmb3JlID8gMiA6IDQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRJblRleHQodGV4dE5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5ub2RlID09IHRleHROb2RlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zIC0gKHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGggLSB0aGlzLmZpbmRbaV0ub2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBjb250ZXh0IHN0cmluZyBtYXRjaGVzIHRoaXMgY29udGV4dC5cbiAgICBtYXRjaGVzQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmluZGV4T2YoXCJ8XCIpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5zcGxpdCgvXFxzKlxcfFxccyovKS5zb21lKHRoaXMubWF0Y2hlc0NvbnRleHQsIHRoaXMpO1xuICAgICAgICBsZXQgcGFydHMgPSBjb250ZXh0LnNwbGl0KFwiL1wiKTtcbiAgICAgICAgbGV0IG9wdGlvbiA9IHRoaXMub3B0aW9ucy5jb250ZXh0O1xuICAgICAgICBsZXQgdXNlUm9vdCA9ICF0aGlzLmlzT3BlbiAmJiAoIW9wdGlvbiB8fCBvcHRpb24ucGFyZW50LnR5cGUgPT0gdGhpcy5ub2Rlc1swXS50eXBlKTtcbiAgICAgICAgbGV0IG1pbkRlcHRoID0gLShvcHRpb24gPyBvcHRpb24uZGVwdGggKyAxIDogMCkgKyAodXNlUm9vdCA/IDAgOiAxKTtcbiAgICAgICAgbGV0IG1hdGNoID0gKGksIGRlcHRoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0ID09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gcGFydHMubGVuZ3RoIC0gMSB8fCBpID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGRlcHRoID49IG1pbkRlcHRoOyBkZXB0aC0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKGkgLSAxLCBkZXB0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gZGVwdGggPiAwIHx8IChkZXB0aCA9PSAwICYmIHVzZVJvb3QpID8gdGhpcy5ub2Rlc1tkZXB0aF0udHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvcHRpb24gJiYgZGVwdGggPj0gbWluRGVwdGggPyBvcHRpb24ubm9kZShkZXB0aCAtIG1pbkRlcHRoKS50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgKG5leHQubmFtZSAhPSBwYXJ0ICYmIG5leHQuZ3JvdXBzLmluZGV4T2YocGFydCkgPT0gLTEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWF0Y2gocGFydHMubGVuZ3RoIC0gMSwgdGhpcy5vcGVuKTtcbiAgICB9XG4gICAgdGV4dGJsb2NrRnJvbUNvbnRleHQoKSB7XG4gICAgICAgIGxldCAkY29udGV4dCA9IHRoaXMub3B0aW9ucy5jb250ZXh0O1xuICAgICAgICBpZiAoJGNvbnRleHQpXG4gICAgICAgICAgICBmb3IgKGxldCBkID0gJGNvbnRleHQuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlZmx0ID0gJGNvbnRleHQubm9kZShkKS5jb250ZW50TWF0Y2hBdCgkY29udGV4dC5pbmRleEFmdGVyKGQpKS5kZWZhdWx0VHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoZGVmbHQgJiYgZGVmbHQuaXNUZXh0YmxvY2sgJiYgZGVmbHQuZGVmYXVsdEF0dHJzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmbHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmIHR5cGUuZGVmYXVsdEF0dHJzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFBlbmRpbmdNYXJrKG1hcmspIHtcbiAgICAgICAgbGV0IGZvdW5kID0gZmluZFNhbWVNYXJrSW5TZXQobWFyaywgdGhpcy50b3AucGVuZGluZ01hcmtzKTtcbiAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgdGhpcy50b3Auc3Rhc2hNYXJrcy5wdXNoKGZvdW5kKTtcbiAgICAgICAgdGhpcy50b3AucGVuZGluZ01hcmtzID0gbWFyay5hZGRUb1NldCh0aGlzLnRvcC5wZW5kaW5nTWFya3MpO1xuICAgIH1cbiAgICByZW1vdmVQZW5kaW5nTWFyayhtYXJrLCB1cHRvKSB7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gdGhpcy5vcGVuOyBkZXB0aCA+PSAwOyBkZXB0aC0tKSB7XG4gICAgICAgICAgICBsZXQgbGV2ZWwgPSB0aGlzLm5vZGVzW2RlcHRoXTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGxldmVsLnBlbmRpbmdNYXJrcy5sYXN0SW5kZXhPZihtYXJrKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwucGVuZGluZ01hcmtzID0gbWFyay5yZW1vdmVGcm9tU2V0KGxldmVsLnBlbmRpbmdNYXJrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5hY3RpdmVNYXJrcyA9IG1hcmsucmVtb3ZlRnJvbVNldChsZXZlbC5hY3RpdmVNYXJrcyk7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXNoTWFyayA9IGxldmVsLnBvcEZyb21TdGFzaE1hcmsobWFyayk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXNoTWFyayAmJiBsZXZlbC50eXBlICYmIGxldmVsLnR5cGUuYWxsb3dzTWFya1R5cGUoc3Rhc2hNYXJrLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICBsZXZlbC5hY3RpdmVNYXJrcyA9IHN0YXNoTWFyay5hZGRUb1NldChsZXZlbC5hY3RpdmVNYXJrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGV2ZWwgPT0gdXB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBkaXJlY3RseSBuZXN0ZWQgbGlzdCBub2RlcyBwcm9kdWNlZCBieSBzb21lXG4vLyB0b29scyBhbmQgYWxsb3dlZCBieSBicm93c2VycyB0byBtZWFuIHRoYXQgdGhlIG5lc3RlZCBsaXN0IGlzXG4vLyBhY3R1YWxseSBwYXJ0IG9mIHRoZSBsaXN0IGl0ZW0gYWJvdmUgaXQuXG5mdW5jdGlvbiBub3JtYWxpemVMaXN0KGRvbSkge1xuICAgIGZvciAobGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQsIHByZXZJdGVtID0gbnVsbDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBjaGlsZC5ub2RlVHlwZSA9PSAxID8gY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XG4gICAgICAgIGlmIChuYW1lICYmIGxpc3RUYWdzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHByZXZJdGVtKSB7XG4gICAgICAgICAgICBwcmV2SXRlbS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICBjaGlsZCA9IHByZXZJdGVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJsaVwiKSB7XG4gICAgICAgICAgICBwcmV2SXRlbSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIHByZXZJdGVtID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIEFwcGx5IGEgQ1NTIHNlbGVjdG9yLlxuZnVuY3Rpb24gbWF0Y2hlcyhkb20sIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIChkb20ubWF0Y2hlcyB8fCBkb20ubXNNYXRjaGVzU2VsZWN0b3IgfHwgZG9tLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBkb20ubW96TWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGRvbSwgc2VsZWN0b3IpO1xufVxuLy8gVG9rZW5pemUgYSBzdHlsZSBhdHRyaWJ1dGUgaW50byBwcm9wZXJ0eS92YWx1ZSBwYWlycy5cbmZ1bmN0aW9uIHBhcnNlU3R5bGVzKHN0eWxlKSB7XG4gICAgbGV0IHJlID0gL1xccyooW1xcdy1dKylcXHMqOlxccyooW147XSspL2csIG0sIHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlIChtID0gcmUuZXhlYyhzdHlsZSkpXG4gICAgICAgIHJlc3VsdC5wdXNoKG1bMV0sIG1bMl0udHJpbSgpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29weShvYmopIHtcbiAgICBsZXQgY29weSA9IHt9O1xuICAgIGZvciAobGV0IHByb3AgaW4gb2JqKVxuICAgICAgICBjb3B5W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIHJldHVybiBjb3B5O1xufVxuLy8gVXNlZCB3aGVuIGZpbmRpbmcgYSBtYXJrIGF0IHRoZSB0b3AgbGV2ZWwgb2YgYSBmcmFnbWVudCBwYXJzZS5cbi8vIENoZWNrcyB3aGV0aGVyIGl0IHdvdWxkIGJlIHJlYXNvbmFibGUgdG8gYXBwbHkgYSBnaXZlbiBtYXJrIHR5cGUgdG9cbi8vIGEgZ2l2ZW4gbm9kZSwgYnkgbG9va2luZyBhdCB0aGUgd2F5IHRoZSBtYXJrIG9jY3VycyBpbiB0aGUgc2NoZW1hLlxuZnVuY3Rpb24gbWFya01heUFwcGx5KG1hcmtUeXBlLCBub2RlVHlwZSkge1xuICAgIGxldCBub2RlcyA9IG5vZGVUeXBlLnNjaGVtYS5ub2RlcztcbiAgICBmb3IgKGxldCBuYW1lIGluIG5vZGVzKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSBub2Rlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFwYXJlbnQuYWxsb3dzTWFya1R5cGUobWFya1R5cGUpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBzZWVuID0gW10sIHNjYW4gPSAobWF0Y2gpID0+IHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChtYXRjaCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gbWF0Y2guZWRnZShpKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBub2RlVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihuZXh0KSA8IDAgJiYgc2NhbihuZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzY2FuKHBhcmVudC5jb250ZW50TWF0Y2gpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZFNhbWVNYXJrSW5TZXQobWFyaywgc2V0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG1hcmsuZXEoc2V0W2ldKSlcbiAgICAgICAgICAgIHJldHVybiBzZXRbaV07XG4gICAgfVxufVxuXG4vKipcbkEgRE9NIHNlcmlhbGl6ZXIga25vd3MgaG93IHRvIGNvbnZlcnQgUHJvc2VNaXJyb3Igbm9kZXMgYW5kXG5tYXJrcyBvZiB2YXJpb3VzIHR5cGVzIHRvIERPTSBub2Rlcy5cbiovXG5jbGFzcyBET01TZXJpYWxpemVyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXJpYWxpemVyLiBgbm9kZXNgIHNob3VsZCBtYXAgbm9kZSBuYW1lcyB0byBmdW5jdGlvbnNcbiAgICB0aGF0IHRha2UgYSBub2RlIGFuZCByZXR1cm4gYSBkZXNjcmlwdGlvbiBvZiB0aGUgY29ycmVzcG9uZGluZ1xuICAgIERPTS4gYG1hcmtzYCBkb2VzIHRoZSBzYW1lIGZvciBtYXJrIG5hbWVzLCBidXQgYWxzbyBnZXRzIGFuXG4gICAgYXJndW1lbnQgdGhhdCB0ZWxscyBpdCB3aGV0aGVyIHRoZSBtYXJrJ3MgY29udGVudCBpcyBibG9jayBvclxuICAgIGlubGluZSBjb250ZW50IChmb3IgdHlwaWNhbCB1c2UsIGl0J2xsIGFsd2F5cyBiZSBpbmxpbmUpLiBBIG1hcmtcbiAgICBzZXJpYWxpemVyIG1heSBiZSBgbnVsbGAgdG8gaW5kaWNhdGUgdGhhdCBtYXJrcyBvZiB0aGF0IHR5cGVcbiAgICBzaG91bGQgbm90IGJlIHNlcmlhbGl6ZWQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbm9kZSBzZXJpYWxpemF0aW9uIGZ1bmN0aW9ucy5cbiAgICAqL1xuICAgIG5vZGVzLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayBzZXJpYWxpemF0aW9uIGZ1bmN0aW9ucy5cbiAgICAqL1xuICAgIG1hcmtzKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhlIGNvbnRlbnQgb2YgdGhpcyBmcmFnbWVudCB0byBhIERPTSBmcmFnbWVudC4gV2hlblxuICAgIG5vdCBpbiB0aGUgYnJvd3NlciwgdGhlIGBkb2N1bWVudGAgb3B0aW9uLCBjb250YWluaW5nIGEgRE9NXG4gICAgZG9jdW1lbnQsIHNob3VsZCBiZSBwYXNzZWQgc28gdGhhdCB0aGUgc2VyaWFsaXplciBjYW4gY3JlYXRlXG4gICAgbm9kZXMuXG4gICAgKi9cbiAgICBzZXJpYWxpemVGcmFnbWVudChmcmFnbWVudCwgb3B0aW9ucyA9IHt9LCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgICAgICB0YXJnZXQgPSBkb2Mob3B0aW9ucykuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBsZXQgdG9wID0gdGFyZ2V0LCBhY3RpdmUgPSBbXTtcbiAgICAgICAgZnJhZ21lbnQuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIGlmIChhY3RpdmUubGVuZ3RoIHx8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtlZXAgPSAwLCByZW5kZXJlZCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGtlZXAgPCBhY3RpdmUubGVuZ3RoICYmIHJlbmRlcmVkIDwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlLm1hcmtzW3JlbmRlcmVkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hcmtzW25leHQudHlwZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dC5lcShhY3RpdmVba2VlcF1bMF0pIHx8IG5leHQudHlwZS5zcGVjLnNwYW5uaW5nID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBrZWVwKys7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChrZWVwIDwgYWN0aXZlLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gYWN0aXZlLnBvcCgpWzFdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZW5kZXJlZCA8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZGQgPSBub2RlLm1hcmtzW3JlbmRlcmVkKytdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWFya0RPTSA9IHRoaXMuc2VyaWFsaXplTWFyayhhZGQsIG5vZGUuaXNJbmxpbmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFya0RPTSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlLnB1c2goW2FkZCwgdG9wXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuYXBwZW5kQ2hpbGQobWFya0RPTS5kb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gbWFya0RPTS5jb250ZW50RE9NIHx8IG1hcmtET00uZG9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9wLmFwcGVuZENoaWxkKHRoaXMuc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHsgZG9tLCBjb250ZW50RE9NIH0gPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jKG9wdGlvbnMpLCB0aGlzLm5vZGVzW25vZGUudHlwZS5uYW1lXShub2RlKSk7XG4gICAgICAgIGlmIChjb250ZW50RE9NKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDb250ZW50IGhvbGUgbm90IGFsbG93ZWQgaW4gYSBsZWFmIG5vZGUgc3BlY1wiKTtcbiAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplRnJhZ21lbnQobm9kZS5jb250ZW50LCBvcHRpb25zLCBjb250ZW50RE9NKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBub2RlIHRvIGEgRE9NIG5vZGUuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHlvdVxuICAgIG5lZWQgdG8gc2VyaWFsaXplIGEgcGFydCBvZiBhIGRvY3VtZW50LCBhcyBvcHBvc2VkIHRvIHRoZSB3aG9sZVxuICAgIGRvY3VtZW50LiBUbyBzZXJpYWxpemUgYSB3aG9sZSBkb2N1bWVudCwgdXNlXG4gICAgW2BzZXJpYWxpemVGcmFnbWVudGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5ET01TZXJpYWxpemVyLnNlcmlhbGl6ZUZyYWdtZW50KSBvblxuICAgIGl0cyBbY29udGVudF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUuY29udGVudCkuXG4gICAgKi9cbiAgICBzZXJpYWxpemVOb2RlKG5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgZG9tID0gdGhpcy5zZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucyk7XG4gICAgICAgIGZvciAobGV0IGkgPSBub2RlLm1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgd3JhcCA9IHRoaXMuc2VyaWFsaXplTWFyayhub2RlLm1hcmtzW2ldLCBub2RlLmlzSW5saW5lLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICh3cmFwKSB7XG4gICAgICAgICAgICAgICAgKHdyYXAuY29udGVudERPTSB8fCB3cmFwLmRvbSkuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgICAgICBkb20gPSB3cmFwLmRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNlcmlhbGl6ZU1hcmsobWFyaywgaW5saW5lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHRvRE9NID0gdGhpcy5tYXJrc1ttYXJrLnR5cGUubmFtZV07XG4gICAgICAgIHJldHVybiB0b0RPTSAmJiBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jKG9wdGlvbnMpLCB0b0RPTShtYXJrLCBpbmxpbmUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVuZGVyIGFuIFtvdXRwdXQgc3BlY10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkRPTU91dHB1dFNwZWMpIHRvIGEgRE9NIG5vZGUuIElmXG4gICAgdGhlIHNwZWMgaGFzIGEgaG9sZSAoemVybykgaW4gaXQsIGBjb250ZW50RE9NYCB3aWxsIHBvaW50IGF0IHRoZVxuICAgIG5vZGUgd2l0aCB0aGUgaG9sZS5cbiAgICAqL1xuICAgIHN0YXRpYyByZW5kZXJTcGVjKGRvYywgc3RydWN0dXJlLCB4bWxOUyA9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJ1Y3R1cmUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiB7IGRvbTogZG9jLmNyZWF0ZVRleHROb2RlKHN0cnVjdHVyZSkgfTtcbiAgICAgICAgaWYgKHN0cnVjdHVyZS5ub2RlVHlwZSAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHsgZG9tOiBzdHJ1Y3R1cmUgfTtcbiAgICAgICAgaWYgKHN0cnVjdHVyZS5kb20gJiYgc3RydWN0dXJlLmRvbS5ub2RlVHlwZSAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdHVyZTtcbiAgICAgICAgbGV0IHRhZ05hbWUgPSBzdHJ1Y3R1cmVbMF0sIHNwYWNlID0gdGFnTmFtZS5pbmRleE9mKFwiIFwiKTtcbiAgICAgICAgaWYgKHNwYWNlID4gMCkge1xuICAgICAgICAgICAgeG1sTlMgPSB0YWdOYW1lLnNsaWNlKDAsIHNwYWNlKTtcbiAgICAgICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnNsaWNlKHNwYWNlICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnRET007XG4gICAgICAgIGxldCBkb20gPSAoeG1sTlMgPyBkb2MuY3JlYXRlRWxlbWVudE5TKHhtbE5TLCB0YWdOYW1lKSA6IGRvYy5jcmVhdGVFbGVtZW50KHRhZ05hbWUpKTtcbiAgICAgICAgbGV0IGF0dHJzID0gc3RydWN0dXJlWzFdLCBzdGFydCA9IDE7XG4gICAgICAgIGlmIChhdHRycyAmJiB0eXBlb2YgYXR0cnMgPT0gXCJvYmplY3RcIiAmJiBhdHRycy5ub2RlVHlwZSA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuICAgICAgICAgICAgc3RhcnQgPSAyO1xuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycylcbiAgICAgICAgICAgICAgICBpZiAoYXR0cnNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2UgPSBuYW1lLmluZGV4T2YoXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BhY2UgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZU5TKG5hbWUuc2xpY2UoMCwgc3BhY2UpLCBuYW1lLnNsaWNlKHNwYWNlICsgMSksIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0cnVjdHVyZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gc3RydWN0dXJlW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBzdHJ1Y3R1cmUubGVuZ3RoIC0gMSB8fCBpID4gc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ29udGVudCBob2xlIG11c3QgYmUgdGhlIG9ubHkgY2hpbGQgb2YgaXRzIHBhcmVudCBub2RlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbSwgY29udGVudERPTTogZG9tIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBkb206IGlubmVyLCBjb250ZW50RE9NOiBpbm5lckNvbnRlbnQgfSA9IERPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2MsIGNoaWxkLCB4bWxOUyk7XG4gICAgICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKGlubmVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNdWx0aXBsZSBjb250ZW50IGhvbGVzXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50RE9NID0gaW5uZXJDb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb20sIGNvbnRlbnRET00gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSBzZXJpYWxpemVyIHVzaW5nIHRoZSBbYHRvRE9NYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLnRvRE9NKVxuICAgIHByb3BlcnRpZXMgaW4gYSBzY2hlbWEncyBub2RlIGFuZCBtYXJrIHNwZWNzLlxuICAgICovXG4gICAgc3RhdGljIGZyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuY2FjaGVkLmRvbVNlcmlhbGl6ZXIgfHxcbiAgICAgICAgICAgIChzY2hlbWEuY2FjaGVkLmRvbVNlcmlhbGl6ZXIgPSBuZXcgRE9NU2VyaWFsaXplcih0aGlzLm5vZGVzRnJvbVNjaGVtYShzY2hlbWEpLCB0aGlzLm1hcmtzRnJvbVNjaGVtYShzY2hlbWEpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdhdGhlciB0aGUgc2VyaWFsaXplcnMgaW4gYSBzY2hlbWEncyBub2RlIHNwZWNzIGludG8gYW4gb2JqZWN0LlxuICAgIFRoaXMgY2FuIGJlIHVzZWZ1bCBhcyBhIGJhc2UgdG8gYnVpbGQgYSBjdXN0b20gc2VyaWFsaXplciBmcm9tLlxuICAgICovXG4gICAgc3RhdGljIG5vZGVzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGdhdGhlclRvRE9NKHNjaGVtYS5ub2Rlcyk7XG4gICAgICAgIGlmICghcmVzdWx0LnRleHQpXG4gICAgICAgICAgICByZXN1bHQudGV4dCA9IG5vZGUgPT4gbm9kZS50ZXh0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBHYXRoZXIgdGhlIHNlcmlhbGl6ZXJzIGluIGEgc2NoZW1hJ3MgbWFyayBzcGVjcyBpbnRvIGFuIG9iamVjdC5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXJrc0Zyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBnYXRoZXJUb0RPTShzY2hlbWEubWFya3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdhdGhlclRvRE9NKG9iaikge1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBuYW1lIGluIG9iaikge1xuICAgICAgICBsZXQgdG9ET00gPSBvYmpbbmFtZV0uc3BlYy50b0RPTTtcbiAgICAgICAgaWYgKHRvRE9NKVxuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gdG9ET007XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBkb2Mob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmRvY3VtZW50IHx8IHdpbmRvdy5kb2N1bWVudDtcbn1cblxuZXhwb3J0IHsgQ29udGVudE1hdGNoLCBET01QYXJzZXIsIERPTVNlcmlhbGl6ZXIsIEZyYWdtZW50LCBNYXJrLCBNYXJrVHlwZSwgTm9kZSwgTm9kZVJhbmdlLCBOb2RlVHlwZSwgUmVwbGFjZUVycm9yLCBSZXNvbHZlZFBvcywgU2NoZW1hLCBTbGljZSB9O1xuIiwgImltcG9ydCB7IFJlcGxhY2VFcnJvciwgU2xpY2UsIEZyYWdtZW50LCBNYXJrVHlwZSwgTWFyayB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcblxuLy8gUmVjb3ZlcnkgdmFsdWVzIGVuY29kZSBhIHJhbmdlIGluZGV4IGFuZCBhbiBvZmZzZXQuIFRoZXkgYXJlXG4vLyByZXByZXNlbnRlZCBhcyBudW1iZXJzLCBiZWNhdXNlIHRvbnMgb2YgdGhlbSB3aWxsIGJlIGNyZWF0ZWQgd2hlblxuLy8gbWFwcGluZywgZm9yIGV4YW1wbGUsIGEgbGFyZ2UgbnVtYmVyIG9mIGRlY29yYXRpb25zLiBUaGUgbnVtYmVyJ3Ncbi8vIGxvd2VyIDE2IGJpdHMgcHJvdmlkZSB0aGUgaW5kZXgsIHRoZSByZW1haW5pbmcgYml0cyB0aGUgb2Zmc2V0LlxuLy9cbi8vIE5vdGU6IFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGJpdCBzaGlmdCBvcGVyYXRvcnMgdG8gZW4tIGFuZFxuLy8gZGVjb2RlIHRoZXNlLCBzaW5jZSB0aG9zZSBjbGlwIHRvIDMyIGJpdHMsIHdoaWNoIHdlIG1pZ2h0IGluIHJhcmVcbi8vIGNhc2VzIHdhbnQgdG8gb3ZlcmZsb3cuIEEgNjQtYml0IGZsb2F0IGNhbiByZXByZXNlbnQgNDgtYml0XG4vLyBpbnRlZ2VycyBwcmVjaXNlbHkuXG5jb25zdCBsb3dlcjE2ID0gMHhmZmZmO1xuY29uc3QgZmFjdG9yMTYgPSBNYXRoLnBvdygyLCAxNik7XG5mdW5jdGlvbiBtYWtlUmVjb3ZlcihpbmRleCwgb2Zmc2V0KSB7IHJldHVybiBpbmRleCArIG9mZnNldCAqIGZhY3RvcjE2OyB9XG5mdW5jdGlvbiByZWNvdmVySW5kZXgodmFsdWUpIHsgcmV0dXJuIHZhbHVlICYgbG93ZXIxNjsgfVxuZnVuY3Rpb24gcmVjb3Zlck9mZnNldCh2YWx1ZSkgeyByZXR1cm4gKHZhbHVlIC0gKHZhbHVlICYgbG93ZXIxNikpIC8gZmFjdG9yMTY7IH1cbmNvbnN0IERFTF9CRUZPUkUgPSAxLCBERUxfQUZURVIgPSAyLCBERUxfQUNST1NTID0gNCwgREVMX1NJREUgPSA4O1xuLyoqXG5BbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgbWFwcGVkIHBvc2l0aW9uIHdpdGggZXh0cmFcbmluZm9ybWF0aW9uLlxuKi9cbmNsYXNzIE1hcFJlc3VsdCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbWFwcGVkIHZlcnNpb24gb2YgdGhlIHBvc2l0aW9uLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRlbEluZm8sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVjb3Zlcikge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5kZWxJbmZvID0gZGVsSW5mbztcbiAgICAgICAgdGhpcy5yZWNvdmVyID0gcmVjb3ZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIHBvc2l0aW9uIHdhcyBkZWxldGVkLCB0aGF0IGlzLCB3aGV0aGVyIHRoZVxuICAgIHN0ZXAgcmVtb3ZlZCB0aGUgdG9rZW4gb24gdGhlIHNpZGUgcXVlcmllZCAodmlhIHRoZSBgYXNzb2NgKVxuICAgIGFyZ3VtZW50IGZyb20gdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWQoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgREVMX1NJREUpID4gMDsgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoZSB0b2tlbiBiZWZvcmUgdGhlIG1hcHBlZCBwb3NpdGlvbiB3YXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIGdldCBkZWxldGVkQmVmb3JlKCkgeyByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIChERUxfQkVGT1JFIHwgREVMX0FDUk9TUykpID4gMDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGUgdG9rZW4gYWZ0ZXIgdGhlIG1hcHBlZCBwb3NpdGlvbiB3YXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIGdldCBkZWxldGVkQWZ0ZXIoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgKERFTF9BRlRFUiB8IERFTF9BQ1JPU1MpKSA+IDA7IH1cbiAgICAvKipcbiAgICBUZWxscyB3aGV0aGVyIGFueSBvZiB0aGUgc3RlcHMgbWFwcGVkIHRocm91Z2ggZGVsZXRlcyBhY3Jvc3MgdGhlXG4gICAgcG9zaXRpb24gKGluY2x1ZGluZyBib3RoIHRoZSB0b2tlbiBiZWZvcmUgYW5kIGFmdGVyIHRoZVxuICAgIHBvc2l0aW9uKS5cbiAgICAqL1xuICAgIGdldCBkZWxldGVkQWNyb3NzKCkgeyByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIERFTF9BQ1JPU1MpID4gMDsgfVxufVxuLyoqXG5BIG1hcCBkZXNjcmliaW5nIHRoZSBkZWxldGlvbnMgYW5kIGluc2VydGlvbnMgbWFkZSBieSBhIHN0ZXAsIHdoaWNoXG5jYW4gYmUgdXNlZCB0byBmaW5kIHRoZSBjb3JyZXNwb25kZW5jZSBiZXR3ZWVuIHBvc2l0aW9ucyBpbiB0aGVcbnByZS1zdGVwIHZlcnNpb24gb2YgYSBkb2N1bWVudCBhbmQgdGhlIHNhbWUgcG9zaXRpb24gaW4gdGhlXG5wb3N0LXN0ZXAgdmVyc2lvbi5cbiovXG5jbGFzcyBTdGVwTWFwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBwb3NpdGlvbiBtYXAuIFRoZSBtb2RpZmljYXRpb25zIHRvIHRoZSBkb2N1bWVudCBhcmVcbiAgICByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBudW1iZXJzLCBpbiB3aGljaCBlYWNoIGdyb3VwIG9mIHRocmVlXG4gICAgcmVwcmVzZW50cyBhIG1vZGlmaWVkIGNodW5rIGFzIGBbc3RhcnQsIG9sZFNpemUsIG5ld1NpemVdYC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmFuZ2VzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGludmVydGVkID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuaW52ZXJ0ZWQgPSBpbnZlcnRlZDtcbiAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoICYmIFN0ZXBNYXAuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gU3RlcE1hcC5lbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWNvdmVyKHZhbHVlKSB7XG4gICAgICAgIGxldCBkaWZmID0gMCwgaW5kZXggPSByZWNvdmVySW5kZXgodmFsdWUpO1xuICAgICAgICBpZiAoIXRoaXMuaW52ZXJ0ZWQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspXG4gICAgICAgICAgICAgICAgZGlmZiArPSB0aGlzLnJhbmdlc1tpICogMyArIDJdIC0gdGhpcy5yYW5nZXNbaSAqIDMgKyAxXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzW2luZGV4ICogM10gKyBkaWZmICsgcmVjb3Zlck9mZnNldCh2YWx1ZSk7XG4gICAgfVxuICAgIG1hcFJlc3VsdChwb3MsIGFzc29jID0gMSkgeyByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIGZhbHNlKTsgfVxuICAgIG1hcChwb3MsIGFzc29jID0gMSkgeyByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBfbWFwKHBvcywgYXNzb2MsIHNpbXBsZSkge1xuICAgICAgICBsZXQgZGlmZiA9IDAsIG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0gLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgbmV3U2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF0sIGVuZCA9IHN0YXJ0ICsgb2xkU2l6ZTtcbiAgICAgICAgICAgIGlmIChwb3MgPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNpZGUgPSAhb2xkU2l6ZSA/IGFzc29jIDogcG9zID09IHN0YXJ0ID8gLTEgOiBwb3MgPT0gZW5kID8gMSA6IGFzc29jO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBzdGFydCArIGRpZmYgKyAoc2lkZSA8IDAgPyAwIDogbmV3U2l6ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpbXBsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICBsZXQgcmVjb3ZlciA9IHBvcyA9PSAoYXNzb2MgPCAwID8gc3RhcnQgOiBlbmQpID8gbnVsbCA6IG1ha2VSZWNvdmVyKGkgLyAzLCBwb3MgLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgbGV0IGRlbCA9IHBvcyA9PSBzdGFydCA/IERFTF9BRlRFUiA6IHBvcyA9PSBlbmQgPyBERUxfQkVGT1JFIDogREVMX0FDUk9TUztcbiAgICAgICAgICAgICAgICBpZiAoYXNzb2MgPCAwID8gcG9zICE9IHN0YXJ0IDogcG9zICE9IGVuZClcbiAgICAgICAgICAgICAgICAgICAgZGVsIHw9IERFTF9TSURFO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWFwUmVzdWx0KHJlc3VsdCwgZGVsLCByZWNvdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpZmYgKz0gbmV3U2l6ZSAtIG9sZFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbXBsZSA/IHBvcyArIGRpZmYgOiBuZXcgTWFwUmVzdWx0KHBvcyArIGRpZmYsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvdWNoZXMocG9zLCByZWNvdmVyKSB7XG4gICAgICAgIGxldCBkaWZmID0gMCwgaW5kZXggPSByZWNvdmVySW5kZXgocmVjb3Zlcik7XG4gICAgICAgIGxldCBvbGRJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAyIDogMSwgbmV3SW5kZXggPSB0aGlzLmludmVydGVkID8gMSA6IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzW2ldIC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgb2xkU2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBvbGRJbmRleF0sIGVuZCA9IHN0YXJ0ICsgb2xkU2l6ZTtcbiAgICAgICAgICAgIGlmIChwb3MgPD0gZW5kICYmIGkgPT0gaW5kZXggKiAzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZGlmZiArPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdIC0gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGxzIHRoZSBnaXZlbiBmdW5jdGlvbiBvbiBlYWNoIG9mIHRoZSBjaGFuZ2VkIHJhbmdlcyBpbmNsdWRlZCBpblxuICAgIHRoaXMgbWFwLlxuICAgICovXG4gICAgZm9yRWFjaChmKSB7XG4gICAgICAgIGxldCBvbGRJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAyIDogMSwgbmV3SW5kZXggPSB0aGlzLmludmVydGVkID8gMSA6IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBkaWZmID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1tpXSwgb2xkU3RhcnQgPSBzdGFydCAtICh0aGlzLmludmVydGVkID8gZGlmZiA6IDApLCBuZXdTdGFydCA9IHN0YXJ0ICsgKHRoaXMuaW52ZXJ0ZWQgPyAwIDogZGlmZik7XG4gICAgICAgICAgICBsZXQgb2xkU2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBvbGRJbmRleF0sIG5ld1NpemUgPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdO1xuICAgICAgICAgICAgZihvbGRTdGFydCwgb2xkU3RhcnQgKyBvbGRTaXplLCBuZXdTdGFydCwgbmV3U3RhcnQgKyBuZXdTaXplKTtcbiAgICAgICAgICAgIGRpZmYgKz0gbmV3U2l6ZSAtIG9sZFNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGludmVydGVkIHZlcnNpb24gb2YgdGhpcyBtYXAuIFRoZSByZXN1bHQgY2FuIGJlIHVzZWQgdG9cbiAgICBtYXAgcG9zaXRpb25zIGluIHRoZSBwb3N0LXN0ZXAgZG9jdW1lbnQgdG8gdGhlIHByZS1zdGVwIGRvY3VtZW50LlxuICAgICovXG4gICAgaW52ZXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0ZXBNYXAodGhpcy5yYW5nZXMsICF0aGlzLmludmVydGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmludmVydGVkID8gXCItXCIgOiBcIlwiKSArIEpTT04uc3RyaW5naWZ5KHRoaXMucmFuZ2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFwIHRoYXQgbW92ZXMgYWxsIHBvc2l0aW9ucyBieSBvZmZzZXQgYG5gICh3aGljaCBtYXkgYmVcbiAgICBuZWdhdGl2ZSkuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIGFwcGx5aW5nIHN0ZXBzIG1lYW50IGZvciBhXG4gICAgc3ViLWRvY3VtZW50IHRvIGEgbGFyZ2VyIGRvY3VtZW50LCBvciB2aWNlLXZlcnNhLlxuICAgICovXG4gICAgc3RhdGljIG9mZnNldChuKSB7XG4gICAgICAgIHJldHVybiBuID09IDAgPyBTdGVwTWFwLmVtcHR5IDogbmV3IFN0ZXBNYXAobiA8IDAgPyBbMCwgLW4sIDBdIDogWzAsIDAsIG5dKTtcbiAgICB9XG59XG4vKipcbkEgU3RlcE1hcCB0aGF0IGNvbnRhaW5zIG5vIGNoYW5nZWQgcmFuZ2VzLlxuKi9cblN0ZXBNYXAuZW1wdHkgPSBuZXcgU3RlcE1hcChbXSk7XG4vKipcbkEgbWFwcGluZyByZXByZXNlbnRzIGEgcGlwZWxpbmUgb2YgemVybyBvciBtb3JlIFtzdGVwXG5tYXBzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXBNYXApLiBJdCBoYXMgc3BlY2lhbCBwcm92aXNpb25zIGZvciBsb3NzbGVzc2x5XG5oYW5kbGluZyBtYXBwaW5nIHBvc2l0aW9ucyB0aHJvdWdoIGEgc2VyaWVzIG9mIHN0ZXBzIGluIHdoaWNoIHNvbWVcbnN0ZXBzIGFyZSBpbnZlcnRlZCB2ZXJzaW9ucyBvZiBlYXJsaWVyIHN0ZXBzLiAoVGhpcyBjb21lcyB1cCB3aGVuXG5cdTIwMThbcmViYXNpbmddKC9kb2NzL2d1aWRlLyN0cmFuc2Zvcm0ucmViYXNpbmcpXHUyMDE5IHN0ZXBzIGZvclxuY29sbGFib3JhdGlvbiBvciBoaXN0b3J5IG1hbmFnZW1lbnQuKVxuKi9cbmNsYXNzIE1hcHBpbmcge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBtYXBwaW5nIHdpdGggdGhlIGdpdmVuIHBvc2l0aW9uIG1hcHMuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RlcCBtYXBzIGluIHRoaXMgbWFwcGluZy5cbiAgICAqL1xuICAgIG1hcHMgPSBbXSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtaXJyb3IsIFxuICAgIC8qKlxuICAgIFRoZSBzdGFydGluZyBwb3NpdGlvbiBpbiB0aGUgYG1hcHNgIGFycmF5LCB1c2VkIHdoZW4gYG1hcGAgb3JcbiAgICBgbWFwUmVzdWx0YCBpcyBjYWxsZWQuXG4gICAgKi9cbiAgICBmcm9tID0gMCwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBwb3NpdGlvbiBpbiB0aGUgYG1hcHNgIGFycmF5LlxuICAgICovXG4gICAgdG8gPSBtYXBzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLm1hcHMgPSBtYXBzO1xuICAgICAgICB0aGlzLm1pcnJvciA9IG1pcnJvcjtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXBwaW5nIHRoYXQgbWFwcyBvbmx5IHRocm91Z2ggYSBwYXJ0IG9mIHRoaXMgb25lLlxuICAgICovXG4gICAgc2xpY2UoZnJvbSA9IDAsIHRvID0gdGhpcy5tYXBzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IE1hcHBpbmcodGhpcy5tYXBzLCB0aGlzLm1pcnJvciwgZnJvbSwgdG8pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwcGluZyh0aGlzLm1hcHMuc2xpY2UoKSwgdGhpcy5taXJyb3IgJiYgdGhpcy5taXJyb3Iuc2xpY2UoKSwgdGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgc3RlcCBtYXAgdG8gdGhlIGVuZCBvZiB0aGlzIG1hcHBpbmcuIElmIGBtaXJyb3JzYCBpc1xuICAgIGdpdmVuLCBpdCBzaG91bGQgYmUgdGhlIGluZGV4IG9mIHRoZSBzdGVwIG1hcCB0aGF0IGlzIHRoZSBtaXJyb3JcbiAgICBpbWFnZSBvZiB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZE1hcChtYXAsIG1pcnJvcnMpIHtcbiAgICAgICAgdGhpcy50byA9IHRoaXMubWFwcy5wdXNoKG1hcCk7XG4gICAgICAgIGlmIChtaXJyb3JzICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLnNldE1pcnJvcih0aGlzLm1hcHMubGVuZ3RoIC0gMSwgbWlycm9ycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhbGwgdGhlIHN0ZXAgbWFwcyBpbiBhIGdpdmVuIG1hcHBpbmcgdG8gdGhpcyBvbmUgKHByZXNlcnZpbmdcbiAgICBtaXJyb3JpbmcgaW5mb3JtYXRpb24pLlxuICAgICovXG4gICAgYXBwZW5kTWFwcGluZyhtYXBwaW5nKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBzdGFydFNpemUgPSB0aGlzLm1hcHMubGVuZ3RoOyBpIDwgbWFwcGluZy5tYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWlyciA9IG1hcHBpbmcuZ2V0TWlycm9yKGkpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRNYXAobWFwcGluZy5tYXBzW2ldLCBtaXJyICE9IG51bGwgJiYgbWlyciA8IGkgPyBzdGFydFNpemUgKyBtaXJyIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBGaW5kcyB0aGUgb2Zmc2V0IG9mIHRoZSBzdGVwIG1hcCB0aGF0IG1pcnJvcnMgdGhlIG1hcCBhdCB0aGVcbiAgICBnaXZlbiBvZmZzZXQsIGluIHRoaXMgbWFwcGluZyAoYXMgcGVyIHRoZSBzZWNvbmQgYXJndW1lbnQgdG9cbiAgICBgYXBwZW5kTWFwYCkuXG4gICAgKi9cbiAgICBnZXRNaXJyb3Iobikge1xuICAgICAgICBpZiAodGhpcy5taXJyb3IpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWlycm9yLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pcnJvcltpXSA9PSBuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5taXJyb3JbaSArIChpICUgMiA/IC0xIDogMSldO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNldE1pcnJvcihuLCBtKSB7XG4gICAgICAgIGlmICghdGhpcy5taXJyb3IpXG4gICAgICAgICAgICB0aGlzLm1pcnJvciA9IFtdO1xuICAgICAgICB0aGlzLm1pcnJvci5wdXNoKG4sIG0pO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBlbmQgdGhlIGludmVyc2Ugb2YgdGhlIGdpdmVuIG1hcHBpbmcgdG8gdGhpcyBvbmUuXG4gICAgKi9cbiAgICBhcHBlbmRNYXBwaW5nSW52ZXJ0ZWQobWFwcGluZykge1xuICAgICAgICBmb3IgKGxldCBpID0gbWFwcGluZy5tYXBzLmxlbmd0aCAtIDEsIHRvdGFsU2l6ZSA9IHRoaXMubWFwcy5sZW5ndGggKyBtYXBwaW5nLm1hcHMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IG1pcnIgPSBtYXBwaW5nLmdldE1pcnJvcihpKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kTWFwKG1hcHBpbmcubWFwc1tpXS5pbnZlcnQoKSwgbWlyciAhPSBudWxsICYmIG1pcnIgPiBpID8gdG90YWxTaXplIC0gbWlyciAtIDEgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnZlcnRlZCB2ZXJzaW9uIG9mIHRoaXMgbWFwcGluZy5cbiAgICAqL1xuICAgIGludmVydCgpIHtcbiAgICAgICAgbGV0IGludmVyc2UgPSBuZXcgTWFwcGluZztcbiAgICAgICAgaW52ZXJzZS5hcHBlbmRNYXBwaW5nSW52ZXJ0ZWQodGhpcyk7XG4gICAgICAgIHJldHVybiBpbnZlcnNlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYSBwb3NpdGlvbiB0aHJvdWdoIHRoaXMgbWFwcGluZy5cbiAgICAqL1xuICAgIG1hcChwb3MsIGFzc29jID0gMSkge1xuICAgICAgICBpZiAodGhpcy5taXJyb3IpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIHRydWUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcm9tOyBpIDwgdGhpcy50bzsgaSsrKVxuICAgICAgICAgICAgcG9zID0gdGhpcy5tYXBzW2ldLm1hcChwb3MsIGFzc29jKTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIGEgcG9zaXRpb24gdGhyb3VnaCB0aGlzIG1hcHBpbmcsIHJldHVybmluZyBhIG1hcHBpbmdcbiAgICByZXN1bHQuXG4gICAgKi9cbiAgICBtYXBSZXN1bHQocG9zLCBhc3NvYyA9IDEpIHsgcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCBmYWxzZSk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIF9tYXAocG9zLCBhc3NvYywgc2ltcGxlKSB7XG4gICAgICAgIGxldCBkZWxJbmZvID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZnJvbTsgaSA8IHRoaXMudG87IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcCA9IHRoaXMubWFwc1tpXSwgcmVzdWx0ID0gbWFwLm1hcFJlc3VsdChwb3MsIGFzc29jKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvcnIgPSB0aGlzLmdldE1pcnJvcihpKTtcbiAgICAgICAgICAgICAgICBpZiAoY29yciAhPSBudWxsICYmIGNvcnIgPiBpICYmIGNvcnIgPCB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBjb3JyO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB0aGlzLm1hcHNbY29ycl0ucmVjb3ZlcihyZXN1bHQucmVjb3Zlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbEluZm8gfD0gcmVzdWx0LmRlbEluZm87XG4gICAgICAgICAgICBwb3MgPSByZXN1bHQucG9zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW1wbGUgPyBwb3MgOiBuZXcgTWFwUmVzdWx0KHBvcywgZGVsSW5mbywgbnVsbCk7XG4gICAgfVxufVxuXG5jb25zdCBzdGVwc0J5SUQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5BIHN0ZXAgb2JqZWN0IHJlcHJlc2VudHMgYW4gYXRvbWljIGNoYW5nZS4gSXQgZ2VuZXJhbGx5IGFwcGxpZXNcbm9ubHkgdG8gdGhlIGRvY3VtZW50IGl0IHdhcyBjcmVhdGVkIGZvciwgc2luY2UgdGhlIHBvc2l0aW9uc1xuc3RvcmVkIGluIGl0IHdpbGwgb25seSBtYWtlIHNlbnNlIGZvciB0aGF0IGRvY3VtZW50LlxuXG5OZXcgc3RlcHMgYXJlIGRlZmluZWQgYnkgY3JlYXRpbmcgY2xhc3NlcyB0aGF0IGV4dGVuZCBgU3RlcGAsXG5vdmVycmlkaW5nIHRoZSBgYXBwbHlgLCBgaW52ZXJ0YCwgYG1hcGAsIGBnZXRNYXBgIGFuZCBgZnJvbUpTT05gXG5tZXRob2RzLCBhbmQgcmVnaXN0ZXJpbmcgeW91ciBjbGFzcyB3aXRoIGEgdW5pcXVlXG5KU09OLXNlcmlhbGl6YXRpb24gaWRlbnRpZmllciB1c2luZ1xuW2BTdGVwLmpzb25JRGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcF5qc29uSUQpLlxuKi9cbmNsYXNzIFN0ZXAge1xuICAgIC8qKlxuICAgIEdldCB0aGUgc3RlcCBtYXAgdGhhdCByZXByZXNlbnRzIHRoZSBjaGFuZ2VzIG1hZGUgYnkgdGhpcyBzdGVwLFxuICAgIGFuZCB3aGljaCBjYW4gYmUgdXNlZCB0byB0cmFuc2Zvcm0gYmV0d2VlbiBwb3NpdGlvbnMgaW4gdGhlIG9sZFxuICAgIGFuZCB0aGUgbmV3IGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0TWFwKCkgeyByZXR1cm4gU3RlcE1hcC5lbXB0eTsgfVxuICAgIC8qKlxuICAgIFRyeSB0byBtZXJnZSB0aGlzIHN0ZXAgd2l0aCBhbm90aGVyIG9uZSwgdG8gYmUgYXBwbGllZCBkaXJlY3RseVxuICAgIGFmdGVyIGl0LiBSZXR1cm5zIHRoZSBtZXJnZWQgc3RlcCB3aGVuIHBvc3NpYmxlLCBudWxsIGlmIHRoZVxuICAgIHN0ZXBzIGNhbid0IGJlIG1lcmdlZC5cbiAgICAqL1xuICAgIG1lcmdlKG90aGVyKSB7IHJldHVybiBudWxsOyB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBzdGVwIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFdpbGwgY2FsbFxuICAgIHRocm91Z2ggdG8gdGhlIHN0ZXAgY2xhc3MnIG93biBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uIHx8ICFqc29uLnN0ZXBUeXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgdHlwZSA9IHN0ZXBzQnlJRFtqc29uLnN0ZXBUeXBlXTtcbiAgICAgICAgaWYgKCF0eXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE5vIHN0ZXAgdHlwZSAke2pzb24uc3RlcFR5cGV9IGRlZmluZWRgKTtcbiAgICAgICAgcmV0dXJuIHR5cGUuZnJvbUpTT04oc2NoZW1hLCBqc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVG8gYmUgYWJsZSB0byBzZXJpYWxpemUgc3RlcHMgdG8gSlNPTiwgZWFjaCBzdGVwIG5lZWRzIGEgc3RyaW5nXG4gICAgSUQgdG8gYXR0YWNoIHRvIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBVc2UgdGhpcyBtZXRob2QgdG9cbiAgICByZWdpc3RlciBhbiBJRCBmb3IgeW91ciBzdGVwIGNsYXNzZXMuIFRyeSB0byBwaWNrIHNvbWV0aGluZ1xuICAgIHRoYXQncyB1bmxpa2VseSB0byBjbGFzaCB3aXRoIHN0ZXBzIGZyb20gb3RoZXIgbW9kdWxlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBqc29uSUQoaWQsIHN0ZXBDbGFzcykge1xuICAgICAgICBpZiAoaWQgaW4gc3RlcHNCeUlEKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEdXBsaWNhdGUgdXNlIG9mIHN0ZXAgSlNPTiBJRCBcIiArIGlkKTtcbiAgICAgICAgc3RlcHNCeUlEW2lkXSA9IHN0ZXBDbGFzcztcbiAgICAgICAgc3RlcENsYXNzLnByb3RvdHlwZS5qc29uSUQgPSBpZDtcbiAgICAgICAgcmV0dXJuIHN0ZXBDbGFzcztcbiAgICB9XG59XG4vKipcblRoZSByZXN1bHQgb2YgW2FwcGx5aW5nXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXAuYXBwbHkpIGEgc3RlcC4gQ29udGFpbnMgZWl0aGVyIGFcbm5ldyBkb2N1bWVudCBvciBhIGZhaWx1cmUgdmFsdWUuXG4qL1xuY2xhc3MgU3RlcFJlc3VsdCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdHJhbnNmb3JtZWQgZG9jdW1lbnQsIGlmIHN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBkb2MsIFxuICAgIC8qKlxuICAgIFRoZSBmYWlsdXJlIG1lc3NhZ2UsIGlmIHVuc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIGZhaWxlZCkge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5mYWlsZWQgPSBmYWlsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHN1Y2Nlc3NmdWwgc3RlcCByZXN1bHQuXG4gICAgKi9cbiAgICBzdGF0aWMgb2soZG9jKSB7IHJldHVybiBuZXcgU3RlcFJlc3VsdChkb2MsIG51bGwpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZmFpbGVkIHN0ZXAgcmVzdWx0LlxuICAgICovXG4gICAgc3RhdGljIGZhaWwobWVzc2FnZSkgeyByZXR1cm4gbmV3IFN0ZXBSZXN1bHQobnVsbCwgbWVzc2FnZSk7IH1cbiAgICAvKipcbiAgICBDYWxsIFtgTm9kZS5yZXBsYWNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUucmVwbGFjZSkgd2l0aCB0aGUgZ2l2ZW5cbiAgICBhcmd1bWVudHMuIENyZWF0ZSBhIHN1Y2Nlc3NmdWwgcmVzdWx0IGlmIGl0IHN1Y2NlZWRzLCBhbmQgYVxuICAgIGZhaWxlZCBvbmUgaWYgaXQgdGhyb3dzIGEgYFJlcGxhY2VFcnJvcmAuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbVJlcGxhY2UoZG9jLCBmcm9tLCB0bywgc2xpY2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0Lm9rKGRvYy5yZXBsYWNlKGZyb20sIHRvLCBzbGljZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJlcGxhY2VFcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKGUubWVzc2FnZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtYXBGcmFnbWVudChmcmFnbWVudCwgZiwgcGFyZW50KSB7XG4gICAgbGV0IG1hcHBlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhZ21lbnQuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGZyYWdtZW50LmNoaWxkKGkpO1xuICAgICAgICBpZiAoY2hpbGQuY29udGVudC5zaXplKVxuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jb3B5KG1hcEZyYWdtZW50KGNoaWxkLmNvbnRlbnQsIGYsIGNoaWxkKSk7XG4gICAgICAgIGlmIChjaGlsZC5pc0lubGluZSlcbiAgICAgICAgICAgIGNoaWxkID0gZihjaGlsZCwgcGFyZW50LCBpKTtcbiAgICAgICAgbWFwcGVkLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gRnJhZ21lbnQuZnJvbUFycmF5KG1hcHBlZCk7XG59XG4vKipcbkFkZCBhIG1hcmsgdG8gYWxsIGlubGluZSBjb250ZW50IGJldHdlZW4gdHdvIHBvc2l0aW9ucy5cbiovXG5jbGFzcyBBZGRNYXJrU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmsgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgbWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgbWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHRvIGFkZC5cbiAgICAqL1xuICAgIG1hcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG9sZFNsaWNlID0gZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50byksICRmcm9tID0gZG9jLnJlc29sdmUodGhpcy5mcm9tKTtcbiAgICAgICAgbGV0IHBhcmVudCA9ICRmcm9tLm5vZGUoJGZyb20uc2hhcmVkRGVwdGgodGhpcy50bykpO1xuICAgICAgICBsZXQgc2xpY2UgPSBuZXcgU2xpY2UobWFwRnJhZ21lbnQob2xkU2xpY2UuY29udGVudCwgKG5vZGUsIHBhcmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFub2RlLmlzQXRvbSB8fCAhcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUodGhpcy5tYXJrLnR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubWFyayh0aGlzLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICB9LCBwYXJlbnQpLCBvbGRTbGljZS5vcGVuU3RhcnQsIG9sZFNsaWNlLm9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgc2xpY2UpO1xuICAgIH1cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBpZiAoZnJvbS5kZWxldGVkICYmIHRvLmRlbGV0ZWQgfHwgZnJvbS5wb3MgPj0gdG8ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoZnJvbS5wb3MsIHRvLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQWRkTWFya1N0ZXAgJiZcbiAgICAgICAgICAgIG90aGVyLm1hcmsuZXEodGhpcy5tYXJrKSAmJlxuICAgICAgICAgICAgdGhpcy5mcm9tIDw9IG90aGVyLnRvICYmIHRoaXMudG8gPj0gb3RoZXIuZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoTWF0aC5taW4odGhpcy5mcm9tLCBvdGhlci5mcm9tKSwgTWF0aC5tYXgodGhpcy50bywgb3RoZXIudG8pLCB0aGlzLm1hcmspO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJhZGRNYXJrXCIsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSxcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgQWRkTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiYWRkTWFya1wiLCBBZGRNYXJrU3RlcCk7XG4vKipcblJlbW92ZSBhIG1hcmsgZnJvbSBhbGwgaW5saW5lIGNvbnRlbnQgYmV0d2VlbiB0d28gcG9zaXRpb25zLlxuKi9cbmNsYXNzIFJlbW92ZU1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyay1yZW1vdmluZyBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSB1bm1hcmtlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIHVubWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHRvIHJlbW92ZS5cbiAgICAqL1xuICAgIG1hcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG9sZFNsaWNlID0gZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShtYXBGcmFnbWVudChvbGRTbGljZS5jb250ZW50LCBub2RlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLm1hcmsodGhpcy5tYXJrLnJlbW92ZUZyb21TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICB9LCBkb2MpLCBvbGRTbGljZS5vcGVuU3RhcnQsIG9sZFNsaWNlLm9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgc2xpY2UpO1xuICAgIH1cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBpZiAoZnJvbS5kZWxldGVkICYmIHRvLmRlbGV0ZWQgfHwgZnJvbS5wb3MgPj0gdG8ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoZnJvbS5wb3MsIHRvLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgUmVtb3ZlTWFya1N0ZXAgJiZcbiAgICAgICAgICAgIG90aGVyLm1hcmsuZXEodGhpcy5tYXJrKSAmJlxuICAgICAgICAgICAgdGhpcy5mcm9tIDw9IG90aGVyLnRvICYmIHRoaXMudG8gPj0gb3RoZXIuZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoTWF0aC5taW4odGhpcy5mcm9tLCBvdGhlci5mcm9tKSwgTWF0aC5tYXgodGhpcy50bywgb3RoZXIudG8pLCB0aGlzLm1hcmspO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJyZW1vdmVNYXJrXCIsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSxcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVtb3ZlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVtb3ZlTWFya1wiLCBSZW1vdmVNYXJrU3RlcCk7XG4vKipcbkFkZCBhIG1hcmsgdG8gYSBzcGVjaWZpYyBub2RlLlxuKi9cbmNsYXNzIEFkZE5vZGVNYXJrU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5vZGUgbWFyayBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gYWRkLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJObyBub2RlIGF0IG1hcmsgc3RlcCdzIHBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IG5vZGUudHlwZS5jcmVhdGUobm9kZS5hdHRycywgbnVsbCwgdGhpcy5tYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLnBvcywgdGhpcy5wb3MgKyAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh1cGRhdGVkKSwgMCwgbm9kZS5pc0xlYWYgPyAwIDogMSkpO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBsZXQgbmV3U2V0ID0gdGhpcy5tYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpO1xuICAgICAgICAgICAgaWYgKG5ld1NldC5sZW5ndGggPT0gbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5tYXJrc1tpXS5pc0luU2V0KG5ld1NldCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcCh0aGlzLnBvcywgbm9kZS5tYXJrc1tpXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGROb2RlTWFya1N0ZXAodGhpcy5wb3MsIHRoaXMubWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAodGhpcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnBvcywgMSk7XG4gICAgICAgIHJldHVybiBwb3MuZGVsZXRlZEFmdGVyID8gbnVsbCA6IG5ldyBBZGROb2RlTWFya1N0ZXAocG9zLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJhZGROb2RlTWFya1wiLCBwb3M6IHRoaXMucG9zLCBtYXJrOiB0aGlzLm1hcmsudG9KU09OKCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgQWRkTm9kZU1hcmtTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcChqc29uLnBvcywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcImFkZE5vZGVNYXJrXCIsIEFkZE5vZGVNYXJrU3RlcCk7XG4vKipcblJlbW92ZSBhIG1hcmsgZnJvbSBhIHNwZWNpZmljIG5vZGUuXG4qL1xuY2xhc3MgUmVtb3ZlTm9kZU1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyay1yZW1vdmluZyBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gcmVtb3ZlLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJObyBub2RlIGF0IG1hcmsgc3RlcCdzIHBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IG5vZGUudHlwZS5jcmVhdGUobm9kZS5hdHRycywgbnVsbCwgdGhpcy5tYXJrLnJlbW92ZUZyb21TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMucG9zLCB0aGlzLnBvcyArIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLCAwLCBub2RlLmlzTGVhZiA/IDAgOiAxKSk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlIHx8ICF0aGlzLm1hcmsuaXNJblNldChub2RlLm1hcmtzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcCh0aGlzLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMucG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIHBvcy5kZWxldGVkQWZ0ZXIgPyBudWxsIDogbmV3IFJlbW92ZU5vZGVNYXJrU3RlcChwb3MucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcInJlbW92ZU5vZGVNYXJrXCIsIHBvczogdGhpcy5wb3MsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZW1vdmVOb2RlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKGpzb24ucG9zLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVtb3ZlTm9kZU1hcmtcIiwgUmVtb3ZlTm9kZU1hcmtTdGVwKTtcblxuLyoqXG5SZXBsYWNlIGEgcGFydCBvZiB0aGUgZG9jdW1lbnQgd2l0aCBhIHNsaWNlIG9mIG5ldyBjb250ZW50LlxuKi9cbmNsYXNzIFJlcGxhY2VTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgVGhlIGdpdmVuIGBzbGljZWAgc2hvdWxkIGZpdCB0aGUgJ2dhcCcgYmV0d2VlbiBgZnJvbWAgYW5kXG4gICAgYHRvYFx1MjAxNHRoZSBkZXB0aHMgbXVzdCBsaW5lIHVwLCBhbmQgdGhlIHN1cnJvdW5kaW5nIG5vZGVzIG11c3QgYmVcbiAgICBhYmxlIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSBvcGVuIHNpZGVzIG9mIHRoZSBzbGljZS4gV2hlblxuICAgIGBzdHJ1Y3R1cmVgIGlzIHRydWUsIHRoZSBzdGVwIHdpbGwgZmFpbCBpZiB0aGUgY29udGVudCBiZXR3ZWVuXG4gICAgZnJvbSBhbmQgdG8gaXMgbm90IGp1c3QgYSBzZXF1ZW5jZSBvZiBjbG9zaW5nIGFuZCB0aGVuIG9wZW5pbmdcbiAgICB0b2tlbnMgKHRoaXMgaXMgdG8gZ3VhcmQgYWdhaW5zdCByZWJhc2VkIHJlcGxhY2Ugc3RlcHNcbiAgICBvdmVyd3JpdGluZyBzb21ldGhpbmcgdGhleSB3ZXJlbid0IHN1cHBvc2VkIHRvKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgc2xpY2UgdG8gaW5zZXJ0LlxuICAgICovXG4gICAgc2xpY2UsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RydWN0dXJlID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMuc3RydWN0dXJlID0gc3RydWN0dXJlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RydWN0dXJlICYmIGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvKSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJTdHJ1Y3R1cmUgcmVwbGFjZSB3b3VsZCBvdmVyd3JpdGUgY29udGVudFwiKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMuc2xpY2UpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RlcE1hcChbdGhpcy5mcm9tLCB0aGlzLnRvIC0gdGhpcy5mcm9tLCB0aGlzLnNsaWNlLnNpemVdKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKHRoaXMuZnJvbSwgdGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplLCBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWRBY3Jvc3MgJiYgdG8uZGVsZXRlZEFjcm9zcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGZyb20ucG9zLCBNYXRoLm1heChmcm9tLnBvcywgdG8ucG9zKSwgdGhpcy5zbGljZSk7XG4gICAgfVxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXApIHx8IG90aGVyLnN0cnVjdHVyZSB8fCB0aGlzLnN0cnVjdHVyZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplID09IG90aGVyLmZyb20gJiYgIXRoaXMuc2xpY2Uub3BlbkVuZCAmJiAhb3RoZXIuc2xpY2Uub3BlblN0YXJ0KSB7XG4gICAgICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLnNsaWNlLnNpemUgKyBvdGhlci5zbGljZS5zaXplID09IDAgPyBTbGljZS5lbXB0eVxuICAgICAgICAgICAgICAgIDogbmV3IFNsaWNlKHRoaXMuc2xpY2UuY29udGVudC5hcHBlbmQob3RoZXIuc2xpY2UuY29udGVudCksIHRoaXMuc2xpY2Uub3BlblN0YXJ0LCBvdGhlci5zbGljZS5vcGVuRW5kKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAodGhpcy5mcm9tLCB0aGlzLnRvICsgKG90aGVyLnRvIC0gb3RoZXIuZnJvbSksIHNsaWNlLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIudG8gPT0gdGhpcy5mcm9tICYmICF0aGlzLnNsaWNlLm9wZW5TdGFydCAmJiAhb3RoZXIuc2xpY2Uub3BlbkVuZCkge1xuICAgICAgICAgICAgbGV0IHNsaWNlID0gdGhpcy5zbGljZS5zaXplICsgb3RoZXIuc2xpY2Uuc2l6ZSA9PSAwID8gU2xpY2UuZW1wdHlcbiAgICAgICAgICAgICAgICA6IG5ldyBTbGljZShvdGhlci5zbGljZS5jb250ZW50LmFwcGVuZCh0aGlzLnNsaWNlLmNvbnRlbnQpLCBvdGhlci5zbGljZS5vcGVuU3RhcnQsIHRoaXMuc2xpY2Uub3BlbkVuZCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKG90aGVyLmZyb20sIHRoaXMudG8sIHNsaWNlLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBqc29uID0geyBzdGVwVHlwZTogXCJyZXBsYWNlXCIsIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8gfTtcbiAgICAgICAgaWYgKHRoaXMuc2xpY2Uuc2l6ZSlcbiAgICAgICAgICAgIGpzb24uc2xpY2UgPSB0aGlzLnNsaWNlLnRvSlNPTigpO1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUpXG4gICAgICAgICAgICBqc29uLnN0cnVjdHVyZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZXBsYWNlU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChqc29uLmZyb20sIGpzb24udG8sIFNsaWNlLmZyb21KU09OKHNjaGVtYSwganNvbi5zbGljZSksICEhanNvbi5zdHJ1Y3R1cmUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVwbGFjZVwiLCBSZXBsYWNlU3RlcCk7XG4vKipcblJlcGxhY2UgYSBwYXJ0IG9mIHRoZSBkb2N1bWVudCB3aXRoIGEgc2xpY2Ugb2YgY29udGVudCwgYnV0XG5wcmVzZXJ2ZSBhIHJhbmdlIG9mIHRoZSByZXBsYWNlZCBjb250ZW50IGJ5IG1vdmluZyBpdCBpbnRvIHRoZVxuc2xpY2UuXG4qL1xuY2xhc3MgUmVwbGFjZUFyb3VuZFN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSByZXBsYWNlLWFyb3VuZCBzdGVwIHdpdGggdGhlIGdpdmVuIHJhbmdlIGFuZCBnYXAuXG4gICAgYGluc2VydGAgc2hvdWxkIGJlIHRoZSBwb2ludCBpbiB0aGUgc2xpY2UgaW50byB3aGljaCB0aGUgY29udGVudFxuICAgIG9mIHRoZSBnYXAgc2hvdWxkIGJlIG1vdmVkLiBgc3RydWN0dXJlYCBoYXMgdGhlIHNhbWUgbWVhbmluZyBhc1xuICAgIGl0IGhhcyBpbiB0aGUgW2BSZXBsYWNlU3RlcGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uUmVwbGFjZVN0ZXApIGNsYXNzLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiBwcmVzZXJ2ZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBnYXBGcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHByZXNlcnZlZCByYW5nZS5cbiAgICAqL1xuICAgIGdhcFRvLCBcbiAgICAvKipcbiAgICBUaGUgc2xpY2UgdG8gaW5zZXJ0LlxuICAgICovXG4gICAgc2xpY2UsIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBpbiB0aGUgc2xpY2Ugd2hlcmUgdGhlIHByZXNlcnZlZCByYW5nZSBzaG91bGQgYmVcbiAgICBpbnNlcnRlZC5cbiAgICAqL1xuICAgIGluc2VydCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdHJ1Y3R1cmUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZ2FwRnJvbSA9IGdhcEZyb207XG4gICAgICAgIHRoaXMuZ2FwVG8gPSBnYXBUbztcbiAgICAgICAgdGhpcy5zbGljZSA9IHNsaWNlO1xuICAgICAgICB0aGlzLmluc2VydCA9IGluc2VydDtcbiAgICAgICAgdGhpcy5zdHJ1Y3R1cmUgPSBzdHJ1Y3R1cmU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUgJiYgKGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5mcm9tLCB0aGlzLmdhcEZyb20pIHx8XG4gICAgICAgICAgICBjb250ZW50QmV0d2Vlbihkb2MsIHRoaXMuZ2FwVG8sIHRoaXMudG8pKSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJTdHJ1Y3R1cmUgZ2FwLXJlcGxhY2Ugd291bGQgb3ZlcndyaXRlIGNvbnRlbnRcIik7XG4gICAgICAgIGxldCBnYXAgPSBkb2Muc2xpY2UodGhpcy5nYXBGcm9tLCB0aGlzLmdhcFRvKTtcbiAgICAgICAgaWYgKGdhcC5vcGVuU3RhcnQgfHwgZ2FwLm9wZW5FbmQpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiR2FwIGlzIG5vdCBhIGZsYXQgcmFuZ2VcIik7XG4gICAgICAgIGxldCBpbnNlcnRlZCA9IHRoaXMuc2xpY2UuaW5zZXJ0QXQodGhpcy5pbnNlcnQsIGdhcC5jb250ZW50KTtcbiAgICAgICAgaWYgKCFpbnNlcnRlZClcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJDb250ZW50IGRvZXMgbm90IGZpdCBpbiBnYXBcIik7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBpbnNlcnRlZCk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGVwTWFwKFt0aGlzLmZyb20sIHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5pbnNlcnQsXG4gICAgICAgICAgICB0aGlzLmdhcFRvLCB0aGlzLnRvIC0gdGhpcy5nYXBUbywgdGhpcy5zbGljZS5zaXplIC0gdGhpcy5pbnNlcnRdKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgZ2FwID0gdGhpcy5nYXBUbyAtIHRoaXMuZ2FwRnJvbTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcCh0aGlzLmZyb20sIHRoaXMuZnJvbSArIHRoaXMuc2xpY2Uuc2l6ZSArIGdhcCwgdGhpcy5mcm9tICsgdGhpcy5pbnNlcnQsIHRoaXMuZnJvbSArIHRoaXMuaW5zZXJ0ICsgZ2FwLCBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKS5yZW1vdmVCZXR3ZWVuKHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5nYXBUbyAtIHRoaXMuZnJvbSksIHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBsZXQgZ2FwRnJvbSA9IG1hcHBpbmcubWFwKHRoaXMuZ2FwRnJvbSwgLTEpLCBnYXBUbyA9IG1hcHBpbmcubWFwKHRoaXMuZ2FwVG8sIDEpO1xuICAgICAgICBpZiAoKGZyb20uZGVsZXRlZEFjcm9zcyAmJiB0by5kZWxldGVkQWNyb3NzKSB8fCBnYXBGcm9tIDwgZnJvbS5wb3MgfHwgZ2FwVG8gPiB0by5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcChmcm9tLnBvcywgdG8ucG9zLCBnYXBGcm9tLCBnYXBUbywgdGhpcy5zbGljZSwgdGhpcy5pbnNlcnQsIHRoaXMuc3RydWN0dXJlKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQganNvbiA9IHsgc3RlcFR5cGU6IFwicmVwbGFjZUFyb3VuZFwiLCBmcm9tOiB0aGlzLmZyb20sIHRvOiB0aGlzLnRvLFxuICAgICAgICAgICAgZ2FwRnJvbTogdGhpcy5nYXBGcm9tLCBnYXBUbzogdGhpcy5nYXBUbywgaW5zZXJ0OiB0aGlzLmluc2VydCB9O1xuICAgICAgICBpZiAodGhpcy5zbGljZS5zaXplKVxuICAgICAgICAgICAganNvbi5zbGljZSA9IHRoaXMuc2xpY2UudG9KU09OKCk7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSlcbiAgICAgICAgICAgIGpzb24uc3RydWN0dXJlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiBqc29uLmdhcEZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5nYXBUbyAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmluc2VydCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZXBsYWNlQXJvdW5kU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcChqc29uLmZyb20sIGpzb24udG8sIGpzb24uZ2FwRnJvbSwganNvbi5nYXBUbywgU2xpY2UuZnJvbUpTT04oc2NoZW1hLCBqc29uLnNsaWNlKSwganNvbi5pbnNlcnQsICEhanNvbi5zdHJ1Y3R1cmUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVwbGFjZUFyb3VuZFwiLCBSZXBsYWNlQXJvdW5kU3RlcCk7XG5mdW5jdGlvbiBjb250ZW50QmV0d2Vlbihkb2MsIGZyb20sIHRvKSB7XG4gICAgbGV0ICRmcm9tID0gZG9jLnJlc29sdmUoZnJvbSksIGRpc3QgPSB0byAtIGZyb20sIGRlcHRoID0gJGZyb20uZGVwdGg7XG4gICAgd2hpbGUgKGRpc3QgPiAwICYmIGRlcHRoID4gMCAmJiAkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSA9PSAkZnJvbS5ub2RlKGRlcHRoKS5jaGlsZENvdW50KSB7XG4gICAgICAgIGRlcHRoLS07XG4gICAgICAgIGRpc3QtLTtcbiAgICB9XG4gICAgaWYgKGRpc3QgPiAwKSB7XG4gICAgICAgIGxldCBuZXh0ID0gJGZyb20ubm9kZShkZXB0aCkubWF5YmVDaGlsZCgkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSk7XG4gICAgICAgIHdoaWxlIChkaXN0ID4gMCkge1xuICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQuaXNMZWFmKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGRpc3QtLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZE1hcmsodHIsIGZyb20sIHRvLCBtYXJrKSB7XG4gICAgbGV0IHJlbW92ZWQgPSBbXSwgYWRkZWQgPSBbXTtcbiAgICBsZXQgcmVtb3ZpbmcsIGFkZGluZztcbiAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zLCBwYXJlbnQpID0+IHtcbiAgICAgICAgaWYgKCFub2RlLmlzSW5saW5lKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbWFya3MgPSBub2RlLm1hcmtzO1xuICAgICAgICBpZiAoIW1hcmsuaXNJblNldChtYXJrcykgJiYgcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUobWFyay50eXBlKSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgocG9zLCBmcm9tKSwgZW5kID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgICAgbGV0IG5ld1NldCA9IG1hcmsuYWRkVG9TZXQobWFya3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghbWFya3NbaV0uaXNJblNldChuZXdTZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmluZyAmJiByZW1vdmluZy50byA9PSBzdGFydCAmJiByZW1vdmluZy5tYXJrLmVxKG1hcmtzW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92aW5nLnRvID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkLnB1c2gocmVtb3ZpbmcgPSBuZXcgUmVtb3ZlTWFya1N0ZXAoc3RhcnQsIGVuZCwgbWFya3NbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWRkaW5nICYmIGFkZGluZy50byA9PSBzdGFydClcbiAgICAgICAgICAgICAgICBhZGRpbmcudG8gPSBlbmQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYWRkZWQucHVzaChhZGRpbmcgPSBuZXcgQWRkTWFya1N0ZXAoc3RhcnQsIGVuZCwgbWFyaykpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmVtb3ZlZC5mb3JFYWNoKHMgPT4gdHIuc3RlcChzKSk7XG4gICAgYWRkZWQuZm9yRWFjaChzID0+IHRyLnN0ZXAocykpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTWFyayh0ciwgZnJvbSwgdG8sIG1hcmspIHtcbiAgICBsZXQgbWF0Y2hlZCA9IFtdLCBzdGVwID0gMDtcbiAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgIGlmICghbm9kZS5pc0lubGluZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc3RlcCsrO1xuICAgICAgICBsZXQgdG9SZW1vdmUgPSBudWxsO1xuICAgICAgICBpZiAobWFyayBpbnN0YW5jZW9mIE1hcmtUeXBlKSB7XG4gICAgICAgICAgICBsZXQgc2V0ID0gbm9kZS5tYXJrcywgZm91bmQ7XG4gICAgICAgICAgICB3aGlsZSAoZm91bmQgPSBtYXJrLmlzSW5TZXQoc2V0KSkge1xuICAgICAgICAgICAgICAgICh0b1JlbW92ZSB8fCAodG9SZW1vdmUgPSBbXSkpLnB1c2goZm91bmQpO1xuICAgICAgICAgICAgICAgIHNldCA9IGZvdW5kLnJlbW92ZUZyb21TZXQoc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXJrKSB7XG4gICAgICAgICAgICBpZiAobWFyay5pc0luU2V0KG5vZGUubWFya3MpKVxuICAgICAgICAgICAgICAgIHRvUmVtb3ZlID0gW21hcmtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9SZW1vdmUgPSBub2RlLm1hcmtzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b1JlbW92ZSAmJiB0b1JlbW92ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvUmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlID0gdG9SZW1vdmVbaV0sIGZvdW5kO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF0Y2hlZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IG1hdGNoZWRbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtLnN0ZXAgPT0gc3RlcCAtIDEgJiYgc3R5bGUuZXEobWF0Y2hlZFtqXS5zdHlsZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IG07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZC50byA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQuc3RlcCA9IHN0ZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkLnB1c2goeyBzdHlsZSwgZnJvbTogTWF0aC5tYXgocG9zLCBmcm9tKSwgdG86IGVuZCwgc3RlcCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBtYXRjaGVkLmZvckVhY2gobSA9PiB0ci5zdGVwKG5ldyBSZW1vdmVNYXJrU3RlcChtLmZyb20sIG0udG8sIG0uc3R5bGUpKSk7XG59XG5mdW5jdGlvbiBjbGVhckluY29tcGF0aWJsZSh0ciwgcG9zLCBwYXJlbnRUeXBlLCBtYXRjaCA9IHBhcmVudFR5cGUuY29udGVudE1hdGNoKSB7XG4gICAgbGV0IG5vZGUgPSB0ci5kb2Mubm9kZUF0KHBvcyk7XG4gICAgbGV0IHJlcGxTdGVwcyA9IFtdLCBjdXIgPSBwb3MgKyAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gbm9kZS5jaGlsZChpKSwgZW5kID0gY3VyICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgIGxldCBhbGxvd2VkID0gbWF0Y2gubWF0Y2hUeXBlKGNoaWxkLnR5cGUpO1xuICAgICAgICBpZiAoIWFsbG93ZWQpIHtcbiAgICAgICAgICAgIHJlcGxTdGVwcy5wdXNoKG5ldyBSZXBsYWNlU3RlcChjdXIsIGVuZCwgU2xpY2UuZW1wdHkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoID0gYWxsb3dlZDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGQubWFya3MubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRUeXBlLmFsbG93c01hcmtUeXBlKGNoaWxkLm1hcmtzW2pdLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICB0ci5zdGVwKG5ldyBSZW1vdmVNYXJrU3RlcChjdXIsIGVuZCwgY2hpbGQubWFya3Nbal0pKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5pc1RleHQgJiYgIXBhcmVudFR5cGUuc3BlYy5jb2RlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG0sIG5ld2xpbmUgPSAvXFxyP1xcbnxcXHIvZywgc2xpY2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG0gPSBuZXdsaW5lLmV4ZWMoY2hpbGQudGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzbGljZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20ocGFyZW50VHlwZS5zY2hlbWEudGV4dChcIiBcIiwgcGFyZW50VHlwZS5hbGxvd2VkTWFya3MoY2hpbGQubWFya3MpKSksIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICByZXBsU3RlcHMucHVzaChuZXcgUmVwbGFjZVN0ZXAoY3VyICsgbS5pbmRleCwgY3VyICsgbS5pbmRleCArIG1bMF0ubGVuZ3RoLCBzbGljZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBlbmQ7XG4gICAgfVxuICAgIGlmICghbWF0Y2gudmFsaWRFbmQpIHtcbiAgICAgICAgbGV0IGZpbGwgPSBtYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgICAgdHIucmVwbGFjZShjdXIsIGN1ciwgbmV3IFNsaWNlKGZpbGwsIDAsIDApKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHJlcGxTdGVwcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgdHIuc3RlcChyZXBsU3RlcHNbaV0pO1xufVxuXG5mdW5jdGlvbiBjYW5DdXQobm9kZSwgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoc3RhcnQgPT0gMCB8fCBub2RlLmNhblJlcGxhY2Uoc3RhcnQsIG5vZGUuY2hpbGRDb3VudCkpICYmXG4gICAgICAgIChlbmQgPT0gbm9kZS5jaGlsZENvdW50IHx8IG5vZGUuY2FuUmVwbGFjZSgwLCBlbmQpKTtcbn1cbi8qKlxuVHJ5IHRvIGZpbmQgYSB0YXJnZXQgZGVwdGggdG8gd2hpY2ggdGhlIGNvbnRlbnQgaW4gdGhlIGdpdmVuIHJhbmdlXG5jYW4gYmUgbGlmdGVkLiBXaWxsIG5vdCBnbyBhY3Jvc3Ncbltpc29sYXRpbmddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5pc29sYXRpbmcpIHBhcmVudCBub2Rlcy5cbiovXG5mdW5jdGlvbiBsaWZ0VGFyZ2V0KHJhbmdlKSB7XG4gICAgbGV0IHBhcmVudCA9IHJhbmdlLnBhcmVudDtcbiAgICBsZXQgY29udGVudCA9IHBhcmVudC5jb250ZW50LmN1dEJ5SW5kZXgocmFuZ2Uuc3RhcnRJbmRleCwgcmFuZ2UuZW5kSW5kZXgpO1xuICAgIGZvciAobGV0IGRlcHRoID0gcmFuZ2UuZGVwdGg7OyAtLWRlcHRoKSB7XG4gICAgICAgIGxldCBub2RlID0gcmFuZ2UuJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgIGxldCBpbmRleCA9IHJhbmdlLiRmcm9tLmluZGV4KGRlcHRoKSwgZW5kSW5kZXggPSByYW5nZS4kdG8uaW5kZXhBZnRlcihkZXB0aCk7XG4gICAgICAgIGlmIChkZXB0aCA8IHJhbmdlLmRlcHRoICYmIG5vZGUuY2FuUmVwbGFjZShpbmRleCwgZW5kSW5kZXgsIGNvbnRlbnQpKVxuICAgICAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCB8fCBub2RlLnR5cGUuc3BlYy5pc29sYXRpbmcgfHwgIWNhbkN1dChub2RlLCBpbmRleCwgZW5kSW5kZXgpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbGlmdCh0ciwgcmFuZ2UsIHRhcmdldCkge1xuICAgIGxldCB7ICRmcm9tLCAkdG8sIGRlcHRoIH0gPSByYW5nZTtcbiAgICBsZXQgZ2FwU3RhcnQgPSAkZnJvbS5iZWZvcmUoZGVwdGggKyAxKSwgZ2FwRW5kID0gJHRvLmFmdGVyKGRlcHRoICsgMSk7XG4gICAgbGV0IHN0YXJ0ID0gZ2FwU3RhcnQsIGVuZCA9IGdhcEVuZDtcbiAgICBsZXQgYmVmb3JlID0gRnJhZ21lbnQuZW1wdHksIG9wZW5TdGFydCA9IDA7XG4gICAgZm9yIChsZXQgZCA9IGRlcHRoLCBzcGxpdHRpbmcgPSBmYWxzZTsgZCA+IHRhcmdldDsgZC0tKVxuICAgICAgICBpZiAoc3BsaXR0aW5nIHx8ICRmcm9tLmluZGV4KGQpID4gMCkge1xuICAgICAgICAgICAgc3BsaXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGJlZm9yZSA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KGJlZm9yZSkpO1xuICAgICAgICAgICAgb3BlblN0YXJ0Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydC0tO1xuICAgICAgICB9XG4gICAgbGV0IGFmdGVyID0gRnJhZ21lbnQuZW1wdHksIG9wZW5FbmQgPSAwO1xuICAgIGZvciAobGV0IGQgPSBkZXB0aCwgc3BsaXR0aW5nID0gZmFsc2U7IGQgPiB0YXJnZXQ7IGQtLSlcbiAgICAgICAgaWYgKHNwbGl0dGluZyB8fCAkdG8uYWZ0ZXIoZCArIDEpIDwgJHRvLmVuZChkKSkge1xuICAgICAgICAgICAgc3BsaXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGFmdGVyID0gRnJhZ21lbnQuZnJvbSgkdG8ubm9kZShkKS5jb3B5KGFmdGVyKSk7XG4gICAgICAgICAgICBvcGVuRW5kKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfVxuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0LCBlbmQsIGdhcFN0YXJ0LCBnYXBFbmQsIG5ldyBTbGljZShiZWZvcmUuYXBwZW5kKGFmdGVyKSwgb3BlblN0YXJ0LCBvcGVuRW5kKSwgYmVmb3JlLnNpemUgLSBvcGVuU3RhcnQsIHRydWUpKTtcbn1cbi8qKlxuVHJ5IHRvIGZpbmQgYSB2YWxpZCB3YXkgdG8gd3JhcCB0aGUgY29udGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2UgaW4gYVxubm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZS4gTWF5IGludHJvZHVjZSBleHRyYSBub2RlcyBhcm91bmQgYW5kIGluc2lkZVxudGhlIHdyYXBwZXIgbm9kZSwgaWYgbmVjZXNzYXJ5LiBSZXR1cm5zIG51bGwgaWYgbm8gdmFsaWQgd3JhcHBpbmdcbmNvdWxkIGJlIGZvdW5kLiBXaGVuIGBpbm5lclJhbmdlYCBpcyBnaXZlbiwgdGhhdCByYW5nZSdzIGNvbnRlbnQgaXNcbnVzZWQgYXMgdGhlIGNvbnRlbnQgdG8gZml0IGludG8gdGhlIHdyYXBwaW5nLCBpbnN0ZWFkIG9mIHRoZVxuY29udGVudCBvZiBgcmFuZ2VgLlxuKi9cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZyhyYW5nZSwgbm9kZVR5cGUsIGF0dHJzID0gbnVsbCwgaW5uZXJSYW5nZSA9IHJhbmdlKSB7XG4gICAgbGV0IGFyb3VuZCA9IGZpbmRXcmFwcGluZ091dHNpZGUocmFuZ2UsIG5vZGVUeXBlKTtcbiAgICBsZXQgaW5uZXIgPSBhcm91bmQgJiYgZmluZFdyYXBwaW5nSW5zaWRlKGlubmVyUmFuZ2UsIG5vZGVUeXBlKTtcbiAgICBpZiAoIWlubmVyKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gYXJvdW5kLm1hcCh3aXRoQXR0cnMpXG4gICAgICAgIC5jb25jYXQoeyB0eXBlOiBub2RlVHlwZSwgYXR0cnMgfSkuY29uY2F0KGlubmVyLm1hcCh3aXRoQXR0cnMpKTtcbn1cbmZ1bmN0aW9uIHdpdGhBdHRycyh0eXBlKSB7IHJldHVybiB7IHR5cGUsIGF0dHJzOiBudWxsIH07IH1cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZ091dHNpZGUocmFuZ2UsIHR5cGUpIHtcbiAgICBsZXQgeyBwYXJlbnQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4IH0gPSByYW5nZTtcbiAgICBsZXQgYXJvdW5kID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KHN0YXJ0SW5kZXgpLmZpbmRXcmFwcGluZyh0eXBlKTtcbiAgICBpZiAoIWFyb3VuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG91dGVyID0gYXJvdW5kLmxlbmd0aCA/IGFyb3VuZFswXSA6IHR5cGU7XG4gICAgcmV0dXJuIHBhcmVudC5jYW5SZXBsYWNlV2l0aChzdGFydEluZGV4LCBlbmRJbmRleCwgb3V0ZXIpID8gYXJvdW5kIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZ0luc2lkZShyYW5nZSwgdHlwZSkge1xuICAgIGxldCB7IHBhcmVudCwgc3RhcnRJbmRleCwgZW5kSW5kZXggfSA9IHJhbmdlO1xuICAgIGxldCBpbm5lciA9IHBhcmVudC5jaGlsZChzdGFydEluZGV4KTtcbiAgICBsZXQgaW5zaWRlID0gdHlwZS5jb250ZW50TWF0Y2guZmluZFdyYXBwaW5nKGlubmVyLnR5cGUpO1xuICAgIGlmICghaW5zaWRlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbGFzdFR5cGUgPSBpbnNpZGUubGVuZ3RoID8gaW5zaWRlW2luc2lkZS5sZW5ndGggLSAxXSA6IHR5cGU7XG4gICAgbGV0IGlubmVyTWF0Y2ggPSBsYXN0VHlwZS5jb250ZW50TWF0Y2g7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGlubmVyTWF0Y2ggJiYgaSA8IGVuZEluZGV4OyBpKyspXG4gICAgICAgIGlubmVyTWF0Y2ggPSBpbm5lck1hdGNoLm1hdGNoVHlwZShwYXJlbnQuY2hpbGQoaSkudHlwZSk7XG4gICAgaWYgKCFpbm5lck1hdGNoIHx8ICFpbm5lck1hdGNoLnZhbGlkRW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gaW5zaWRlO1xufVxuZnVuY3Rpb24gd3JhcCh0ciwgcmFuZ2UsIHdyYXBwZXJzKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBpID0gd3JhcHBlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gd3JhcHBlcnNbaV0udHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgICAgICAgIGlmICghbWF0Y2ggfHwgIW1hdGNoLnZhbGlkRW5kKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiV3JhcHBlciB0eXBlIGdpdmVuIHRvIFRyYW5zZm9ybS53cmFwIGRvZXMgbm90IGZvcm0gdmFsaWQgY29udGVudCBvZiBpdHMgcGFyZW50IHdyYXBwZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20od3JhcHBlcnNbaV0udHlwZS5jcmVhdGUod3JhcHBlcnNbaV0uYXR0cnMsIGNvbnRlbnQpKTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0ID0gcmFuZ2Uuc3RhcnQsIGVuZCA9IHJhbmdlLmVuZDtcbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCwgZW5kLCBzdGFydCwgZW5kLCBuZXcgU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpO1xufVxuZnVuY3Rpb24gc2V0QmxvY2tUeXBlKHRyLCBmcm9tLCB0bywgdHlwZSwgYXR0cnMpIHtcbiAgICBpZiAoIXR5cGUuaXNUZXh0YmxvY2spXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHlwZSBnaXZlbiB0byBzZXRCbG9ja1R5cGUgc2hvdWxkIGJlIGEgdGV4dGJsb2NrXCIpO1xuICAgIGxldCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoO1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0YmxvY2sgJiYgIW5vZGUuaGFzTWFya3VwKHR5cGUsIGF0dHJzKSAmJiBjYW5DaGFuZ2VUeXBlKHRyLmRvYywgdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zKSwgdHlwZSkpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBhbGwgbWFya3VwIHRoYXQgaXNuJ3QgYWxsb3dlZCBpbiB0aGUgbmV3IG5vZGUgdHlwZSBpcyBjbGVhcmVkXG4gICAgICAgICAgICB0ci5jbGVhckluY29tcGF0aWJsZSh0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MsIDEpLCB0eXBlKTtcbiAgICAgICAgICAgIGxldCBtYXBwaW5nID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKTtcbiAgICAgICAgICAgIGxldCBzdGFydE0gPSBtYXBwaW5nLm1hcChwb3MsIDEpLCBlbmRNID0gbWFwcGluZy5tYXAocG9zICsgbm9kZS5ub2RlU2l6ZSwgMSk7XG4gICAgICAgICAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydE0sIGVuZE0sIHN0YXJ0TSArIDEsIGVuZE0gLSAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZShhdHRycywgbnVsbCwgbm9kZS5tYXJrcykpLCAwLCAwKSwgMSwgdHJ1ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjYW5DaGFuZ2VUeXBlKGRvYywgcG9zLCB0eXBlKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICByZXR1cm4gJHBvcy5wYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4ICsgMSwgdHlwZSk7XG59XG4vKipcbkNoYW5nZSB0aGUgdHlwZSwgYXR0cmlidXRlcywgYW5kL29yIG1hcmtzIG9mIHRoZSBub2RlIGF0IGBwb3NgLlxuV2hlbiBgdHlwZWAgaXNuJ3QgZ2l2ZW4sIHRoZSBleGlzdGluZyBub2RlIHR5cGUgaXMgcHJlc2VydmVkLFxuKi9cbmZ1bmN0aW9uIHNldE5vZGVNYXJrdXAodHIsIHBvcywgdHlwZSwgYXR0cnMsIG1hcmtzKSB7XG4gICAgbGV0IG5vZGUgPSB0ci5kb2Mubm9kZUF0KHBvcyk7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYXQgZ2l2ZW4gcG9zaXRpb25cIik7XG4gICAgaWYgKCF0eXBlKVxuICAgICAgICB0eXBlID0gbm9kZS50eXBlO1xuICAgIGxldCBuZXdOb2RlID0gdHlwZS5jcmVhdGUoYXR0cnMsIG51bGwsIG1hcmtzIHx8IG5vZGUubWFya3MpO1xuICAgIGlmIChub2RlLmlzTGVhZilcbiAgICAgICAgcmV0dXJuIHRyLnJlcGxhY2VXaXRoKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwgbmV3Tm9kZSk7XG4gICAgaWYgKCF0eXBlLnZhbGlkQ29udGVudChub2RlLmNvbnRlbnQpKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgY29udGVudCBmb3Igbm9kZSB0eXBlIFwiICsgdHlwZS5uYW1lKTtcbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIHBvcyArIDEsIHBvcyArIG5vZGUubm9kZVNpemUgLSAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShuZXdOb2RlKSwgMCwgMCksIDEsIHRydWUpKTtcbn1cbi8qKlxuQ2hlY2sgd2hldGhlciBzcGxpdHRpbmcgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIGFsbG93ZWQuXG4qL1xuZnVuY3Rpb24gY2FuU3BsaXQoZG9jLCBwb3MsIGRlcHRoID0gMSwgdHlwZXNBZnRlcikge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKSwgYmFzZSA9ICRwb3MuZGVwdGggLSBkZXB0aDtcbiAgICBsZXQgaW5uZXJUeXBlID0gKHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlclt0eXBlc0FmdGVyLmxlbmd0aCAtIDFdKSB8fCAkcG9zLnBhcmVudDtcbiAgICBpZiAoYmFzZSA8IDAgfHwgJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZyB8fFxuICAgICAgICAhJHBvcy5wYXJlbnQuY2FuUmVwbGFjZSgkcG9zLmluZGV4KCksICRwb3MucGFyZW50LmNoaWxkQ291bnQpIHx8XG4gICAgICAgICFpbm5lclR5cGUudHlwZS52YWxpZENvbnRlbnQoJHBvcy5wYXJlbnQuY29udGVudC5jdXRCeUluZGV4KCRwb3MuaW5kZXgoKSwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudCkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGggLSAxLCBpID0gZGVwdGggLSAyOyBkID4gYmFzZTsgZC0tLCBpLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSAkcG9zLm5vZGUoZCksIGluZGV4ID0gJHBvcy5pbmRleChkKTtcbiAgICAgICAgaWYgKG5vZGUudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHJlc3QgPSBub2RlLmNvbnRlbnQuY3V0QnlJbmRleChpbmRleCwgbm9kZS5jaGlsZENvdW50KTtcbiAgICAgICAgbGV0IG92ZXJyaWRlQ2hpbGQgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbaSArIDFdO1xuICAgICAgICBpZiAob3ZlcnJpZGVDaGlsZClcbiAgICAgICAgICAgIHJlc3QgPSByZXN0LnJlcGxhY2VDaGlsZCgwLCBvdmVycmlkZUNoaWxkLnR5cGUuY3JlYXRlKG92ZXJyaWRlQ2hpbGQuYXR0cnMpKTtcbiAgICAgICAgbGV0IGFmdGVyID0gKHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlcltpXSkgfHwgbm9kZTtcbiAgICAgICAgaWYgKCFub2RlLmNhblJlcGxhY2UoaW5kZXggKyAxLCBub2RlLmNoaWxkQ291bnQpIHx8ICFhZnRlci50eXBlLnZhbGlkQ29udGVudChyZXN0KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleEFmdGVyKGJhc2UpO1xuICAgIGxldCBiYXNlVHlwZSA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlclswXTtcbiAgICByZXR1cm4gJHBvcy5ub2RlKGJhc2UpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgYmFzZVR5cGUgPyBiYXNlVHlwZS50eXBlIDogJHBvcy5ub2RlKGJhc2UgKyAxKS50eXBlKTtcbn1cbmZ1bmN0aW9uIHNwbGl0KHRyLCBwb3MsIGRlcHRoID0gMSwgdHlwZXNBZnRlcikge1xuICAgIGxldCAkcG9zID0gdHIuZG9jLnJlc29sdmUocG9zKSwgYmVmb3JlID0gRnJhZ21lbnQuZW1wdHksIGFmdGVyID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGgsIGUgPSAkcG9zLmRlcHRoIC0gZGVwdGgsIGkgPSBkZXB0aCAtIDE7IGQgPiBlOyBkLS0sIGktLSkge1xuICAgICAgICBiZWZvcmUgPSBGcmFnbWVudC5mcm9tKCRwb3Mubm9kZShkKS5jb3B5KGJlZm9yZSkpO1xuICAgICAgICBsZXQgdHlwZUFmdGVyID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW2ldO1xuICAgICAgICBhZnRlciA9IEZyYWdtZW50LmZyb20odHlwZUFmdGVyID8gdHlwZUFmdGVyLnR5cGUuY3JlYXRlKHR5cGVBZnRlci5hdHRycywgYWZ0ZXIpIDogJHBvcy5ub2RlKGQpLmNvcHkoYWZ0ZXIpKTtcbiAgICB9XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZVN0ZXAocG9zLCBwb3MsIG5ldyBTbGljZShiZWZvcmUuYXBwZW5kKGFmdGVyKSwgZGVwdGgsIGRlcHRoKSwgdHJ1ZSkpO1xufVxuLyoqXG5UZXN0IHdoZXRoZXIgdGhlIGJsb2NrcyBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gcG9zaXRpb24gY2FuIGJlXG5qb2luZWQuXG4qL1xuZnVuY3Rpb24gY2FuSm9pbihkb2MsIHBvcykge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKSwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgcmV0dXJuIGpvaW5hYmxlKCRwb3Mubm9kZUJlZm9yZSwgJHBvcy5ub2RlQWZ0ZXIpICYmXG4gICAgICAgICRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSk7XG59XG5mdW5jdGlvbiBqb2luYWJsZShhLCBiKSB7XG4gICAgcmV0dXJuICEhKGEgJiYgYiAmJiAhYS5pc0xlYWYgJiYgYS5jYW5BcHBlbmQoYikpO1xufVxuLyoqXG5GaW5kIGFuIGFuY2VzdG9yIG9mIHRoZSBnaXZlbiBwb3NpdGlvbiB0aGF0IGNhbiBiZSBqb2luZWQgdG8gdGhlXG5ibG9jayBiZWZvcmUgKG9yIGFmdGVyIGlmIGBkaXJgIGlzIHBvc2l0aXZlKS4gUmV0dXJucyB0aGUgam9pbmFibGVcbnBvaW50LCBpZiBhbnkuXG4qL1xuZnVuY3Rpb24gam9pblBvaW50KGRvYywgcG9zLCBkaXIgPSAtMSkge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDs7IGQtLSkge1xuICAgICAgICBsZXQgYmVmb3JlLCBhZnRlciwgaW5kZXggPSAkcG9zLmluZGV4KGQpO1xuICAgICAgICBpZiAoZCA9PSAkcG9zLmRlcHRoKSB7XG4gICAgICAgICAgICBiZWZvcmUgPSAkcG9zLm5vZGVCZWZvcmU7XG4gICAgICAgICAgICBhZnRlciA9ICRwb3Mubm9kZUFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZShkICsgMSk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgYWZ0ZXIgPSAkcG9zLm5vZGUoZCkubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiZWZvcmUgPSAkcG9zLm5vZGUoZCkubWF5YmVDaGlsZChpbmRleCAtIDEpO1xuICAgICAgICAgICAgYWZ0ZXIgPSAkcG9zLm5vZGUoZCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiZWZvcmUgJiYgIWJlZm9yZS5pc1RleHRibG9jayAmJiBqb2luYWJsZShiZWZvcmUsIGFmdGVyKSAmJlxuICAgICAgICAgICAgJHBvcy5ub2RlKGQpLmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSkpXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICBpZiAoZCA9PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHBvcyA9IGRpciA8IDAgPyAkcG9zLmJlZm9yZShkKSA6ICRwb3MuYWZ0ZXIoZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gam9pbih0ciwgcG9zLCBkZXB0aCkge1xuICAgIGxldCBzdGVwID0gbmV3IFJlcGxhY2VTdGVwKHBvcyAtIGRlcHRoLCBwb3MgKyBkZXB0aCwgU2xpY2UuZW1wdHksIHRydWUpO1xuICAgIHRyLnN0ZXAoc3RlcCk7XG59XG4vKipcblRyeSB0byBmaW5kIGEgcG9pbnQgd2hlcmUgYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlIGNhbiBiZSBpbnNlcnRlZFxubmVhciBgcG9zYCwgYnkgc2VhcmNoaW5nIHVwIHRoZSBub2RlIGhpZXJhcmNoeSB3aGVuIGBwb3NgIGl0c2VsZlxuaXNuJ3QgYSB2YWxpZCBwbGFjZSBidXQgaXMgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhIG5vZGUuIFJldHVyblxubnVsbCBpZiBubyBwb3NpdGlvbiB3YXMgZm91bmQuXG4qL1xuZnVuY3Rpb24gaW5zZXJ0UG9pbnQoZG9jLCBwb3MsIG5vZGVUeXBlKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmICgkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aCgkcG9zLmluZGV4KCksICRwb3MuaW5kZXgoKSwgbm9kZVR5cGUpKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PSAwKVxuICAgICAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4KGQpO1xuICAgICAgICAgICAgaWYgKCRwb3Mubm9kZShkKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIG5vZGVUeXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5iZWZvcmUoZCArIDEpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PSAkcG9zLnBhcmVudC5jb250ZW50LnNpemUpXG4gICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXhBZnRlcihkKTtcbiAgICAgICAgICAgIGlmICgkcG9zLm5vZGUoZCkuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBub2RlVHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3MuYWZ0ZXIoZCArIDEpO1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgJHBvcy5ub2RlKGQpLmNoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuRmluZHMgYSBwb3NpdGlvbiBhdCBvciBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uIHdoZXJlIHRoZSBnaXZlblxuc2xpY2UgY2FuIGJlIGluc2VydGVkLiBXaWxsIGxvb2sgYXQgcGFyZW50IG5vZGVzJyBuZWFyZXN0IGJvdW5kYXJ5XG5hbmQgdHJ5IHRoZXJlLCBldmVuIGlmIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiB3YXNuJ3QgZGlyZWN0bHkgYXQgdGhlXG5zdGFydCBvciBlbmQgb2YgdGhhdCBub2RlLiBSZXR1cm5zIG51bGwgd2hlbiBubyBwb3NpdGlvbiB3YXMgZm91bmQuXG4qL1xuZnVuY3Rpb24gZHJvcFBvaW50KGRvYywgcG9zLCBzbGljZSkge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoIXNsaWNlLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBsZXQgY29udGVudCA9IHNsaWNlLmNvbnRlbnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGljZS5vcGVuU3RhcnQ7IGkrKylcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgIGZvciAobGV0IHBhc3MgPSAxOyBwYXNzIDw9IChzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5zaXplID8gMiA6IDEpOyBwYXNzKyspIHtcbiAgICAgICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICBsZXQgYmlhcyA9IGQgPT0gJHBvcy5kZXB0aCA/IDAgOiAkcG9zLnBvcyA8PSAoJHBvcy5zdGFydChkICsgMSkgKyAkcG9zLmVuZChkICsgMSkpIC8gMiA/IC0xIDogMTtcbiAgICAgICAgICAgIGxldCBpbnNlcnRQb3MgPSAkcG9zLmluZGV4KGQpICsgKGJpYXMgPiAwID8gMSA6IDApO1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9ICRwb3Mubm9kZShkKSwgZml0cyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHBhc3MgPT0gMSkge1xuICAgICAgICAgICAgICAgIGZpdHMgPSBwYXJlbnQuY2FuUmVwbGFjZShpbnNlcnRQb3MsIGluc2VydFBvcywgY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcHBpbmcgPSBwYXJlbnQuY29udGVudE1hdGNoQXQoaW5zZXJ0UG9zKS5maW5kV3JhcHBpbmcoY29udGVudC5maXJzdENoaWxkLnR5cGUpO1xuICAgICAgICAgICAgICAgIGZpdHMgPSB3cmFwcGluZyAmJiBwYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5zZXJ0UG9zLCBpbnNlcnRQb3MsIHdyYXBwaW5nWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXRzKVxuICAgICAgICAgICAgICAgIHJldHVybiBiaWFzID09IDAgPyAkcG9zLnBvcyA6IGJpYXMgPCAwID8gJHBvcy5iZWZvcmUoZCArIDEpIDogJHBvcy5hZnRlcihkICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuXHUyMDE4Rml0XHUyMDE5IGEgc2xpY2UgaW50byBhIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCwgcHJvZHVjaW5nIGFcbltzdGVwXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXApIHRoYXQgaW5zZXJ0cyBpdC4gV2lsbCByZXR1cm4gbnVsbCBpZlxudGhlcmUncyBubyBtZWFuaW5nZnVsIHdheSB0byBpbnNlcnQgdGhlIHNsaWNlIGhlcmUsIG9yIGluc2VydGluZyBpdFxud291bGQgYmUgYSBuby1vcCAoYW4gZW1wdHkgc2xpY2Ugb3ZlciBhbiBlbXB0eSByYW5nZSkuXG4qL1xuZnVuY3Rpb24gcmVwbGFjZVN0ZXAoZG9jLCBmcm9tLCB0byA9IGZyb20sIHNsaWNlID0gU2xpY2UuZW1wdHkpIHtcbiAgICBpZiAoZnJvbSA9PSB0byAmJiAhc2xpY2Uuc2l6ZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0ICRmcm9tID0gZG9jLnJlc29sdmUoZnJvbSksICR0byA9IGRvYy5yZXNvbHZlKHRvKTtcbiAgICAvLyBPcHRpbWl6YXRpb24gLS0gYXZvaWQgd29yayBpZiBpdCdzIG9idmlvdXMgdGhhdCBpdCdzIG5vdCBuZWVkZWQuXG4gICAgaWYgKGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpKVxuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGZyb20sIHRvLCBzbGljZSk7XG4gICAgcmV0dXJuIG5ldyBGaXR0ZXIoJGZyb20sICR0bywgc2xpY2UpLmZpdCgpO1xufVxuZnVuY3Rpb24gZml0c1RyaXZpYWxseSgkZnJvbSwgJHRvLCBzbGljZSkge1xuICAgIHJldHVybiAhc2xpY2Uub3BlblN0YXJ0ICYmICFzbGljZS5vcGVuRW5kICYmICRmcm9tLnN0YXJ0KCkgPT0gJHRvLnN0YXJ0KCkgJiZcbiAgICAgICAgJGZyb20ucGFyZW50LmNhblJlcGxhY2UoJGZyb20uaW5kZXgoKSwgJHRvLmluZGV4KCksIHNsaWNlLmNvbnRlbnQpO1xufVxuLy8gQWxnb3JpdGhtIGZvciAncGxhY2luZycgdGhlIGVsZW1lbnRzIG9mIGEgc2xpY2UgaW50byBhIGdhcDpcbi8vXG4vLyBXZSBjb25zaWRlciB0aGUgY29udGVudCBvZiBlYWNoIG5vZGUgdGhhdCBpcyBvcGVuIHRvIHRoZSBsZWZ0IHRvIGJlXG4vLyBpbmRlcGVuZGVudGx5IHBsYWNlYWJsZS4gSS5lLiBpbiA8cChcImZvb1wiKSwgcChcImJhclwiKT4sIHdoZW4gdGhlXG4vLyBwYXJhZ3JhcGggb24gdGhlIGxlZnQgaXMgb3BlbiwgXCJmb29cIiBjYW4gYmUgcGxhY2VkIChzb21ld2hlcmUgb25cbi8vIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHJlcGxhY2VtZW50IGdhcCkgaW5kZXBlbmRlbnRseSBmcm9tIHAoXCJiYXJcIikuXG4vL1xuLy8gVGhpcyBjbGFzcyB0cmFja3MgdGhlIHN0YXRlIG9mIHRoZSBwbGFjZW1lbnQgcHJvZ3Jlc3MgaW4gdGhlXG4vLyBmb2xsb3dpbmcgcHJvcGVydGllczpcbi8vXG4vLyAgLSBgZnJvbnRpZXJgIGhvbGRzIGEgc3RhY2sgb2YgYHt0eXBlLCBtYXRjaH1gIG9iamVjdHMgdGhhdFxuLy8gICAgcmVwcmVzZW50IHRoZSBvcGVuIHNpZGUgb2YgdGhlIHJlcGxhY2VtZW50LiBJdCBzdGFydHMgYXRcbi8vICAgIGAkZnJvbWAsIHRoZW4gbW92ZXMgZm9yd2FyZCBhcyBjb250ZW50IGlzIHBsYWNlZCwgYW5kIGlzIGZpbmFsbHlcbi8vICAgIHJlY29uY2lsZWQgd2l0aCBgJHRvYC5cbi8vXG4vLyAgLSBgdW5wbGFjZWRgIGlzIGEgc2xpY2UgdGhhdCByZXByZXNlbnRzIHRoZSBjb250ZW50IHRoYXQgaGFzbid0XG4vLyAgICBiZWVuIHBsYWNlZCB5ZXQuXG4vL1xuLy8gIC0gYHBsYWNlZGAgaXMgYSBmcmFnbWVudCBvZiBwbGFjZWQgY29udGVudC4gSXRzIG9wZW4tc3RhcnQgdmFsdWVcbi8vICAgIGlzIGltcGxpY2l0IGluIGAkZnJvbWAsIGFuZCBpdHMgb3Blbi1lbmQgdmFsdWUgaW4gYGZyb250aWVyYC5cbmNsYXNzIEZpdHRlciB7XG4gICAgY29uc3RydWN0b3IoJGZyb20sICR0bywgdW5wbGFjZWQpIHtcbiAgICAgICAgdGhpcy4kZnJvbSA9ICRmcm9tO1xuICAgICAgICB0aGlzLiR0byA9ICR0bztcbiAgICAgICAgdGhpcy51bnBsYWNlZCA9IHVucGxhY2VkO1xuICAgICAgICB0aGlzLmZyb250aWVyID0gW107XG4gICAgICAgIHRoaXMucGxhY2VkID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9ICRmcm9tLmRlcHRoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gJGZyb20ubm9kZShpKTtcbiAgICAgICAgICAgIHRoaXMuZnJvbnRpZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgIG1hdGNoOiBub2RlLmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4QWZ0ZXIoaSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gJGZyb20uZGVwdGg7IGkgPiAwOyBpLS0pXG4gICAgICAgICAgICB0aGlzLnBsYWNlZCA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShpKS5jb3B5KHRoaXMucGxhY2VkKSk7XG4gICAgfVxuICAgIGdldCBkZXB0aCgpIHsgcmV0dXJuIHRoaXMuZnJvbnRpZXIubGVuZ3RoIC0gMTsgfVxuICAgIGZpdCgpIHtcbiAgICAgICAgLy8gQXMgbG9uZyBhcyB0aGVyZSdzIHVucGxhY2VkIGNvbnRlbnQsIHRyeSB0byBwbGFjZSBzb21lIG9mIGl0LlxuICAgICAgICAvLyBJZiB0aGF0IGZhaWxzLCBlaXRoZXIgaW5jcmVhc2UgdGhlIG9wZW4gc2NvcmUgb2YgdGhlIHVucGxhY2VkXG4gICAgICAgIC8vIHNsaWNlLCBvciBkcm9wIG5vZGVzIGZyb20gaXQsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICAgICAgd2hpbGUgKHRoaXMudW5wbGFjZWQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGZpdCA9IHRoaXMuZmluZEZpdHRhYmxlKCk7XG4gICAgICAgICAgICBpZiAoZml0KVxuICAgICAgICAgICAgICAgIHRoaXMucGxhY2VOb2RlcyhmaXQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMub3Blbk1vcmUoKSB8fCB0aGlzLmRyb3BOb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB0aGVyZSdzIGlubGluZSBjb250ZW50IGRpcmVjdGx5IGFmdGVyIHRoZSBmcm9udGllciBfYW5kX1xuICAgICAgICAvLyBkaXJlY3RseSBhZnRlciBgdGhpcy4kdG9gLCB3ZSBtdXN0IGdlbmVyYXRlIGEgYFJlcGxhY2VBcm91bmRgXG4gICAgICAgIC8vIHN0ZXAgdGhhdCBwdWxscyB0aGF0IGNvbnRlbnQgaW50byB0aGUgbm9kZSBhZnRlciB0aGUgZnJvbnRpZXIuXG4gICAgICAgIC8vIFRoYXQgbWVhbnMgdGhlIGZpdHRpbmcgbXVzdCBiZSBkb25lIHRvIHRoZSBlbmQgb2YgdGhlIHRleHRibG9ja1xuICAgICAgICAvLyBub2RlIGFmdGVyIGB0aGlzLiR0b2AsIG5vdCBgdGhpcy4kdG9gIGl0c2VsZi5cbiAgICAgICAgbGV0IG1vdmVJbmxpbmUgPSB0aGlzLm11c3RNb3ZlSW5saW5lKCksIHBsYWNlZFNpemUgPSB0aGlzLnBsYWNlZC5zaXplIC0gdGhpcy5kZXB0aCAtIHRoaXMuJGZyb20uZGVwdGg7XG4gICAgICAgIGxldCAkZnJvbSA9IHRoaXMuJGZyb20sICR0byA9IHRoaXMuY2xvc2UobW92ZUlubGluZSA8IDAgPyB0aGlzLiR0byA6ICRmcm9tLmRvYy5yZXNvbHZlKG1vdmVJbmxpbmUpKTtcbiAgICAgICAgaWYgKCEkdG8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gSWYgY2xvc2luZyB0byBgJHRvYCBzdWNjZWVkZWQsIGNyZWF0ZSBhIHN0ZXBcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLnBsYWNlZCwgb3BlblN0YXJ0ID0gJGZyb20uZGVwdGgsIG9wZW5FbmQgPSAkdG8uZGVwdGg7XG4gICAgICAgIHdoaWxlIChvcGVuU3RhcnQgJiYgb3BlbkVuZCAmJiBjb250ZW50LmNoaWxkQ291bnQgPT0gMSkgeyAvLyBOb3JtYWxpemUgYnkgZHJvcHBpbmcgb3BlbiBwYXJlbnQgbm9kZXNcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgICAgICAgICAgIG9wZW5TdGFydC0tO1xuICAgICAgICAgICAgb3BlbkVuZC0tO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICBpZiAobW92ZUlubGluZSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcCgkZnJvbS5wb3MsIG1vdmVJbmxpbmUsIHRoaXMuJHRvLnBvcywgdGhpcy4kdG8uZW5kKCksIHNsaWNlLCBwbGFjZWRTaXplKTtcbiAgICAgICAgaWYgKHNsaWNlLnNpemUgfHwgJGZyb20ucG9zICE9IHRoaXMuJHRvLnBvcykgLy8gRG9uJ3QgZ2VuZXJhdGUgbm8tb3Agc3RlcHNcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoJGZyb20ucG9zLCAkdG8ucG9zLCBzbGljZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBGaW5kIGEgcG9zaXRpb24gb24gdGhlIHN0YXJ0IHNwaW5lIG9mIGB0aGlzLnVucGxhY2VkYCB0aGF0IGhhc1xuICAgIC8vIGNvbnRlbnQgdGhhdCBjYW4gYmUgbW92ZWQgc29tZXdoZXJlIG9uIHRoZSBmcm9udGllci4gUmV0dXJucyB0d29cbiAgICAvLyBkZXB0aHMsIG9uZSBmb3IgdGhlIHNsaWNlIGFuZCBvbmUgZm9yIHRoZSBmcm9udGllci5cbiAgICBmaW5kRml0dGFibGUoKSB7XG4gICAgICAgIGxldCBzdGFydERlcHRoID0gdGhpcy51bnBsYWNlZC5vcGVuU3RhcnQ7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IHRoaXMudW5wbGFjZWQuY29udGVudCwgZCA9IDAsIG9wZW5FbmQgPSB0aGlzLnVucGxhY2VkLm9wZW5FbmQ7IGQgPCBzdGFydERlcHRoOyBkKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gY3VyLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoY3VyLmNoaWxkQ291bnQgPiAxKVxuICAgICAgICAgICAgICAgIG9wZW5FbmQgPSAwO1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZS5zcGVjLmlzb2xhdGluZyAmJiBvcGVuRW5kIDw9IGQpIHtcbiAgICAgICAgICAgICAgICBzdGFydERlcHRoID0gZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ciA9IG5vZGUuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IHRyeSB3cmFwcGluZyBub2RlcyAocGFzcyAyKSBhZnRlciBmaW5kaW5nIGEgcGxhY2Ugd2l0aG91dFxuICAgICAgICAvLyB3cmFwcGluZyBmYWlsZWQuXG4gICAgICAgIGZvciAobGV0IHBhc3MgPSAxOyBwYXNzIDw9IDI7IHBhc3MrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgc2xpY2VEZXB0aCA9IHBhc3MgPT0gMSA/IHN0YXJ0RGVwdGggOiB0aGlzLnVucGxhY2VkLm9wZW5TdGFydDsgc2xpY2VEZXB0aCA+PSAwOyBzbGljZURlcHRoLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJhZ21lbnQsIHBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWNlRGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gY29udGVudEF0KHRoaXMudW5wbGFjZWQuY29udGVudCwgc2xpY2VEZXB0aCAtIDEpLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gcGFyZW50LmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMudW5wbGFjZWQuY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBmcm9udGllckRlcHRoID0gdGhpcy5kZXB0aDsgZnJvbnRpZXJEZXB0aCA+PSAwOyBmcm9udGllckRlcHRoLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbWF0Y2ggfSA9IHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF0sIHdyYXAsIGluamVjdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHBhc3MgMSwgaWYgdGhlIG5leHQgbm9kZSBtYXRjaGVzLCBvciB0aGVyZSBpcyBubyBuZXh0XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vZGUgYnV0IHRoZSBwYXJlbnRzIGxvb2sgY29tcGF0aWJsZSwgd2UndmUgZm91bmQgYVxuICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhc3MgPT0gMSAmJiAoZmlyc3QgPyBtYXRjaC5tYXRjaFR5cGUoZmlyc3QudHlwZSkgfHwgKGluamVjdCA9IG1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZnJvbShmaXJzdCksIGZhbHNlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcGFyZW50ICYmIHR5cGUuY29tcGF0aWJsZUNvbnRlbnQocGFyZW50LnR5cGUpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHNsaWNlRGVwdGgsIGZyb250aWVyRGVwdGgsIHBhcmVudCwgaW5qZWN0IH07XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHBhc3MgMiwgbG9vayBmb3IgYSBzZXQgb2Ygd3JhcHBpbmcgbm9kZXMgdGhhdCBtYWtlXG4gICAgICAgICAgICAgICAgICAgIC8vIGBmaXJzdGAgZml0IGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhc3MgPT0gMiAmJiBmaXJzdCAmJiAod3JhcCA9IG1hdGNoLmZpbmRXcmFwcGluZyhmaXJzdC50eXBlKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzbGljZURlcHRoLCBmcm9udGllckRlcHRoLCBwYXJlbnQsIHdyYXAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY29udGludWUgbG9va2luZyBmdXJ0aGVyIHVwIGlmIHRoZSBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyB3b3VsZCBmaXQgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBtYXRjaC5tYXRjaFR5cGUocGFyZW50LnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG9wZW5Nb3JlKCkge1xuICAgICAgICBsZXQgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHRoaXMudW5wbGFjZWQ7XG4gICAgICAgIGxldCBpbm5lciA9IGNvbnRlbnRBdChjb250ZW50LCBvcGVuU3RhcnQpO1xuICAgICAgICBpZiAoIWlubmVyLmNoaWxkQ291bnQgfHwgaW5uZXIuZmlyc3RDaGlsZC5pc0xlYWYpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgU2xpY2UoY29udGVudCwgb3BlblN0YXJ0ICsgMSwgTWF0aC5tYXgob3BlbkVuZCwgaW5uZXIuc2l6ZSArIG9wZW5TdGFydCA+PSBjb250ZW50LnNpemUgLSBvcGVuRW5kID8gb3BlblN0YXJ0ICsgMSA6IDApKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRyb3BOb2RlKCkge1xuICAgICAgICBsZXQgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHRoaXMudW5wbGFjZWQ7XG4gICAgICAgIGxldCBpbm5lciA9IGNvbnRlbnRBdChjb250ZW50LCBvcGVuU3RhcnQpO1xuICAgICAgICBpZiAoaW5uZXIuY2hpbGRDb3VudCA8PSAxICYmIG9wZW5TdGFydCA+IDApIHtcbiAgICAgICAgICAgIGxldCBvcGVuQXRFbmQgPSBjb250ZW50LnNpemUgLSBvcGVuU3RhcnQgPD0gb3BlblN0YXJ0ICsgaW5uZXIuc2l6ZTtcbiAgICAgICAgICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChjb250ZW50LCBvcGVuU3RhcnQgLSAxLCAxKSwgb3BlblN0YXJ0IC0gMSwgb3BlbkF0RW5kID8gb3BlblN0YXJ0IC0gMSA6IG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KGNvbnRlbnQsIG9wZW5TdGFydCwgMSksIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTW92ZSBjb250ZW50IGZyb20gdGhlIHVucGxhY2VkIHNsaWNlIGF0IGBzbGljZURlcHRoYCB0byB0aGVcbiAgICAvLyBmcm9udGllciBub2RlIGF0IGBmcm9udGllckRlcHRoYC4gQ2xvc2UgdGhhdCBmcm9udGllciBub2RlIHdoZW5cbiAgICAvLyBhcHBsaWNhYmxlLlxuICAgIHBsYWNlTm9kZXMoeyBzbGljZURlcHRoLCBmcm9udGllckRlcHRoLCBwYXJlbnQsIGluamVjdCwgd3JhcCB9KSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmRlcHRoID4gZnJvbnRpZXJEZXB0aClcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGcm9udGllck5vZGUoKTtcbiAgICAgICAgaWYgKHdyYXApXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyYXAubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuRnJvbnRpZXJOb2RlKHdyYXBbaV0pO1xuICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLnVucGxhY2VkLCBmcmFnbWVudCA9IHBhcmVudCA/IHBhcmVudC5jb250ZW50IDogc2xpY2UuY29udGVudDtcbiAgICAgICAgbGV0IG9wZW5TdGFydCA9IHNsaWNlLm9wZW5TdGFydCAtIHNsaWNlRGVwdGg7XG4gICAgICAgIGxldCB0YWtlbiA9IDAsIGFkZCA9IFtdO1xuICAgICAgICBsZXQgeyBtYXRjaCwgdHlwZSB9ID0gdGhpcy5mcm9udGllcltmcm9udGllckRlcHRoXTtcbiAgICAgICAgaWYgKGluamVjdCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmplY3QuY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICAgICAgICAgIGFkZC5wdXNoKGluamVjdC5jaGlsZChpKSk7XG4gICAgICAgICAgICBtYXRjaCA9IG1hdGNoLm1hdGNoRnJhZ21lbnQoaW5qZWN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlcyB0aGUgYW1vdW50IG9mIChlbmQpIG9wZW4gbm9kZXMgYXQgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgLy8gZnJhZ21lbnQuIFdoZW4gMCwgdGhlIHBhcmVudCBpcyBvcGVuLCBidXQgbm8gbW9yZS4gV2hlblxuICAgICAgICAvLyBuZWdhdGl2ZSwgbm90aGluZyBpcyBvcGVuLlxuICAgICAgICBsZXQgb3BlbkVuZENvdW50ID0gKGZyYWdtZW50LnNpemUgKyBzbGljZURlcHRoKSAtIChzbGljZS5jb250ZW50LnNpemUgLSBzbGljZS5vcGVuRW5kKTtcbiAgICAgICAgLy8gU2NhbiBvdmVyIHRoZSBmcmFnbWVudCwgZml0dGluZyBhcyBtYW55IGNoaWxkIG5vZGVzIGFzXG4gICAgICAgIC8vIHBvc3NpYmxlLlxuICAgICAgICB3aGlsZSAodGFrZW4gPCBmcmFnbWVudC5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGZyYWdtZW50LmNoaWxkKHRha2VuKSwgbWF0Y2hlcyA9IG1hdGNoLm1hdGNoVHlwZShuZXh0LnR5cGUpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdGFrZW4rKztcbiAgICAgICAgICAgIGlmICh0YWtlbiA+IDEgfHwgb3BlblN0YXJ0ID09IDAgfHwgbmV4dC5jb250ZW50LnNpemUpIHsgLy8gRHJvcCBlbXB0eSBvcGVuIG5vZGVzXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaGVzO1xuICAgICAgICAgICAgICAgIGFkZC5wdXNoKGNsb3NlTm9kZVN0YXJ0KG5leHQubWFyayh0eXBlLmFsbG93ZWRNYXJrcyhuZXh0Lm1hcmtzKSksIHRha2VuID09IDEgPyBvcGVuU3RhcnQgOiAwLCB0YWtlbiA9PSBmcmFnbWVudC5jaGlsZENvdW50ID8gb3BlbkVuZENvdW50IDogLTEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9FbmQgPSB0YWtlbiA9PSBmcmFnbWVudC5jaGlsZENvdW50O1xuICAgICAgICBpZiAoIXRvRW5kKVxuICAgICAgICAgICAgb3BlbkVuZENvdW50ID0gLTE7XG4gICAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgZnJvbnRpZXJEZXB0aCwgRnJhZ21lbnQuZnJvbShhZGQpKTtcbiAgICAgICAgdGhpcy5mcm9udGllcltmcm9udGllckRlcHRoXS5tYXRjaCA9IG1hdGNoO1xuICAgICAgICAvLyBJZiB0aGUgcGFyZW50IHR5cGVzIG1hdGNoLCBhbmQgdGhlIGVudGlyZSBub2RlIHdhcyBtb3ZlZCwgYW5kXG4gICAgICAgIC8vIGl0J3Mgbm90IG9wZW4sIGNsb3NlIHRoaXMgZnJvbnRpZXIgbm9kZSByaWdodCBhd2F5LlxuICAgICAgICBpZiAodG9FbmQgJiYgb3BlbkVuZENvdW50IDwgMCAmJiBwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXS50eXBlICYmIHRoaXMuZnJvbnRpZXIubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGcm9udGllck5vZGUoKTtcbiAgICAgICAgLy8gQWRkIG5ldyBmcm9udGllciBub2RlcyBmb3IgYW55IG9wZW4gbm9kZXMgYXQgdGhlIGVuZC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGN1ciA9IGZyYWdtZW50OyBpIDwgb3BlbkVuZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gY3VyLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHRoaXMuZnJvbnRpZXIucHVzaCh7IHR5cGU6IG5vZGUudHlwZSwgbWF0Y2g6IG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KSB9KTtcbiAgICAgICAgICAgIGN1ciA9IG5vZGUuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgYHRoaXMudW5wbGFjZWRgLiBEcm9wIHRoZSBlbnRpcmUgbm9kZSBmcm9tIHdoaWNoIHdlXG4gICAgICAgIC8vIHBsYWNlZCBpdCB3ZSBnb3QgdG8gaXRzIGVuZCwgb3RoZXJ3aXNlIGp1c3QgZHJvcCB0aGUgcGxhY2VkXG4gICAgICAgIC8vIG5vZGVzLlxuICAgICAgICB0aGlzLnVucGxhY2VkID0gIXRvRW5kID8gbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoc2xpY2UuY29udGVudCwgc2xpY2VEZXB0aCwgdGFrZW4pLCBzbGljZS5vcGVuU3RhcnQsIHNsaWNlLm9wZW5FbmQpXG4gICAgICAgICAgICA6IHNsaWNlRGVwdGggPT0gMCA/IFNsaWNlLmVtcHR5XG4gICAgICAgICAgICAgICAgOiBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChzbGljZS5jb250ZW50LCBzbGljZURlcHRoIC0gMSwgMSksIHNsaWNlRGVwdGggLSAxLCBvcGVuRW5kQ291bnQgPCAwID8gc2xpY2Uub3BlbkVuZCA6IHNsaWNlRGVwdGggLSAxKTtcbiAgICB9XG4gICAgbXVzdE1vdmVJbmxpbmUoKSB7XG4gICAgICAgIGlmICghdGhpcy4kdG8ucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBsZXQgdG9wID0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXSwgbGV2ZWw7XG4gICAgICAgIGlmICghdG9wLnR5cGUuaXNUZXh0YmxvY2sgfHwgIWNvbnRlbnRBZnRlckZpdHModGhpcy4kdG8sIHRoaXMuJHRvLmRlcHRoLCB0b3AudHlwZSwgdG9wLm1hdGNoLCBmYWxzZSkgfHxcbiAgICAgICAgICAgICh0aGlzLiR0by5kZXB0aCA9PSB0aGlzLmRlcHRoICYmIChsZXZlbCA9IHRoaXMuZmluZENsb3NlTGV2ZWwodGhpcy4kdG8pKSAmJiBsZXZlbC5kZXB0aCA9PSB0aGlzLmRlcHRoKSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgbGV0IHsgZGVwdGggfSA9IHRoaXMuJHRvLCBhZnRlciA9IHRoaXMuJHRvLmFmdGVyKGRlcHRoKTtcbiAgICAgICAgd2hpbGUgKGRlcHRoID4gMSAmJiBhZnRlciA9PSB0aGlzLiR0by5lbmQoLS1kZXB0aCkpXG4gICAgICAgICAgICArK2FmdGVyO1xuICAgICAgICByZXR1cm4gYWZ0ZXI7XG4gICAgfVxuICAgIGZpbmRDbG9zZUxldmVsKCR0bykge1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBpID0gTWF0aC5taW4odGhpcy5kZXB0aCwgJHRvLmRlcHRoKTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB7IG1hdGNoLCB0eXBlIH0gPSB0aGlzLmZyb250aWVyW2ldO1xuICAgICAgICAgICAgbGV0IGRyb3BJbm5lciA9IGkgPCAkdG8uZGVwdGggJiYgJHRvLmVuZChpICsgMSkgPT0gJHRvLnBvcyArICgkdG8uZGVwdGggLSAoaSArIDEpKTtcbiAgICAgICAgICAgIGxldCBmaXQgPSBjb250ZW50QWZ0ZXJGaXRzKCR0bywgaSwgdHlwZSwgbWF0Y2gsIGRyb3BJbm5lcik7XG4gICAgICAgICAgICBpZiAoIWZpdClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSBpIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBtYXRjaCwgdHlwZSB9ID0gdGhpcy5mcm9udGllcltkXTtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlcyA9IGNvbnRlbnRBZnRlckZpdHMoJHRvLCBkLCB0eXBlLCBtYXRjaCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRlcHRoOiBpLCBmaXQsIG1vdmU6IGRyb3BJbm5lciA/ICR0by5kb2MucmVzb2x2ZSgkdG8uYWZ0ZXIoaSArIDEpKSA6ICR0byB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKCR0bykge1xuICAgICAgICBsZXQgY2xvc2UgPSB0aGlzLmZpbmRDbG9zZUxldmVsKCR0byk7XG4gICAgICAgIGlmICghY2xvc2UpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKHRoaXMuZGVwdGggPiBjbG9zZS5kZXB0aClcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGcm9udGllck5vZGUoKTtcbiAgICAgICAgaWYgKGNsb3NlLmZpdC5jaGlsZENvdW50KVxuICAgICAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCBjbG9zZS5kZXB0aCwgY2xvc2UuZml0KTtcbiAgICAgICAgJHRvID0gY2xvc2UubW92ZTtcbiAgICAgICAgZm9yIChsZXQgZCA9IGNsb3NlLmRlcHRoICsgMTsgZCA8PSAkdG8uZGVwdGg7IGQrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSAkdG8ubm9kZShkKSwgYWRkID0gbm9kZS50eXBlLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKG5vZGUuY29udGVudCwgdHJ1ZSwgJHRvLmluZGV4KGQpKTtcbiAgICAgICAgICAgIHRoaXMub3BlbkZyb250aWVyTm9kZShub2RlLnR5cGUsIG5vZGUuYXR0cnMsIGFkZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0bztcbiAgICB9XG4gICAgb3BlbkZyb250aWVyTm9kZSh0eXBlLCBhdHRycyA9IG51bGwsIGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMuZnJvbnRpZXJbdGhpcy5kZXB0aF07XG4gICAgICAgIHRvcC5tYXRjaCA9IHRvcC5tYXRjaC5tYXRjaFR5cGUodHlwZSk7XG4gICAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgdGhpcy5kZXB0aCwgRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZShhdHRycywgY29udGVudCkpKTtcbiAgICAgICAgdGhpcy5mcm9udGllci5wdXNoKHsgdHlwZSwgbWF0Y2g6IHR5cGUuY29udGVudE1hdGNoIH0pO1xuICAgIH1cbiAgICBjbG9zZUZyb250aWVyTm9kZSgpIHtcbiAgICAgICAgbGV0IG9wZW4gPSB0aGlzLmZyb250aWVyLnBvcCgpO1xuICAgICAgICBsZXQgYWRkID0gb3Blbi5tYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgICAgaWYgKGFkZC5jaGlsZENvdW50KVxuICAgICAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCB0aGlzLmZyb250aWVyLmxlbmd0aCwgYWRkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkcm9wRnJvbUZyYWdtZW50KGZyYWdtZW50LCBkZXB0aCwgY291bnQpIHtcbiAgICBpZiAoZGVwdGggPT0gMClcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LmN1dEJ5SW5kZXgoY291bnQsIGZyYWdtZW50LmNoaWxkQ291bnQpO1xuICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoMCwgZnJhZ21lbnQuZmlyc3RDaGlsZC5jb3B5KGRyb3BGcm9tRnJhZ21lbnQoZnJhZ21lbnQuZmlyc3RDaGlsZC5jb250ZW50LCBkZXB0aCAtIDEsIGNvdW50KSkpO1xufVxuZnVuY3Rpb24gYWRkVG9GcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIGNvbnRlbnQpIHtcbiAgICBpZiAoZGVwdGggPT0gMClcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LmFwcGVuZChjb250ZW50KTtcbiAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZUNoaWxkKGZyYWdtZW50LmNoaWxkQ291bnQgLSAxLCBmcmFnbWVudC5sYXN0Q2hpbGQuY29weShhZGRUb0ZyYWdtZW50KGZyYWdtZW50Lmxhc3RDaGlsZC5jb250ZW50LCBkZXB0aCAtIDEsIGNvbnRlbnQpKSk7XG59XG5mdW5jdGlvbiBjb250ZW50QXQoZnJhZ21lbnQsIGRlcHRoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXB0aDsgaSsrKVxuICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG59XG5mdW5jdGlvbiBjbG9zZU5vZGVTdGFydChub2RlLCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICBpZiAob3BlblN0YXJ0IDw9IDApXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIGxldCBmcmFnID0gbm9kZS5jb250ZW50O1xuICAgIGlmIChvcGVuU3RhcnQgPiAxKVxuICAgICAgICBmcmFnID0gZnJhZy5yZXBsYWNlQ2hpbGQoMCwgY2xvc2VOb2RlU3RhcnQoZnJhZy5maXJzdENoaWxkLCBvcGVuU3RhcnQgLSAxLCBmcmFnLmNoaWxkQ291bnQgPT0gMSA/IG9wZW5FbmQgLSAxIDogMCkpO1xuICAgIGlmIChvcGVuU3RhcnQgPiAwKSB7XG4gICAgICAgIGZyYWcgPSBub2RlLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoZnJhZykuYXBwZW5kKGZyYWcpO1xuICAgICAgICBpZiAob3BlbkVuZCA8PSAwKVxuICAgICAgICAgICAgZnJhZyA9IGZyYWcuYXBwZW5kKG5vZGUudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChmcmFnKS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLmNvcHkoZnJhZyk7XG59XG5mdW5jdGlvbiBjb250ZW50QWZ0ZXJGaXRzKCR0bywgZGVwdGgsIHR5cGUsIG1hdGNoLCBvcGVuKSB7XG4gICAgbGV0IG5vZGUgPSAkdG8ubm9kZShkZXB0aCksIGluZGV4ID0gb3BlbiA/ICR0by5pbmRleEFmdGVyKGRlcHRoKSA6ICR0by5pbmRleChkZXB0aCk7XG4gICAgaWYgKGluZGV4ID09IG5vZGUuY2hpbGRDb3VudCAmJiAhdHlwZS5jb21wYXRpYmxlQ29udGVudChub2RlLnR5cGUpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZml0ID0gbWF0Y2guZmlsbEJlZm9yZShub2RlLmNvbnRlbnQsIHRydWUsIGluZGV4KTtcbiAgICByZXR1cm4gZml0ICYmICFpbnZhbGlkTWFya3ModHlwZSwgbm9kZS5jb250ZW50LCBpbmRleCkgPyBmaXQgOiBudWxsO1xufVxuZnVuY3Rpb24gaW52YWxpZE1hcmtzKHR5cGUsIGZyYWdtZW50LCBzdGFydCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGZyYWdtZW50LmNoaWxkQ291bnQ7IGkrKylcbiAgICAgICAgaWYgKCF0eXBlLmFsbG93c01hcmtzKGZyYWdtZW50LmNoaWxkKGkpLm1hcmtzKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRlZmluZXNDb250ZW50KHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZS5zcGVjLmRlZmluaW5nIHx8IHR5cGUuc3BlYy5kZWZpbmluZ0ZvckNvbnRlbnQ7XG59XG5mdW5jdGlvbiByZXBsYWNlUmFuZ2UodHIsIGZyb20sIHRvLCBzbGljZSkge1xuICAgIGlmICghc2xpY2Uuc2l6ZSlcbiAgICAgICAgcmV0dXJuIHRyLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICBsZXQgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gdHIuZG9jLnJlc29sdmUodG8pO1xuICAgIGlmIChmaXRzVHJpdmlhbGx5KCRmcm9tLCAkdG8sIHNsaWNlKSlcbiAgICAgICAgcmV0dXJuIHRyLnN0ZXAobmV3IFJlcGxhY2VTdGVwKGZyb20sIHRvLCBzbGljZSkpO1xuICAgIGxldCB0YXJnZXREZXB0aHMgPSBjb3ZlcmVkRGVwdGhzKCRmcm9tLCB0ci5kb2MucmVzb2x2ZSh0bykpO1xuICAgIC8vIENhbid0IHJlcGxhY2UgdGhlIHdob2xlIGRvY3VtZW50LCBzbyByZW1vdmUgMCBpZiBpdCdzIHByZXNlbnRcbiAgICBpZiAodGFyZ2V0RGVwdGhzW3RhcmdldERlcHRocy5sZW5ndGggLSAxXSA9PSAwKVxuICAgICAgICB0YXJnZXREZXB0aHMucG9wKCk7XG4gICAgLy8gTmVnYXRpdmUgbnVtYmVycyByZXByZXNlbnQgbm90IGV4cGFuc2lvbiBvdmVyIHRoZSB3aG9sZSBub2RlIGF0XG4gICAgLy8gdGhhdCBkZXB0aCwgYnV0IHJlcGxhY2luZyBmcm9tICRmcm9tLmJlZm9yZSgtRCkgdG8gJHRvLnBvcy5cbiAgICBsZXQgcHJlZmVycmVkVGFyZ2V0ID0gLSgkZnJvbS5kZXB0aCArIDEpO1xuICAgIHRhcmdldERlcHRocy51bnNoaWZ0KHByZWZlcnJlZFRhcmdldCk7XG4gICAgLy8gVGhpcyBsb29wIHBpY2tzIGEgcHJlZmVycmVkIHRhcmdldCBkZXB0aCwgaWYgb25lIG9mIHRoZSBjb3ZlcmluZ1xuICAgIC8vIGRlcHRocyBpcyBub3Qgb3V0c2lkZSBvZiBhIGRlZmluaW5nIG5vZGUsIGFuZCBhZGRzIG5lZ2F0aXZlXG4gICAgLy8gZGVwdGhzIGZvciBhbnkgZGVwdGggdGhhdCBoYXMgJGZyb20gYXQgaXRzIHN0YXJ0IGFuZCBkb2VzIG5vdFxuICAgIC8vIGNyb3NzIGEgZGVmaW5pbmcgbm9kZS5cbiAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGgsIHBvcyA9ICRmcm9tLnBvcyAtIDE7IGQgPiAwOyBkLS0sIHBvcy0tKSB7XG4gICAgICAgIGxldCBzcGVjID0gJGZyb20ubm9kZShkKS50eXBlLnNwZWM7XG4gICAgICAgIGlmIChzcGVjLmRlZmluaW5nIHx8IHNwZWMuZGVmaW5pbmdBc0NvbnRleHQgfHwgc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHRhcmdldERlcHRocy5pbmRleE9mKGQpID4gLTEpXG4gICAgICAgICAgICBwcmVmZXJyZWRUYXJnZXQgPSBkO1xuICAgICAgICBlbHNlIGlmICgkZnJvbS5iZWZvcmUoZCkgPT0gcG9zKVxuICAgICAgICAgICAgdGFyZ2V0RGVwdGhzLnNwbGljZSgxLCAwLCAtZCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byBmaXQgZWFjaCBwb3NzaWJsZSBkZXB0aCBvZiB0aGUgc2xpY2UgaW50byBlYWNoIHBvc3NpYmxlXG4gICAgLy8gdGFyZ2V0IGRlcHRoLCBzdGFydGluZyB3aXRoIHRoZSBwcmVmZXJyZWQgZGVwdGhzLlxuICAgIGxldCBwcmVmZXJyZWRUYXJnZXRJbmRleCA9IHRhcmdldERlcHRocy5pbmRleE9mKHByZWZlcnJlZFRhcmdldCk7XG4gICAgbGV0IGxlZnROb2RlcyA9IFtdLCBwcmVmZXJyZWREZXB0aCA9IHNsaWNlLm9wZW5TdGFydDtcbiAgICBmb3IgKGxldCBjb250ZW50ID0gc2xpY2UuY29udGVudCwgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBjb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGxlZnROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAoaSA9PSBzbGljZS5vcGVuU3RhcnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY29udGVudCA9IG5vZGUuY29udGVudDtcbiAgICB9XG4gICAgLy8gQmFjayB1cCBwcmVmZXJyZWREZXB0aCB0byBjb3ZlciBkZWZpbmluZyB0ZXh0YmxvY2tzIGRpcmVjdGx5XG4gICAgLy8gYWJvdmUgaXQsIHBvc3NpYmx5IHNraXBwaW5nIGEgbm9uLWRlZmluaW5nIHRleHRibG9jay5cbiAgICBmb3IgKGxldCBkID0gcHJlZmVycmVkRGVwdGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgbGVmdE5vZGUgPSBsZWZ0Tm9kZXNbZF0sIGRlZiA9IGRlZmluZXNDb250ZW50KGxlZnROb2RlLnR5cGUpO1xuICAgICAgICBpZiAoZGVmICYmICFsZWZ0Tm9kZS5zYW1lTWFya3VwKCRmcm9tLm5vZGUoTWF0aC5hYnMocHJlZmVycmVkVGFyZ2V0KSAtIDEpKSlcbiAgICAgICAgICAgIHByZWZlcnJlZERlcHRoID0gZDtcbiAgICAgICAgZWxzZSBpZiAoZGVmIHx8ICFsZWZ0Tm9kZS50eXBlLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBzbGljZS5vcGVuU3RhcnQ7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIGxldCBvcGVuRGVwdGggPSAoaiArIHByZWZlcnJlZERlcHRoICsgMSkgJSAoc2xpY2Uub3BlblN0YXJ0ICsgMSk7XG4gICAgICAgIGxldCBpbnNlcnQgPSBsZWZ0Tm9kZXNbb3BlbkRlcHRoXTtcbiAgICAgICAgaWYgKCFpbnNlcnQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXREZXB0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIExvb3Agb3ZlciBwb3NzaWJsZSBleHBhbnNpb24gbGV2ZWxzLCBzdGFydGluZyB3aXRoIHRoZVxuICAgICAgICAgICAgLy8gcHJlZmVycmVkIG9uZVxuICAgICAgICAgICAgbGV0IHRhcmdldERlcHRoID0gdGFyZ2V0RGVwdGhzWyhpICsgcHJlZmVycmVkVGFyZ2V0SW5kZXgpICUgdGFyZ2V0RGVwdGhzLmxlbmd0aF0sIGV4cGFuZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RGVwdGggPCAwKSB7XG4gICAgICAgICAgICAgICAgZXhwYW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RGVwdGggPSAtdGFyZ2V0RGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gJGZyb20ubm9kZSh0YXJnZXREZXB0aCAtIDEpLCBpbmRleCA9ICRmcm9tLmluZGV4KHRhcmdldERlcHRoIC0gMSk7XG4gICAgICAgICAgICBpZiAocGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgaW5zZXJ0LnR5cGUsIGluc2VydC5tYXJrcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyLnJlcGxhY2UoJGZyb20uYmVmb3JlKHRhcmdldERlcHRoKSwgZXhwYW5kID8gJHRvLmFmdGVyKHRhcmdldERlcHRoKSA6IHRvLCBuZXcgU2xpY2UoY2xvc2VGcmFnbWVudChzbGljZS5jb250ZW50LCAwLCBzbGljZS5vcGVuU3RhcnQsIG9wZW5EZXB0aCksIG9wZW5EZXB0aCwgc2xpY2Uub3BlbkVuZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdGFydFN0ZXBzID0gdHIuc3RlcHMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSB0YXJnZXREZXB0aHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdHIucmVwbGFjZShmcm9tLCB0bywgc2xpY2UpO1xuICAgICAgICBpZiAodHIuc3RlcHMubGVuZ3RoID4gc3RhcnRTdGVwcylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgZGVwdGggPSB0YXJnZXREZXB0aHNbaV07XG4gICAgICAgIGlmIChkZXB0aCA8IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZnJvbSA9ICRmcm9tLmJlZm9yZShkZXB0aCk7XG4gICAgICAgIHRvID0gJHRvLmFmdGVyKGRlcHRoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbG9zZUZyYWdtZW50KGZyYWdtZW50LCBkZXB0aCwgb2xkT3BlbiwgbmV3T3BlbiwgcGFyZW50KSB7XG4gICAgaWYgKGRlcHRoIDwgb2xkT3Blbikge1xuICAgICAgICBsZXQgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2VDaGlsZCgwLCBmaXJzdC5jb3B5KGNsb3NlRnJhZ21lbnQoZmlyc3QuY29udGVudCwgZGVwdGggKyAxLCBvbGRPcGVuLCBuZXdPcGVuLCBmaXJzdCkpKTtcbiAgICB9XG4gICAgaWYgKGRlcHRoID4gbmV3T3Blbikge1xuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJlbnQuY29udGVudE1hdGNoQXQoMCk7XG4gICAgICAgIGxldCBzdGFydCA9IG1hdGNoLmZpbGxCZWZvcmUoZnJhZ21lbnQpLmFwcGVuZChmcmFnbWVudCk7XG4gICAgICAgIGZyYWdtZW50ID0gc3RhcnQuYXBwZW5kKG1hdGNoLm1hdGNoRnJhZ21lbnQoc3RhcnQpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gcmVwbGFjZVJhbmdlV2l0aCh0ciwgZnJvbSwgdG8sIG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuaXNJbmxpbmUgJiYgZnJvbSA9PSB0byAmJiB0ci5kb2MucmVzb2x2ZShmcm9tKS5wYXJlbnQuY29udGVudC5zaXplKSB7XG4gICAgICAgIGxldCBwb2ludCA9IGluc2VydFBvaW50KHRyLmRvYywgZnJvbSwgbm9kZS50eXBlKTtcbiAgICAgICAgaWYgKHBvaW50ICE9IG51bGwpXG4gICAgICAgICAgICBmcm9tID0gdG8gPSBwb2ludDtcbiAgICB9XG4gICAgdHIucmVwbGFjZVJhbmdlKGZyb20sIHRvLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShub2RlKSwgMCwgMCkpO1xufVxuZnVuY3Rpb24gZGVsZXRlUmFuZ2UodHIsIGZyb20sIHRvKSB7XG4gICAgbGV0ICRmcm9tID0gdHIuZG9jLnJlc29sdmUoZnJvbSksICR0byA9IHRyLmRvYy5yZXNvbHZlKHRvKTtcbiAgICBsZXQgY292ZXJlZCA9IGNvdmVyZWREZXB0aHMoJGZyb20sICR0byk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3ZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBkZXB0aCA9IGNvdmVyZWRbaV0sIGxhc3QgPSBpID09IGNvdmVyZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKChsYXN0ICYmIGRlcHRoID09IDApIHx8ICRmcm9tLm5vZGUoZGVwdGgpLnR5cGUuY29udGVudE1hdGNoLnZhbGlkRW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRyLmRlbGV0ZSgkZnJvbS5zdGFydChkZXB0aCksICR0by5lbmQoZGVwdGgpKTtcbiAgICAgICAgaWYgKGRlcHRoID4gMCAmJiAobGFzdCB8fCAkZnJvbS5ub2RlKGRlcHRoIC0gMSkuY2FuUmVwbGFjZSgkZnJvbS5pbmRleChkZXB0aCAtIDEpLCAkdG8uaW5kZXhBZnRlcihkZXB0aCAtIDEpKSkpXG4gICAgICAgICAgICByZXR1cm4gdHIuZGVsZXRlKCRmcm9tLmJlZm9yZShkZXB0aCksICR0by5hZnRlcihkZXB0aCkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBkID0gMTsgZCA8PSAkZnJvbS5kZXB0aCAmJiBkIDw9ICR0by5kZXB0aDsgZCsrKSB7XG4gICAgICAgIGlmIChmcm9tIC0gJGZyb20uc3RhcnQoZCkgPT0gJGZyb20uZGVwdGggLSBkICYmIHRvID4gJGZyb20uZW5kKGQpICYmICR0by5lbmQoZCkgLSB0byAhPSAkdG8uZGVwdGggLSBkKVxuICAgICAgICAgICAgcmV0dXJuIHRyLmRlbGV0ZSgkZnJvbS5iZWZvcmUoZCksIHRvKTtcbiAgICB9XG4gICAgdHIuZGVsZXRlKGZyb20sIHRvKTtcbn1cbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGRlcHRocyBmb3Igd2hpY2ggJGZyb20gLSAkdG8gc3BhbnMgdGhlXG4vLyB3aG9sZSBjb250ZW50IG9mIHRoZSBub2RlcyBhdCB0aGF0IGRlcHRoLlxuZnVuY3Rpb24gY292ZXJlZERlcHRocygkZnJvbSwgJHRvKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdLCBtaW5EZXB0aCA9IE1hdGgubWluKCRmcm9tLmRlcHRoLCAkdG8uZGVwdGgpO1xuICAgIGZvciAobGV0IGQgPSBtaW5EZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gJGZyb20uc3RhcnQoZCk7XG4gICAgICAgIGlmIChzdGFydCA8ICRmcm9tLnBvcyAtICgkZnJvbS5kZXB0aCAtIGQpIHx8XG4gICAgICAgICAgICAkdG8uZW5kKGQpID4gJHRvLnBvcyArICgkdG8uZGVwdGggLSBkKSB8fFxuICAgICAgICAgICAgJGZyb20ubm9kZShkKS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8XG4gICAgICAgICAgICAkdG8ubm9kZShkKS50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChzdGFydCA9PSAkdG8uc3RhcnQoZCkgfHxcbiAgICAgICAgICAgIChkID09ICRmcm9tLmRlcHRoICYmIGQgPT0gJHRvLmRlcHRoICYmICRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50ICYmICR0by5wYXJlbnQuaW5saW5lQ29udGVudCAmJlxuICAgICAgICAgICAgICAgIGQgJiYgJHRvLnN0YXJ0KGQgLSAxKSA9PSBzdGFydCAtIDEpKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuVXBkYXRlIGFuIGF0dHJpYnV0ZSBpbiBhIHNwZWNpZmljIG5vZGUuXG4qL1xuY2xhc3MgQXR0clN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYW4gYXR0cmlidXRlIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBub2RlLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgYXR0cmlidXRlIHRvIHNldC5cbiAgICAqL1xuICAgIGF0dHIsIFxuICAgIC8vIFRoZSBhdHRyaWJ1dGUncyBuZXcgdmFsdWUuXG4gICAgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuYXR0ciA9IGF0dHI7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJObyBub2RlIGF0IGF0dHJpYnV0ZSBzdGVwJ3MgcG9zaXRpb25cIik7XG4gICAgICAgIGxldCBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gbm9kZS5hdHRycylcbiAgICAgICAgICAgIGF0dHJzW25hbWVdID0gbm9kZS5hdHRyc1tuYW1lXTtcbiAgICAgICAgYXR0cnNbdGhpcy5hdHRyXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbm9kZS50eXBlLmNyZWF0ZShhdHRycywgbnVsbCwgbm9kZS5tYXJrcyk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5wb3MsIHRoaXMucG9zICsgMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odXBkYXRlZCksIDAsIG5vZGUuaXNMZWFmID8gMCA6IDEpKTtcbiAgICB9XG4gICAgZ2V0TWFwKCkge1xuICAgICAgICByZXR1cm4gU3RlcE1hcC5lbXB0eTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJTdGVwKHRoaXMucG9zLCB0aGlzLmF0dHIsIGRvYy5ub2RlQXQodGhpcy5wb3MpLmF0dHJzW3RoaXMuYXR0cl0pO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgcG9zID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5wb3MsIDEpO1xuICAgICAgICByZXR1cm4gcG9zLmRlbGV0ZWRBZnRlciA/IG51bGwgOiBuZXcgQXR0clN0ZXAocG9zLnBvcywgdGhpcy5hdHRyLCB0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJhdHRyXCIsIHBvczogdGhpcy5wb3MsIGF0dHI6IHRoaXMuYXR0ciwgdmFsdWU6IHRoaXMudmFsdWUgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24ucG9zICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uYXR0ciAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBBdHRyU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyU3RlcChqc29uLnBvcywganNvbi5hdHRyLCBqc29uLnZhbHVlKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcImF0dHJcIiwgQXR0clN0ZXApO1xuLyoqXG5VcGRhdGUgYW4gYXR0cmlidXRlIGluIHRoZSBkb2Mgbm9kZS5cbiovXG5jbGFzcyBEb2NBdHRyU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhbiBhdHRyaWJ1dGUgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBhdHRyaWJ1dGUgdG8gc2V0LlxuICAgICovXG4gICAgYXR0ciwgXG4gICAgLy8gVGhlIGF0dHJpYnV0ZSdzIG5ldyB2YWx1ZS5cbiAgICB2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmF0dHIgPSBhdHRyO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGRvYy5hdHRycylcbiAgICAgICAgICAgIGF0dHJzW25hbWVdID0gZG9jLmF0dHJzW25hbWVdO1xuICAgICAgICBhdHRyc1t0aGlzLmF0dHJdID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBkb2MudHlwZS5jcmVhdGUoYXR0cnMsIGRvYy5jb250ZW50LCBkb2MubWFya3MpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5vayh1cGRhdGVkKTtcbiAgICB9XG4gICAgZ2V0TWFwKCkge1xuICAgICAgICByZXR1cm4gU3RlcE1hcC5lbXB0eTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IERvY0F0dHJTdGVwKHRoaXMuYXR0ciwgZG9jLmF0dHJzW3RoaXMuYXR0cl0pO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJkb2NBdHRyXCIsIGF0dHI6IHRoaXMuYXR0ciwgdmFsdWU6IHRoaXMudmFsdWUgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uYXR0ciAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBEb2NBdHRyU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2NBdHRyU3RlcChqc29uLmF0dHIsIGpzb24udmFsdWUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiZG9jQXR0clwiLCBEb2NBdHRyU3RlcCk7XG5cbi8qKlxuQGludGVybmFsXG4qL1xubGV0IFRyYW5zZm9ybUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG59O1xuVHJhbnNmb3JtRXJyb3IgPSBmdW5jdGlvbiBUcmFuc2Zvcm1FcnJvcihtZXNzYWdlKSB7XG4gICAgbGV0IGVyciA9IEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgZXJyLl9fcHJvdG9fXyA9IFRyYW5zZm9ybUVycm9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gZXJyO1xufTtcblRyYW5zZm9ybUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblRyYW5zZm9ybUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyYW5zZm9ybUVycm9yO1xuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIlRyYW5zZm9ybUVycm9yXCI7XG4vKipcbkFic3RyYWN0aW9uIHRvIGJ1aWxkIHVwIGFuZCB0cmFjayBhbiBhcnJheSBvZlxuW3N0ZXBzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXApIHJlcHJlc2VudGluZyBhIGRvY3VtZW50IHRyYW5zZm9ybWF0aW9uLlxuXG5Nb3N0IHRyYW5zZm9ybWluZyBtZXRob2RzIHJldHVybiB0aGUgYFRyYW5zZm9ybWAgb2JqZWN0IGl0c2VsZiwgc29cbnRoYXQgdGhleSBjYW4gYmUgY2hhaW5lZC5cbiovXG5jbGFzcyBUcmFuc2Zvcm0ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRyYW5zZm9ybSB0aGF0IHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGRvY3VtZW50ICh0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBzdGVwcyBpbiB0aGVcbiAgICB0cmFuc2Zvcm0pLlxuICAgICovXG4gICAgZG9jKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIHN0ZXBzIGluIHRoaXMgdHJhbnNmb3JtLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0ZXBzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgZG9jdW1lbnRzIGJlZm9yZSBlYWNoIG9mIHRoZSBzdGVwcy5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb2NzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBBIG1hcHBpbmcgd2l0aCB0aGUgbWFwcyBmb3IgZWFjaCBvZiB0aGUgc3RlcHMgaW4gdGhpcyB0cmFuc2Zvcm0uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc3RhcnRpbmcgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgYmVmb3JlKCkgeyByZXR1cm4gdGhpcy5kb2NzLmxlbmd0aCA/IHRoaXMuZG9jc1swXSA6IHRoaXMuZG9jOyB9XG4gICAgLyoqXG4gICAgQXBwbHkgYSBuZXcgc3RlcCBpbiB0aGlzIHRyYW5zZm9ybSwgc2F2aW5nIHRoZSByZXN1bHQuIFRocm93cyBhblxuICAgIGVycm9yIHdoZW4gdGhlIHN0ZXAgZmFpbHMuXG4gICAgKi9cbiAgICBzdGVwKHN0ZXApIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMubWF5YmVTdGVwKHN0ZXApO1xuICAgICAgICBpZiAocmVzdWx0LmZhaWxlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2Zvcm1FcnJvcihyZXN1bHQuZmFpbGVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBhcHBseSBhIHN0ZXAgaW4gdGhpcyB0cmFuc2Zvcm1hdGlvbiwgaWdub3JpbmcgaXQgaWYgaXRcbiAgICBmYWlscy4gUmV0dXJucyB0aGUgc3RlcCByZXN1bHQuXG4gICAgKi9cbiAgICBtYXliZVN0ZXAoc3RlcCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc3RlcC5hcHBseSh0aGlzLmRvYyk7XG4gICAgICAgIGlmICghcmVzdWx0LmZhaWxlZClcbiAgICAgICAgICAgIHRoaXMuYWRkU3RlcChzdGVwLCByZXN1bHQuZG9jKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoZSBkb2N1bWVudCBoYXMgYmVlbiBjaGFuZ2VkICh3aGVuIHRoZXJlIGFyZSBhbnlcbiAgICBzdGVwcykuXG4gICAgKi9cbiAgICBnZXQgZG9jQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcHMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRTdGVwKHN0ZXAsIGRvYykge1xuICAgICAgICB0aGlzLmRvY3MucHVzaCh0aGlzLmRvYyk7XG4gICAgICAgIHRoaXMuc3RlcHMucHVzaChzdGVwKTtcbiAgICAgICAgdGhpcy5tYXBwaW5nLmFwcGVuZE1hcChzdGVwLmdldE1hcCgpKTtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIHdpdGggdGhlXG4gICAgZ2l2ZW4gYHNsaWNlYC5cbiAgICAqL1xuICAgIHJlcGxhY2UoZnJvbSwgdG8gPSBmcm9tLCBzbGljZSA9IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgIGxldCBzdGVwID0gcmVwbGFjZVN0ZXAodGhpcy5kb2MsIGZyb20sIHRvLCBzbGljZSk7XG4gICAgICAgIGlmIChzdGVwKVxuICAgICAgICAgICAgdGhpcy5zdGVwKHN0ZXApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aCB0aGUgZ2l2ZW4gY29udGVudCwgd2hpY2ggbWF5IGJlIGFcbiAgICBmcmFnbWVudCwgbm9kZSwgb3IgYXJyYXkgb2Ygbm9kZXMuXG4gICAgKi9cbiAgICByZXBsYWNlV2l0aChmcm9tLCB0bywgY29udGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKGZyb20sIHRvLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShjb250ZW50KSwgMCwgMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWxldGUgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9zaXRpb25zLlxuICAgICovXG4gICAgZGVsZXRlKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoZnJvbSwgdG8sIFNsaWNlLmVtcHR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5zZXJ0IHRoZSBnaXZlbiBjb250ZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGluc2VydChwb3MsIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVdpdGgocG9zLCBwb3MsIGNvbnRlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgcmFuZ2Ugb2YgdGhlIGRvY3VtZW50IHdpdGggYSBnaXZlbiBzbGljZSwgdXNpbmdcbiAgICBgZnJvbWAsIGB0b2AsIGFuZCB0aGUgc2xpY2Unc1xuICAgIFtgb3BlblN0YXJ0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlNsaWNlLm9wZW5TdGFydCkgcHJvcGVydHkgYXMgaGludHMsIHJhdGhlclxuICAgIHRoYW4gZml4ZWQgc3RhcnQgYW5kIGVuZCBwb2ludHMuIFRoaXMgbWV0aG9kIG1heSBncm93IHRoZVxuICAgIHJlcGxhY2VkIGFyZWEgb3IgY2xvc2Ugb3BlbiBub2RlcyBpbiB0aGUgc2xpY2UgaW4gb3JkZXIgdG8gZ2V0IGFcbiAgICBmaXQgdGhhdCBpcyBtb3JlIGluIGxpbmUgd2l0aCBXWVNJV1lHIGV4cGVjdGF0aW9ucywgYnkgZHJvcHBpbmdcbiAgICBmdWxseSBjb3ZlcmVkIHBhcmVudCBub2RlcyBvZiB0aGUgcmVwbGFjZWQgcmVnaW9uIHdoZW4gdGhleSBhcmVcbiAgICBtYXJrZWQgW25vbi1kZWZpbmluZyBhc1xuICAgIGNvbnRleHRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5kZWZpbmluZ0FzQ29udGV4dCksIG9yIGluY2x1ZGluZyBhblxuICAgIG9wZW4gcGFyZW50IG5vZGUgZnJvbSB0aGUgc2xpY2UgdGhhdCBfaXNfIG1hcmtlZCBhcyBbZGVmaW5pbmdcbiAgICBpdHMgY29udGVudF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmRlZmluaW5nRm9yQ29udGVudCkuXG4gICAgXG4gICAgVGhpcyBpcyB0aGUgbWV0aG9kLCBmb3IgZXhhbXBsZSwgdG8gaGFuZGxlIHBhc3RlLiBUaGUgc2ltaWxhclxuICAgIFtgcmVwbGFjZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uVHJhbnNmb3JtLnJlcGxhY2UpIG1ldGhvZCBpcyBhIG1vcmVcbiAgICBwcmltaXRpdmUgdG9vbCB3aGljaCB3aWxsIF9ub3RfIG1vdmUgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgaXRzIGdpdmVuXG4gICAgcmFuZ2UsIGFuZCBpcyB1c2VmdWwgaW4gc2l0dWF0aW9ucyB3aGVyZSB5b3UgbmVlZCBtb3JlIHByZWNpc2VcbiAgICBjb250cm9sIG92ZXIgd2hhdCBoYXBwZW5zLlxuICAgICovXG4gICAgcmVwbGFjZVJhbmdlKGZyb20sIHRvLCBzbGljZSkge1xuICAgICAgICByZXBsYWNlUmFuZ2UodGhpcywgZnJvbSwgdG8sIHNsaWNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIGdpdmVuIHJhbmdlIHdpdGggYSBub2RlLCBidXQgdXNlIGBmcm9tYCBhbmQgYHRvYCBhc1xuICAgIGhpbnRzLCByYXRoZXIgdGhhbiBwcmVjaXNlIHBvc2l0aW9ucy4gV2hlbiBmcm9tIGFuZCB0byBhcmUgdGhlIHNhbWVcbiAgICBhbmQgYXJlIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgYSBwYXJlbnQgbm9kZSBpbiB3aGljaCB0aGUgZ2l2ZW5cbiAgICBub2RlIGRvZXNuJ3QgZml0LCB0aGlzIG1ldGhvZCBtYXkgX21vdmVfIHRoZW0gb3V0IHRvd2FyZHMgYSBwYXJlbnRcbiAgICB0aGF0IGRvZXMgYWxsb3cgdGhlIGdpdmVuIG5vZGUgdG8gYmUgcGxhY2VkLiBXaGVuIHRoZSBnaXZlbiByYW5nZVxuICAgIGNvbXBsZXRlbHkgY292ZXJzIGEgcGFyZW50IG5vZGUsIHRoaXMgbWV0aG9kIG1heSBjb21wbGV0ZWx5IHJlcGxhY2VcbiAgICB0aGF0IHBhcmVudCBub2RlLlxuICAgICovXG4gICAgcmVwbGFjZVJhbmdlV2l0aChmcm9tLCB0bywgbm9kZSkge1xuICAgICAgICByZXBsYWNlUmFuZ2VXaXRoKHRoaXMsIGZyb20sIHRvLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSB0aGUgZ2l2ZW4gcmFuZ2UsIGV4cGFuZGluZyBpdCB0byBjb3ZlciBmdWxseSBjb3ZlcmVkXG4gICAgcGFyZW50IG5vZGVzIHVudGlsIGEgdmFsaWQgcmVwbGFjZSBpcyBmb3VuZC5cbiAgICAqL1xuICAgIGRlbGV0ZVJhbmdlKGZyb20sIHRvKSB7XG4gICAgICAgIGRlbGV0ZVJhbmdlKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNwbGl0IHRoZSBjb250ZW50IGluIHRoZSBnaXZlbiByYW5nZSBvZmYgZnJvbSBpdHMgcGFyZW50LCBpZiB0aGVyZVxuICAgIGlzIHNpYmxpbmcgY29udGVudCBiZWZvcmUgb3IgYWZ0ZXIgaXQsIGFuZCBtb3ZlIGl0IHVwIHRoZSB0cmVlIHRvXG4gICAgdGhlIGRlcHRoIHNwZWNpZmllZCBieSBgdGFyZ2V0YC4gWW91J2xsIHByb2JhYmx5IHdhbnQgdG8gdXNlXG4gICAgW2BsaWZ0VGFyZ2V0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5saWZ0VGFyZ2V0KSB0byBjb21wdXRlIGB0YXJnZXRgLCB0byBtYWtlXG4gICAgc3VyZSB0aGUgbGlmdCBpcyB2YWxpZC5cbiAgICAqL1xuICAgIGxpZnQocmFuZ2UsIHRhcmdldCkge1xuICAgICAgICBsaWZ0KHRoaXMsIHJhbmdlLCB0YXJnZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgSm9pbiB0aGUgYmxvY2tzIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uIElmIGRlcHRoIGlzIDIsIHRoZWlyXG4gICAgbGFzdCBhbmQgZmlyc3Qgc2libGluZ3MgYXJlIGFsc28gam9pbmVkLCBhbmQgc28gb24uXG4gICAgKi9cbiAgICBqb2luKHBvcywgZGVwdGggPSAxKSB7XG4gICAgICAgIGpvaW4odGhpcywgcG9zLCBkZXB0aCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBXcmFwIHRoZSBnaXZlbiBbcmFuZ2VdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlUmFuZ2UpIGluIHRoZSBnaXZlbiBzZXQgb2Ygd3JhcHBlcnMuXG4gICAgVGhlIHdyYXBwZXJzIGFyZSBhc3N1bWVkIHRvIGJlIHZhbGlkIGluIHRoaXMgcG9zaXRpb24sIGFuZCBzaG91bGRcbiAgICBwcm9iYWJseSBiZSBjb21wdXRlZCB3aXRoIFtgZmluZFdyYXBwaW5nYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5maW5kV3JhcHBpbmcpLlxuICAgICovXG4gICAgd3JhcChyYW5nZSwgd3JhcHBlcnMpIHtcbiAgICAgICAgd3JhcCh0aGlzLCByYW5nZSwgd3JhcHBlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB0eXBlIG9mIGFsbCB0ZXh0YmxvY2tzIChwYXJ0bHkpIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIHRvXG4gICAgdGhlIGdpdmVuIG5vZGUgdHlwZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgc2V0QmxvY2tUeXBlKGZyb20sIHRvID0gZnJvbSwgdHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgICAgIHNldEJsb2NrVHlwZSh0aGlzLCBmcm9tLCB0bywgdHlwZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hhbmdlIHRoZSB0eXBlLCBhdHRyaWJ1dGVzLCBhbmQvb3IgbWFya3Mgb2YgdGhlIG5vZGUgYXQgYHBvc2AuXG4gICAgV2hlbiBgdHlwZWAgaXNuJ3QgZ2l2ZW4sIHRoZSBleGlzdGluZyBub2RlIHR5cGUgaXMgcHJlc2VydmVkLFxuICAgICovXG4gICAgc2V0Tm9kZU1hcmt1cChwb3MsIHR5cGUsIGF0dHJzID0gbnVsbCwgbWFya3MpIHtcbiAgICAgICAgc2V0Tm9kZU1hcmt1cCh0aGlzLCBwb3MsIHR5cGUsIGF0dHJzLCBtYXJrcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgYSBzaW5nbGUgYXR0cmlidXRlIG9uIGEgZ2l2ZW4gbm9kZSB0byBhIG5ldyB2YWx1ZS5cbiAgICBUaGUgYHBvc2AgYWRkcmVzc2VzIHRoZSBkb2N1bWVudCBjb250ZW50LiBVc2UgYHNldERvY0F0dHJpYnV0ZWBcbiAgICB0byBzZXQgYXR0cmlidXRlcyBvbiB0aGUgZG9jdW1lbnQgaXRzZWxmLlxuICAgICovXG4gICAgc2V0Tm9kZUF0dHJpYnV0ZShwb3MsIGF0dHIsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RlcChuZXcgQXR0clN0ZXAocG9zLCBhdHRyLCB2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IGEgc2luZ2xlIGF0dHJpYnV0ZSBvbiB0aGUgZG9jdW1lbnQgdG8gYSBuZXcgdmFsdWUuXG4gICAgKi9cbiAgICBzZXREb2NBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdGVwKG5ldyBEb2NBdHRyU3RlcChhdHRyLCB2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgbWFyayB0byB0aGUgbm9kZSBhdCBwb3NpdGlvbiBgcG9zYC5cbiAgICAqL1xuICAgIGFkZE5vZGVNYXJrKHBvcywgbWFyaykge1xuICAgICAgICB0aGlzLnN0ZXAobmV3IEFkZE5vZGVNYXJrU3RlcChwb3MsIG1hcmspKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZSBhIG1hcmsgKG9yIGEgbWFyayBvZiB0aGUgZ2l2ZW4gdHlwZSkgZnJvbSB0aGUgbm9kZSBhdFxuICAgIHBvc2l0aW9uIGBwb3NgLlxuICAgICovXG4gICAgcmVtb3ZlTm9kZU1hcmsocG9zLCBtYXJrKSB7XG4gICAgICAgIGlmICghKG1hcmsgaW5zdGFuY2VvZiBNYXJrKSkge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmRvYy5ub2RlQXQocG9zKTtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYXQgcG9zaXRpb24gXCIgKyBwb3MpO1xuICAgICAgICAgICAgbWFyayA9IG1hcmsuaXNJblNldChub2RlLm1hcmtzKTtcbiAgICAgICAgICAgIGlmICghbWFyaylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0ZXAobmV3IFJlbW92ZU5vZGVNYXJrU3RlcChwb3MsIG1hcmspKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNwbGl0IHRoZSBub2RlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgYW5kIG9wdGlvbmFsbHksIGlmIGBkZXB0aGAgaXNcbiAgICBncmVhdGVyIHRoYW4gb25lLCBhbnkgbnVtYmVyIG9mIG5vZGVzIGFib3ZlIHRoYXQuIEJ5IGRlZmF1bHQsIHRoZVxuICAgIHBhcnRzIHNwbGl0IG9mZiB3aWxsIGluaGVyaXQgdGhlIG5vZGUgdHlwZSBvZiB0aGUgb3JpZ2luYWwgbm9kZS5cbiAgICBUaGlzIGNhbiBiZSBjaGFuZ2VkIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgdHlwZXMgYW5kIGF0dHJpYnV0ZXMgdG9cbiAgICB1c2UgYWZ0ZXIgdGhlIHNwbGl0LlxuICAgICovXG4gICAgc3BsaXQocG9zLCBkZXB0aCA9IDEsIHR5cGVzQWZ0ZXIpIHtcbiAgICAgICAgc3BsaXQodGhpcywgcG9zLCBkZXB0aCwgdHlwZXNBZnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgdGhlIGdpdmVuIG1hcmsgdG8gdGhlIGlubGluZSBjb250ZW50IGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLlxuICAgICovXG4gICAgYWRkTWFyayhmcm9tLCB0bywgbWFyaykge1xuICAgICAgICBhZGRNYXJrKHRoaXMsIGZyb20sIHRvLCBtYXJrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZSBtYXJrcyBmcm9tIGlubGluZSBub2RlcyBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC4gV2hlblxuICAgIGBtYXJrYCBpcyBhIHNpbmdsZSBtYXJrLCByZW1vdmUgcHJlY2lzZWx5IHRoYXQgbWFyay4gV2hlbiBpdCBpc1xuICAgIGEgbWFyayB0eXBlLCByZW1vdmUgYWxsIG1hcmtzIG9mIHRoYXQgdHlwZS4gV2hlbiBpdCBpcyBudWxsLFxuICAgIHJlbW92ZSBhbGwgbWFya3Mgb2YgYW55IHR5cGUuXG4gICAgKi9cbiAgICByZW1vdmVNYXJrKGZyb20sIHRvLCBtYXJrKSB7XG4gICAgICAgIHJlbW92ZU1hcmsodGhpcywgZnJvbSwgdG8sIG1hcmspO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlcyBhbGwgbWFya3MgYW5kIG5vZGVzIGZyb20gdGhlIGNvbnRlbnQgb2YgdGhlIG5vZGUgYXRcbiAgICBgcG9zYCB0aGF0IGRvbid0IG1hdGNoIHRoZSBnaXZlbiBuZXcgcGFyZW50IG5vZGUgdHlwZS4gQWNjZXB0c1xuICAgIGFuIG9wdGlvbmFsIHN0YXJ0aW5nIFtjb250ZW50IG1hdGNoXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuQ29udGVudE1hdGNoKSBhc1xuICAgIHRoaXJkIGFyZ3VtZW50LlxuICAgICovXG4gICAgY2xlYXJJbmNvbXBhdGlibGUocG9zLCBwYXJlbnRUeXBlLCBtYXRjaCkge1xuICAgICAgICBjbGVhckluY29tcGF0aWJsZSh0aGlzLCBwb3MsIHBhcmVudFR5cGUsIG1hdGNoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5leHBvcnQgeyBBZGRNYXJrU3RlcCwgQWRkTm9kZU1hcmtTdGVwLCBBdHRyU3RlcCwgRG9jQXR0clN0ZXAsIE1hcFJlc3VsdCwgTWFwcGluZywgUmVtb3ZlTWFya1N0ZXAsIFJlbW92ZU5vZGVNYXJrU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIFJlcGxhY2VTdGVwLCBTdGVwLCBTdGVwTWFwLCBTdGVwUmVzdWx0LCBUcmFuc2Zvcm0sIFRyYW5zZm9ybUVycm9yLCBjYW5Kb2luLCBjYW5TcGxpdCwgZHJvcFBvaW50LCBmaW5kV3JhcHBpbmcsIGluc2VydFBvaW50LCBqb2luUG9pbnQsIGxpZnRUYXJnZXQsIHJlcGxhY2VTdGVwIH07XG4iLCAiaW1wb3J0IHsgU2xpY2UsIEZyYWdtZW50LCBNYXJrLCBOb2RlIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgUmVwbGFjZVN0ZXAsIFJlcGxhY2VBcm91bmRTdGVwLCBUcmFuc2Zvcm0gfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuXG5jb25zdCBjbGFzc2VzQnlJZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcblN1cGVyY2xhc3MgZm9yIGVkaXRvciBzZWxlY3Rpb25zLiBFdmVyeSBzZWxlY3Rpb24gdHlwZSBzaG91bGRcbmV4dGVuZCB0aGlzLiBTaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cbiovXG5jbGFzcyBTZWxlY3Rpb24ge1xuICAgIC8qKlxuICAgIEluaXRpYWxpemUgYSBzZWxlY3Rpb24gd2l0aCB0aGUgaGVhZCBhbmQgYW5jaG9yIGFuZCByYW5nZXMuIElmIG5vXG4gICAgcmFuZ2VzIGFyZSBnaXZlbiwgY29uc3RydWN0cyBhIHNpbmdsZSByYW5nZSBhY3Jvc3MgYCRhbmNob3JgIGFuZFxuICAgIGAkaGVhZGAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcmVzb2x2ZWQgYW5jaG9yIG9mIHRoZSBzZWxlY3Rpb24gKHRoZSBzaWRlIHRoYXQgc3RheXMgaW5cbiAgICBwbGFjZSB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgbW9kaWZpZWQpLlxuICAgICovXG4gICAgJGFuY2hvciwgXG4gICAgLyoqXG4gICAgVGhlIHJlc29sdmVkIGhlYWQgb2YgdGhlIHNlbGVjdGlvbiAodGhlIHNpZGUgdGhhdCBtb3ZlcyB3aGVuXG4gICAgdGhlIHNlbGVjdGlvbiBpcyBtb2RpZmllZCkuXG4gICAgKi9cbiAgICAkaGVhZCwgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMuJGFuY2hvciA9ICRhbmNob3I7XG4gICAgICAgIHRoaXMuJGhlYWQgPSAkaGVhZDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXMgfHwgW25ldyBTZWxlY3Rpb25SYW5nZSgkYW5jaG9yLm1pbigkaGVhZCksICRhbmNob3IubWF4KCRoZWFkKSldO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2VsZWN0aW9uJ3MgYW5jaG9yLCBhcyBhbiB1bnJlc29sdmVkIHBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IGFuY2hvcigpIHsgcmV0dXJuIHRoaXMuJGFuY2hvci5wb3M7IH1cbiAgICAvKipcbiAgICBUaGUgc2VsZWN0aW9uJ3MgaGVhZC5cbiAgICAqL1xuICAgIGdldCBoZWFkKCkgeyByZXR1cm4gdGhpcy4kaGVhZC5wb3M7IH1cbiAgICAvKipcbiAgICBUaGUgbG93ZXIgYm91bmQgb2YgdGhlIHNlbGVjdGlvbidzIG1haW4gcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuJGZyb20ucG9zOyB9XG4gICAgLyoqXG4gICAgVGhlIHVwcGVyIGJvdW5kIG9mIHRoZSBzZWxlY3Rpb24ncyBtYWluIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy4kdG8ucG9zOyB9XG4gICAgLyoqXG4gICAgVGhlIHJlc29sdmVkIGxvd2VyICBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbiAgICAqL1xuICAgIGdldCAkZnJvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzWzBdLiRmcm9tO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgcmVzb2x2ZWQgdXBwZXIgYm91bmQgb2YgdGhlIHNlbGVjdGlvbidzIG1haW4gcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgJHRvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXNbMF0uJHRvO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc2VsZWN0aW9uIGNvbnRhaW5zIGFueSBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkge1xuICAgICAgICBsZXQgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHJhbmdlc1tpXS4kZnJvbS5wb3MgIT0gcmFuZ2VzW2ldLiR0by5wb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjb250ZW50IG9mIHRoaXMgc2VsZWN0aW9uIGFzIGEgc2xpY2UuXG4gICAgKi9cbiAgICBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZnJvbS5kb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggYSBzbGljZSBvciwgaWYgbm8gc2xpY2UgaXMgZ2l2ZW4sXG4gICAgZGVsZXRlIHRoZSBzZWxlY3Rpb24uIFdpbGwgYXBwZW5kIHRvIHRoZSBnaXZlbiB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHJlcGxhY2UodHIsIGNvbnRlbnQgPSBTbGljZS5lbXB0eSkge1xuICAgICAgICAvLyBQdXQgdGhlIG5ldyBzZWxlY3Rpb24gYXQgdGhlIHBvc2l0aW9uIGFmdGVyIHRoZSBpbnNlcnRlZFxuICAgICAgICAvLyBjb250ZW50LiBXaGVuIHRoYXQgZW5kZWQgaW4gYW4gaW5saW5lIG5vZGUsIHNlYXJjaCBiYWNrd2FyZHMsXG4gICAgICAgIC8vIHRvIGdldCB0aGUgcG9zaXRpb24gYWZ0ZXIgdGhhdCBub2RlLiBJZiBub3QsIHNlYXJjaCBmb3J3YXJkLlxuICAgICAgICBsZXQgbGFzdE5vZGUgPSBjb250ZW50LmNvbnRlbnQubGFzdENoaWxkLCBsYXN0UGFyZW50ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50Lm9wZW5FbmQ7IGkrKykge1xuICAgICAgICAgICAgbGFzdFBhcmVudCA9IGxhc3ROb2RlO1xuICAgICAgICAgICAgbGFzdE5vZGUgPSBsYXN0Tm9kZS5sYXN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hcEZyb20gPSB0ci5zdGVwcy5sZW5ndGgsIHJhbmdlcyA9IHRoaXMucmFuZ2VzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldLCBtYXBwaW5nID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKTtcbiAgICAgICAgICAgIHRyLnJlcGxhY2VSYW5nZShtYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCBtYXBwaW5nLm1hcCgkdG8ucG9zKSwgaSA/IFNsaWNlLmVtcHR5IDogY29udGVudCk7XG4gICAgICAgICAgICBpZiAoaSA9PSAwKVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBtYXBGcm9tLCAobGFzdE5vZGUgPyBsYXN0Tm9kZS5pc0lubGluZSA6IGxhc3RQYXJlbnQgJiYgbGFzdFBhcmVudC5pc1RleHRibG9jaykgPyAtMSA6IDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIHRoZSBnaXZlbiBub2RlLCBhcHBlbmRpbmcgdGhlIGNoYW5nZXNcbiAgICB0byB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICByZXBsYWNlV2l0aCh0ciwgbm9kZSkge1xuICAgICAgICBsZXQgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aCwgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV0sIG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCB0byA9IG1hcHBpbmcubWFwKCR0by5wb3MpO1xuICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICB0ci5kZWxldGVSYW5nZShmcm9tLCB0byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ci5yZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBub2RlKTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0ciwgbWFwRnJvbSwgbm9kZS5pc0lubGluZSA/IC0xIDogMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBhIHZhbGlkIGN1cnNvciBvciBsZWFmIG5vZGUgc2VsZWN0aW9uIHN0YXJ0aW5nIGF0IHRoZSBnaXZlblxuICAgIHBvc2l0aW9uIGFuZCBzZWFyY2hpbmcgYmFjayBpZiBgZGlyYCBpcyBuZWdhdGl2ZSwgYW5kIGZvcndhcmQgaWZcbiAgICBwb3NpdGl2ZS4gV2hlbiBgdGV4dE9ubHlgIGlzIHRydWUsIG9ubHkgY29uc2lkZXIgY3Vyc29yXG4gICAgc2VsZWN0aW9ucy4gV2lsbCByZXR1cm4gbnVsbCB3aGVuIG5vIHZhbGlkIHNlbGVjdGlvbiBwb3NpdGlvbiBpc1xuICAgIGZvdW5kLlxuICAgICovXG4gICAgc3RhdGljIGZpbmRGcm9tKCRwb3MsIGRpciwgdGV4dE9ubHkgPSBmYWxzZSkge1xuICAgICAgICBsZXQgaW5uZXIgPSAkcG9zLnBhcmVudC5pbmxpbmVDb250ZW50ID8gbmV3IFRleHRTZWxlY3Rpb24oJHBvcylcbiAgICAgICAgICAgIDogZmluZFNlbGVjdGlvbkluKCRwb3Mubm9kZSgwKSwgJHBvcy5wYXJlbnQsICRwb3MucG9zLCAkcG9zLmluZGV4KCksIGRpciwgdGV4dE9ubHkpO1xuICAgICAgICBpZiAoaW5uZXIpXG4gICAgICAgICAgICByZXR1cm4gaW5uZXI7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gJHBvcy5kZXB0aCAtIDE7IGRlcHRoID49IDA7IGRlcHRoLS0pIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGRpciA8IDBcbiAgICAgICAgICAgICAgICA/IGZpbmRTZWxlY3Rpb25JbigkcG9zLm5vZGUoMCksICRwb3Mubm9kZShkZXB0aCksICRwb3MuYmVmb3JlKGRlcHRoICsgMSksICRwb3MuaW5kZXgoZGVwdGgpLCBkaXIsIHRleHRPbmx5KVxuICAgICAgICAgICAgICAgIDogZmluZFNlbGVjdGlvbkluKCRwb3Mubm9kZSgwKSwgJHBvcy5ub2RlKGRlcHRoKSwgJHBvcy5hZnRlcihkZXB0aCArIDEpLCAkcG9zLmluZGV4KGRlcHRoKSArIDEsIGRpciwgdGV4dE9ubHkpO1xuICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBhIHZhbGlkIGN1cnNvciBvciBsZWFmIG5vZGUgc2VsZWN0aW9uIG5lYXIgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24uIFNlYXJjaGVzIGZvcndhcmQgZmlyc3QgYnkgZGVmYXVsdCwgYnV0IGlmIGBiaWFzYCBpc1xuICAgIG5lZ2F0aXZlLCBpdCB3aWxsIHNlYXJjaCBiYWNrd2FyZHMgZmlyc3QuXG4gICAgKi9cbiAgICBzdGF0aWMgbmVhcigkcG9zLCBiaWFzID0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kRnJvbSgkcG9zLCBiaWFzKSB8fCB0aGlzLmZpbmRGcm9tKCRwb3MsIC1iaWFzKSB8fCBuZXcgQWxsU2VsZWN0aW9uKCRwb3Mubm9kZSgwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGN1cnNvciBvciBsZWFmIG5vZGUgc2VsZWN0aW9uIGNsb3Nlc3QgdG8gdGhlIHN0YXJ0IG9mXG4gICAgdGhlIGdpdmVuIGRvY3VtZW50LiBXaWxsIHJldHVybiBhblxuICAgIFtgQWxsU2VsZWN0aW9uYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkFsbFNlbGVjdGlvbikgaWYgbm8gdmFsaWQgcG9zaXRpb25cbiAgICBleGlzdHMuXG4gICAgKi9cbiAgICBzdGF0aWMgYXRTdGFydChkb2MpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRTZWxlY3Rpb25Jbihkb2MsIGRvYywgMCwgMCwgMSkgfHwgbmV3IEFsbFNlbGVjdGlvbihkb2MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBjdXJzb3Igb3IgbGVhZiBub2RlIHNlbGVjdGlvbiBjbG9zZXN0IHRvIHRoZSBlbmQgb2YgdGhlXG4gICAgZ2l2ZW4gZG9jdW1lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgYXRFbmQoZG9jKSB7XG4gICAgICAgIHJldHVybiBmaW5kU2VsZWN0aW9uSW4oZG9jLCBkb2MsIGRvYy5jb250ZW50LnNpemUsIGRvYy5jaGlsZENvdW50LCAtMSkgfHwgbmV3IEFsbFNlbGVjdGlvbihkb2MpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHNlbGVjdGlvbi4gTXVzdCBiZVxuICAgIGltcGxlbWVudGVkIGZvciBjdXN0b20gY2xhc3NlcyAoYXMgYSBzdGF0aWMgY2xhc3MgbWV0aG9kKS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uIHx8ICFqc29uLnR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFNlbGVjdGlvbi5mcm9tSlNPTlwiKTtcbiAgICAgICAgbGV0IGNscyA9IGNsYXNzZXNCeUlkW2pzb24udHlwZV07XG4gICAgICAgIGlmICghY2xzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE5vIHNlbGVjdGlvbiB0eXBlICR7anNvbi50eXBlfSBkZWZpbmVkYCk7XG4gICAgICAgIHJldHVybiBjbHMuZnJvbUpTT04oZG9jLCBqc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVG8gYmUgYWJsZSB0byBkZXNlcmlhbGl6ZSBzZWxlY3Rpb25zIGZyb20gSlNPTiwgY3VzdG9tIHNlbGVjdGlvblxuICAgIGNsYXNzZXMgbXVzdCByZWdpc3RlciB0aGVtc2VsdmVzIHdpdGggYW4gSUQgc3RyaW5nLCBzbyB0aGF0IHRoZXlcbiAgICBjYW4gYmUgZGlzYW1iaWd1YXRlZC4gVHJ5IHRvIHBpY2sgc29tZXRoaW5nIHRoYXQncyB1bmxpa2VseSB0b1xuICAgIGNsYXNoIHdpdGggY2xhc3NlcyBmcm9tIG90aGVyIG1vZHVsZXMuXG4gICAgKi9cbiAgICBzdGF0aWMganNvbklEKGlkLCBzZWxlY3Rpb25DbGFzcykge1xuICAgICAgICBpZiAoaWQgaW4gY2xhc3Nlc0J5SWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkR1cGxpY2F0ZSB1c2Ugb2Ygc2VsZWN0aW9uIEpTT04gSUQgXCIgKyBpZCk7XG4gICAgICAgIGNsYXNzZXNCeUlkW2lkXSA9IHNlbGVjdGlvbkNsYXNzO1xuICAgICAgICBzZWxlY3Rpb25DbGFzcy5wcm90b3R5cGUuanNvbklEID0gaWQ7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25DbGFzcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW2Jvb2ttYXJrXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uQm9va21hcmspIGZvciB0aGlzIHNlbGVjdGlvbixcbiAgICB3aGljaCBpcyBhIHZhbHVlIHRoYXQgY2FuIGJlIG1hcHBlZCB3aXRob3V0IGhhdmluZyBhY2Nlc3MgdG8gYVxuICAgIGN1cnJlbnQgZG9jdW1lbnQsIGFuZCBsYXRlciByZXNvbHZlZCB0byBhIHJlYWwgc2VsZWN0aW9uIGZvciBhXG4gICAgZ2l2ZW4gZG9jdW1lbnQgYWdhaW4uIChUaGlzIGlzIHVzZWQgbW9zdGx5IGJ5IHRoZSBoaXN0b3J5IHRvXG4gICAgdHJhY2sgYW5kIHJlc3RvcmUgb2xkIHNlbGVjdGlvbnMuKSBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZlxuICAgIHRoaXMgbWV0aG9kIGp1c3QgY29udmVydHMgdGhlIHNlbGVjdGlvbiB0byBhIHRleHQgc2VsZWN0aW9uIGFuZFxuICAgIHJldHVybnMgdGhlIGJvb2ttYXJrIGZvciB0aGF0LlxuICAgICovXG4gICAgZ2V0Qm9va21hcmsoKSB7XG4gICAgICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmJldHdlZW4odGhpcy4kYW5jaG9yLCB0aGlzLiRoZWFkKS5nZXRCb29rbWFyaygpO1xuICAgIH1cbn1cblNlbGVjdGlvbi5wcm90b3R5cGUudmlzaWJsZSA9IHRydWU7XG4vKipcblJlcHJlc2VudHMgYSBzZWxlY3RlZCByYW5nZSBpbiBhIGRvY3VtZW50LlxuKi9cbmNsYXNzIFNlbGVjdGlvblJhbmdlIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSByYW5nZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBsb3dlciBib3VuZCBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICAkZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIHVwcGVyIGJvdW5kIG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgICR0bykge1xuICAgICAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgICAgIHRoaXMuJHRvID0gJHRvO1xuICAgIH1cbn1cbmxldCB3YXJuZWRBYm91dFRleHRTZWxlY3Rpb24gPSBmYWxzZTtcbmZ1bmN0aW9uIGNoZWNrVGV4dFNlbGVjdGlvbigkcG9zKSB7XG4gICAgaWYgKCF3YXJuZWRBYm91dFRleHRTZWxlY3Rpb24gJiYgISRwb3MucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgd2FybmVkQWJvdXRUZXh0U2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZVtcIndhcm5cIl0oXCJUZXh0U2VsZWN0aW9uIGVuZHBvaW50IG5vdCBwb2ludGluZyBpbnRvIGEgbm9kZSB3aXRoIGlubGluZSBjb250ZW50IChcIiArICRwb3MucGFyZW50LnR5cGUubmFtZSArIFwiKVwiKTtcbiAgICB9XG59XG4vKipcbkEgdGV4dCBzZWxlY3Rpb24gcmVwcmVzZW50cyBhIGNsYXNzaWNhbCBlZGl0b3Igc2VsZWN0aW9uLCB3aXRoIGFcbmhlYWQgKHRoZSBtb3Zpbmcgc2lkZSkgYW5kIGFuY2hvciAoaW1tb2JpbGUgc2lkZSksIGJvdGggb2Ygd2hpY2hcbnBvaW50IGludG8gdGV4dGJsb2NrIG5vZGVzLiBJdCBjYW4gYmUgZW1wdHkgKGEgcmVndWxhciBjdXJzb3JcbnBvc2l0aW9uKS5cbiovXG5jbGFzcyBUZXh0U2VsZWN0aW9uIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSB0ZXh0IHNlbGVjdGlvbiBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludHMuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigkYW5jaG9yLCAkaGVhZCA9ICRhbmNob3IpIHtcbiAgICAgICAgY2hlY2tUZXh0U2VsZWN0aW9uKCRhbmNob3IpO1xuICAgICAgICBjaGVja1RleHRTZWxlY3Rpb24oJGhlYWQpO1xuICAgICAgICBzdXBlcigkYW5jaG9yLCAkaGVhZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYSByZXNvbHZlZCBwb3NpdGlvbiBpZiB0aGlzIGlzIGEgY3Vyc29yIHNlbGVjdGlvbiAoYW5cbiAgICBlbXB0eSB0ZXh0IHNlbGVjdGlvbiksIGFuZCBudWxsIG90aGVyd2lzZS5cbiAgICAqL1xuICAgIGdldCAkY3Vyc29yKCkgeyByZXR1cm4gdGhpcy4kYW5jaG9yLnBvcyA9PSB0aGlzLiRoZWFkLnBvcyA/IHRoaXMuJGhlYWQgOiBudWxsOyB9XG4gICAgbWFwKGRvYywgbWFwcGluZykge1xuICAgICAgICBsZXQgJGhlYWQgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLmhlYWQpKTtcbiAgICAgICAgaWYgKCEkaGVhZC5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkaGVhZCk7XG4gICAgICAgIGxldCAkYW5jaG9yID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAodGhpcy5hbmNob3IpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0U2VsZWN0aW9uKCRhbmNob3IucGFyZW50LmlubGluZUNvbnRlbnQgPyAkYW5jaG9yIDogJGhlYWQsICRoZWFkKTtcbiAgICB9XG4gICAgcmVwbGFjZSh0ciwgY29udGVudCA9IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgIHN1cGVyLnJlcGxhY2UodHIsIGNvbnRlbnQpO1xuICAgICAgICBpZiAoY29udGVudCA9PSBTbGljZS5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IG1hcmtzID0gdGhpcy4kZnJvbS5tYXJrc0Fjcm9zcyh0aGlzLiR0byk7XG4gICAgICAgICAgICBpZiAobWFya3MpXG4gICAgICAgICAgICAgICAgdHIuZW5zdXJlTWFya3MobWFya3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgb3RoZXIuYW5jaG9yID09IHRoaXMuYW5jaG9yICYmIG90aGVyLmhlYWQgPT0gdGhpcy5oZWFkO1xuICAgIH1cbiAgICBnZXRCb29rbWFyaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Qm9va21hcmsodGhpcy5hbmNob3IsIHRoaXMuaGVhZCk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0ZXh0XCIsIGFuY2hvcjogdGhpcy5hbmNob3IsIGhlYWQ6IHRoaXMuaGVhZCB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmFuY2hvciAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmhlYWQgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgVGV4dFNlbGVjdGlvbi5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0U2VsZWN0aW9uKGRvYy5yZXNvbHZlKGpzb24uYW5jaG9yKSwgZG9jLnJlc29sdmUoanNvbi5oZWFkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRleHQgc2VsZWN0aW9uIGZyb20gbm9uLXJlc29sdmVkIHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZG9jLCBhbmNob3IsIGhlYWQgPSBhbmNob3IpIHtcbiAgICAgICAgbGV0ICRhbmNob3IgPSBkb2MucmVzb2x2ZShhbmNob3IpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoJGFuY2hvciwgaGVhZCA9PSBhbmNob3IgPyAkYW5jaG9yIDogZG9jLnJlc29sdmUoaGVhZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSB0ZXh0IHNlbGVjdGlvbiB0aGF0IHNwYW5zIHRoZSBnaXZlbiBwb3NpdGlvbnMgb3IsIGlmXG4gICAgdGhleSBhcmVuJ3QgdGV4dCBwb3NpdGlvbnMsIGZpbmQgYSB0ZXh0IHNlbGVjdGlvbiBuZWFyIHRoZW0uXG4gICAgYGJpYXNgIGRldGVybWluZXMgd2hldGhlciB0aGUgbWV0aG9kIHNlYXJjaGVzIGZvcndhcmQgKGRlZmF1bHQpXG4gICAgb3IgYmFja3dhcmRzIChuZWdhdGl2ZSBudW1iZXIpIGZpcnN0LiBXaWxsIGZhbGwgYmFjayB0byBjYWxsaW5nXG4gICAgW2BTZWxlY3Rpb24ubmVhcmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25ebmVhcikgd2hlbiB0aGUgZG9jdW1lbnRcbiAgICBkb2Vzbid0IGNvbnRhaW4gYSB2YWxpZCB0ZXh0IHBvc2l0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGJldHdlZW4oJGFuY2hvciwgJGhlYWQsIGJpYXMpIHtcbiAgICAgICAgbGV0IGRQb3MgPSAkYW5jaG9yLnBvcyAtICRoZWFkLnBvcztcbiAgICAgICAgaWYgKCFiaWFzIHx8IGRQb3MpXG4gICAgICAgICAgICBiaWFzID0gZFBvcyA+PSAwID8gMSA6IC0xO1xuICAgICAgICBpZiAoISRoZWFkLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBTZWxlY3Rpb24uZmluZEZyb20oJGhlYWQsIGJpYXMsIHRydWUpIHx8IFNlbGVjdGlvbi5maW5kRnJvbSgkaGVhZCwgLWJpYXMsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICRoZWFkID0gZm91bmQuJGhlYWQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRoZWFkLCBiaWFzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISRhbmNob3IucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmIChkUG9zID09IDApIHtcbiAgICAgICAgICAgICAgICAkYW5jaG9yID0gJGhlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAkYW5jaG9yID0gKFNlbGVjdGlvbi5maW5kRnJvbSgkYW5jaG9yLCAtYmlhcywgdHJ1ZSkgfHwgU2VsZWN0aW9uLmZpbmRGcm9tKCRhbmNob3IsIGJpYXMsIHRydWUpKS4kYW5jaG9yO1xuICAgICAgICAgICAgICAgIGlmICgoJGFuY2hvci5wb3MgPCAkaGVhZC5wb3MpICE9IChkUG9zIDwgMCkpXG4gICAgICAgICAgICAgICAgICAgICRhbmNob3IgPSAkaGVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb24oJGFuY2hvciwgJGhlYWQpO1xuICAgIH1cbn1cblNlbGVjdGlvbi5qc29uSUQoXCJ0ZXh0XCIsIFRleHRTZWxlY3Rpb24pO1xuY2xhc3MgVGV4dEJvb2ttYXJrIHtcbiAgICBjb25zdHJ1Y3RvcihhbmNob3IsIGhlYWQpIHtcbiAgICAgICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgICAgIHRoaXMuaGVhZCA9IGhlYWQ7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEJvb2ttYXJrKG1hcHBpbmcubWFwKHRoaXMuYW5jaG9yKSwgbWFwcGluZy5tYXAodGhpcy5oZWFkKSk7XG4gICAgfVxuICAgIHJlc29sdmUoZG9jKSB7XG4gICAgICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmJldHdlZW4oZG9jLnJlc29sdmUodGhpcy5hbmNob3IpLCBkb2MucmVzb2x2ZSh0aGlzLmhlYWQpKTtcbiAgICB9XG59XG4vKipcbkEgbm9kZSBzZWxlY3Rpb24gaXMgYSBzZWxlY3Rpb24gdGhhdCBwb2ludHMgYXQgYSBzaW5nbGUgbm9kZS4gQWxsXG5ub2RlcyBtYXJrZWQgW3NlbGVjdGFibGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5zZWxlY3RhYmxlKSBjYW4gYmUgdGhlXG50YXJnZXQgb2YgYSBub2RlIHNlbGVjdGlvbi4gSW4gc3VjaCBhIHNlbGVjdGlvbiwgYGZyb21gIGFuZCBgdG9gXG5wb2ludCBkaXJlY3RseSBiZWZvcmUgYW5kIGFmdGVyIHRoZSBzZWxlY3RlZCBub2RlLCBgYW5jaG9yYCBlcXVhbHNcbmBmcm9tYCwgYW5kIGBoZWFkYCBlcXVhbHMgYHRvYC4uXG4qL1xuY2xhc3MgTm9kZVNlbGVjdGlvbiBleHRlbmRzIFNlbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBzZWxlY3Rpb24uIERvZXMgbm90IHZlcmlmeSB0aGUgdmFsaWRpdHkgb2YgaXRzXG4gICAgYXJndW1lbnQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigkcG9zKSB7XG4gICAgICAgIGxldCBub2RlID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgICAgIGxldCAkZW5kID0gJHBvcy5ub2RlKDApLnJlc29sdmUoJHBvcy5wb3MgKyBub2RlLm5vZGVTaXplKTtcbiAgICAgICAgc3VwZXIoJHBvcywgJGVuZCk7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgfVxuICAgIG1hcChkb2MsIG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHsgZGVsZXRlZCwgcG9zIH0gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmFuY2hvcik7XG4gICAgICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgICAgICAgaWYgKGRlbGV0ZWQpXG4gICAgICAgICAgICByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJHBvcyk7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNlbGVjdGlvbigkcG9zKTtcbiAgICB9XG4gICAgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHRoaXMubm9kZSksIDAsIDApO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIG90aGVyLmFuY2hvciA9PSB0aGlzLmFuY2hvcjtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm5vZGVcIiwgYW5jaG9yOiB0aGlzLmFuY2hvciB9O1xuICAgIH1cbiAgICBnZXRCb29rbWFyaygpIHsgcmV0dXJuIG5ldyBOb2RlQm9va21hcmsodGhpcy5hbmNob3IpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5hbmNob3IgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgTm9kZVNlbGVjdGlvbi5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKGRvYy5yZXNvbHZlKGpzb24uYW5jaG9yKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5vZGUgc2VsZWN0aW9uIGZyb20gbm9uLXJlc29sdmVkIHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZG9jLCBmcm9tKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNlbGVjdGlvbihkb2MucmVzb2x2ZShmcm9tKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gbm9kZSBtYXkgYmUgc2VsZWN0ZWQgYXMgYSBub2RlXG4gICAgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGlzU2VsZWN0YWJsZShub2RlKSB7XG4gICAgICAgIHJldHVybiAhbm9kZS5pc1RleHQgJiYgbm9kZS50eXBlLnNwZWMuc2VsZWN0YWJsZSAhPT0gZmFsc2U7XG4gICAgfVxufVxuTm9kZVNlbGVjdGlvbi5wcm90b3R5cGUudmlzaWJsZSA9IGZhbHNlO1xuU2VsZWN0aW9uLmpzb25JRChcIm5vZGVcIiwgTm9kZVNlbGVjdGlvbik7XG5jbGFzcyBOb2RlQm9va21hcmsge1xuICAgIGNvbnN0cnVjdG9yKGFuY2hvcikge1xuICAgICAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHsgZGVsZXRlZCwgcG9zIH0gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmFuY2hvcik7XG4gICAgICAgIHJldHVybiBkZWxldGVkID8gbmV3IFRleHRCb29rbWFyayhwb3MsIHBvcykgOiBuZXcgTm9kZUJvb2ttYXJrKHBvcyk7XG4gICAgfVxuICAgIHJlc29sdmUoZG9jKSB7XG4gICAgICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUodGhpcy5hbmNob3IpLCBub2RlID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgICAgIGlmIChub2RlICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpO1xuICAgICAgICByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJHBvcyk7XG4gICAgfVxufVxuLyoqXG5BIHNlbGVjdGlvbiB0eXBlIHRoYXQgcmVwcmVzZW50cyBzZWxlY3RpbmcgdGhlIHdob2xlIGRvY3VtZW50XG4od2hpY2ggY2FuIG5vdCBuZWNlc3NhcmlseSBiZSBleHByZXNzZWQgd2l0aCBhIHRleHQgc2VsZWN0aW9uLCB3aGVuXG50aGVyZSBhcmUgZm9yIGV4YW1wbGUgbGVhZiBibG9jayBub2RlcyBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZVxuZG9jdW1lbnQpLlxuKi9cbmNsYXNzIEFsbFNlbGVjdGlvbiBleHRlbmRzIFNlbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGFsbC1zZWxlY3Rpb24gb3ZlciB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihkb2MpIHtcbiAgICAgICAgc3VwZXIoZG9jLnJlc29sdmUoMCksIGRvYy5yZXNvbHZlKGRvYy5jb250ZW50LnNpemUpKTtcbiAgICB9XG4gICAgcmVwbGFjZSh0ciwgY29udGVudCA9IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgIGlmIChjb250ZW50ID09IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgICAgICB0ci5kZWxldGUoMCwgdHIuZG9jLmNvbnRlbnQuc2l6ZSk7XG4gICAgICAgICAgICBsZXQgc2VsID0gU2VsZWN0aW9uLmF0U3RhcnQodHIuZG9jKTtcbiAgICAgICAgICAgIGlmICghc2VsLmVxKHRyLnNlbGVjdGlvbikpXG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHNlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5yZXBsYWNlKHRyLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7IHJldHVybiB7IHR5cGU6IFwiYWxsXCIgfTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYykgeyByZXR1cm4gbmV3IEFsbFNlbGVjdGlvbihkb2MpOyB9XG4gICAgbWFwKGRvYykgeyByZXR1cm4gbmV3IEFsbFNlbGVjdGlvbihkb2MpOyB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uOyB9XG4gICAgZ2V0Qm9va21hcmsoKSB7IHJldHVybiBBbGxCb29rbWFyazsgfVxufVxuU2VsZWN0aW9uLmpzb25JRChcImFsbFwiLCBBbGxTZWxlY3Rpb24pO1xuY29uc3QgQWxsQm9va21hcmsgPSB7XG4gICAgbWFwKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICByZXNvbHZlKGRvYykgeyByZXR1cm4gbmV3IEFsbFNlbGVjdGlvbihkb2MpOyB9XG59O1xuLy8gRklYTUUgd2UnbGwgbmVlZCBzb21lIGF3YXJlbmVzcyBvZiB0ZXh0IGRpcmVjdGlvbiB3aGVuIHNjYW5uaW5nIGZvciBzZWxlY3Rpb25zXG4vLyBUcnkgdG8gZmluZCBhIHNlbGVjdGlvbiBpbnNpZGUgdGhlIGdpdmVuIG5vZGUuIGBwb3NgIHBvaW50cyBhdCB0aGVcbi8vIHBvc2l0aW9uIHdoZXJlIHRoZSBzZWFyY2ggc3RhcnRzLiBXaGVuIGB0ZXh0YCBpcyB0cnVlLCBvbmx5IHJldHVyblxuLy8gdGV4dCBzZWxlY3Rpb25zLlxuZnVuY3Rpb24gZmluZFNlbGVjdGlvbkluKGRvYywgbm9kZSwgcG9zLCBpbmRleCwgZGlyLCB0ZXh0ID0gZmFsc2UpIHtcbiAgICBpZiAobm9kZS5pbmxpbmVDb250ZW50KVxuICAgICAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBwb3MpO1xuICAgIGZvciAobGV0IGkgPSBpbmRleCAtIChkaXIgPiAwID8gMCA6IDEpOyBkaXIgPiAwID8gaSA8IG5vZGUuY2hpbGRDb3VudCA6IGkgPj0gMDsgaSArPSBkaXIpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gbm9kZS5jaGlsZChpKTtcbiAgICAgICAgaWYgKCFjaGlsZC5pc0F0b20pIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGZpbmRTZWxlY3Rpb25Jbihkb2MsIGNoaWxkLCBwb3MgKyBkaXIsIGRpciA8IDAgPyBjaGlsZC5jaGlsZENvdW50IDogMCwgZGlyLCB0ZXh0KTtcbiAgICAgICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRleHQgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoY2hpbGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gTm9kZVNlbGVjdGlvbi5jcmVhdGUoZG9jLCBwb3MgLSAoZGlyIDwgMCA/IGNoaWxkLm5vZGVTaXplIDogMCkpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBjaGlsZC5ub2RlU2l6ZSAqIGRpcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0ciwgc3RhcnRMZW4sIGJpYXMpIHtcbiAgICBsZXQgbGFzdCA9IHRyLnN0ZXBzLmxlbmd0aCAtIDE7XG4gICAgaWYgKGxhc3QgPCBzdGFydExlbilcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBzdGVwID0gdHIuc3RlcHNbbGFzdF07XG4gICAgaWYgKCEoc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VTdGVwIHx8IHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlQXJvdW5kU3RlcCkpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbWFwID0gdHIubWFwcGluZy5tYXBzW2xhc3RdLCBlbmQ7XG4gICAgbWFwLmZvckVhY2goKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgPT4geyBpZiAoZW5kID09IG51bGwpXG4gICAgICAgIGVuZCA9IG5ld1RvOyB9KTtcbiAgICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoZW5kKSwgYmlhcykpO1xufVxuXG5jb25zdCBVUERBVEVEX1NFTCA9IDEsIFVQREFURURfTUFSS1MgPSAyLCBVUERBVEVEX1NDUk9MTCA9IDQ7XG4vKipcbkFuIGVkaXRvciBzdGF0ZSB0cmFuc2FjdGlvbiwgd2hpY2ggY2FuIGJlIGFwcGxpZWQgdG8gYSBzdGF0ZSB0b1xuY3JlYXRlIGFuIHVwZGF0ZWQgc3RhdGUuIFVzZVxuW2BFZGl0b3JTdGF0ZS50cmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50cikgdG8gY3JlYXRlIGFuIGluc3RhbmNlLlxuXG5UcmFuc2FjdGlvbnMgdHJhY2sgY2hhbmdlcyB0byB0aGUgZG9jdW1lbnQgKHRoZXkgYXJlIGEgc3ViY2xhc3Mgb2ZcbltgVHJhbnNmb3JtYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5UcmFuc2Zvcm0pKSwgYnV0IGFsc28gb3RoZXIgc3RhdGUgY2hhbmdlcyxcbmxpa2Ugc2VsZWN0aW9uIHVwZGF0ZXMgYW5kIGFkanVzdG1lbnRzIG9mIHRoZSBzZXQgb2YgW3N0b3JlZFxubWFya3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5zdG9yZWRNYXJrcykuIEluIGFkZGl0aW9uLCB5b3UgY2FuIHN0b3JlXG5tZXRhZGF0YSBwcm9wZXJ0aWVzIGluIGEgdHJhbnNhY3Rpb24sIHdoaWNoIGFyZSBleHRyYSBwaWVjZXMgb2ZcbmluZm9ybWF0aW9uIHRoYXQgY2xpZW50IGNvZGUgb3IgcGx1Z2lucyBjYW4gdXNlIHRvIGRlc2NyaWJlIHdoYXQgYVxudHJhbnNhY3Rpb24gcmVwcmVzZW50cywgc28gdGhhdCB0aGV5IGNhbiB1cGRhdGUgdGhlaXIgW293blxuc3RhdGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUZpZWxkKSBhY2NvcmRpbmdseS5cblxuVGhlIFtlZGl0b3Igdmlld10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldykgdXNlcyBhIGZldyBtZXRhZGF0YVxucHJvcGVydGllczogaXQgd2lsbCBhdHRhY2ggYSBwcm9wZXJ0eSBgXCJwb2ludGVyXCJgIHdpdGggdGhlIHZhbHVlXG5gdHJ1ZWAgdG8gc2VsZWN0aW9uIHRyYW5zYWN0aW9ucyBkaXJlY3RseSBjYXVzZWQgYnkgbW91c2Ugb3IgdG91Y2hcbmlucHV0LCBhIGBcImNvbXBvc2l0aW9uXCJgIHByb3BlcnR5IGhvbGRpbmcgYW4gSUQgaWRlbnRpZnlpbmcgdGhlXG5jb21wb3NpdGlvbiB0aGF0IGNhdXNlZCBpdCB0byB0cmFuc2FjdGlvbnMgY2F1c2VkIGJ5IGNvbXBvc2VkIERPTVxuaW5wdXQsIGFuZCBhIGBcInVpRXZlbnRcImAgcHJvcGVydHkgb2YgdGhhdCBtYXkgYmUgYFwicGFzdGVcImAsXG5gXCJjdXRcImAsIG9yIGBcImRyb3BcImAuXG4qL1xuY2xhc3MgVHJhbnNhY3Rpb24gZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoc3RhdGUuZG9jKTtcbiAgICAgICAgLy8gVGhlIHN0ZXAgY291bnQgZm9yIHdoaWNoIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyB2YWxpZC5cbiAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb25Gb3IgPSAwO1xuICAgICAgICAvLyBCaXRmaWVsZCB0byB0cmFjayB3aGljaCBhc3BlY3RzIG9mIHRoZSBzdGF0ZSB3ZXJlIHVwZGF0ZWQgYnlcbiAgICAgICAgLy8gdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgICAgdGhpcy51cGRhdGVkID0gMDtcbiAgICAgICAgLy8gT2JqZWN0IHVzZWQgdG8gc3RvcmUgbWV0YWRhdGEgcHJvcGVydGllcyBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICB0aGlzLm1ldGEgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLmN1clNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5zdG9yZWRNYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgdHJhbnNhY3Rpb24ncyBjdXJyZW50IHNlbGVjdGlvbi4gVGhpcyBkZWZhdWx0cyB0byB0aGUgZWRpdG9yXG4gICAgc2VsZWN0aW9uIFttYXBwZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb24ubWFwKSB0aHJvdWdoIHRoZSBzdGVwcyBpbiB0aGVcbiAgICB0cmFuc2FjdGlvbiwgYnV0IGNhbiBiZSBvdmVyd3JpdHRlbiB3aXRoXG4gICAgW2BzZXRTZWxlY3Rpb25gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc2V0U2VsZWN0aW9uKS5cbiAgICAqL1xuICAgIGdldCBzZWxlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmN1clNlbGVjdGlvbkZvciA8IHRoaXMuc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmN1clNlbGVjdGlvbiA9IHRoaXMuY3VyU2VsZWN0aW9uLm1hcCh0aGlzLmRvYywgdGhpcy5tYXBwaW5nLnNsaWNlKHRoaXMuY3VyU2VsZWN0aW9uRm9yKSk7XG4gICAgICAgICAgICB0aGlzLmN1clNlbGVjdGlvbkZvciA9IHRoaXMuc3RlcHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmN1clNlbGVjdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB0cmFuc2FjdGlvbidzIGN1cnJlbnQgc2VsZWN0aW9uLiBXaWxsIGRldGVybWluZSB0aGVcbiAgICBzZWxlY3Rpb24gdGhhdCB0aGUgZWRpdG9yIGdldHMgd2hlbiB0aGUgdHJhbnNhY3Rpb24gaXMgYXBwbGllZC5cbiAgICAqL1xuICAgIHNldFNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbi4kZnJvbS5kb2MgIT0gdGhpcy5kb2MpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlNlbGVjdGlvbiBwYXNzZWQgdG8gc2V0U2VsZWN0aW9uIG11c3QgcG9pbnQgYXQgdGhlIGN1cnJlbnQgZG9jdW1lbnRcIik7XG4gICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmN1clNlbGVjdGlvbkZvciA9IHRoaXMuc3RlcHMubGVuZ3RoO1xuICAgICAgICB0aGlzLnVwZGF0ZWQgPSAodGhpcy51cGRhdGVkIHwgVVBEQVRFRF9TRUwpICYgflVQREFURURfTUFSS1M7XG4gICAgICAgIHRoaXMuc3RvcmVkTWFya3MgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc2VsZWN0aW9uIHdhcyBleHBsaWNpdGx5IHVwZGF0ZWQgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGdldCBzZWxlY3Rpb25TZXQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy51cGRhdGVkICYgVVBEQVRFRF9TRUwpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSBjdXJyZW50IHN0b3JlZCBtYXJrcy5cbiAgICAqL1xuICAgIHNldFN0b3JlZE1hcmtzKG1hcmtzKSB7XG4gICAgICAgIHRoaXMuc3RvcmVkTWFya3MgPSBtYXJrcztcbiAgICAgICAgdGhpcy51cGRhdGVkIHw9IFVQREFURURfTUFSS1M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBNYWtlIHN1cmUgdGhlIGN1cnJlbnQgc3RvcmVkIG1hcmtzIG9yLCBpZiB0aGF0IGlzIG51bGwsIHRoZSBtYXJrc1xuICAgIGF0IHRoZSBzZWxlY3Rpb24sIG1hdGNoIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MuIERvZXMgbm90aGluZyBpZlxuICAgIHRoaXMgaXMgYWxyZWFkeSB0aGUgY2FzZS5cbiAgICAqL1xuICAgIGVuc3VyZU1hcmtzKG1hcmtzKSB7XG4gICAgICAgIGlmICghTWFyay5zYW1lU2V0KHRoaXMuc3RvcmVkTWFya3MgfHwgdGhpcy5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSwgbWFya3MpKVxuICAgICAgICAgICAgdGhpcy5zZXRTdG9yZWRNYXJrcyhtYXJrcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSBtYXJrIHRvIHRoZSBzZXQgb2Ygc3RvcmVkIG1hcmtzLlxuICAgICovXG4gICAgYWRkU3RvcmVkTWFyayhtYXJrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuc3VyZU1hcmtzKG1hcmsuYWRkVG9TZXQodGhpcy5zdG9yZWRNYXJrcyB8fCB0aGlzLnNlbGVjdGlvbi4kaGVhZC5tYXJrcygpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZSBhIG1hcmsgb3IgbWFyayB0eXBlIGZyb20gdGhlIHNldCBvZiBzdG9yZWQgbWFya3MuXG4gICAgKi9cbiAgICByZW1vdmVTdG9yZWRNYXJrKG1hcmspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlTWFya3MobWFyay5yZW1vdmVGcm9tU2V0KHRoaXMuc3RvcmVkTWFya3MgfHwgdGhpcy5zZWxlY3Rpb24uJGhlYWQubWFya3MoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzdG9yZWQgbWFya3Mgd2VyZSBleHBsaWNpdGx5IHNldCBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGdldCBzdG9yZWRNYXJrc1NldCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnVwZGF0ZWQgJiBVUERBVEVEX01BUktTKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkU3RlcChzdGVwLCBkb2MpIHtcbiAgICAgICAgc3VwZXIuYWRkU3RlcChzdGVwLCBkb2MpO1xuICAgICAgICB0aGlzLnVwZGF0ZWQgPSB0aGlzLnVwZGF0ZWQgJiB+VVBEQVRFRF9NQVJLUztcbiAgICAgICAgdGhpcy5zdG9yZWRNYXJrcyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdGltZXN0YW1wIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBzZXRUaW1lKHRpbWUpIHtcbiAgICAgICAgdGhpcy50aW1lID0gdGltZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIHNsaWNlLlxuICAgICovXG4gICAgcmVwbGFjZVNlbGVjdGlvbihzbGljZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5yZXBsYWNlKHRoaXMsIHNsaWNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIHRoZSBnaXZlbiBub2RlLiBXaGVuIGBpbmhlcml0TWFya3NgIGlzXG4gICAgdHJ1ZSBhbmQgdGhlIGNvbnRlbnQgaXMgaW5saW5lLCBpdCBpbmhlcml0cyB0aGUgbWFya3MgZnJvbSB0aGVcbiAgICBwbGFjZSB3aGVyZSBpdCBpcyBpbnNlcnRlZC5cbiAgICAqL1xuICAgIHJlcGxhY2VTZWxlY3Rpb25XaXRoKG5vZGUsIGluaGVyaXRNYXJrcyA9IHRydWUpIHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoaW5oZXJpdE1hcmtzKVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubWFyayh0aGlzLnN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uZW1wdHkgPyBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSA6IChzZWxlY3Rpb24uJGZyb20ubWFya3NBY3Jvc3Moc2VsZWN0aW9uLiR0bykgfHwgTWFyay5ub25lKSkpO1xuICAgICAgICBzZWxlY3Rpb24ucmVwbGFjZVdpdGgodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWxldGUgdGhlIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIGRlbGV0ZVNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ucmVwbGFjZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIGdpdmVuIHJhbmdlLCBvciB0aGUgc2VsZWN0aW9uIGlmIG5vIHJhbmdlIGlzIGdpdmVuLFxuICAgIHdpdGggYSB0ZXh0IG5vZGUgY29udGFpbmluZyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgaW5zZXJ0VGV4dCh0ZXh0LCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgc2NoZW1hID0gdGhpcy5kb2MudHlwZS5zY2hlbWE7XG4gICAgICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghdGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHNjaGVtYS50ZXh0KHRleHQpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRvID0gZnJvbTtcbiAgICAgICAgICAgIHRvID0gdG8gPT0gbnVsbCA/IGZyb20gOiB0bztcbiAgICAgICAgICAgIGlmICghdGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxldGVSYW5nZShmcm9tLCB0byk7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSB0aGlzLnN0b3JlZE1hcmtzO1xuICAgICAgICAgICAgaWYgKCFtYXJrcykge1xuICAgICAgICAgICAgICAgIGxldCAkZnJvbSA9IHRoaXMuZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgICAgICAgICAgICAgbWFya3MgPSB0byA9PSBmcm9tID8gJGZyb20ubWFya3MoKSA6ICRmcm9tLm1hcmtzQWNyb3NzKHRoaXMuZG9jLnJlc29sdmUodG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVJhbmdlV2l0aChmcm9tLCB0bywgc2NoZW1hLnRleHQodGV4dCwgbWFya3MpKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24uZW1wdHkpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodGhpcy5zZWxlY3Rpb24uJHRvKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBTdG9yZSBhIG1ldGFkYXRhIHByb3BlcnR5IGluIHRoaXMgdHJhbnNhY3Rpb24sIGtleWVkIGVpdGhlciBieVxuICAgIG5hbWUgb3IgYnkgcGx1Z2luLlxuICAgICovXG4gICAgc2V0TWV0YShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWV0YVt0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgPyBrZXkgOiBrZXkua2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmUgYSBtZXRhZGF0YSBwcm9wZXJ0eSBmb3IgYSBnaXZlbiBuYW1lIG9yIHBsdWdpbi5cbiAgICAqL1xuICAgIGdldE1ldGEoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGFbdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiID8ga2V5IDoga2V5LmtleV07XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGRvZXNuJ3QgY29udGFpbiBhbnkgbWV0YWRhdGEsXG4gICAgYW5kIGNhbiB0aHVzIHNhZmVseSBiZSBleHRlbmRlZC5cbiAgICAqL1xuICAgIGdldCBpc0dlbmVyaWMoKSB7XG4gICAgICAgIGZvciAobGV0IF8gaW4gdGhpcy5tZXRhKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGUgdGhhdCB0aGUgZWRpdG9yIHNob3VsZCBzY3JvbGwgdGhlIHNlbGVjdGlvbiBpbnRvIHZpZXdcbiAgICB3aGVuIHVwZGF0ZWQgdG8gdGhlIHN0YXRlIHByb2R1Y2VkIGJ5IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBzY3JvbGxJbnRvVmlldygpIHtcbiAgICAgICAgdGhpcy51cGRhdGVkIHw9IFVQREFURURfU0NST0xMO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGhhZCBgc2Nyb2xsSW50b1ZpZXdgIGNhbGxlZCBvbiBpdC5cbiAgICAqL1xuICAgIGdldCBzY3JvbGxlZEludG9WaWV3KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudXBkYXRlZCAmIFVQREFURURfU0NST0xMKSA+IDA7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBiaW5kKGYsIHNlbGYpIHtcbiAgICByZXR1cm4gIXNlbGYgfHwgIWYgPyBmIDogZi5iaW5kKHNlbGYpO1xufVxuY2xhc3MgRmllbGREZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBkZXNjLCBzZWxmKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaW5pdCA9IGJpbmQoZGVzYy5pbml0LCBzZWxmKTtcbiAgICAgICAgdGhpcy5hcHBseSA9IGJpbmQoZGVzYy5hcHBseSwgc2VsZik7XG4gICAgfVxufVxuY29uc3QgYmFzZUZpZWxkcyA9IFtcbiAgICBuZXcgRmllbGREZXNjKFwiZG9jXCIsIHtcbiAgICAgICAgaW5pdChjb25maWcpIHsgcmV0dXJuIGNvbmZpZy5kb2MgfHwgY29uZmlnLnNjaGVtYS50b3BOb2RlVHlwZS5jcmVhdGVBbmRGaWxsKCk7IH0sXG4gICAgICAgIGFwcGx5KHRyKSB7IHJldHVybiB0ci5kb2M7IH1cbiAgICB9KSxcbiAgICBuZXcgRmllbGREZXNjKFwic2VsZWN0aW9uXCIsIHtcbiAgICAgICAgaW5pdChjb25maWcsIGluc3RhbmNlKSB7IHJldHVybiBjb25maWcuc2VsZWN0aW9uIHx8IFNlbGVjdGlvbi5hdFN0YXJ0KGluc3RhbmNlLmRvYyk7IH0sXG4gICAgICAgIGFwcGx5KHRyKSB7IHJldHVybiB0ci5zZWxlY3Rpb247IH1cbiAgICB9KSxcbiAgICBuZXcgRmllbGREZXNjKFwic3RvcmVkTWFya3NcIiwge1xuICAgICAgICBpbml0KGNvbmZpZykgeyByZXR1cm4gY29uZmlnLnN0b3JlZE1hcmtzIHx8IG51bGw7IH0sXG4gICAgICAgIGFwcGx5KHRyLCBfbWFya3MsIF9vbGQsIHN0YXRlKSB7IHJldHVybiBzdGF0ZS5zZWxlY3Rpb24uJGN1cnNvciA/IHRyLnN0b3JlZE1hcmtzIDogbnVsbDsgfVxuICAgIH0pLFxuICAgIG5ldyBGaWVsZERlc2MoXCJzY3JvbGxUb1NlbGVjdGlvblwiLCB7XG4gICAgICAgIGluaXQoKSB7IHJldHVybiAwOyB9LFxuICAgICAgICBhcHBseSh0ciwgcHJldikgeyByZXR1cm4gdHIuc2Nyb2xsZWRJbnRvVmlldyA/IHByZXYgKyAxIDogcHJldjsgfVxuICAgIH0pXG5dO1xuLy8gT2JqZWN0IHdyYXBwaW5nIHRoZSBwYXJ0IG9mIGEgc3RhdGUgb2JqZWN0IHRoYXQgc3RheXMgdGhlIHNhbWVcbi8vIGFjcm9zcyB0cmFuc2FjdGlvbnMuIFN0b3JlZCBpbiB0aGUgc3RhdGUncyBgY29uZmlnYCBwcm9wZXJ0eS5cbmNsYXNzIENvbmZpZ3VyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSwgcGx1Z2lucykge1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMucGx1Z2luc0J5S2V5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBiYXNlRmllbGRzLnNsaWNlKCk7XG4gICAgICAgIGlmIChwbHVnaW5zKVxuICAgICAgICAgICAgcGx1Z2lucy5mb3JFYWNoKHBsdWdpbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGx1Z2luc0J5S2V5W3BsdWdpbi5rZXldKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFkZGluZyBkaWZmZXJlbnQgaW5zdGFuY2VzIG9mIGEga2V5ZWQgcGx1Z2luIChcIiArIHBsdWdpbi5rZXkgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbnNCeUtleVtwbHVnaW4ua2V5XSA9IHBsdWdpbjtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMuc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmllbGRzLnB1c2gobmV3IEZpZWxkRGVzYyhwbHVnaW4ua2V5LCBwbHVnaW4uc3BlYy5zdGF0ZSwgcGx1Z2luKSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcblRoZSBzdGF0ZSBvZiBhIFByb3NlTWlycm9yIGVkaXRvciBpcyByZXByZXNlbnRlZCBieSBhbiBvYmplY3Qgb2ZcbnRoaXMgdHlwZS4gQSBzdGF0ZSBpcyBhIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmVcdTIwMTRpdCBpc24ndFxudXBkYXRlZCwgYnV0IHJhdGhlciBhIG5ldyBzdGF0ZSB2YWx1ZSBpcyBjb21wdXRlZCBmcm9tIGFuIG9sZCBvbmVcbnVzaW5nIHRoZSBbYGFwcGx5YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmFwcGx5KSBtZXRob2QuXG5cbkEgc3RhdGUgaG9sZHMgYSBudW1iZXIgb2YgYnVpbHQtaW4gZmllbGRzLCBhbmQgcGx1Z2lucyBjYW5cbltkZWZpbmVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5QbHVnaW5TcGVjLnN0YXRlKSBhZGRpdGlvbmFsIGZpZWxkcy5cbiovXG5jbGFzcyBFZGl0b3JTdGF0ZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNjaGVtYSBvZiB0aGUgc3RhdGUncyBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBzY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5zY2hlbWE7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBwbHVnaW5zIHRoYXQgYXJlIGFjdGl2ZSBpbiB0aGlzIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5wbHVnaW5zO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBseSB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24gdG8gcHJvZHVjZSBhIG5ldyBzdGF0ZS5cbiAgICAqL1xuICAgIGFwcGx5KHRyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5VHJhbnNhY3Rpb24odHIpLnN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbHRlclRyYW5zYWN0aW9uKHRyLCBpZ25vcmUgPSAtMSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlnLnBsdWdpbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoaSAhPSBpZ25vcmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5jb25maWcucGx1Z2luc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMuZmlsdGVyVHJhbnNhY3Rpb24gJiYgIXBsdWdpbi5zcGVjLmZpbHRlclRyYW5zYWN0aW9uLmNhbGwocGx1Z2luLCB0ciwgdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFZlcmJvc2UgdmFyaWFudCBvZiBbYGFwcGx5YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmFwcGx5KSB0aGF0XG4gICAgcmV0dXJucyB0aGUgcHJlY2lzZSB0cmFuc2FjdGlvbnMgdGhhdCB3ZXJlIGFwcGxpZWQgKHdoaWNoIG1pZ2h0XG4gICAgYmUgaW5mbHVlbmNlZCBieSB0aGUgW3RyYW5zYWN0aW9uXG4gICAgaG9va3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5QbHVnaW5TcGVjLmZpbHRlclRyYW5zYWN0aW9uKSBvZlxuICAgIHBsdWdpbnMpIGFsb25nIHdpdGggdGhlIG5ldyBzdGF0ZS5cbiAgICAqL1xuICAgIGFwcGx5VHJhbnNhY3Rpb24ocm9vdFRyKSB7XG4gICAgICAgIGlmICghdGhpcy5maWx0ZXJUcmFuc2FjdGlvbihyb290VHIpKVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IHRoaXMsIHRyYW5zYWN0aW9uczogW10gfTtcbiAgICAgICAgbGV0IHRycyA9IFtyb290VHJdLCBuZXdTdGF0ZSA9IHRoaXMuYXBwbHlJbm5lcihyb290VHIpLCBzZWVuID0gbnVsbDtcbiAgICAgICAgLy8gVGhpcyBsb29wIHJlcGVhdGVkbHkgZ2l2ZXMgcGx1Z2lucyBhIGNoYW5jZSB0byByZXNwb25kIHRvXG4gICAgICAgIC8vIHRyYW5zYWN0aW9ucyBhcyBuZXcgdHJhbnNhY3Rpb25zIGFyZSBhZGRlZCwgbWFraW5nIHN1cmUgdG8gb25seVxuICAgICAgICAvLyBwYXNzIHRoZSB0cmFuc2FjdGlvbnMgdGhlIHBsdWdpbiBkaWQgbm90IHNlZSBiZWZvcmUuXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBoYXZlTmV3ID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlnLnBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5jb25maWcucGx1Z2luc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMuYXBwZW5kVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG4gPSBzZWVuID8gc2VlbltpXS5uIDogMCwgb2xkU3RhdGUgPSBzZWVuID8gc2VlbltpXS5zdGF0ZSA6IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ciA9IG4gPCB0cnMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW4uc3BlYy5hcHBlbmRUcmFuc2FjdGlvbi5jYWxsKHBsdWdpbiwgbiA/IHRycy5zbGljZShuKSA6IHRycywgb2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyICYmIG5ld1N0YXRlLmZpbHRlclRyYW5zYWN0aW9uKHRyLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcImFwcGVuZGVkVHJhbnNhY3Rpb25cIiwgcm9vdFRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2Vlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZW4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29uZmlnLnBsdWdpbnMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZW4ucHVzaChqIDwgaSA/IHsgc3RhdGU6IG5ld1N0YXRlLCBuOiB0cnMubGVuZ3RoIH0gOiB7IHN0YXRlOiB0aGlzLCBuOiAwIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJzLnB1c2godHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSBuZXdTdGF0ZS5hcHBseUlubmVyKHRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVOZXcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VlbltpXSA9IHsgc3RhdGU6IG5ld1N0YXRlLCBuOiB0cnMubGVuZ3RoIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXZlTmV3KVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBuZXdTdGF0ZSwgdHJhbnNhY3Rpb25zOiB0cnMgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFwcGx5SW5uZXIodHIpIHtcbiAgICAgICAgaWYgKCF0ci5iZWZvcmUuZXEodGhpcy5kb2MpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBcHBseWluZyBhIG1pc21hdGNoZWQgdHJhbnNhY3Rpb25cIik7XG4gICAgICAgIGxldCBuZXdJbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSh0aGlzLmNvbmZpZyksIGZpZWxkcyA9IHRoaXMuY29uZmlnLmZpZWxkcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgICAgIG5ld0luc3RhbmNlW2ZpZWxkLm5hbWVdID0gZmllbGQuYXBwbHkodHIsIHRoaXNbZmllbGQubmFtZV0sIHRoaXMsIG5ld0luc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3SW5zdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFN0YXJ0IGEgW3RyYW5zYWN0aW9uXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24pIGZyb20gdGhpcyBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCB0cigpIHsgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbih0aGlzKTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlnKSB7XG4gICAgICAgIGxldCAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24oY29uZmlnLmRvYyA/IGNvbmZpZy5kb2MudHlwZS5zY2hlbWEgOiBjb25maWcuc2NoZW1hLCBjb25maWcucGx1Z2lucyk7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSgkY29uZmlnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAkY29uZmlnLmZpZWxkcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGluc3RhbmNlWyRjb25maWcuZmllbGRzW2ldLm5hbWVdID0gJGNvbmZpZy5maWVsZHNbaV0uaW5pdChjb25maWcsIGluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgc3RhdGUgYmFzZWQgb24gdGhpcyBvbmUsIGJ1dCB3aXRoIGFuIGFkanVzdGVkIHNldFxuICAgIG9mIGFjdGl2ZSBwbHVnaW5zLiBTdGF0ZSBmaWVsZHMgdGhhdCBleGlzdCBpbiBib3RoIHNldHMgb2ZcbiAgICBwbHVnaW5zIGFyZSBrZXB0IHVuY2hhbmdlZC4gVGhvc2UgdGhhdCBubyBsb25nZXIgZXhpc3QgYXJlXG4gICAgZHJvcHBlZCwgYW5kIHRob3NlIHRoYXQgYXJlIG5ldyBhcmUgaW5pdGlhbGl6ZWQgdXNpbmcgdGhlaXJcbiAgICBbYGluaXRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuU3RhdGVGaWVsZC5pbml0KSBtZXRob2QsIHBhc3NpbmcgaW4gdGhlIG5ld1xuICAgIGNvbmZpZ3VyYXRpb24gb2JqZWN0Li5cbiAgICAqL1xuICAgIHJlY29uZmlndXJlKGNvbmZpZykge1xuICAgICAgICBsZXQgJGNvbmZpZyA9IG5ldyBDb25maWd1cmF0aW9uKHRoaXMuc2NoZW1hLCBjb25maWcucGx1Z2lucyk7XG4gICAgICAgIGxldCBmaWVsZHMgPSAkY29uZmlnLmZpZWxkcywgaW5zdGFuY2UgPSBuZXcgRWRpdG9yU3RhdGUoJGNvbmZpZyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGZpZWxkc1tpXS5uYW1lO1xuICAgICAgICAgICAgaW5zdGFuY2VbbmFtZV0gPSB0aGlzLmhhc093blByb3BlcnR5KG5hbWUpID8gdGhpc1tuYW1lXSA6IGZpZWxkc1tpXS5pbml0KGNvbmZpZywgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoaXMgc3RhdGUgdG8gSlNPTi4gSWYgeW91IHdhbnQgdG8gc2VyaWFsaXplIHRoZSBzdGF0ZVxuICAgIG9mIHBsdWdpbnMsIHBhc3MgYW4gb2JqZWN0IG1hcHBpbmcgcHJvcGVydHkgbmFtZXMgdG8gdXNlIGluIHRoZVxuICAgIHJlc3VsdGluZyBKU09OIG9iamVjdCB0byBwbHVnaW4gb2JqZWN0cy4gVGhlIGFyZ3VtZW50IG1heSBhbHNvIGJlXG4gICAgYSBzdHJpbmcgb3IgbnVtYmVyLCBpbiB3aGljaCBjYXNlIGl0IGlzIGlnbm9yZWQsIHRvIHN1cHBvcnQgdGhlXG4gICAgd2F5IGBKU09OLnN0cmluZ2lmeWAgY2FsbHMgYHRvU3RyaW5nYCBtZXRob2RzLlxuICAgICovXG4gICAgdG9KU09OKHBsdWdpbkZpZWxkcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0geyBkb2M6IHRoaXMuZG9jLnRvSlNPTigpLCBzZWxlY3Rpb246IHRoaXMuc2VsZWN0aW9uLnRvSlNPTigpIH07XG4gICAgICAgIGlmICh0aGlzLnN0b3JlZE1hcmtzKVxuICAgICAgICAgICAgcmVzdWx0LnN0b3JlZE1hcmtzID0gdGhpcy5zdG9yZWRNYXJrcy5tYXAobSA9PiBtLnRvSlNPTigpKTtcbiAgICAgICAgaWYgKHBsdWdpbkZpZWxkcyAmJiB0eXBlb2YgcGx1Z2luRmllbGRzID09ICdvYmplY3QnKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBwbHVnaW5GaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PSBcImRvY1wiIHx8IHByb3AgPT0gXCJzZWxlY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgSlNPTiBmaWVsZHMgYGRvY2AgYW5kIGBzZWxlY3Rpb25gIGFyZSByZXNlcnZlZFwiKTtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gcGx1Z2luRmllbGRzW3Byb3BdLCBzdGF0ZSA9IHBsdWdpbi5zcGVjLnN0YXRlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS50b0pTT04pXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IHN0YXRlLnRvSlNPTi5jYWxsKHBsdWdpbiwgdGhpc1twbHVnaW4ua2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHN0YXRlLiBgY29uZmlnYCBzaG91bGRcbiAgICBoYXZlIGF0IGxlYXN0IGEgYHNjaGVtYWAgZmllbGQsIGFuZCBzaG91bGQgY29udGFpbiBhcnJheSBvZlxuICAgIHBsdWdpbnMgdG8gaW5pdGlhbGl6ZSB0aGUgc3RhdGUgd2l0aC4gYHBsdWdpbkZpZWxkc2AgY2FuIGJlIHVzZWRcbiAgICB0byBkZXNlcmlhbGl6ZSB0aGUgc3RhdGUgb2YgcGx1Z2lucywgYnkgYXNzb2NpYXRpbmcgcGx1Z2luXG4gICAgaW5zdGFuY2VzIHdpdGggdGhlIHByb3BlcnR5IG5hbWVzIHRoZXkgdXNlIGluIHRoZSBKU09OIG9iamVjdC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihjb25maWcsIGpzb24sIHBsdWdpbkZpZWxkcykge1xuICAgICAgICBpZiAoIWpzb24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEVkaXRvclN0YXRlLmZyb21KU09OXCIpO1xuICAgICAgICBpZiAoIWNvbmZpZy5zY2hlbWEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJlcXVpcmVkIGNvbmZpZyBmaWVsZCAnc2NoZW1hJyBtaXNzaW5nXCIpO1xuICAgICAgICBsZXQgJGNvbmZpZyA9IG5ldyBDb25maWd1cmF0aW9uKGNvbmZpZy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKCRjb25maWcpO1xuICAgICAgICAkY29uZmlnLmZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5uYW1lID09IFwiZG9jXCIpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5kb2MgPSBOb2RlLmZyb21KU09OKGNvbmZpZy5zY2hlbWEsIGpzb24uZG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLm5hbWUgPT0gXCJzZWxlY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLnNlbGVjdGlvbiA9IFNlbGVjdGlvbi5mcm9tSlNPTihpbnN0YW5jZS5kb2MsIGpzb24uc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLm5hbWUgPT0gXCJzdG9yZWRNYXJrc1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpzb24uc3RvcmVkTWFya3MpXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnN0b3JlZE1hcmtzID0ganNvbi5zdG9yZWRNYXJrcy5tYXAoY29uZmlnLnNjaGVtYS5tYXJrRnJvbUpTT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbkZpZWxkcylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBwbHVnaW5GaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSBwbHVnaW5GaWVsZHNbcHJvcF0sIHN0YXRlID0gcGx1Z2luLnNwZWMuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGx1Z2luLmtleSA9PSBmaWVsZC5uYW1lICYmIHN0YXRlICYmIHN0YXRlLmZyb21KU09OICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGpzb24sIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VbZmllbGQubmFtZV0gPSBzdGF0ZS5mcm9tSlNPTi5jYWxsKHBsdWdpbiwgY29uZmlnLCBqc29uW3Byb3BdLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VbZmllbGQubmFtZV0gPSBmaWVsZC5pbml0KGNvbmZpZywgaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYmluZFByb3BzKG9iaiwgc2VsZiwgdGFyZ2V0KSB7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgbGV0IHZhbCA9IG9ialtwcm9wXTtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAgICAgICAgdmFsID0gdmFsLmJpbmQoc2VsZik7XG4gICAgICAgIGVsc2UgaWYgKHByb3AgPT0gXCJoYW5kbGVET01FdmVudHNcIilcbiAgICAgICAgICAgIHZhbCA9IGJpbmRQcm9wcyh2YWwsIHNlbGYsIHt9KTtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuLyoqXG5QbHVnaW5zIGJ1bmRsZSBmdW5jdGlvbmFsaXR5IHRoYXQgY2FuIGJlIGFkZGVkIHRvIGFuIGVkaXRvci5cblRoZXkgYXJlIHBhcnQgb2YgdGhlIFtlZGl0b3Igc3RhdGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZSkgYW5kXG5tYXkgaW5mbHVlbmNlIHRoYXQgc3RhdGUgYW5kIHRoZSB2aWV3IHRoYXQgY29udGFpbnMgaXQuXG4qL1xuY2xhc3MgUGx1Z2luIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBwbHVnaW4uXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcGx1Z2luJ3MgW3NwZWMgb2JqZWN0XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuUGx1Z2luU3BlYykuXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgW3Byb3BzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcykgZXhwb3J0ZWQgYnkgdGhpcyBwbHVnaW4uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucHJvcHMgPSB7fTtcbiAgICAgICAgaWYgKHNwZWMucHJvcHMpXG4gICAgICAgICAgICBiaW5kUHJvcHMoc3BlYy5wcm9wcywgdGhpcywgdGhpcy5wcm9wcyk7XG4gICAgICAgIHRoaXMua2V5ID0gc3BlYy5rZXkgPyBzcGVjLmtleS5rZXkgOiBjcmVhdGVLZXkoXCJwbHVnaW5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4dHJhY3QgdGhlIHBsdWdpbidzIHN0YXRlIGZpZWxkIGZyb20gYW4gZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgZ2V0U3RhdGUoc3RhdGUpIHsgcmV0dXJuIHN0YXRlW3RoaXMua2V5XTsgfVxufVxuY29uc3Qga2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBjcmVhdGVLZXkobmFtZSkge1xuICAgIGlmIChuYW1lIGluIGtleXMpXG4gICAgICAgIHJldHVybiBuYW1lICsgXCIkXCIgKyArK2tleXNbbmFtZV07XG4gICAga2V5c1tuYW1lXSA9IDA7XG4gICAgcmV0dXJuIG5hbWUgKyBcIiRcIjtcbn1cbi8qKlxuQSBrZXkgaXMgdXNlZCB0byBbdGFnXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuUGx1Z2luU3BlYy5rZXkpIHBsdWdpbnMgaW4gYSB3YXlcbnRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG8gZmluZCB0aGVtLCBnaXZlbiBhbiBlZGl0b3Igc3RhdGUuXG5Bc3NpZ25pbmcgYSBrZXkgZG9lcyBtZWFuIG9ubHkgb25lIHBsdWdpbiBvZiB0aGF0IHR5cGUgY2FuIGJlXG5hY3RpdmUgaW4gYSBzdGF0ZS5cbiovXG5jbGFzcyBQbHVnaW5LZXkge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBsdWdpbiBrZXkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lID0gXCJrZXlcIikgeyB0aGlzLmtleSA9IGNyZWF0ZUtleShuYW1lKTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgYWN0aXZlIHBsdWdpbiB3aXRoIHRoaXMga2V5LCBpZiBhbnksIGZyb20gYW4gZWRpdG9yXG4gICAgc3RhdGUuXG4gICAgKi9cbiAgICBnZXQoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLmNvbmZpZy5wbHVnaW5zQnlLZXlbdGhpcy5rZXldOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwbHVnaW4ncyBzdGF0ZSBmcm9tIGFuIGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIGdldFN0YXRlKHN0YXRlKSB7IHJldHVybiBzdGF0ZVt0aGlzLmtleV07IH1cbn1cblxuZXhwb3J0IHsgQWxsU2VsZWN0aW9uLCBFZGl0b3JTdGF0ZSwgTm9kZVNlbGVjdGlvbiwgUGx1Z2luLCBQbHVnaW5LZXksIFNlbGVjdGlvbiwgU2VsZWN0aW9uUmFuZ2UsIFRleHRTZWxlY3Rpb24sIFRyYW5zYWN0aW9uIH07XG4iLCAiaW1wb3J0IHsgbGlmdFRhcmdldCwgcmVwbGFjZVN0ZXAsIFJlcGxhY2VTdGVwLCBjYW5Kb2luLCBqb2luUG9pbnQsIGNhblNwbGl0LCBSZXBsYWNlQXJvdW5kU3RlcCwgZmluZFdyYXBwaW5nIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcbmltcG9ydCB7IFNsaWNlLCBGcmFnbWVudCB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IE5vZGVTZWxlY3Rpb24sIFNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiwgQWxsU2VsZWN0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBpZiB0aGVyZSBpcyBvbmUuXG4qL1xuY29uc3QgZGVsZXRlU2VsZWN0aW9uID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24uZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZVNlbGVjdGlvbigpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldykge1xuICAgIGxldCB7ICRjdXJzb3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRjdXJzb3IgfHwgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImJhY2t3YXJkXCIsIHN0YXRlKVxuICAgICAgICA6ICRjdXJzb3IucGFyZW50T2Zmc2V0ID4gMCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiAkY3Vyc29yO1xufVxuLyoqXG5JZiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2ssIHRyeSB0b1xucmVkdWNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoYXQgYmxvY2sgYW5kIHRoZSBvbmUgYmVmb3JlIGl0XHUyMDE0aWZcbnRoZXJlJ3MgYSBibG9jayBkaXJlY3RseSBiZWZvcmUgaXQgdGhhdCBjYW4gYmUgam9pbmVkLCBqb2luIHRoZW0uXG5JZiBub3QsIHRyeSB0byBtb3ZlIHRoZSBzZWxlY3RlZCBibG9jayBjbG9zZXIgdG8gdGhlIG5leHQgb25lIGluXG50aGUgZG9jdW1lbnQgc3RydWN0dXJlIGJ5IGxpZnRpbmcgaXQgb3V0IG9mIGl0cyBwYXJlbnQgb3IgbW92aW5nIGl0XG5pbnRvIGEgcGFyZW50IG9mIHRoZSBwcmV2aW91cyBibG9jay4gV2lsbCB1c2UgdGhlIHZpZXcgZm9yIGFjY3VyYXRlXG4oYmlkaS1hd2FyZSkgc3RhcnQtb2YtdGV4dGJsb2NrIGRldGVjdGlvbiBpZiBnaXZlbi5cbiovXG5jb25zdCBqb2luQmFja3dhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrU3RhcnQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEJlZm9yZSgkY3Vyc29yKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBub2RlIGJlZm9yZSB0aGlzLCB0cnkgdG8gbGlmdFxuICAgIGlmICghJGN1dCkge1xuICAgICAgICBsZXQgcmFuZ2UgPSAkY3Vyc29yLmJsb2NrUmFuZ2UoKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBiZWZvcmUgPSAkY3V0Lm5vZGVCZWZvcmU7XG4gICAgLy8gQXBwbHkgdGhlIGpvaW5pbmcgYWxnb3JpdGhtXG4gICAgaWYgKCFiZWZvcmUudHlwZS5zcGVjLmlzb2xhdGluZyAmJiBkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIElmIHRoZSBub2RlIGJlbG93IGhhcyBubyBjb250ZW50IGFuZCB0aGUgbm9kZSBhYm92ZSBpc1xuICAgIC8vIHNlbGVjdGFibGUsIGRlbGV0ZSB0aGUgbm9kZSBiZWxvdyBhbmQgc2VsZWN0IHRoZSBvbmUgYWJvdmUuXG4gICAgaWYgKCRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmXG4gICAgICAgICh0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpIHx8IE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGJlZm9yZSkpKSB7XG4gICAgICAgIGxldCBkZWxTdGVwID0gcmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCAkY3Vyc29yLmJlZm9yZSgpLCAkY3Vyc29yLmFmdGVyKCksIFNsaWNlLmVtcHR5KTtcbiAgICAgICAgaWYgKGRlbFN0ZXAgJiYgZGVsU3RlcC5zbGljZS5zaXplIDwgZGVsU3RlcC50byAtIGRlbFN0ZXAuZnJvbSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChkZWxTdGVwKTtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24odGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSA/IFNlbGVjdGlvbi5maW5kRnJvbSh0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLm1hcCgkY3V0LnBvcywgLTEpKSwgLTEpXG4gICAgICAgICAgICAgICAgICAgIDogTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkY3V0LnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIG5vZGUgYmVmb3JlIGlzIGFuIGF0b20sIGRlbGV0ZSBpdFxuICAgIGlmIChiZWZvcmUuaXNBdG9tICYmICRjdXQuZGVwdGggPT0gJGN1cnNvci5kZXB0aCAtIDEpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRjdXQucG9zIC0gYmVmb3JlLm5vZGVTaXplLCAkY3V0LnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG5BIG1vcmUgbGltaXRlZCBmb3JtIG9mIFtgam9pbkJhY2t3YXJkYF0oJGNvbW1hbmRzLmpvaW5CYWNrd2FyZClcbnRoYXQgb25seSB0cmllcyB0byBqb2luIHRoZSBjdXJyZW50IHRleHRibG9jayB0byB0aGUgb25lIGJlZm9yZVxuaXQsIGlmIHRoZSBjdXJzb3IgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuKi9cbmNvbnN0IGpvaW5UZXh0YmxvY2tCYWNrd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRjdXJzb3IpO1xuICAgIHJldHVybiAkY3V0ID8gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSA6IGZhbHNlO1xufTtcbi8qKlxuQSBtb3JlIGxpbWl0ZWQgZm9ybSBvZiBbYGpvaW5Gb3J3YXJkYF0oJGNvbW1hbmRzLmpvaW5Gb3J3YXJkKVxudGhhdCBvbmx5IHRyaWVzIHRvIGpvaW4gdGhlIGN1cnJlbnQgdGV4dGJsb2NrIHRvIHRoZSBvbmUgYWZ0ZXJcbml0LCBpZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2suXG4qL1xuY29uc3Qgam9pblRleHRibG9ja0ZvcndhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrRW5kKHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRBZnRlcigkY3Vyc29yKTtcbiAgICByZXR1cm4gJGN1dCA/IGpvaW5UZXh0YmxvY2tzQXJvdW5kKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiBqb2luVGV4dGJsb2Nrc0Fyb3VuZChzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpIHtcbiAgICBsZXQgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlLCBiZWZvcmVUZXh0ID0gYmVmb3JlLCBiZWZvcmVQb3MgPSAkY3V0LnBvcyAtIDE7XG4gICAgZm9yICg7ICFiZWZvcmVUZXh0LmlzVGV4dGJsb2NrOyBiZWZvcmVQb3MtLSkge1xuICAgICAgICBpZiAoYmVmb3JlVGV4dC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hpbGQgPSBiZWZvcmVUZXh0Lmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgYmVmb3JlVGV4dCA9IGNoaWxkO1xuICAgIH1cbiAgICBsZXQgYWZ0ZXIgPSAkY3V0Lm5vZGVBZnRlciwgYWZ0ZXJUZXh0ID0gYWZ0ZXIsIGFmdGVyUG9zID0gJGN1dC5wb3MgKyAxO1xuICAgIGZvciAoOyAhYWZ0ZXJUZXh0LmlzVGV4dGJsb2NrOyBhZnRlclBvcysrKSB7XG4gICAgICAgIGlmIChhZnRlclRleHQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gYWZ0ZXJUZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGFmdGVyVGV4dCA9IGNoaWxkO1xuICAgIH1cbiAgICBsZXQgc3RlcCA9IHJlcGxhY2VTdGVwKHN0YXRlLmRvYywgYmVmb3JlUG9zLCBhZnRlclBvcywgU2xpY2UuZW1wdHkpO1xuICAgIGlmICghc3RlcCB8fCBzdGVwLmZyb20gIT0gYmVmb3JlUG9zIHx8XG4gICAgICAgIHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCAmJiBzdGVwLnNsaWNlLnNpemUgPj0gYWZ0ZXJQb3MgLSBiZWZvcmVQb3MpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChzdGVwKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgYmVmb3JlUG9zKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRleHRibG9ja0F0KG5vZGUsIHNpZGUsIG9ubHkgPSBmYWxzZSkge1xuICAgIGZvciAobGV0IHNjYW4gPSBub2RlOyBzY2FuOyBzY2FuID0gKHNpZGUgPT0gXCJzdGFydFwiID8gc2Nhbi5maXJzdENoaWxkIDogc2Nhbi5sYXN0Q2hpbGQpKSB7XG4gICAgICAgIGlmIChzY2FuLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvbmx5ICYmIHNjYW4uY2hpbGRDb3VudCAhPSAxKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbldoZW4gdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLCBzZWxlY3RcbnRoZSBub2RlIGJlZm9yZSB0aGF0IHRleHRibG9jaywgaWYgcG9zc2libGUuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbmJvdW5kIHRvIGtleXMgbGlrZSBiYWNrc3BhY2UsIGFmdGVyXG5bYGpvaW5CYWNrd2FyZGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5qb2luQmFja3dhcmQpIG9yIG90aGVyIGRlbGV0aW5nXG5jb21tYW5kcywgYXMgYSBmYWxsLWJhY2sgYmVoYXZpb3Igd2hlbiB0aGUgc2NoZW1hIGRvZXNuJ3QgYWxsb3dcbmRlbGV0aW9uIGF0IHRoZSBzZWxlY3RlZCBwb2ludC5cbiovXG5jb25zdCBzZWxlY3ROb2RlQmFja3dhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb24sICRjdXQgPSAkaGVhZDtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgICAgICBpZiAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiYmFja3dhcmRcIiwgc3RhdGUpIDogJGhlYWQucGFyZW50T2Zmc2V0ID4gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGhlYWQpO1xuICAgIH1cbiAgICBsZXQgbm9kZSA9ICRjdXQgJiYgJGN1dC5ub2RlQmVmb3JlO1xuICAgIGlmICghbm9kZSB8fCAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsICRjdXQucG9zIC0gbm9kZS5ub2RlU2l6ZSkpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGZpbmRDdXRCZWZvcmUoJHBvcykge1xuICAgIGlmICghJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKCRwb3MuaW5kZXgoaSkgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmRvYy5yZXNvbHZlKCRwb3MuYmVmb3JlKGkgKyAxKSk7XG4gICAgICAgICAgICBpZiAoJHBvcy5ub2RlKGkpLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpIHtcbiAgICBsZXQgeyAkY3Vyc29yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJmb3J3YXJkXCIsIHN0YXRlKVxuICAgICAgICA6ICRjdXJzb3IucGFyZW50T2Zmc2V0IDwgJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuICRjdXJzb3I7XG59XG4vKipcbklmIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIHRoZSBjdXJzb3IgaXMgYXQgdGhlIGVuZCBvZiBhXG50ZXh0YmxvY2ssIHRyeSB0byByZWR1Y2Ugb3IgcmVtb3ZlIHRoZSBib3VuZGFyeSBiZXR3ZWVuIHRoYXQgYmxvY2tcbmFuZCB0aGUgb25lIGFmdGVyIGl0LCBlaXRoZXIgYnkgam9pbmluZyB0aGVtIG9yIGJ5IG1vdmluZyB0aGUgb3RoZXJcbmJsb2NrIGNsb3NlciB0byB0aGlzIG9uZSBpbiB0aGUgdHJlZSBzdHJ1Y3R1cmUuIFdpbGwgdXNlIHRoZSB2aWV3XG5mb3IgYWNjdXJhdGUgc3RhcnQtb2YtdGV4dGJsb2NrIGRldGVjdGlvbiBpZiBnaXZlbi5cbiovXG5jb25zdCBqb2luRm9yd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEFmdGVyKCRjdXJzb3IpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIG5vZGUgYWZ0ZXIgdGhpcywgdGhlcmUncyBub3RoaW5nIHRvIGRvXG4gICAgaWYgKCEkY3V0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXI7XG4gICAgLy8gVHJ5IHRoZSBqb2luaW5nIGFsZ29yaXRobVxuICAgIGlmIChkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIElmIHRoZSBub2RlIGFib3ZlIGhhcyBubyBjb250ZW50IGFuZCB0aGUgbm9kZSBiZWxvdyBpc1xuICAgIC8vIHNlbGVjdGFibGUsIGRlbGV0ZSB0aGUgbm9kZSBhYm92ZSBhbmQgc2VsZWN0IHRoZSBvbmUgYmVsb3cuXG4gICAgaWYgKCRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmXG4gICAgICAgICh0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiKSB8fCBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShhZnRlcikpKSB7XG4gICAgICAgIGxldCBkZWxTdGVwID0gcmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCAkY3Vyc29yLmJlZm9yZSgpLCAkY3Vyc29yLmFmdGVyKCksIFNsaWNlLmVtcHR5KTtcbiAgICAgICAgaWYgKGRlbFN0ZXAgJiYgZGVsU3RlcC5zbGljZS5zaXplIDwgZGVsU3RlcC50byAtIGRlbFN0ZXAuZnJvbSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChkZWxTdGVwKTtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24odGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIikgPyBTZWxlY3Rpb24uZmluZEZyb20odHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5tYXAoJGN1dC5wb3MpKSwgMSlcbiAgICAgICAgICAgICAgICAgICAgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRjdXQucG9zKSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIG5leHQgbm9kZSBpcyBhbiBhdG9tLCBkZWxldGUgaXRcbiAgICBpZiAoYWZ0ZXIuaXNBdG9tICYmICRjdXQuZGVwdGggPT0gJGN1cnNvci5kZXB0aCAtIDEpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRjdXQucG9zLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbldoZW4gdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgYXQgdGhlIGVuZCBvZiBhIHRleHRibG9jaywgc2VsZWN0XG50aGUgbm9kZSBjb21pbmcgYWZ0ZXIgdGhhdCB0ZXh0YmxvY2ssIGlmIHBvc3NpYmxlLiBUaGlzIGlzIGludGVuZGVkXG50byBiZSBib3VuZCB0byBrZXlzIGxpa2UgZGVsZXRlLCBhZnRlclxuW2Bqb2luRm9yd2FyZGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5qb2luRm9yd2FyZCkgYW5kIHNpbWlsYXIgZGVsZXRpbmdcbmNvbW1hbmRzLCB0byBwcm92aWRlIGEgZmFsbC1iYWNrIGJlaGF2aW9yIHdoZW4gdGhlIHNjaGVtYSBkb2Vzbid0XG5hbGxvdyBkZWxldGlvbiBhdCB0aGUgc2VsZWN0ZWQgcG9pbnQuXG4qL1xuY29uc3Qgc2VsZWN0Tm9kZUZvcndhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb24sICRjdXQgPSAkaGVhZDtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgICAgICBpZiAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiZm9yd2FyZFwiLCBzdGF0ZSkgOiAkaGVhZC5wYXJlbnRPZmZzZXQgPCAkaGVhZC5wYXJlbnQuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAkY3V0ID0gZmluZEN1dEFmdGVyKCRoZWFkKTtcbiAgICB9XG4gICAgbGV0IG5vZGUgPSAkY3V0ICYmICRjdXQubm9kZUFmdGVyO1xuICAgIGlmICghbm9kZSB8fCAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsICRjdXQucG9zKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZmluZEN1dEFmdGVyKCRwb3MpIHtcbiAgICBpZiAoISRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkcG9zLm5vZGUoaSk7XG4gICAgICAgICAgICBpZiAoJHBvcy5pbmRleChpKSArIDEgPCBwYXJlbnQuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5kb2MucmVzb2x2ZSgkcG9zLmFmdGVyKGkgKyAxKSk7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuSm9pbiB0aGUgc2VsZWN0ZWQgYmxvY2sgb3IsIGlmIHRoZXJlIGlzIGEgdGV4dCBzZWxlY3Rpb24sIHRoZVxuY2xvc2VzdCBhbmNlc3RvciBibG9jayBvZiB0aGUgc2VsZWN0aW9uIHRoYXQgY2FuIGJlIGpvaW5lZCwgd2l0aFxudGhlIHNpYmxpbmcgYWJvdmUgaXQuXG4qL1xuY29uc3Qgam9pblVwID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIG5vZGVTZWwgPSBzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uLCBwb2ludDtcbiAgICBpZiAobm9kZVNlbCkge1xuICAgICAgICBpZiAoc2VsLm5vZGUuaXNUZXh0YmxvY2sgfHwgIWNhbkpvaW4oc3RhdGUuZG9jLCBzZWwuZnJvbSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBvaW50ID0gc2VsLmZyb207XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHNlbC5mcm9tLCAtMSk7XG4gICAgICAgIGlmIChwb2ludCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuam9pbihwb2ludCk7XG4gICAgICAgIGlmIChub2RlU2VsKVxuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgcG9pbnQgLSBzdGF0ZS5kb2MucmVzb2x2ZShwb2ludCkubm9kZUJlZm9yZS5ub2RlU2l6ZSkpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Kb2luIHRoZSBzZWxlY3RlZCBibG9jaywgb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2YgdGhlIHNlbGVjdGlvblxudGhhdCBjYW4gYmUgam9pbmVkLCB3aXRoIHRoZSBzaWJsaW5nIGFmdGVyIGl0LlxuKi9cbmNvbnN0IGpvaW5Eb3duID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIHBvaW50O1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChzZWwubm9kZS5pc1RleHRibG9jayB8fCAhY2FuSm9pbihzdGF0ZS5kb2MsIHNlbC50bykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBvaW50ID0gc2VsLnRvO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzZWwudG8sIDEpO1xuICAgICAgICBpZiAocG9pbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5qb2luKHBvaW50KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkxpZnQgdGhlIHNlbGVjdGVkIGJsb2NrLCBvciB0aGUgY2xvc2VzdCBhbmNlc3RvciBibG9jayBvZiB0aGVcbnNlbGVjdGlvbiB0aGF0IGNhbiBiZSBsaWZ0ZWQsIG91dCBvZiBpdHMgcGFyZW50IG5vZGUuXG4qL1xuY29uc3QgbGlmdCA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JZiB0aGUgc2VsZWN0aW9uIGlzIGluIGEgbm9kZSB3aG9zZSB0eXBlIGhhcyBhIHRydXRoeVxuW2Bjb2RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmNvZGUpIHByb3BlcnR5IGluIGl0cyBzcGVjLCByZXBsYWNlIHRoZVxuc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lIGNoYXJhY3Rlci5cbiovXG5jb25zdCBuZXdsaW5lSW5Db2RlID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmluc2VydFRleHQoXCJcXG5cIikuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZGVmYXVsdEJsb2NrQXQobWF0Y2gpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCB7IHR5cGUgfSA9IG1hdGNoLmVkZ2UoaSk7XG4gICAgICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSlcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuV2hlbiB0aGUgc2VsZWN0aW9uIGlzIGluIGEgbm9kZSB3aXRoIGEgdHJ1dGh5XG5bYGNvZGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuY29kZSkgcHJvcGVydHkgaW4gaXRzIHNwZWMsIGNyZWF0ZSBhXG5kZWZhdWx0IGJsb2NrIGFmdGVyIHRoZSBjb2RlIGJsb2NrLCBhbmQgbW92ZSB0aGUgY3Vyc29yIHRoZXJlLlxuKi9cbmNvbnN0IGV4aXRDb2RlID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYWJvdmUgPSAkaGVhZC5ub2RlKC0xKSwgYWZ0ZXIgPSAkaGVhZC5pbmRleEFmdGVyKC0xKSwgdHlwZSA9IGRlZmF1bHRCbG9ja0F0KGFib3ZlLmNvbnRlbnRNYXRjaEF0KGFmdGVyKSk7XG4gICAgaWYgKCF0eXBlIHx8ICFhYm92ZS5jYW5SZXBsYWNlV2l0aChhZnRlciwgYWZ0ZXIsIHR5cGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBwb3MgPSAkaGVhZC5hZnRlcigpLCB0ciA9IHN0YXRlLnRyLnJlcGxhY2VXaXRoKHBvcywgcG9zLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShwb3MpLCAxKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbklmIGEgYmxvY2sgbm9kZSBpcyBzZWxlY3RlZCwgY3JlYXRlIGFuIGVtcHR5IHBhcmFncmFwaCBiZWZvcmUgKGlmXG5pdCBpcyBpdHMgcGFyZW50J3MgZmlyc3QgY2hpbGQpIG9yIGFmdGVyIGl0LlxuKi9cbmNvbnN0IGNyZWF0ZVBhcmFncmFwaE5lYXIgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgeyAkZnJvbSwgJHRvIH0gPSBzZWw7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbiB8fCAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCB8fCAkdG8ucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdHlwZSA9IGRlZmF1bHRCbG9ja0F0KCR0by5wYXJlbnQuY29udGVudE1hdGNoQXQoJHRvLmluZGV4QWZ0ZXIoKSkpO1xuICAgIGlmICghdHlwZSB8fCAhdHlwZS5pc1RleHRibG9jaylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgc2lkZSA9ICghJGZyb20ucGFyZW50T2Zmc2V0ICYmICR0by5pbmRleCgpIDwgJHRvLnBhcmVudC5jaGlsZENvdW50ID8gJGZyb20gOiAkdG8pLnBvcztcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuaW5zZXJ0KHNpZGUsIHR5cGUuY3JlYXRlQW5kRmlsbCgpKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgc2lkZSArIDEpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSWYgdGhlIGN1cnNvciBpcyBpbiBhbiBlbXB0eSB0ZXh0YmxvY2sgdGhhdCBjYW4gYmUgbGlmdGVkLCBsaWZ0IHRoZVxuYmxvY2suXG4qL1xuY29uc3QgbGlmdEVtcHR5QmxvY2sgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGN1cnNvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGN1cnNvciB8fCAkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoJGN1cnNvci5kZXB0aCA+IDEgJiYgJGN1cnNvci5hZnRlcigpICE9ICRjdXJzb3IuZW5kKC0xKSkge1xuICAgICAgICBsZXQgYmVmb3JlID0gJGN1cnNvci5iZWZvcmUoKTtcbiAgICAgICAgaWYgKGNhblNwbGl0KHN0YXRlLmRvYywgYmVmb3JlKSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNwbGl0KGJlZm9yZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmFuZ2UgPSAkY3Vyc29yLmJsb2NrUmFuZ2UoKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQ3JlYXRlIGEgdmFyaWFudCBvZiBbYHNwbGl0QmxvY2tgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuc3BsaXRCbG9jaykgdGhhdCB1c2VzXG5hIGN1c3RvbSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgdGhlIG5ld2x5IHNwbGl0IG9mZiBibG9jay5cbiovXG5mdW5jdGlvbiBzcGxpdEJsb2NrQXMoc3BsaXROb2RlKSB7XG4gICAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBzdGF0ZS5zZWxlY3Rpb24ubm9kZS5pc0Jsb2NrKSB7XG4gICAgICAgICAgICBpZiAoISRmcm9tLnBhcmVudE9mZnNldCB8fCAhY2FuU3BsaXQoc3RhdGUuZG9jLCAkZnJvbS5wb3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zcGxpdCgkZnJvbS5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkZnJvbS5wYXJlbnQuaXNCbG9jaylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgYXRFbmQgPSAkdG8ucGFyZW50T2Zmc2V0ID09ICR0by5wYXJlbnQuY29udGVudC5zaXplO1xuICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiB8fCBzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBsZXQgZGVmbHQgPSAkZnJvbS5kZXB0aCA9PSAwID8gbnVsbCA6IGRlZmF1bHRCbG9ja0F0KCRmcm9tLm5vZGUoLTEpLmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4QWZ0ZXIoLTEpKSk7XG4gICAgICAgICAgICBsZXQgc3BsaXRUeXBlID0gc3BsaXROb2RlICYmIHNwbGl0Tm9kZSgkdG8ucGFyZW50LCBhdEVuZCk7XG4gICAgICAgICAgICBsZXQgdHlwZXMgPSBzcGxpdFR5cGUgPyBbc3BsaXRUeXBlXSA6IGF0RW5kICYmIGRlZmx0ID8gW3sgdHlwZTogZGVmbHQgfV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgY2FuID0gY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcyk7XG4gICAgICAgICAgICBpZiAoIXR5cGVzICYmICFjYW4gJiYgY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCBkZWZsdCA/IFt7IHR5cGU6IGRlZmx0IH1dIDogdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIGlmIChkZWZsdClcbiAgICAgICAgICAgICAgICAgICAgdHlwZXMgPSBbeyB0eXBlOiBkZWZsdCB9XTtcbiAgICAgICAgICAgICAgICBjYW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbikge1xuICAgICAgICAgICAgICAgIHRyLnNwbGl0KHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWF0RW5kICYmICEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJGZyb20ucGFyZW50LnR5cGUgIT0gZGVmbHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0ID0gdHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpLCAkZmlyc3QgPSB0ci5kb2MucmVzb2x2ZShmaXJzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZsdCAmJiAkZnJvbS5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkZmlyc3QuaW5kZXgoKSwgJGZpcnN0LmluZGV4KCkgKyAxLCBkZWZsdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKSwgZGVmbHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcblNwbGl0IHRoZSBwYXJlbnQgYmxvY2sgb2YgdGhlIHNlbGVjdGlvbi4gSWYgdGhlIHNlbGVjdGlvbiBpcyBhIHRleHRcbnNlbGVjdGlvbiwgYWxzbyBkZWxldGUgaXRzIGNvbnRlbnQuXG4qL1xuY29uc3Qgc3BsaXRCbG9jayA9IHNwbGl0QmxvY2tBcygpO1xuLyoqXG5BY3RzIGxpa2UgW2BzcGxpdEJsb2NrYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLnNwbGl0QmxvY2spLCBidXQgd2l0aG91dFxucmVzZXR0aW5nIHRoZSBzZXQgb2YgYWN0aXZlIG1hcmtzIGF0IHRoZSBjdXJzb3IuXG4qL1xuY29uc3Qgc3BsaXRCbG9ja0tlZXBNYXJrcyA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICByZXR1cm4gc3BsaXRCbG9jayhzdGF0ZSwgZGlzcGF0Y2ggJiYgKHRyID0+IHtcbiAgICAgICAgbGV0IG1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3MgfHwgKHN0YXRlLnNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcbiAgICAgICAgaWYgKG1hcmtzKVxuICAgICAgICAgICAgdHIuZW5zdXJlTWFya3MobWFya3MpO1xuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgfSkpO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBub2RlIHdyYXBwaW5nIHRoZSBjdXJyZW50IHNlbGVjdGlvbiwgaWZcbmFueS4gKFdpbGwgbm90IHNlbGVjdCB0aGUgZG9jdW1lbnQgbm9kZS4pXG4qL1xuY29uc3Qgc2VsZWN0UGFyZW50Tm9kZSA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvbiwgcG9zO1xuICAgIGxldCBzYW1lID0gJGZyb20uc2hhcmVkRGVwdGgodG8pO1xuICAgIGlmIChzYW1lID09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBwb3MgPSAkZnJvbS5iZWZvcmUoc2FtZSk7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCBwb3MpKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TZWxlY3QgdGhlIHdob2xlIGRvY3VtZW50LlxuKi9cbmNvbnN0IHNlbGVjdEFsbCA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgQWxsU2VsZWN0aW9uKHN0YXRlLmRvYykpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBqb2luTWF5YmVDbGVhcihzdGF0ZSwgJHBvcywgZGlzcGF0Y2gpIHtcbiAgICBsZXQgYmVmb3JlID0gJHBvcy5ub2RlQmVmb3JlLCBhZnRlciA9ICRwb3Mubm9kZUFmdGVyLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICBpZiAoIWJlZm9yZSB8fCAhYWZ0ZXIgfHwgIWJlZm9yZS50eXBlLmNvbXBhdGlibGVDb250ZW50KGFmdGVyLnR5cGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFiZWZvcmUuY29udGVudC5zaXplICYmICRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXggLSAxLCBpbmRleCkpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRwb3MucG9zIC0gYmVmb3JlLm5vZGVTaXplLCAkcG9zLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoISRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSkgfHwgIShhZnRlci5pc1RleHRibG9jayB8fCBjYW5Kb2luKHN0YXRlLmRvYywgJHBvcy5wb3MpKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHJcbiAgICAgICAgICAgIC5jbGVhckluY29tcGF0aWJsZSgkcG9zLnBvcywgYmVmb3JlLnR5cGUsIGJlZm9yZS5jb250ZW50TWF0Y2hBdChiZWZvcmUuY2hpbGRDb3VudCkpXG4gICAgICAgICAgICAuam9pbigkcG9zLnBvcylcbiAgICAgICAgICAgIC5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUJhcnJpZXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSB7XG4gICAgbGV0IGJlZm9yZSA9ICRjdXQubm9kZUJlZm9yZSwgYWZ0ZXIgPSAkY3V0Lm5vZGVBZnRlciwgY29ubiwgbWF0Y2g7XG4gICAgaWYgKGJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8IGFmdGVyLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoam9pbk1heWJlQ2xlYXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGNhbkRlbEFmdGVyID0gJGN1dC5wYXJlbnQuY2FuUmVwbGFjZSgkY3V0LmluZGV4KCksICRjdXQuaW5kZXgoKSArIDEpO1xuICAgIGlmIChjYW5EZWxBZnRlciAmJlxuICAgICAgICAoY29ubiA9IChtYXRjaCA9IGJlZm9yZS5jb250ZW50TWF0Y2hBdChiZWZvcmUuY2hpbGRDb3VudCkpLmZpbmRXcmFwcGluZyhhZnRlci50eXBlKSkgJiZcbiAgICAgICAgbWF0Y2gubWF0Y2hUeXBlKGNvbm5bMF0gfHwgYWZ0ZXIudHlwZSkudmFsaWRFbmQpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSwgd3JhcCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNvbm4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oY29ubltpXS5jcmVhdGUobnVsbCwgd3JhcCkpO1xuICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oYmVmb3JlLmNvcHkod3JhcCkpO1xuICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGN1dC5wb3MgLSAxLCBlbmQsICRjdXQucG9zLCBlbmQsIG5ldyBTbGljZSh3cmFwLCAxLCAwKSwgY29ubi5sZW5ndGgsIHRydWUpKTtcbiAgICAgICAgICAgIGxldCBqb2luQXQgPSBlbmQgKyAyICogY29ubi5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoY2FuSm9pbih0ci5kb2MsIGpvaW5BdCkpXG4gICAgICAgICAgICAgICAgdHIuam9pbihqb2luQXQpO1xuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBzZWxBZnRlciA9IFNlbGVjdGlvbi5maW5kRnJvbSgkY3V0LCAxKTtcbiAgICBsZXQgcmFuZ2UgPSBzZWxBZnRlciAmJiBzZWxBZnRlci4kZnJvbS5ibG9ja1JhbmdlKHNlbEFmdGVyLiR0byksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgIGlmICh0YXJnZXQgIT0gbnVsbCAmJiB0YXJnZXQgPj0gJGN1dC5kZXB0aCkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNhbkRlbEFmdGVyICYmIHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIsIHRydWUpICYmIHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIikpIHtcbiAgICAgICAgbGV0IGF0ID0gYmVmb3JlLCB3cmFwID0gW107XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIHdyYXAucHVzaChhdCk7XG4gICAgICAgICAgICBpZiAoYXQuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBhdCA9IGF0Lmxhc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWZ0ZXJUZXh0ID0gYWZ0ZXIsIGFmdGVyRGVwdGggPSAxO1xuICAgICAgICBmb3IgKDsgIWFmdGVyVGV4dC5pc1RleHRibG9jazsgYWZ0ZXJUZXh0ID0gYWZ0ZXJUZXh0LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICBhZnRlckRlcHRoKys7XG4gICAgICAgIGlmIChhdC5jYW5SZXBsYWNlKGF0LmNoaWxkQ291bnQsIGF0LmNoaWxkQ291bnQsIGFmdGVyVGV4dC5jb250ZW50KSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB3cmFwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBGcmFnbWVudC5mcm9tKHdyYXBbaV0uY29weShlbmQpKTtcbiAgICAgICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcCgkY3V0LnBvcyAtIHdyYXAubGVuZ3RoLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplLCAkY3V0LnBvcyArIGFmdGVyRGVwdGgsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUgLSBhZnRlckRlcHRoLCBuZXcgU2xpY2UoZW5kLCB3cmFwLmxlbmd0aCwgMCksIDAsIHRydWUpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdFRleHRibG9ja1NpZGUoc2lkZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sICRwb3MgPSBzaWRlIDwgMCA/IHNlbC4kZnJvbSA6IHNlbC4kdG87XG4gICAgICAgIGxldCBkZXB0aCA9ICRwb3MuZGVwdGg7XG4gICAgICAgIHdoaWxlICgkcG9zLm5vZGUoZGVwdGgpLmlzSW5saW5lKSB7XG4gICAgICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkcG9zLm5vZGUoZGVwdGgpLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCBzaWRlIDwgMCA/ICRwb3Muc3RhcnQoZGVwdGgpIDogJHBvcy5lbmQoZGVwdGgpKSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5Nb3ZlcyB0aGUgY3Vyc29yIHRvIHRoZSBzdGFydCBvZiBjdXJyZW50IHRleHQgYmxvY2suXG4qL1xuY29uc3Qgc2VsZWN0VGV4dGJsb2NrU3RhcnQgPSBzZWxlY3RUZXh0YmxvY2tTaWRlKC0xKTtcbi8qKlxuTW92ZXMgdGhlIGN1cnNvciB0byB0aGUgZW5kIG9mIGN1cnJlbnQgdGV4dCBibG9jay5cbiovXG5jb25zdCBzZWxlY3RUZXh0YmxvY2tFbmQgPSBzZWxlY3RUZXh0YmxvY2tTaWRlKDEpO1xuLy8gUGFyYW1ldGVyaXplZCBjb21tYW5kc1xuLyoqXG5XcmFwIHRoZSBzZWxlY3Rpb24gaW4gYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlIHdpdGggdGhlIGdpdmVuXG5hdHRyaWJ1dGVzLlxuKi9cbmZ1bmN0aW9uIHdyYXBJbihub2RlVHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byksIHdyYXBwaW5nID0gcmFuZ2UgJiYgZmluZFdyYXBwaW5nKHJhbmdlLCBub2RlVHlwZSwgYXR0cnMpO1xuICAgICAgICBpZiAoIXdyYXBwaW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci53cmFwKHJhbmdlLCB3cmFwcGluZykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcblJldHVybnMgYSBjb21tYW5kIHRoYXQgdHJpZXMgdG8gc2V0IHRoZSBzZWxlY3RlZCB0ZXh0YmxvY2tzIHRvIHRoZVxuZ2l2ZW4gbm9kZSB0eXBlIHdpdGggdGhlIGdpdmVuIGF0dHJpYnV0ZXMuXG4qL1xuZnVuY3Rpb24gc2V0QmxvY2tUeXBlKG5vZGVUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgYXBwbGljYWJsZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoICYmICFhcHBsaWNhYmxlOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7ICRmcm9tOiB7IHBvczogZnJvbSB9LCAkdG86IHsgcG9zOiB0byB9IH0gPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzW2ldO1xuICAgICAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhcHBsaWNhYmxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmlzVGV4dGJsb2NrIHx8IG5vZGUuaGFzTWFya3VwKG5vZGVUeXBlLCBhdHRycykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09IG5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0ICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgYXBwbGljYWJsZSA9ICRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCArIDEsIG5vZGVUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFwcGxpY2FibGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyAkZnJvbTogeyBwb3M6IGZyb20gfSwgJHRvOiB7IHBvczogdG8gfSB9ID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICB0ci5zZXRCbG9ja1R5cGUoZnJvbSwgdG8sIG5vZGVUeXBlLCBhdHRycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFya0FwcGxpZXMoZG9jLCByYW5nZXMsIHR5cGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV07XG4gICAgICAgIGxldCBjYW4gPSAkZnJvbS5kZXB0aCA9PSAwID8gZG9jLmlubGluZUNvbnRlbnQgJiYgZG9jLnR5cGUuYWxsb3dzTWFya1R5cGUodHlwZSkgOiBmYWxzZTtcbiAgICAgICAgZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYW4gPSBub2RlLmlubGluZUNvbnRlbnQgJiYgbm9kZS50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNhbilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbkNyZWF0ZSBhIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB0b2dnbGVzIHRoZSBnaXZlbiBtYXJrIHdpdGggdGhlXG5naXZlbiBhdHRyaWJ1dGVzLiBXaWxsIHJldHVybiBgZmFsc2VgIHdoZW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5kb2Vzbid0IHN1cHBvcnQgdGhhdCBtYXJrLiBUaGlzIHdpbGwgcmVtb3ZlIHRoZSBtYXJrIGlmIGFueSBtYXJrc1xub2YgdGhhdCB0eXBlIGV4aXN0IGluIHRoZSBzZWxlY3Rpb24sIG9yIGFkZCBpdCBvdGhlcndpc2UuIElmIHRoZVxuc2VsZWN0aW9uIGlzIGVtcHR5LCB0aGlzIGFwcGxpZXMgdG8gdGhlIFtzdG9yZWRcbm1hcmtzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuc3RvcmVkTWFya3MpIGluc3RlYWQgb2YgYSByYW5nZSBvZiB0aGVcbmRvY3VtZW50LlxuKi9cbmZ1bmN0aW9uIHRvZ2dsZU1hcmsobWFya1R5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7IGVtcHR5LCAkY3Vyc29yLCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKChlbXB0eSAmJiAhJGN1cnNvcikgfHwgIW1hcmtBcHBsaWVzKHN0YXRlLmRvYywgcmFuZ2VzLCBtYXJrVHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgaWYgKCRjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFya1R5cGUuaXNJblNldChzdGF0ZS5zdG9yZWRNYXJrcyB8fCAkY3Vyc29yLm1hcmtzKCkpKVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5hZGRTdG9yZWRNYXJrKG1hcmtUeXBlLmNyZWF0ZShhdHRycykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBoYXMgPSBmYWxzZSwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgIWhhcyAmJiBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaGFzID0gc3RhdGUuZG9jLnJhbmdlSGFzTWFyaygkZnJvbS5wb3MsICR0by5wb3MsIG1hcmtUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5yZW1vdmVNYXJrKCRmcm9tLnBvcywgJHRvLnBvcywgbWFya1R5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSAkZnJvbS5wb3MsIHRvID0gJHRvLnBvcywgc3RhcnQgPSAkZnJvbS5ub2RlQWZ0ZXIsIGVuZCA9ICR0by5ub2RlQmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlU3RhcnQgPSBzdGFydCAmJiBzdGFydC5pc1RleHQgPyAvXlxccyovLmV4ZWMoc3RhcnQudGV4dClbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZUVuZCA9IGVuZCAmJiBlbmQuaXNUZXh0ID8gL1xccyokLy5leGVjKGVuZC50ZXh0KVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gKyBzcGFjZVN0YXJ0IDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICs9IHNwYWNlU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gLT0gc3BhY2VFbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKGZyb20sIHRvLCBtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gd3JhcERpc3BhdGNoRm9ySm9pbihkaXNwYXRjaCwgaXNKb2luYWJsZSkge1xuICAgIHJldHVybiAodHIpID0+IHtcbiAgICAgICAgaWYgKCF0ci5pc0dlbmVyaWMpXG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2godHIpO1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHIubWFwcGluZy5tYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwID0gdHIubWFwcGluZy5tYXBzW2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByYW5nZXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgcmFuZ2VzW2pdID0gbWFwLm1hcChyYW5nZXNbal0pO1xuICAgICAgICAgICAgbWFwLmZvckVhY2goKF9zLCBfZSwgZnJvbSwgdG8pID0+IHJhbmdlcy5wdXNoKGZyb20sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCBqb2luYWJsZSBwb2ludHMgZXhpc3QgaW5zaWRlIHRob3NlIHJhbmdlcyxcbiAgICAgICAgLy8gYnkgY2hlY2tpbmcgYWxsIG5vZGUgYm91bmRhcmllcyBpbiB0aGVpciBwYXJlbnQgbm9kZXMuXG4gICAgICAgIGxldCBqb2luYWJsZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbaV0sIHRvID0gcmFuZ2VzW2kgKyAxXTtcbiAgICAgICAgICAgIGxldCAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLCBkZXB0aCA9ICRmcm9tLnNoYXJlZERlcHRoKHRvKSwgcGFyZW50ID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9ICRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpLCBwb3MgPSAkZnJvbS5hZnRlcihkZXB0aCArIDEpOyBwb3MgPD0gdG87ICsraW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKCFhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICYmIGpvaW5hYmxlLmluZGV4T2YocG9zKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gcGFyZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmUudHlwZSA9PSBhZnRlci50eXBlICYmIGlzSm9pbmFibGUoYmVmb3JlLCBhZnRlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luYWJsZS5wdXNoKHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyArPSBhZnRlci5ub2RlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKb2luIHRoZSBqb2luYWJsZSBwb2ludHNcbiAgICAgICAgam9pbmFibGUuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICBmb3IgKGxldCBpID0gam9pbmFibGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChjYW5Kb2luKHRyLmRvYywgam9pbmFibGVbaV0pKVxuICAgICAgICAgICAgICAgIHRyLmpvaW4oam9pbmFibGVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICB9O1xufVxuLyoqXG5XcmFwIGEgY29tbWFuZCBzbyB0aGF0LCB3aGVuIGl0IHByb2R1Y2VzIGEgdHJhbnNmb3JtIHRoYXQgY2F1c2VzXG50d28gam9pbmFibGUgbm9kZXMgdG8gZW5kIHVwIG5leHQgdG8gZWFjaCBvdGhlciwgdGhvc2UgYXJlIGpvaW5lZC5cbk5vZGVzIGFyZSBjb25zaWRlcmVkIGpvaW5hYmxlIHdoZW4gdGhleSBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhbmRcbndoZW4gdGhlIGBpc0pvaW5hYmxlYCBwcmVkaWNhdGUgcmV0dXJucyB0cnVlIGZvciB0aGVtIG9yLCBpZiBhblxuYXJyYXkgb2Ygc3RyaW5ncyB3YXMgcGFzc2VkLCBpZiB0aGVpciBub2RlIHR5cGUgbmFtZSBpcyBpbiB0aGF0XG5hcnJheS5cbiovXG5mdW5jdGlvbiBhdXRvSm9pbihjb21tYW5kLCBpc0pvaW5hYmxlKSB7XG4gICAgbGV0IGNhbkpvaW4gPSBBcnJheS5pc0FycmF5KGlzSm9pbmFibGUpID8gKG5vZGUpID0+IGlzSm9pbmFibGUuaW5kZXhPZihub2RlLnR5cGUubmFtZSkgPiAtMVxuICAgICAgICA6IGlzSm9pbmFibGU7XG4gICAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IGNvbW1hbmQoc3RhdGUsIGRpc3BhdGNoICYmIHdyYXBEaXNwYXRjaEZvckpvaW4oZGlzcGF0Y2gsIGNhbkpvaW4pLCB2aWV3KTtcbn1cbi8qKlxuQ29tYmluZSBhIG51bWJlciBvZiBjb21tYW5kIGZ1bmN0aW9ucyBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uICh3aGljaFxuY2FsbHMgdGhlbSBvbmUgYnkgb25lIHVudGlsIG9uZSByZXR1cm5zIHRydWUpLlxuKi9cbmZ1bmN0aW9uIGNoYWluQ29tbWFuZHMoLi4uY29tbWFuZHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNvbW1hbmRzW2ldKHN0YXRlLCBkaXNwYXRjaCwgdmlldykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxubGV0IGJhY2tzcGFjZSA9IGNoYWluQ29tbWFuZHMoZGVsZXRlU2VsZWN0aW9uLCBqb2luQmFja3dhcmQsIHNlbGVjdE5vZGVCYWNrd2FyZCk7XG5sZXQgZGVsID0gY2hhaW5Db21tYW5kcyhkZWxldGVTZWxlY3Rpb24sIGpvaW5Gb3J3YXJkLCBzZWxlY3ROb2RlRm9yd2FyZCk7XG4vKipcbkEgYmFzaWMga2V5bWFwIGNvbnRhaW5pbmcgYmluZGluZ3Mgbm90IHNwZWNpZmljIHRvIGFueSBzY2hlbWEuXG5CaW5kcyB0aGUgZm9sbG93aW5nIGtleXMgKHdoZW4gbXVsdGlwbGUgY29tbWFuZHMgYXJlIGxpc3RlZCwgdGhleVxuYXJlIGNoYWluZWQgd2l0aCBbYGNoYWluQ29tbWFuZHNgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuY2hhaW5Db21tYW5kcykpOlxuXG4qICoqRW50ZXIqKiB0byBgbmV3bGluZUluQ29kZWAsIGBjcmVhdGVQYXJhZ3JhcGhOZWFyYCwgYGxpZnRFbXB0eUJsb2NrYCwgYHNwbGl0QmxvY2tgXG4qICoqTW9kLUVudGVyKiogdG8gYGV4aXRDb2RlYFxuKiAqKkJhY2tzcGFjZSoqIGFuZCAqKk1vZC1CYWNrc3BhY2UqKiB0byBgZGVsZXRlU2VsZWN0aW9uYCwgYGpvaW5CYWNrd2FyZGAsIGBzZWxlY3ROb2RlQmFja3dhcmRgXG4qICoqRGVsZXRlKiogYW5kICoqTW9kLURlbGV0ZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkZvcndhcmRgLCBgc2VsZWN0Tm9kZUZvcndhcmRgXG4qICoqTW9kLURlbGV0ZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkZvcndhcmRgLCBgc2VsZWN0Tm9kZUZvcndhcmRgXG4qICoqTW9kLWEqKiB0byBgc2VsZWN0QWxsYFxuKi9cbmNvbnN0IHBjQmFzZUtleW1hcCA9IHtcbiAgICBcIkVudGVyXCI6IGNoYWluQ29tbWFuZHMobmV3bGluZUluQ29kZSwgY3JlYXRlUGFyYWdyYXBoTmVhciwgbGlmdEVtcHR5QmxvY2ssIHNwbGl0QmxvY2spLFxuICAgIFwiTW9kLUVudGVyXCI6IGV4aXRDb2RlLFxuICAgIFwiQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgICBcIk1vZC1CYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICAgIFwiU2hpZnQtQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgICBcIkRlbGV0ZVwiOiBkZWwsXG4gICAgXCJNb2QtRGVsZXRlXCI6IGRlbCxcbiAgICBcIk1vZC1hXCI6IHNlbGVjdEFsbFxufTtcbi8qKlxuQSBjb3B5IG9mIGBwY0Jhc2VLZXltYXBgIHRoYXQgYWxzbyBiaW5kcyAqKkN0cmwtaCoqIGxpa2UgQmFja3NwYWNlLFxuKipDdHJsLWQqKiBsaWtlIERlbGV0ZSwgKipBbHQtQmFja3NwYWNlKiogbGlrZSBDdHJsLUJhY2tzcGFjZSwgYW5kXG4qKkN0cmwtQWx0LUJhY2tzcGFjZSoqLCAqKkFsdC1EZWxldGUqKiwgYW5kICoqQWx0LWQqKiBsaWtlXG5DdHJsLURlbGV0ZS5cbiovXG5jb25zdCBtYWNCYXNlS2V5bWFwID0ge1xuICAgIFwiQ3RybC1oXCI6IHBjQmFzZUtleW1hcFtcIkJhY2tzcGFjZVwiXSxcbiAgICBcIkFsdC1CYWNrc3BhY2VcIjogcGNCYXNlS2V5bWFwW1wiTW9kLUJhY2tzcGFjZVwiXSxcbiAgICBcIkN0cmwtZFwiOiBwY0Jhc2VLZXltYXBbXCJEZWxldGVcIl0sXG4gICAgXCJDdHJsLUFsdC1CYWNrc3BhY2VcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgICBcIkFsdC1EZWxldGVcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgICBcIkFsdC1kXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gICAgXCJDdHJsLWFcIjogc2VsZWN0VGV4dGJsb2NrU3RhcnQsXG4gICAgXCJDdHJsLWVcIjogc2VsZWN0VGV4dGJsb2NrRW5kXG59O1xuZm9yIChsZXQga2V5IGluIHBjQmFzZUtleW1hcClcbiAgICBtYWNCYXNlS2V5bWFwW2tleV0gPSBwY0Jhc2VLZXltYXBba2V5XTtcbmNvbnN0IG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IC9NYWN8aVAoaG9uZXxbb2FdZCkvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICA6IHR5cGVvZiBvcyAhPSBcInVuZGVmaW5lZFwiICYmIG9zLnBsYXRmb3JtID8gb3MucGxhdGZvcm0oKSA9PSBcImRhcndpblwiIDogZmFsc2U7XG4vKipcbkRlcGVuZGluZyBvbiB0aGUgZGV0ZWN0ZWQgcGxhdGZvcm0sIHRoaXMgd2lsbCBob2xkXG5bYHBjQmFzZWtleW1hcGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5wY0Jhc2VLZXltYXApIG9yXG5bYG1hY0Jhc2VLZXltYXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMubWFjQmFzZUtleW1hcCkuXG4qL1xuY29uc3QgYmFzZUtleW1hcCA9IG1hYyA/IG1hY0Jhc2VLZXltYXAgOiBwY0Jhc2VLZXltYXA7XG5cbmV4cG9ydCB7IGF1dG9Kb2luLCBiYXNlS2V5bWFwLCBjaGFpbkNvbW1hbmRzLCBjcmVhdGVQYXJhZ3JhcGhOZWFyLCBkZWxldGVTZWxlY3Rpb24sIGV4aXRDb2RlLCBqb2luQmFja3dhcmQsIGpvaW5Eb3duLCBqb2luRm9yd2FyZCwgam9pblRleHRibG9ja0JhY2t3YXJkLCBqb2luVGV4dGJsb2NrRm9yd2FyZCwgam9pblVwLCBsaWZ0LCBsaWZ0RW1wdHlCbG9jaywgbWFjQmFzZUtleW1hcCwgbmV3bGluZUluQ29kZSwgcGNCYXNlS2V5bWFwLCBzZWxlY3RBbGwsIHNlbGVjdE5vZGVCYWNrd2FyZCwgc2VsZWN0Tm9kZUZvcndhcmQsIHNlbGVjdFBhcmVudE5vZGUsIHNlbGVjdFRleHRibG9ja0VuZCwgc2VsZWN0VGV4dGJsb2NrU3RhcnQsIHNldEJsb2NrVHlwZSwgc3BsaXRCbG9jaywgc3BsaXRCbG9ja0FzLCBzcGxpdEJsb2NrS2VlcE1hcmtzLCB0b2dnbGVNYXJrLCB3cmFwSW4gfTtcbiIsICJpbXBvcnQgeyBmaW5kV3JhcHBpbmcsIFJlcGxhY2VBcm91bmRTdGVwLCBjYW5TcGxpdCwgbGlmdFRhcmdldCwgY2FuSm9pbiB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBOb2RlUmFuZ2UsIEZyYWdtZW50LCBTbGljZSB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcblxuY29uc3Qgb2xET00gPSBbXCJvbFwiLCAwXSwgdWxET00gPSBbXCJ1bFwiLCAwXSwgbGlET00gPSBbXCJsaVwiLCAwXTtcbi8qKlxuQW4gb3JkZXJlZCBsaXN0IFtub2RlIHNwZWNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYykuIEhhcyBhIHNpbmdsZVxuYXR0cmlidXRlLCBgb3JkZXJgLCB3aGljaCBkZXRlcm1pbmVzIHRoZSBudW1iZXIgYXQgd2hpY2ggdGhlIGxpc3RcbnN0YXJ0cyBjb3VudGluZywgYW5kIGRlZmF1bHRzIHRvIDEuIFJlcHJlc2VudGVkIGFzIGFuIGA8b2w+YFxuZWxlbWVudC5cbiovXG5jb25zdCBvcmRlcmVkTGlzdCA9IHtcbiAgICBhdHRyczogeyBvcmRlcjogeyBkZWZhdWx0OiAxIH0gfSxcbiAgICBwYXJzZURPTTogW3sgdGFnOiBcIm9sXCIsIGdldEF0dHJzKGRvbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG9yZGVyOiBkb20uaGFzQXR0cmlidXRlKFwic3RhcnRcIikgPyArZG9tLmdldEF0dHJpYnV0ZShcInN0YXJ0XCIpIDogMSB9O1xuICAgICAgICAgICAgfSB9XSxcbiAgICB0b0RPTShub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmF0dHJzLm9yZGVyID09IDEgPyBvbERPTSA6IFtcIm9sXCIsIHsgc3RhcnQ6IG5vZGUuYXR0cnMub3JkZXIgfSwgMF07XG4gICAgfVxufTtcbi8qKlxuQSBidWxsZXQgbGlzdCBub2RlIHNwZWMsIHJlcHJlc2VudGVkIGluIHRoZSBET00gYXMgYDx1bD5gLlxuKi9cbmNvbnN0IGJ1bGxldExpc3QgPSB7XG4gICAgcGFyc2VET006IFt7IHRhZzogXCJ1bFwiIH1dLFxuICAgIHRvRE9NKCkgeyByZXR1cm4gdWxET007IH1cbn07XG4vKipcbkEgbGlzdCBpdGVtIChgPGxpPmApIHNwZWMuXG4qL1xuY29uc3QgbGlzdEl0ZW0gPSB7XG4gICAgcGFyc2VET006IFt7IHRhZzogXCJsaVwiIH1dLFxuICAgIHRvRE9NKCkgeyByZXR1cm4gbGlET007IH0sXG4gICAgZGVmaW5pbmc6IHRydWVcbn07XG5mdW5jdGlvbiBhZGQob2JqLCBwcm9wcykge1xuICAgIGxldCBjb3B5ID0ge307XG4gICAgZm9yIChsZXQgcHJvcCBpbiBvYmopXG4gICAgICAgIGNvcHlbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcylcbiAgICAgICAgY29weVtwcm9wXSA9IHByb3BzW3Byb3BdO1xuICAgIHJldHVybiBjb3B5O1xufVxuLyoqXG5Db252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgYWRkaW5nIGxpc3QtcmVsYXRlZCBub2RlIHR5cGVzIHRvIGEgbWFwXG5zcGVjaWZ5aW5nIHRoZSBub2RlcyBmb3IgYSBzY2hlbWEuIEFkZHNcbltgb3JkZXJlZExpc3RgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc2NoZW1hLWxpc3Qub3JkZXJlZExpc3QpIGFzIGBcIm9yZGVyZWRfbGlzdFwiYCxcbltgYnVsbGV0TGlzdGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzY2hlbWEtbGlzdC5idWxsZXRMaXN0KSBhcyBgXCJidWxsZXRfbGlzdFwiYCwgYW5kXG5bYGxpc3RJdGVtYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3NjaGVtYS1saXN0Lmxpc3RJdGVtKSBhcyBgXCJsaXN0X2l0ZW1cImAuXG5cbmBpdGVtQ29udGVudGAgZGV0ZXJtaW5lcyB0aGUgY29udGVudCBleHByZXNzaW9uIGZvciB0aGUgbGlzdCBpdGVtcy5cbklmIHlvdSB3YW50IHRoZSBjb21tYW5kcyBkZWZpbmVkIGluIHRoaXMgbW9kdWxlIHRvIGFwcGx5IHRvIHlvdXJcbmxpc3Qgc3RydWN0dXJlLCBpdCBzaG91bGQgaGF2ZSBhIHNoYXBlIGxpa2UgYFwicGFyYWdyYXBoIGJsb2NrKlwiYCBvclxuYFwicGFyYWdyYXBoIChvcmRlcmVkX2xpc3QgfCBidWxsZXRfbGlzdCkqXCJgLiBgbGlzdEdyb3VwYCBjYW4gYmVcbmdpdmVuIHRvIGFzc2lnbiBhIGdyb3VwIG5hbWUgdG8gdGhlIGxpc3Qgbm9kZSB0eXBlcywgZm9yIGV4YW1wbGVcbmBcImJsb2NrXCJgLlxuKi9cbmZ1bmN0aW9uIGFkZExpc3ROb2Rlcyhub2RlcywgaXRlbUNvbnRlbnQsIGxpc3RHcm91cCkge1xuICAgIHJldHVybiBub2Rlcy5hcHBlbmQoe1xuICAgICAgICBvcmRlcmVkX2xpc3Q6IGFkZChvcmRlcmVkTGlzdCwgeyBjb250ZW50OiBcImxpc3RfaXRlbStcIiwgZ3JvdXA6IGxpc3RHcm91cCB9KSxcbiAgICAgICAgYnVsbGV0X2xpc3Q6IGFkZChidWxsZXRMaXN0LCB7IGNvbnRlbnQ6IFwibGlzdF9pdGVtK1wiLCBncm91cDogbGlzdEdyb3VwIH0pLFxuICAgICAgICBsaXN0X2l0ZW06IGFkZChsaXN0SXRlbSwgeyBjb250ZW50OiBpdGVtQ29udGVudCB9KVxuICAgIH0pO1xufVxuLyoqXG5SZXR1cm5zIGEgY29tbWFuZCBmdW5jdGlvbiB0aGF0IHdyYXBzIHRoZSBzZWxlY3Rpb24gaW4gYSBsaXN0IHdpdGhcbnRoZSBnaXZlbiB0eXBlIGFuIGF0dHJpYnV0ZXMuIElmIGBkaXNwYXRjaGAgaXMgbnVsbCwgb25seSByZXR1cm4gYVxudmFsdWUgdG8gaW5kaWNhdGUgd2hldGhlciB0aGlzIGlzIHBvc3NpYmxlLCBidXQgZG9uJ3QgYWN0dWFsbHlcbnBlcmZvcm0gdGhlIGNoYW5nZS5cbiovXG5mdW5jdGlvbiB3cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKSwgZG9Kb2luID0gZmFsc2UsIG91dGVyUmFuZ2UgPSByYW5nZTtcbiAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gVGhpcyBpcyBhdCB0aGUgdG9wIG9mIGFuIGV4aXN0aW5nIGxpc3QgaXRlbVxuICAgICAgICBpZiAocmFuZ2UuZGVwdGggPj0gMiAmJiAkZnJvbS5ub2RlKHJhbmdlLmRlcHRoIC0gMSkudHlwZS5jb21wYXRpYmxlQ29udGVudChsaXN0VHlwZSkgJiYgcmFuZ2Uuc3RhcnRJbmRleCA9PSAwKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGlzIGlzIHRoZSB0b3Agb2YgdGhlIGxpc3RcbiAgICAgICAgICAgIGlmICgkZnJvbS5pbmRleChyYW5nZS5kZXB0aCAtIDEpID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0ICRpbnNlcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShyYW5nZS5zdGFydCAtIDIpO1xuICAgICAgICAgICAgb3V0ZXJSYW5nZSA9IG5ldyBOb2RlUmFuZ2UoJGluc2VydCwgJGluc2VydCwgcmFuZ2UuZGVwdGgpO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmVuZEluZGV4IDwgcmFuZ2UucGFyZW50LmNoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBuZXcgTm9kZVJhbmdlKCRmcm9tLCBzdGF0ZS5kb2MucmVzb2x2ZSgkdG8uZW5kKHJhbmdlLmRlcHRoKSksIHJhbmdlLmRlcHRoKTtcbiAgICAgICAgICAgIGRvSm9pbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdyYXAgPSBmaW5kV3JhcHBpbmcob3V0ZXJSYW5nZSwgbGlzdFR5cGUsIGF0dHJzLCByYW5nZSk7XG4gICAgICAgIGlmICghd3JhcClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goZG9XcmFwSW5MaXN0KHN0YXRlLnRyLCByYW5nZSwgd3JhcCwgZG9Kb2luLCBsaXN0VHlwZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBkb1dyYXBJbkxpc3QodHIsIHJhbmdlLCB3cmFwcGVycywgam9pbkJlZm9yZSwgbGlzdFR5cGUpIHtcbiAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGZvciAobGV0IGkgPSB3cmFwcGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20od3JhcHBlcnNbaV0udHlwZS5jcmVhdGUod3JhcHBlcnNbaV0uYXR0cnMsIGNvbnRlbnQpKTtcbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChyYW5nZS5zdGFydCAtIChqb2luQmVmb3JlID8gMiA6IDApLCByYW5nZS5lbmQsIHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIG5ldyBTbGljZShjb250ZW50LCAwLCAwKSwgd3JhcHBlcnMubGVuZ3RoLCB0cnVlKSk7XG4gICAgbGV0IGZvdW5kID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyYXBwZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAod3JhcHBlcnNbaV0udHlwZSA9PSBsaXN0VHlwZSlcbiAgICAgICAgICAgIGZvdW5kID0gaSArIDE7XG4gICAgbGV0IHNwbGl0RGVwdGggPSB3cmFwcGVycy5sZW5ndGggLSBmb3VuZDtcbiAgICBsZXQgc3BsaXRQb3MgPSByYW5nZS5zdGFydCArIHdyYXBwZXJzLmxlbmd0aCAtIChqb2luQmVmb3JlID8gMiA6IDApLCBwYXJlbnQgPSByYW5nZS5wYXJlbnQ7XG4gICAgZm9yIChsZXQgaSA9IHJhbmdlLnN0YXJ0SW5kZXgsIGUgPSByYW5nZS5lbmRJbmRleCwgZmlyc3QgPSB0cnVlOyBpIDwgZTsgaSsrLCBmaXJzdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghZmlyc3QgJiYgY2FuU3BsaXQodHIuZG9jLCBzcGxpdFBvcywgc3BsaXREZXB0aCkpIHtcbiAgICAgICAgICAgIHRyLnNwbGl0KHNwbGl0UG9zLCBzcGxpdERlcHRoKTtcbiAgICAgICAgICAgIHNwbGl0UG9zICs9IDIgKiBzcGxpdERlcHRoO1xuICAgICAgICB9XG4gICAgICAgIHNwbGl0UG9zICs9IHBhcmVudC5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRyO1xufVxuLyoqXG5CdWlsZCBhIGNvbW1hbmQgdGhhdCBzcGxpdHMgYSBub24tZW1wdHkgdGV4dGJsb2NrIGF0IHRoZSB0b3AgbGV2ZWxcbm9mIGEgbGlzdCBpdGVtIGJ5IGFsc28gc3BsaXR0aW5nIHRoYXQgbGlzdCBpdGVtLlxuKi9cbmZ1bmN0aW9uIHNwbGl0TGlzdEl0ZW0oaXRlbVR5cGUsIGl0ZW1BdHRycykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8sIG5vZGUgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKChub2RlICYmIG5vZGUuaXNCbG9jaykgfHwgJGZyb20uZGVwdGggPCAyIHx8ICEkZnJvbS5zYW1lUGFyZW50KCR0bykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBncmFuZFBhcmVudCA9ICRmcm9tLm5vZGUoLTEpO1xuICAgICAgICBpZiAoZ3JhbmRQYXJlbnQudHlwZSAhPSBpdGVtVHlwZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCRmcm9tLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJiAkZnJvbS5ub2RlKC0xKS5jaGlsZENvdW50ID09ICRmcm9tLmluZGV4QWZ0ZXIoLTEpKSB7XG4gICAgICAgICAgICAvLyBJbiBhbiBlbXB0eSBibG9jay4gSWYgdGhpcyBpcyBhIG5lc3RlZCBsaXN0LCB0aGUgd3JhcHBpbmdcbiAgICAgICAgICAgIC8vIGxpc3QgaXRlbSBzaG91bGQgYmUgc3BsaXQuIE90aGVyd2lzZSwgYmFpbCBvdXQgYW5kIGxldCBuZXh0XG4gICAgICAgICAgICAvLyBjb21tYW5kIGhhbmRsZSBsaWZ0aW5nLlxuICAgICAgICAgICAgaWYgKCRmcm9tLmRlcHRoID09IDMgfHwgJGZyb20ubm9kZSgtMykudHlwZSAhPSBpdGVtVHlwZSB8fFxuICAgICAgICAgICAgICAgICRmcm9tLmluZGV4KC0yKSAhPSAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50IC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgICAgIGxldCBkZXB0aEJlZm9yZSA9ICRmcm9tLmluZGV4KC0xKSA/IDEgOiAkZnJvbS5pbmRleCgtMikgPyAyIDogMztcbiAgICAgICAgICAgICAgICAvLyBCdWlsZCBhIGZyYWdtZW50IGNvbnRhaW5pbmcgZW1wdHkgdmVyc2lvbnMgb2YgdGhlIHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIC8vIGZyb20gdGhlIG91dGVyIGxpc3QgaXRlbSB0byB0aGUgcGFyZW50IG5vZGUgb2YgdGhlIGN1cnNvclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSAkZnJvbS5kZXB0aCAtIGRlcHRoQmVmb3JlOyBkID49ICRmcm9tLmRlcHRoIC0gMzsgZC0tKVxuICAgICAgICAgICAgICAgICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGQpLmNvcHkod3JhcCkpO1xuICAgICAgICAgICAgICAgIGxldCBkZXB0aEFmdGVyID0gJGZyb20uaW5kZXhBZnRlcigtMSkgPCAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50ID8gMVxuICAgICAgICAgICAgICAgICAgICA6ICRmcm9tLmluZGV4QWZ0ZXIoLTIpIDwgJGZyb20ubm9kZSgtMykuY2hpbGRDb3VudCA/IDIgOiAzO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhIHNlY29uZCBsaXN0IGl0ZW0gd2l0aCBhbiBlbXB0eSBkZWZhdWx0IHN0YXJ0IG5vZGVcbiAgICAgICAgICAgICAgICB3cmFwID0gd3JhcC5hcHBlbmQoRnJhZ21lbnQuZnJvbShpdGVtVHlwZS5jcmVhdGVBbmRGaWxsKCkpKTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSAkZnJvbS5iZWZvcmUoJGZyb20uZGVwdGggLSAoZGVwdGhCZWZvcmUgLSAxKSk7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIucmVwbGFjZShzdGFydCwgJGZyb20uYWZ0ZXIoLWRlcHRoQWZ0ZXIpLCBuZXcgU2xpY2Uod3JhcCwgNCAtIGRlcHRoQmVmb3JlLCAwKSk7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IC0xO1xuICAgICAgICAgICAgICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oc3RhcnQsIHRyLmRvYy5jb250ZW50LnNpemUsIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pc1RleHRibG9jayAmJiBub2RlLmNvbnRlbnQuc2l6ZSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShzZWwpKSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFR5cGUgPSAkdG8ucG9zID09ICRmcm9tLmVuZCgpID8gZ3JhbmRQYXJlbnQuY29udGVudE1hdGNoQXQoMCkuZGVmYXVsdFR5cGUgOiBudWxsO1xuICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5kZWxldGUoJGZyb20ucG9zLCAkdG8ucG9zKTtcbiAgICAgICAgbGV0IHR5cGVzID0gbmV4dFR5cGUgPyBbaXRlbUF0dHJzID8geyB0eXBlOiBpdGVtVHlwZSwgYXR0cnM6IGl0ZW1BdHRycyB9IDogbnVsbCwgeyB0eXBlOiBuZXh0VHlwZSB9XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFjYW5TcGxpdCh0ci5kb2MsICRmcm9tLnBvcywgMiwgdHlwZXMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zcGxpdCgkZnJvbS5wb3MsIDIsIHR5cGVzKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuQ3JlYXRlIGEgY29tbWFuZCB0byBsaWZ0IHRoZSBsaXN0IGl0ZW0gYXJvdW5kIHRoZSBzZWxlY3Rpb24gdXAgaW50b1xuYSB3cmFwcGluZyBsaXN0LlxuKi9cbmZ1bmN0aW9uIGxpZnRMaXN0SXRlbShpdGVtVHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8sIG5vZGUgPT4gbm9kZS5jaGlsZENvdW50ID4gMCAmJiBub2RlLmZpcnN0Q2hpbGQudHlwZSA9PSBpdGVtVHlwZSk7XG4gICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghZGlzcGF0Y2gpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCRmcm9tLm5vZGUocmFuZ2UuZGVwdGggLSAxKS50eXBlID09IGl0ZW1UeXBlKSAvLyBJbnNpZGUgYSBwYXJlbnQgbGlzdFxuICAgICAgICAgICAgcmV0dXJuIGxpZnRUb091dGVyTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIGl0ZW1UeXBlLCByYW5nZSk7XG4gICAgICAgIGVsc2UgLy8gT3V0ZXIgbGlzdCBub2RlXG4gICAgICAgICAgICByZXR1cm4gbGlmdE91dE9mTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIHJhbmdlKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbGlmdFRvT3V0ZXJMaXN0KHN0YXRlLCBkaXNwYXRjaCwgaXRlbVR5cGUsIHJhbmdlKSB7XG4gICAgbGV0IHRyID0gc3RhdGUudHIsIGVuZCA9IHJhbmdlLmVuZCwgZW5kT2ZMaXN0ID0gcmFuZ2UuJHRvLmVuZChyYW5nZS5kZXB0aCk7XG4gICAgaWYgKGVuZCA8IGVuZE9mTGlzdCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgc2libGluZ3MgYWZ0ZXIgdGhlIGxpZnRlZCBpdGVtcywgd2hpY2ggbXVzdCBiZWNvbWVcbiAgICAgICAgLy8gY2hpbGRyZW4gb2YgdGhlIGxhc3QgaXRlbVxuICAgICAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChlbmQgLSAxLCBlbmRPZkxpc3QsIGVuZCwgZW5kT2ZMaXN0LCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShpdGVtVHlwZS5jcmVhdGUobnVsbCwgcmFuZ2UucGFyZW50LmNvcHkoKSkpLCAxLCAwKSwgMSwgdHJ1ZSkpO1xuICAgICAgICByYW5nZSA9IG5ldyBOb2RlUmFuZ2UodHIuZG9jLnJlc29sdmUocmFuZ2UuJGZyb20ucG9zKSwgdHIuZG9jLnJlc29sdmUoZW5kT2ZMaXN0KSwgcmFuZ2UuZGVwdGgpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0ci5saWZ0KHJhbmdlLCB0YXJnZXQpO1xuICAgIGxldCBhZnRlciA9IHRyLm1hcHBpbmcubWFwKGVuZCwgLTEpIC0gMTtcbiAgICBpZiAoY2FuSm9pbih0ci5kb2MsIGFmdGVyKSlcbiAgICAgICAgdHIuam9pbihhZnRlcik7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBsaWZ0T3V0T2ZMaXN0KHN0YXRlLCBkaXNwYXRjaCwgcmFuZ2UpIHtcbiAgICBsZXQgdHIgPSBzdGF0ZS50ciwgbGlzdCA9IHJhbmdlLnBhcmVudDtcbiAgICAvLyBNZXJnZSB0aGUgbGlzdCBpdGVtcyBpbnRvIGEgc2luZ2xlIGJpZyBpdGVtXG4gICAgZm9yIChsZXQgcG9zID0gcmFuZ2UuZW5kLCBpID0gcmFuZ2UuZW5kSW5kZXggLSAxLCBlID0gcmFuZ2Uuc3RhcnRJbmRleDsgaSA+IGU7IGktLSkge1xuICAgICAgICBwb3MgLT0gbGlzdC5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICAgICAgdHIuZGVsZXRlKHBvcyAtIDEsIHBvcyArIDEpO1xuICAgIH1cbiAgICBsZXQgJHN0YXJ0ID0gdHIuZG9jLnJlc29sdmUocmFuZ2Uuc3RhcnQpLCBpdGVtID0gJHN0YXJ0Lm5vZGVBZnRlcjtcbiAgICBpZiAodHIubWFwcGluZy5tYXAocmFuZ2UuZW5kKSAhPSByYW5nZS5zdGFydCArICRzdGFydC5ub2RlQWZ0ZXIubm9kZVNpemUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYXRTdGFydCA9IHJhbmdlLnN0YXJ0SW5kZXggPT0gMCwgYXRFbmQgPSByYW5nZS5lbmRJbmRleCA9PSBsaXN0LmNoaWxkQ291bnQ7XG4gICAgbGV0IHBhcmVudCA9ICRzdGFydC5ub2RlKC0xKSwgaW5kZXhCZWZvcmUgPSAkc3RhcnQuaW5kZXgoLTEpO1xuICAgIGlmICghcGFyZW50LmNhblJlcGxhY2UoaW5kZXhCZWZvcmUgKyAoYXRTdGFydCA/IDAgOiAxKSwgaW5kZXhCZWZvcmUgKyAxLCBpdGVtLmNvbnRlbnQuYXBwZW5kKGF0RW5kID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QpKSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc3RhcnQgPSAkc3RhcnQucG9zLCBlbmQgPSBzdGFydCArIGl0ZW0ubm9kZVNpemU7XG4gICAgLy8gU3RyaXAgb2ZmIHRoZSBzdXJyb3VuZGluZyBsaXN0LiBBdCB0aGUgc2lkZXMgd2hlcmUgd2UncmUgbm90IGF0XG4gICAgLy8gdGhlIGVuZCBvZiB0aGUgbGlzdCwgdGhlIGV4aXN0aW5nIGxpc3QgaXMgY2xvc2VkLiBBdCBzaWRlcyB3aGVyZVxuICAgIC8vIHRoaXMgaXMgdGhlIGVuZCwgaXQgaXMgb3ZlcndyaXR0ZW4gdG8gaXRzIGVuZC5cbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCAtIChhdFN0YXJ0ID8gMSA6IDApLCBlbmQgKyAoYXRFbmQgPyAxIDogMCksIHN0YXJ0ICsgMSwgZW5kIC0gMSwgbmV3IFNsaWNlKChhdFN0YXJ0ID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QuY29weShGcmFnbWVudC5lbXB0eSkpKVxuICAgICAgICAuYXBwZW5kKGF0RW5kID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QuY29weShGcmFnbWVudC5lbXB0eSkpKSwgYXRTdGFydCA/IDAgOiAxLCBhdEVuZCA/IDAgOiAxKSwgYXRTdGFydCA/IDAgOiAxKSk7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbkNyZWF0ZSBhIGNvbW1hbmQgdG8gc2luayB0aGUgbGlzdCBpdGVtIGFyb3VuZCB0aGUgc2VsZWN0aW9uIGRvd25cbmludG8gYW4gaW5uZXIgbGlzdC5cbiovXG5mdW5jdGlvbiBzaW5rTGlzdEl0ZW0oaXRlbVR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBub2RlID0+IG5vZGUuY2hpbGRDb3VudCA+IDAgJiYgbm9kZS5maXJzdENoaWxkLnR5cGUgPT0gaXRlbVR5cGUpO1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHJhbmdlLnN0YXJ0SW5kZXg7XG4gICAgICAgIGlmIChzdGFydEluZGV4ID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBwYXJlbnQgPSByYW5nZS5wYXJlbnQsIG5vZGVCZWZvcmUgPSBwYXJlbnQuY2hpbGQoc3RhcnRJbmRleCAtIDEpO1xuICAgICAgICBpZiAobm9kZUJlZm9yZS50eXBlICE9IGl0ZW1UeXBlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBuZXN0ZWRCZWZvcmUgPSBub2RlQmVmb3JlLmxhc3RDaGlsZCAmJiBub2RlQmVmb3JlLmxhc3RDaGlsZC50eXBlID09IHBhcmVudC50eXBlO1xuICAgICAgICAgICAgbGV0IGlubmVyID0gRnJhZ21lbnQuZnJvbShuZXN0ZWRCZWZvcmUgPyBpdGVtVHlwZS5jcmVhdGUoKSA6IG51bGwpO1xuICAgICAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlKG51bGwsIEZyYWdtZW50LmZyb20ocGFyZW50LnR5cGUuY3JlYXRlKG51bGwsIGlubmVyKSkpKSwgbmVzdGVkQmVmb3JlID8gMyA6IDEsIDApO1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHJhbmdlLnN0YXJ0LCBhZnRlciA9IHJhbmdlLmVuZDtcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKGJlZm9yZSAtIChuZXN0ZWRCZWZvcmUgPyAzIDogMSksIGFmdGVyLCBiZWZvcmUsIGFmdGVyLCBzbGljZSwgMSwgdHJ1ZSkpXG4gICAgICAgICAgICAgICAgLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5cbmV4cG9ydCB7IGFkZExpc3ROb2RlcywgYnVsbGV0TGlzdCwgbGlmdExpc3RJdGVtLCBsaXN0SXRlbSwgb3JkZXJlZExpc3QsIHNpbmtMaXN0SXRlbSwgc3BsaXRMaXN0SXRlbSwgd3JhcEluTGlzdCB9O1xuIiwgImltcG9ydCB7IEVkaXRvclN0YXRlLCBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVTdGF0ZShjb25maWc6IHtcbiAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZVxufSk6IEVkaXRvclN0YXRlIHtcbiAgY29uc3QgeyBzdGF0ZSwgdHJhbnNhY3Rpb24gfSA9IGNvbmZpZ1xuICBsZXQgeyBzZWxlY3Rpb24gfSA9IHRyYW5zYWN0aW9uXG4gIGxldCB7IGRvYyB9ID0gdHJhbnNhY3Rpb25cbiAgbGV0IHsgc3RvcmVkTWFya3MgfSA9IHRyYW5zYWN0aW9uXG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBhcHBseTogc3RhdGUuYXBwbHkuYmluZChzdGF0ZSksXG4gICAgYXBwbHlUcmFuc2FjdGlvbjogc3RhdGUuYXBwbHlUcmFuc2FjdGlvbi5iaW5kKHN0YXRlKSxcbiAgICBmaWx0ZXJUcmFuc2FjdGlvbjogc3RhdGUuZmlsdGVyVHJhbnNhY3Rpb24sXG4gICAgcGx1Z2luczogc3RhdGUucGx1Z2lucyxcbiAgICBzY2hlbWE6IHN0YXRlLnNjaGVtYSxcbiAgICByZWNvbmZpZ3VyZTogc3RhdGUucmVjb25maWd1cmUuYmluZChzdGF0ZSksXG4gICAgdG9KU09OOiBzdGF0ZS50b0pTT04uYmluZChzdGF0ZSksXG4gICAgZ2V0IHN0b3JlZE1hcmtzKCkge1xuICAgICAgcmV0dXJuIHN0b3JlZE1hcmtzXG4gICAgfSxcbiAgICBnZXQgc2VsZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNlbGVjdGlvblxuICAgIH0sXG4gICAgZ2V0IGRvYygpIHtcbiAgICAgIHJldHVybiBkb2NcbiAgICB9LFxuICAgIGdldCB0cigpIHtcbiAgICAgIHNlbGVjdGlvbiA9IHRyYW5zYWN0aW9uLnNlbGVjdGlvblxuICAgICAgZG9jID0gdHJhbnNhY3Rpb24uZG9jXG4gICAgICBzdG9yZWRNYXJrcyA9IHRyYW5zYWN0aW9uLnN0b3JlZE1hcmtzXG5cbiAgICAgIHJldHVybiB0cmFuc2FjdGlvblxuICAgIH0sXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBFZGl0b3JTdGF0ZSwgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB7IGNyZWF0ZUNoYWluYWJsZVN0YXRlIH0gZnJvbSAnLi9oZWxwZXJzL2NyZWF0ZUNoYWluYWJsZVN0YXRlLmpzJ1xuaW1wb3J0IHtcbiAgQW55Q29tbWFuZHMsIENhbkNvbW1hbmRzLCBDaGFpbmVkQ29tbWFuZHMsIENvbW1hbmRQcm9wcywgU2luZ2xlQ29tbWFuZHMsXG59IGZyb20gJy4vdHlwZXMuanMnXG5cbmV4cG9ydCBjbGFzcyBDb21tYW5kTWFuYWdlciB7XG4gIGVkaXRvcjogRWRpdG9yXG5cbiAgcmF3Q29tbWFuZHM6IEFueUNvbW1hbmRzXG5cbiAgY3VzdG9tU3RhdGU/OiBFZGl0b3JTdGF0ZVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiB7IGVkaXRvcjogRWRpdG9yOyBzdGF0ZT86IEVkaXRvclN0YXRlIH0pIHtcbiAgICB0aGlzLmVkaXRvciA9IHByb3BzLmVkaXRvclxuICAgIHRoaXMucmF3Q29tbWFuZHMgPSB0aGlzLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmNvbW1hbmRzXG4gICAgdGhpcy5jdXN0b21TdGF0ZSA9IHByb3BzLnN0YXRlXG4gIH1cblxuICBnZXQgaGFzQ3VzdG9tU3RhdGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5jdXN0b21TdGF0ZVxuICB9XG5cbiAgZ2V0IHN0YXRlKCk6IEVkaXRvclN0YXRlIHtcbiAgICByZXR1cm4gdGhpcy5jdXN0b21TdGF0ZSB8fCB0aGlzLmVkaXRvci5zdGF0ZVxuICB9XG5cbiAgZ2V0IGNvbW1hbmRzKCk6IFNpbmdsZUNvbW1hbmRzIHtcbiAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzXG4gICAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3JcbiAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZVxuICAgIGNvbnN0IHByb3BzID0gdGhpcy5idWlsZFByb3BzKHRyKVxuXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kXSkgPT4ge1xuICAgICAgICBjb25zdCBtZXRob2QgPSAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGNvbW1hbmQoLi4uYXJncykocHJvcHMpXG5cbiAgICAgICAgICBpZiAoIXRyLmdldE1ldGEoJ3ByZXZlbnREaXNwYXRjaCcpICYmICF0aGlzLmhhc0N1c3RvbVN0YXRlKSB7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjYWxsYmFja1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtuYW1lLCBtZXRob2RdXG4gICAgICB9KSxcbiAgICApIGFzIHVua25vd24gYXMgU2luZ2xlQ29tbWFuZHNcbiAgfVxuXG4gIGdldCBjaGFpbigpOiAoKSA9PiBDaGFpbmVkQ29tbWFuZHMge1xuICAgIHJldHVybiAoKSA9PiB0aGlzLmNyZWF0ZUNoYWluKClcbiAgfVxuXG4gIGdldCBjYW4oKTogKCkgPT4gQ2FuQ29tbWFuZHMge1xuICAgIHJldHVybiAoKSA9PiB0aGlzLmNyZWF0ZUNhbigpXG4gIH1cblxuICBwdWJsaWMgY3JlYXRlQ2hhaW4oc3RhcnRUcj86IFRyYW5zYWN0aW9uLCBzaG91bGREaXNwYXRjaCA9IHRydWUpOiBDaGFpbmVkQ29tbWFuZHMge1xuICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXNcbiAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvclxuICAgIGNvbnN0IGNhbGxiYWNrczogYm9vbGVhbltdID0gW11cbiAgICBjb25zdCBoYXNTdGFydFRyYW5zYWN0aW9uID0gISFzdGFydFRyXG4gICAgY29uc3QgdHIgPSBzdGFydFRyIHx8IHN0YXRlLnRyXG5cbiAgICBjb25zdCBydW4gPSAoKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgICFoYXNTdGFydFRyYW5zYWN0aW9uXG4gICAgICAgICYmIHNob3VsZERpc3BhdGNoXG4gICAgICAgICYmICF0ci5nZXRNZXRhKCdwcmV2ZW50RGlzcGF0Y2gnKVxuICAgICAgICAmJiAhdGhpcy5oYXNDdXN0b21TdGF0ZVxuICAgICAgKSB7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2godHIpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxsYmFja3MuZXZlcnkoY2FsbGJhY2sgPT4gY2FsbGJhY2sgPT09IHRydWUpXG4gICAgfVxuXG4gICAgY29uc3QgY2hhaW4gPSB7XG4gICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNoYWluZWRDb21tYW5kID0gKC4uLmFyZ3M6IG5ldmVyW10pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5idWlsZFByb3BzKHRyLCBzaG91bGREaXNwYXRjaClcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gY29tbWFuZCguLi5hcmdzKShwcm9wcylcblxuICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spXG5cbiAgICAgICAgICAgIHJldHVybiBjaGFpblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbbmFtZSwgY2hhaW5lZENvbW1hbmRdXG4gICAgICAgIH0pLFxuICAgICAgKSxcbiAgICAgIHJ1bixcbiAgICB9IGFzIHVua25vd24gYXMgQ2hhaW5lZENvbW1hbmRzXG5cbiAgICByZXR1cm4gY2hhaW5cbiAgfVxuXG4gIHB1YmxpYyBjcmVhdGVDYW4oc3RhcnRUcj86IFRyYW5zYWN0aW9uKTogQ2FuQ29tbWFuZHMge1xuICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIHN0YXRlIH0gPSB0aGlzXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBmYWxzZVxuICAgIGNvbnN0IHRyID0gc3RhcnRUciB8fCBzdGF0ZS50clxuICAgIGNvbnN0IHByb3BzID0gdGhpcy5idWlsZFByb3BzKHRyLCBkaXNwYXRjaClcbiAgICBjb25zdCBmb3JtYXR0ZWRDb21tYW5kcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kXSkgPT4ge1xuICAgICAgICByZXR1cm4gW25hbWUsICguLi5hcmdzOiBuZXZlcltdKSA9PiBjb21tYW5kKC4uLmFyZ3MpKHsgLi4ucHJvcHMsIGRpc3BhdGNoOiB1bmRlZmluZWQgfSldXG4gICAgICB9KSxcbiAgICApIGFzIHVua25vd24gYXMgU2luZ2xlQ29tbWFuZHNcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5mb3JtYXR0ZWRDb21tYW5kcyxcbiAgICAgIGNoYWluOiAoKSA9PiB0aGlzLmNyZWF0ZUNoYWluKHRyLCBkaXNwYXRjaCksXG4gICAgfSBhcyBDYW5Db21tYW5kc1xuICB9XG5cbiAgcHVibGljIGJ1aWxkUHJvcHModHI6IFRyYW5zYWN0aW9uLCBzaG91bGREaXNwYXRjaCA9IHRydWUpOiBDb21tYW5kUHJvcHMge1xuICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXNcbiAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvclxuXG4gICAgY29uc3QgcHJvcHM6IENvbW1hbmRQcm9wcyA9IHtcbiAgICAgIHRyLFxuICAgICAgZWRpdG9yLFxuICAgICAgdmlldyxcbiAgICAgIHN0YXRlOiBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgICB9KSxcbiAgICAgIGRpc3BhdGNoOiBzaG91bGREaXNwYXRjaCA/ICgpID0+IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCxcbiAgICAgIGNoYWluOiAoKSA9PiB0aGlzLmNyZWF0ZUNoYWluKHRyLCBzaG91bGREaXNwYXRjaCksXG4gICAgICBjYW46ICgpID0+IHRoaXMuY3JlYXRlQ2FuKHRyKSxcbiAgICAgIGdldCBjb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbbmFtZSwgKC4uLmFyZ3M6IG5ldmVyW10pID0+IGNvbW1hbmQoLi4uYXJncykocHJvcHMpXVxuICAgICAgICAgIH0pLFxuICAgICAgICApIGFzIHVua25vd24gYXMgU2luZ2xlQ29tbWFuZHNcbiAgICAgIH0sXG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzXG4gIH1cbn1cbiIsICJ0eXBlIFN0cmluZ0tleU9mPFQ+ID0gRXh0cmFjdDxrZXlvZiBULCBzdHJpbmc+XG50eXBlIENhbGxiYWNrVHlwZTxcbiAgVCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIEV2ZW50TmFtZSBleHRlbmRzIFN0cmluZ0tleU9mPFQ+LFxuPiA9IFRbRXZlbnROYW1lXSBleHRlbmRzIGFueVtdID8gVFtFdmVudE5hbWVdIDogW1RbRXZlbnROYW1lXV1cbnR5cGUgQ2FsbGJhY2tGdW5jdGlvbjxcbiAgVCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIEV2ZW50TmFtZSBleHRlbmRzIFN0cmluZ0tleU9mPFQ+LFxuPiA9ICguLi5wcm9wczogQ2FsbGJhY2tUeXBlPFQsIEV2ZW50TmFtZT4pID0+IGFueVxuXG5leHBvcnQgY2xhc3MgRXZlbnRFbWl0dGVyPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+PiB7XG5cbiAgcHJpdmF0ZSBjYWxsYmFja3M6IHsgW2tleTogc3RyaW5nXTogRnVuY3Rpb25bXSB9ID0ge31cblxuICBwdWJsaWMgb248RXZlbnROYW1lIGV4dGVuZHMgU3RyaW5nS2V5T2Y8VD4+KGV2ZW50OiBFdmVudE5hbWUsIGZuOiBDYWxsYmFja0Z1bmN0aW9uPFQsIEV2ZW50TmFtZT4pOiB0aGlzIHtcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW2V2ZW50XSkge1xuICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdID0gW11cbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0ucHVzaChmbilcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcm90ZWN0ZWQgZW1pdDxFdmVudE5hbWUgZXh0ZW5kcyBTdHJpbmdLZXlPZjxUPj4oZXZlbnQ6IEV2ZW50TmFtZSwgLi4uYXJnczogQ2FsbGJhY2tUeXBlPFQsIEV2ZW50TmFtZT4pOiB0aGlzIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF1cblxuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgb2ZmPEV2ZW50TmFtZSBleHRlbmRzIFN0cmluZ0tleU9mPFQ+PihldmVudDogRXZlbnROYW1lLCBmbj86IENhbGxiYWNrRnVuY3Rpb248VCwgRXZlbnROYW1lPik6IHRoaXMge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzW2V2ZW50XVxuXG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IGNhbGxiYWNrcy5maWx0ZXIoY2FsbGJhY2sgPT4gY2FsbGJhY2sgIT09IGZuKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tzW2V2ZW50XVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcm90ZWN0ZWQgcmVtb3ZlQWxsTGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIHRoaXMuY2FsbGJhY2tzID0ge31cbiAgfVxufVxuIiwgImltcG9ydCB7IEFueUV4dGVuc2lvbiwgTWF5YmVUaGlzUGFyYW1ldGVyVHlwZSwgUmVtb3ZlVGhpcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uRmllbGQ8VCA9IGFueT4oXG4gIGV4dGVuc2lvbjogQW55RXh0ZW5zaW9uLFxuICBmaWVsZDogc3RyaW5nLFxuICBjb250ZXh0PzogT21pdDxNYXliZVRoaXNQYXJhbWV0ZXJUeXBlPFQ+LCAncGFyZW50Jz4sXG4pOiBSZW1vdmVUaGlzPFQ+IHtcblxuICBpZiAoZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF0gPT09IHVuZGVmaW5lZCAmJiBleHRlbnNpb24ucGFyZW50KSB7XG4gICAgcmV0dXJuIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbi5wYXJlbnQsIGZpZWxkLCBjb250ZXh0KVxuICB9XG5cbiAgaWYgKHR5cGVvZiBleHRlbnNpb24uY29uZmlnW2ZpZWxkXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IHZhbHVlID0gZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF0uYmluZCh7XG4gICAgICAuLi5jb250ZXh0LFxuICAgICAgcGFyZW50OiBleHRlbnNpb24ucGFyZW50XG4gICAgICAgID8gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLnBhcmVudCwgZmllbGQsIGNvbnRleHQpXG4gICAgICAgIDogbnVsbCxcbiAgICB9KVxuXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICByZXR1cm4gZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF1cbn1cbiIsICJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5pbXBvcnQgeyBNYXJrIH0gZnJvbSAnLi4vTWFyay5qcydcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuLi9Ob2RlLmpzJ1xuaW1wb3J0IHsgRXh0ZW5zaW9ucyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpIHtcbiAgY29uc3QgYmFzZUV4dGVuc2lvbnMgPSBleHRlbnNpb25zLmZpbHRlcihleHRlbnNpb24gPT4gZXh0ZW5zaW9uLnR5cGUgPT09ICdleHRlbnNpb24nKSBhcyBFeHRlbnNpb25bXVxuICBjb25zdCBub2RlRXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMuZmlsdGVyKGV4dGVuc2lvbiA9PiBleHRlbnNpb24udHlwZSA9PT0gJ25vZGUnKSBhcyBOb2RlW11cbiAgY29uc3QgbWFya0V4dGVuc2lvbnMgPSBleHRlbnNpb25zLmZpbHRlcihleHRlbnNpb24gPT4gZXh0ZW5zaW9uLnR5cGUgPT09ICdtYXJrJykgYXMgTWFya1tdXG5cbiAgcmV0dXJuIHtcbiAgICBiYXNlRXh0ZW5zaW9ucyxcbiAgICBub2RlRXh0ZW5zaW9ucyxcbiAgICBtYXJrRXh0ZW5zaW9ucyxcbiAgfVxufVxuIiwgImltcG9ydCB7IE1hcmtDb25maWcsIE5vZGVDb25maWcgfSBmcm9tICcuLi9pbmRleC5qcydcbmltcG9ydCB7XG4gIEFueUNvbmZpZyxcbiAgQXR0cmlidXRlLFxuICBBdHRyaWJ1dGVzLFxuICBFeHRlbnNpb25BdHRyaWJ1dGUsXG4gIEV4dGVuc2lvbnMsXG4gIEdsb2JhbEF0dHJpYnV0ZXMsXG59IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZ2V0RXh0ZW5zaW9uRmllbGQgfSBmcm9tICcuL2dldEV4dGVuc2lvbkZpZWxkLmpzJ1xuaW1wb3J0IHsgc3BsaXRFeHRlbnNpb25zIH0gZnJvbSAnLi9zcGxpdEV4dGVuc2lvbnMuanMnXG5cbi8qKlxuICogR2V0IGEgbGlzdCBvZiBhbGwgZXh0ZW5zaW9uIGF0dHJpYnV0ZXMgZGVmaW5lZCBpbiBgYWRkQXR0cmlidXRlYCBhbmQgYGFkZEdsb2JhbEF0dHJpYnV0ZWAuXG4gKiBAcGFyYW0gZXh0ZW5zaW9ucyBMaXN0IG9mIGV4dGVuc2lvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyhleHRlbnNpb25zOiBFeHRlbnNpb25zKTogRXh0ZW5zaW9uQXR0cmlidXRlW10ge1xuICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzOiBFeHRlbnNpb25BdHRyaWJ1dGVbXSA9IFtdXG4gIGNvbnN0IHsgbm9kZUV4dGVuc2lvbnMsIG1hcmtFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnMoZXh0ZW5zaW9ucylcbiAgY29uc3Qgbm9kZUFuZE1hcmtFeHRlbnNpb25zID0gWy4uLm5vZGVFeHRlbnNpb25zLCAuLi5tYXJrRXh0ZW5zaW9uc11cbiAgY29uc3QgZGVmYXVsdEF0dHJpYnV0ZTogUmVxdWlyZWQ8QXR0cmlidXRlPiA9IHtcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIHJlbmRlcmVkOiB0cnVlLFxuICAgIHJlbmRlckhUTUw6IG51bGwsXG4gICAgcGFyc2VIVE1MOiBudWxsLFxuICAgIGtlZXBPblNwbGl0OiB0cnVlLFxuICAgIGlzUmVxdWlyZWQ6IGZhbHNlLFxuICB9XG5cbiAgZXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICB9XG5cbiAgICBjb25zdCBhZGRHbG9iYWxBdHRyaWJ1dGVzID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRHbG9iYWxBdHRyaWJ1dGVzJ10+KFxuICAgICAgZXh0ZW5zaW9uLFxuICAgICAgJ2FkZEdsb2JhbEF0dHJpYnV0ZXMnLFxuICAgICAgY29udGV4dCxcbiAgICApXG5cbiAgICBpZiAoIWFkZEdsb2JhbEF0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSBgYXMgR2xvYmFsQXR0cmlidXRlc2BcbiAgICBjb25zdCBnbG9iYWxBdHRyaWJ1dGVzID0gYWRkR2xvYmFsQXR0cmlidXRlcygpIGFzIEdsb2JhbEF0dHJpYnV0ZXNcblxuICAgIGdsb2JhbEF0dHJpYnV0ZXMuZm9yRWFjaChnbG9iYWxBdHRyaWJ1dGUgPT4ge1xuICAgICAgZ2xvYmFsQXR0cmlidXRlLnR5cGVzLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAgIE9iamVjdFxuICAgICAgICAgIC5lbnRyaWVzKGdsb2JhbEF0dHJpYnV0ZS5hdHRyaWJ1dGVzKVxuICAgICAgICAgIC5mb3JFYWNoKChbbmFtZSwgYXR0cmlidXRlXSkgPT4ge1xuICAgICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlOiB7XG4gICAgICAgICAgICAgICAgLi4uZGVmYXVsdEF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGUsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG5cbiAgbm9kZUFuZE1hcmtFeHRlbnNpb25zLmZvckVhY2goZXh0ZW5zaW9uID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgIH1cblxuICAgIGNvbnN0IGFkZEF0dHJpYnV0ZXMgPSBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydhZGRBdHRyaWJ1dGVzJ10gfCBNYXJrQ29uZmlnWydhZGRBdHRyaWJ1dGVzJ10+KFxuICAgICAgZXh0ZW5zaW9uLFxuICAgICAgJ2FkZEF0dHJpYnV0ZXMnLFxuICAgICAgY29udGV4dCxcbiAgICApXG5cbiAgICBpZiAoIWFkZEF0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSBgYXMgQXR0cmlidXRlc2BcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gYWRkQXR0cmlidXRlcygpIGFzIEF0dHJpYnV0ZXNcblxuICAgIE9iamVjdFxuICAgICAgLmVudHJpZXMoYXR0cmlidXRlcylcbiAgICAgIC5mb3JFYWNoKChbbmFtZSwgYXR0cmlidXRlXSkgPT4ge1xuICAgICAgICBjb25zdCBtZXJnZWRBdHRyID0ge1xuICAgICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGUsXG4gICAgICAgICAgLi4uYXR0cmlidXRlLFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXJnZWRBdHRyPy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbWVyZ2VkQXR0ci5kZWZhdWx0ID0gbWVyZ2VkQXR0ci5kZWZhdWx0KClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXJnZWRBdHRyPy5pc1JlcXVpcmVkICYmIG1lcmdlZEF0dHI/LmRlZmF1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlbGV0ZSBtZXJnZWRBdHRyLmRlZmF1bHRcbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBhdHRyaWJ1dGU6IG1lcmdlZEF0dHIsXG4gICAgICAgIH0pXG4gICAgICB9KVxuICB9KVxuXG4gIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGVzXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlVHlwZShuYW1lT3JUeXBlOiBzdHJpbmcgfCBOb2RlVHlwZSwgc2NoZW1hOiBTY2hlbWEpOiBOb2RlVHlwZSB7XG4gIGlmICh0eXBlb2YgbmFtZU9yVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIXNjaGVtYS5ub2Rlc1tuYW1lT3JUeXBlXSkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBUaGVyZSBpcyBubyBub2RlIHR5cGUgbmFtZWQgJyR7bmFtZU9yVHlwZX0nLiBNYXliZSB5b3UgZm9yZ290IHRvIGFkZCB0aGUgZXh0ZW5zaW9uP2AsXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYS5ub2Rlc1tuYW1lT3JUeXBlXVxuICB9XG5cbiAgcmV0dXJuIG5hbWVPclR5cGVcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gbWVyZ2VBdHRyaWJ1dGVzKC4uLm9iamVjdHM6IFJlY29yZDxzdHJpbmcsIGFueT5bXSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICByZXR1cm4gb2JqZWN0c1xuICAgIC5maWx0ZXIoaXRlbSA9PiAhIWl0ZW0pXG4gICAgLnJlZHVjZSgoaXRlbXMsIGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IG1lcmdlZEF0dHJpYnV0ZXMgPSB7IC4uLml0ZW1zIH1cblxuICAgICAgT2JqZWN0LmVudHJpZXMoaXRlbSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IG1lcmdlZEF0dHJpYnV0ZXNba2V5XVxuXG4gICAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gdmFsdWVcblxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlQ2xhc3Nlczogc3RyaW5nW10gPSB2YWx1ZSA/IHZhbHVlLnNwbGl0KCcgJykgOiBbXVxuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nQ2xhc3Nlczogc3RyaW5nW10gPSBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPyBtZXJnZWRBdHRyaWJ1dGVzW2tleV0uc3BsaXQoJyAnKSA6IFtdXG5cbiAgICAgICAgICBjb25zdCBpbnNlcnRDbGFzc2VzID0gdmFsdWVDbGFzc2VzLmZpbHRlcihcbiAgICAgICAgICAgIHZhbHVlQ2xhc3MgPT4gIWV4aXN0aW5nQ2xhc3Nlcy5pbmNsdWRlcyh2YWx1ZUNsYXNzKSxcbiAgICAgICAgICApXG5cbiAgICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSBbLi4uZXhpc3RpbmdDbGFzc2VzLCAuLi5pbnNlcnRDbGFzc2VzXS5qb2luKCcgJylcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSBbbWVyZ2VkQXR0cmlidXRlc1trZXldLCB2YWx1ZV0uam9pbignOyAnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiBtZXJnZWRBdHRyaWJ1dGVzXG4gICAgfSwge30pXG59XG4iLCAiaW1wb3J0IHsgTWFyaywgTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IEV4dGVuc2lvbkF0dHJpYnV0ZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vdXRpbGl0aWVzL21lcmdlQXR0cmlidXRlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbmRlcmVkQXR0cmlidXRlcyhcbiAgbm9kZU9yTWFyazogTm9kZSB8IE1hcmssXG4gIGV4dGVuc2lvbkF0dHJpYnV0ZXM6IEV4dGVuc2lvbkF0dHJpYnV0ZVtdLFxuKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGVzXG4gICAgLmZpbHRlcihpdGVtID0+IGl0ZW0uYXR0cmlidXRlLnJlbmRlcmVkKVxuICAgIC5tYXAoaXRlbSA9PiB7XG4gICAgICBpZiAoIWl0ZW0uYXR0cmlidXRlLnJlbmRlckhUTUwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBbaXRlbS5uYW1lXTogbm9kZU9yTWFyay5hdHRyc1tpdGVtLm5hbWVdLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtLmF0dHJpYnV0ZS5yZW5kZXJIVE1MKG5vZGVPck1hcmsuYXR0cnMpIHx8IHt9XG4gICAgfSlcbiAgICAucmVkdWNlKChhdHRyaWJ1dGVzLCBhdHRyaWJ1dGUpID0+IG1lcmdlQXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBhdHRyaWJ1dGUpLCB7fSlcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZTogYW55KTogdmFsdWUgaXMgRnVuY3Rpb24ge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nXG59XG4iLCAiaW1wb3J0IHsgTWF5YmVSZXR1cm5UeXBlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJ1xuXG4vKipcbiAqIE9wdGlvbmFsbHkgY2FsbHMgYHZhbHVlYCBhcyBhIGZ1bmN0aW9uLlxuICogT3RoZXJ3aXNlIGl0IGlzIHJldHVybmVkIGRpcmVjdGx5LlxuICogQHBhcmFtIHZhbHVlIEZ1bmN0aW9uIG9yIGFueSB2YWx1ZS5cbiAqIEBwYXJhbSBjb250ZXh0IE9wdGlvbmFsIGNvbnRleHQgdG8gYmluZCB0byBmdW5jdGlvbi5cbiAqIEBwYXJhbSBwcm9wcyBPcHRpb25hbCBwcm9wcyB0byBwYXNzIHRvIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsbE9yUmV0dXJuPFQ+KHZhbHVlOiBULCBjb250ZXh0OiBhbnkgPSB1bmRlZmluZWQsIC4uLnByb3BzOiBhbnlbXSk6IE1heWJlUmV0dXJuVHlwZTxUPiB7XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdmFsdWUuYmluZChjb250ZXh0KSguLi5wcm9wcylcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUoLi4ucHJvcHMpXG4gIH1cblxuICByZXR1cm4gdmFsdWUgYXMgTWF5YmVSZXR1cm5UeXBlPFQ+XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHlPYmplY3QodmFsdWUgPSB7fSk6IGJvb2xlYW4ge1xuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMCAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWU6IGFueSk6IGFueSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBpZiAodmFsdWUubWF0Y2goL15bKy1dPyg/OlxcZCpcXC4pP1xcZCskLykpIHtcbiAgICByZXR1cm4gTnVtYmVyKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdmFsdWVcbn1cbiIsICJpbXBvcnQgeyBQYXJzZVJ1bGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb25BdHRyaWJ1dGUgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGZyb21TdHJpbmcgfSBmcm9tICcuLi91dGlsaXRpZXMvZnJvbVN0cmluZy5qcydcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIG1lcmdlcyBleHRlbnNpb24gYXR0cmlidXRlcyBpbnRvIHBhcnNlcnVsZSBhdHRyaWJ1dGVzIChgYXR0cnNgIG9yIGBnZXRBdHRyc2ApLlxuICogQ2FuY2VscyB3aGVuIGBnZXRBdHRyc2AgcmV0dXJuZWQgYGZhbHNlYC5cbiAqIEBwYXJhbSBwYXJzZVJ1bGUgUHJvc2VNaXJyb3IgUGFyc2VSdWxlXG4gKiBAcGFyYW0gZXh0ZW5zaW9uQXR0cmlidXRlcyBMaXN0IG9mIGF0dHJpYnV0ZXMgdG8gaW5qZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUoXG4gIHBhcnNlUnVsZTogUGFyc2VSdWxlLFxuICBleHRlbnNpb25BdHRyaWJ1dGVzOiBFeHRlbnNpb25BdHRyaWJ1dGVbXSxcbik6IFBhcnNlUnVsZSB7XG4gIGlmIChwYXJzZVJ1bGUuc3R5bGUpIHtcbiAgICByZXR1cm4gcGFyc2VSdWxlXG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnBhcnNlUnVsZSxcbiAgICBnZXRBdHRyczogbm9kZSA9PiB7XG4gICAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0gcGFyc2VSdWxlLmdldEF0dHJzID8gcGFyc2VSdWxlLmdldEF0dHJzKG5vZGUpIDogcGFyc2VSdWxlLmF0dHJzXG5cbiAgICAgIGlmIChvbGRBdHRyaWJ1dGVzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IGV4dGVuc2lvbkF0dHJpYnV0ZXMucmVkdWNlKChpdGVtcywgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGl0ZW0uYXR0cmlidXRlLnBhcnNlSFRNTFxuICAgICAgICAgID8gaXRlbS5hdHRyaWJ1dGUucGFyc2VIVE1MKG5vZGUgYXMgSFRNTEVsZW1lbnQpXG4gICAgICAgICAgOiBmcm9tU3RyaW5nKChub2RlIGFzIEhUTUxFbGVtZW50KS5nZXRBdHRyaWJ1dGUoaXRlbS5uYW1lKSlcblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBpdGVtc1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5pdGVtcyxcbiAgICAgICAgICBbaXRlbS5uYW1lXTogdmFsdWUsXG4gICAgICAgIH1cbiAgICAgIH0sIHt9KVxuXG4gICAgICByZXR1cm4geyAuLi5vbGRBdHRyaWJ1dGVzLCAuLi5uZXdBdHRyaWJ1dGVzIH1cbiAgICB9LFxuICB9XG59XG4iLCAiaW1wb3J0IHsgTWFya1NwZWMsIE5vZGVTcGVjLCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBFZGl0b3IsIE1hcmtDb25maWcsIE5vZGVDb25maWcgfSBmcm9tICcuLi9pbmRleC5qcydcbmltcG9ydCB7IEFueUNvbmZpZywgRXh0ZW5zaW9ucyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcbmltcG9ydCB7IGlzRW1wdHlPYmplY3QgfSBmcm9tICcuLi91dGlsaXRpZXMvaXNFbXB0eU9iamVjdC5qcydcbmltcG9ydCB7IGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyB9IGZyb20gJy4vZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zLmpzJ1xuaW1wb3J0IHsgZ2V0RXh0ZW5zaW9uRmllbGQgfSBmcm9tICcuL2dldEV4dGVuc2lvbkZpZWxkLmpzJ1xuaW1wb3J0IHsgZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzIH0gZnJvbSAnLi9nZXRSZW5kZXJlZEF0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUgfSBmcm9tICcuL2luamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZS5qcydcbmltcG9ydCB7IHNwbGl0RXh0ZW5zaW9ucyB9IGZyb20gJy4vc3BsaXRFeHRlbnNpb25zLmpzJ1xuXG5mdW5jdGlvbiBjbGVhblVwU2NoZW1hSXRlbTxUPihkYXRhOiBUKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIE9iamVjdC5lbnRyaWVzKGRhdGEpLmZpbHRlcigoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAoa2V5ID09PSAnYXR0cnMnICYmIGlzRW1wdHlPYmplY3QodmFsdWUgYXMge30gfCB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZFxuICAgIH0pLFxuICApIGFzIFRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMsIGVkaXRvcj86IEVkaXRvcik6IFNjaGVtYSB7XG4gIGNvbnN0IGFsbEF0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMoZXh0ZW5zaW9ucylcbiAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucywgbWFya0V4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKVxuICBjb25zdCB0b3BOb2RlID0gbm9kZUV4dGVuc2lvbnMuZmluZChleHRlbnNpb24gPT4gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAndG9wTm9kZScpKT8ubmFtZVxuXG4gIGNvbnN0IG5vZGVzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIG5vZGVFeHRlbnNpb25zLm1hcChleHRlbnNpb24gPT4ge1xuICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGFsbEF0dHJpYnV0ZXMuZmlsdGVyKFxuICAgICAgICBhdHRyaWJ1dGUgPT4gYXR0cmlidXRlLnR5cGUgPT09IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgKVxuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgZWRpdG9yLFxuICAgICAgfVxuXG4gICAgICBjb25zdCBleHRyYU5vZGVGaWVsZHMgPSBleHRlbnNpb25zLnJlZHVjZSgoZmllbGRzLCBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4dGVuZE5vZGVTY2hlbWEgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2V4dGVuZE5vZGVTY2hlbWEnXT4oXG4gICAgICAgICAgZSxcbiAgICAgICAgICAnZXh0ZW5kTm9kZVNjaGVtYScsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgIC4uLihleHRlbmROb2RlU2NoZW1hID8gZXh0ZW5kTm9kZVNjaGVtYShleHRlbnNpb24pIDoge30pLFxuICAgICAgICB9XG4gICAgICB9LCB7fSlcblxuICAgICAgY29uc3Qgc2NoZW1hOiBOb2RlU3BlYyA9IGNsZWFuVXBTY2hlbWFJdGVtKHtcbiAgICAgICAgLi4uZXh0cmFOb2RlRmllbGRzLFxuICAgICAgICBjb250ZW50OiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snY29udGVudCddPihleHRlbnNpb24sICdjb250ZW50JywgY29udGV4dCksXG4gICAgICAgICksXG4gICAgICAgIG1hcmtzOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snbWFya3MnXT4oZXh0ZW5zaW9uLCAnbWFya3MnLCBjb250ZXh0KSksXG4gICAgICAgIGdyb3VwOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snZ3JvdXAnXT4oZXh0ZW5zaW9uLCAnZ3JvdXAnLCBjb250ZXh0KSksXG4gICAgICAgIGlubGluZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2lubGluZSddPihleHRlbnNpb24sICdpbmxpbmUnLCBjb250ZXh0KSksXG4gICAgICAgIGF0b206IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydhdG9tJ10+KGV4dGVuc2lvbiwgJ2F0b20nLCBjb250ZXh0KSksXG4gICAgICAgIHNlbGVjdGFibGU6IGNhbGxPclJldHVybihcbiAgICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydzZWxlY3RhYmxlJ10+KGV4dGVuc2lvbiwgJ3NlbGVjdGFibGUnLCBjb250ZXh0KSxcbiAgICAgICAgKSxcbiAgICAgICAgZHJhZ2dhYmxlOiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snZHJhZ2dhYmxlJ10+KGV4dGVuc2lvbiwgJ2RyYWdnYWJsZScsIGNvbnRleHQpLFxuICAgICAgICApLFxuICAgICAgICBjb2RlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snY29kZSddPihleHRlbnNpb24sICdjb2RlJywgY29udGV4dCkpLFxuICAgICAgICBkZWZpbmluZzogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2RlZmluaW5nJ10+KGV4dGVuc2lvbiwgJ2RlZmluaW5nJywgY29udGV4dCksXG4gICAgICAgICksXG4gICAgICAgIGlzb2xhdGluZzogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2lzb2xhdGluZyddPihleHRlbnNpb24sICdpc29sYXRpbmcnLCBjb250ZXh0KSxcbiAgICAgICAgKSxcbiAgICAgICAgYXR0cnM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLm1hcChleHRlbnNpb25BdHRyaWJ1dGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25BdHRyaWJ1dGUubmFtZSwgeyBkZWZhdWx0OiBleHRlbnNpb25BdHRyaWJ1dGU/LmF0dHJpYnV0ZT8uZGVmYXVsdCB9XVxuICAgICAgICAgIH0pLFxuICAgICAgICApLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgcGFyc2VIVE1MID0gY2FsbE9yUmV0dXJuKFxuICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydwYXJzZUhUTUwnXT4oZXh0ZW5zaW9uLCAncGFyc2VIVE1MJywgY29udGV4dCksXG4gICAgICApXG5cbiAgICAgIGlmIChwYXJzZUhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnBhcnNlRE9NID0gcGFyc2VIVE1MLm1hcChwYXJzZVJ1bGUgPT4gaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlKHBhcnNlUnVsZSwgZXh0ZW5zaW9uQXR0cmlidXRlcykpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlbmRlckhUTUwgPSBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydyZW5kZXJIVE1MJ10+KFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICdyZW5kZXJIVE1MJyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgIClcblxuICAgICAgaWYgKHJlbmRlckhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnRvRE9NID0gbm9kZSA9PiByZW5kZXJIVE1MKHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobm9kZSwgZXh0ZW5zaW9uQXR0cmlidXRlcyksXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlbmRlclRleHQgPSBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydyZW5kZXJUZXh0J10+KFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICdyZW5kZXJUZXh0JyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgIClcblxuICAgICAgaWYgKHJlbmRlclRleHQpIHtcbiAgICAgICAgc2NoZW1hLnRvVGV4dCA9IHJlbmRlclRleHRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtleHRlbnNpb24ubmFtZSwgc2NoZW1hXVxuICAgIH0pLFxuICApXG5cbiAgY29uc3QgbWFya3MgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgbWFya0V4dGVuc2lvbnMubWFwKGV4dGVuc2lvbiA9PiB7XG4gICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gYWxsQXR0cmlidXRlcy5maWx0ZXIoXG4gICAgICAgIGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUsXG4gICAgICApXG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICBlZGl0b3IsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4dHJhTWFya0ZpZWxkcyA9IGV4dGVuc2lvbnMucmVkdWNlKChmaWVsZHMsIGUpID0+IHtcbiAgICAgICAgY29uc3QgZXh0ZW5kTWFya1NjaGVtYSA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snZXh0ZW5kTWFya1NjaGVtYSddPihcbiAgICAgICAgICBlLFxuICAgICAgICAgICdleHRlbmRNYXJrU2NoZW1hJyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICApXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgLi4uKGV4dGVuZE1hcmtTY2hlbWEgPyBleHRlbmRNYXJrU2NoZW1hKGV4dGVuc2lvbikgOiB7fSksXG4gICAgICAgIH1cbiAgICAgIH0sIHt9KVxuXG4gICAgICBjb25zdCBzY2hlbWE6IE1hcmtTcGVjID0gY2xlYW5VcFNjaGVtYUl0ZW0oe1xuICAgICAgICAuLi5leHRyYU1hcmtGaWVsZHMsXG4gICAgICAgIGluY2x1c2l2ZTogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE1hcmtDb25maWdbJ2luY2x1c2l2ZSddPihleHRlbnNpb24sICdpbmNsdXNpdmUnLCBjb250ZXh0KSxcbiAgICAgICAgKSxcbiAgICAgICAgZXhjbHVkZXM6IGNhbGxPclJldHVybihcbiAgICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydleGNsdWRlcyddPihleHRlbnNpb24sICdleGNsdWRlcycsIGNvbnRleHQpLFxuICAgICAgICApLFxuICAgICAgICBncm91cDogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE1hcmtDb25maWdbJ2dyb3VwJ10+KGV4dGVuc2lvbiwgJ2dyb3VwJywgY29udGV4dCkpLFxuICAgICAgICBzcGFubmluZzogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE1hcmtDb25maWdbJ3NwYW5uaW5nJ10+KGV4dGVuc2lvbiwgJ3NwYW5uaW5nJywgY29udGV4dCksXG4gICAgICAgICksXG4gICAgICAgIGNvZGU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydjb2RlJ10+KGV4dGVuc2lvbiwgJ2NvZGUnLCBjb250ZXh0KSksXG4gICAgICAgIGF0dHJzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcy5tYXAoZXh0ZW5zaW9uQXR0cmlidXRlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uQXR0cmlidXRlLm5hbWUsIHsgZGVmYXVsdDogZXh0ZW5zaW9uQXR0cmlidXRlPy5hdHRyaWJ1dGU/LmRlZmF1bHQgfV1cbiAgICAgICAgICB9KSxcbiAgICAgICAgKSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHBhcnNlSFRNTCA9IGNhbGxPclJldHVybihcbiAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1sncGFyc2VIVE1MJ10+KGV4dGVuc2lvbiwgJ3BhcnNlSFRNTCcsIGNvbnRleHQpLFxuICAgICAgKVxuXG4gICAgICBpZiAocGFyc2VIVE1MKSB7XG4gICAgICAgIHNjaGVtYS5wYXJzZURPTSA9IHBhcnNlSFRNTC5tYXAocGFyc2VSdWxlID0+IGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZShwYXJzZVJ1bGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpKVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZW5kZXJIVE1MID0gZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1sncmVuZGVySFRNTCddPihcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAncmVuZGVySFRNTCcsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApXG5cbiAgICAgIGlmIChyZW5kZXJIVE1MKSB7XG4gICAgICAgIHNjaGVtYS50b0RPTSA9IG1hcmsgPT4gcmVuZGVySFRNTCh7XG4gICAgICAgICAgbWFyayxcbiAgICAgICAgICBIVE1MQXR0cmlidXRlczogZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG1hcmssIGV4dGVuc2lvbkF0dHJpYnV0ZXMpLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2V4dGVuc2lvbi5uYW1lLCBzY2hlbWFdXG4gICAgfSksXG4gIClcblxuICByZXR1cm4gbmV3IFNjaGVtYSh7XG4gICAgdG9wTm9kZSxcbiAgICBub2RlcyxcbiAgICBtYXJrcyxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSwgTm9kZVR5cGUsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2hlbWFUeXBlQnlOYW1lKG5hbWU6IHN0cmluZywgc2NoZW1hOiBTY2hlbWEpOiBOb2RlVHlwZSB8IE1hcmtUeXBlIHwgbnVsbCB7XG4gIHJldHVybiBzY2hlbWEubm9kZXNbbmFtZV0gfHwgc2NoZW1hLm1hcmtzW25hbWVdIHx8IG51bGxcbn1cbiIsICJpbXBvcnQgeyBBbnlFeHRlbnNpb24sIEVuYWJsZVJ1bGVzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZChleHRlbnNpb246IEFueUV4dGVuc2lvbiwgZW5hYmxlZDogRW5hYmxlUnVsZXMpOiBib29sZWFuIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZW5hYmxlZCkpIHtcbiAgICByZXR1cm4gZW5hYmxlZC5zb21lKGVuYWJsZWRFeHRlbnNpb24gPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IHR5cGVvZiBlbmFibGVkRXh0ZW5zaW9uID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGVuYWJsZWRFeHRlbnNpb25cbiAgICAgICAgOiBlbmFibGVkRXh0ZW5zaW9uLm5hbWVcblxuICAgICAgcmV0dXJuIG5hbWUgPT09IGV4dGVuc2lvbi5uYW1lXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBlbmFibGVkXG59XG4iLCAiaW1wb3J0IHsgUmVzb2x2ZWRQb3MgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgY29uc3QgZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMgPSAoJGZyb206IFJlc29sdmVkUG9zLCBtYXhNYXRjaCA9IDUwMCkgPT4ge1xuICBsZXQgdGV4dEJlZm9yZSA9ICcnXG5cbiAgY29uc3Qgc2xpY2VFbmRQb3MgPSAkZnJvbS5wYXJlbnRPZmZzZXRcblxuICAkZnJvbS5wYXJlbnQubm9kZXNCZXR3ZWVuKFxuICAgIE1hdGgubWF4KDAsIHNsaWNlRW5kUG9zIC0gbWF4TWF0Y2gpLFxuICAgIHNsaWNlRW5kUG9zLFxuICAgIChub2RlLCBwb3MsIHBhcmVudCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNodW5rID0gbm9kZS50eXBlLnNwZWMudG9UZXh0Py4oe1xuICAgICAgICBub2RlLFxuICAgICAgICBwb3MsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9KVxuICAgICAgICB8fCBub2RlLnRleHRDb250ZW50XG4gICAgICAgIHx8ICclbGVhZiUnXG5cbiAgICAgIHRleHRCZWZvcmUgKz0gY2h1bmsuc2xpY2UoMCwgTWF0aC5tYXgoMCwgc2xpY2VFbmRQb3MgLSBwb3MpKVxuICAgIH0sXG4gIClcblxuICByZXR1cm4gdGV4dEJlZm9yZVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZTogYW55KTogdmFsdWUgaXMgUmVnRXhwIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUsIFBsdWdpbiwgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IENvbW1hbmRNYW5hZ2VyIH0gZnJvbSAnLi9Db21tYW5kTWFuYWdlci5qcydcbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgY3JlYXRlQ2hhaW5hYmxlU3RhdGUgfSBmcm9tICcuL2hlbHBlcnMvY3JlYXRlQ2hhaW5hYmxlU3RhdGUuanMnXG5pbXBvcnQgeyBnZXRUZXh0Q29udGVudEZyb21Ob2RlcyB9IGZyb20gJy4vaGVscGVycy9nZXRUZXh0Q29udGVudEZyb21Ob2Rlcy5qcydcbmltcG9ydCB7XG4gIENhbkNvbW1hbmRzLFxuICBDaGFpbmVkQ29tbWFuZHMsXG4gIEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSxcbiAgUmFuZ2UsXG4gIFNpbmdsZUNvbW1hbmRzLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgaXNSZWdFeHAgfSBmcm9tICcuL3V0aWxpdGllcy9pc1JlZ0V4cC5qcydcblxuZXhwb3J0IHR5cGUgSW5wdXRSdWxlTWF0Y2ggPSB7XG4gIGluZGV4OiBudW1iZXJcbiAgdGV4dDogc3RyaW5nXG4gIHJlcGxhY2VXaXRoPzogc3RyaW5nXG4gIG1hdGNoPzogUmVnRXhwTWF0Y2hBcnJheVxuICBkYXRhPzogUmVjb3JkPHN0cmluZywgYW55PlxufVxuXG5leHBvcnQgdHlwZSBJbnB1dFJ1bGVGaW5kZXIgPSBSZWdFeHAgfCAoKHRleHQ6IHN0cmluZykgPT4gSW5wdXRSdWxlTWF0Y2ggfCBudWxsKVxuXG5leHBvcnQgY2xhc3MgSW5wdXRSdWxlIHtcbiAgZmluZDogSW5wdXRSdWxlRmluZGVyXG5cbiAgaGFuZGxlcjogKHByb3BzOiB7XG4gICAgc3RhdGU6IEVkaXRvclN0YXRlXG4gICAgcmFuZ2U6IFJhbmdlXG4gICAgbWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheVxuICAgIGNvbW1hbmRzOiBTaW5nbGVDb21tYW5kc1xuICAgIGNoYWluOiAoKSA9PiBDaGFpbmVkQ29tbWFuZHNcbiAgICBjYW46ICgpID0+IENhbkNvbW1hbmRzXG4gIH0pID0+IHZvaWQgfCBudWxsXG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiB7XG4gICAgZmluZDogSW5wdXRSdWxlRmluZGVyXG4gICAgaGFuZGxlcjogKHByb3BzOiB7XG4gICAgICBzdGF0ZTogRWRpdG9yU3RhdGVcbiAgICAgIHJhbmdlOiBSYW5nZVxuICAgICAgbWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheVxuICAgICAgY29tbWFuZHM6IFNpbmdsZUNvbW1hbmRzXG4gICAgICBjaGFpbjogKCkgPT4gQ2hhaW5lZENvbW1hbmRzXG4gICAgICBjYW46ICgpID0+IENhbkNvbW1hbmRzXG4gICAgfSkgPT4gdm9pZCB8IG51bGxcbiAgfSkge1xuICAgIHRoaXMuZmluZCA9IGNvbmZpZy5maW5kXG4gICAgdGhpcy5oYW5kbGVyID0gY29uZmlnLmhhbmRsZXJcbiAgfVxufVxuXG5jb25zdCBpbnB1dFJ1bGVNYXRjaGVySGFuZGxlciA9IChcbiAgdGV4dDogc3RyaW5nLFxuICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXIsXG4pOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkgfCBudWxsID0+IHtcbiAgaWYgKGlzUmVnRXhwKGZpbmQpKSB7XG4gICAgcmV0dXJuIGZpbmQuZXhlYyh0ZXh0KVxuICB9XG5cbiAgY29uc3QgaW5wdXRSdWxlTWF0Y2ggPSBmaW5kKHRleHQpXG5cbiAgaWYgKCFpbnB1dFJ1bGVNYXRjaCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCByZXN1bHQ6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSA9IFtpbnB1dFJ1bGVNYXRjaC50ZXh0XVxuXG4gIHJlc3VsdC5pbmRleCA9IGlucHV0UnVsZU1hdGNoLmluZGV4XG4gIHJlc3VsdC5pbnB1dCA9IHRleHRcbiAgcmVzdWx0LmRhdGEgPSBpbnB1dFJ1bGVNYXRjaC5kYXRhXG5cbiAgaWYgKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKSB7XG4gICAgaWYgKCFpbnB1dFJ1bGVNYXRjaC50ZXh0LmluY2x1ZGVzKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnW3RpcHRhcCB3YXJuXTogXCJpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aFwiIG11c3QgYmUgcGFydCBvZiBcImlucHV0UnVsZU1hdGNoLnRleHRcIi4nLFxuICAgICAgKVxuICAgIH1cblxuICAgIHJlc3VsdC5wdXNoKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBydW4oY29uZmlnOiB7XG4gIGVkaXRvcjogRWRpdG9yXG4gIGZyb206IG51bWJlclxuICB0bzogbnVtYmVyXG4gIHRleHQ6IHN0cmluZ1xuICBydWxlczogSW5wdXRSdWxlW11cbiAgcGx1Z2luOiBQbHVnaW5cbn0pOiBib29sZWFuIHtcbiAgY29uc3Qge1xuICAgIGVkaXRvciwgZnJvbSwgdG8sIHRleHQsIHJ1bGVzLCBwbHVnaW4sXG4gIH0gPSBjb25maWdcbiAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3JcblxuICBpZiAodmlldy5jb21wb3NpbmcpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0ICRmcm9tID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShmcm9tKVxuXG4gIGlmIChcbiAgICAvLyBjaGVjayBmb3IgY29kZSBub2RlXG4gICAgJGZyb20ucGFyZW50LnR5cGUuc3BlYy5jb2RlXG4gICAgLy8gY2hlY2sgZm9yIGNvZGUgbWFya1xuICAgIHx8ICEhKCRmcm9tLm5vZGVCZWZvcmUgfHwgJGZyb20ubm9kZUFmdGVyKT8ubWFya3MuZmluZChtYXJrID0+IG1hcmsudHlwZS5zcGVjLmNvZGUpXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgbGV0IG1hdGNoZWQgPSBmYWxzZVxuXG4gIGNvbnN0IHRleHRCZWZvcmUgPSBnZXRUZXh0Q29udGVudEZyb21Ob2RlcygkZnJvbSkgKyB0ZXh0XG5cbiAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgbWF0Y2ggPSBpbnB1dFJ1bGVNYXRjaGVySGFuZGxlcih0ZXh0QmVmb3JlLCBydWxlLmZpbmQpXG5cbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB0ciA9IHZpZXcuc3RhdGUudHJcbiAgICBjb25zdCBzdGF0ZSA9IGNyZWF0ZUNoYWluYWJsZVN0YXRlKHtcbiAgICAgIHN0YXRlOiB2aWV3LnN0YXRlLFxuICAgICAgdHJhbnNhY3Rpb246IHRyLFxuICAgIH0pXG4gICAgY29uc3QgcmFuZ2UgPSB7XG4gICAgICBmcm9tOiBmcm9tIC0gKG1hdGNoWzBdLmxlbmd0aCAtIHRleHQubGVuZ3RoKSxcbiAgICAgIHRvLFxuICAgIH1cblxuICAgIGNvbnN0IHsgY29tbWFuZHMsIGNoYWluLCBjYW4gfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgICBlZGl0b3IsXG4gICAgICBzdGF0ZSxcbiAgICB9KVxuXG4gICAgY29uc3QgaGFuZGxlciA9IHJ1bGUuaGFuZGxlcih7XG4gICAgICBzdGF0ZSxcbiAgICAgIHJhbmdlLFxuICAgICAgbWF0Y2gsXG4gICAgICBjb21tYW5kcyxcbiAgICAgIGNoYWluLFxuICAgICAgY2FuLFxuICAgIH0pXG5cbiAgICAvLyBzdG9wIGlmIHRoZXJlIGFyZSBubyBjaGFuZ2VzXG4gICAgaWYgKGhhbmRsZXIgPT09IG51bGwgfHwgIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gc3RvcmUgdHJhbnNmb3JtIGFzIG1ldGEgZGF0YVxuICAgIC8vIHNvIHdlIGNhbiB1bmRvIGlucHV0IHJ1bGVzIHdpdGhpbiB0aGUgYHVuZG9JbnB1dFJ1bGVzYCBjb21tYW5kXG4gICAgdHIuc2V0TWV0YShwbHVnaW4sIHtcbiAgICAgIHRyYW5zZm9ybTogdHIsXG4gICAgICBmcm9tLFxuICAgICAgdG8sXG4gICAgICB0ZXh0LFxuICAgIH0pXG5cbiAgICB2aWV3LmRpc3BhdGNoKHRyKVxuICAgIG1hdGNoZWQgPSB0cnVlXG4gIH0pXG5cbiAgcmV0dXJuIG1hdGNoZWRcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5wdXQgcnVsZXMgcGx1Z2luLiBXaGVuIGVuYWJsZWQsIGl0IHdpbGwgY2F1c2UgdGV4dFxuICogaW5wdXQgdGhhdCBtYXRjaGVzIGFueSBvZiB0aGUgZ2l2ZW4gcnVsZXMgdG8gdHJpZ2dlciB0aGUgcnVsZeKAmXNcbiAqIGFjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlucHV0UnVsZXNQbHVnaW4ocHJvcHM6IHsgZWRpdG9yOiBFZGl0b3I7IHJ1bGVzOiBJbnB1dFJ1bGVbXSB9KTogUGx1Z2luIHtcbiAgY29uc3QgeyBlZGl0b3IsIHJ1bGVzIH0gPSBwcm9wc1xuICBjb25zdCBwbHVnaW4gPSBuZXcgUGx1Z2luKHtcbiAgICBzdGF0ZToge1xuICAgICAgaW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH0sXG4gICAgICBhcHBseSh0ciwgcHJldikge1xuICAgICAgICBjb25zdCBzdG9yZWQgPSB0ci5nZXRNZXRhKHBsdWdpbilcblxuICAgICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHN0b3JlZFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyLnNlbGVjdGlvblNldCB8fCB0ci5kb2NDaGFuZ2VkID8gbnVsbCA6IHByZXZcbiAgICAgIH0sXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG4gICAgICBoYW5kbGVUZXh0SW5wdXQodmlldywgZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJ1bih7XG4gICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgIGZyb20sXG4gICAgICAgICAgdG8sXG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgICBydWxlcyxcbiAgICAgICAgICBwbHVnaW4sXG4gICAgICAgIH0pXG4gICAgICB9LFxuXG4gICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgY29tcG9zaXRpb25lbmQ6IHZpZXcgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyAkY3Vyc29yIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiBhcyBUZXh0U2VsZWN0aW9uXG5cbiAgICAgICAgICAgIGlmICgkY3Vyc29yKSB7XG4gICAgICAgICAgICAgIHJ1bih7XG4gICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgIGZyb206ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgICAgIHRvOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICAgICBydWxlcyxcbiAgICAgICAgICAgICAgICBwbHVnaW4sXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgfSxcblxuICAgICAgLy8gYWRkIHN1cHBvcnQgZm9yIGlucHV0IHJ1bGVzIHRvIHRyaWdnZXIgb24gZW50ZXJcbiAgICAgIC8vIHRoaXMgaXMgdXNlZnVsIGZvciBleGFtcGxlIGZvciBjb2RlIGJsb2Nrc1xuICAgICAgaGFuZGxlS2V5RG93bih2aWV3LCBldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5ICE9PSAnRW50ZXInKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7ICRjdXJzb3IgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uIGFzIFRleHRTZWxlY3Rpb25cblxuICAgICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICAgIHJldHVybiBydW4oe1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgZnJvbTogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICB0bzogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICB0ZXh0OiAnXFxuJyxcbiAgICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgICAgcGx1Z2luLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0sXG4gICAgfSxcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpc0lucHV0UnVsZXM6IHRydWUsXG4gIH0pIGFzIFBsdWdpblxuXG4gIHJldHVybiBwbHVnaW5cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWU6IGFueSk6IHZhbHVlIGlzIG51bWJlciB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUsIFBsdWdpbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IENvbW1hbmRNYW5hZ2VyIH0gZnJvbSAnLi9Db21tYW5kTWFuYWdlci5qcydcbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgY3JlYXRlQ2hhaW5hYmxlU3RhdGUgfSBmcm9tICcuL2hlbHBlcnMvY3JlYXRlQ2hhaW5hYmxlU3RhdGUuanMnXG5pbXBvcnQge1xuICBDYW5Db21tYW5kcyxcbiAgQ2hhaW5lZENvbW1hbmRzLFxuICBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXksXG4gIFJhbmdlLFxuICBTaW5nbGVDb21tYW5kcyxcbn0gZnJvbSAnLi90eXBlcy5qcydcbmltcG9ydCB7IGlzTnVtYmVyIH0gZnJvbSAnLi91dGlsaXRpZXMvaXNOdW1iZXIuanMnXG5pbXBvcnQgeyBpc1JlZ0V4cCB9IGZyb20gJy4vdXRpbGl0aWVzL2lzUmVnRXhwLmpzJ1xuXG5leHBvcnQgdHlwZSBQYXN0ZVJ1bGVNYXRjaCA9IHtcbiAgaW5kZXg6IG51bWJlclxuICB0ZXh0OiBzdHJpbmdcbiAgcmVwbGFjZVdpdGg/OiBzdHJpbmdcbiAgbWF0Y2g/OiBSZWdFeHBNYXRjaEFycmF5XG4gIGRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG59XG5cbmV4cG9ydCB0eXBlIFBhc3RlUnVsZUZpbmRlciA9IFJlZ0V4cCB8ICgodGV4dDogc3RyaW5nKSA9PiBQYXN0ZVJ1bGVNYXRjaFtdIHwgbnVsbCB8IHVuZGVmaW5lZClcblxuZXhwb3J0IGNsYXNzIFBhc3RlUnVsZSB7XG4gIGZpbmQ6IFBhc3RlUnVsZUZpbmRlclxuXG4gIGhhbmRsZXI6IChwcm9wczoge1xuICAgIHN0YXRlOiBFZGl0b3JTdGF0ZVxuICAgIHJhbmdlOiBSYW5nZVxuICAgIG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXlcbiAgICBjb21tYW5kczogU2luZ2xlQ29tbWFuZHNcbiAgICBjaGFpbjogKCkgPT4gQ2hhaW5lZENvbW1hbmRzXG4gICAgY2FuOiAoKSA9PiBDYW5Db21tYW5kc1xuICB9KSA9PiB2b2lkIHwgbnVsbFxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzoge1xuICAgIGZpbmQ6IFBhc3RlUnVsZUZpbmRlclxuICAgIGhhbmRsZXI6IChwcm9wczoge1xuICAgICAgc3RhdGU6IEVkaXRvclN0YXRlXG4gICAgICByYW5nZTogUmFuZ2VcbiAgICAgIG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXlcbiAgICAgIGNvbW1hbmRzOiBTaW5nbGVDb21tYW5kc1xuICAgICAgY2hhaW46ICgpID0+IENoYWluZWRDb21tYW5kc1xuICAgICAgY2FuOiAoKSA9PiBDYW5Db21tYW5kc1xuICAgIH0pID0+IHZvaWQgfCBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmZpbmQgPSBjb25maWcuZmluZFxuICAgIHRoaXMuaGFuZGxlciA9IGNvbmZpZy5oYW5kbGVyXG4gIH1cbn1cblxuY29uc3QgcGFzdGVSdWxlTWF0Y2hlckhhbmRsZXIgPSAoXG4gIHRleHQ6IHN0cmluZyxcbiAgZmluZDogUGFzdGVSdWxlRmluZGVyLFxuKTogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5W10gPT4ge1xuICBpZiAoaXNSZWdFeHAoZmluZCkpIHtcbiAgICByZXR1cm4gWy4uLnRleHQubWF0Y2hBbGwoZmluZCldXG4gIH1cblxuICBjb25zdCBtYXRjaGVzID0gZmluZCh0ZXh0KVxuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXMubWFwKHBhc3RlUnVsZU1hdGNoID0+IHtcbiAgICBjb25zdCByZXN1bHQ6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSA9IFtwYXN0ZVJ1bGVNYXRjaC50ZXh0XVxuXG4gICAgcmVzdWx0LmluZGV4ID0gcGFzdGVSdWxlTWF0Y2guaW5kZXhcbiAgICByZXN1bHQuaW5wdXQgPSB0ZXh0XG4gICAgcmVzdWx0LmRhdGEgPSBwYXN0ZVJ1bGVNYXRjaC5kYXRhXG5cbiAgICBpZiAocGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGgpIHtcbiAgICAgIGlmICghcGFzdGVSdWxlTWF0Y2gudGV4dC5pbmNsdWRlcyhwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdbdGlwdGFwIHdhcm5dOiBcInBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoXCIgbXVzdCBiZSBwYXJ0IG9mIFwicGFzdGVSdWxlTWF0Y2gudGV4dFwiLicsXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgcmVzdWx0LnB1c2gocGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KVxufVxuXG5mdW5jdGlvbiBydW4oY29uZmlnOiB7XG4gIGVkaXRvcjogRWRpdG9yXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZVxuICBmcm9tOiBudW1iZXJcbiAgdG86IG51bWJlclxuICBydWxlOiBQYXN0ZVJ1bGVcbn0pOiBib29sZWFuIHtcbiAgY29uc3Qge1xuICAgIGVkaXRvciwgc3RhdGUsIGZyb20sIHRvLCBydWxlLFxuICB9ID0gY29uZmlnXG5cbiAgY29uc3QgeyBjb21tYW5kcywgY2hhaW4sIGNhbiB9ID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICBlZGl0b3IsXG4gICAgc3RhdGUsXG4gIH0pXG5cbiAgY29uc3QgaGFuZGxlcnM6ICh2b2lkIHwgbnVsbClbXSA9IFtdXG5cbiAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgIGlmICghbm9kZS5pc1RleHRibG9jayB8fCBub2RlLnR5cGUuc3BlYy5jb2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByZXNvbHZlZEZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpXG4gICAgY29uc3QgcmVzb2x2ZWRUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBub2RlLmNvbnRlbnQuc2l6ZSlcbiAgICBjb25zdCB0ZXh0VG9NYXRjaCA9IG5vZGUudGV4dEJldHdlZW4ocmVzb2x2ZWRGcm9tIC0gcG9zLCByZXNvbHZlZFRvIC0gcG9zLCB1bmRlZmluZWQsICdcXHVmZmZjJylcblxuICAgIGNvbnN0IG1hdGNoZXMgPSBwYXN0ZVJ1bGVNYXRjaGVySGFuZGxlcih0ZXh0VG9NYXRjaCwgcnVsZS5maW5kKVxuXG4gICAgbWF0Y2hlcy5mb3JFYWNoKG1hdGNoID0+IHtcbiAgICAgIGlmIChtYXRjaC5pbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBzdGFydCA9IHJlc29sdmVkRnJvbSArIG1hdGNoLmluZGV4ICsgMVxuICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyBtYXRjaFswXS5sZW5ndGhcbiAgICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgICBmcm9tOiBzdGF0ZS50ci5tYXBwaW5nLm1hcChzdGFydCksXG4gICAgICAgIHRvOiBzdGF0ZS50ci5tYXBwaW5nLm1hcChlbmQpLFxuICAgICAgfVxuXG4gICAgICBjb25zdCBoYW5kbGVyID0gcnVsZS5oYW5kbGVyKHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHJhbmdlLFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgY29tbWFuZHMsXG4gICAgICAgIGNoYWluLFxuICAgICAgICBjYW4sXG4gICAgICB9KVxuXG4gICAgICBoYW5kbGVycy5wdXNoKGhhbmRsZXIpXG4gICAgfSlcbiAgfSlcblxuICBjb25zdCBzdWNjZXNzID0gaGFuZGxlcnMuZXZlcnkoaGFuZGxlciA9PiBoYW5kbGVyICE9PSBudWxsKVxuXG4gIHJldHVybiBzdWNjZXNzXG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIHBhc3RlIHJ1bGVzIHBsdWdpbi4gV2hlbiBlbmFibGVkLCBpdCB3aWxsIGNhdXNlIHBhc3RlZFxuICogdGV4dCB0aGF0IG1hdGNoZXMgYW55IG9mIHRoZSBnaXZlbiBydWxlcyB0byB0cmlnZ2VyIHRoZSBydWxl4oCZc1xuICogYWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFzdGVSdWxlc1BsdWdpbihwcm9wczogeyBlZGl0b3I6IEVkaXRvcjsgcnVsZXM6IFBhc3RlUnVsZVtdIH0pOiBQbHVnaW5bXSB7XG4gIGNvbnN0IHsgZWRpdG9yLCBydWxlcyB9ID0gcHJvcHNcbiAgbGV0IGRyYWdTb3VyY2VFbGVtZW50OiBFbGVtZW50IHwgbnVsbCA9IG51bGxcbiAgbGV0IGlzUGFzdGVkRnJvbVByb3NlTWlycm9yID0gZmFsc2VcbiAgbGV0IGlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvciA9IGZhbHNlXG5cbiAgY29uc3QgcGx1Z2lucyA9IHJ1bGVzLm1hcChydWxlID0+IHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAvLyB3ZSByZWdpc3RlciBhIGdsb2JhbCBkcmFnIGhhbmRsZXIgdG8gdHJhY2sgdGhlIGN1cnJlbnQgZHJhZyBzb3VyY2UgZWxlbWVudFxuICAgICAgdmlldyh2aWV3KSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZURyYWdzdGFydCA9IChldmVudDogRHJhZ0V2ZW50KSA9PiB7XG4gICAgICAgICAgZHJhZ1NvdXJjZUVsZW1lbnQgPSB2aWV3LmRvbS5wYXJlbnRFbGVtZW50Py5jb250YWlucyhldmVudC50YXJnZXQgYXMgRWxlbWVudClcbiAgICAgICAgICAgID8gdmlldy5kb20ucGFyZW50RWxlbWVudFxuICAgICAgICAgICAgOiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgaGFuZGxlRHJhZ3N0YXJ0KVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBoYW5kbGVEcmFnc3RhcnQpXG4gICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgZHJvcDogdmlldyA9PiB7XG4gICAgICAgICAgICBpc0Ryb3BwZWRGcm9tUHJvc2VNaXJyb3IgPSBkcmFnU291cmNlRWxlbWVudCA9PT0gdmlldy5kb20ucGFyZW50RWxlbWVudFxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgcGFzdGU6ICh2aWV3LCBldmVudDogRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSAoZXZlbnQgYXMgQ2xpcGJvYXJkRXZlbnQpLmNsaXBib2FyZERhdGE/LmdldERhdGEoJ3RleHQvaHRtbCcpXG5cbiAgICAgICAgICAgIGlzUGFzdGVkRnJvbVByb3NlTWlycm9yID0gISFodG1sPy5pbmNsdWRlcygnZGF0YS1wbS1zbGljZScpXG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuXG4gICAgICBhcHBlbmRUcmFuc2FjdGlvbjogKHRyYW5zYWN0aW9ucywgb2xkU3RhdGUsIHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25zWzBdXG4gICAgICAgIGNvbnN0IGlzUGFzdGUgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCd1aUV2ZW50JykgPT09ICdwYXN0ZScgJiYgIWlzUGFzdGVkRnJvbVByb3NlTWlycm9yXG4gICAgICAgIGNvbnN0IGlzRHJvcCA9IHRyYW5zYWN0aW9uLmdldE1ldGEoJ3VpRXZlbnQnKSA9PT0gJ2Ryb3AnICYmICFpc0Ryb3BwZWRGcm9tUHJvc2VNaXJyb3JcblxuICAgICAgICBpZiAoIWlzUGFzdGUgJiYgIWlzRHJvcCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcCBpZiB0aGVyZSBpcyBubyBjaGFuZ2VkIHJhbmdlXG4gICAgICAgIGNvbnN0IGZyb20gPSBvbGRTdGF0ZS5kb2MuY29udGVudC5maW5kRGlmZlN0YXJ0KHN0YXRlLmRvYy5jb250ZW50KVxuICAgICAgICBjb25zdCB0byA9IG9sZFN0YXRlLmRvYy5jb250ZW50LmZpbmREaWZmRW5kKHN0YXRlLmRvYy5jb250ZW50KVxuXG4gICAgICAgIGlmICghaXNOdW1iZXIoZnJvbSkgfHwgIXRvIHx8IGZyb20gPT09IHRvLmIpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJ1aWxkIGEgY2hhaW5hYmxlIHN0YXRlXG4gICAgICAgIC8vIHNvIHdlIGNhbiB1c2UgYSBzaW5nbGUgdHJhbnNhY3Rpb24gZm9yIGFsbCBwYXN0ZSBydWxlc1xuICAgICAgICBjb25zdCB0ciA9IHN0YXRlLnRyXG4gICAgICAgIGNvbnN0IGNoYWluYWJsZVN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cixcbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBoYW5kbGVyID0gcnVuKHtcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgc3RhdGU6IGNoYWluYWJsZVN0YXRlLFxuICAgICAgICAgIGZyb206IE1hdGgubWF4KGZyb20gLSAxLCAwKSxcbiAgICAgICAgICB0bzogdG8uYiAtIDEsXG4gICAgICAgICAgcnVsZSxcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBzdG9wIGlmIHRoZXJlIGFyZSBubyBjaGFuZ2VzXG4gICAgICAgIGlmICghaGFuZGxlciB8fCAhdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJcbiAgICAgIH0sXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gcGx1Z2luc1xufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBmaW5kRHVwbGljYXRlcyhpdGVtczogYW55W10pOiBhbnlbXSB7XG4gIGNvbnN0IGZpbHRlcmVkID0gaXRlbXMuZmlsdGVyKChlbCwgaW5kZXgpID0+IGl0ZW1zLmluZGV4T2YoZWwpICE9PSBpbmRleClcblxuICByZXR1cm4gWy4uLm5ldyBTZXQoZmlsdGVyZWQpXVxufVxuIiwgImltcG9ydCB7IGtleW1hcCB9IGZyb20gJ0B0aXB0YXAvcG0va2V5bWFwJ1xuaW1wb3J0IHsgTm9kZSBhcyBQcm9zZW1pcnJvck5vZGUsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgRGVjb3JhdGlvbiwgRWRpdG9yVmlldyB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldydcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMgfSBmcm9tICcuL2hlbHBlcnMvZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zLmpzJ1xuaW1wb3J0IHsgZ2V0RXh0ZW5zaW9uRmllbGQgfSBmcm9tICcuL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGdldFJlbmRlcmVkQXR0cmlidXRlcyB9IGZyb20gJy4vaGVscGVycy9nZXRSZW5kZXJlZEF0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyB9IGZyb20gJy4vaGVscGVycy9nZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucy5qcydcbmltcG9ydCB7IGdldFNjaGVtYVR5cGVCeU5hbWUgfSBmcm9tICcuL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZUJ5TmFtZS5qcydcbmltcG9ydCB7IGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkIH0gZnJvbSAnLi9oZWxwZXJzL2lzRXh0ZW5zaW9uUnVsZXNFbmFibGVkLmpzJ1xuaW1wb3J0IHsgc3BsaXRFeHRlbnNpb25zIH0gZnJvbSAnLi9oZWxwZXJzL3NwbGl0RXh0ZW5zaW9ucy5qcydcbmltcG9ydCB7IE1hcmssIE5vZGVDb25maWcgfSBmcm9tICcuL2luZGV4LmpzJ1xuaW1wb3J0IHsgaW5wdXRSdWxlc1BsdWdpbiB9IGZyb20gJy4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgcGFzdGVSdWxlc1BsdWdpbiB9IGZyb20gJy4vUGFzdGVSdWxlLmpzJ1xuaW1wb3J0IHsgQW55Q29uZmlnLCBFeHRlbnNpb25zLCBSYXdDb21tYW5kcyB9IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5pbXBvcnQgeyBmaW5kRHVwbGljYXRlcyB9IGZyb20gJy4vdXRpbGl0aWVzL2ZpbmREdXBsaWNhdGVzLmpzJ1xuXG5leHBvcnQgY2xhc3MgRXh0ZW5zaW9uTWFuYWdlciB7XG4gIGVkaXRvcjogRWRpdG9yXG5cbiAgc2NoZW1hOiBTY2hlbWFcblxuICBleHRlbnNpb25zOiBFeHRlbnNpb25zXG5cbiAgc3BsaXR0YWJsZU1hcmtzOiBzdHJpbmdbXSA9IFtdXG5cbiAgY29uc3RydWN0b3IoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucywgZWRpdG9yOiBFZGl0b3IpIHtcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvclxuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IEV4dGVuc2lvbk1hbmFnZXIucmVzb2x2ZShleHRlbnNpb25zKVxuICAgIHRoaXMuc2NoZW1hID0gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zLCBlZGl0b3IpXG5cbiAgICB0aGlzLmV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgICAgLy8gc3RvcmUgZXh0ZW5zaW9uIHN0b3JhZ2UgaW4gZWRpdG9yXG4gICAgICB0aGlzLmVkaXRvci5leHRlbnNpb25TdG9yYWdlW2V4dGVuc2lvbi5uYW1lXSA9IGV4dGVuc2lvbi5zdG9yYWdlXG5cbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgIHR5cGU6IGdldFNjaGVtYVR5cGVCeU5hbWUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKSxcbiAgICAgIH1cblxuICAgICAgaWYgKGV4dGVuc2lvbi50eXBlID09PSAnbWFyaycpIHtcbiAgICAgICAgY29uc3Qga2VlcE9uU3BsaXQgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAna2VlcE9uU3BsaXQnLCBjb250ZXh0KSkgPz8gdHJ1ZVxuXG4gICAgICAgIGlmIChrZWVwT25TcGxpdCkge1xuICAgICAgICAgIHRoaXMuc3BsaXR0YWJsZU1hcmtzLnB1c2goZXh0ZW5zaW9uLm5hbWUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25CZWZvcmVDcmVhdGUgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ29uQmVmb3JlQ3JlYXRlJ10+KFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICdvbkJlZm9yZUNyZWF0ZScsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApXG5cbiAgICAgIGlmIChvbkJlZm9yZUNyZWF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbignYmVmb3JlQ3JlYXRlJywgb25CZWZvcmVDcmVhdGUpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uQ3JlYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvbkNyZWF0ZSddPihleHRlbnNpb24sICdvbkNyZWF0ZScsIGNvbnRleHQpXG5cbiAgICAgIGlmIChvbkNyZWF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbignY3JlYXRlJywgb25DcmVhdGUpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uVXBkYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvblVwZGF0ZSddPihleHRlbnNpb24sICdvblVwZGF0ZScsIGNvbnRleHQpXG5cbiAgICAgIGlmIChvblVwZGF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbigndXBkYXRlJywgb25VcGRhdGUpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uU2VsZWN0aW9uVXBkYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvblNlbGVjdGlvblVwZGF0ZSddPihcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAnb25TZWxlY3Rpb25VcGRhdGUnLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuXG4gICAgICBpZiAob25TZWxlY3Rpb25VcGRhdGUpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3NlbGVjdGlvblVwZGF0ZScsIG9uU2VsZWN0aW9uVXBkYXRlKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvblRyYW5zYWN0aW9uID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvblRyYW5zYWN0aW9uJ10+KFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICdvblRyYW5zYWN0aW9uJyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgIClcblxuICAgICAgaWYgKG9uVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3RyYW5zYWN0aW9uJywgb25UcmFuc2FjdGlvbilcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25Gb2N1cyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25Gb2N1cyddPihleHRlbnNpb24sICdvbkZvY3VzJywgY29udGV4dClcblxuICAgICAgaWYgKG9uRm9jdXMpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2ZvY3VzJywgb25Gb2N1cylcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25CbHVyID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvbkJsdXInXT4oZXh0ZW5zaW9uLCAnb25CbHVyJywgY29udGV4dClcblxuICAgICAgaWYgKG9uQmx1cikge1xuICAgICAgICB0aGlzLmVkaXRvci5vbignYmx1cicsIG9uQmx1cilcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25EZXN0cm95ID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvbkRlc3Ryb3knXT4oZXh0ZW5zaW9uLCAnb25EZXN0cm95JywgY29udGV4dClcblxuICAgICAgaWYgKG9uRGVzdHJveSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbignZGVzdHJveScsIG9uRGVzdHJveSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc3RhdGljIHJlc29sdmUoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyk6IEV4dGVuc2lvbnMge1xuICAgIGNvbnN0IHJlc29sdmVkRXh0ZW5zaW9ucyA9IEV4dGVuc2lvbk1hbmFnZXIuc29ydChFeHRlbnNpb25NYW5hZ2VyLmZsYXR0ZW4oZXh0ZW5zaW9ucykpXG4gICAgY29uc3QgZHVwbGljYXRlZE5hbWVzID0gZmluZER1cGxpY2F0ZXMocmVzb2x2ZWRFeHRlbnNpb25zLm1hcChleHRlbnNpb24gPT4gZXh0ZW5zaW9uLm5hbWUpKVxuXG4gICAgaWYgKGR1cGxpY2F0ZWROYW1lcy5sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFt0aXB0YXAgd2Fybl06IER1cGxpY2F0ZSBleHRlbnNpb24gbmFtZXMgZm91bmQ6IFske2R1cGxpY2F0ZWROYW1lc1xuICAgICAgICAgIC5tYXAoaXRlbSA9PiBgJyR7aXRlbX0nYClcbiAgICAgICAgICAuam9pbignLCAnKX1dLiBUaGlzIGNhbiBsZWFkIHRvIGlzc3Vlcy5gLFxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiByZXNvbHZlZEV4dGVuc2lvbnNcbiAgfVxuXG4gIHN0YXRpYyBmbGF0dGVuKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpOiBFeHRlbnNpb25zIHtcbiAgICByZXR1cm4gKFxuICAgICAgZXh0ZW5zaW9uc1xuICAgICAgICAubWFwKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBhZGRFeHRlbnNpb25zID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRFeHRlbnNpb25zJ10+KFxuICAgICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICAgJ2FkZEV4dGVuc2lvbnMnLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICApXG5cbiAgICAgICAgICBpZiAoYWRkRXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIFtleHRlbnNpb24sIC4uLnRoaXMuZmxhdHRlbihhZGRFeHRlbnNpb25zKCkpXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBleHRlbnNpb25cbiAgICAgICAgfSlcbiAgICAgICAgLy8gYEluZmluaXR5YCB3aWxsIGJyZWFrIFR5cGVTY3JpcHQgc28gd2Ugc2V0IGEgbnVtYmVyIHRoYXQgaXMgcHJvYmFibHkgaGlnaCBlbm91Z2hcbiAgICAgICAgLmZsYXQoMTApXG4gICAgKVxuICB9XG5cbiAgc3RhdGljIHNvcnQoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyk6IEV4dGVuc2lvbnMge1xuICAgIGNvbnN0IGRlZmF1bHRQcmlvcml0eSA9IDEwMFxuXG4gICAgcmV0dXJuIGV4dGVuc2lvbnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgcHJpb3JpdHlBID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydwcmlvcml0eSddPihhLCAncHJpb3JpdHknKSB8fCBkZWZhdWx0UHJpb3JpdHlcbiAgICAgIGNvbnN0IHByaW9yaXR5QiA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1sncHJpb3JpdHknXT4oYiwgJ3ByaW9yaXR5JykgfHwgZGVmYXVsdFByaW9yaXR5XG5cbiAgICAgIGlmIChwcmlvcml0eUEgPiBwcmlvcml0eUIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG5cbiAgICAgIGlmIChwcmlvcml0eUEgPCBwcmlvcml0eUIpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDBcbiAgICB9KVxuICB9XG5cbiAgZ2V0IGNvbW1hbmRzKCk6IFJhd0NvbW1hbmRzIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zLnJlZHVjZSgoY29tbWFuZHMsIGV4dGVuc2lvbikgPT4ge1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgdHlwZTogZ2V0U2NoZW1hVHlwZUJ5TmFtZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxuICAgICAgfVxuXG4gICAgICBjb25zdCBhZGRDb21tYW5kcyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkQ29tbWFuZHMnXT4oXG4gICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgJ2FkZENvbW1hbmRzJyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgIClcblxuICAgICAgaWYgKCFhZGRDb21tYW5kcykge1xuICAgICAgICByZXR1cm4gY29tbWFuZHNcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29tbWFuZHMsXG4gICAgICAgIC4uLmFkZENvbW1hbmRzKCksXG4gICAgICB9XG4gICAgfSwge30gYXMgUmF3Q29tbWFuZHMpXG4gIH1cblxuICBnZXQgcGx1Z2lucygpOiBQbHVnaW5bXSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXNcblxuICAgIC8vIFdpdGggUHJvc2VNaXJyb3IsIGZpcnN0IHBsdWdpbnMgd2l0aGluIGFuIGFycmF5IGFyZSBleGVjdXRlZCBmaXJzdC5cbiAgICAvLyBJbiBUaXB0YXAsIHdlIHByb3ZpZGUgdGhlIGFiaWxpdHkgdG8gb3ZlcnJpZGUgcGx1Z2lucyxcbiAgICAvLyBzbyBpdCBmZWVscyBtb3JlIG5hdHVyYWwgdG8gcnVuIHBsdWdpbnMgYXQgdGhlIGVuZCBvZiBhbiBhcnJheSBmaXJzdC5cbiAgICAvLyBUaGF04oCZcyB3aHkgd2UgaGF2ZSB0byByZXZlcnNlIHRoZSBgZXh0ZW5zaW9uc2AgYXJyYXkgYW5kIHNvcnQgYWdhaW5cbiAgICAvLyBiYXNlZCBvbiB0aGUgYHByaW9yaXR5YCBvcHRpb24uXG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IEV4dGVuc2lvbk1hbmFnZXIuc29ydChbLi4udGhpcy5leHRlbnNpb25zXS5yZXZlcnNlKCkpXG5cbiAgICBjb25zdCBpbnB1dFJ1bGVzOiBhbnlbXSA9IFtdXG4gICAgY29uc3QgcGFzdGVSdWxlczogYW55W10gPSBbXVxuXG4gICAgY29uc3QgYWxsUGx1Z2lucyA9IGV4dGVuc2lvbnNcbiAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgdHlwZTogZ2V0U2NoZW1hVHlwZUJ5TmFtZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGx1Z2luczogUGx1Z2luW10gPSBbXVxuXG4gICAgICAgIGNvbnN0IGFkZEtleWJvYXJkU2hvcnRjdXRzID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRLZXlib2FyZFNob3J0Y3V0cyddPihcbiAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgJ2FkZEtleWJvYXJkU2hvcnRjdXRzJyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICApXG5cbiAgICAgICAgbGV0IGRlZmF1bHRCaW5kaW5nczogUmVjb3JkPHN0cmluZywgKCkgPT4gYm9vbGVhbj4gPSB7fVxuXG4gICAgICAgIC8vIGJpbmQgZXhpdCBoYW5kbGluZ1xuICAgICAgICBpZiAoZXh0ZW5zaW9uLnR5cGUgPT09ICdtYXJrJyAmJiBleHRlbnNpb24uY29uZmlnLmV4aXRhYmxlKSB7XG4gICAgICAgICAgZGVmYXVsdEJpbmRpbmdzLkFycm93UmlnaHQgPSAoKSA9PiBNYXJrLmhhbmRsZUV4aXQoeyBlZGl0b3IsIG1hcms6IGV4dGVuc2lvbiBhcyBNYXJrIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWRkS2V5Ym9hcmRTaG9ydGN1dHMpIHtcbiAgICAgICAgICBjb25zdCBiaW5kaW5ncyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGFkZEtleWJvYXJkU2hvcnRjdXRzKCkpLm1hcCgoW3Nob3J0Y3V0LCBtZXRob2RdKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBbc2hvcnRjdXQsICgpID0+IG1ldGhvZCh7IGVkaXRvciB9KV1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIClcblxuICAgICAgICAgIGRlZmF1bHRCaW5kaW5ncyA9IHsgLi4uZGVmYXVsdEJpbmRpbmdzLCAuLi5iaW5kaW5ncyB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBrZXlNYXBQbHVnaW4gPSBrZXltYXAoZGVmYXVsdEJpbmRpbmdzKVxuXG4gICAgICAgIHBsdWdpbnMucHVzaChrZXlNYXBQbHVnaW4pXG5cbiAgICAgICAgY29uc3QgYWRkSW5wdXRSdWxlcyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkSW5wdXRSdWxlcyddPihcbiAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgJ2FkZElucHV0UnVsZXMnLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIClcblxuICAgICAgICBpZiAoaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQoZXh0ZW5zaW9uLCBlZGl0b3Iub3B0aW9ucy5lbmFibGVJbnB1dFJ1bGVzKSAmJiBhZGRJbnB1dFJ1bGVzKSB7XG4gICAgICAgICAgaW5wdXRSdWxlcy5wdXNoKC4uLmFkZElucHV0UnVsZXMoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFkZFBhc3RlUnVsZXMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFBhc3RlUnVsZXMnXT4oXG4gICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICdhZGRQYXN0ZVJ1bGVzJyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkKGV4dGVuc2lvbiwgZWRpdG9yLm9wdGlvbnMuZW5hYmxlUGFzdGVSdWxlcykgJiYgYWRkUGFzdGVSdWxlcykge1xuICAgICAgICAgIHBhc3RlUnVsZXMucHVzaCguLi5hZGRQYXN0ZVJ1bGVzKCkpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhZGRQcm9zZU1pcnJvclBsdWdpbnMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFByb3NlTWlycm9yUGx1Z2lucyddPihcbiAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgJ2FkZFByb3NlTWlycm9yUGx1Z2lucycsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChhZGRQcm9zZU1pcnJvclBsdWdpbnMpIHtcbiAgICAgICAgICBjb25zdCBwcm9zZU1pcnJvclBsdWdpbnMgPSBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKVxuXG4gICAgICAgICAgcGx1Z2lucy5wdXNoKC4uLnByb3NlTWlycm9yUGx1Z2lucylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwbHVnaW5zXG4gICAgICB9KVxuICAgICAgLmZsYXQoKVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIGlucHV0UnVsZXNQbHVnaW4oe1xuICAgICAgICBlZGl0b3IsXG4gICAgICAgIHJ1bGVzOiBpbnB1dFJ1bGVzLFxuICAgICAgfSksXG4gICAgICAuLi5wYXN0ZVJ1bGVzUGx1Z2luKHtcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICBydWxlczogcGFzdGVSdWxlcyxcbiAgICAgIH0pLFxuICAgICAgLi4uYWxsUGx1Z2lucyxcbiAgICBdXG4gIH1cblxuICBnZXQgYXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucylcbiAgfVxuXG4gIGdldCBub2RlVmlld3MoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXNcbiAgICBjb25zdCB7IG5vZGVFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKVxuXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIG5vZGVFeHRlbnNpb25zXG4gICAgICAgIC5maWx0ZXIoZXh0ZW5zaW9uID0+ICEhZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkTm9kZVZpZXcnKSlcbiAgICAgICAgLm1hcChleHRlbnNpb24gPT4ge1xuICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgYXR0cmlidXRlID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIHR5cGU6IGdldE5vZGVUeXBlKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGFkZE5vZGVWaWV3ID0gZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snYWRkTm9kZVZpZXcnXT4oXG4gICAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgICAnYWRkTm9kZVZpZXcnLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICApXG5cbiAgICAgICAgICBpZiAoIWFkZE5vZGVWaWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBub2RldmlldyA9IChcbiAgICAgICAgICAgIG5vZGU6IFByb3NlbWlycm9yTm9kZSxcbiAgICAgICAgICAgIHZpZXc6IEVkaXRvclZpZXcsXG4gICAgICAgICAgICBnZXRQb3M6ICgoKSA9PiBudW1iZXIpIHwgYm9vbGVhbixcbiAgICAgICAgICAgIGRlY29yYXRpb25zOiBEZWNvcmF0aW9uW10sXG4gICAgICAgICAgKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBIVE1MQXR0cmlidXRlcyA9IGdldFJlbmRlcmVkQXR0cmlidXRlcyhub2RlLCBleHRlbnNpb25BdHRyaWJ1dGVzKVxuXG4gICAgICAgICAgICByZXR1cm4gYWRkTm9kZVZpZXcoKSh7XG4gICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgZ2V0UG9zLFxuICAgICAgICAgICAgICBkZWNvcmF0aW9ucyxcbiAgICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb24ubmFtZSwgbm9kZXZpZXddXG4gICAgICAgIH0pLFxuICAgIClcbiAgfVxufVxuIiwgIi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL21lc3F1ZWViL2lzLXdoYXQvYmxvYi84OGQ2ZTRjYTkyZmIyYmFhYjYwMDNjNTRlMDJlZWRmNGU3MjllNWFiL3NyYy9pbmRleC50c1xuXG5mdW5jdGlvbiBnZXRUeXBlKHZhbHVlOiBhbnkpOiBzdHJpbmcge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWU6IGFueSk6IHZhbHVlIGlzIFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBpZiAoZ2V0VHlwZSh2YWx1ZSkgIT09ICdPYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBPYmplY3QucHJvdG90eXBlXG59XG4iLCAiaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4vaXNQbGFpbk9iamVjdC5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGVlcCh0YXJnZXQ6IFJlY29yZDxzdHJpbmcsIGFueT4sIHNvdXJjZTogUmVjb3JkPHN0cmluZywgYW55Pik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCBvdXRwdXQgPSB7IC4uLnRhcmdldCB9XG5cbiAgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiBpc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3V0cHV0LCB7IFtrZXldOiBzb3VyY2Vba2V5XSB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dFtrZXldID0gbWVyZ2VEZWVwKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvdXRwdXQsIHsgW2tleV06IHNvdXJjZVtrZXldIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cbiIsICJpbXBvcnQgeyBQbHVnaW4sIFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vaGVscGVycy9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IEV4dGVuc2lvbkNvbmZpZyB9IGZyb20gJy4vaW5kZXguanMnXG5pbXBvcnQgeyBJbnB1dFJ1bGUgfSBmcm9tICcuL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IE1hcmsgfSBmcm9tICcuL01hcmsuanMnXG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi9Ob2RlLmpzJ1xuaW1wb3J0IHsgUGFzdGVSdWxlIH0gZnJvbSAnLi9QYXN0ZVJ1bGUuanMnXG5pbXBvcnQge1xuICBBbnlDb25maWcsXG4gIEV4dGVuc2lvbnMsXG4gIEdsb2JhbEF0dHJpYnV0ZXMsXG4gIEtleWJvYXJkU2hvcnRjdXRDb21tYW5kLFxuICBQYXJlbnRDb25maWcsXG4gIFJhd0NvbW1hbmRzLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuaW1wb3J0IHsgbWVyZ2VEZWVwIH0gZnJvbSAnLi91dGlsaXRpZXMvbWVyZ2VEZWVwLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBFeHRlbnNpb25Db25maWc8T3B0aW9ucyA9IGFueSwgU3RvcmFnZSA9IGFueT4ge1xuICAgIFtrZXk6IHN0cmluZ106IGFueVxuXG4gICAgLyoqXG4gICAgICogTmFtZVxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZ1xuXG4gICAgLyoqXG4gICAgICogUHJpb3JpdHlcbiAgICAgKi9cbiAgICBwcmlvcml0eT86IG51bWJlclxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBvcHRpb25zXG4gICAgICovXG4gICAgZGVmYXVsdE9wdGlvbnM/OiBPcHRpb25zXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IE9wdGlvbnNcbiAgICAgKi9cbiAgICBhZGRPcHRpb25zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgcGFyZW50OiBFeGNsdWRlPFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRPcHRpb25zJ10sIHVuZGVmaW5lZD5cbiAgICB9KSA9PiBPcHRpb25zXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IFN0b3JhZ2VcbiAgICAgKi9cbiAgICBhZGRTdG9yYWdlPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgcGFyZW50OiBFeGNsdWRlPFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRTdG9yYWdlJ10sIHVuZGVmaW5lZD5cbiAgICB9KSA9PiBTdG9yYWdlXG5cbiAgICAvKipcbiAgICAgKiBHbG9iYWwgYXR0cmlidXRlc1xuICAgICAqL1xuICAgIGFkZEdsb2JhbEF0dHJpYnV0ZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRHbG9iYWxBdHRyaWJ1dGVzJ11cbiAgICB9KSA9PiBHbG9iYWxBdHRyaWJ1dGVzIHwge31cblxuICAgIC8qKlxuICAgICAqIFJhd1xuICAgICAqL1xuICAgIGFkZENvbW1hbmRzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZENvbW1hbmRzJ11cbiAgICB9KSA9PiBQYXJ0aWFsPFJhd0NvbW1hbmRzPlxuXG4gICAgLyoqXG4gICAgICogS2V5Ym9hcmQgc2hvcnRjdXRzXG4gICAgICovXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkS2V5Ym9hcmRTaG9ydGN1dHMnXVxuICAgIH0pID0+IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IEtleWJvYXJkU2hvcnRjdXRDb21tYW5kXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5wdXQgcnVsZXNcbiAgICAgKi9cbiAgICBhZGRJbnB1dFJ1bGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZElucHV0UnVsZXMnXVxuICAgIH0pID0+IElucHV0UnVsZVtdXG5cbiAgICAvKipcbiAgICAgKiBQYXN0ZSBydWxlc1xuICAgICAqL1xuICAgIGFkZFBhc3RlUnVsZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkUGFzdGVSdWxlcyddXG4gICAgfSkgPT4gUGFzdGVSdWxlW11cblxuICAgIC8qKlxuICAgICAqIFByb3NlTWlycm9yIHBsdWdpbnNcbiAgICAgKi9cbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkUHJvc2VNaXJyb3JQbHVnaW5zJ11cbiAgICB9KSA9PiBQbHVnaW5bXVxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5zaW9uc1xuICAgICAqL1xuICAgIGFkZEV4dGVuc2lvbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRFeHRlbnNpb25zJ11cbiAgICB9KSA9PiBFeHRlbnNpb25zXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgTm9kZSBTY2hlbWFcbiAgICAgKi9cbiAgICBleHRlbmROb2RlU2NoZW1hPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4dGVuZE5vZGVTY2hlbWEnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXh0ZW5zaW9uOiBOb2RlLFxuICAgICAgICApID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBNYXJrIFNjaGVtYVxuICAgICAqL1xuICAgIGV4dGVuZE1hcmtTY2hlbWE/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZXh0ZW5kTWFya1NjaGVtYSddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHRlbnNpb246IE1hcmssXG4gICAgICAgICkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBub3QgcmVhZHkgeWV0LlxuICAgICAqL1xuICAgIG9uQmVmb3JlQ3JlYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uQmVmb3JlQ3JlYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyByZWFkeS5cbiAgICAgKi9cbiAgICBvbkNyZWF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkNyZWF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZW50IGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uVXBkYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uVXBkYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdGlvbiBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblNlbGVjdGlvblVwZGF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblNlbGVjdGlvblVwZGF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3Igc3RhdGUgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25UcmFuc2FjdGlvbj86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25UcmFuc2FjdGlvbiddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGZvY3VzZWQuXG4gICAgICovXG4gICAgb25Gb2N1cz86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25Gb2N1cyddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZXZlbnQ6IEZvY3VzRXZlbnRcbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXNu4oCZdCBmb2N1c2VkIGFueW1vcmUuXG4gICAgICovXG4gICAgb25CbHVyPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkJsdXInXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGV2ZW50OiBGb2N1c0V2ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBvbkRlc3Ryb3k/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25EZXN0cm95J11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBFeHRlbnNpb248T3B0aW9ucyA9IGFueSwgU3RvcmFnZSA9IGFueT4ge1xuICB0eXBlID0gJ2V4dGVuc2lvbidcblxuICBuYW1lID0gJ2V4dGVuc2lvbidcblxuICBwYXJlbnQ6IEV4dGVuc2lvbiB8IG51bGwgPSBudWxsXG5cbiAgY2hpbGQ6IEV4dGVuc2lvbiB8IG51bGwgPSBudWxsXG5cbiAgb3B0aW9uczogT3B0aW9uc1xuXG4gIHN0b3JhZ2U6IFN0b3JhZ2VcblxuICBjb25maWc6IEV4dGVuc2lvbkNvbmZpZyA9IHtcbiAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgZGVmYXVsdE9wdGlvbnM6IHt9LFxuICB9XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBQYXJ0aWFsPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj4gPSB7fSkge1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICAuLi5jb25maWcsXG4gICAgfVxuXG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25maWcubmFtZVxuXG4gICAgaWYgKGNvbmZpZy5kZWZhdWx0T3B0aW9ucykge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHt0aGlzLm5hbWV9XCIuYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgYGFkZE9wdGlvbnNgIGZhbGxiYWNrXG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5jb25maWcuZGVmYXVsdE9wdGlvbnNcblxuICAgIGlmICh0aGlzLmNvbmZpZy5hZGRPcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkT3B0aW9ucyddPih0aGlzLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIH0pLFxuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMuc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPih0aGlzLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApIHx8IHt9XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlPE8gPSBhbnksIFMgPSBhbnk+KGNvbmZpZzogUGFydGlhbDxFeHRlbnNpb25Db25maWc8TywgUz4+ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEV4dGVuc2lvbjxPLCBTPihjb25maWcpXG4gIH1cblxuICBjb25maWd1cmUob3B0aW9uczogUGFydGlhbDxPcHRpb25zPiA9IHt9KSB7XG4gICAgLy8gcmV0dXJuIGEgbmV3IGluc3RhbmNlIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgZXh0ZW5zaW9uXG4gICAgLy8gd2l0aCBkaWZmZXJlbnQgY2FsbHMgb2YgYGNvbmZpZ3VyZWBcbiAgICBjb25zdCBleHRlbnNpb24gPSB0aGlzLmV4dGVuZCgpXG5cbiAgICBleHRlbnNpb24ub3B0aW9ucyA9IG1lcmdlRGVlcCh0aGlzLm9wdGlvbnMgYXMgUmVjb3JkPHN0cmluZywgYW55Piwgb3B0aW9ucykgYXMgT3B0aW9uc1xuXG4gICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4oZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG5cbiAgZXh0ZW5kPEV4dGVuZGVkT3B0aW9ucyA9IE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZSA9IFN0b3JhZ2U+KFxuICAgIGV4dGVuZGVkQ29uZmlnOiBQYXJ0aWFsPEV4dGVuc2lvbkNvbmZpZzxFeHRlbmRlZE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZT4+ID0ge30sXG4gICkge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5ldyBFeHRlbnNpb248RXh0ZW5kZWRPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2U+KGV4dGVuZGVkQ29uZmlnKVxuXG4gICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXNcblxuICAgIHRoaXMuY2hpbGQgPSBleHRlbnNpb25cblxuICAgIGV4dGVuc2lvbi5uYW1lID0gZXh0ZW5kZWRDb25maWcubmFtZSA/IGV4dGVuZGVkQ29uZmlnLm5hbWUgOiBleHRlbnNpb24ucGFyZW50Lm5hbWVcblxuICAgIGlmIChleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucykge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHtleHRlbnNpb24ubmFtZX1cIi5gLFxuICAgICAgKVxuICAgIH1cblxuICAgIGV4dGVuc2lvbi5vcHRpb25zID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRPcHRpb25zJ10+KGV4dGVuc2lvbiwgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4oZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBSYW5nZSwgVGV4dFNlcmlhbGl6ZXIgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRleHRCZXR3ZWVuKFxuICBzdGFydE5vZGU6IFByb3NlTWlycm9yTm9kZSxcbiAgcmFuZ2U6IFJhbmdlLFxuICBvcHRpb25zPzoge1xuICAgIGJsb2NrU2VwYXJhdG9yPzogc3RyaW5nXG4gICAgdGV4dFNlcmlhbGl6ZXJzPzogUmVjb3JkPHN0cmluZywgVGV4dFNlcmlhbGl6ZXI+XG4gIH0sXG4pOiBzdHJpbmcge1xuICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZVxuICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gJ1xcblxcbicsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9XG4gIGxldCB0ZXh0ID0gJydcbiAgbGV0IHNlcGFyYXRlZCA9IHRydWVcblxuICBzdGFydE5vZGUubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zLCBwYXJlbnQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgdGV4dFNlcmlhbGl6ZXIgPSB0ZXh0U2VyaWFsaXplcnM/Lltub2RlLnR5cGUubmFtZV1cblxuICAgIGlmICh0ZXh0U2VyaWFsaXplcikge1xuICAgICAgaWYgKG5vZGUuaXNCbG9jayAmJiAhc2VwYXJhdGVkKSB7XG4gICAgICAgIHRleHQgKz0gYmxvY2tTZXBhcmF0b3JcbiAgICAgICAgc2VwYXJhdGVkID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHRleHQgKz0gdGV4dFNlcmlhbGl6ZXIoe1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgcG9zLFxuICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICByYW5nZSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICB0ZXh0ICs9IG5vZGU/LnRleHQ/LnNsaWNlKE1hdGgubWF4KGZyb20sIHBvcykgLSBwb3MsIHRvIC0gcG9zKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBzZXBhcmF0ZWQgPSBmYWxzZVxuICAgIH0gZWxzZSBpZiAobm9kZS5pc0Jsb2NrICYmICFzZXBhcmF0ZWQpIHtcbiAgICAgIHRleHQgKz0gYmxvY2tTZXBhcmF0b3JcbiAgICAgIHNlcGFyYXRlZCA9IHRydWVcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHRleHRcbn1cbiIsICJpbXBvcnQgeyBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBUZXh0U2VyaWFsaXplciB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWE6IFNjaGVtYSk6IFJlY29yZDxzdHJpbmcsIFRleHRTZXJpYWxpemVyPiB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hLm5vZGVzKVxuICAgICAgLmZpbHRlcigoWywgbm9kZV0pID0+IG5vZGUuc3BlYy50b1RleHQpXG4gICAgICAubWFwKChbbmFtZSwgbm9kZV0pID0+IFtuYW1lLCBub2RlLnNwZWMudG9UZXh0XSksXG4gIClcbn1cbiIsICJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcbmltcG9ydCB7IGdldFRleHRCZXR3ZWVuIH0gZnJvbSAnLi4vaGVscGVycy9nZXRUZXh0QmV0d2Vlbi5qcydcbmltcG9ydCB7IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEgfSBmcm9tICcuLi9oZWxwZXJzL2dldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEuanMnXG5cbmV4cG9ydCBjb25zdCBDbGlwYm9hcmRUZXh0U2VyaWFsaXplciA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAnY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXInLFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXInKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBjbGlwYm9hcmRUZXh0U2VyaWFsaXplcjogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXNcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUsIHNjaGVtYSB9ID0gZWRpdG9yXG4gICAgICAgICAgICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICAgICAgICAgICAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvblxuICAgICAgICAgICAgY29uc3QgZnJvbSA9IE1hdGgubWluKC4uLnJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuJGZyb20ucG9zKSlcbiAgICAgICAgICAgIGNvbnN0IHRvID0gTWF0aC5tYXgoLi4ucmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS4kdG8ucG9zKSlcbiAgICAgICAgICAgIGNvbnN0IHRleHRTZXJpYWxpemVycyA9IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hKVxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB7IGZyb20sIHRvIH1cblxuICAgICAgICAgICAgcmV0dXJuIGdldFRleHRCZXR3ZWVuKGRvYywgcmFuZ2UsIHtcbiAgICAgICAgICAgICAgdGV4dFNlcmlhbGl6ZXJzLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgYmx1cjoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGZvY3VzIGZyb20gdGhlIGVkaXRvci5cbiAgICAgICAqL1xuICAgICAgYmx1cjogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGJsdXI6IFJhd0NvbW1hbmRzWydibHVyJ10gPSAoKSA9PiAoeyBlZGl0b3IsIHZpZXcgfSkgPT4ge1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAodmlldy5kb20gYXMgSFRNTEVsZW1lbnQpLmJsdXIoKVxuXG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgcmVtb3ZlIHRoZSBjYXJldCBvbiBibHVyIGJ1dCBzYWZhcmkgZG9lcyBub3QuXG4gICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMjQwNVxuICAgICAgd2luZG93Py5nZXRTZWxlY3Rpb24oKT8ucmVtb3ZlQWxsUmFuZ2VzKClcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgY2xlYXJDb250ZW50OiB7XG4gICAgICAvKipcbiAgICAgICAqIENsZWFyIHRoZSB3aG9sZSBkb2N1bWVudC5cbiAgICAgICAqL1xuICAgICAgY2xlYXJDb250ZW50OiAoZW1pdFVwZGF0ZT86IGJvb2xlYW4pID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjbGVhckNvbnRlbnQ6IFJhd0NvbW1hbmRzWydjbGVhckNvbnRlbnQnXSA9IChlbWl0VXBkYXRlID0gZmFsc2UpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgcmV0dXJuIGNvbW1hbmRzLnNldENvbnRlbnQoJycsIGVtaXRVcGRhdGUpXG59XG4iLCAiaW1wb3J0IHsgbGlmdFRhcmdldCB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgY2xlYXJOb2Rlczoge1xuICAgICAgLyoqXG4gICAgICAgKiBOb3JtYWxpemUgbm9kZXMgdG8gYSBzaW1wbGUgcGFyYWdyYXBoLlxuICAgICAgICovXG4gICAgICBjbGVhck5vZGVzOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY2xlYXJOb2RlczogUmF3Q29tbWFuZHNbJ2NsZWFyTm9kZXMnXSA9ICgpID0+ICh7IHN0YXRlLCB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHJcbiAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvblxuXG4gIGlmICghZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmFuZ2VzLmZvckVhY2goKHsgJGZyb20sICR0byB9KSA9PiB7XG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIChub2RlLCBwb3MpID0+IHtcbiAgICAgIGlmIChub2RlLnR5cGUuaXNUZXh0KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGRvYywgbWFwcGluZyB9ID0gdHJcbiAgICAgIGNvbnN0ICRtYXBwZWRGcm9tID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAocG9zKSlcbiAgICAgIGNvbnN0ICRtYXBwZWRUbyA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHBvcyArIG5vZGUubm9kZVNpemUpKVxuICAgICAgY29uc3Qgbm9kZVJhbmdlID0gJG1hcHBlZEZyb20uYmxvY2tSYW5nZSgkbWFwcGVkVG8pXG5cbiAgICAgIGlmICghbm9kZVJhbmdlKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB0YXJnZXRMaWZ0RGVwdGggPSBsaWZ0VGFyZ2V0KG5vZGVSYW5nZSlcblxuICAgICAgaWYgKG5vZGUudHlwZS5pc1RleHRibG9jaykge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHRUeXBlIH0gPSAkbWFwcGVkRnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJG1hcHBlZEZyb20uaW5kZXgoKSlcblxuICAgICAgICB0ci5zZXROb2RlTWFya3VwKG5vZGVSYW5nZS5zdGFydCwgZGVmYXVsdFR5cGUpXG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXRMaWZ0RGVwdGggfHwgdGFyZ2V0TGlmdERlcHRoID09PSAwKSB7XG4gICAgICAgIHRyLmxpZnQobm9kZVJhbmdlLCB0YXJnZXRMaWZ0RGVwdGgpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IENvbW1hbmQsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBjb21tYW5kOiB7XG4gICAgICAvKipcbiAgICAgICAqIERlZmluZSBhIGNvbW1hbmQgaW5saW5lLlxuICAgICAgICovXG4gICAgICBjb21tYW5kOiAoZm46IChwcm9wczogUGFyYW1ldGVyczxDb21tYW5kPlswXSkgPT4gYm9vbGVhbikgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNvbW1hbmQ6IFJhd0NvbW1hbmRzWydjb21tYW5kJ10gPSBmbiA9PiBwcm9wcyA9PiB7XG4gIHJldHVybiBmbihwcm9wcylcbn1cbiIsICJpbXBvcnQgeyBjcmVhdGVQYXJhZ3JhcGhOZWFyIGFzIG9yaWdpbmFsQ3JlYXRlUGFyYWdyYXBoTmVhciB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBjcmVhdGVQYXJhZ3JhcGhOZWFyOiB7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSBhIHBhcmFncmFwaCBuZWFyYnkuXG4gICAgICAgKi9cbiAgICAgIGNyZWF0ZVBhcmFncmFwaE5lYXI6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVBhcmFncmFwaE5lYXI6IFJhd0NvbW1hbmRzWydjcmVhdGVQYXJhZ3JhcGhOZWFyJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxDcmVhdGVQYXJhZ3JhcGhOZWFyKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGN1dDoge1xuICAgICAgLyoqXG4gICAgICAgKiBDdXRzIGNvbnRlbnQgZnJvbSBhIHJhbmdlIGFuZCBpbnNlcnRzIGl0IGF0IGEgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICAgKi9cbiAgICAgIGN1dDogKHsgZnJvbSwgdG8gfTogeyBmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIgfSwgdGFyZ2V0UG9zOiBudW1iZXIpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjdXQ6IFJhd0NvbW1hbmRzWydjdXQnXSA9IChvcmlnaW5SYW5nZSwgdGFyZ2V0UG9zKSA9PiAoeyBlZGl0b3IsIHRyIH0pID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yXG5cbiAgY29uc3QgY29udGVudFNsaWNlID0gc3RhdGUuZG9jLnNsaWNlKG9yaWdpblJhbmdlLmZyb20sIG9yaWdpblJhbmdlLnRvKVxuXG4gIHRyLmRlbGV0ZVJhbmdlKG9yaWdpblJhbmdlLmZyb20sIG9yaWdpblJhbmdlLnRvKVxuICBjb25zdCBuZXdQb3MgPSB0ci5tYXBwaW5nLm1hcCh0YXJnZXRQb3MpXG5cbiAgdHIuaW5zZXJ0KG5ld1BvcywgY29udGVudFNsaWNlLmNvbnRlbnQpXG5cbiAgdHIuc2V0U2VsZWN0aW9uKG5ldyBUZXh0U2VsZWN0aW9uKHRyLmRvYy5yZXNvbHZlKG5ld1BvcyAtIDEpKSlcblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBkZWxldGVDdXJyZW50Tm9kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBEZWxldGUgdGhlIG5vZGUgdGhhdCBjdXJyZW50bHkgaGFzIHRoZSBzZWxlY3Rpb24gYW5jaG9yLlxuICAgICAgICovXG4gICAgICBkZWxldGVDdXJyZW50Tm9kZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlbGV0ZUN1cnJlbnROb2RlOiBSYXdDb21tYW5kc1snZGVsZXRlQ3VycmVudE5vZGUnXSA9ICgpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0clxuICBjb25zdCBjdXJyZW50Tm9kZSA9IHNlbGVjdGlvbi4kYW5jaG9yLm5vZGUoKVxuXG4gIC8vIGlmIHRoZXJlIGlzIGNvbnRlbnQgaW5zaWRlIHRoZSBjdXJyZW50IG5vZGUsIGJyZWFrIG91dCBvZiB0aGlzIGNvbW1hbmRcbiAgaWYgKGN1cnJlbnROb2RlLmNvbnRlbnQuc2l6ZSA+IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0ICRwb3MgPSB0ci5zZWxlY3Rpb24uJGFuY2hvclxuXG4gIGZvciAobGV0IGRlcHRoID0gJHBvcy5kZXB0aDsgZGVwdGggPiAwOyBkZXB0aCAtPSAxKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRwb3Mubm9kZShkZXB0aClcblxuICAgIGlmIChub2RlLnR5cGUgPT09IGN1cnJlbnROb2RlLnR5cGUpIHtcbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCBmcm9tID0gJHBvcy5iZWZvcmUoZGVwdGgpXG4gICAgICAgIGNvbnN0IHRvID0gJHBvcy5hZnRlcihkZXB0aClcblxuICAgICAgICB0ci5kZWxldGUoZnJvbSwgdG8pLnNjcm9sbEludG9WaWV3KClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBkZWxldGVOb2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIERlbGV0ZSBhIG5vZGUuXG4gICAgICAgKi9cbiAgICAgIGRlbGV0ZU5vZGU6ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlbGV0ZU5vZGU6IFJhd0NvbW1hbmRzWydkZWxldGVOb2RlJ10gPSB0eXBlT3JOYW1lID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCAkcG9zID0gdHIuc2VsZWN0aW9uLiRhbmNob3JcblxuICBmb3IgKGxldCBkZXB0aCA9ICRwb3MuZGVwdGg7IGRlcHRoID4gMDsgZGVwdGggLT0gMSkge1xuICAgIGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoZGVwdGgpXG5cbiAgICBpZiAobm9kZS50eXBlID09PSB0eXBlKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgZnJvbSA9ICRwb3MuYmVmb3JlKGRlcHRoKVxuICAgICAgICBjb25zdCB0byA9ICRwb3MuYWZ0ZXIoZGVwdGgpXG5cbiAgICAgICAgdHIuZGVsZXRlKGZyb20sIHRvKS5zY3JvbGxJbnRvVmlldygpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCAiaW1wb3J0IHsgUmFuZ2UsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBkZWxldGVSYW5nZToge1xuICAgICAgLyoqXG4gICAgICAgKiBEZWxldGUgYSBnaXZlbiByYW5nZS5cbiAgICAgICAqL1xuICAgICAgZGVsZXRlUmFuZ2U6IChyYW5nZTogUmFuZ2UpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWxldGVSYW5nZTogUmF3Q29tbWFuZHNbJ2RlbGV0ZVJhbmdlJ10gPSByYW5nZSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHRyLmRlbGV0ZShmcm9tLCB0bylcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgZGVsZXRlU2VsZWN0aW9uIGFzIG9yaWdpbmFsRGVsZXRlU2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGRlbGV0ZVNlbGVjdGlvbjoge1xuICAgICAgLyoqXG4gICAgICAgKiBEZWxldGUgdGhlIHNlbGVjdGlvbiwgaWYgdGhlcmUgaXMgb25lLlxuICAgICAgICovXG4gICAgICBkZWxldGVTZWxlY3Rpb246ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlbGV0ZVNlbGVjdGlvbjogUmF3Q29tbWFuZHNbJ2RlbGV0ZVNlbGVjdGlvbiddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsRGVsZXRlU2VsZWN0aW9uKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZW50ZXI6IHtcbiAgICAgIC8qKlxuICAgICAgICogVHJpZ2dlciBlbnRlci5cbiAgICAgICAqL1xuICAgICAgZW50ZXI6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBlbnRlcjogUmF3Q29tbWFuZHNbJ2VudGVyJ10gPSAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gIHJldHVybiBjb21tYW5kcy5rZXlib2FyZFNob3J0Y3V0KCdFbnRlcicpXG59XG4iLCAiaW1wb3J0IHsgZXhpdENvZGUgYXMgb3JpZ2luYWxFeGl0Q29kZSB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBleGl0Q29kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBFeGl0IGZyb20gYSBjb2RlIGJsb2NrLlxuICAgICAgICovXG4gICAgICBleGl0Q29kZTogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZXhpdENvZGU6IFJhd0NvbW1hbmRzWydleGl0Q29kZSddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsRXhpdENvZGUoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IGlzUmVnRXhwIH0gZnJvbSAnLi9pc1JlZ0V4cC5qcydcblxuLyoqXG4gKiBDaGVjayBpZiBvYmplY3QxIGluY2x1ZGVzIG9iamVjdDJcbiAqIEBwYXJhbSBvYmplY3QxIE9iamVjdFxuICogQHBhcmFtIG9iamVjdDIgT2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3RJbmNsdWRlcyhcbiAgb2JqZWN0MTogUmVjb3JkPHN0cmluZywgYW55PixcbiAgb2JqZWN0MjogUmVjb3JkPHN0cmluZywgYW55PixcbiAgb3B0aW9uczogeyBzdHJpY3Q6IGJvb2xlYW4gfSA9IHsgc3RyaWN0OiB0cnVlIH0sXG4pOiBib29sZWFuIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdDIpXG5cbiAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4ga2V5cy5ldmVyeShrZXkgPT4ge1xuICAgIGlmIChvcHRpb25zLnN0cmljdCkge1xuICAgICAgcmV0dXJuIG9iamVjdDJba2V5XSA9PT0gb2JqZWN0MVtrZXldXG4gICAgfVxuXG4gICAgaWYgKGlzUmVnRXhwKG9iamVjdDJba2V5XSkpIHtcbiAgICAgIHJldHVybiBvYmplY3QyW2tleV0udGVzdChvYmplY3QxW2tleV0pXG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdDJba2V5XSA9PT0gb2JqZWN0MVtrZXldXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgTWFyayBhcyBQcm9zZU1pcnJvck1hcmssIE1hcmtUeXBlLCBSZXNvbHZlZFBvcyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBvYmplY3RJbmNsdWRlcyB9IGZyb20gJy4uL3V0aWxpdGllcy9vYmplY3RJbmNsdWRlcy5qcydcblxuZnVuY3Rpb24gZmluZE1hcmtJblNldChcbiAgbWFya3M6IFByb3NlTWlycm9yTWFya1tdLFxuICB0eXBlOiBNYXJrVHlwZSxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogUHJvc2VNaXJyb3JNYXJrIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIG1hcmtzLmZpbmQoaXRlbSA9PiB7XG4gICAgcmV0dXJuIGl0ZW0udHlwZSA9PT0gdHlwZSAmJiBvYmplY3RJbmNsdWRlcyhpdGVtLmF0dHJzLCBhdHRyaWJ1dGVzKVxuICB9KVxufVxuXG5mdW5jdGlvbiBpc01hcmtJblNldChcbiAgbWFya3M6IFByb3NlTWlycm9yTWFya1tdLFxuICB0eXBlOiBNYXJrVHlwZSxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogYm9vbGVhbiB7XG4gIHJldHVybiAhIWZpbmRNYXJrSW5TZXQobWFya3MsIHR5cGUsIGF0dHJpYnV0ZXMpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXJrUmFuZ2UoXG4gICRwb3M6IFJlc29sdmVkUG9zLFxuICB0eXBlOiBNYXJrVHlwZSxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogUmFuZ2UgfCB2b2lkIHtcbiAgaWYgKCEkcG9zIHx8ICF0eXBlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgc3RhcnQgPSAkcG9zLnBhcmVudC5jaGlsZEFmdGVyKCRwb3MucGFyZW50T2Zmc2V0KVxuXG4gIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PT0gc3RhcnQub2Zmc2V0ICYmIHN0YXJ0Lm9mZnNldCAhPT0gMCkge1xuICAgIHN0YXJ0ID0gJHBvcy5wYXJlbnQuY2hpbGRCZWZvcmUoJHBvcy5wYXJlbnRPZmZzZXQpXG4gIH1cblxuICBpZiAoIXN0YXJ0Lm5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IG1hcmsgPSBmaW5kTWFya0luU2V0KFsuLi5zdGFydC5ub2RlLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcylcblxuICBpZiAoIW1hcmspIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGxldCBzdGFydEluZGV4ID0gc3RhcnQuaW5kZXhcbiAgbGV0IHN0YXJ0UG9zID0gJHBvcy5zdGFydCgpICsgc3RhcnQub2Zmc2V0XG4gIGxldCBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyAxXG4gIGxldCBlbmRQb3MgPSBzdGFydFBvcyArIHN0YXJ0Lm5vZGUubm9kZVNpemVcblxuICBmaW5kTWFya0luU2V0KFsuLi5zdGFydC5ub2RlLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcylcblxuICB3aGlsZSAoc3RhcnRJbmRleCA+IDAgJiYgbWFyay5pc0luU2V0KCRwb3MucGFyZW50LmNoaWxkKHN0YXJ0SW5kZXggLSAxKS5tYXJrcykpIHtcbiAgICBzdGFydEluZGV4IC09IDFcbiAgICBzdGFydFBvcyAtPSAkcG9zLnBhcmVudC5jaGlsZChzdGFydEluZGV4KS5ub2RlU2l6ZVxuICB9XG5cbiAgd2hpbGUgKFxuICAgIGVuZEluZGV4IDwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudFxuICAgICYmIGlzTWFya0luU2V0KFsuLi4kcG9zLnBhcmVudC5jaGlsZChlbmRJbmRleCkubWFya3NdLCB0eXBlLCBhdHRyaWJ1dGVzKVxuICApIHtcbiAgICBlbmRQb3MgKz0gJHBvcy5wYXJlbnQuY2hpbGQoZW5kSW5kZXgpLm5vZGVTaXplXG4gICAgZW5kSW5kZXggKz0gMVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmcm9tOiBzdGFydFBvcyxcbiAgICB0bzogZW5kUG9zLFxuICB9XG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXJrVHlwZShuYW1lT3JUeXBlOiBzdHJpbmcgfCBNYXJrVHlwZSwgc2NoZW1hOiBTY2hlbWEpOiBNYXJrVHlwZSB7XG4gIGlmICh0eXBlb2YgbmFtZU9yVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIXNjaGVtYS5tYXJrc1tuYW1lT3JUeXBlXSkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBUaGVyZSBpcyBubyBtYXJrIHR5cGUgbmFtZWQgJyR7bmFtZU9yVHlwZX0nLiBNYXliZSB5b3UgZm9yZ290IHRvIGFkZCB0aGUgZXh0ZW5zaW9uP2AsXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYS5tYXJrc1tuYW1lT3JUeXBlXVxuICB9XG5cbiAgcmV0dXJuIG5hbWVPclR5cGVcbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgZ2V0TWFya1JhbmdlIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrUmFuZ2UuanMnXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZXh0ZW5kTWFya1JhbmdlOiB7XG4gICAgICAvKipcbiAgICAgICAqIEV4dGVuZHMgdGhlIHRleHQgc2VsZWN0aW9uIHRvIHRoZSBjdXJyZW50IG1hcmsuXG4gICAgICAgKi9cbiAgICAgIGV4dGVuZE1hcmtSYW5nZTogKFxuICAgICAgICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBNYXJrVHlwZSxcbiAgICAgICAgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGV4dGVuZE1hcmtSYW5nZTogUmF3Q29tbWFuZHNbJ2V4dGVuZE1hcmtSYW5nZSddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgZG9jLCBzZWxlY3Rpb24gfSA9IHRyXG4gIGNvbnN0IHsgJGZyb20sIGZyb20sIHRvIH0gPSBzZWxlY3Rpb25cblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkZnJvbSwgdHlwZSwgYXR0cmlidXRlcylcblxuICAgIGlmIChyYW5nZSAmJiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8pIHtcbiAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgcmFuZ2UuZnJvbSwgcmFuZ2UudG8pXG5cbiAgICAgIHRyLnNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBDb21tYW5kLCBDb21tYW5kUHJvcHMsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBmaXJzdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBSdW5zIG9uZSBjb21tYW5kIGFmdGVyIHRoZSBvdGhlciBhbmQgc3RvcHMgYXQgdGhlIGZpcnN0IHdoaWNoIHJldHVybnMgdHJ1ZS5cbiAgICAgICAqL1xuICAgICAgZmlyc3Q6IChjb21tYW5kczogQ29tbWFuZFtdIHwgKChwcm9wczogQ29tbWFuZFByb3BzKSA9PiBDb21tYW5kW10pKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZmlyc3Q6IFJhd0NvbW1hbmRzWydmaXJzdCddID0gY29tbWFuZHMgPT4gcHJvcHMgPT4ge1xuICBjb25zdCBpdGVtcyA9IHR5cGVvZiBjb21tYW5kcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gY29tbWFuZHMocHJvcHMpXG4gICAgOiBjb21tYW5kc1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoaXRlbXNbaV0ocHJvcHMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwgImltcG9ydCB7IFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNUZXh0U2VsZWN0aW9uKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgVGV4dFNlbGVjdGlvbiB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb25cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gbWluTWF4KHZhbHVlID0gMCwgbWluID0gMCwgbWF4ID0gMCk6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KVxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEZvY3VzUG9zaXRpb24gfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG1pbk1heCB9IGZyb20gJy4uL3V0aWxpdGllcy9taW5NYXguanMnXG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlRm9jdXNQb3NpdGlvbihcbiAgZG9jOiBQcm9zZU1pcnJvck5vZGUsXG4gIHBvc2l0aW9uOiBGb2N1c1Bvc2l0aW9uID0gbnVsbCxcbik6IFNlbGVjdGlvbiB8IG51bGwge1xuICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IHNlbGVjdGlvbkF0U3RhcnQgPSBTZWxlY3Rpb24uYXRTdGFydChkb2MpXG4gIGNvbnN0IHNlbGVjdGlvbkF0RW5kID0gU2VsZWN0aW9uLmF0RW5kKGRvYylcblxuICBpZiAocG9zaXRpb24gPT09ICdzdGFydCcgfHwgcG9zaXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uQXRTdGFydFxuICB9XG5cbiAgaWYgKHBvc2l0aW9uID09PSAnZW5kJykge1xuICAgIHJldHVybiBzZWxlY3Rpb25BdEVuZFxuICB9XG5cbiAgY29uc3QgbWluUG9zID0gc2VsZWN0aW9uQXRTdGFydC5mcm9tXG4gIGNvbnN0IG1heFBvcyA9IHNlbGVjdGlvbkF0RW5kLnRvXG5cbiAgaWYgKHBvc2l0aW9uID09PSAnYWxsJykge1xuICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZShcbiAgICAgIGRvYyxcbiAgICAgIG1pbk1heCgwLCBtaW5Qb3MsIG1heFBvcyksXG4gICAgICBtaW5NYXgoZG9jLmNvbnRlbnQuc2l6ZSwgbWluUG9zLCBtYXhQb3MpLFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZShcbiAgICBkb2MsXG4gICAgbWluTWF4KHBvc2l0aW9uLCBtaW5Qb3MsIG1heFBvcyksXG4gICAgbWluTWF4KHBvc2l0aW9uLCBtaW5Qb3MsIG1heFBvcyksXG4gIClcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNpT1MoKTogYm9vbGVhbiB7XG4gIHJldHVybiBbXG4gICAgJ2lQYWQgU2ltdWxhdG9yJyxcbiAgICAnaVBob25lIFNpbXVsYXRvcicsXG4gICAgJ2lQb2QgU2ltdWxhdG9yJyxcbiAgICAnaVBhZCcsXG4gICAgJ2lQaG9uZScsXG4gICAgJ2lQb2QnLFxuICBdLmluY2x1ZGVzKG5hdmlnYXRvci5wbGF0Zm9ybSlcbiAgLy8gaVBhZCBvbiBpT1MgMTMgZGV0ZWN0aW9uXG4gIHx8IChuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdNYWMnKSAmJiAnb250b3VjaGVuZCcgaW4gZG9jdW1lbnQpXG59XG4iLCAiaW1wb3J0IHsgaXNUZXh0U2VsZWN0aW9uIH0gZnJvbSAnLi4vaGVscGVycy9pc1RleHRTZWxlY3Rpb24uanMnXG5pbXBvcnQgeyByZXNvbHZlRm9jdXNQb3NpdGlvbiB9IGZyb20gJy4uL2hlbHBlcnMvcmVzb2x2ZUZvY3VzUG9zaXRpb24uanMnXG5pbXBvcnQgeyBGb2N1c1Bvc2l0aW9uLCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgaXNpT1MgfSBmcm9tICcuLi91dGlsaXRpZXMvaXNpT1MuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBmb2N1czoge1xuICAgICAgLyoqXG4gICAgICAgKiBGb2N1cyB0aGUgZWRpdG9yIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgICAqL1xuICAgICAgZm9jdXM6IChcbiAgICAgICAgcG9zaXRpb24/OiBGb2N1c1Bvc2l0aW9uLFxuICAgICAgICBvcHRpb25zPzoge1xuICAgICAgICAgIHNjcm9sbEludG9WaWV3PzogYm9vbGVhbixcbiAgICAgICAgfSxcbiAgICAgICkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGZvY3VzOiBSYXdDb21tYW5kc1snZm9jdXMnXSA9IChwb3NpdGlvbiA9IG51bGwsIG9wdGlvbnMgPSB7fSkgPT4gKHtcbiAgZWRpdG9yLFxuICB2aWV3LFxuICB0cixcbiAgZGlzcGF0Y2gsXG59KSA9PiB7XG4gIG9wdGlvbnMgPSB7XG4gICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxuXG4gIGNvbnN0IGRlbGF5ZWRGb2N1cyA9ICgpID0+IHtcbiAgICAvLyBmb2N1cyB3aXRoaW4gYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYnJlYWtzIGZvY3VzIG9uIGlPU1xuICAgIC8vIHNvIHdlIGhhdmUgdG8gY2FsbCB0aGlzXG4gICAgaWYgKGlzaU9TKCkpIHtcbiAgICAgICh2aWV3LmRvbSBhcyBIVE1MRWxlbWVudCkuZm9jdXMoKVxuICAgIH1cblxuICAgIC8vIEZvciBSZWFjdCB3ZSBoYXZlIHRvIGZvY3VzIGFzeW5jaHJvbm91c2x5LiBPdGhlcndpc2Ugd2lsZCB0aGluZ3MgaGFwcGVuLlxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8xNTIwXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAgIHZpZXcuZm9jdXMoKVxuXG4gICAgICAgIGlmIChvcHRpb25zPy5zY3JvbGxJbnRvVmlldykge1xuICAgICAgICAgIGVkaXRvci5jb21tYW5kcy5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaWYgKCh2aWV3Lmhhc0ZvY3VzKCkgJiYgcG9zaXRpb24gPT09IG51bGwpIHx8IHBvc2l0aW9uID09PSBmYWxzZSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyB3ZSBkb27igJl0IHRyeSB0byByZXNvbHZlIGEgTm9kZVNlbGVjdGlvbiBvciBDZWxsU2VsZWN0aW9uXG4gIGlmIChkaXNwYXRjaCAmJiBwb3NpdGlvbiA9PT0gbnVsbCAmJiAhaXNUZXh0U2VsZWN0aW9uKGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24pKSB7XG4gICAgZGVsYXllZEZvY3VzKClcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gcGFzcyB0aHJvdWdoIHRyLmRvYyBpbnN0ZWFkIG9mIGVkaXRvci5zdGF0ZS5kb2NcbiAgLy8gc2luY2UgdHJhbnNhY3Rpb25zIGNvdWxkIGNoYW5nZSB0aGUgZWRpdG9ycyBzdGF0ZSBiZWZvcmUgdGhpcyBjb21tYW5kIGhhcyBiZWVuIHJ1blxuICBjb25zdCBzZWxlY3Rpb24gPSByZXNvbHZlRm9jdXNQb3NpdGlvbih0ci5kb2MsIHBvc2l0aW9uKSB8fCBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uXG4gIGNvbnN0IGlzU2FtZVNlbGVjdGlvbiA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZXEoc2VsZWN0aW9uKVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGlmICghaXNTYW1lU2VsZWN0aW9uKSB7XG4gICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKVxuICAgIH1cblxuICAgIC8vIGB0ci5zZXRTZWxlY3Rpb25gIHJlc2V0cyB0aGUgc3RvcmVkIG1hcmtzXG4gICAgLy8gc28gd2XigJlsbCByZXN0b3JlIHRoZW0gaWYgdGhlIHNlbGVjdGlvbiBpcyB0aGUgc2FtZSBhcyBiZWZvcmVcbiAgICBpZiAoaXNTYW1lU2VsZWN0aW9uICYmIHRyLnN0b3JlZE1hcmtzKSB7XG4gICAgICB0ci5zZXRTdG9yZWRNYXJrcyh0ci5zdG9yZWRNYXJrcylcbiAgICB9XG5cbiAgICBkZWxheWVkRm9jdXMoKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBDb21tYW5kUHJvcHMsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBmb3JFYWNoOiB7XG4gICAgICAvKipcbiAgICAgICAqIExvb3AgdGhyb3VnaCBhbiBhcnJheSBvZiBpdGVtcy5cbiAgICAgICAqL1xuICAgICAgZm9yRWFjaDogPFQ+KFxuICAgICAgICBpdGVtczogVFtdLFxuICAgICAgICBmbjogKFxuICAgICAgICAgIGl0ZW06IFQsXG4gICAgICAgICAgcHJvcHM6IENvbW1hbmRQcm9wcyAmIHtcbiAgICAgICAgICAgIGluZGV4OiBudW1iZXIsXG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiBib29sZWFuLFxuICAgICAgKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZm9yRWFjaDogUmF3Q29tbWFuZHNbJ2ZvckVhY2gnXSA9IChpdGVtcywgZm4pID0+IHByb3BzID0+IHtcbiAgcmV0dXJuIGl0ZW1zLmV2ZXJ5KChpdGVtLCBpbmRleCkgPT4gZm4oaXRlbSwgeyAuLi5wcm9wcywgaW5kZXggfSkpXG59XG4iLCAiaW1wb3J0IHsgUGFyc2VPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgQ29udGVudCwgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGluc2VydENvbnRlbnQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSW5zZXJ0IGEgbm9kZSBvciBzdHJpbmcgb2YgSFRNTCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAqL1xuICAgICAgaW5zZXJ0Q29udGVudDogKFxuICAgICAgICB2YWx1ZTogQ29udGVudCxcbiAgICAgICAgb3B0aW9ucz86IHtcbiAgICAgICAgICBwYXJzZU9wdGlvbnM/OiBQYXJzZU9wdGlvbnNcbiAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24/OiBib29sZWFuXG4gICAgICAgIH0sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGluc2VydENvbnRlbnQ6IFJhd0NvbW1hbmRzWydpbnNlcnRDb250ZW50J10gPSAodmFsdWUsIG9wdGlvbnMpID0+ICh7IHRyLCBjb21tYW5kcyB9KSA9PiB7XG4gIHJldHVybiBjb21tYW5kcy5pbnNlcnRDb250ZW50QXQoXG4gICAgeyBmcm9tOiB0ci5zZWxlY3Rpb24uZnJvbSwgdG86IHRyLnNlbGVjdGlvbi50byB9LFxuICAgIHZhbHVlLFxuICAgIG9wdGlvbnMsXG4gIClcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZWxlbWVudEZyb21TdHJpbmcodmFsdWU6IHN0cmluZyk6IEhUTUxFbGVtZW50IHtcbiAgLy8gYWRkIGEgd3JhcHBlciB0byBwcmVzZXJ2ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gIGNvbnN0IHdyYXBwZWRWYWx1ZSA9IGA8Ym9keT4ke3ZhbHVlfTwvYm9keT5gXG5cbiAgcmV0dXJuIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHdyYXBwZWRWYWx1ZSwgJ3RleHQvaHRtbCcpLmJvZHlcbn1cbiIsICJpbXBvcnQge1xuICBET01QYXJzZXIsXG4gIEZyYWdtZW50LFxuICBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSxcbiAgUGFyc2VPcHRpb25zLFxuICBTY2hlbWEsXG59IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IENvbnRlbnQgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGVsZW1lbnRGcm9tU3RyaW5nIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2VsZW1lbnRGcm9tU3RyaW5nLmpzJ1xuXG5leHBvcnQgdHlwZSBDcmVhdGVOb2RlRnJvbUNvbnRlbnRPcHRpb25zID0ge1xuICBzbGljZT86IGJvb2xlYW5cbiAgcGFyc2VPcHRpb25zPzogUGFyc2VPcHRpb25zXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoXG4gIGNvbnRlbnQ6IENvbnRlbnQsXG4gIHNjaGVtYTogU2NoZW1hLFxuICBvcHRpb25zPzogQ3JlYXRlTm9kZUZyb21Db250ZW50T3B0aW9ucyxcbik6IFByb3NlTWlycm9yTm9kZSB8IEZyYWdtZW50IHtcbiAgb3B0aW9ucyA9IHtcbiAgICBzbGljZTogdHJ1ZSxcbiAgICBwYXJzZU9wdGlvbnM6IHt9LFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdvYmplY3QnICYmIGNvbnRlbnQgIT09IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudCkgJiYgY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tQXJyYXkoY29udGVudC5tYXAoaXRlbSA9PiBzY2hlbWEubm9kZUZyb21KU09OKGl0ZW0pKSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNjaGVtYS5ub2RlRnJvbUpTT04oY29udGVudClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBJbnZhbGlkIGNvbnRlbnQuJywgJ1Bhc3NlZCB2YWx1ZTonLCBjb250ZW50LCAnRXJyb3I6JywgZXJyb3IpXG5cbiAgICAgIHJldHVybiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoJycsIHNjaGVtYSwgb3B0aW9ucylcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgcGFyc2VyID0gRE9NUGFyc2VyLmZyb21TY2hlbWEoc2NoZW1hKVxuXG4gICAgcmV0dXJuIG9wdGlvbnMuc2xpY2VcbiAgICAgID8gcGFyc2VyLnBhcnNlU2xpY2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKS5jb250ZW50XG4gICAgICA6IHBhcnNlci5wYXJzZShlbGVtZW50RnJvbVN0cmluZyhjb250ZW50KSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KCcnLCBzY2hlbWEsIG9wdGlvbnMpXG59XG4iLCAiaW1wb3J0IHsgU2VsZWN0aW9uLCBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBSZXBsYWNlQXJvdW5kU3RlcCwgUmVwbGFjZVN0ZXAgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3Itc3RhdGUvYmxvYi9tYXN0ZXIvc3JjL3NlbGVjdGlvbi5qcyNMNDY2XG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHI6IFRyYW5zYWN0aW9uLCBzdGFydExlbjogbnVtYmVyLCBiaWFzOiBudW1iZXIpIHtcbiAgY29uc3QgbGFzdCA9IHRyLnN0ZXBzLmxlbmd0aCAtIDFcblxuICBpZiAobGFzdCA8IHN0YXJ0TGVuKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBzdGVwID0gdHIuc3RlcHNbbGFzdF1cblxuICBpZiAoIShzdGVwIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXAgfHwgc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VBcm91bmRTdGVwKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgbWFwID0gdHIubWFwcGluZy5tYXBzW2xhc3RdXG4gIGxldCBlbmQgPSAwXG5cbiAgbWFwLmZvckVhY2goKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgPT4ge1xuICAgIGlmIChlbmQgPT09IDApIHtcbiAgICAgIGVuZCA9IG5ld1RvXG4gICAgfVxuICB9KVxuXG4gIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShlbmQpLCBiaWFzKSlcbn1cbiIsICJpbXBvcnQgeyBGcmFnbWVudCwgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUsIFBhcnNlT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGNyZWF0ZU5vZGVGcm9tQ29udGVudCB9IGZyb20gJy4uL2hlbHBlcnMvY3JlYXRlTm9kZUZyb21Db250ZW50LmpzJ1xuaW1wb3J0IHsgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQgfSBmcm9tICcuLi9oZWxwZXJzL3NlbGVjdGlvblRvSW5zZXJ0aW9uRW5kLmpzJ1xuaW1wb3J0IHsgQ29udGVudCwgUmFuZ2UsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBpbnNlcnRDb250ZW50QXQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSW5zZXJ0IGEgbm9kZSBvciBzdHJpbmcgb2YgSFRNTCBhdCBhIHNwZWNpZmljIHBvc2l0aW9uLlxuICAgICAgICovXG4gICAgICBpbnNlcnRDb250ZW50QXQ6IChcbiAgICAgICAgcG9zaXRpb246IG51bWJlciB8IFJhbmdlLFxuICAgICAgICB2YWx1ZTogQ29udGVudCxcbiAgICAgICAgb3B0aW9ucz86IHtcbiAgICAgICAgICBwYXJzZU9wdGlvbnM/OiBQYXJzZU9wdGlvbnNcbiAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24/OiBib29sZWFuXG4gICAgICAgIH0sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaXNGcmFnbWVudCA9IChub2RlT3JGcmFnbWVudDogUHJvc2VNaXJyb3JOb2RlIHwgRnJhZ21lbnQpOiBub2RlT3JGcmFnbWVudCBpcyBGcmFnbWVudCA9PiB7XG4gIHJldHVybiBub2RlT3JGcmFnbWVudC50b1N0cmluZygpLnN0YXJ0c1dpdGgoJzwnKVxufVxuXG5leHBvcnQgY29uc3QgaW5zZXJ0Q29udGVudEF0OiBSYXdDb21tYW5kc1snaW5zZXJ0Q29udGVudEF0J10gPSAocG9zaXRpb24sIHZhbHVlLCBvcHRpb25zKSA9PiAoeyB0ciwgZGlzcGF0Y2gsIGVkaXRvciB9KSA9PiB7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBwYXJzZU9wdGlvbnM6IHt9LFxuICAgICAgdXBkYXRlU2VsZWN0aW9uOiB0cnVlLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50ID0gY3JlYXRlTm9kZUZyb21Db250ZW50KHZhbHVlLCBlZGl0b3Iuc2NoZW1hLCB7XG4gICAgICBwYXJzZU9wdGlvbnM6IHtcbiAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAnZnVsbCcsXG4gICAgICAgIC4uLm9wdGlvbnMucGFyc2VPcHRpb25zLFxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgLy8gZG9u4oCZdCBkaXNwYXRjaCBhbiBlbXB0eSBmcmFnbWVudCBiZWNhdXNlIHRoaXMgY2FuIGxlYWQgdG8gc3RyYW5nZSBlcnJvcnNcbiAgICBpZiAoY29udGVudC50b1N0cmluZygpID09PSAnPD4nKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGxldCB7IGZyb20sIHRvIH0gPSB0eXBlb2YgcG9zaXRpb24gPT09ICdudW1iZXInID8geyBmcm9tOiBwb3NpdGlvbiwgdG86IHBvc2l0aW9uIH0gOiB7IGZyb206IHBvc2l0aW9uLmZyb20sIHRvOiBwb3NpdGlvbi50byB9XG5cbiAgICBsZXQgaXNPbmx5VGV4dENvbnRlbnQgPSB0cnVlXG4gICAgbGV0IGlzT25seUJsb2NrQ29udGVudCA9IHRydWVcbiAgICBjb25zdCBub2RlcyA9IGlzRnJhZ21lbnQoY29udGVudCkgPyBjb250ZW50IDogW2NvbnRlbnRdXG5cbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgLy8gY2hlY2sgaWYgYWRkZWQgbm9kZSBpcyB2YWxpZFxuICAgICAgbm9kZS5jaGVjaygpXG5cbiAgICAgIGlzT25seVRleHRDb250ZW50ID0gaXNPbmx5VGV4dENvbnRlbnQgPyBub2RlLmlzVGV4dCAmJiBub2RlLm1hcmtzLmxlbmd0aCA9PT0gMCA6IGZhbHNlXG5cbiAgICAgIGlzT25seUJsb2NrQ29udGVudCA9IGlzT25seUJsb2NrQ29udGVudCA/IG5vZGUuaXNCbG9jayA6IGZhbHNlXG4gICAgfSlcblxuICAgIC8vIGNoZWNrIGlmIHdlIGNhbiByZXBsYWNlIHRoZSB3cmFwcGluZyBub2RlIGJ5XG4gICAgLy8gdGhlIG5ld2x5IGluc2VydGVkIGNvbnRlbnRcbiAgICAvLyBleGFtcGxlOlxuICAgIC8vIHJlcGxhY2UgYW4gZW1wdHkgcGFyYWdyYXBoIGJ5IGFuIGluc2VydGVkIGltYWdlXG4gICAgLy8gaW5zdGVhZCBvZiBpbnNlcnRpbmcgdGhlIGltYWdlIGJlbG93IHRoZSBwYXJhZ3JhcGhcbiAgICBpZiAoZnJvbSA9PT0gdG8gJiYgaXNPbmx5QmxvY2tDb250ZW50KSB7XG4gICAgICBjb25zdCB7IHBhcmVudCB9ID0gdHIuZG9jLnJlc29sdmUoZnJvbSlcbiAgICAgIGNvbnN0IGlzRW1wdHlUZXh0QmxvY2sgPSBwYXJlbnQuaXNUZXh0YmxvY2sgJiYgIXBhcmVudC50eXBlLnNwZWMuY29kZSAmJiAhcGFyZW50LmNoaWxkQ291bnRcblxuICAgICAgaWYgKGlzRW1wdHlUZXh0QmxvY2spIHtcbiAgICAgICAgZnJvbSAtPSAxXG4gICAgICAgIHRvICs9IDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBvbmx5IHBsYWluIHRleHQgd2UgaGF2ZSB0byB1c2UgYGluc2VydFRleHRgXG4gICAgLy8gYmVjYXVzZSB0aGlzIHdpbGwga2VlcCB0aGUgY3VycmVudCBtYXJrc1xuICAgIGlmIChpc09ubHlUZXh0Q29udGVudCkge1xuICAgICAgLy8gaWYgdmFsdWUgaXMgc3RyaW5nLCB3ZSBjYW4gdXNlIGl0IGRpcmVjdGx5XG4gICAgICAvLyBvdGhlcndpc2UgaWYgaXQgaXMgYW4gYXJyYXksIHdlIGhhdmUgdG8gam9pbiBpdFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRyLmluc2VydFRleHQodmFsdWUubWFwKHYgPT4gdi50ZXh0IHx8ICcnKS5qb2luKCcnKSwgZnJvbSwgdG8pXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgISF2YWx1ZSAmJiAhIXZhbHVlLnRleHQpIHtcbiAgICAgICAgdHIuaW5zZXJ0VGV4dCh2YWx1ZS50ZXh0LCBmcm9tLCB0bylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyLmluc2VydFRleHQodmFsdWUgYXMgc3RyaW5nLCBmcm9tLCB0bylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHIucmVwbGFjZVdpdGgoZnJvbSwgdG8sIGNvbnRlbnQpXG4gICAgfVxuXG4gICAgLy8gc2V0IGN1cnNvciBhdCBlbmQgb2YgaW5zZXJ0ZWQgY29udGVudFxuICAgIGlmIChvcHRpb25zLnVwZGF0ZVNlbGVjdGlvbikge1xuICAgICAgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIHRyLnN0ZXBzLmxlbmd0aCAtIDEsIC0xKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHtcbiAgam9pbkJhY2t3YXJkIGFzIG9yaWdpbmFsSm9pbkJhY2t3YXJkLFxuICBqb2luRG93biBhcyBvcmlnaW5hbEpvaW5Eb3duLFxuICBqb2luRm9yd2FyZCBhcyBvcmlnaW5hbEpvaW5Gb3J3YXJkLFxuICBqb2luVXAgYXMgb3JpZ2luYWxKb2luVXAsXG59IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBqb2luVXA6IHtcbiAgICAgIC8qKlxuICAgICAgICogSm9pbiB0d28gbm9kZXMgVXAuXG4gICAgICAgKi9cbiAgICAgIGpvaW5VcDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgICBqb2luRG93bjoge1xuICAgICAgLyoqXG4gICAgICAgKiBKb2luIHR3byBub2RlcyBEb3duLlxuICAgICAgICovXG4gICAgICBqb2luRG93bjogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgICBqb2luQmFja3dhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSm9pbiB0d28gbm9kZXMgQmFja3dhcmRzLlxuICAgICAgICovXG4gICAgICBqb2luQmFja3dhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gICAgam9pbkZvcndhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSm9pbiB0d28gbm9kZXMgRm9yd2FyZHMuXG4gICAgICAgKi9cbiAgICAgIGpvaW5Gb3J3YXJkOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBqb2luVXA6IFJhd0NvbW1hbmRzWydqb2luVXAnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbEpvaW5VcChzdGF0ZSwgZGlzcGF0Y2gpXG59XG5cbmV4cG9ydCBjb25zdCBqb2luRG93bjogUmF3Q29tbWFuZHNbJ2pvaW5Eb3duJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxKb2luRG93bihzdGF0ZSwgZGlzcGF0Y2gpXG59XG5cbmV4cG9ydCBjb25zdCBqb2luQmFja3dhcmQ6IFJhd0NvbW1hbmRzWydqb2luQmFja3dhcmQnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbEpvaW5CYWNrd2FyZChzdGF0ZSwgZGlzcGF0Y2gpXG59XG5cbmV4cG9ydCBjb25zdCBqb2luRm9yd2FyZDogUmF3Q29tbWFuZHNbJ2pvaW5Gb3J3YXJkJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxKb2luRm9yd2FyZChzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgam9pblBvaW50IH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBqb2luSXRlbUJhY2t3YXJkOiB7XG4gICAgICAvKipcbiAgICAgICAqIEpvaW4gdHdvIG5vZGVzIEZvcndhcmRzLlxuICAgICAgICovXG4gICAgICBqb2luSXRlbUJhY2t3YXJkOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBqb2luSXRlbUJhY2t3YXJkOiBSYXdDb21tYW5kc1snam9pbkl0ZW1CYWNrd2FyZCddID0gKCkgPT4gKHtcbiAgdHIsIHN0YXRlLCBkaXNwYXRjaCxcbn0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wb3MsIC0xKVxuXG4gICAgaWYgKHBvaW50ID09PSBudWxsIHx8IHBvaW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHRyLmpvaW4ocG9pbnQsIDIpXG5cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGRpc3BhdGNoKHRyKVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG4iLCAiaW1wb3J0IHsgam9pblBvaW50IH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBqb2luSXRlbUZvcndhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSm9pbiB0d28gbm9kZXMgRm9yd2FyZHMuXG4gICAgICAgKi9cbiAgICAgIGpvaW5JdGVtRm9yd2FyZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgam9pbkl0ZW1Gb3J3YXJkOiBSYXdDb21tYW5kc1snam9pbkl0ZW1Gb3J3YXJkJ10gPSAoKSA9PiAoe1xuICBzdGF0ZSxcbiAgZGlzcGF0Y2gsXG4gIHRyLFxufSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBvcywgKzEpXG5cbiAgICBpZiAocG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdHIuam9pbihwb2ludCwgMilcblxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgZGlzcGF0Y2godHIpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzTWFjT1MoKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJ1xuICAgID8gL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG4gICAgOiBmYWxzZVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBpc2lPUyB9IGZyb20gJy4uL3V0aWxpdGllcy9pc2lPUy5qcydcbmltcG9ydCB7IGlzTWFjT1MgfSBmcm9tICcuLi91dGlsaXRpZXMvaXNNYWNPUy5qcydcblxuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lOiBzdHJpbmcpIHtcbiAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKVxuICBsZXQgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV1cblxuICBpZiAocmVzdWx0ID09PSAnU3BhY2UnKSB7XG4gICAgcmVzdWx0ID0gJyAnXG4gIH1cblxuICBsZXQgYWx0XG4gIGxldCBjdHJsXG4gIGxldCBzaGlmdFxuICBsZXQgbWV0YVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgY29uc3QgbW9kID0gcGFydHNbaV1cblxuICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIG1ldGEgPSB0cnVlXG4gICAgfSBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIGFsdCA9IHRydWVcbiAgICB9IGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIGN0cmwgPSB0cnVlXG4gICAgfSBlbHNlIGlmICgvXnMoaGlmdCk/JC9pLnRlc3QobW9kKSkge1xuICAgICAgc2hpZnQgPSB0cnVlXG4gICAgfSBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIGlmIChpc2lPUygpIHx8IGlzTWFjT1MoKSkge1xuICAgICAgICBtZXRhID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3RybCA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogJHttb2R9YClcbiAgICB9XG4gIH1cblxuICBpZiAoYWx0KSB7XG4gICAgcmVzdWx0ID0gYEFsdC0ke3Jlc3VsdH1gXG4gIH1cblxuICBpZiAoY3RybCkge1xuICAgIHJlc3VsdCA9IGBDdHJsLSR7cmVzdWx0fWBcbiAgfVxuXG4gIGlmIChtZXRhKSB7XG4gICAgcmVzdWx0ID0gYE1ldGEtJHtyZXN1bHR9YFxuICB9XG5cbiAgaWYgKHNoaWZ0KSB7XG4gICAgcmVzdWx0ID0gYFNoaWZ0LSR7cmVzdWx0fWBcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGtleWJvYXJkU2hvcnRjdXQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogVHJpZ2dlciBhIGtleWJvYXJkIHNob3J0Y3V0LlxuICAgICAgICovXG4gICAgICBrZXlib2FyZFNob3J0Y3V0OiAobmFtZTogc3RyaW5nKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qga2V5Ym9hcmRTaG9ydGN1dDogUmF3Q29tbWFuZHNbJ2tleWJvYXJkU2hvcnRjdXQnXSA9IG5hbWUgPT4gKHtcbiAgZWRpdG9yLFxuICB2aWV3LFxuICB0cixcbiAgZGlzcGF0Y2gsXG59KSA9PiB7XG4gIGNvbnN0IGtleXMgPSBub3JtYWxpemVLZXlOYW1lKG5hbWUpLnNwbGl0KC8tKD8hJCkvKVxuICBjb25zdCBrZXkgPSBrZXlzLmZpbmQoaXRlbSA9PiAhWydBbHQnLCAnQ3RybCcsICdNZXRhJywgJ1NoaWZ0J10uaW5jbHVkZXMoaXRlbSkpXG4gIGNvbnN0IGV2ZW50ID0gbmV3IEtleWJvYXJkRXZlbnQoJ2tleWRvd24nLCB7XG4gICAga2V5OiBrZXkgPT09ICdTcGFjZSdcbiAgICAgID8gJyAnXG4gICAgICA6IGtleSxcbiAgICBhbHRLZXk6IGtleXMuaW5jbHVkZXMoJ0FsdCcpLFxuICAgIGN0cmxLZXk6IGtleXMuaW5jbHVkZXMoJ0N0cmwnKSxcbiAgICBtZXRhS2V5OiBrZXlzLmluY2x1ZGVzKCdNZXRhJyksXG4gICAgc2hpZnRLZXk6IGtleXMuaW5jbHVkZXMoJ1NoaWZ0JyksXG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICB9KVxuXG4gIGNvbnN0IGNhcHR1cmVkVHJhbnNhY3Rpb24gPSBlZGl0b3IuY2FwdHVyZVRyYW5zYWN0aW9uKCgpID0+IHtcbiAgICB2aWV3LnNvbWVQcm9wKCdoYW5kbGVLZXlEb3duJywgZiA9PiBmKHZpZXcsIGV2ZW50KSlcbiAgfSlcblxuICBjYXB0dXJlZFRyYW5zYWN0aW9uPy5zdGVwcy5mb3JFYWNoKHN0ZXAgPT4ge1xuICAgIGNvbnN0IG5ld1N0ZXAgPSBzdGVwLm1hcCh0ci5tYXBwaW5nKVxuXG4gICAgaWYgKG5ld1N0ZXAgJiYgZGlzcGF0Y2gpIHtcbiAgICAgIHRyLm1heWJlU3RlcChuZXdTdGVwKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgTm9kZVJhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBvYmplY3RJbmNsdWRlcyB9IGZyb20gJy4uL3V0aWxpdGllcy9vYmplY3RJbmNsdWRlcy5qcydcbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi9nZXROb2RlVHlwZS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZUFjdGl2ZShcbiAgc3RhdGU6IEVkaXRvclN0YXRlLFxuICB0eXBlT3JOYW1lOiBOb2RlVHlwZSB8IHN0cmluZyB8IG51bGwsXG4gIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSxcbik6IGJvb2xlYW4ge1xuICBjb25zdCB7IGZyb20sIHRvLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uXG4gIGNvbnN0IHR5cGUgPSB0eXBlT3JOYW1lID8gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKSA6IG51bGxcblxuICBjb25zdCBub2RlUmFuZ2VzOiBOb2RlUmFuZ2VbXSA9IFtdXG5cbiAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVsYXRpdmVGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKVxuICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBNYXRoLm1pbih0bywgcG9zICsgbm9kZS5ub2RlU2l6ZSlcblxuICAgIG5vZGVSYW5nZXMucHVzaCh7XG4gICAgICBub2RlLFxuICAgICAgZnJvbTogcmVsYXRpdmVGcm9tLFxuICAgICAgdG86IHJlbGF0aXZlVG8sXG4gICAgfSlcbiAgfSlcblxuICBjb25zdCBzZWxlY3Rpb25SYW5nZSA9IHRvIC0gZnJvbVxuICBjb25zdCBtYXRjaGVkTm9kZVJhbmdlcyA9IG5vZGVSYW5nZXNcbiAgICAuZmlsdGVyKG5vZGVSYW5nZSA9PiB7XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gbm9kZVJhbmdlLm5vZGUudHlwZS5uYW1lXG4gICAgfSlcbiAgICAuZmlsdGVyKG5vZGVSYW5nZSA9PiBvYmplY3RJbmNsdWRlcyhub2RlUmFuZ2Uubm9kZS5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKVxuXG4gIGlmIChlbXB0eSkge1xuICAgIHJldHVybiAhIW1hdGNoZWROb2RlUmFuZ2VzLmxlbmd0aFxuICB9XG5cbiAgY29uc3QgcmFuZ2UgPSBtYXRjaGVkTm9kZVJhbmdlcy5yZWR1Y2UoKHN1bSwgbm9kZVJhbmdlKSA9PiBzdW0gKyBub2RlUmFuZ2UudG8gLSBub2RlUmFuZ2UuZnJvbSwgMClcblxuICByZXR1cm4gcmFuZ2UgPj0gc2VsZWN0aW9uUmFuZ2Vcbn1cbiIsICJpbXBvcnQgeyBsaWZ0IGFzIG9yaWdpbmFsTGlmdCB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5pbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGlzTm9kZUFjdGl2ZSB9IGZyb20gJy4uL2hlbHBlcnMvaXNOb2RlQWN0aXZlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGxpZnQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBhbiBleGlzdGluZyB3cmFwLlxuICAgICAgICovXG4gICAgICBsaWZ0OiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBsaWZ0OiBSYXdDb21tYW5kc1snbGlmdCddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgaXNBY3RpdmUgPSBpc05vZGVBY3RpdmUoc3RhdGUsIHR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgaWYgKCFpc0FjdGl2ZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIG9yaWdpbmFsTGlmdChzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgbGlmdEVtcHR5QmxvY2sgYXMgb3JpZ2luYWxMaWZ0RW1wdHlCbG9jayB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBsaWZ0RW1wdHlCbG9jazoge1xuICAgICAgLyoqXG4gICAgICAgKiBMaWZ0IGJsb2NrIGlmIGVtcHR5LlxuICAgICAgICovXG4gICAgICBsaWZ0RW1wdHlCbG9jazogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGxpZnRFbXB0eUJsb2NrOiBSYXdDb21tYW5kc1snbGlmdEVtcHR5QmxvY2snXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbExpZnRFbXB0eUJsb2NrKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBsaWZ0TGlzdEl0ZW0gYXMgb3JpZ2luYWxMaWZ0TGlzdEl0ZW0gfSBmcm9tICdAdGlwdGFwL3BtL3NjaGVtYS1saXN0J1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgbGlmdExpc3RJdGVtOiB7XG4gICAgICAvKipcbiAgICAgICAqIExpZnQgdGhlIGxpc3QgaXRlbSBpbnRvIGEgd3JhcHBpbmcgbGlzdC5cbiAgICAgICAqL1xuICAgICAgbGlmdExpc3RJdGVtOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGxpZnRMaXN0SXRlbTogUmF3Q29tbWFuZHNbJ2xpZnRMaXN0SXRlbSddID0gdHlwZU9yTmFtZSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIHJldHVybiBvcmlnaW5hbExpZnRMaXN0SXRlbSh0eXBlKShzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgbmV3bGluZUluQ29kZSBhcyBvcmlnaW5hbE5ld2xpbmVJbkNvZGUgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgbmV3bGluZUluQ29kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYSBuZXdsaW5lIGNoYXJhY3RlciBpbiBjb2RlLlxuICAgICAgICovXG4gICAgICBuZXdsaW5lSW5Db2RlOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBuZXdsaW5lSW5Db2RlOiBSYXdDb21tYW5kc1snbmV3bGluZUluQ29kZSddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsTmV3bGluZUluQ29kZShzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKG5hbWU6IHN0cmluZywgc2NoZW1hOiBTY2hlbWEpOiAnbm9kZScgfCAnbWFyaycgfCBudWxsIHtcbiAgaWYgKHNjaGVtYS5ub2Rlc1tuYW1lXSkge1xuICAgIHJldHVybiAnbm9kZSdcbiAgfVxuXG4gIGlmIChzY2hlbWEubWFya3NbbmFtZV0pIHtcbiAgICByZXR1cm4gJ21hcmsnXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuIiwgIi8qKlxuICogUmVtb3ZlIGEgcHJvcGVydHkgb3IgYW4gYXJyYXkgb2YgcHJvcGVydGllcyBmcm9tIGFuIG9iamVjdFxuICogQHBhcmFtIG9iaiBPYmplY3RcbiAqIEBwYXJhbSBrZXkgS2V5IHRvIHJlbW92ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlUHJvcHMob2JqOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBwcm9wT3JQcm9wczogc3RyaW5nIHwgc3RyaW5nW10pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgY29uc3QgcHJvcHMgPSB0eXBlb2YgcHJvcE9yUHJvcHMgPT09ICdzdHJpbmcnXG4gICAgPyBbcHJvcE9yUHJvcHNdXG4gICAgOiBwcm9wT3JQcm9wc1xuXG4gIHJldHVybiBPYmplY3RcbiAgICAua2V5cyhvYmopXG4gICAgLnJlZHVjZSgobmV3T2JqOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBwcm9wKSA9PiB7XG4gICAgICBpZiAoIXByb3BzLmluY2x1ZGVzKHByb3ApKSB7XG4gICAgICAgIG5ld09ialtwcm9wXSA9IG9ialtwcm9wXVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3T2JqXG4gICAgfSwge30pXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtUeXBlLmpzJ1xuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUgfSBmcm9tICcuLi9oZWxwZXJzL2dldFNjaGVtYVR5cGVOYW1lQnlOYW1lLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGRlbGV0ZVByb3BzIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2RlbGV0ZVByb3BzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgcmVzZXRBdHRyaWJ1dGVzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlc2V0cyBzb21lIG5vZGUgYXR0cmlidXRlcyB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAqL1xuICAgICAgcmVzZXRBdHRyaWJ1dGVzOiAoXG4gICAgICAgIHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlIHwgTWFya1R5cGUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHN0cmluZyB8IHN0cmluZ1tdLFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCByZXNldEF0dHJpYnV0ZXM6IFJhd0NvbW1hbmRzWydyZXNldEF0dHJpYnV0ZXMnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzKSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgbGV0IG5vZGVUeXBlOiBOb2RlVHlwZSB8IG51bGwgPSBudWxsXG4gIGxldCBtYXJrVHlwZTogTWFya1R5cGUgfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShcbiAgICB0eXBlb2YgdHlwZU9yTmFtZSA9PT0gJ3N0cmluZycgPyB0eXBlT3JOYW1lIDogdHlwZU9yTmFtZS5uYW1lLFxuICAgIHN0YXRlLnNjaGVtYSxcbiAgKVxuXG4gIGlmICghc2NoZW1hVHlwZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09ICdub2RlJykge1xuICAgIG5vZGVUeXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSBhcyBOb2RlVHlwZSwgc3RhdGUuc2NoZW1hKVxuICB9XG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09ICdtYXJrJykge1xuICAgIG1hcmtUeXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSBhcyBNYXJrVHlwZSwgc3RhdGUuc2NoZW1hKVxuICB9XG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdHIuc2VsZWN0aW9uLnJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4ocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XG4gICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIHVuZGVmaW5lZCwgZGVsZXRlUHJvcHMobm9kZS5hdHRycywgYXR0cmlidXRlcykpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFya1R5cGUgJiYgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgICAgICBpZiAobWFya1R5cGUgPT09IG1hcmsudHlwZSkge1xuICAgICAgICAgICAgICB0ci5hZGRNYXJrKFxuICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICBwb3MgKyBub2RlLm5vZGVTaXplLFxuICAgICAgICAgICAgICAgIG1hcmtUeXBlLmNyZWF0ZShkZWxldGVQcm9wcyhtYXJrLmF0dHJzLCBhdHRyaWJ1dGVzKSksXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzY3JvbGxJbnRvVmlldzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgdGhlIHNlbGVjdGlvbiBpbnRvIHZpZXcuXG4gICAgICAgKi9cbiAgICAgIHNjcm9sbEludG9WaWV3OiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2Nyb2xsSW50b1ZpZXc6IFJhd0NvbW1hbmRzWydzY3JvbGxJbnRvVmlldyddID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdHIuc2Nyb2xsSW50b1ZpZXcoKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2VsZWN0QWxsOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNlbGVjdCB0aGUgd2hvbGUgZG9jdW1lbnQuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdEFsbDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNlbGVjdEFsbDogUmF3Q29tbWFuZHNbJ3NlbGVjdEFsbCddID0gKCkgPT4gKHsgdHIsIGNvbW1hbmRzIH0pID0+IHtcbiAgcmV0dXJuIGNvbW1hbmRzLnNldFRleHRTZWxlY3Rpb24oe1xuICAgIGZyb206IDAsXG4gICAgdG86IHRyLmRvYy5jb250ZW50LnNpemUsXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgc2VsZWN0Tm9kZUJhY2t3YXJkIGFzIG9yaWdpbmFsU2VsZWN0Tm9kZUJhY2t3YXJkIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNlbGVjdE5vZGVCYWNrd2FyZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZWxlY3QgYSBub2RlIGJhY2t3YXJkLlxuICAgICAgICovXG4gICAgICBzZWxlY3ROb2RlQmFja3dhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNlbGVjdE5vZGVCYWNrd2FyZDogUmF3Q29tbWFuZHNbJ3NlbGVjdE5vZGVCYWNrd2FyZCddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0Tm9kZUJhY2t3YXJkKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBzZWxlY3ROb2RlRm9yd2FyZCBhcyBvcmlnaW5hbFNlbGVjdE5vZGVGb3J3YXJkIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNlbGVjdE5vZGVGb3J3YXJkOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNlbGVjdCBhIG5vZGUgZm9yd2FyZC5cbiAgICAgICAqL1xuICAgICAgc2VsZWN0Tm9kZUZvcndhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNlbGVjdE5vZGVGb3J3YXJkOiBSYXdDb21tYW5kc1snc2VsZWN0Tm9kZUZvcndhcmQnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbFNlbGVjdE5vZGVGb3J3YXJkKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBzZWxlY3RQYXJlbnROb2RlIGFzIG9yaWdpbmFsU2VsZWN0UGFyZW50Tm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZWxlY3RQYXJlbnROb2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNlbGVjdCB0aGUgcGFyZW50IG5vZGUuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdFBhcmVudE5vZGU6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNlbGVjdFBhcmVudE5vZGU6IFJhd0NvbW1hbmRzWydzZWxlY3RQYXJlbnROb2RlJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3RQYXJlbnROb2RlKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICIvLyBAdHMtaWdub3JlXG4vLyBUT0RPOiBhZGQgdHlwZXMgdG8gQHR5cGVzL3Byb3NlbWlycm9yLWNvbW1hbmRzXG5pbXBvcnQgeyBzZWxlY3RUZXh0YmxvY2tFbmQgYXMgb3JpZ2luYWxTZWxlY3RUZXh0YmxvY2tFbmQgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2VsZWN0VGV4dGJsb2NrRW5kOiB7XG4gICAgICAvKipcbiAgICAgICAqIE1vdmVzIHRoZSBjdXJzb3IgdG8gdGhlIGVuZCBvZiBjdXJyZW50IHRleHQgYmxvY2suXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdFRleHRibG9ja0VuZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2VsZWN0VGV4dGJsb2NrRW5kOiBSYXdDb21tYW5kc1snc2VsZWN0VGV4dGJsb2NrRW5kJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3RUZXh0YmxvY2tFbmQoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgIi8vIEB0cy1pZ25vcmVcbi8vIFRPRE86IGFkZCB0eXBlcyB0byBAdHlwZXMvcHJvc2VtaXJyb3ItY29tbWFuZHNcbmltcG9ydCB7IHNlbGVjdFRleHRibG9ja1N0YXJ0IGFzIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrU3RhcnQgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2VsZWN0VGV4dGJsb2NrU3RhcnQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogTW92ZXMgdGhlIGN1cnNvciB0byB0aGUgc3RhcnQgb2YgY3VycmVudCB0ZXh0IGJsb2NrLlxuICAgICAgICovXG4gICAgICBzZWxlY3RUZXh0YmxvY2tTdGFydDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2VsZWN0VGV4dGJsb2NrU3RhcnQ6IFJhd0NvbW1hbmRzWydzZWxlY3RUZXh0YmxvY2tTdGFydCddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrU3RhcnQoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLCBQYXJzZU9wdGlvbnMsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IENvbnRlbnQgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGNyZWF0ZU5vZGVGcm9tQ29udGVudCB9IGZyb20gJy4vY3JlYXRlTm9kZUZyb21Db250ZW50LmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnQoXG4gIGNvbnRlbnQ6IENvbnRlbnQsXG4gIHNjaGVtYTogU2NoZW1hLFxuICBwYXJzZU9wdGlvbnM6IFBhcnNlT3B0aW9ucyA9IHt9LFxuKTogUHJvc2VNaXJyb3JOb2RlIHtcbiAgcmV0dXJuIGNyZWF0ZU5vZGVGcm9tQ29udGVudChjb250ZW50LCBzY2hlbWEsIHsgc2xpY2U6IGZhbHNlLCBwYXJzZU9wdGlvbnMgfSkgYXMgUHJvc2VNaXJyb3JOb2RlXG59XG4iLCAiaW1wb3J0IHsgUGFyc2VPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgY3JlYXRlRG9jdW1lbnQgfSBmcm9tICcuLi9oZWxwZXJzL2NyZWF0ZURvY3VtZW50LmpzJ1xuaW1wb3J0IHsgQ29udGVudCwgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNldENvbnRlbnQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVwbGFjZSB0aGUgd2hvbGUgZG9jdW1lbnQgd2l0aCBuZXcgY29udGVudC5cbiAgICAgICAqL1xuICAgICAgc2V0Q29udGVudDogKFxuICAgICAgICBjb250ZW50OiBDb250ZW50LFxuICAgICAgICBlbWl0VXBkYXRlPzogYm9vbGVhbixcbiAgICAgICAgcGFyc2VPcHRpb25zPzogUGFyc2VPcHRpb25zLFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZXRDb250ZW50OiBSYXdDb21tYW5kc1snc2V0Q29udGVudCddID0gKGNvbnRlbnQsIGVtaXRVcGRhdGUgPSBmYWxzZSwgcGFyc2VPcHRpb25zID0ge30pID0+ICh7IHRyLCBlZGl0b3IsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBkb2MgfSA9IHRyXG4gIGNvbnN0IGRvY3VtZW50ID0gY3JlYXRlRG9jdW1lbnQoY29udGVudCwgZWRpdG9yLnNjaGVtYSwgcGFyc2VPcHRpb25zKVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHRyLnJlcGxhY2VXaXRoKDAsIGRvYy5jb250ZW50LnNpemUsIGRvY3VtZW50KS5zZXRNZXRhKCdwcmV2ZW50VXBkYXRlJywgIWVtaXRVcGRhdGUpXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IE1hcmssIE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuL2dldE1hcmtUeXBlLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFya0F0dHJpYnV0ZXMoXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZSxcbiAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTWFya1R5cGUsXG4pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgeyBmcm9tLCB0bywgZW1wdHkgfSA9IHN0YXRlLnNlbGVjdGlvblxuICBjb25zdCBtYXJrczogTWFya1tdID0gW11cblxuICBpZiAoZW1wdHkpIHtcbiAgICBpZiAoc3RhdGUuc3RvcmVkTWFya3MpIHtcbiAgICAgIG1hcmtzLnB1c2goLi4uc3RhdGUuc3RvcmVkTWFya3MpXG4gICAgfVxuXG4gICAgbWFya3MucHVzaCguLi5zdGF0ZS5zZWxlY3Rpb24uJGhlYWQubWFya3MoKSlcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBub2RlID0+IHtcbiAgICAgIG1hcmtzLnB1c2goLi4ubm9kZS5tYXJrcylcbiAgICB9KVxuICB9XG5cbiAgY29uc3QgbWFyayA9IG1hcmtzLmZpbmQobWFya0l0ZW0gPT4gbWFya0l0ZW0udHlwZS5uYW1lID09PSB0eXBlLm5hbWUpXG5cbiAgaWYgKCFtYXJrKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cblxuICByZXR1cm4geyAuLi5tYXJrLmF0dHJzIH1cbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGBUcmFuc2Zvcm1gIGJhc2VkIG9uIGFsbCBzdGVwcyBvZiB0aGUgcGFzc2VkIHRyYW5zYWN0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzKFxuICBvbGREb2M6IFByb3NlTWlycm9yTm9kZSxcbiAgdHJhbnNhY3Rpb25zOiBUcmFuc2FjdGlvbltdLFxuKTogVHJhbnNmb3JtIHtcbiAgY29uc3QgdHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybShvbGREb2MpXG5cbiAgdHJhbnNhY3Rpb25zLmZvckVhY2godHJhbnNhY3Rpb24gPT4ge1xuICAgIHRyYW5zYWN0aW9uLnN0ZXBzLmZvckVhY2goc3RlcCA9PiB7XG4gICAgICB0cmFuc2Zvcm0uc3RlcChzdGVwKVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHRyYW5zZm9ybVxufVxuIiwgImltcG9ydCB7IENvbnRlbnRNYXRjaCwgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdEJsb2NrQXQobWF0Y2g6IENvbnRlbnRNYXRjaCk6IE5vZGVUeXBlIHwgbnVsbCB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2guZWRnZUNvdW50OyBpICs9IDEpIHtcbiAgICBjb25zdCB7IHR5cGUgfSA9IG1hdGNoLmVkZ2UoaSlcblxuICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkge1xuICAgICAgcmV0dXJuIHR5cGVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgTm9kZVdpdGhQb3MsIFByZWRpY2F0ZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZmluZENoaWxkcmVuKG5vZGU6IFByb3NlTWlycm9yTm9kZSwgcHJlZGljYXRlOiBQcmVkaWNhdGUpOiBOb2RlV2l0aFBvc1tdIHtcbiAgY29uc3Qgbm9kZXNXaXRoUG9zOiBOb2RlV2l0aFBvc1tdID0gW11cblxuICBub2RlLmRlc2NlbmRhbnRzKChjaGlsZCwgcG9zKSA9PiB7XG4gICAgaWYgKHByZWRpY2F0ZShjaGlsZCkpIHtcbiAgICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgIHBvcyxcbiAgICAgIH0pXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBub2Rlc1dpdGhQb3Ncbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IE5vZGVXaXRoUG9zLCBQcmVkaWNhdGUsIFJhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbi8qKlxuICogU2FtZSBhcyBgZmluZENoaWxkcmVuYCBidXQgc2VhcmNoZXMgb25seSB3aXRoaW4gYSBgcmFuZ2VgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZENoaWxkcmVuSW5SYW5nZShcbiAgbm9kZTogUHJvc2VNaXJyb3JOb2RlLFxuICByYW5nZTogUmFuZ2UsXG4gIHByZWRpY2F0ZTogUHJlZGljYXRlLFxuKTogTm9kZVdpdGhQb3NbXSB7XG4gIGNvbnN0IG5vZGVzV2l0aFBvczogTm9kZVdpdGhQb3NbXSA9IFtdXG5cbiAgLy8gaWYgKHJhbmdlLmZyb20gPT09IHJhbmdlLnRvKSB7XG4gIC8vICAgY29uc3Qgbm9kZUF0ID0gbm9kZS5ub2RlQXQocmFuZ2UuZnJvbSlcblxuICAvLyAgIGlmIChub2RlQXQpIHtcbiAgLy8gICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgLy8gICAgICAgbm9kZTogbm9kZUF0LFxuICAvLyAgICAgICBwb3M6IHJhbmdlLmZyb20sXG4gIC8vICAgICB9KVxuICAvLyAgIH1cbiAgLy8gfVxuXG4gIG5vZGUubm9kZXNCZXR3ZWVuKHJhbmdlLmZyb20sIHJhbmdlLnRvLCAoY2hpbGQsIHBvcykgPT4ge1xuICAgIGlmIChwcmVkaWNhdGUoY2hpbGQpKSB7XG4gICAgICBub2Rlc1dpdGhQb3MucHVzaCh7XG4gICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICBwb3MsXG4gICAgICB9KVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gbm9kZXNXaXRoUG9zXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUsIFJlc29sdmVkUG9zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgUHJlZGljYXRlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1BvcyhcbiAgJHBvczogUmVzb2x2ZWRQb3MsXG4gIHByZWRpY2F0ZTogUHJlZGljYXRlLFxuKTpcbiAgfCB7XG4gICAgICBwb3M6IG51bWJlclxuICAgICAgc3RhcnQ6IG51bWJlclxuICAgICAgZGVwdGg6IG51bWJlclxuICAgICAgbm9kZTogUHJvc2VNaXJyb3JOb2RlXG4gICAgfVxuICB8IHVuZGVmaW5lZCB7XG4gIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoOyBpID4gMDsgaSAtPSAxKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRwb3Mubm9kZShpKVxuXG4gICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9zOiBpID4gMCA/ICRwb3MuYmVmb3JlKGkpIDogMCxcbiAgICAgICAgc3RhcnQ6ICRwb3Muc3RhcnQoaSksXG4gICAgICAgIGRlcHRoOiBpLFxuICAgICAgICBub2RlLFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IFByZWRpY2F0ZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MgfSBmcm9tICcuL2ZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZmluZFBhcmVudE5vZGUocHJlZGljYXRlOiBQcmVkaWNhdGUpIHtcbiAgcmV0dXJuIChzZWxlY3Rpb246IFNlbGVjdGlvbikgPT4gZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3Moc2VsZWN0aW9uLiRmcm9tLCBwcmVkaWNhdGUpXG59XG4iLCAiaW1wb3J0IHsgRE9NU2VyaWFsaXplciwgRnJhZ21lbnQsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIVE1MRnJvbUZyYWdtZW50KGZyYWdtZW50OiBGcmFnbWVudCwgc2NoZW1hOiBTY2hlbWEpOiBzdHJpbmcge1xuICBjb25zdCBkb2N1bWVudEZyYWdtZW50ID0gRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHNjaGVtYSkuc2VyaWFsaXplRnJhZ21lbnQoZnJhZ21lbnQpXG5cbiAgY29uc3QgdGVtcG9yYXJ5RG9jdW1lbnQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoKVxuICBjb25zdCBjb250YWluZXIgPSB0ZW1wb3JhcnlEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudEZyYWdtZW50KVxuXG4gIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG59XG4iLCAiaW1wb3J0IHsgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgRXh0ZW5zaW9uTWFuYWdlciB9IGZyb20gJy4uL0V4dGVuc2lvbk1hbmFnZXIuanMnXG5pbXBvcnQgeyBFeHRlbnNpb25zIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyB9IGZyb20gJy4vZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2hlbWEoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucywgZWRpdG9yPzogRWRpdG9yKTogU2NoZW1hIHtcbiAgY29uc3QgcmVzb2x2ZWRFeHRlbnNpb25zID0gRXh0ZW5zaW9uTWFuYWdlci5yZXNvbHZlKGV4dGVuc2lvbnMpXG5cbiAgcmV0dXJuIGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zKHJlc29sdmVkRXh0ZW5zaW9ucywgZWRpdG9yKVxufVxuIiwgImltcG9ydCB7IE5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb25zLCBKU09OQ29udGVudCB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZ2V0SFRNTEZyb21GcmFnbWVudCB9IGZyb20gJy4vZ2V0SFRNTEZyb21GcmFnbWVudC5qcydcbmltcG9ydCB7IGdldFNjaGVtYSB9IGZyb20gJy4vZ2V0U2NoZW1hLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVIVE1MKGRvYzogSlNPTkNvbnRlbnQsIGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpOiBzdHJpbmcge1xuICBjb25zdCBzY2hlbWEgPSBnZXRTY2hlbWEoZXh0ZW5zaW9ucylcbiAgY29uc3QgY29udGVudE5vZGUgPSBOb2RlLmZyb21KU09OKHNjaGVtYSwgZG9jKVxuXG4gIHJldHVybiBnZXRIVE1MRnJvbUZyYWdtZW50KGNvbnRlbnROb2RlLmNvbnRlbnQsIHNjaGVtYSlcbn1cbiIsICJpbXBvcnQgeyBET01QYXJzZXIgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb25zIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBlbGVtZW50RnJvbVN0cmluZyB9IGZyb20gJy4uL3V0aWxpdGllcy9lbGVtZW50RnJvbVN0cmluZy5qcydcbmltcG9ydCB7IGdldFNjaGVtYSB9IGZyb20gJy4vZ2V0U2NoZW1hLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVKU09OKGh0bWw6IHN0cmluZywgZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCBzY2hlbWEgPSBnZXRTY2hlbWEoZXh0ZW5zaW9ucylcbiAgY29uc3QgZG9tID0gZWxlbWVudEZyb21TdHJpbmcoaHRtbClcblxuICByZXR1cm4gRE9NUGFyc2VyLmZyb21TY2hlbWEoc2NoZW1hKS5wYXJzZShkb20pLnRvSlNPTigpXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBUZXh0U2VyaWFsaXplciB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZ2V0VGV4dEJldHdlZW4gfSBmcm9tICcuL2dldFRleHRCZXR3ZWVuLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dChcbiAgbm9kZTogUHJvc2VNaXJyb3JOb2RlLFxuICBvcHRpb25zPzoge1xuICAgIGJsb2NrU2VwYXJhdG9yPzogc3RyaW5nXG4gICAgdGV4dFNlcmlhbGl6ZXJzPzogUmVjb3JkPHN0cmluZywgVGV4dFNlcmlhbGl6ZXI+XG4gIH0sXG4pIHtcbiAgY29uc3QgcmFuZ2UgPSB7XG4gICAgZnJvbTogMCxcbiAgICB0bzogbm9kZS5jb250ZW50LnNpemUsXG4gIH1cblxuICByZXR1cm4gZ2V0VGV4dEJldHdlZW4obm9kZSwgcmFuZ2UsIG9wdGlvbnMpXG59XG4iLCAiaW1wb3J0IHsgTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IEV4dGVuc2lvbnMsIEpTT05Db250ZW50LCBUZXh0U2VyaWFsaXplciB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hIH0gZnJvbSAnLi9nZXRTY2hlbWEuanMnXG5pbXBvcnQgeyBnZXRUZXh0IH0gZnJvbSAnLi9nZXRUZXh0LmpzJ1xuaW1wb3J0IHsgZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSB9IGZyb20gJy4vZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVGV4dChcbiAgZG9jOiBKU09OQ29udGVudCxcbiAgZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyxcbiAgb3B0aW9ucz86IHtcbiAgICBibG9ja1NlcGFyYXRvcj86IHN0cmluZ1xuICAgIHRleHRTZXJpYWxpemVycz86IFJlY29yZDxzdHJpbmcsIFRleHRTZXJpYWxpemVyPlxuICB9LFxuKTogc3RyaW5nIHtcbiAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9ICdcXG5cXG4nLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fVxuICBjb25zdCBzY2hlbWEgPSBnZXRTY2hlbWEoZXh0ZW5zaW9ucylcbiAgY29uc3QgY29udGVudE5vZGUgPSBOb2RlLmZyb21KU09OKHNjaGVtYSwgZG9jKVxuXG4gIHJldHVybiBnZXRUZXh0KGNvbnRlbnROb2RlLCB7XG4gICAgYmxvY2tTZXBhcmF0b3IsXG4gICAgdGV4dFNlcmlhbGl6ZXJzOiB7XG4gICAgICAuLi5nZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hKHNjaGVtYSksXG4gICAgICAuLi50ZXh0U2VyaWFsaXplcnMsXG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBOb2RlLCBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi9nZXROb2RlVHlwZS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVBdHRyaWJ1dGVzKFxuICBzdGF0ZTogRWRpdG9yU3RhdGUsXG4gIHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLFxuKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvblxuICBjb25zdCBub2RlczogTm9kZVtdID0gW11cblxuICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBub2RlID0+IHtcbiAgICBub2Rlcy5wdXNoKG5vZGUpXG4gIH0pXG5cbiAgY29uc3Qgbm9kZSA9IG5vZGVzLnJldmVyc2UoKS5maW5kKG5vZGVJdGVtID0+IG5vZGVJdGVtLnR5cGUubmFtZSA9PT0gdHlwZS5uYW1lKVxuXG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB7fVxuICB9XG5cbiAgcmV0dXJuIHsgLi4ubm9kZS5hdHRycyB9XG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgZ2V0TWFya0F0dHJpYnV0ZXMgfSBmcm9tICcuL2dldE1hcmtBdHRyaWJ1dGVzLmpzJ1xuaW1wb3J0IHsgZ2V0Tm9kZUF0dHJpYnV0ZXMgfSBmcm9tICcuL2dldE5vZGVBdHRyaWJ1dGVzLmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUgfSBmcm9tICcuL2dldFNjaGVtYVR5cGVOYW1lQnlOYW1lLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyhcbiAgc3RhdGU6IEVkaXRvclN0YXRlLFxuICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSB8IE1hcmtUeXBlLFxuKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShcbiAgICB0eXBlb2YgdHlwZU9yTmFtZSA9PT0gJ3N0cmluZycgPyB0eXBlT3JOYW1lIDogdHlwZU9yTmFtZS5uYW1lLFxuICAgIHN0YXRlLnNjaGVtYSxcbiAgKVxuXG4gIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcbiAgICByZXR1cm4gZ2V0Tm9kZUF0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUgYXMgTm9kZVR5cGUpXG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgcmV0dXJuIGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lIGFzIE1hcmtUeXBlKVxuICB9XG5cbiAgcmV0dXJuIHt9XG59XG4iLCAiLyoqXG4gKiBSZW1vdmVzIGR1cGxpY2F0ZWQgdmFsdWVzIHdpdGhpbiBhbiBhcnJheS5cbiAqIFN1cHBvcnRzIG51bWJlcnMsIHN0cmluZ3MgYW5kIG9iamVjdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVzPFQ+KGFycmF5OiBUW10sIGJ5ID0gSlNPTi5zdHJpbmdpZnkpOiBUW10ge1xuICBjb25zdCBzZWVuOiBSZWNvcmQ8YW55LCBhbnk+ID0ge31cblxuICByZXR1cm4gYXJyYXkuZmlsdGVyKGl0ZW0gPT4ge1xuICAgIGNvbnN0IGtleSA9IGJ5KGl0ZW0pXG5cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlZW4sIGtleSlcbiAgICAgID8gZmFsc2VcbiAgICAgIDogKHNlZW5ba2V5XSA9IHRydWUpXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgU3RlcCwgVHJhbnNmb3JtIH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyByZW1vdmVEdXBsaWNhdGVzIH0gZnJvbSAnLi4vdXRpbGl0aWVzL3JlbW92ZUR1cGxpY2F0ZXMuanMnXG5cbmV4cG9ydCB0eXBlIENoYW5nZWRSYW5nZSA9IHtcbiAgb2xkUmFuZ2U6IFJhbmdlLFxuICBuZXdSYW5nZTogUmFuZ2UsXG59XG5cbi8qKlxuICogUmVtb3ZlcyBkdXBsaWNhdGVkIHJhbmdlcyBhbmQgcmFuZ2VzIHRoYXQgYXJlXG4gKiBmdWxseSBjYXB0dXJlZCBieSBvdGhlciByYW5nZXMuXG4gKi9cbmZ1bmN0aW9uIHNpbXBsaWZ5Q2hhbmdlZFJhbmdlcyhjaGFuZ2VzOiBDaGFuZ2VkUmFuZ2VbXSk6IENoYW5nZWRSYW5nZVtdIHtcbiAgY29uc3QgdW5pcXVlQ2hhbmdlcyA9IHJlbW92ZUR1cGxpY2F0ZXMoY2hhbmdlcylcblxuICByZXR1cm4gdW5pcXVlQ2hhbmdlcy5sZW5ndGggPT09IDFcbiAgICA/IHVuaXF1ZUNoYW5nZXNcbiAgICA6IHVuaXF1ZUNoYW5nZXMuZmlsdGVyKChjaGFuZ2UsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCByZXN0ID0gdW5pcXVlQ2hhbmdlcy5maWx0ZXIoKF8sIGkpID0+IGkgIT09IGluZGV4KVxuXG4gICAgICByZXR1cm4gIXJlc3Quc29tZShvdGhlckNoYW5nZSA9PiB7XG4gICAgICAgIHJldHVybiBjaGFuZ2Uub2xkUmFuZ2UuZnJvbSA+PSBvdGhlckNoYW5nZS5vbGRSYW5nZS5mcm9tXG4gICAgICAgICAgJiYgY2hhbmdlLm9sZFJhbmdlLnRvIDw9IG90aGVyQ2hhbmdlLm9sZFJhbmdlLnRvXG4gICAgICAgICAgJiYgY2hhbmdlLm5ld1JhbmdlLmZyb20gPj0gb3RoZXJDaGFuZ2UubmV3UmFuZ2UuZnJvbVxuICAgICAgICAgICYmIGNoYW5nZS5uZXdSYW5nZS50byA8PSBvdGhlckNoYW5nZS5uZXdSYW5nZS50b1xuICAgICAgfSlcbiAgICB9KVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGNoYW5nZWQgcmFuZ2VzXG4gKiBiYXNlZCBvbiB0aGUgZmlyc3QgYW5kIGxhc3Qgc3RhdGUgb2YgYWxsIHN0ZXBzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hhbmdlZFJhbmdlcyh0cmFuc2Zvcm06IFRyYW5zZm9ybSk6IENoYW5nZWRSYW5nZVtdIHtcbiAgY29uc3QgeyBtYXBwaW5nLCBzdGVwcyB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IGNoYW5nZXM6IENoYW5nZWRSYW5nZVtdID0gW11cblxuICBtYXBwaW5nLm1hcHMuZm9yRWFjaCgoc3RlcE1hcCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCByYW5nZXM6IFJhbmdlW10gPSBbXVxuXG4gICAgLy8gVGhpcyBhY2NvdW50cyBmb3Igc3RlcCBjaGFuZ2VzIHdoZXJlIG5vIHJhbmdlIHdhcyBhY3R1YWxseSBhbHRlcmVkXG4gICAgLy8gZS5nLiB3aGVuIHNldHRpbmcgYSBtYXJrLCBub2RlIGF0dHJpYnV0ZSwgZXRjLlxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoIXN0ZXBNYXAucmFuZ2VzLmxlbmd0aCkge1xuICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gc3RlcHNbaW5kZXhdIGFzIFN0ZXAgJiB7XG4gICAgICAgIGZyb20/OiBudW1iZXIsXG4gICAgICAgIHRvPzogbnVtYmVyLFxuICAgICAgfVxuXG4gICAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkIHx8IHRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3RlcE1hcC5mb3JFYWNoKChmcm9tLCB0bykgPT4ge1xuICAgICAgICByYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJhbmdlcy5mb3JFYWNoKCh7IGZyb20sIHRvIH0pID0+IHtcbiAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gbWFwcGluZy5zbGljZShpbmRleCkubWFwKGZyb20sIC0xKVxuICAgICAgY29uc3QgbmV3RW5kID0gbWFwcGluZy5zbGljZShpbmRleCkubWFwKHRvKVxuICAgICAgY29uc3Qgb2xkU3RhcnQgPSBtYXBwaW5nLmludmVydCgpLm1hcChuZXdTdGFydCwgLTEpXG4gICAgICBjb25zdCBvbGRFbmQgPSBtYXBwaW5nLmludmVydCgpLm1hcChuZXdFbmQpXG5cbiAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgIG9sZFJhbmdlOiB7XG4gICAgICAgICAgZnJvbTogb2xkU3RhcnQsXG4gICAgICAgICAgdG86IG9sZEVuZCxcbiAgICAgICAgfSxcbiAgICAgICAgbmV3UmFuZ2U6IHtcbiAgICAgICAgICBmcm9tOiBuZXdTdGFydCxcbiAgICAgICAgICB0bzogbmV3RW5kLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9KVxuICB9KVxuXG4gIHJldHVybiBzaW1wbGlmeUNoYW5nZWRSYW5nZXMoY2hhbmdlcylcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IEpTT05Db250ZW50IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmludGVyZmFjZSBEZWJ1Z0pTT05Db250ZW50IGV4dGVuZHMgSlNPTkNvbnRlbnQge1xuICBmcm9tOiBudW1iZXJcbiAgdG86IG51bWJlclxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVidWdKU09OKG5vZGU6IFByb3NlTWlycm9yTm9kZSwgc3RhcnRPZmZzZXQgPSAwKTogRGVidWdKU09OQ29udGVudCB7XG4gIGNvbnN0IGlzVG9wTm9kZSA9IG5vZGUudHlwZSA9PT0gbm9kZS50eXBlLnNjaGVtYS50b3BOb2RlVHlwZVxuICBjb25zdCBpbmNyZW1lbnQgPSBpc1RvcE5vZGUgPyAwIDogMVxuICBjb25zdCBmcm9tID0gc3RhcnRPZmZzZXRcbiAgY29uc3QgdG8gPSBmcm9tICsgbm9kZS5ub2RlU2l6ZVxuICBjb25zdCBtYXJrcyA9IG5vZGUubWFya3MubWFwKG1hcmsgPT4ge1xuICAgIGNvbnN0IG91dHB1dDogeyB0eXBlOiBzdHJpbmc7IGF0dHJzPzogUmVjb3JkPHN0cmluZywgYW55PiB9ID0ge1xuICAgICAgdHlwZTogbWFyay50eXBlLm5hbWUsXG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKG1hcmsuYXR0cnMpLmxlbmd0aCkge1xuICAgICAgb3V0cHV0LmF0dHJzID0geyAuLi5tYXJrLmF0dHJzIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0XG4gIH0pXG4gIGNvbnN0IGF0dHJzID0geyAuLi5ub2RlLmF0dHJzIH1cbiAgY29uc3Qgb3V0cHV0OiBEZWJ1Z0pTT05Db250ZW50ID0ge1xuICAgIHR5cGU6IG5vZGUudHlwZS5uYW1lLFxuICAgIGZyb20sXG4gICAgdG8sXG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoYXR0cnMpLmxlbmd0aCkge1xuICAgIG91dHB1dC5hdHRycyA9IGF0dHJzXG4gIH1cblxuICBpZiAobWFya3MubGVuZ3RoKSB7XG4gICAgb3V0cHV0Lm1hcmtzID0gbWFya3NcbiAgfVxuXG4gIGlmIChub2RlLmNvbnRlbnQuY2hpbGRDb3VudCkge1xuICAgIG91dHB1dC5jb250ZW50ID0gW11cblxuICAgIG5vZGUuZm9yRWFjaCgoY2hpbGQsIG9mZnNldCkgPT4ge1xuICAgICAgb3V0cHV0LmNvbnRlbnQ/LnB1c2goZ2V0RGVidWdKU09OKGNoaWxkLCBzdGFydE9mZnNldCArIG9mZnNldCArIGluY3JlbWVudCkpXG4gICAgfSlcbiAgfVxuXG4gIGlmIChub2RlLnRleHQpIHtcbiAgICBvdXRwdXQudGV4dCA9IG5vZGUudGV4dFxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgTWFya1JhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRNYXJrUmFuZ2UgfSBmcm9tICcuL2dldE1hcmtSYW5nZS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmtzQmV0d2Vlbihmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIsIGRvYzogUHJvc2VNaXJyb3JOb2RlKTogTWFya1JhbmdlW10ge1xuICBjb25zdCBtYXJrczogTWFya1JhbmdlW10gPSBbXVxuXG4gIC8vIGdldCBhbGwgaW5jbHVzaXZlIG1hcmtzIG9uIGVtcHR5IHNlbGVjdGlvblxuICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICBkb2NcbiAgICAgIC5yZXNvbHZlKGZyb20pXG4gICAgICAubWFya3MoKVxuICAgICAgLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgIGNvbnN0ICRwb3MgPSBkb2MucmVzb2x2ZShmcm9tIC0gMSlcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRNYXJrUmFuZ2UoJHBvcywgbWFyay50eXBlKVxuXG4gICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgIG1hcmssXG4gICAgICAgICAgLi4ucmFuZ2UsXG4gICAgICAgIH0pXG4gICAgICB9KVxuICB9IGVsc2Uge1xuICAgIGRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgIG1hcmtzLnB1c2goXG4gICAgICAgIC4uLm5vZGUubWFya3MubWFwKG1hcmsgPT4gKHtcbiAgICAgICAgICBmcm9tOiBwb3MsXG4gICAgICAgICAgdG86IHBvcyArIG5vZGUubm9kZVNpemUsXG4gICAgICAgICAgbWFyayxcbiAgICAgICAgfSkpLFxuICAgICAgKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gbWFya3Ncbn1cbiIsICJpbXBvcnQgeyBOb2RlLCBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IG5vZGUgb2YgYSBnaXZlbiB0eXBlIG9yIG5hbWUgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICogQHBhcmFtIHN0YXRlIFRoZSBlZGl0b3Igc3RhdGUuXG4gKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgbm9kZSB0eXBlIG9yIG5hbWUuXG4gKiBAcGFyYW0gcG9zIFRoZSBwb3NpdGlvbiB0byBzdGFydCBzZWFyY2hpbmcgZnJvbS5cbiAqIEBwYXJhbSBtYXhEZXB0aCBUaGUgbWF4aW11bSBkZXB0aCB0byBzZWFyY2guXG4gKiBAcmV0dXJucyBUaGUgbm9kZSBhbmQgdGhlIGRlcHRoIGFzIGFuIGFycmF5LlxuICovXG5leHBvcnQgY29uc3QgZ2V0Tm9kZUF0UG9zaXRpb24gPSAoc3RhdGU6IEVkaXRvclN0YXRlLCB0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgcG9zOiBudW1iZXIsIG1heERlcHRoID0gMjApID0+IHtcbiAgY29uc3QgJHBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKHBvcylcblxuICBsZXQgY3VycmVudERlcHRoID0gbWF4RGVwdGhcbiAgbGV0IG5vZGU6IE5vZGUgfCBudWxsID0gbnVsbFxuXG4gIHdoaWxlIChjdXJyZW50RGVwdGggPiAwICYmIG5vZGUgPT09IG51bGwpIHtcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9ICRwb3Mubm9kZShjdXJyZW50RGVwdGgpXG5cbiAgICBpZiAoY3VycmVudE5vZGU/LnR5cGUubmFtZSA9PT0gdHlwZU9yTmFtZSkge1xuICAgICAgbm9kZSA9IGN1cnJlbnROb2RlXG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnREZXB0aCAtPSAxXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtub2RlLCBjdXJyZW50RGVwdGhdIGFzIFtOb2RlIHwgbnVsbCwgbnVtYmVyXVxufVxuIiwgImltcG9ydCB7IEV4dGVuc2lvbkF0dHJpYnV0ZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKFxuICBleHRlbnNpb25BdHRyaWJ1dGVzOiBFeHRlbnNpb25BdHRyaWJ1dGVbXSxcbiAgdHlwZU5hbWU6IHN0cmluZyxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdFxuICAgIC5lbnRyaWVzKGF0dHJpYnV0ZXMpXG4gICAgLmZpbHRlcigoW25hbWVdKSA9PiB7XG4gICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGUgPSBleHRlbnNpb25BdHRyaWJ1dGVzLmZpbmQoaXRlbSA9PiB7XG4gICAgICAgIHJldHVybiBpdGVtLnR5cGUgPT09IHR5cGVOYW1lICYmIGl0ZW0ubmFtZSA9PT0gbmFtZVxuICAgICAgfSlcblxuICAgICAgaWYgKCFleHRlbnNpb25BdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGUuYXR0cmlidXRlLmtlZXBPblNwbGl0XG4gICAgfSkpXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBNYXJrUmFuZ2UgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG9iamVjdEluY2x1ZGVzIH0gZnJvbSAnLi4vdXRpbGl0aWVzL29iamVjdEluY2x1ZGVzLmpzJ1xuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuL2dldE1hcmtUeXBlLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNNYXJrQWN0aXZlKFxuICBzdGF0ZTogRWRpdG9yU3RhdGUsXG4gIHR5cGVPck5hbWU6IE1hcmtUeXBlIHwgc3RyaW5nIHwgbnVsbCxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uXG4gIGNvbnN0IHR5cGUgPSB0eXBlT3JOYW1lID8gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKSA6IG51bGxcblxuICBpZiAoZW1wdHkpIHtcbiAgICByZXR1cm4gISEoc3RhdGUuc3RvcmVkTWFya3MgfHwgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpXG4gICAgICAuZmlsdGVyKG1hcmsgPT4ge1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gbWFyay50eXBlLm5hbWVcbiAgICAgIH0pXG4gICAgICAuZmluZChtYXJrID0+IG9iamVjdEluY2x1ZGVzKG1hcmsuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSlcbiAgfVxuXG4gIGxldCBzZWxlY3Rpb25SYW5nZSA9IDBcbiAgY29uc3QgbWFya1JhbmdlczogTWFya1JhbmdlW10gPSBbXVxuXG4gIHJhbmdlcy5mb3JFYWNoKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgIGNvbnN0IGZyb20gPSAkZnJvbS5wb3NcbiAgICBjb25zdCB0byA9ICR0by5wb3NcblxuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgIGlmICghbm9kZS5pc1RleHQgJiYgIW5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCByZWxhdGl2ZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpXG4gICAgICBjb25zdCByZWxhdGl2ZVRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUubm9kZVNpemUpXG4gICAgICBjb25zdCByYW5nZSA9IHJlbGF0aXZlVG8gLSByZWxhdGl2ZUZyb21cblxuICAgICAgc2VsZWN0aW9uUmFuZ2UgKz0gcmFuZ2VcblxuICAgICAgbWFya1Jhbmdlcy5wdXNoKFxuICAgICAgICAuLi5ub2RlLm1hcmtzLm1hcChtYXJrID0+ICh7XG4gICAgICAgICAgbWFyayxcbiAgICAgICAgICBmcm9tOiByZWxhdGl2ZUZyb20sXG4gICAgICAgICAgdG86IHJlbGF0aXZlVG8sXG4gICAgICAgIH0pKSxcbiAgICAgIClcbiAgICB9KVxuICB9KVxuXG4gIGlmIChzZWxlY3Rpb25SYW5nZSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gY2FsY3VsYXRlIHJhbmdlIG9mIG1hdGNoZWQgbWFya1xuICBjb25zdCBtYXRjaGVkUmFuZ2UgPSBtYXJrUmFuZ2VzXG4gICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4ge1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09IG1hcmtSYW5nZS5tYXJrLnR5cGUubmFtZVxuICAgIH0pXG4gICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4gb2JqZWN0SW5jbHVkZXMobWFya1JhbmdlLm1hcmsuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSlcbiAgICAucmVkdWNlKChzdW0sIG1hcmtSYW5nZSkgPT4gc3VtICsgbWFya1JhbmdlLnRvIC0gbWFya1JhbmdlLmZyb20sIDApXG5cbiAgLy8gY2FsY3VsYXRlIHJhbmdlIG9mIG1hcmtzIHRoYXQgZXhjbHVkZXMgdGhlIHNlYXJjaGVkIG1hcmtcbiAgLy8gZm9yIGV4YW1wbGUgYGNvZGVgIGRvZXNu4oCZdCBhbGxvdyBhbnkgb3RoZXIgbWFya3NcbiAgY29uc3QgZXhjbHVkZWRSYW5nZSA9IG1hcmtSYW5nZXNcbiAgICAuZmlsdGVyKG1hcmtSYW5nZSA9PiB7XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcmtSYW5nZS5tYXJrLnR5cGUgIT09IHR5cGUgJiYgbWFya1JhbmdlLm1hcmsudHlwZS5leGNsdWRlcyh0eXBlKVxuICAgIH0pXG4gICAgLnJlZHVjZSgoc3VtLCBtYXJrUmFuZ2UpID0+IHN1bSArIG1hcmtSYW5nZS50byAtIG1hcmtSYW5nZS5mcm9tLCAwKVxuXG4gIC8vIHdlIG9ubHkgaW5jbHVkZSB0aGUgcmVzdWx0IG9mIGBleGNsdWRlZFJhbmdlYFxuICAvLyBpZiB0aGVyZSBpcyBhIG1hdGNoIGF0IGFsbFxuICBjb25zdCByYW5nZSA9IG1hdGNoZWRSYW5nZSA+IDAgPyBtYXRjaGVkUmFuZ2UgKyBleGNsdWRlZFJhbmdlIDogbWF0Y2hlZFJhbmdlXG5cbiAgcmV0dXJuIHJhbmdlID49IHNlbGVjdGlvblJhbmdlXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSB9IGZyb20gJy4vZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUuanMnXG5pbXBvcnQgeyBpc01hcmtBY3RpdmUgfSBmcm9tICcuL2lzTWFya0FjdGl2ZS5qcydcbmltcG9ydCB7IGlzTm9kZUFjdGl2ZSB9IGZyb20gJy4vaXNOb2RlQWN0aXZlLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNBY3RpdmUoXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZSxcbiAgbmFtZTogc3RyaW5nIHwgbnVsbCxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogYm9vbGVhbiB7XG4gIGlmICghbmFtZSkge1xuICAgIHJldHVybiBpc05vZGVBY3RpdmUoc3RhdGUsIG51bGwsIGF0dHJpYnV0ZXMpIHx8IGlzTWFya0FjdGl2ZShzdGF0ZSwgbnVsbCwgYXR0cmlidXRlcylcbiAgfVxuXG4gIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShuYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09ICdub2RlJykge1xuICAgIHJldHVybiBpc05vZGVBY3RpdmUoc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMpXG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgcmV0dXJuIGlzTWFya0FjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcylcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwgImltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgZmluZFBhcmVudE5vZGUgfSBmcm9tICcuL2ZpbmRQYXJlbnROb2RlLmpzJ1xuXG5leHBvcnQgY29uc3QgaXNBdEVuZE9mTm9kZSA9IChzdGF0ZTogRWRpdG9yU3RhdGUsIG5vZGVUeXBlPzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHsgJGZyb20sICR0bywgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uXG5cbiAgaWYgKG5vZGVUeXBlKSB7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gbm9kZS50eXBlLm5hbWUgPT09IG5vZGVUeXBlKShzdGF0ZS5zZWxlY3Rpb24pXG5cbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0ICRwYXJlbnRQb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwYXJlbnROb2RlLnBvcyArIDEpXG5cbiAgICBpZiAoJGFuY2hvci5wb3MgKyAxID09PSAkcGFyZW50UG9zLmVuZCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKCR0by5wYXJlbnRPZmZzZXQgPCAkdG8ucGFyZW50Lm5vZGVTaXplIC0gMiB8fCAkZnJvbS5wb3MgIT09ICR0by5wb3MpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5leHBvcnQgY29uc3QgaXNBdFN0YXJ0T2ZOb2RlID0gKHN0YXRlOiBFZGl0b3JTdGF0ZSkgPT4ge1xuICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvblxuXG4gIGlmICgkZnJvbS5wYXJlbnRPZmZzZXQgPiAwIHx8ICRmcm9tLnBvcyAhPT0gJHRvLnBvcykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBOb2RlQ29uZmlnIH0gZnJvbSAnLi4vaW5kZXguanMnXG5pbXBvcnQgeyBFeHRlbnNpb25zIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuaW1wb3J0IHsgc3BsaXRFeHRlbnNpb25zIH0gZnJvbSAnLi9zcGxpdEV4dGVuc2lvbnMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xpc3QobmFtZTogc3RyaW5nLCBleHRlbnNpb25zOiBFeHRlbnNpb25zKTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgbm9kZUV4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKVxuICBjb25zdCBleHRlbnNpb24gPSBub2RlRXh0ZW5zaW9ucy5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lID09PSBuYW1lKVxuXG4gIGlmICghZXh0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICB9XG4gIGNvbnN0IGdyb3VwID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2dyb3VwJ10+KGV4dGVuc2lvbiwgJ2dyb3VwJywgY29udGV4dCkpXG5cbiAgaWYgKHR5cGVvZiBncm91cCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBncm91cC5zcGxpdCgnICcpLmluY2x1ZGVzKCdsaXN0Jylcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVFbXB0eShub2RlOiBQcm9zZU1pcnJvck5vZGUpOiBib29sZWFuIHtcbiAgY29uc3QgZGVmYXVsdENvbnRlbnQgPSBub2RlLnR5cGUuY3JlYXRlQW5kRmlsbCgpPy50b0pTT04oKVxuICBjb25zdCBjb250ZW50ID0gbm9kZS50b0pTT04oKVxuXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShkZWZhdWx0Q29udGVudCkgPT09IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpXG59XG4iLCAiaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVTZWxlY3Rpb24odmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBOb2RlU2VsZWN0aW9uIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvblxufVxuIiwgImltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnXG5cbmltcG9ydCB7IG1pbk1heCB9IGZyb20gJy4uL3V0aWxpdGllcy9taW5NYXguanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBwb3NUb0RPTVJlY3QodmlldzogRWRpdG9yVmlldywgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyKTogRE9NUmVjdCB7XG4gIGNvbnN0IG1pblBvcyA9IDBcbiAgY29uc3QgbWF4UG9zID0gdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplXG4gIGNvbnN0IHJlc29sdmVkRnJvbSA9IG1pbk1heChmcm9tLCBtaW5Qb3MsIG1heFBvcylcbiAgY29uc3QgcmVzb2x2ZWRFbmQgPSBtaW5NYXgodG8sIG1pblBvcywgbWF4UG9zKVxuICBjb25zdCBzdGFydCA9IHZpZXcuY29vcmRzQXRQb3MocmVzb2x2ZWRGcm9tKVxuICBjb25zdCBlbmQgPSB2aWV3LmNvb3Jkc0F0UG9zKHJlc29sdmVkRW5kLCAtMSlcbiAgY29uc3QgdG9wID0gTWF0aC5taW4oc3RhcnQudG9wLCBlbmQudG9wKVxuICBjb25zdCBib3R0b20gPSBNYXRoLm1heChzdGFydC5ib3R0b20sIGVuZC5ib3R0b20pXG4gIGNvbnN0IGxlZnQgPSBNYXRoLm1pbihzdGFydC5sZWZ0LCBlbmQubGVmdClcbiAgY29uc3QgcmlnaHQgPSBNYXRoLm1heChzdGFydC5yaWdodCwgZW5kLnJpZ2h0KVxuICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdFxuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3BcbiAgY29uc3QgeCA9IGxlZnRcbiAgY29uc3QgeSA9IHRvcFxuICBjb25zdCBkYXRhID0ge1xuICAgIHRvcCxcbiAgICBib3R0b20sXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5LFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIHRvSlNPTjogKCkgPT4gZGF0YSxcbiAgfVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlLCBSZXNvbHZlZFBvcyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSwgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXRNYXJrQXR0cmlidXRlcyB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya0F0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBpc1RleHRTZWxlY3Rpb24gfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNldE1hcms6IHtcbiAgICAgIC8qKlxuICAgICAgICogQWRkIGEgbWFyayB3aXRoIG5ldyBhdHRyaWJ1dGVzLlxuICAgICAgICovXG4gICAgICBzZXRNYXJrOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTWFya1R5cGUsIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhblNldE1hcmsoc3RhdGU6IEVkaXRvclN0YXRlLCB0cjogVHJhbnNhY3Rpb24sIG5ld01hcmtUeXBlOiBNYXJrVHlwZSkge1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHJcbiAgbGV0IGN1cnNvcjogUmVzb2x2ZWRQb3MgfCBudWxsID0gbnVsbFxuXG4gIGlmIChpc1RleHRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGN1cnNvciA9IHNlbGVjdGlvbi4kY3Vyc29yXG4gIH1cblxuICBpZiAoY3Vyc29yKSB7XG4gICAgY29uc3QgY3VycmVudE1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3MgPz8gY3Vyc29yLm1hcmtzKClcblxuICAgIC8vIFRoZXJlIGNhbiBiZSBubyBjdXJyZW50IG1hcmtzIHRoYXQgZXhjbHVkZSB0aGUgbmV3IG1hcmtcbiAgICByZXR1cm4gKFxuICAgICAgISFuZXdNYXJrVHlwZS5pc0luU2V0KGN1cnJlbnRNYXJrcylcbiAgICAgIHx8ICFjdXJyZW50TWFya3Muc29tZShtYXJrID0+IG1hcmsudHlwZS5leGNsdWRlcyhuZXdNYXJrVHlwZSkpXG4gICAgKVxuICB9XG5cbiAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvblxuXG4gIHJldHVybiByYW5nZXMuc29tZSgoeyAkZnJvbSwgJHRvIH0pID0+IHtcbiAgICBsZXQgc29tZU5vZGVTdXBwb3J0c01hcmsgPSAkZnJvbS5kZXB0aCA9PT0gMFxuICAgICAgPyBzdGF0ZS5kb2MuaW5saW5lQ29udGVudCAmJiBzdGF0ZS5kb2MudHlwZS5hbGxvd3NNYXJrVHlwZShuZXdNYXJrVHlwZSlcbiAgICAgIDogZmFsc2VcblxuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgX3BvcywgcGFyZW50KSA9PiB7XG4gICAgICAvLyBJZiB3ZSBhbHJlYWR5IGZvdW5kIGEgbWFyayB0aGF0IHdlIGNhbiBlbmFibGUsIHJldHVybiBmYWxzZSB0byBieXBhc3MgdGhlIHJlbWFpbmluZyBzZWFyY2hcbiAgICAgIGlmIChzb21lTm9kZVN1cHBvcnRzTWFyaykge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuaXNJbmxpbmUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50QWxsb3dzTWFya1R5cGUgPSAhcGFyZW50IHx8IHBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG5ld01hcmtUeXBlKVxuICAgICAgICBjb25zdCBjdXJyZW50TWFya3NBbGxvd01hcmtUeXBlID0gISFuZXdNYXJrVHlwZS5pc0luU2V0KG5vZGUubWFya3MpXG4gICAgICAgICAgfHwgIW5vZGUubWFya3Muc29tZShvdGhlck1hcmsgPT4gb3RoZXJNYXJrLnR5cGUuZXhjbHVkZXMobmV3TWFya1R5cGUpKVxuXG4gICAgICAgIHNvbWVOb2RlU3VwcG9ydHNNYXJrID0gcGFyZW50QWxsb3dzTWFya1R5cGUgJiYgY3VycmVudE1hcmtzQWxsb3dNYXJrVHlwZVxuICAgICAgfVxuICAgICAgcmV0dXJuICFzb21lTm9kZVN1cHBvcnRzTWFya1xuICAgIH0pXG5cbiAgICByZXR1cm4gc29tZU5vZGVTdXBwb3J0c01hcmtcbiAgfSlcbn1cbmV4cG9ydCBjb25zdCBzZXRNYXJrOiBSYXdDb21tYW5kc1snc2V0TWFyayddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0clxuICBjb25zdCB7IGVtcHR5LCByYW5nZXMgfSA9IHNlbGVjdGlvblxuICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGlmIChlbXB0eSkge1xuICAgICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlKVxuXG4gICAgICB0ci5hZGRTdG9yZWRNYXJrKFxuICAgICAgICB0eXBlLmNyZWF0ZSh7XG4gICAgICAgICAgLi4ub2xkQXR0cmlidXRlcyxcbiAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICBjb25zdCBmcm9tID0gcmFuZ2UuJGZyb20ucG9zXG4gICAgICAgIGNvbnN0IHRvID0gcmFuZ2UuJHRvLnBvc1xuXG4gICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICBjb25zdCB0cmltbWVkRnJvbSA9IE1hdGgubWF4KHBvcywgZnJvbSlcbiAgICAgICAgICBjb25zdCB0cmltbWVkVG8gPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0bylcbiAgICAgICAgICBjb25zdCBzb21lSGFzTWFyayA9IG5vZGUubWFya3MuZmluZChtYXJrID0+IG1hcmsudHlwZSA9PT0gdHlwZSlcblxuICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBtYXJrIG9mIHRoaXMgdHlwZVxuICAgICAgICAgIC8vIHdlIGtub3cgdGhhdCB3ZSBoYXZlIHRvIG1lcmdlIGl0cyBhdHRyaWJ1dGVzXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGFkZCBhIGZyZXNoIG5ldyBtYXJrXG4gICAgICAgICAgaWYgKHNvbWVIYXNNYXJrKSB7XG4gICAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgICAgICAgIGlmICh0eXBlID09PSBtYXJrLnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKFxuICAgICAgICAgICAgICAgICAgdHJpbW1lZEZyb20sXG4gICAgICAgICAgICAgICAgICB0cmltbWVkVG8sXG4gICAgICAgICAgICAgICAgICB0eXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyLmFkZE1hcmsodHJpbW1lZEZyb20sIHRyaW1tZWRUbywgdHlwZS5jcmVhdGUoYXR0cmlidXRlcykpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FuU2V0TWFyayhzdGF0ZSwgdHIsIHR5cGUpXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNldE1ldGE6IHtcbiAgICAgIC8qKlxuICAgICAgICogU3RvcmUgYSBtZXRhZGF0YSBwcm9wZXJ0eSBpbiB0aGUgY3VycmVudCB0cmFuc2FjdGlvbi5cbiAgICAgICAqL1xuICAgICAgc2V0TWV0YTogKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2V0TWV0YTogUmF3Q29tbWFuZHNbJ3NldE1ldGEnXSA9IChrZXksIHZhbHVlKSA9PiAoeyB0ciB9KSA9PiB7XG4gIHRyLnNldE1ldGEoa2V5LCB2YWx1ZSlcblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IHNldEJsb2NrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5pbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZXROb2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlcGxhY2UgYSBnaXZlbiByYW5nZSB3aXRoIGEgbm9kZS5cbiAgICAgICAqL1xuICAgICAgc2V0Tm9kZTogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2V0Tm9kZTogUmF3Q29tbWFuZHNbJ3NldE5vZGUnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCwgY2hhaW4gfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIC8vIFRPRE86IHVzZSBhIGZhbGxiYWNrIGxpa2UgaW5zZXJ0Q29udGVudD9cbiAgaWYgKCF0eXBlLmlzVGV4dGJsb2NrKSB7XG4gICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBDdXJyZW50bHkgXCJzZXROb2RlKClcIiBvbmx5IHN1cHBvcnRzIHRleHQgYmxvY2sgbm9kZXMuJylcblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICBjaGFpbigpXG4gICAgLy8gdHJ5IHRvIGNvbnZlcnQgbm9kZSB0byBkZWZhdWx0IG5vZGUgaWYgbmVlZGVkXG4gICAgICAuY29tbWFuZCgoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhblNldEJsb2NrID0gc2V0QmxvY2tUeXBlKHR5cGUsIGF0dHJpYnV0ZXMpKHN0YXRlKVxuXG4gICAgICAgIGlmIChjYW5TZXRCbG9jaykge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpXG4gICAgICB9KVxuICAgICAgLmNvbW1hbmQoKHsgc3RhdGU6IHVwZGF0ZWRTdGF0ZSB9KSA9PiB7XG4gICAgICAgIHJldHVybiBzZXRCbG9ja1R5cGUodHlwZSwgYXR0cmlidXRlcykodXBkYXRlZFN0YXRlLCBkaXNwYXRjaClcbiAgICAgIH0pXG4gICAgICAucnVuKClcbiAgKVxufVxuIiwgImltcG9ydCB7IE5vZGVTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgbWluTWF4IH0gZnJvbSAnLi4vdXRpbGl0aWVzL21pbk1heC5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNldE5vZGVTZWxlY3Rpb246IHtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIE5vZGVTZWxlY3Rpb24uXG4gICAgICAgKi9cbiAgICAgIHNldE5vZGVTZWxlY3Rpb246IChwb3NpdGlvbjogbnVtYmVyKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZXROb2RlU2VsZWN0aW9uOiBSYXdDb21tYW5kc1snc2V0Tm9kZVNlbGVjdGlvbiddID0gcG9zaXRpb24gPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgeyBkb2MgfSA9IHRyXG4gICAgY29uc3QgZnJvbSA9IG1pbk1heChwb3NpdGlvbiwgMCwgZG9jLmNvbnRlbnQuc2l6ZSlcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIGZyb20pXG5cbiAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgUmFuZ2UsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBtaW5NYXggfSBmcm9tICcuLi91dGlsaXRpZXMvbWluTWF4LmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2V0VGV4dFNlbGVjdGlvbjoge1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgVGV4dFNlbGVjdGlvbi5cbiAgICAgICAqL1xuICAgICAgc2V0VGV4dFNlbGVjdGlvbjogKHBvc2l0aW9uOiBudW1iZXIgfCBSYW5nZSkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2V0VGV4dFNlbGVjdGlvbjogUmF3Q29tbWFuZHNbJ3NldFRleHRTZWxlY3Rpb24nXSA9IHBvc2l0aW9uID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHsgZG9jIH0gPSB0clxuICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHR5cGVvZiBwb3NpdGlvbiA9PT0gJ251bWJlcicgPyB7IGZyb206IHBvc2l0aW9uLCB0bzogcG9zaXRpb24gfSA6IHBvc2l0aW9uXG4gICAgY29uc3QgbWluUG9zID0gVGV4dFNlbGVjdGlvbi5hdFN0YXJ0KGRvYykuZnJvbVxuICAgIGNvbnN0IG1heFBvcyA9IFRleHRTZWxlY3Rpb24uYXRFbmQoZG9jKS50b1xuICAgIGNvbnN0IHJlc29sdmVkRnJvbSA9IG1pbk1heChmcm9tLCBtaW5Qb3MsIG1heFBvcylcbiAgICBjb25zdCByZXNvbHZlZEVuZCA9IG1pbk1heCh0bywgbWluUG9zLCBtYXhQb3MpXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCByZXNvbHZlZEZyb20sIHJlc29sdmVkRW5kKVxuXG4gICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbilcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgc2lua0xpc3RJdGVtIGFzIG9yaWdpbmFsU2lua0xpc3RJdGVtIH0gZnJvbSAnQHRpcHRhcC9wbS9zY2hlbWEtbGlzdCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNpbmtMaXN0SXRlbToge1xuICAgICAgLyoqXG4gICAgICAgKiBTaW5rIHRoZSBsaXN0IGl0ZW0gZG93biBpbnRvIGFuIGlubmVyIGxpc3QuXG4gICAgICAgKi9cbiAgICAgIHNpbmtMaXN0SXRlbTogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzaW5rTGlzdEl0ZW06IFJhd0NvbW1hbmRzWydzaW5rTGlzdEl0ZW0nXSA9IHR5cGVPck5hbWUgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcblxuICByZXR1cm4gb3JpZ2luYWxTaW5rTGlzdEl0ZW0odHlwZSkoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IEVkaXRvclN0YXRlLCBOb2RlU2VsZWN0aW9uLCBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IGNhblNwbGl0IH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IGRlZmF1bHRCbG9ja0F0IH0gZnJvbSAnLi4vaGVscGVycy9kZWZhdWx0QmxvY2tBdC5qcydcbmltcG9ydCB7IGdldFNwbGl0dGVkQXR0cmlidXRlcyB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZnVuY3Rpb24gZW5zdXJlTWFya3Moc3RhdGU6IEVkaXRvclN0YXRlLCBzcGxpdHRhYmxlTWFya3M/OiBzdHJpbmdbXSkge1xuICBjb25zdCBtYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzIHx8IChzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSlcblxuICBpZiAobWFya3MpIHtcbiAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzPy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpXG5cbiAgICBzdGF0ZS50ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKVxuICB9XG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzcGxpdEJsb2NrOiB7XG4gICAgICAvKipcbiAgICAgICAqIEZvcmtzIGEgbmV3IG5vZGUgZnJvbSBhbiBleGlzdGluZyBub2RlLlxuICAgICAgICovXG4gICAgICBzcGxpdEJsb2NrOiAob3B0aW9ucz86IHsga2VlcE1hcmtzPzogYm9vbGVhbiB9KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzcGxpdEJsb2NrOiBSYXdDb21tYW5kc1snc3BsaXRCbG9jayddID0gKHsga2VlcE1hcmtzID0gdHJ1ZSB9ID0ge30pID0+ICh7XG4gIHRyLCBzdGF0ZSwgZGlzcGF0Y2gsIGVkaXRvcixcbn0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gdHJcbiAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzZWxlY3Rpb25cbiAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmF0dHJpYnV0ZXNcbiAgY29uc3QgbmV3QXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhcbiAgICBleHRlbnNpb25BdHRyaWJ1dGVzLFxuICAgICRmcm9tLm5vZGUoKS50eXBlLm5hbWUsXG4gICAgJGZyb20ubm9kZSgpLmF0dHJzLFxuICApXG5cbiAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc2VsZWN0aW9uLm5vZGUuaXNCbG9jaykge1xuICAgIGlmICghJGZyb20ucGFyZW50T2Zmc2V0IHx8ICFjYW5TcGxpdChkb2MsICRmcm9tLnBvcykpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgaWYgKGtlZXBNYXJrcykge1xuICAgICAgICBlbnN1cmVNYXJrcyhzdGF0ZSwgZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuc3BsaXR0YWJsZU1hcmtzKVxuICAgICAgfVxuXG4gICAgICB0ci5zcGxpdCgkZnJvbS5wb3MpLnNjcm9sbEludG9WaWV3KClcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKCEkZnJvbS5wYXJlbnQuaXNCbG9jaykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgYXRFbmQgPSAkdG8ucGFyZW50T2Zmc2V0ID09PSAkdG8ucGFyZW50LmNvbnRlbnQuc2l6ZVxuXG4gICAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICAgIHRyLmRlbGV0ZVNlbGVjdGlvbigpXG4gICAgfVxuXG4gICAgY29uc3QgZGVmbHQgPSAkZnJvbS5kZXB0aCA9PT0gMFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogZGVmYXVsdEJsb2NrQXQoJGZyb20ubm9kZSgtMSkuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcigtMSkpKVxuXG4gICAgbGV0IHR5cGVzID0gYXRFbmQgJiYgZGVmbHRcbiAgICAgID8gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogZGVmbHQsXG4gICAgICAgICAgYXR0cnM6IG5ld0F0dHJpYnV0ZXMsXG4gICAgICAgIH0sXG4gICAgICBdXG4gICAgICA6IHVuZGVmaW5lZFxuXG4gICAgbGV0IGNhbiA9IGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpXG5cbiAgICBpZiAoXG4gICAgICAhdHlwZXNcbiAgICAgICAgJiYgIWNhblxuICAgICAgICAmJiBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIGRlZmx0ID8gW3sgdHlwZTogZGVmbHQgfV0gOiB1bmRlZmluZWQpXG4gICAgKSB7XG4gICAgICBjYW4gPSB0cnVlXG4gICAgICB0eXBlcyA9IGRlZmx0XG4gICAgICAgID8gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IGRlZmx0LFxuICAgICAgICAgICAgYXR0cnM6IG5ld0F0dHJpYnV0ZXMsXG4gICAgICAgICAgfSxcbiAgICAgICAgXVxuICAgICAgICA6IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmIChjYW4pIHtcbiAgICAgIHRyLnNwbGl0KHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKVxuXG4gICAgICBpZiAoZGVmbHQgJiYgIWF0RW5kICYmICEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJGZyb20ucGFyZW50LnR5cGUgIT09IGRlZmx0KSB7XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gdHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpXG4gICAgICAgIGNvbnN0ICRmaXJzdCA9IHRyLmRvYy5yZXNvbHZlKGZpcnN0KVxuXG4gICAgICAgIGlmICgkZnJvbS5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkZmlyc3QuaW5kZXgoKSwgJGZpcnN0LmluZGV4KCkgKyAxLCBkZWZsdCkpIHtcbiAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKSwgZGVmbHQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2VlcE1hcmtzKSB7XG4gICAgICBlbnN1cmVNYXJrcyhzdGF0ZSwgZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuc3BsaXR0YWJsZU1hcmtzKVxuICAgIH1cblxuICAgIHRyLnNjcm9sbEludG9WaWV3KClcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHtcbiAgRnJhZ21lbnQsIE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLCBOb2RlVHlwZSwgU2xpY2UsXG59IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IGNhblNwbGl0IH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGdldFNwbGl0dGVkQXR0cmlidXRlcyB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNwbGl0TGlzdEl0ZW06IHtcbiAgICAgIC8qKlxuICAgICAgICogU3BsaXRzIG9uZSBsaXN0IGl0ZW0gaW50byB0d28gbGlzdCBpdGVtcy5cbiAgICAgICAqL1xuICAgICAgc3BsaXRMaXN0SXRlbTogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzcGxpdExpc3RJdGVtOiBSYXdDb21tYW5kc1snc3BsaXRMaXN0SXRlbSddID0gdHlwZU9yTmFtZSA9PiAoe1xuICB0ciwgc3RhdGUsIGRpc3BhdGNoLCBlZGl0b3IsXG59KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uXG5cbiAgLy8gQHRzLWlnbm9yZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBjb25zdCBub2RlOiBQcm9zZU1pcnJvck5vZGUgPSBzdGF0ZS5zZWxlY3Rpb24ubm9kZVxuXG4gIGlmICgobm9kZSAmJiBub2RlLmlzQmxvY2spIHx8ICRmcm9tLmRlcHRoIDwgMiB8fCAhJGZyb20uc2FtZVBhcmVudCgkdG8pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBncmFuZFBhcmVudCA9ICRmcm9tLm5vZGUoLTEpXG5cbiAgaWYgKGdyYW5kUGFyZW50LnR5cGUgIT09IHR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5hdHRyaWJ1dGVzXG5cbiAgaWYgKCRmcm9tLnBhcmVudC5jb250ZW50LnNpemUgPT09IDAgJiYgJGZyb20ubm9kZSgtMSkuY2hpbGRDb3VudCA9PT0gJGZyb20uaW5kZXhBZnRlcigtMSkpIHtcbiAgICAvLyBJbiBhbiBlbXB0eSBibG9jay4gSWYgdGhpcyBpcyBhIG5lc3RlZCBsaXN0LCB0aGUgd3JhcHBpbmdcbiAgICAvLyBsaXN0IGl0ZW0gc2hvdWxkIGJlIHNwbGl0LiBPdGhlcndpc2UsIGJhaWwgb3V0IGFuZCBsZXQgbmV4dFxuICAgIC8vIGNvbW1hbmQgaGFuZGxlIGxpZnRpbmcuXG4gICAgaWYgKFxuICAgICAgJGZyb20uZGVwdGggPT09IDJcbiAgICAgICAgfHwgJGZyb20ubm9kZSgtMykudHlwZSAhPT0gdHlwZVxuICAgICAgICB8fCAkZnJvbS5pbmRleCgtMikgIT09ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgLSAxXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGxldCB3cmFwID0gRnJhZ21lbnQuZW1wdHlcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBjb25zdCBkZXB0aEJlZm9yZSA9ICRmcm9tLmluZGV4KC0xKSA/IDEgOiAkZnJvbS5pbmRleCgtMikgPyAyIDogM1xuXG4gICAgICAvLyBCdWlsZCBhIGZyYWdtZW50IGNvbnRhaW5pbmcgZW1wdHkgdmVyc2lvbnMgb2YgdGhlIHN0cnVjdHVyZVxuICAgICAgLy8gZnJvbSB0aGUgb3V0ZXIgbGlzdCBpdGVtIHRvIHRoZSBwYXJlbnQgbm9kZSBvZiB0aGUgY3Vyc29yXG4gICAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGggLSBkZXB0aEJlZm9yZTsgZCA+PSAkZnJvbS5kZXB0aCAtIDM7IGQgLT0gMSkge1xuICAgICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGQpLmNvcHkod3JhcCkpXG4gICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBjb25zdCBkZXB0aEFmdGVyID0gJGZyb20uaW5kZXhBZnRlcigtMSkgPCAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50ID8gMSA6ICRmcm9tLmluZGV4QWZ0ZXIoLTIpIDwgJGZyb20ubm9kZSgtMykuY2hpbGRDb3VudCA/IDIgOiAzXG5cbiAgICAgIC8vIEFkZCBhIHNlY29uZCBsaXN0IGl0ZW0gd2l0aCBhbiBlbXB0eSBkZWZhdWx0IHN0YXJ0IG5vZGVcbiAgICAgIGNvbnN0IG5ld05leHRUeXBlQXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhcbiAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcyxcbiAgICAgICAgJGZyb20ubm9kZSgpLnR5cGUubmFtZSxcbiAgICAgICAgJGZyb20ubm9kZSgpLmF0dHJzLFxuICAgICAgKVxuICAgICAgY29uc3QgbmV4dFR5cGUgPSB0eXBlLmNvbnRlbnRNYXRjaC5kZWZhdWx0VHlwZT8uY3JlYXRlQW5kRmlsbChuZXdOZXh0VHlwZUF0dHJpYnV0ZXMpIHx8IHVuZGVmaW5lZFxuXG4gICAgICB3cmFwID0gd3JhcC5hcHBlbmQoRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZUFuZEZpbGwobnVsbCwgbmV4dFR5cGUpIHx8IHVuZGVmaW5lZCkpXG5cbiAgICAgIGNvbnN0IHN0YXJ0ID0gJGZyb20uYmVmb3JlKCRmcm9tLmRlcHRoIC0gKGRlcHRoQmVmb3JlIC0gMSkpXG5cbiAgICAgIHRyLnJlcGxhY2Uoc3RhcnQsICRmcm9tLmFmdGVyKC1kZXB0aEFmdGVyKSwgbmV3IFNsaWNlKHdyYXAsIDQgLSBkZXB0aEJlZm9yZSwgMCkpXG5cbiAgICAgIGxldCBzZWwgPSAtMVxuXG4gICAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKHN0YXJ0LCB0ci5kb2MuY29udGVudC5zaXplLCAobiwgcG9zKSA9PiB7XG4gICAgICAgIGlmIChzZWwgPiAtMSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4uaXNUZXh0YmxvY2sgJiYgbi5jb250ZW50LnNpemUgPT09IDApIHtcbiAgICAgICAgICBzZWwgPSBwb3MgKyAxXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGlmIChzZWwgPiAtMSkge1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKHNlbCkpKVxuICAgICAgfVxuXG4gICAgICB0ci5zY3JvbGxJbnRvVmlldygpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNvbnN0IG5leHRUeXBlID0gJHRvLnBvcyA9PT0gJGZyb20uZW5kKCkgPyBncmFuZFBhcmVudC5jb250ZW50TWF0Y2hBdCgwKS5kZWZhdWx0VHlwZSA6IG51bGxcblxuICBjb25zdCBuZXdUeXBlQXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhcbiAgICBleHRlbnNpb25BdHRyaWJ1dGVzLFxuICAgIGdyYW5kUGFyZW50LnR5cGUubmFtZSxcbiAgICBncmFuZFBhcmVudC5hdHRycyxcbiAgKVxuICBjb25zdCBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgPSBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoXG4gICAgZXh0ZW5zaW9uQXR0cmlidXRlcyxcbiAgICAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLFxuICAgICRmcm9tLm5vZGUoKS5hdHRycyxcbiAgKVxuXG4gIHRyLmRlbGV0ZSgkZnJvbS5wb3MsICR0by5wb3MpXG5cbiAgY29uc3QgdHlwZXMgPSBuZXh0VHlwZVxuICAgID8gW1xuICAgICAgeyB0eXBlLCBhdHRyczogbmV3VHlwZUF0dHJpYnV0ZXMgfSxcbiAgICAgIHsgdHlwZTogbmV4dFR5cGUsIGF0dHJzOiBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgfSxcbiAgICBdXG4gICAgOiBbeyB0eXBlLCBhdHRyczogbmV3VHlwZUF0dHJpYnV0ZXMgfV1cblxuICBpZiAoIWNhblNwbGl0KHRyLmRvYywgJGZyb20ucG9zLCAyKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZVxuICAgIGNvbnN0IHsgc3BsaXR0YWJsZU1hcmtzIH0gPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlclxuICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKVxuXG4gICAgdHIuc3BsaXQoJGZyb20ucG9zLCAyLCB0eXBlcykuc2Nyb2xsSW50b1ZpZXcoKVxuXG4gICAgaWYgKCFtYXJrcyB8fCAhZGlzcGF0Y2gpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpXG5cbiAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBjYW5Kb2luIH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IGZpbmRQYXJlbnROb2RlIH0gZnJvbSAnLi4vaGVscGVycy9maW5kUGFyZW50Tm9kZS5qcydcbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGlzTGlzdCB9IGZyb20gJy4uL2hlbHBlcnMvaXNMaXN0LmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuY29uc3Qgam9pbkxpc3RCYWNrd2FyZHMgPSAodHI6IFRyYW5zYWN0aW9uLCBsaXN0VHlwZTogTm9kZVR5cGUpOiBib29sZWFuID0+IHtcbiAgY29uc3QgbGlzdCA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gbm9kZS50eXBlID09PSBsaXN0VHlwZSkodHIuc2VsZWN0aW9uKVxuXG4gIGlmICghbGlzdCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBiZWZvcmUgPSB0ci5kb2MucmVzb2x2ZShNYXRoLm1heCgwLCBsaXN0LnBvcyAtIDEpKS5iZWZvcmUobGlzdC5kZXB0aClcblxuICBpZiAoYmVmb3JlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3Qgbm9kZUJlZm9yZSA9IHRyLmRvYy5ub2RlQXQoYmVmb3JlKVxuICBjb25zdCBjYW5Kb2luQmFja3dhcmRzID0gbGlzdC5ub2RlLnR5cGUgPT09IG5vZGVCZWZvcmU/LnR5cGUgJiYgY2FuSm9pbih0ci5kb2MsIGxpc3QucG9zKVxuXG4gIGlmICghY2FuSm9pbkJhY2t3YXJkcykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB0ci5qb2luKGxpc3QucG9zKVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmNvbnN0IGpvaW5MaXN0Rm9yd2FyZHMgPSAodHI6IFRyYW5zYWN0aW9uLCBsaXN0VHlwZTogTm9kZVR5cGUpOiBib29sZWFuID0+IHtcbiAgY29uc3QgbGlzdCA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gbm9kZS50eXBlID09PSBsaXN0VHlwZSkodHIuc2VsZWN0aW9uKVxuXG4gIGlmICghbGlzdCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBhZnRlciA9IHRyLmRvYy5yZXNvbHZlKGxpc3Quc3RhcnQpLmFmdGVyKGxpc3QuZGVwdGgpXG5cbiAgaWYgKGFmdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3Qgbm9kZUFmdGVyID0gdHIuZG9jLm5vZGVBdChhZnRlcilcbiAgY29uc3QgY2FuSm9pbkZvcndhcmRzID0gbGlzdC5ub2RlLnR5cGUgPT09IG5vZGVBZnRlcj8udHlwZSAmJiBjYW5Kb2luKHRyLmRvYywgYWZ0ZXIpXG5cbiAgaWYgKCFjYW5Kb2luRm9yd2FyZHMpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgdHIuam9pbihhZnRlcilcblxuICByZXR1cm4gdHJ1ZVxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdG9nZ2xlTGlzdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgbGlzdCB0eXBlcy5cbiAgICAgICAqL1xuICAgICAgdG9nZ2xlTGlzdDogKGxpc3RUeXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgaXRlbVR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBrZWVwTWFya3M/OiBib29sZWFuLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRvZ2dsZUxpc3Q6IFJhd0NvbW1hbmRzWyd0b2dnbGVMaXN0J10gPSAobGlzdFR5cGVPck5hbWUsIGl0ZW1UeXBlT3JOYW1lLCBrZWVwTWFya3MsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHtcbiAgZWRpdG9yLCB0ciwgc3RhdGUsIGRpc3BhdGNoLCBjaGFpbiwgY29tbWFuZHMsIGNhbixcbn0pID0+IHtcbiAgY29uc3QgeyBleHRlbnNpb25zLCBzcGxpdHRhYmxlTWFya3MgfSA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyXG4gIGNvbnN0IGxpc3RUeXBlID0gZ2V0Tm9kZVR5cGUobGlzdFR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgaXRlbVR5cGUgPSBnZXROb2RlVHlwZShpdGVtVHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlXG4gIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc2VsZWN0aW9uXG4gIGNvbnN0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pXG5cbiAgY29uc3QgbWFya3MgPSBzdG9yZWRNYXJrcyB8fCAoc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpXG5cbiAgaWYgKCFyYW5nZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgcGFyZW50TGlzdCA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gaXNMaXN0KG5vZGUudHlwZS5uYW1lLCBleHRlbnNpb25zKSkoc2VsZWN0aW9uKVxuXG4gIGlmIChyYW5nZS5kZXB0aCA+PSAxICYmIHBhcmVudExpc3QgJiYgcmFuZ2UuZGVwdGggLSBwYXJlbnRMaXN0LmRlcHRoIDw9IDEpIHtcbiAgICAvLyByZW1vdmUgbGlzdFxuICAgIGlmIChwYXJlbnRMaXN0Lm5vZGUudHlwZSA9PT0gbGlzdFR5cGUpIHtcbiAgICAgIHJldHVybiBjb21tYW5kcy5saWZ0TGlzdEl0ZW0oaXRlbVR5cGUpXG4gICAgfVxuXG4gICAgLy8gY2hhbmdlIGxpc3QgdHlwZVxuICAgIGlmIChcbiAgICAgIGlzTGlzdChwYXJlbnRMaXN0Lm5vZGUudHlwZS5uYW1lLCBleHRlbnNpb25zKVxuICAgICAgICAmJiBsaXN0VHlwZS52YWxpZENvbnRlbnQocGFyZW50TGlzdC5ub2RlLmNvbnRlbnQpXG4gICAgICAgICYmIGRpc3BhdGNoXG4gICAgKSB7XG4gICAgICByZXR1cm4gY2hhaW4oKVxuICAgICAgICAuY29tbWFuZCgoKSA9PiB7XG4gICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwYXJlbnRMaXN0LnBvcywgbGlzdFR5cGUpXG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9KVxuICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEJhY2t3YXJkcyh0ciwgbGlzdFR5cGUpKVxuICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAgIC5ydW4oKVxuICAgIH1cbiAgfVxuICBpZiAoIWtlZXBNYXJrcyB8fCAhbWFya3MgfHwgIWRpc3BhdGNoKSB7XG5cbiAgICByZXR1cm4gY2hhaW4oKVxuICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgbm9kZSB0byBkZWZhdWx0IG5vZGUgaWYgbmVlZGVkXG4gICAgICAuY29tbWFuZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbldyYXBJbkxpc3QgPSBjYW4oKS53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKVxuXG4gICAgICAgIGlmIChjYW5XcmFwSW5MaXN0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKClcbiAgICAgIH0pXG4gICAgICAud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcylcbiAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0QmFja3dhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAucnVuKClcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgY2hhaW4oKVxuICAgIC8vIHRyeSB0byBjb252ZXJ0IG5vZGUgdG8gZGVmYXVsdCBub2RlIGlmIG5lZWRlZFxuICAgICAgLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICBjb25zdCBjYW5XcmFwSW5MaXN0ID0gY2FuKCkud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcylcblxuICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSlcblxuICAgICAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKVxuXG4gICAgICAgIGlmIChjYW5XcmFwSW5MaXN0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKClcbiAgICAgIH0pXG4gICAgICAud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcylcbiAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0QmFja3dhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAucnVuKClcbiAgKVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtUeXBlLmpzJ1xuaW1wb3J0IHsgaXNNYXJrQWN0aXZlIH0gZnJvbSAnLi4vaGVscGVycy9pc01hcmtBY3RpdmUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdG9nZ2xlTWFyazoge1xuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBtYXJrIG9uIGFuZCBvZmYuXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZU1hcms6IChcbiAgICAgICAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTWFya1R5cGUsXG4gICAgICAgIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgICAgICBvcHRpb25zPzoge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFJlbW92ZXMgdGhlIG1hcmsgZXZlbiBhY3Jvc3MgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGV4dGVuZEVtcHR5TWFya1JhbmdlPzogYm9vbGVhblxuICAgICAgICB9LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVNYXJrOiBSYXdDb21tYW5kc1sndG9nZ2xlTWFyayddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSwgb3B0aW9ucyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICBjb25zdCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlID0gZmFsc2UgfSA9IG9wdGlvbnNcbiAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgaXNBY3RpdmUgPSBpc01hcmtBY3RpdmUoc3RhdGUsIHR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgaWYgKGlzQWN0aXZlKSB7XG4gICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0eXBlLCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlIH0pXG4gIH1cblxuICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0eXBlLCBhdHRyaWJ1dGVzKVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgaXNOb2RlQWN0aXZlIH0gZnJvbSAnLi4vaGVscGVycy9pc05vZGVBY3RpdmUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdG9nZ2xlTm9kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBub2RlIHdpdGggYW5vdGhlciBub2RlLlxuICAgICAgICovXG4gICAgICB0b2dnbGVOb2RlOiAoXG4gICAgICAgIHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLFxuICAgICAgICB0b2dnbGVUeXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSxcbiAgICAgICAgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRvZ2dsZU5vZGU6IFJhd0NvbW1hbmRzWyd0b2dnbGVOb2RlJ10gPSAodHlwZU9yTmFtZSwgdG9nZ2xlVHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCB0b2dnbGVUeXBlID0gZ2V0Tm9kZVR5cGUodG9nZ2xlVHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCBpc0FjdGl2ZSA9IGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcylcblxuICBpZiAoaXNBY3RpdmUpIHtcbiAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0b2dnbGVUeXBlKVxuICB9XG5cbiAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodHlwZSwgYXR0cmlidXRlcylcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGlzTm9kZUFjdGl2ZSB9IGZyb20gJy4uL2hlbHBlcnMvaXNOb2RlQWN0aXZlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHRvZ2dsZVdyYXA6IHtcbiAgICAgIC8qKlxuICAgICAgICogV3JhcHMgbm9kZXMgaW4gYW5vdGhlciBub2RlLCBvciByZW1vdmVzIGFuIGV4aXN0aW5nIHdyYXAuXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZVdyYXA6ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRvZ2dsZVdyYXA6IFJhd0NvbW1hbmRzWyd0b2dnbGVXcmFwJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCBpc0FjdGl2ZSA9IGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcylcblxuICBpZiAoaXNBY3RpdmUpIHtcbiAgICByZXR1cm4gY29tbWFuZHMubGlmdCh0eXBlKVxuICB9XG5cbiAgcmV0dXJuIGNvbW1hbmRzLndyYXBJbih0eXBlLCBhdHRyaWJ1dGVzKVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB1bmRvSW5wdXRSdWxlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFVuZG8gYW4gaW5wdXQgcnVsZS5cbiAgICAgICAqL1xuICAgICAgdW5kb0lucHV0UnVsZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHVuZG9JbnB1dFJ1bGU6IFJhd0NvbW1hbmRzWyd1bmRvSW5wdXRSdWxlJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCBwbHVnaW5zID0gc3RhdGUucGx1Z2luc1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbaV1cbiAgICBsZXQgdW5kb2FibGVcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBpZiAocGx1Z2luLnNwZWMuaXNJbnB1dFJ1bGVzICYmICh1bmRvYWJsZSA9IHBsdWdpbi5nZXRTdGF0ZShzdGF0ZSkpKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgdHIgPSBzdGF0ZS50clxuICAgICAgICBjb25zdCB0b1VuZG8gPSB1bmRvYWJsZS50cmFuc2Zvcm1cblxuICAgICAgICBmb3IgKGxldCBqID0gdG9VbmRvLnN0ZXBzLmxlbmd0aCAtIDE7IGogPj0gMDsgaiAtPSAxKSB7XG4gICAgICAgICAgdHIuc3RlcCh0b1VuZG8uc3RlcHNbal0uaW52ZXJ0KHRvVW5kby5kb2NzW2pdKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1bmRvYWJsZS50ZXh0KSB7XG4gICAgICAgICAgY29uc3QgbWFya3MgPSB0ci5kb2MucmVzb2x2ZSh1bmRvYWJsZS5mcm9tKS5tYXJrcygpXG5cbiAgICAgICAgICB0ci5yZXBsYWNlV2l0aCh1bmRvYWJsZS5mcm9tLCB1bmRvYWJsZS50bywgc3RhdGUuc2NoZW1hLnRleHQodW5kb2FibGUudGV4dCwgbWFya3MpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyLmRlbGV0ZSh1bmRvYWJsZS5mcm9tLCB1bmRvYWJsZS50bylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB1bnNldEFsbE1hcmtzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBhbGwgbWFya3MgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICovXG4gICAgICB1bnNldEFsbE1hcmtzOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdW5zZXRBbGxNYXJrczogUmF3Q29tbWFuZHNbJ3Vuc2V0QWxsTWFya3MnXSA9ICgpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0clxuICBjb25zdCB7IGVtcHR5LCByYW5nZXMgfSA9IHNlbGVjdGlvblxuXG4gIGlmIChlbXB0eSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICB0ci5yZW1vdmVNYXJrKHJhbmdlLiRmcm9tLnBvcywgcmFuZ2UuJHRvLnBvcylcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE1hcmtSYW5nZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1JhbmdlLmpzJ1xuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtUeXBlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHVuc2V0TWFyazoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgYWxsIG1hcmtzIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgICAqL1xuICAgICAgdW5zZXRNYXJrOiAoXG4gICAgICAgIHR5cGVPck5hbWU6IHN0cmluZyB8IE1hcmtUeXBlLFxuICAgICAgICBvcHRpb25zPzoge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFJlbW92ZXMgdGhlIG1hcmsgZXZlbiBhY3Jvc3MgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGV4dGVuZEVtcHR5TWFya1JhbmdlPzogYm9vbGVhblxuICAgICAgICB9LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB1bnNldE1hcms6IFJhd0NvbW1hbmRzWyd1bnNldE1hcmsnXSA9ICh0eXBlT3JOYW1lLCBvcHRpb25zID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlID0gZmFsc2UgfSA9IG9wdGlvbnNcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyXG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgJGZyb20sIGVtcHR5LCByYW5nZXMgfSA9IHNlbGVjdGlvblxuXG4gIGlmICghZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKGVtcHR5ICYmIGV4dGVuZEVtcHR5TWFya1JhbmdlKSB7XG4gICAgbGV0IHsgZnJvbSwgdG8gfSA9IHNlbGVjdGlvblxuICAgIGNvbnN0IGF0dHJzID0gJGZyb20ubWFya3MoKS5maW5kKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKT8uYXR0cnNcbiAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkZnJvbSwgdHlwZSwgYXR0cnMpXG5cbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgIGZyb20gPSByYW5nZS5mcm9tXG4gICAgICB0byA9IHJhbmdlLnRvXG4gICAgfVxuXG4gICAgdHIucmVtb3ZlTWFyayhmcm9tLCB0bywgdHlwZSlcbiAgfSBlbHNlIHtcbiAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICB0ci5yZW1vdmVNYXJrKHJhbmdlLiRmcm9tLnBvcywgcmFuZ2UuJHRvLnBvcywgdHlwZSlcbiAgICB9KVxuICB9XG5cbiAgdHIucmVtb3ZlU3RvcmVkTWFyayh0eXBlKVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtUeXBlLmpzJ1xuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUgfSBmcm9tICcuLi9oZWxwZXJzL2dldFNjaGVtYVR5cGVOYW1lQnlOYW1lLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHVwZGF0ZUF0dHJpYnV0ZXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlIGF0dHJpYnV0ZXMgb2YgYSBub2RlIG9yIG1hcmsuXG4gICAgICAgKi9cbiAgICAgIHVwZGF0ZUF0dHJpYnV0ZXM6IChcbiAgICAgICAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUgfCBNYXJrVHlwZSxcbiAgICAgICAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PixcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdXBkYXRlQXR0cmlidXRlczogUmF3Q29tbWFuZHNbJ3VwZGF0ZUF0dHJpYnV0ZXMnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBsZXQgbm9kZVR5cGU6IE5vZGVUeXBlIHwgbnVsbCA9IG51bGxcbiAgbGV0IG1hcmtUeXBlOiBNYXJrVHlwZSB8IG51bGwgPSBudWxsXG5cbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKFxuICAgIHR5cGVvZiB0eXBlT3JOYW1lID09PSAnc3RyaW5nJyA/IHR5cGVPck5hbWUgOiB0eXBlT3JOYW1lLm5hbWUsXG4gICAgc3RhdGUuc2NoZW1hLFxuICApXG5cbiAgaWYgKCFzY2hlbWFUeXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgbm9kZVR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lIGFzIE5vZGVUeXBlLCBzdGF0ZS5zY2hlbWEpXG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgbWFya1R5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lIGFzIE1hcmtUeXBlLCBzdGF0ZS5zY2hlbWEpXG4gIH1cblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5zZWxlY3Rpb24ucmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgY29uc3QgZnJvbSA9IHJhbmdlLiRmcm9tLnBvc1xuICAgICAgY29uc3QgdG8gPSByYW5nZS4kdG8ucG9zXG5cbiAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKG5vZGVUeXBlICYmIG5vZGVUeXBlID09PSBub2RlLnR5cGUpIHtcbiAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAuLi5ub2RlLmF0dHJzLFxuICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hcmtUeXBlICYmIG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgbm9kZS5tYXJrcy5mb3JFYWNoKG1hcmsgPT4ge1xuICAgICAgICAgICAgaWYgKG1hcmtUeXBlID09PSBtYXJrLnR5cGUpIHtcbiAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZEZyb20gPSBNYXRoLm1heChwb3MsIGZyb20pXG4gICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRUbyA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKVxuXG4gICAgICAgICAgICAgIHRyLmFkZE1hcmsoXG4gICAgICAgICAgICAgICAgdHJpbW1lZEZyb20sXG4gICAgICAgICAgICAgICAgdHJpbW1lZFRvLFxuICAgICAgICAgICAgICAgIG1hcmtUeXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAuLi5tYXJrLmF0dHJzLFxuICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgd3JhcEluIGFzIG9yaWdpbmFsV3JhcEluIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcbmltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHdyYXBJbjoge1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwcyBub2RlcyBpbiBhbm90aGVyIG5vZGUuXG4gICAgICAgKi9cbiAgICAgIHdyYXBJbjogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgd3JhcEluOiBSYXdDb21tYW5kc1snd3JhcEluJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIHJldHVybiBvcmlnaW5hbFdyYXBJbih0eXBlLCBhdHRyaWJ1dGVzKShzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgd3JhcEluTGlzdCBhcyBvcmlnaW5hbFdyYXBJbkxpc3QgfSBmcm9tICdAdGlwdGFwL3BtL3NjaGVtYS1saXN0J1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgd3JhcEluTGlzdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwIGEgbm9kZSBpbiBhIGxpc3QuXG4gICAgICAgKi9cbiAgICAgIHdyYXBJbkxpc3Q6ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHdyYXBJbkxpc3Q6IFJhd0NvbW1hbmRzWyd3cmFwSW5MaXN0J10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIHJldHVybiBvcmlnaW5hbFdyYXBJbkxpc3QodHlwZSwgYXR0cmlidXRlcykoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCAqIGFzIGNvbW1hbmRzIGZyb20gJy4uL2NvbW1hbmRzL2luZGV4LmpzJ1xuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnLi4vRXh0ZW5zaW9uLmpzJ1xuXG5leHBvcnQgKiBmcm9tICcuLi9jb21tYW5kcy9pbmRleC5qcydcblxuZXhwb3J0IGNvbnN0IENvbW1hbmRzID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICdjb21tYW5kcycsXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbW1hbmRzLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5cbmV4cG9ydCBjb25zdCBFZGl0YWJsZSA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAnZWRpdGFibGUnLFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnZWRpdGFibGUnKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBlZGl0YWJsZTogKCkgPT4gdGhpcy5lZGl0b3Iub3B0aW9ucy5lZGl0YWJsZSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5cbmV4cG9ydCBjb25zdCBGb2N1c0V2ZW50cyA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAnZm9jdXNFdmVudHMnLFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpc1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2ZvY3VzRXZlbnRzJyksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICBmb2N1czogKHZpZXcsIGV2ZW50OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgICBlZGl0b3IuaXNGb2N1c2VkID0gdHJ1ZVxuXG4gICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZWRpdG9yLnN0YXRlLnRyXG4gICAgICAgICAgICAgICAgLnNldE1ldGEoJ2ZvY3VzJywgeyBldmVudCB9KVxuICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdhZGRUb0hpc3RvcnknLCBmYWxzZSlcblxuICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKVxuXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJsdXI6ICh2aWV3LCBldmVudDogRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgZWRpdG9yLmlzRm9jdXNlZCA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBlZGl0b3Iuc3RhdGUudHJcbiAgICAgICAgICAgICAgICAuc2V0TWV0YSgnYmx1cicsIHsgZXZlbnQgfSlcbiAgICAgICAgICAgICAgICAuc2V0TWV0YSgnYWRkVG9IaXN0b3J5JywgZmFsc2UpXG5cbiAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbilcblxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXksIFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IENvbW1hbmRNYW5hZ2VyIH0gZnJvbSAnLi4vQ29tbWFuZE1hbmFnZXIuanMnXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5pbXBvcnQgeyBjcmVhdGVDaGFpbmFibGVTdGF0ZSB9IGZyb20gJy4uL2hlbHBlcnMvY3JlYXRlQ2hhaW5hYmxlU3RhdGUuanMnXG5pbXBvcnQgeyBpc2lPUyB9IGZyb20gJy4uL3V0aWxpdGllcy9pc2lPUy5qcydcbmltcG9ydCB7IGlzTWFjT1MgfSBmcm9tICcuLi91dGlsaXRpZXMvaXNNYWNPUy5qcydcblxuZXhwb3J0IGNvbnN0IEtleW1hcCA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAna2V5bWFwJyxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICBjb25zdCBoYW5kbGVCYWNrc3BhY2UgPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXG4gICAgICAoKSA9PiBjb21tYW5kcy51bmRvSW5wdXRSdWxlKCksXG5cbiAgICAgIC8vIG1heWJlIGNvbnZlcnQgZmlyc3QgdGV4dCBibG9jayBub2RlIHRvIGRlZmF1bHQgbm9kZVxuICAgICAgKCkgPT4gY29tbWFuZHMuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHRyXG4gICAgICAgIGNvbnN0IHsgZW1wdHksICRhbmNob3IgfSA9IHNlbGVjdGlvblxuICAgICAgICBjb25zdCB7IHBvcywgcGFyZW50IH0gPSAkYW5jaG9yXG4gICAgICAgIGNvbnN0ICRwYXJlbnRQb3MgPSAkYW5jaG9yLnBhcmVudC5pc1RleHRibG9jayA/IHRyLmRvYy5yZXNvbHZlKHBvcyAtIDEpIDogJGFuY2hvclxuICAgICAgICBjb25zdCBwYXJlbnRJc0lzb2xhdGluZyA9ICRwYXJlbnRQb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmdcblxuICAgICAgICBjb25zdCBwYXJlbnRQb3MgPSAkYW5jaG9yLnBvcyAtICRhbmNob3IucGFyZW50T2Zmc2V0XG5cbiAgICAgICAgY29uc3QgaXNBdFN0YXJ0ID0gKHBhcmVudElzSXNvbGF0aW5nICYmICRwYXJlbnRQb3MucGFyZW50LmNoaWxkQ291bnQgPT09IDEpXG4gICAgICAgICAgPyBwYXJlbnRQb3MgPT09ICRhbmNob3IucG9zXG4gICAgICAgICAgOiBTZWxlY3Rpb24uYXRTdGFydChkb2MpLmZyb20gPT09IHBvc1xuXG4gICAgICAgIGlmICghZW1wdHkgfHwgIWlzQXRTdGFydCB8fCAhcGFyZW50LnR5cGUuaXNUZXh0YmxvY2sgfHwgcGFyZW50LnRleHRDb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKVxuICAgICAgfSksXG5cbiAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuam9pbkJhY2t3YXJkKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5zZWxlY3ROb2RlQmFja3dhcmQoKSxcbiAgICBdKVxuXG4gICAgY29uc3QgaGFuZGxlRGVsZXRlID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZmlyc3QoKHsgY29tbWFuZHMgfSkgPT4gW1xuICAgICAgKCkgPT4gY29tbWFuZHMuZGVsZXRlU2VsZWN0aW9uKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5kZWxldGVDdXJyZW50Tm9kZSgpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuam9pbkZvcndhcmQoKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLnNlbGVjdE5vZGVGb3J3YXJkKCksXG4gICAgXSlcblxuICAgIGNvbnN0IGhhbmRsZUVudGVyID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZmlyc3QoKHsgY29tbWFuZHMgfSkgPT4gW1xuICAgICAgKCkgPT4gY29tbWFuZHMubmV3bGluZUluQ29kZSgpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuY3JlYXRlUGFyYWdyYXBoTmVhcigpLFxuICAgICAgKCkgPT4gY29tbWFuZHMubGlmdEVtcHR5QmxvY2soKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLnNwbGl0QmxvY2soKSxcbiAgICBdKVxuXG4gICAgY29uc3QgYmFzZUtleW1hcCA9IHtcbiAgICAgIEVudGVyOiBoYW5kbGVFbnRlcixcbiAgICAgICdNb2QtRW50ZXInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5leGl0Q29kZSgpLFxuICAgICAgQmFja3NwYWNlOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAnTW9kLUJhY2tzcGFjZSc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICdTaGlmdC1CYWNrc3BhY2UnOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICBEZWxldGU6IGhhbmRsZURlbGV0ZSxcbiAgICAgICdNb2QtRGVsZXRlJzogaGFuZGxlRGVsZXRlLFxuICAgICAgJ01vZC1hJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0QWxsKCksXG4gICAgfVxuXG4gICAgY29uc3QgcGNLZXltYXAgPSB7XG4gICAgICAuLi5iYXNlS2V5bWFwLFxuICAgIH1cblxuICAgIGNvbnN0IG1hY0tleW1hcCA9IHtcbiAgICAgIC4uLmJhc2VLZXltYXAsXG4gICAgICAnQ3RybC1oJzogaGFuZGxlQmFja3NwYWNlLFxuICAgICAgJ0FsdC1CYWNrc3BhY2UnOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAnQ3RybC1kJzogaGFuZGxlRGVsZXRlLFxuICAgICAgJ0N0cmwtQWx0LUJhY2tzcGFjZSc6IGhhbmRsZURlbGV0ZSxcbiAgICAgICdBbHQtRGVsZXRlJzogaGFuZGxlRGVsZXRlLFxuICAgICAgJ0FsdC1kJzogaGFuZGxlRGVsZXRlLFxuICAgICAgJ0N0cmwtYSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNlbGVjdFRleHRibG9ja1N0YXJ0KCksXG4gICAgICAnQ3RybC1lJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0VGV4dGJsb2NrRW5kKCksXG4gICAgfVxuXG4gICAgaWYgKGlzaU9TKCkgfHwgaXNNYWNPUygpKSB7XG4gICAgICByZXR1cm4gbWFjS2V5bWFwXG4gICAgfVxuXG4gICAgcmV0dXJuIHBjS2V5bWFwXG4gIH0sXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICAvLyBXaXRoIHRoaXMgcGx1Z2luIHdlIGNoZWNrIGlmIHRoZSB3aG9sZSBkb2N1bWVudCB3YXMgc2VsZWN0ZWQgYW5kIGRlbGV0ZWQuXG4gICAgICAvLyBJbiB0aGlzIGNhc2Ugd2Ugd2lsbCBhZGRpdGlvbmFsbHkgY2FsbCBgY2xlYXJOb2RlcygpYCB0byBjb252ZXJ0IGUuZy4gYSBoZWFkaW5nXG4gICAgICAvLyB0byBhIHBhcmFncmFwaCBpZiBuZWNlc3NhcnkuXG4gICAgICAvLyBUaGlzIGlzIGFuIGFsdGVybmF0aXZlIHRvIFByb3NlTWlycm9yJ3MgYEFsbFNlbGVjdGlvbmAsIHdoaWNoIGRvZXNu4oCZdCB3b3JrIHdlbGxcbiAgICAgIC8vIHdpdGggbWFueSBvdGhlciBjb21tYW5kcy5cbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2NsZWFyRG9jdW1lbnQnKSxcbiAgICAgICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbnMsIG9sZFN0YXRlLCBuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRvY0NoYW5nZXMgPSB0cmFuc2FjdGlvbnMuc29tZSh0cmFuc2FjdGlvbiA9PiB0cmFuc2FjdGlvbi5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgJiYgIW9sZFN0YXRlLmRvYy5lcShuZXdTdGF0ZS5kb2MpXG5cbiAgICAgICAgICBpZiAoIWRvY0NoYW5nZXMpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHsgZW1wdHksIGZyb20sIHRvIH0gPSBvbGRTdGF0ZS5zZWxlY3Rpb25cbiAgICAgICAgICBjb25zdCBhbGxGcm9tID0gU2VsZWN0aW9uLmF0U3RhcnQob2xkU3RhdGUuZG9jKS5mcm9tXG4gICAgICAgICAgY29uc3QgYWxsRW5kID0gU2VsZWN0aW9uLmF0RW5kKG9sZFN0YXRlLmRvYykudG9cbiAgICAgICAgICBjb25zdCBhbGxXYXNTZWxlY3RlZCA9IGZyb20gPT09IGFsbEZyb20gJiYgdG8gPT09IGFsbEVuZFxuXG4gICAgICAgICAgaWYgKGVtcHR5IHx8ICFhbGxXYXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaXNFbXB0eSA9IG5ld1N0YXRlLmRvYy50ZXh0QmV0d2VlbigwLCBuZXdTdGF0ZS5kb2MuY29udGVudC5zaXplLCAnICcsICcgJykubGVuZ3RoID09PSAwXG5cbiAgICAgICAgICBpZiAoIWlzRW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHRyID0gbmV3U3RhdGUudHJcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IGNyZWF0ZUNoYWluYWJsZVN0YXRlKHtcbiAgICAgICAgICAgIHN0YXRlOiBuZXdTdGF0ZSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cixcbiAgICAgICAgICB9KVxuICAgICAgICAgIGNvbnN0IHsgY29tbWFuZHMgfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGNvbW1hbmRzLmNsZWFyTm9kZXMoKVxuXG4gICAgICAgICAgaWYgKCF0ci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0clxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcblxuZXhwb3J0IGNvbnN0IFRhYmluZGV4ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICd0YWJpbmRleCcsXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCd0YWJpbmRleCcpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuZWRpdG9yLmlzRWRpdGFibGUgPyB7IHRhYmluZGV4OiAnMCcgfSA6IHt9LFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJleHBvcnQgY29uc3Qgc3R5bGUgPSBgLlByb3NlTWlycm9yIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuXG4uUHJvc2VNaXJyb3Ige1xuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgd2hpdGUtc3BhY2U6IGJyZWFrLXNwYWNlcztcbiAgLXdlYmtpdC1mb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IFwibGlnYVwiIDA7IC8qIHRoZSBhYm92ZSBkb2Vzbid0IHNlZW0gdG8gd29yayBpbiBFZGdlICovXG59XG5cbi5Qcm9zZU1pcnJvciBbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0ge1xuICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xufVxuXG4uUHJvc2VNaXJyb3IgW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdIFtjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG4uUHJvc2VNaXJyb3IgcHJlIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG5pbWcuUHJvc2VNaXJyb3Itc2VwYXJhdG9yIHtcbiAgZGlzcGxheTogaW5saW5lICFpbXBvcnRhbnQ7XG4gIGJvcmRlcjogbm9uZSAhaW1wb3J0YW50O1xuICBtYXJnaW46IDAgIWltcG9ydGFudDtcbiAgd2lkdGg6IDFweCAhaW1wb3J0YW50O1xuICBoZWlnaHQ6IDFweCAhaW1wb3J0YW50O1xufVxuXG4uUHJvc2VNaXJyb3ItZ2FwY3Vyc29yIHtcbiAgZGlzcGxheTogbm9uZTtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgbWFyZ2luOiAwO1xufVxuXG4uUHJvc2VNaXJyb3ItZ2FwY3Vyc29yOmFmdGVyIHtcbiAgY29udGVudDogXCJcIjtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAtMnB4O1xuICB3aWR0aDogMjBweDtcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIGJsYWNrO1xuICBhbmltYXRpb246IFByb3NlTWlycm9yLWN1cnNvci1ibGluayAxLjFzIHN0ZXBzKDIsIHN0YXJ0KSBpbmZpbml0ZTtcbn1cblxuQGtleWZyYW1lcyBQcm9zZU1pcnJvci1jdXJzb3ItYmxpbmsge1xuICB0byB7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICB9XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICo6OnNlbGVjdGlvbiB7XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xufVxuXG4uUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvbiAqOjotbW96LXNlbGVjdGlvbiB7XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xufVxuXG4uUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvbiAqIHtcbiAgY2FyZXQtY29sb3I6IHRyYW5zcGFyZW50O1xufVxuXG4uUHJvc2VNaXJyb3ItZm9jdXNlZCAuUHJvc2VNaXJyb3ItZ2FwY3Vyc29yIHtcbiAgZGlzcGxheTogYmxvY2s7XG59XG5cbi50aXBweS1ib3hbZGF0YS1hbmltYXRpb249ZmFkZV1bZGF0YS1zdGF0ZT1oaWRkZW5dIHtcbiAgb3BhY2l0eTogMFxufWBcbiIsICJleHBvcnQgZnVuY3Rpb24gY3JlYXRlU3R5bGVUYWcoc3R5bGU6IHN0cmluZywgbm9uY2U/OiBzdHJpbmcsIHN1ZmZpeD86IHN0cmluZyk6IEhUTUxTdHlsZUVsZW1lbnQge1xuICBjb25zdCB0aXB0YXBTdHlsZVRhZyA9ICg8SFRNTFN0eWxlRWxlbWVudD5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzdHlsZVtkYXRhLXRpcHRhcC1zdHlsZSR7c3VmZml4ID8gYC0ke3N1ZmZpeH1gIDogJyd9XWApKVxuXG4gIGlmICh0aXB0YXBTdHlsZVRhZyAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0aXB0YXBTdHlsZVRhZ1xuICB9XG5cbiAgY29uc3Qgc3R5bGVOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuXG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlTm9kZS5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpXG4gIH1cblxuICBzdHlsZU5vZGUuc2V0QXR0cmlidXRlKGBkYXRhLXRpcHRhcC1zdHlsZSR7c3VmZml4ID8gYC0ke3N1ZmZpeH1gIDogJyd9YCwgJycpXG4gIHN0eWxlTm9kZS5pbm5lckhUTUwgPSBzdHlsZVxuICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHN0eWxlTm9kZSlcblxuICByZXR1cm4gc3R5bGVOb2RlXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUsIE5vZGVUeXBlLCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHtcbiAgRWRpdG9yU3RhdGUsIFBsdWdpbiwgUGx1Z2luS2V5LCBUcmFuc2FjdGlvbixcbn0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnXG5cbmltcG9ydCB7IENvbW1hbmRNYW5hZ2VyIH0gZnJvbSAnLi9Db21tYW5kTWFuYWdlci5qcydcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4vRXZlbnRFbWl0dGVyLmpzJ1xuaW1wb3J0IHsgRXh0ZW5zaW9uTWFuYWdlciB9IGZyb20gJy4vRXh0ZW5zaW9uTWFuYWdlci5qcydcbmltcG9ydCAqIGFzIGV4dGVuc2lvbnMgZnJvbSAnLi9leHRlbnNpb25zL2luZGV4LmpzJ1xuaW1wb3J0IHsgY3JlYXRlRG9jdW1lbnQgfSBmcm9tICcuL2hlbHBlcnMvY3JlYXRlRG9jdW1lbnQuanMnXG5pbXBvcnQgeyBnZXRBdHRyaWJ1dGVzIH0gZnJvbSAnLi9oZWxwZXJzL2dldEF0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXRIVE1MRnJvbUZyYWdtZW50IH0gZnJvbSAnLi9oZWxwZXJzL2dldEhUTUxGcm9tRnJhZ21lbnQuanMnXG5pbXBvcnQgeyBnZXRUZXh0IH0gZnJvbSAnLi9oZWxwZXJzL2dldFRleHQuanMnXG5pbXBvcnQgeyBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hIH0gZnJvbSAnLi9oZWxwZXJzL2dldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEuanMnXG5pbXBvcnQgeyBpc0FjdGl2ZSB9IGZyb20gJy4vaGVscGVycy9pc0FjdGl2ZS5qcydcbmltcG9ydCB7IGlzTm9kZUVtcHR5IH0gZnJvbSAnLi9oZWxwZXJzL2lzTm9kZUVtcHR5LmpzJ1xuaW1wb3J0IHsgcmVzb2x2ZUZvY3VzUG9zaXRpb24gfSBmcm9tICcuL2hlbHBlcnMvcmVzb2x2ZUZvY3VzUG9zaXRpb24uanMnXG5pbXBvcnQgeyBzdHlsZSB9IGZyb20gJy4vc3R5bGUuanMnXG5pbXBvcnQge1xuICBDYW5Db21tYW5kcyxcbiAgQ2hhaW5lZENvbW1hbmRzLFxuICBFZGl0b3JFdmVudHMsXG4gIEVkaXRvck9wdGlvbnMsXG4gIEpTT05Db250ZW50LFxuICBTaW5nbGVDb21tYW5kcyxcbiAgVGV4dFNlcmlhbGl6ZXIsXG59IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBjcmVhdGVTdHlsZVRhZyB9IGZyb20gJy4vdXRpbGl0aWVzL2NyZWF0ZVN0eWxlVGFnLmpzJ1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4vdXRpbGl0aWVzL2lzRnVuY3Rpb24uanMnXG5cbmV4cG9ydCB7IGV4dGVuc2lvbnMgfVxuXG5leHBvcnQgaW50ZXJmYWNlIEhUTUxFbGVtZW50IHtcbiAgZWRpdG9yPzogRWRpdG9yXG59XG5cbmV4cG9ydCBjbGFzcyBFZGl0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXI8RWRpdG9yRXZlbnRzPiB7XG4gIHByaXZhdGUgY29tbWFuZE1hbmFnZXIhOiBDb21tYW5kTWFuYWdlclxuXG4gIHB1YmxpYyBleHRlbnNpb25NYW5hZ2VyITogRXh0ZW5zaW9uTWFuYWdlclxuXG4gIHByaXZhdGUgY3NzITogSFRNTFN0eWxlRWxlbWVudFxuXG4gIHB1YmxpYyBzY2hlbWEhOiBTY2hlbWFcblxuICBwdWJsaWMgdmlldyE6IEVkaXRvclZpZXdcblxuICBwdWJsaWMgaXNGb2N1c2VkID0gZmFsc2VcblxuICBwdWJsaWMgZXh0ZW5zaW9uU3RvcmFnZTogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9XG5cbiAgcHVibGljIG9wdGlvbnM6IEVkaXRvck9wdGlvbnMgPSB7XG4gICAgZWxlbWVudDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgY29udGVudDogJycsXG4gICAgaW5qZWN0Q1NTOiB0cnVlLFxuICAgIGluamVjdE5vbmNlOiB1bmRlZmluZWQsXG4gICAgZXh0ZW5zaW9uczogW10sXG4gICAgYXV0b2ZvY3VzOiBmYWxzZSxcbiAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICBlZGl0b3JQcm9wczoge30sXG4gICAgcGFyc2VPcHRpb25zOiB7fSxcbiAgICBlbmFibGVJbnB1dFJ1bGVzOiB0cnVlLFxuICAgIGVuYWJsZVBhc3RlUnVsZXM6IHRydWUsXG4gICAgZW5hYmxlQ29yZUV4dGVuc2lvbnM6IHRydWUsXG4gICAgb25CZWZvcmVDcmVhdGU6ICgpID0+IG51bGwsXG4gICAgb25DcmVhdGU6ICgpID0+IG51bGwsXG4gICAgb25VcGRhdGU6ICgpID0+IG51bGwsXG4gICAgb25TZWxlY3Rpb25VcGRhdGU6ICgpID0+IG51bGwsXG4gICAgb25UcmFuc2FjdGlvbjogKCkgPT4gbnVsbCxcbiAgICBvbkZvY3VzOiAoKSA9PiBudWxsLFxuICAgIG9uQmx1cjogKCkgPT4gbnVsbCxcbiAgICBvbkRlc3Ryb3k6ICgpID0+IG51bGwsXG4gIH1cblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBQYXJ0aWFsPEVkaXRvck9wdGlvbnM+ID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpXG4gICAgdGhpcy5jcmVhdGVFeHRlbnNpb25NYW5hZ2VyKClcbiAgICB0aGlzLmNyZWF0ZUNvbW1hbmRNYW5hZ2VyKClcbiAgICB0aGlzLmNyZWF0ZVNjaGVtYSgpXG4gICAgdGhpcy5vbignYmVmb3JlQ3JlYXRlJywgdGhpcy5vcHRpb25zLm9uQmVmb3JlQ3JlYXRlKVxuICAgIHRoaXMuZW1pdCgnYmVmb3JlQ3JlYXRlJywgeyBlZGl0b3I6IHRoaXMgfSlcbiAgICB0aGlzLmNyZWF0ZVZpZXcoKVxuICAgIHRoaXMuaW5qZWN0Q1NTKClcbiAgICB0aGlzLm9uKCdjcmVhdGUnLCB0aGlzLm9wdGlvbnMub25DcmVhdGUpXG4gICAgdGhpcy5vbigndXBkYXRlJywgdGhpcy5vcHRpb25zLm9uVXBkYXRlKVxuICAgIHRoaXMub24oJ3NlbGVjdGlvblVwZGF0ZScsIHRoaXMub3B0aW9ucy5vblNlbGVjdGlvblVwZGF0ZSlcbiAgICB0aGlzLm9uKCd0cmFuc2FjdGlvbicsIHRoaXMub3B0aW9ucy5vblRyYW5zYWN0aW9uKVxuICAgIHRoaXMub24oJ2ZvY3VzJywgdGhpcy5vcHRpb25zLm9uRm9jdXMpXG4gICAgdGhpcy5vbignYmx1cicsIHRoaXMub3B0aW9ucy5vbkJsdXIpXG4gICAgdGhpcy5vbignZGVzdHJveScsIHRoaXMub3B0aW9ucy5vbkRlc3Ryb3kpXG5cbiAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcy5jb21tYW5kcy5mb2N1cyh0aGlzLm9wdGlvbnMuYXV0b2ZvY3VzKVxuICAgICAgdGhpcy5lbWl0KCdjcmVhdGUnLCB7IGVkaXRvcjogdGhpcyB9KVxuICAgIH0sIDApXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWRpdG9yIHN0b3JhZ2UuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0b3JhZ2UoKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uU3RvcmFnZVxuICB9XG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBvZiBhbGwgcmVnaXN0ZXJlZCBjb21tYW5kcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgY29tbWFuZHMoKTogU2luZ2xlQ29tbWFuZHMge1xuICAgIHJldHVybiB0aGlzLmNvbW1hbmRNYW5hZ2VyLmNvbW1hbmRzXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgY29tbWFuZCBjaGFpbiB0byBjYWxsIG11bHRpcGxlIGNvbW1hbmRzIGF0IG9uY2UuXG4gICAqL1xuICBwdWJsaWMgY2hhaW4oKTogQ2hhaW5lZENvbW1hbmRzIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jaGFpbigpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBjb21tYW5kIG9yIGEgY29tbWFuZCBjaGFpbiBjYW4gYmUgZXhlY3V0ZWQuIFdpdGhvdXQgZXhlY3V0aW5nIGl0LlxuICAgKi9cbiAgcHVibGljIGNhbigpOiBDYW5Db21tYW5kcyB7XG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZE1hbmFnZXIuY2FuKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmplY3QgQ1NTIHN0eWxlcy5cbiAgICovXG4gIHByaXZhdGUgaW5qZWN0Q1NTKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuaW5qZWN0Q1NTICYmIGRvY3VtZW50KSB7XG4gICAgICB0aGlzLmNzcyA9IGNyZWF0ZVN0eWxlVGFnKHN0eWxlLCB0aGlzLm9wdGlvbnMuaW5qZWN0Tm9uY2UpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBlZGl0b3Igb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgQSBsaXN0IG9mIG9wdGlvbnNcbiAgICovXG4gIHB1YmxpYyBzZXRPcHRpb25zKG9wdGlvbnM6IFBhcnRpYWw8RWRpdG9yT3B0aW9ucz4gPSB7fSk6IHZvaWQge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnZpZXcgfHwgIXRoaXMuc3RhdGUgfHwgdGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lZGl0b3JQcm9wcykge1xuICAgICAgdGhpcy52aWV3LnNldFByb3BzKHRoaXMub3B0aW9ucy5lZGl0b3JQcm9wcylcbiAgICB9XG5cbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUodGhpcy5zdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZWRpdGFibGUgc3RhdGUgb2YgdGhlIGVkaXRvci5cbiAgICovXG4gIHB1YmxpYyBzZXRFZGl0YWJsZShlZGl0YWJsZTogYm9vbGVhbiwgZW1pdFVwZGF0ZSA9IHRydWUpOiB2b2lkIHtcbiAgICB0aGlzLnNldE9wdGlvbnMoeyBlZGl0YWJsZSB9KVxuXG4gICAgaWYgKGVtaXRVcGRhdGUpIHtcbiAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgeyBlZGl0b3I6IHRoaXMsIHRyYW5zYWN0aW9uOiB0aGlzLnN0YXRlLnRyIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgZWRpdG9yIGlzIGVkaXRhYmxlLlxuICAgKi9cbiAgcHVibGljIGdldCBpc0VkaXRhYmxlKCk6IGJvb2xlYW4ge1xuICAgIC8vIHNpbmNlIHBsdWdpbnMgYXJlIGFwcGxpZWQgYWZ0ZXIgY3JlYXRpbmcgdGhlIHZpZXdcbiAgICAvLyBgZWRpdGFibGVgIGlzIGFsd2F5cyBgdHJ1ZWAgZm9yIG9uZSB0aWNrLlxuICAgIC8vIHRoYXTigJlzIHdoeSB3ZSBhbHNvIGhhdmUgdG8gY2hlY2sgZm9yIGBvcHRpb25zLmVkaXRhYmxlYFxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZWRpdGFibGUgJiYgdGhpcy52aWV3ICYmIHRoaXMudmlldy5lZGl0YWJsZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVkaXRvciBzdGF0ZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RhdGUoKTogRWRpdG9yU3RhdGUge1xuICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIFByb3NlTWlycm9yIHBsdWdpbi5cbiAgICpcbiAgICogQHBhcmFtIHBsdWdpbiBBIFByb3NlTWlycm9yIHBsdWdpblxuICAgKiBAcGFyYW0gaGFuZGxlUGx1Z2lucyBDb250cm9sIGhvdyB0byBtZXJnZSB0aGUgcGx1Z2luIGludG8gdGhlIGV4aXN0aW5nIHBsdWdpbnMuXG4gICAqL1xuICBwdWJsaWMgcmVnaXN0ZXJQbHVnaW4oXG4gICAgcGx1Z2luOiBQbHVnaW4sXG4gICAgaGFuZGxlUGx1Z2lucz86IChuZXdQbHVnaW46IFBsdWdpbiwgcGx1Z2luczogUGx1Z2luW10pID0+IFBsdWdpbltdLFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBwbHVnaW5zID0gaXNGdW5jdGlvbihoYW5kbGVQbHVnaW5zKVxuICAgICAgPyBoYW5kbGVQbHVnaW5zKHBsdWdpbiwgWy4uLnRoaXMuc3RhdGUucGx1Z2luc10pXG4gICAgICA6IFsuLi50aGlzLnN0YXRlLnBsdWdpbnMsIHBsdWdpbl1cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5yZWNvbmZpZ3VyZSh7IHBsdWdpbnMgfSlcblxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGEgUHJvc2VNaXJyb3IgcGx1Z2luLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZU9yUGx1Z2luS2V5IFRoZSBwbHVnaW5zIG5hbWVcbiAgICovXG4gIHB1YmxpYyB1bnJlZ2lzdGVyUGx1Z2luKG5hbWVPclBsdWdpbktleTogc3RyaW5nIHwgUGx1Z2luS2V5KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBuYW1lID0gdHlwZW9mIG5hbWVPclBsdWdpbktleSA9PT0gJ3N0cmluZycgPyBgJHtuYW1lT3JQbHVnaW5LZXl9JGAgOiBuYW1lT3JQbHVnaW5LZXkua2V5XG5cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUucmVjb25maWd1cmUoe1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcGx1Z2luczogdGhpcy5zdGF0ZS5wbHVnaW5zLmZpbHRlcihwbHVnaW4gPT4gIXBsdWdpbi5rZXkuc3RhcnRzV2l0aChuYW1lKSksXG4gICAgfSlcblxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGV4dGVuc2lvbiBtYW5hZ2VyLlxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVFeHRlbnNpb25NYW5hZ2VyKCk6IHZvaWQge1xuICAgIGNvbnN0IGNvcmVFeHRlbnNpb25zID0gdGhpcy5vcHRpb25zLmVuYWJsZUNvcmVFeHRlbnNpb25zID8gT2JqZWN0LnZhbHVlcyhleHRlbnNpb25zKSA6IFtdXG4gICAgY29uc3QgYWxsRXh0ZW5zaW9ucyA9IFsuLi5jb3JlRXh0ZW5zaW9ucywgLi4udGhpcy5vcHRpb25zLmV4dGVuc2lvbnNdLmZpbHRlcihleHRlbnNpb24gPT4ge1xuICAgICAgcmV0dXJuIFsnZXh0ZW5zaW9uJywgJ25vZGUnLCAnbWFyayddLmluY2x1ZGVzKGV4dGVuc2lvbj8udHlwZSlcbiAgICB9KVxuXG4gICAgdGhpcy5leHRlbnNpb25NYW5hZ2VyID0gbmV3IEV4dGVuc2lvbk1hbmFnZXIoYWxsRXh0ZW5zaW9ucywgdGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGNvbW1hbmQgbWFuYWdlci5cbiAgICovXG4gIHByaXZhdGUgY3JlYXRlQ29tbWFuZE1hbmFnZXIoKTogdm9pZCB7XG4gICAgdGhpcy5jb21tYW5kTWFuYWdlciA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgICBlZGl0b3I6IHRoaXMsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUHJvc2VNaXJyb3Igc2NoZW1hLlxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVTY2hlbWEoKTogdm9pZCB7XG4gICAgdGhpcy5zY2hlbWEgPSB0aGlzLmV4dGVuc2lvbk1hbmFnZXIuc2NoZW1hXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFByb3NlTWlycm9yIHZpZXcuXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZVZpZXcoKTogdm9pZCB7XG4gICAgY29uc3QgZG9jID0gY3JlYXRlRG9jdW1lbnQodGhpcy5vcHRpb25zLmNvbnRlbnQsIHRoaXMuc2NoZW1hLCB0aGlzLm9wdGlvbnMucGFyc2VPcHRpb25zKVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHJlc29sdmVGb2N1c1Bvc2l0aW9uKGRvYywgdGhpcy5vcHRpb25zLmF1dG9mb2N1cylcblxuICAgIHRoaXMudmlldyA9IG5ldyBFZGl0b3JWaWV3KHRoaXMub3B0aW9ucy5lbGVtZW50LCB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMsXG4gICAgICBkaXNwYXRjaFRyYW5zYWN0aW9uOiB0aGlzLmRpc3BhdGNoVHJhbnNhY3Rpb24uYmluZCh0aGlzKSxcbiAgICAgIHN0YXRlOiBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xuICAgICAgICBkb2MsXG4gICAgICAgIHNlbGVjdGlvbjogc2VsZWN0aW9uIHx8IHVuZGVmaW5lZCxcbiAgICAgIH0pLFxuICAgIH0pXG5cbiAgICAvLyBgZWRpdG9yLnZpZXdgIGlzIG5vdCB5ZXQgYXZhaWxhYmxlIGF0IHRoaXMgdGltZS5cbiAgICAvLyBUaGVyZWZvcmUgd2Ugd2lsbCBhZGQgYWxsIHBsdWdpbnMgYW5kIG5vZGUgdmlld3MgZGlyZWN0bHkgYWZ0ZXJ3YXJkcy5cbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuc3RhdGUucmVjb25maWd1cmUoe1xuICAgICAgcGx1Z2luczogdGhpcy5leHRlbnNpb25NYW5hZ2VyLnBsdWdpbnMsXG4gICAgfSlcblxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShuZXdTdGF0ZSlcblxuICAgIHRoaXMuY3JlYXRlTm9kZVZpZXdzKClcbiAgICB0aGlzLnByZXBlbmRDbGFzcygpXG5cbiAgICAvLyBMZXTigJlzIHN0b3JlIHRoZSBlZGl0b3IgaW5zdGFuY2UgaW4gdGhlIERPTSBlbGVtZW50LlxuICAgIC8vIFNvIHdl4oCZbGwgaGF2ZSBhY2Nlc3MgdG8gaXQgZm9yIHRlc3RzLlxuICAgIGNvbnN0IGRvbSA9IHRoaXMudmlldy5kb20gYXMgSFRNTEVsZW1lbnRcblxuICAgIGRvbS5lZGl0b3IgPSB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbGwgbm9kZSB2aWV3cy5cbiAgICovXG4gIHB1YmxpYyBjcmVhdGVOb2RlVmlld3MoKTogdm9pZCB7XG4gICAgdGhpcy52aWV3LnNldFByb3BzKHtcbiAgICAgIG5vZGVWaWV3czogdGhpcy5leHRlbnNpb25NYW5hZ2VyLm5vZGVWaWV3cyxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFByZXBlbmQgY2xhc3MgbmFtZSB0byBlbGVtZW50LlxuICAgKi9cbiAgcHVibGljIHByZXBlbmRDbGFzcygpOiB2b2lkIHtcbiAgICB0aGlzLnZpZXcuZG9tLmNsYXNzTmFtZSA9IGB0aXB0YXAgJHt0aGlzLnZpZXcuZG9tLmNsYXNzTmFtZX1gXG4gIH1cblxuICBwdWJsaWMgaXNDYXB0dXJpbmdUcmFuc2FjdGlvbiA9IGZhbHNlXG5cbiAgcHJpdmF0ZSBjYXB0dXJlZFRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbiB8IG51bGwgPSBudWxsXG5cbiAgcHVibGljIGNhcHR1cmVUcmFuc2FjdGlvbihmbjogRnVuY3Rpb24pIHtcbiAgICB0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSB0cnVlXG4gICAgZm4oKVxuICAgIHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbiA9IGZhbHNlXG5cbiAgICBjb25zdCB0ciA9IHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvblxuXG4gICAgdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uID0gbnVsbFxuXG4gICAgcmV0dXJuIHRyXG4gIH1cblxuICAvKipcbiAgICogVGhlIGNhbGxiYWNrIG92ZXIgd2hpY2ggdG8gc2VuZCB0cmFuc2FjdGlvbnMgKHN0YXRlIHVwZGF0ZXMpIHByb2R1Y2VkIGJ5IHRoZSB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gQW4gZWRpdG9yIHN0YXRlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBwcml2YXRlIGRpc3BhdGNoVHJhbnNhY3Rpb24odHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uKTogdm9pZCB7XG4gICAgLy8gaWYgdGhlIGVkaXRvciAvIHRoZSB2aWV3IG9mIHRoZSBlZGl0b3Igd2FzIGRlc3Ryb3llZFxuICAgIC8vIHRoZSB0cmFuc2FjdGlvbiBzaG91bGQgbm90IGJlIGRpc3BhdGNoZWQgYXMgdGhlcmUgaXMgbm8gdmlldyBhbnltb3JlLlxuICAgIGlmICh0aGlzLnZpZXcuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24pIHtcbiAgICAgIGlmICghdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uXG5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRyYW5zYWN0aW9uLnN0ZXBzLmZvckVhY2goc3RlcCA9PiB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24/LnN0ZXAoc3RlcCkpXG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5hcHBseSh0cmFuc2FjdGlvbilcbiAgICBjb25zdCBzZWxlY3Rpb25IYXNDaGFuZ2VkID0gIXRoaXMuc3RhdGUuc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbilcblxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSlcbiAgICB0aGlzLmVtaXQoJ3RyYW5zYWN0aW9uJywge1xuICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgfSlcblxuICAgIGlmIChzZWxlY3Rpb25IYXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLmVtaXQoJ3NlbGVjdGlvblVwZGF0ZScsIHtcbiAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3QgZm9jdXMgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCdmb2N1cycpXG4gICAgY29uc3QgYmx1ciA9IHRyYW5zYWN0aW9uLmdldE1ldGEoJ2JsdXInKVxuXG4gICAgaWYgKGZvY3VzKSB7XG4gICAgICB0aGlzLmVtaXQoJ2ZvY3VzJywge1xuICAgICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICAgIGV2ZW50OiBmb2N1cy5ldmVudCxcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChibHVyKSB7XG4gICAgICB0aGlzLmVtaXQoJ2JsdXInLCB7XG4gICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgZXZlbnQ6IGJsdXIuZXZlbnQsXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoIXRyYW5zYWN0aW9uLmRvY0NoYW5nZWQgfHwgdHJhbnNhY3Rpb24uZ2V0TWV0YSgncHJldmVudFVwZGF0ZScpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHtcbiAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0IGF0dHJpYnV0ZXMgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBub2RlIG9yIG1hcmsuXG4gICAqL1xuICBwdWJsaWMgZ2V0QXR0cmlidXRlcyhuYW1lT3JUeXBlOiBzdHJpbmcgfCBOb2RlVHlwZSB8IE1hcmtUeXBlKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgcmV0dXJuIGdldEF0dHJpYnV0ZXModGhpcy5zdGF0ZSwgbmFtZU9yVHlwZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZSBvciBtYXJrIGlzIGFjdGl2ZS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgbm9kZSBvciBtYXJrXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVzIEF0dHJpYnV0ZXMgb2YgdGhlIG5vZGUgb3IgbWFya1xuICAgKi9cbiAgcHVibGljIGlzQWN0aXZlKG5hbWU6IHN0cmluZywgYXR0cmlidXRlcz86IHt9KTogYm9vbGVhblxuICBwdWJsaWMgaXNBY3RpdmUoYXR0cmlidXRlczoge30pOiBib29sZWFuXG4gIHB1YmxpYyBpc0FjdGl2ZShuYW1lT3JBdHRyaWJ1dGVzOiBzdHJpbmcsIGF0dHJpYnV0ZXNPclVuZGVmaW5lZD86IHt9KTogYm9vbGVhbiB7XG4gICAgY29uc3QgbmFtZSA9IHR5cGVvZiBuYW1lT3JBdHRyaWJ1dGVzID09PSAnc3RyaW5nJyA/IG5hbWVPckF0dHJpYnV0ZXMgOiBudWxsXG5cbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gdHlwZW9mIG5hbWVPckF0dHJpYnV0ZXMgPT09ICdzdHJpbmcnID8gYXR0cmlidXRlc09yVW5kZWZpbmVkIDogbmFtZU9yQXR0cmlidXRlc1xuXG4gICAgcmV0dXJuIGlzQWN0aXZlKHRoaXMuc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkb2N1bWVudCBhcyBKU09OLlxuICAgKi9cbiAgcHVibGljIGdldEpTT04oKTogSlNPTkNvbnRlbnQge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmRvYy50b0pTT04oKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgSFRNTC5cbiAgICovXG4gIHB1YmxpYyBnZXRIVE1MKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGdldEhUTUxGcm9tRnJhZ21lbnQodGhpcy5zdGF0ZS5kb2MuY29udGVudCwgdGhpcy5zY2hlbWEpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkb2N1bWVudCBhcyB0ZXh0LlxuICAgKi9cbiAgcHVibGljIGdldFRleHQob3B0aW9ucz86IHtcbiAgICBibG9ja1NlcGFyYXRvcj86IHN0cmluZ1xuICAgIHRleHRTZXJpYWxpemVycz86IFJlY29yZDxzdHJpbmcsIFRleHRTZXJpYWxpemVyPlxuICB9KTogc3RyaW5nIHtcbiAgICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gJ1xcblxcbicsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9XG5cbiAgICByZXR1cm4gZ2V0VGV4dCh0aGlzLnN0YXRlLmRvYywge1xuICAgICAgYmxvY2tTZXBhcmF0b3IsXG4gICAgICB0ZXh0U2VyaWFsaXplcnM6IHtcbiAgICAgICAgLi4uZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSh0aGlzLnNjaGVtYSksXG4gICAgICAgIC4uLnRleHRTZXJpYWxpemVycyxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGVyZSBpcyBubyBjb250ZW50LlxuICAgKi9cbiAgcHVibGljIGdldCBpc0VtcHR5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc05vZGVFbXB0eSh0aGlzLnN0YXRlLmRvYylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGZvciB0aGUgY3VycmVudCBkb2N1bWVudC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHB1YmxpYyBnZXRDaGFyYWN0ZXJDb3VudCgpOiBudW1iZXIge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdbdGlwdGFwIHdhcm5dOiBcImVkaXRvci5nZXRDaGFyYWN0ZXJDb3VudCgpXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImVkaXRvci5zdG9yYWdlLmNoYXJhY3RlckNvdW50LmNoYXJhY3RlcnMoKVwiIGluc3RlYWQuJyxcbiAgICApXG5cbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5kb2MuY29udGVudC5zaXplIC0gMlxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIGVkaXRvci5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuZW1pdCgnZGVzdHJveScpXG5cbiAgICBpZiAodGhpcy52aWV3KSB7XG4gICAgICB0aGlzLnZpZXcuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBlZGl0b3IgaXMgYWxyZWFkeSBkZXN0cm95ZWQuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGlzRGVzdHJveWVkKCk6IGJvb2xlYW4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gIXRoaXMudmlldz8uZG9jVmlld1xuICB9XG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXRNYXJrc0JldHdlZW4gfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtzQmV0d2Vlbi5qcydcbmltcG9ydCB7IElucHV0UnVsZSwgSW5wdXRSdWxlRmluZGVyIH0gZnJvbSAnLi4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBhZGRzIGEgbWFyayB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXJrSW5wdXRSdWxlKGNvbmZpZzoge1xuICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXJcbiAgdHlwZTogTWFya1R5cGVcbiAgZ2V0QXR0cmlidXRlcz86XG4gICAgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICAgfCAoKG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkpID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgfCBmYWxzZVxuICAgIHwgbnVsbFxufSkge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKVxuXG4gICAgICBpZiAoYXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgYXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZVxuICAgICAgY29uc3QgY2FwdHVyZUdyb3VwID0gbWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV1cbiAgICAgIGNvbnN0IGZ1bGxNYXRjaCA9IG1hdGNoWzBdXG5cbiAgICAgIGlmIChjYXB0dXJlR3JvdXApIHtcbiAgICAgICAgY29uc3Qgc3RhcnRTcGFjZXMgPSBmdWxsTWF0Y2guc2VhcmNoKC9cXFMvKVxuICAgICAgICBjb25zdCB0ZXh0U3RhcnQgPSByYW5nZS5mcm9tICsgZnVsbE1hdGNoLmluZGV4T2YoY2FwdHVyZUdyb3VwKVxuICAgICAgICBjb25zdCB0ZXh0RW5kID0gdGV4dFN0YXJ0ICsgY2FwdHVyZUdyb3VwLmxlbmd0aFxuXG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVkTWFya3MgPSBnZXRNYXJrc0JldHdlZW4ocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHN0YXRlLmRvYylcbiAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgZXhjbHVkZWQgPSBpdGVtLm1hcmsudHlwZS5leGNsdWRlZCBhcyBNYXJrVHlwZVtdXG5cbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlZC5maW5kKHR5cGUgPT4gdHlwZSA9PT0gY29uZmlnLnR5cGUgJiYgdHlwZSAhPT0gaXRlbS5tYXJrLnR5cGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS50byA+IHRleHRTdGFydClcblxuICAgICAgICBpZiAoZXhjbHVkZWRNYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRFbmQgPCByYW5nZS50bykge1xuICAgICAgICAgIHRyLmRlbGV0ZSh0ZXh0RW5kLCByYW5nZS50bylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0U3RhcnQgPiByYW5nZS5mcm9tKSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgdGV4dFN0YXJ0KVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWFya0VuZCA9IHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcyArIGNhcHR1cmVHcm91cC5sZW5ndGhcblxuICAgICAgICB0ci5hZGRNYXJrKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgbWFya0VuZCwgY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMgfHwge30pKVxuXG4gICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsoY29uZmlnLnR5cGUpXG4gICAgICB9XG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IElucHV0UnVsZSwgSW5wdXRSdWxlRmluZGVyIH0gZnJvbSAnLi4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBhZGRzIGEgbm9kZSB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub2RlSW5wdXRSdWxlKGNvbmZpZzoge1xuICAvKipcbiAgICogVGhlIHJlZ2V4IHRvIG1hdGNoLlxuICAgKi9cbiAgZmluZDogSW5wdXRSdWxlRmluZGVyXG5cbiAgLyoqXG4gICAqIFRoZSBub2RlIHR5cGUgdG8gYWRkLlxuICAgKi9cbiAgdHlwZTogTm9kZVR5cGVcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGF0dHJpYnV0ZXMgZm9yIHRoZSBub2RlXG4gICAqIGNhbiBhbHNvIGJlIGFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzXG4gICAqL1xuICBnZXRBdHRyaWJ1dGVzPzpcbiAgICB8IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICB8ICgobWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICB8IGZhbHNlXG4gICAgfCBudWxsXG59KSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gpIHx8IHt9XG4gICAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZVxuICAgICAgY29uc3Qgc3RhcnQgPSByYW5nZS5mcm9tXG4gICAgICBsZXQgZW5kID0gcmFuZ2UudG9cblxuICAgICAgY29uc3QgbmV3Tm9kZSA9IGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzKVxuXG4gICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbWF0Y2hbMF0ubGFzdEluZGV4T2YobWF0Y2hbMV0pXG4gICAgICAgIGxldCBtYXRjaFN0YXJ0ID0gc3RhcnQgKyBvZmZzZXRcblxuICAgICAgICBpZiAobWF0Y2hTdGFydCA+IGVuZCkge1xuICAgICAgICAgIG1hdGNoU3RhcnQgPSBlbmRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmQgPSBtYXRjaFN0YXJ0ICsgbWF0Y2hbMV0ubGVuZ3RoXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbnNlcnQgbGFzdCB0eXBlZCBjaGFyYWN0ZXJcbiAgICAgICAgY29uc3QgbGFzdENoYXIgPSBtYXRjaFswXVttYXRjaFswXS5sZW5ndGggLSAxXVxuXG4gICAgICAgIHRyLmluc2VydFRleHQobGFzdENoYXIsIHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoIC0gMSlcblxuICAgICAgICAvLyBpbnNlcnQgbm9kZSBmcm9tIGlucHV0IHJ1bGVcbiAgICAgICAgdHIucmVwbGFjZVdpdGgobWF0Y2hTdGFydCwgZW5kLCBuZXdOb2RlKVxuICAgICAgfSBlbHNlIGlmIChtYXRjaFswXSkge1xuICAgICAgICB0ci5pbnNlcnQoc3RhcnQgLSAxLCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcykpLmRlbGV0ZShcbiAgICAgICAgICB0ci5tYXBwaW5nLm1hcChzdGFydCksXG4gICAgICAgICAgdHIubWFwcGluZy5tYXAoZW5kKSxcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB0ci5zY3JvbGxJbnRvVmlldygpXG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IElucHV0UnVsZSwgSW5wdXRSdWxlRmluZGVyIH0gZnJvbSAnLi4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBjaGFuZ2VzIHRoZSB0eXBlIG9mIGEgdGV4dGJsb2NrIHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC4gV2hlbiB1c2luZyBhIHJlZ3VsYXIgZXhwcmVzaW9uIHlvdeKAmWxsXG4gKiBwcm9iYWJseSB3YW50IHRoZSByZWdleHAgdG8gc3RhcnQgd2l0aCBgXmAsIHNvIHRoYXQgdGhlIHBhdHRlcm4gY2FuXG4gKiBvbmx5IG9jY3VyIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoY29uZmlnOiB7XG4gIGZpbmQ6IElucHV0UnVsZUZpbmRlclxuICB0eXBlOiBOb2RlVHlwZVxuICBnZXRBdHRyaWJ1dGVzPzpcbiAgICB8IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICB8ICgobWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICB8IGZhbHNlXG4gICAgfCBudWxsXG59KSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGNvbnN0ICRzdGFydCA9IHN0YXRlLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20pXG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKSB8fCB7fVxuXG4gICAgICBpZiAoISRzdGFydC5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkc3RhcnQuaW5kZXgoLTEpLCAkc3RhcnQuaW5kZXhBZnRlcigtMSksIGNvbmZpZy50eXBlKSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBzdGF0ZS50clxuICAgICAgICAuZGVsZXRlKHJhbmdlLmZyb20sIHJhbmdlLnRvKVxuICAgICAgICAuc2V0QmxvY2tUeXBlKHJhbmdlLmZyb20sIHJhbmdlLmZyb20sIGNvbmZpZy50eXBlLCBhdHRyaWJ1dGVzKVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgSW5wdXRSdWxlLCBJbnB1dFJ1bGVGaW5kZXIgfSBmcm9tICcuLi9JbnB1dFJ1bGUuanMnXG5cbi8qKlxuICogQnVpbGQgYW4gaW5wdXQgcnVsZSB0aGF0IHJlcGxhY2VzIHRleHQgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyB0eXBlZCBpbnRvIGl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGV4dElucHV0UnVsZShjb25maWc6IHtcbiAgZmluZDogSW5wdXRSdWxlRmluZGVyLFxuICByZXBsYWNlOiBzdHJpbmcsXG59KSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGxldCBpbnNlcnQgPSBjb25maWcucmVwbGFjZVxuICAgICAgbGV0IHN0YXJ0ID0gcmFuZ2UuZnJvbVxuICAgICAgY29uc3QgZW5kID0gcmFuZ2UudG9cblxuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKVxuXG4gICAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpXG4gICAgICAgIHN0YXJ0ICs9IG9mZnNldFxuXG4gICAgICAgIGNvbnN0IGN1dE9mZiA9IHN0YXJ0IC0gZW5kXG5cbiAgICAgICAgaWYgKGN1dE9mZiA+IDApIHtcbiAgICAgICAgICBpbnNlcnQgPSBtYXRjaFswXS5zbGljZShvZmZzZXQgLSBjdXRPZmYsIG9mZnNldCkgKyBpbnNlcnRcbiAgICAgICAgICBzdGFydCA9IGVuZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IGNhbkpvaW4sIGZpbmRXcmFwcGluZyB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBJbnB1dFJ1bGUsIElucHV0UnVsZUZpbmRlciB9IGZyb20gJy4uL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIGZvciBhdXRvbWF0aWNhbGx5IHdyYXBwaW5nIGEgdGV4dGJsb2NrIHdoZW4gYVxuICogZ2l2ZW4gc3RyaW5nIGlzIHR5cGVkLiBXaGVuIHVzaW5nIGEgcmVndWxhciBleHByZXNpb24geW914oCZbGxcbiAqIHByb2JhYmx5IHdhbnQgdGhlIHJlZ2V4cCB0byBzdGFydCB3aXRoIGBeYCwgc28gdGhhdCB0aGUgcGF0dGVybiBjYW5cbiAqIG9ubHkgb2NjdXIgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuICpcbiAqIGB0eXBlYCBpcyB0aGUgdHlwZSBvZiBub2RlIHRvIHdyYXAgaW4uXG4gKlxuICogQnkgZGVmYXVsdCwgaWYgdGhlcmXigJlzIGEgbm9kZSB3aXRoIHRoZSBzYW1lIHR5cGUgYWJvdmUgdGhlIG5ld2x5XG4gKiB3cmFwcGVkIG5vZGUsIHRoZSBydWxlIHdpbGwgdHJ5IHRvIGpvaW4gdGhvc2VcbiAqIHR3byBub2Rlcy4gWW91IGNhbiBwYXNzIGEgam9pbiBwcmVkaWNhdGUsIHdoaWNoIHRha2VzIGEgcmVndWxhclxuICogZXhwcmVzc2lvbiBtYXRjaCBhbmQgdGhlIG5vZGUgYmVmb3JlIHRoZSB3cmFwcGVkIG5vZGUsIGFuZCBjYW5cbiAqIHJldHVybiBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciBhIGpvaW4gc2hvdWxkIGhhcHBlbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBwaW5nSW5wdXRSdWxlKGNvbmZpZzoge1xuICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXIsXG4gIHR5cGU6IE5vZGVUeXBlLFxuICBrZWVwTWFya3M/OiBib29sZWFuLFxuICBrZWVwQXR0cmlidXRlcz86IGJvb2xlYW4sXG4gIGVkaXRvcj86IEVkaXRvclxuICBnZXRBdHRyaWJ1dGVzPzpcbiAgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIHwgKChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5KSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICB8IGZhbHNlXG4gIHwgbnVsbFxuICAsXG4gIGpvaW5QcmVkaWNhdGU/OiAobWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSwgbm9kZTogUHJvc2VNaXJyb3JOb2RlKSA9PiBib29sZWFuLFxufSkge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHtcbiAgICAgIHN0YXRlLCByYW5nZSwgbWF0Y2gsIGNoYWluLFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gpIHx8IHt9XG4gICAgICBjb25zdCB0ciA9IHN0YXRlLnRyLmRlbGV0ZShyYW5nZS5mcm9tLCByYW5nZS50bylcbiAgICAgIGNvbnN0ICRzdGFydCA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20pXG4gICAgICBjb25zdCBibG9ja1JhbmdlID0gJHN0YXJ0LmJsb2NrUmFuZ2UoKVxuICAgICAgY29uc3Qgd3JhcHBpbmcgPSBibG9ja1JhbmdlICYmIGZpbmRXcmFwcGluZyhibG9ja1JhbmdlLCBjb25maWcudHlwZSwgYXR0cmlidXRlcylcblxuICAgICAgaWYgKCF3cmFwcGluZykge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICB0ci53cmFwKGJsb2NrUmFuZ2UsIHdyYXBwaW5nKVxuXG4gICAgICBpZiAoY29uZmlnLmtlZXBNYXJrcyAmJiBjb25maWcuZWRpdG9yKSB7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGVcbiAgICAgICAgY29uc3QgeyBzcGxpdHRhYmxlTWFya3MgfSA9IGNvbmZpZy5lZGl0b3IuZXh0ZW5zaW9uTWFuYWdlclxuICAgICAgICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSlcblxuICAgICAgICBpZiAobWFya3MpIHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSlcblxuICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb25maWcua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgLyoqIElmIHRoZSBub2RlVHlwZSBpcyBgYnVsbGV0TGlzdGAgb3IgYG9yZGVyZWRMaXN0YCBzZXQgdGhlIGBub2RlVHlwZWAgYXMgYGxpc3RJdGVtYCAqL1xuICAgICAgICBjb25zdCBub2RlVHlwZSA9IGNvbmZpZy50eXBlLm5hbWUgPT09ICdidWxsZXRMaXN0JyB8fCBjb25maWcudHlwZS5uYW1lID09PSAnb3JkZXJlZExpc3QnID8gJ2xpc3RJdGVtJyA6ICd0YXNrTGlzdCdcblxuICAgICAgICBjaGFpbigpLnVwZGF0ZUF0dHJpYnV0ZXMobm9kZVR5cGUsIGF0dHJpYnV0ZXMpLnJ1bigpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJlZm9yZSA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20gLSAxKS5ub2RlQmVmb3JlXG5cbiAgICAgIGlmIChcbiAgICAgICAgYmVmb3JlXG4gICAgICAgICYmIGJlZm9yZS50eXBlID09PSBjb25maWcudHlwZVxuICAgICAgICAmJiBjYW5Kb2luKHRyLmRvYywgcmFuZ2UuZnJvbSAtIDEpXG4gICAgICAgICYmICghY29uZmlnLmpvaW5QcmVkaWNhdGUgfHwgY29uZmlnLmpvaW5QcmVkaWNhdGUobWF0Y2gsIGJlZm9yZSkpXG4gICAgICApIHtcbiAgICAgICAgdHIuam9pbihyYW5nZS5mcm9tIC0gMSlcbiAgICAgIH1cbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7XG4gIERPTU91dHB1dFNwZWMsIE1hcmsgYXMgUHJvc2VNaXJyb3JNYXJrLCBNYXJrU3BlYywgTWFya1R5cGUsXG59IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4sIFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vaGVscGVycy9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IE1hcmtDb25maWcgfSBmcm9tICcuL2luZGV4LmpzJ1xuaW1wb3J0IHsgSW5wdXRSdWxlIH0gZnJvbSAnLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi9Ob2RlLmpzJ1xuaW1wb3J0IHsgUGFzdGVSdWxlIH0gZnJvbSAnLi9QYXN0ZVJ1bGUuanMnXG5pbXBvcnQge1xuICBBbnlDb25maWcsXG4gIEF0dHJpYnV0ZXMsXG4gIEV4dGVuc2lvbnMsXG4gIEdsb2JhbEF0dHJpYnV0ZXMsXG4gIEtleWJvYXJkU2hvcnRjdXRDb21tYW5kLFxuICBQYXJlbnRDb25maWcsXG4gIFJhd0NvbW1hbmRzLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuaW1wb3J0IHsgbWVyZ2VEZWVwIH0gZnJvbSAnLi91dGlsaXRpZXMvbWVyZ2VEZWVwLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgTWFya0NvbmZpZzxPcHRpb25zID0gYW55LCBTdG9yYWdlID0gYW55PiB7XG4gICAgW2tleTogc3RyaW5nXTogYW55XG5cbiAgICAvKipcbiAgICAgKiBOYW1lXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nXG5cbiAgICAvKipcbiAgICAgKiBQcmlvcml0eVxuICAgICAqL1xuICAgIHByaW9yaXR5PzogbnVtYmVyXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IG9wdGlvbnNcbiAgICAgKi9cbiAgICBkZWZhdWx0T3B0aW9ucz86IE9wdGlvbnNcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgT3B0aW9uc1xuICAgICAqL1xuICAgIGFkZE9wdGlvbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBwYXJlbnQ6IEV4Y2x1ZGU8UGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRPcHRpb25zJ10sIHVuZGVmaW5lZD5cbiAgICB9KSA9PiBPcHRpb25zXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IFN0b3JhZ2VcbiAgICAgKi9cbiAgICBhZGRTdG9yYWdlPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgcGFyZW50OiBFeGNsdWRlPFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkU3RvcmFnZSddLCB1bmRlZmluZWQ+XG4gICAgfSkgPT4gU3RvcmFnZVxuXG4gICAgLyoqXG4gICAgICogR2xvYmFsIGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBhZGRHbG9iYWxBdHRyaWJ1dGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEdsb2JhbEF0dHJpYnV0ZXMnXVxuICAgIH0pID0+IEdsb2JhbEF0dHJpYnV0ZXMgfCB7fVxuXG4gICAgLyoqXG4gICAgICogUmF3XG4gICAgICovXG4gICAgYWRkQ29tbWFuZHM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRDb21tYW5kcyddXG4gICAgfSkgPT4gUGFydGlhbDxSYXdDb21tYW5kcz5cblxuICAgIC8qKlxuICAgICAqIEtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAqL1xuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkS2V5Ym9hcmRTaG9ydGN1dHMnXVxuICAgIH0pID0+IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IEtleWJvYXJkU2hvcnRjdXRDb21tYW5kXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5wdXQgcnVsZXNcbiAgICAgKi9cbiAgICBhZGRJbnB1dFJ1bGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkSW5wdXRSdWxlcyddXG4gICAgfSkgPT4gSW5wdXRSdWxlW11cblxuICAgIC8qKlxuICAgICAqIFBhc3RlIHJ1bGVzXG4gICAgICovXG4gICAgYWRkUGFzdGVSdWxlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFBhc3RlUnVsZXMnXVxuICAgIH0pID0+IFBhc3RlUnVsZVtdXG5cbiAgICAvKipcbiAgICAgKiBQcm9zZU1pcnJvciBwbHVnaW5zXG4gICAgICovXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkUHJvc2VNaXJyb3JQbHVnaW5zJ11cbiAgICB9KSA9PiBQbHVnaW5bXVxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5zaW9uc1xuICAgICAqL1xuICAgIGFkZEV4dGVuc2lvbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkRXh0ZW5zaW9ucyddXG4gICAgfSkgPT4gRXh0ZW5zaW9uc1xuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIE5vZGUgU2NoZW1hXG4gICAgICovXG4gICAgZXh0ZW5kTm9kZVNjaGVtYT86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZXh0ZW5kTm9kZVNjaGVtYSddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHRlbnNpb246IE5vZGUsXG4gICAgICAgICkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIE1hcmsgU2NoZW1hXG4gICAgICovXG4gICAgZXh0ZW5kTWFya1NjaGVtYT86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZXh0ZW5kTWFya1NjaGVtYSddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHRlbnNpb246IE1hcmssXG4gICAgICAgICkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBub3QgcmVhZHkgeWV0LlxuICAgICAqL1xuICAgIG9uQmVmb3JlQ3JlYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uQmVmb3JlQ3JlYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyByZWFkeS5cbiAgICAgKi9cbiAgICBvbkNyZWF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkNyZWF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZW50IGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uVXBkYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uVXBkYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdGlvbiBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblNlbGVjdGlvblVwZGF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblNlbGVjdGlvblVwZGF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3Igc3RhdGUgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25UcmFuc2FjdGlvbj86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblRyYW5zYWN0aW9uJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25cbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cbiAgICAgKi9cbiAgICBvbkZvY3VzPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uRm9jdXMnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGV2ZW50OiBGb2N1c0V2ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzbuKAmXQgZm9jdXNlZCBhbnltb3JlLlxuICAgICAqL1xuICAgIG9uQmx1cj86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkJsdXInXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGV2ZW50OiBGb2N1c0V2ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBvbkRlc3Ryb3k/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25EZXN0cm95J11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogS2VlcCBtYXJrIGFmdGVyIHNwbGl0IG5vZGVcbiAgICAgKi9cbiAgICBrZWVwT25TcGxpdD86IGJvb2xlYW4gfCAoKCkgPT4gYm9vbGVhbilcblxuICAgIC8qKlxuICAgICAqIEluY2x1c2l2ZVxuICAgICAqL1xuICAgIGluY2x1c2l2ZT86XG4gICAgICB8IE1hcmtTcGVjWydpbmNsdXNpdmUnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydpbmNsdXNpdmUnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBNYXJrU3BlY1snaW5jbHVzaXZlJ10pXG5cbiAgICAvKipcbiAgICAgKiBFeGNsdWRlc1xuICAgICAqL1xuICAgIGV4Y2x1ZGVzPzpcbiAgICAgIHwgTWFya1NwZWNbJ2V4Y2x1ZGVzJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZXhjbHVkZXMnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBNYXJrU3BlY1snZXhjbHVkZXMnXSlcblxuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoaXMgTWFyayBhcyBleGl0YWJsZVxuICAgICAqL1xuICAgIGV4aXRhYmxlPzogYm9vbGVhbiB8ICgoKSA9PiBib29sZWFuKVxuXG4gICAgLyoqXG4gICAgICogR3JvdXBcbiAgICAgKi9cbiAgICBncm91cD86XG4gICAgICB8IE1hcmtTcGVjWydncm91cCddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2dyb3VwJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTWFya1NwZWNbJ2dyb3VwJ10pXG5cbiAgICAvKipcbiAgICAgKiBTcGFubmluZ1xuICAgICAqL1xuICAgIHNwYW5uaW5nPzpcbiAgICAgIHwgTWFya1NwZWNbJ3NwYW5uaW5nJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnc3Bhbm5pbmcnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBNYXJrU3BlY1snc3Bhbm5pbmcnXSlcblxuICAgIC8qKlxuICAgICAqIENvZGVcbiAgICAgKi9cbiAgICBjb2RlPzpcbiAgICAgIHwgYm9vbGVhblxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wydjb2RlJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gYm9vbGVhbilcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIEhUTUxcbiAgICAgKi9cbiAgICBwYXJzZUhUTUw/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsncGFyc2VIVE1MJ11cbiAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgIH0pID0+IE1hcmtTcGVjWydwYXJzZURPTSddXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgSFRNTFxuICAgICAqL1xuICAgIHJlbmRlckhUTUw/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3JlbmRlckhUTUwnXVxuICAgICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgbWFyazogUHJvc2VNaXJyb3JNYXJrXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gRE9NT3V0cHV0U3BlYylcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlc1xuICAgICAqL1xuICAgIGFkZEF0dHJpYnV0ZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkQXR0cmlidXRlcyddXG4gICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICB9KSA9PiBBdHRyaWJ1dGVzIHwge31cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWFyazxPcHRpb25zID0gYW55LCBTdG9yYWdlID0gYW55PiB7XG4gIHR5cGUgPSAnbWFyaydcblxuICBuYW1lID0gJ21hcmsnXG5cbiAgcGFyZW50OiBNYXJrIHwgbnVsbCA9IG51bGxcblxuICBjaGlsZDogTWFyayB8IG51bGwgPSBudWxsXG5cbiAgb3B0aW9uczogT3B0aW9uc1xuXG4gIHN0b3JhZ2U6IFN0b3JhZ2VcblxuICBjb25maWc6IE1hcmtDb25maWcgPSB7XG4gICAgbmFtZTogdGhpcy5uYW1lLFxuICAgIGRlZmF1bHRPcHRpb25zOiB7fSxcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogUGFydGlhbDxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PiA9IHt9KSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIC4uLmNvbmZpZyxcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lXG5cbiAgICBpZiAoY29uZmlnLmRlZmF1bHRPcHRpb25zKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke3RoaXMubmFtZX1cIi5gLFxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSBgYWRkT3B0aW9uc2AgZmFsbGJhY2tcbiAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0T3B0aW9uc1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmFkZE9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IGNhbGxPclJldHVybihcbiAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRPcHRpb25zJ10+KHRoaXMsICdhZGRPcHRpb25zJywge1xuICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgfSksXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRTdG9yYWdlJ10+KHRoaXMsICdhZGRTdG9yYWdlJywge1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIH0pLFxuICAgICkgfHwge31cbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGU8TyA9IGFueSwgUyA9IGFueT4oY29uZmlnOiBQYXJ0aWFsPE1hcmtDb25maWc8TywgUz4+ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IE1hcms8TywgUz4oY29uZmlnKVxuICB9XG5cbiAgY29uZmlndXJlKG9wdGlvbnM6IFBhcnRpYWw8T3B0aW9ucz4gPSB7fSkge1xuICAgIC8vIHJldHVybiBhIG5ldyBpbnN0YW5jZSBzbyB3ZSBjYW4gdXNlIHRoZSBzYW1lIGV4dGVuc2lvblxuICAgIC8vIHdpdGggZGlmZmVyZW50IGNhbGxzIG9mIGBjb25maWd1cmVgXG4gICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5leHRlbmQoKVxuXG4gICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBtZXJnZURlZXAodGhpcy5vcHRpb25zIGFzIFJlY29yZDxzdHJpbmcsIGFueT4sIG9wdGlvbnMpIGFzIE9wdGlvbnNcblxuICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRTdG9yYWdlJ10+KGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIH0pLFxuICAgIClcblxuICAgIHJldHVybiBleHRlbnNpb25cbiAgfVxuXG4gIGV4dGVuZDxFeHRlbmRlZE9wdGlvbnMgPSBPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2UgPSBTdG9yYWdlPihcbiAgICBleHRlbmRlZENvbmZpZzogUGFydGlhbDxNYXJrQ29uZmlnPEV4dGVuZGVkT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlPj4gPSB7fSxcbiAgKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbmV3IE1hcms8RXh0ZW5kZWRPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2U+KGV4dGVuZGVkQ29uZmlnKVxuXG4gICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXNcblxuICAgIHRoaXMuY2hpbGQgPSBleHRlbnNpb25cblxuICAgIGV4dGVuc2lvbi5uYW1lID0gZXh0ZW5kZWRDb25maWcubmFtZSA/IGV4dGVuZGVkQ29uZmlnLm5hbWUgOiBleHRlbnNpb24ucGFyZW50Lm5hbWVcblxuICAgIGlmIChleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucykge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHtleHRlbnNpb24ubmFtZX1cIi5gLFxuICAgICAgKVxuICAgIH1cblxuICAgIGV4dGVuc2lvbi5vcHRpb25zID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRPcHRpb25zJ10+KGV4dGVuc2lvbiwgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4oZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG5cbiAgc3RhdGljIGhhbmRsZUV4aXQoeyBlZGl0b3IsIG1hcmsgfTogeyBlZGl0b3I6IEVkaXRvcjsgbWFyazogTWFyayB9KSB7XG4gICAgY29uc3QgeyB0ciB9ID0gZWRpdG9yLnN0YXRlXG4gICAgY29uc3QgY3VycmVudFBvcyA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uJGZyb21cbiAgICBjb25zdCBpc0F0RW5kID0gY3VycmVudFBvcy5wb3MgPT09IGN1cnJlbnRQb3MuZW5kKClcblxuICAgIGlmIChpc0F0RW5kKSB7XG4gICAgICBjb25zdCBjdXJyZW50TWFya3MgPSBjdXJyZW50UG9zLm1hcmtzKClcbiAgICAgIGNvbnN0IGlzSW5NYXJrID0gISFjdXJyZW50TWFya3MuZmluZChtID0+IG0/LnR5cGUubmFtZSA9PT0gbWFyay5uYW1lKVxuXG4gICAgICBpZiAoIWlzSW5NYXJrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZW1vdmVNYXJrID0gY3VycmVudE1hcmtzLmZpbmQobSA9PiBtPy50eXBlLm5hbWUgPT09IG1hcmsubmFtZSlcblxuICAgICAgaWYgKHJlbW92ZU1hcmspIHtcbiAgICAgICAgdHIucmVtb3ZlU3RvcmVkTWFyayhyZW1vdmVNYXJrKVxuICAgICAgfVxuICAgICAgdHIuaW5zZXJ0VGV4dCgnICcsIGN1cnJlbnRQb3MucG9zKVxuXG4gICAgICBlZGl0b3Iudmlldy5kaXNwYXRjaCh0cilcblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIERPTU91dHB1dFNwZWMsIE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLCBOb2RlU3BlYywgTm9kZVR5cGUsXG59IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4sIFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vaGVscGVycy9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IE5vZGVDb25maWcgfSBmcm9tICcuL2luZGV4LmpzJ1xuaW1wb3J0IHsgSW5wdXRSdWxlIH0gZnJvbSAnLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgeyBQYXN0ZVJ1bGUgfSBmcm9tICcuL1Bhc3RlUnVsZS5qcydcbmltcG9ydCB7XG4gIEFueUNvbmZpZyxcbiAgQXR0cmlidXRlcyxcbiAgRXh0ZW5zaW9ucyxcbiAgR2xvYmFsQXR0cmlidXRlcyxcbiAgS2V5Ym9hcmRTaG9ydGN1dENvbW1hbmQsXG4gIE5vZGVWaWV3UmVuZGVyZXIsXG4gIFBhcmVudENvbmZpZyxcbiAgUmF3Q29tbWFuZHMsXG59IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5pbXBvcnQgeyBtZXJnZURlZXAgfSBmcm9tICcuL3V0aWxpdGllcy9tZXJnZURlZXAuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIE5vZGVDb25maWc8T3B0aW9ucyA9IGFueSwgU3RvcmFnZSA9IGFueT4ge1xuICAgIFtrZXk6IHN0cmluZ106IGFueVxuXG4gICAgLyoqXG4gICAgICogTmFtZVxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZ1xuXG4gICAgLyoqXG4gICAgICogUHJpb3JpdHlcbiAgICAgKi9cbiAgICBwcmlvcml0eT86IG51bWJlclxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBvcHRpb25zXG4gICAgICovXG4gICAgZGVmYXVsdE9wdGlvbnM/OiBPcHRpb25zXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IE9wdGlvbnNcbiAgICAgKi9cbiAgICBhZGRPcHRpb25zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgcGFyZW50OiBFeGNsdWRlPFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkT3B0aW9ucyddLCB1bmRlZmluZWQ+XG4gICAgfSkgPT4gT3B0aW9uc1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBTdG9yYWdlXG4gICAgICovXG4gICAgYWRkU3RvcmFnZT86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHBhcmVudDogRXhjbHVkZTxQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFN0b3JhZ2UnXSwgdW5kZWZpbmVkPlxuICAgIH0pID0+IFN0b3JhZ2VcblxuICAgIC8qKlxuICAgICAqIEdsb2JhbCBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgYWRkR2xvYmFsQXR0cmlidXRlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRHbG9iYWxBdHRyaWJ1dGVzJ11cbiAgICB9KSA9PiBHbG9iYWxBdHRyaWJ1dGVzIHwge31cblxuICAgIC8qKlxuICAgICAqIFJhd1xuICAgICAqL1xuICAgIGFkZENvbW1hbmRzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkQ29tbWFuZHMnXVxuICAgIH0pID0+IFBhcnRpYWw8UmF3Q29tbWFuZHM+XG5cbiAgICAvKipcbiAgICAgKiBLZXlib2FyZCBzaG9ydGN1dHNcbiAgICAgKi9cbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEtleWJvYXJkU2hvcnRjdXRzJ11cbiAgICB9KSA9PiB7XG4gICAgICBba2V5OiBzdHJpbmddOiBLZXlib2FyZFNob3J0Y3V0Q29tbWFuZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElucHV0IHJ1bGVzXG4gICAgICovXG4gICAgYWRkSW5wdXRSdWxlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZElucHV0UnVsZXMnXVxuICAgIH0pID0+IElucHV0UnVsZVtdXG5cbiAgICAvKipcbiAgICAgKiBQYXN0ZSBydWxlc1xuICAgICAqL1xuICAgIGFkZFBhc3RlUnVsZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRQYXN0ZVJ1bGVzJ11cbiAgICB9KSA9PiBQYXN0ZVJ1bGVbXVxuXG4gICAgLyoqXG4gICAgICogUHJvc2VNaXJyb3IgcGx1Z2luc1xuICAgICAqL1xuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFByb3NlTWlycm9yUGx1Z2lucyddXG4gICAgfSkgPT4gUGx1Z2luW11cblxuICAgIC8qKlxuICAgICAqIEV4dGVuc2lvbnNcbiAgICAgKi9cbiAgICBhZGRFeHRlbnNpb25zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEV4dGVuc2lvbnMnXVxuICAgIH0pID0+IEV4dGVuc2lvbnNcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBOb2RlIFNjaGVtYVxuICAgICAqL1xuICAgIGV4dGVuZE5vZGVTY2hlbWE/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4dGVuZE5vZGVTY2hlbWEnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXh0ZW5zaW9uOiBOb2RlLFxuICAgICAgICApID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBNYXJrIFNjaGVtYVxuICAgICAqL1xuICAgIGV4dGVuZE1hcmtTY2hlbWE/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4dGVuZE1hcmtTY2hlbWEnXVxuICAgICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHRlbnNpb246IE5vZGUsXG4gICAgICAgICkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBub3QgcmVhZHkgeWV0LlxuICAgICAqL1xuICAgIG9uQmVmb3JlQ3JlYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uQmVmb3JlQ3JlYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyByZWFkeS5cbiAgICAgKi9cbiAgICBvbkNyZWF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkNyZWF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZW50IGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uVXBkYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uVXBkYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdGlvbiBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblNlbGVjdGlvblVwZGF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblNlbGVjdGlvblVwZGF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3Igc3RhdGUgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25UcmFuc2FjdGlvbj86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblRyYW5zYWN0aW9uJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25cbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cbiAgICAgKi9cbiAgICBvbkZvY3VzPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uRm9jdXMnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGV2ZW50OiBGb2N1c0V2ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzbuKAmXQgZm9jdXNlZCBhbnltb3JlLlxuICAgICAqL1xuICAgIG9uQmx1cj86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkJsdXInXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGV2ZW50OiBGb2N1c0V2ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBvbkRlc3Ryb3k/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25EZXN0cm95J11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogTm9kZSBWaWV3XG4gICAgICovXG4gICAgYWRkTm9kZVZpZXc/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkTm9kZVZpZXcnXVxuICAgICAgICB9KSA9PiBOb2RlVmlld1JlbmRlcmVyKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUb3BOb2RlXG4gICAgICovXG4gICAgdG9wTm9kZT86IGJvb2xlYW5cblxuICAgIC8qKlxuICAgICAqIENvbnRlbnRcbiAgICAgKi9cbiAgICBjb250ZW50PzpcbiAgICAgIHwgTm9kZVNwZWNbJ2NvbnRlbnQnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wydjb250ZW50J11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2NvbnRlbnQnXSlcblxuICAgIC8qKlxuICAgICAqIE1hcmtzXG4gICAgICovXG4gICAgbWFya3M/OlxuICAgICAgfCBOb2RlU3BlY1snbWFya3MnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydtYXJrcyddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydtYXJrcyddKVxuXG4gICAgLyoqXG4gICAgICogR3JvdXBcbiAgICAgKi9cbiAgICBncm91cD86XG4gICAgICB8IE5vZGVTcGVjWydncm91cCddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2dyb3VwJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2dyb3VwJ10pXG5cbiAgICAvKipcbiAgICAgKiBJbmxpbmVcbiAgICAgKi9cbiAgICBpbmxpbmU/OlxuICAgICAgfCBOb2RlU3BlY1snaW5saW5lJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnaW5saW5lJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2lubGluZSddKVxuXG4gICAgLyoqXG4gICAgICogQXRvbVxuICAgICAqL1xuICAgIGF0b20/OlxuICAgICAgfCBOb2RlU3BlY1snYXRvbSddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2F0b20nXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snYXRvbSddKVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0YWJsZVxuICAgICAqL1xuICAgIHNlbGVjdGFibGU/OlxuICAgICAgfCBOb2RlU3BlY1snc2VsZWN0YWJsZSddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3NlbGVjdGFibGUnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snc2VsZWN0YWJsZSddKVxuXG4gICAgLyoqXG4gICAgICogRHJhZ2dhYmxlXG4gICAgICovXG4gICAgZHJhZ2dhYmxlPzpcbiAgICAgIHwgTm9kZVNwZWNbJ2RyYWdnYWJsZSddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2RyYWdnYWJsZSddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydkcmFnZ2FibGUnXSlcblxuICAgIC8qKlxuICAgICAqIENvZGVcbiAgICAgKi9cbiAgICBjb2RlPzpcbiAgICAgIHwgTm9kZVNwZWNbJ2NvZGUnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wydjb2RlJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2NvZGUnXSlcblxuICAgIC8qKlxuICAgICAqIFdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICB3aGl0ZXNwYWNlPzpcbiAgICAgIHwgTm9kZVNwZWNbJ3doaXRlc3BhY2UnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wyd3aGl0ZXNwYWNlJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ3doaXRlc3BhY2UnXSlcblxuICAgIC8qKlxuICAgICAqIERlZmluaW5nXG4gICAgICovXG4gICAgZGVmaW5pbmc/OlxuICAgICAgfCBOb2RlU3BlY1snZGVmaW5pbmcnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydkZWZpbmluZyddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydkZWZpbmluZyddKVxuXG4gICAgLyoqXG4gICAgICogSXNvbGF0aW5nXG4gICAgICovXG4gICAgaXNvbGF0aW5nPzpcbiAgICAgIHwgTm9kZVNwZWNbJ2lzb2xhdGluZyddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2lzb2xhdGluZyddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydpc29sYXRpbmcnXSlcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIEhUTUxcbiAgICAgKi9cbiAgICBwYXJzZUhUTUw/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsncGFyc2VIVE1MJ11cbiAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgIH0pID0+IE5vZGVTcGVjWydwYXJzZURPTSddXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgSFRNTFxuICAgICAqL1xuICAgIHJlbmRlckhUTUw/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3JlbmRlckhUTUwnXVxuICAgICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgbm9kZTogUHJvc2VNaXJyb3JOb2RlXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gRE9NT3V0cHV0U3BlYylcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIFRleHRcbiAgICAgKi9cbiAgICByZW5kZXJUZXh0PzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydyZW5kZXJUZXh0J11cbiAgICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIG5vZGU6IFByb3NlTWlycm9yTm9kZVxuICAgICAgICAgICAgcG9zOiBudW1iZXJcbiAgICAgICAgICAgIHBhcmVudDogUHJvc2VNaXJyb3JOb2RlXG4gICAgICAgICAgICBpbmRleDogbnVtYmVyXG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiBzdHJpbmcpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIEFkZCBBdHRyaWJ1dGVzXG4gICAgICovXG4gICAgYWRkQXR0cmlidXRlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRBdHRyaWJ1dGVzJ11cbiAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgIH0pID0+IEF0dHJpYnV0ZXMgfCB7fVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBOb2RlPE9wdGlvbnMgPSBhbnksIFN0b3JhZ2UgPSBhbnk+IHtcbiAgdHlwZSA9ICdub2RlJ1xuXG4gIG5hbWUgPSAnbm9kZSdcblxuICBwYXJlbnQ6IE5vZGUgfCBudWxsID0gbnVsbFxuXG4gIGNoaWxkOiBOb2RlIHwgbnVsbCA9IG51bGxcblxuICBvcHRpb25zOiBPcHRpb25zXG5cbiAgc3RvcmFnZTogU3RvcmFnZVxuXG4gIGNvbmZpZzogTm9kZUNvbmZpZyA9IHtcbiAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgZGVmYXVsdE9wdGlvbnM6IHt9LFxuICB9XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBQYXJ0aWFsPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+ID0ge30pIHtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgLi4uY29uZmlnLFxuICAgIH1cblxuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uZmlnLm5hbWVcblxuICAgIGlmIChjb25maWcuZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7dGhpcy5uYW1lfVwiLmAsXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGBhZGRPcHRpb25zYCBmYWxsYmFja1xuICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuY29uZmlnLmRlZmF1bHRPcHRpb25zXG5cbiAgICBpZiAodGhpcy5jb25maWcuYWRkT3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gY2FsbE9yUmV0dXJuKFxuICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZE9wdGlvbnMnXT4odGhpcywgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4odGhpcywgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKSB8fCB7fVxuICB9XG5cbiAgc3RhdGljIGNyZWF0ZTxPID0gYW55LCBTID0gYW55Pihjb25maWc6IFBhcnRpYWw8Tm9kZUNvbmZpZzxPLCBTPj4gPSB7fSkge1xuICAgIHJldHVybiBuZXcgTm9kZTxPLCBTPihjb25maWcpXG4gIH1cblxuICBjb25maWd1cmUob3B0aW9uczogUGFydGlhbDxPcHRpb25zPiA9IHt9KSB7XG4gICAgLy8gcmV0dXJuIGEgbmV3IGluc3RhbmNlIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgZXh0ZW5zaW9uXG4gICAgLy8gd2l0aCBkaWZmZXJlbnQgY2FsbHMgb2YgYGNvbmZpZ3VyZWBcbiAgICBjb25zdCBleHRlbnNpb24gPSB0aGlzLmV4dGVuZCgpXG5cbiAgICBleHRlbnNpb24ub3B0aW9ucyA9IG1lcmdlRGVlcCh0aGlzLm9wdGlvbnMgYXMgUmVjb3JkPHN0cmluZywgYW55Piwgb3B0aW9ucykgYXMgT3B0aW9uc1xuXG4gICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4oZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG5cbiAgZXh0ZW5kPEV4dGVuZGVkT3B0aW9ucyA9IE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZSA9IFN0b3JhZ2U+KFxuICAgIGV4dGVuZGVkQ29uZmlnOiBQYXJ0aWFsPE5vZGVDb25maWc8RXh0ZW5kZWRPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2U+PiA9IHt9LFxuICApIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSBuZXcgTm9kZTxFeHRlbmRlZE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZT4oZXh0ZW5kZWRDb25maWcpXG5cbiAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpc1xuXG4gICAgdGhpcy5jaGlsZCA9IGV4dGVuc2lvblxuXG4gICAgZXh0ZW5zaW9uLm5hbWUgPSBleHRlbmRlZENvbmZpZy5uYW1lID8gZXh0ZW5kZWRDb25maWcubmFtZSA6IGV4dGVuc2lvbi5wYXJlbnQubmFtZVxuXG4gICAgaWYgKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke2V4dGVuc2lvbi5uYW1lfVwiLmAsXG4gICAgICApXG4gICAgfVxuXG4gICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZE9wdGlvbnMnXT4oZXh0ZW5zaW9uLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPihleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICByZXR1cm4gZXh0ZW5zaW9uXG4gIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNBbmRyb2lkKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gbmF2aWdhdG9yLnBsYXRmb3JtID09PSAnQW5kcm9pZCcgfHwgL2FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBOb2RlVmlldyBhcyBQcm9zZU1pcnJvck5vZGVWaWV3IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3J1xuXG5pbXBvcnQgeyBFZGl0b3IgYXMgQ29yZUVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4vTm9kZS5qcydcbmltcG9ydCB7IERlY29yYXRpb25XaXRoVHlwZSwgTm9kZVZpZXdSZW5kZXJlck9wdGlvbnMsIE5vZGVWaWV3UmVuZGVyZXJQcm9wcyB9IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBpc0FuZHJvaWQgfSBmcm9tICcuL3V0aWxpdGllcy9pc0FuZHJvaWQuanMnXG5pbXBvcnQgeyBpc2lPUyB9IGZyb20gJy4vdXRpbGl0aWVzL2lzaU9TLmpzJ1xuXG5leHBvcnQgY2xhc3MgTm9kZVZpZXc8XG4gIENvbXBvbmVudCxcbiAgTm9kZUVkaXRvciBleHRlbmRzIENvcmVFZGl0b3IgPSBDb3JlRWRpdG9yLFxuICBPcHRpb25zIGV4dGVuZHMgTm9kZVZpZXdSZW5kZXJlck9wdGlvbnMgPSBOb2RlVmlld1JlbmRlcmVyT3B0aW9ucyxcbj4gaW1wbGVtZW50cyBQcm9zZU1pcnJvck5vZGVWaWV3IHtcbiAgY29tcG9uZW50OiBDb21wb25lbnRcblxuICBlZGl0b3I6IE5vZGVFZGl0b3JcblxuICBvcHRpb25zOiBPcHRpb25zXG5cbiAgZXh0ZW5zaW9uOiBOb2RlXG5cbiAgbm9kZTogUHJvc2VNaXJyb3JOb2RlXG5cbiAgZGVjb3JhdGlvbnM6IERlY29yYXRpb25XaXRoVHlwZVtdXG5cbiAgZ2V0UG9zOiBhbnlcblxuICBpc0RyYWdnaW5nID0gZmFsc2VcblxuICBjb25zdHJ1Y3Rvcihjb21wb25lbnQ6IENvbXBvbmVudCwgcHJvcHM6IE5vZGVWaWV3UmVuZGVyZXJQcm9wcywgb3B0aW9ucz86IFBhcnRpYWw8T3B0aW9ucz4pIHtcbiAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudFxuICAgIHRoaXMuZWRpdG9yID0gcHJvcHMuZWRpdG9yIGFzIE5vZGVFZGl0b3JcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBzdG9wRXZlbnQ6IG51bGwsXG4gICAgICBpZ25vcmVNdXRhdGlvbjogbnVsbCxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSBhcyBPcHRpb25zXG4gICAgdGhpcy5leHRlbnNpb24gPSBwcm9wcy5leHRlbnNpb25cbiAgICB0aGlzLm5vZGUgPSBwcm9wcy5ub2RlXG4gICAgdGhpcy5kZWNvcmF0aW9ucyA9IHByb3BzLmRlY29yYXRpb25zIGFzIERlY29yYXRpb25XaXRoVHlwZVtdXG4gICAgdGhpcy5nZXRQb3MgPSBwcm9wcy5nZXRQb3NcbiAgICB0aGlzLm1vdW50KClcbiAgfVxuXG4gIG1vdW50KCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHJldHVyblxuICB9XG5cbiAgZ2V0IGRvbSgpOiBIVE1MRWxlbWVudCB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yLnZpZXcuZG9tIGFzIEhUTUxFbGVtZW50XG4gIH1cblxuICBnZXQgY29udGVudERPTSgpOiBIVE1MRWxlbWVudCB8IG51bGwge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBvbkRyYWdTdGFydChldmVudDogRHJhZ0V2ZW50KSB7XG4gICAgY29uc3QgeyB2aWV3IH0gPSB0aGlzLmVkaXRvclxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudFxuXG4gICAgLy8gZ2V0IHRoZSBkcmFnIGhhbmRsZSBlbGVtZW50XG4gICAgLy8gYGNsb3Nlc3RgIGlzIG5vdCBhdmFpbGFibGUgZm9yIHRleHQgbm9kZXMgc28gd2UgbWF5IGhhdmUgdG8gdXNlIGl0cyBwYXJlbnRcbiAgICBjb25zdCBkcmFnSGFuZGxlID0gdGFyZ2V0Lm5vZGVUeXBlID09PSAzXG4gICAgICA/IHRhcmdldC5wYXJlbnRFbGVtZW50Py5jbG9zZXN0KCdbZGF0YS1kcmFnLWhhbmRsZV0nKVxuICAgICAgOiB0YXJnZXQuY2xvc2VzdCgnW2RhdGEtZHJhZy1oYW5kbGVdJylcblxuICAgIGlmICghdGhpcy5kb20gfHwgdGhpcy5jb250ZW50RE9NPy5jb250YWlucyh0YXJnZXQpIHx8ICFkcmFnSGFuZGxlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgeCA9IDBcbiAgICBsZXQgeSA9IDBcblxuICAgIC8vIGNhbGN1bGF0ZSBvZmZzZXQgZm9yIGRyYWcgZWxlbWVudCBpZiB3ZSB1c2UgYSBkaWZmZXJlbnQgZHJhZyBoYW5kbGUgZWxlbWVudFxuICAgIGlmICh0aGlzLmRvbSAhPT0gZHJhZ0hhbmRsZSkge1xuICAgICAgY29uc3QgZG9tQm94ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIGNvbnN0IGhhbmRsZUJveCA9IGRyYWdIYW5kbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICAgICAgLy8gSW4gUmVhY3QsIHdlIGhhdmUgdG8gZ28gdGhyb3VnaCBuYXRpdmVFdmVudCB0byByZWFjaCBvZmZzZXRYL29mZnNldFkuXG4gICAgICBjb25zdCBvZmZzZXRYID0gZXZlbnQub2Zmc2V0WCA/PyAoZXZlbnQgYXMgYW55KS5uYXRpdmVFdmVudD8ub2Zmc2V0WFxuICAgICAgY29uc3Qgb2Zmc2V0WSA9IGV2ZW50Lm9mZnNldFkgPz8gKGV2ZW50IGFzIGFueSkubmF0aXZlRXZlbnQ/Lm9mZnNldFlcblxuICAgICAgeCA9IGhhbmRsZUJveC54IC0gZG9tQm94LnggKyBvZmZzZXRYXG4gICAgICB5ID0gaGFuZGxlQm94LnkgLSBkb21Cb3gueSArIG9mZnNldFlcbiAgICB9XG5cbiAgICBldmVudC5kYXRhVHJhbnNmZXI/LnNldERyYWdJbWFnZSh0aGlzLmRvbSwgeCwgeSlcblxuICAgIC8vIHdlIG5lZWQgdG8gdGVsbCBQcm9zZU1pcnJvciB0aGF0IHdlIHdhbnQgdG8gbW92ZSB0aGUgd2hvbGUgbm9kZVxuICAgIC8vIHNvIHdlIGNyZWF0ZSBhIE5vZGVTZWxlY3Rpb25cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgdGhpcy5nZXRQb3MoKSlcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbilcblxuICAgIHZpZXcuZGlzcGF0Y2godHJhbnNhY3Rpb24pXG4gIH1cblxuICBzdG9wRXZlbnQoZXZlbnQ6IEV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmRvbSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuc3RvcEV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnN0b3BFdmVudCh7IGV2ZW50IH0pXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50XG4gICAgY29uc3QgaXNJbkVsZW1lbnQgPSB0aGlzLmRvbS5jb250YWlucyh0YXJnZXQpICYmICF0aGlzLmNvbnRlbnRET00/LmNvbnRhaW5zKHRhcmdldClcblxuICAgIC8vIGFueSBldmVudCBmcm9tIGNoaWxkIG5vZGVzIHNob3VsZCBiZSBoYW5kbGVkIGJ5IFByb3NlTWlycm9yXG4gICAgaWYgKCFpc0luRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgaXNEcmFnRXZlbnQgPSBldmVudC50eXBlLnN0YXJ0c1dpdGgoJ2RyYWcnKVxuICAgIGNvbnN0IGlzRHJvcEV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ2Ryb3AnXG4gICAgY29uc3QgaXNJbnB1dCA9IFsnSU5QVVQnLCAnQlVUVE9OJywgJ1NFTEVDVCcsICdURVhUQVJFQSddLmluY2x1ZGVzKHRhcmdldC50YWdOYW1lKSB8fCB0YXJnZXQuaXNDb250ZW50RWRpdGFibGVcblxuICAgIC8vIGFueSBpbnB1dCBldmVudCB3aXRoaW4gbm9kZSB2aWV3cyBzaG91bGQgYmUgaWdub3JlZCBieSBQcm9zZU1pcnJvclxuICAgIGlmIChpc0lucHV0ICYmICFpc0Ryb3BFdmVudCAmJiAhaXNEcmFnRXZlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgeyBpc0VkaXRhYmxlIH0gPSB0aGlzLmVkaXRvclxuICAgIGNvbnN0IHsgaXNEcmFnZ2luZyB9ID0gdGhpc1xuICAgIGNvbnN0IGlzRHJhZ2dhYmxlID0gISF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZVxuICAgIGNvbnN0IGlzU2VsZWN0YWJsZSA9IE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKHRoaXMubm9kZSlcbiAgICBjb25zdCBpc0NvcHlFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdjb3B5J1xuICAgIGNvbnN0IGlzUGFzdGVFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdwYXN0ZSdcbiAgICBjb25zdCBpc0N1dEV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ2N1dCdcbiAgICBjb25zdCBpc0NsaWNrRXZlbnQgPSBldmVudC50eXBlID09PSAnbW91c2Vkb3duJ1xuXG4gICAgLy8gUHJvc2VNaXJyb3IgdHJpZXMgdG8gZHJhZyBzZWxlY3RhYmxlIG5vZGVzXG4gICAgLy8gZXZlbiBpZiBgZHJhZ2dhYmxlYCBpcyBzZXQgdG8gYGZhbHNlYFxuICAgIC8vIHRoaXMgZml4IHByZXZlbnRzIHRoYXRcbiAgICBpZiAoIWlzRHJhZ2dhYmxlICYmIGlzU2VsZWN0YWJsZSAmJiBpc0RyYWdFdmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIH1cblxuICAgIGlmIChpc0RyYWdnYWJsZSAmJiBpc0RyYWdFdmVudCAmJiAhaXNEcmFnZ2luZykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gd2UgaGF2ZSB0byBzdG9yZSB0aGF0IGRyYWdnaW5nIHN0YXJ0ZWRcbiAgICBpZiAoaXNEcmFnZ2FibGUgJiYgaXNFZGl0YWJsZSAmJiAhaXNEcmFnZ2luZyAmJiBpc0NsaWNrRXZlbnQpIHtcbiAgICAgIGNvbnN0IGRyYWdIYW5kbGUgPSB0YXJnZXQuY2xvc2VzdCgnW2RhdGEtZHJhZy1oYW5kbGVdJylcbiAgICAgIGNvbnN0IGlzVmFsaWREcmFnSGFuZGxlID0gZHJhZ0hhbmRsZSAmJiAodGhpcy5kb20gPT09IGRyYWdIYW5kbGUgfHwgdGhpcy5kb20uY29udGFpbnMoZHJhZ0hhbmRsZSkpXG5cbiAgICAgIGlmIChpc1ZhbGlkRHJhZ0hhbmRsZSkge1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlXG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAnZHJhZ2VuZCcsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgb25jZTogdHJ1ZSB9LFxuICAgICAgICApXG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAnZHJvcCcsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgb25jZTogdHJ1ZSB9LFxuICAgICAgICApXG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAnbW91c2V1cCcsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgb25jZTogdHJ1ZSB9LFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhlc2UgZXZlbnRzIGFyZSBoYW5kbGVkIGJ5IHByb3NlbWlycm9yXG4gICAgaWYgKFxuICAgICAgaXNEcmFnZ2luZ1xuICAgICAgfHwgaXNEcm9wRXZlbnRcbiAgICAgIHx8IGlzQ29weUV2ZW50XG4gICAgICB8fCBpc1Bhc3RlRXZlbnRcbiAgICAgIHx8IGlzQ3V0RXZlbnRcbiAgICAgIHx8IChpc0NsaWNrRXZlbnQgJiYgaXNTZWxlY3RhYmxlKVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uOiBNdXRhdGlvblJlY29yZCB8IHsgdHlwZTogJ3NlbGVjdGlvbic7IHRhcmdldDogRWxlbWVudCB9KSB7XG4gICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmlnbm9yZU11dGF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlnbm9yZU11dGF0aW9uKHsgbXV0YXRpb24gfSlcbiAgICB9XG5cbiAgICAvLyBhIGxlYWYvYXRvbSBub2RlIGlzIGxpa2UgYSBibGFjayBib3ggZm9yIFByb3NlTWlycm9yXG4gICAgLy8gYW5kIHNob3VsZCBiZSBmdWxseSBoYW5kbGVkIGJ5IHRoZSBub2RlIHZpZXdcbiAgICBpZiAodGhpcy5ub2RlLmlzTGVhZiB8fCB0aGlzLm5vZGUuaXNBdG9tKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIFByb3NlTWlycm9yIHNob3VsZCBoYW5kbGUgYW55IHNlbGVjdGlvbnNcbiAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ3NlbGVjdGlvbicpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIHRyeSB0byBwcmV2ZW50IGEgYnVnIG9uIGlPUyBhbmQgQW5kcm9pZCB0aGF0IHdpbGwgYnJlYWsgbm9kZSB2aWV3cyBvbiBlbnRlclxuICAgIC8vIHRoaXMgaXMgYmVjYXVzZSBQcm9zZU1pcnJvciBjYW7igJl0IHByZXZlbnREaXNwYXRjaCBvbiBlbnRlclxuICAgIC8vIHRoaXMgd2lsbCBsZWFkIHRvIGEgcmUtcmVuZGVyIG9mIHRoZSBub2RlIHZpZXcgb24gZW50ZXJcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMTIxNFxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8yNTM0XG4gICAgaWYgKFxuICAgICAgdGhpcy5kb20uY29udGFpbnMobXV0YXRpb24udGFyZ2V0KVxuICAgICAgJiYgbXV0YXRpb24udHlwZSA9PT0gJ2NoaWxkTGlzdCdcbiAgICAgICYmIChpc2lPUygpIHx8IGlzQW5kcm9pZCgpKVxuICAgICAgJiYgdGhpcy5lZGl0b3IuaXNGb2N1c2VkXG4gICAgKSB7XG4gICAgICBjb25zdCBjaGFuZ2VkTm9kZXMgPSBbXG4gICAgICAgIC4uLkFycmF5LmZyb20obXV0YXRpb24uYWRkZWROb2RlcyksXG4gICAgICAgIC4uLkFycmF5LmZyb20obXV0YXRpb24ucmVtb3ZlZE5vZGVzKSxcbiAgICAgIF0gYXMgSFRNTEVsZW1lbnRbXVxuXG4gICAgICAvLyB3ZeKAmWxsIGNoZWNrIGlmIGV2ZXJ5IGNoYW5nZWQgbm9kZSBpcyBjb250ZW50RWRpdGFibGVcbiAgICAgIC8vIHRvIG1ha2Ugc3VyZSBpdOKAmXMgcHJvYmFibHkgbXV0YXRlZCBieSBQcm9zZU1pcnJvclxuICAgICAgaWYgKGNoYW5nZWROb2Rlcy5ldmVyeShub2RlID0+IG5vZGUuaXNDb250ZW50RWRpdGFibGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHdlIHdpbGwgYWxsb3cgbXV0YXRpb24gY29udGVudERPTSB3aXRoIGF0dHJpYnV0ZXNcbiAgICAvLyBzbyB3ZSBjYW4gZm9yIGV4YW1wbGUgYWRkaW5nIGNsYXNzZXMgd2l0aGluIG91ciBub2RlIHZpZXdcbiAgICBpZiAodGhpcy5jb250ZW50RE9NID09PSBtdXRhdGlvbi50YXJnZXQgJiYgbXV0YXRpb24udHlwZSA9PT0gJ2F0dHJpYnV0ZXMnKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIFByb3NlTWlycm9yIHNob3VsZCBoYW5kbGUgYW55IGNoYW5nZXMgd2l0aGluIGNvbnRlbnRET01cbiAgICBpZiAodGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB1cGRhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXM6IHt9KSB7XG4gICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICBjb25zdCBwb3MgPSB0aGlzLmdldFBvcygpXG5cbiAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB1bmRlZmluZWQsIHtcbiAgICAgICAgLi4udGhpcy5ub2RlLmF0dHJzLFxuICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KVxuICB9XG5cbiAgZGVsZXRlTm9kZSgpOiB2b2lkIHtcbiAgICBjb25zdCBmcm9tID0gdGhpcy5nZXRQb3MoKVxuICAgIGNvbnN0IHRvID0gZnJvbSArIHRoaXMubm9kZS5ub2RlU2l6ZVxuXG4gICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuZGVsZXRlUmFuZ2UoeyBmcm9tLCB0byB9KVxuICB9XG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXRNYXJrc0JldHdlZW4gfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtzQmV0d2Vlbi5qcydcbmltcG9ydCB7IFBhc3RlUnVsZSwgUGFzdGVSdWxlRmluZGVyIH0gZnJvbSAnLi4vUGFzdGVSdWxlLmpzJ1xuaW1wb3J0IHsgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIHBhc3RlIHJ1bGUgdGhhdCBhZGRzIGEgbWFyayB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHBhc3RlZCBpbnRvIGl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFya1Bhc3RlUnVsZShjb25maWc6IHtcbiAgZmluZDogUGFzdGVSdWxlRmluZGVyXG4gIHR5cGU6IE1hcmtUeXBlXG4gIGdldEF0dHJpYnV0ZXM/OlxuICAgIHwgUmVjb3JkPHN0cmluZywgYW55PlxuICAgIHwgKChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5KSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgIHwgZmFsc2VcbiAgICB8IG51bGxcbn0pIHtcbiAgcmV0dXJuIG5ldyBQYXN0ZVJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaClcblxuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGVcbiAgICAgIGNvbnN0IGNhcHR1cmVHcm91cCA9IG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdXG4gICAgICBjb25zdCBmdWxsTWF0Y2ggPSBtYXRjaFswXVxuICAgICAgbGV0IG1hcmtFbmQgPSByYW5nZS50b1xuXG4gICAgICBpZiAoY2FwdHVyZUdyb3VwKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0U3BhY2VzID0gZnVsbE1hdGNoLnNlYXJjaCgvXFxTLylcbiAgICAgICAgY29uc3QgdGV4dFN0YXJ0ID0gcmFuZ2UuZnJvbSArIGZ1bGxNYXRjaC5pbmRleE9mKGNhcHR1cmVHcm91cClcbiAgICAgICAgY29uc3QgdGV4dEVuZCA9IHRleHRTdGFydCArIGNhcHR1cmVHcm91cC5sZW5ndGhcblxuICAgICAgICBjb25zdCBleGNsdWRlZE1hcmtzID0gZ2V0TWFya3NCZXR3ZWVuKHJhbmdlLmZyb20sIHJhbmdlLnRvLCBzdGF0ZS5kb2MpXG4gICAgICAgICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gaXRlbS5tYXJrLnR5cGUuZXhjbHVkZWQgYXMgTWFya1R5cGVbXVxuXG4gICAgICAgICAgICByZXR1cm4gZXhjbHVkZWQuZmluZCh0eXBlID0+IHR5cGUgPT09IGNvbmZpZy50eXBlICYmIHR5cGUgIT09IGl0ZW0ubWFyay50eXBlKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0udG8gPiB0ZXh0U3RhcnQpXG5cbiAgICAgICAgaWYgKGV4Y2x1ZGVkTWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0RW5kIDwgcmFuZ2UudG8pIHtcbiAgICAgICAgICB0ci5kZWxldGUodGV4dEVuZCwgcmFuZ2UudG8pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dFN0YXJ0ID4gcmFuZ2UuZnJvbSkge1xuICAgICAgICAgIHRyLmRlbGV0ZShyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIHRleHRTdGFydClcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtFbmQgPSByYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMgKyBjYXB0dXJlR3JvdXAubGVuZ3RoXG5cbiAgICAgICAgdHIuYWRkTWFyayhyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIG1hcmtFbmQsIGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzIHx8IHt9KSlcblxuICAgICAgICB0ci5yZW1vdmVTdG9yZWRNYXJrKGNvbmZpZy50eXBlKVxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG4iLCAiLy8gc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjk2OTQ4NlxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUZvclJlZ0V4KHN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJylcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWU6IGFueSk6IHZhbHVlIGlzIHN0cmluZyB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBQYXN0ZVJ1bGUsIFBhc3RlUnVsZUZpbmRlciB9IGZyb20gJy4uL1Bhc3RlUnVsZS5qcydcbmltcG9ydCB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2luZGV4LmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIHBhc3RlIHJ1bGUgdGhhdCBhZGRzIGEgbm9kZSB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHBhc3RlZCBpbnRvIGl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9kZVBhc3RlUnVsZShjb25maWc6IHtcbiAgZmluZDogUGFzdGVSdWxlRmluZGVyXG4gIHR5cGU6IE5vZGVUeXBlXG4gIGdldEF0dHJpYnV0ZXM/OlxuICAgIHwgUmVjb3JkPHN0cmluZywgYW55PlxuICAgIHwgKChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5KSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgIHwgZmFsc2VcbiAgICB8IG51bGxcbn0pIHtcbiAgcmV0dXJuIG5ldyBQYXN0ZVJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXIoeyBtYXRjaCwgY2hhaW4sIHJhbmdlIH0pIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gpXG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzID09PSBmYWxzZSB8fCBhdHRyaWJ1dGVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaC5pbnB1dCkge1xuICAgICAgICBjaGFpbigpLmRlbGV0ZVJhbmdlKHJhbmdlKS5pbnNlcnRDb250ZW50QXQocmFuZ2UuZnJvbSwge1xuICAgICAgICAgIHR5cGU6IGNvbmZpZy50eXBlLm5hbWUsXG4gICAgICAgICAgYXR0cnM6IGF0dHJpYnV0ZXMsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBQYXN0ZVJ1bGUsIFBhc3RlUnVsZUZpbmRlciB9IGZyb20gJy4uL1Bhc3RlUnVsZS5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBwYXN0ZSBydWxlIHRoYXQgcmVwbGFjZXMgdGV4dCB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHBhc3RlZCBpbnRvIGl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGV4dFBhc3RlUnVsZShjb25maWc6IHtcbiAgZmluZDogUGFzdGVSdWxlRmluZGVyLFxuICByZXBsYWNlOiBzdHJpbmcsXG59KSB7XG4gIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGxldCBpbnNlcnQgPSBjb25maWcucmVwbGFjZVxuICAgICAgbGV0IHN0YXJ0ID0gcmFuZ2UuZnJvbVxuICAgICAgY29uc3QgZW5kID0gcmFuZ2UudG9cblxuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKVxuXG4gICAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpXG4gICAgICAgIHN0YXJ0ICs9IG9mZnNldFxuXG4gICAgICAgIGNvbnN0IGN1dE9mZiA9IHN0YXJ0IC0gZW5kXG5cbiAgICAgICAgaWYgKGN1dE9mZiA+IDApIHtcbiAgICAgICAgICBpbnNlcnQgPSBtYXRjaFswXS5zbGljZShvZmZzZXQgLSBjdXRPZmYsIG9mZnNldCkgKyBpbnNlcnRcbiAgICAgICAgICBzdGFydCA9IGVuZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYWNrZXJSZXN1bHQge1xuICBwb3NpdGlvbjogbnVtYmVyXG4gIGRlbGV0ZWQ6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIFRyYWNrZXIge1xuICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25cblxuICBjdXJyZW50U3RlcDogbnVtYmVyXG5cbiAgY29uc3RydWN0b3IodHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uXG4gICAgdGhpcy5jdXJyZW50U3RlcCA9IHRoaXMudHJhbnNhY3Rpb24uc3RlcHMubGVuZ3RoXG4gIH1cblxuICBtYXAocG9zaXRpb246IG51bWJlcik6IFRyYWNrZXJSZXN1bHQge1xuICAgIGxldCBkZWxldGVkID0gZmFsc2VcblxuICAgIGNvbnN0IG1hcHBlZFBvc2l0aW9uID0gdGhpcy50cmFuc2FjdGlvbi5zdGVwc1xuICAgICAgLnNsaWNlKHRoaXMuY3VycmVudFN0ZXApXG4gICAgICAucmVkdWNlKChuZXdQb3NpdGlvbiwgc3RlcCkgPT4ge1xuICAgICAgICBjb25zdCBtYXBSZXN1bHQgPSBzdGVwLmdldE1hcCgpLm1hcFJlc3VsdChuZXdQb3NpdGlvbilcblxuICAgICAgICBpZiAobWFwUmVzdWx0LmRlbGV0ZWQpIHtcbiAgICAgICAgICBkZWxldGVkID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcFJlc3VsdC5wb3NcbiAgICAgIH0sIHBvc2l0aW9uKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiBtYXBwZWRQb3NpdGlvbixcbiAgICAgIGRlbGV0ZWQsXG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFRleHRBbGlnbk9wdGlvbnMge1xuICB0eXBlczogc3RyaW5nW10sXG4gIGFsaWdubWVudHM6IHN0cmluZ1tdLFxuICBkZWZhdWx0QWxpZ25tZW50OiBzdHJpbmcsXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB0ZXh0QWxpZ246IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IHRoZSB0ZXh0IGFsaWduIGF0dHJpYnV0ZVxuICAgICAgICovXG4gICAgICBzZXRUZXh0QWxpZ246IChhbGlnbm1lbnQ6IHN0cmluZykgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVW5zZXQgdGhlIHRleHQgYWxpZ24gYXR0cmlidXRlXG4gICAgICAgKi9cbiAgICAgIHVuc2V0VGV4dEFsaWduOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgVGV4dEFsaWduID0gRXh0ZW5zaW9uLmNyZWF0ZTxUZXh0QWxpZ25PcHRpb25zPih7XG4gIG5hbWU6ICd0ZXh0QWxpZ24nLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGVzOiBbXSxcbiAgICAgIGFsaWdubWVudHM6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnLCAnanVzdGlmeSddLFxuICAgICAgZGVmYXVsdEFsaWdubWVudDogJ2xlZnQnLFxuICAgIH1cbiAgfSxcblxuICBhZGRHbG9iYWxBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHR5cGVzOiB0aGlzLm9wdGlvbnMudHlwZXMsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICB0ZXh0QWxpZ246IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRoaXMub3B0aW9ucy5kZWZhdWx0QWxpZ25tZW50LFxuICAgICAgICAgICAgcGFyc2VIVE1MOiBlbGVtZW50ID0+IGVsZW1lbnQuc3R5bGUudGV4dEFsaWduIHx8IHRoaXMub3B0aW9ucy5kZWZhdWx0QWxpZ25tZW50LFxuICAgICAgICAgICAgcmVuZGVySFRNTDogYXR0cmlidXRlcyA9PiB7XG4gICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLnRleHRBbGlnbiA9PT0gdGhpcy5vcHRpb25zLmRlZmF1bHRBbGlnbm1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge31cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiB7IHN0eWxlOiBgdGV4dC1hbGlnbjogJHthdHRyaWJ1dGVzLnRleHRBbGlnbn1gIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRUZXh0QWxpZ246IChhbGlnbm1lbnQ6IHN0cmluZykgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGlnbm1lbnRzLmluY2x1ZGVzKGFsaWdubWVudCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZXMuZXZlcnkodHlwZSA9PiBjb21tYW5kcy51cGRhdGVBdHRyaWJ1dGVzKHR5cGUsIHsgdGV4dEFsaWduOiBhbGlnbm1lbnQgfSkpXG4gICAgICB9LFxuXG4gICAgICB1bnNldFRleHRBbGlnbjogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGVzLmV2ZXJ5KHR5cGUgPT4gY29tbWFuZHMucmVzZXRBdHRyaWJ1dGVzKHR5cGUsICd0ZXh0QWxpZ24nKSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLVNoaWZ0LWwnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRUZXh0QWxpZ24oJ2xlZnQnKSxcbiAgICAgICdNb2QtU2hpZnQtZSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldFRleHRBbGlnbignY2VudGVyJyksXG4gICAgICAnTW9kLVNoaWZ0LXInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRUZXh0QWxpZ24oJ3JpZ2h0JyksXG4gICAgICAnTW9kLVNoaWZ0LWonOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRUZXh0QWxpZ24oJ2p1c3RpZnknKSxcbiAgICB9XG4gIH0sXG59KVxuIiwgImltcG9ydCB7IE1hcmssIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBVbmRlcmxpbmVPcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB1bmRlcmxpbmU6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGFuIHVuZGVybGluZSBtYXJrXG4gICAgICAgKi9cbiAgICAgIHNldFVuZGVybGluZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGFuIHVuZGVybGluZSBtYXJrXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZVVuZGVybGluZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVW5zZXQgYW4gdW5kZXJsaW5lIG1hcmtcbiAgICAgICAqL1xuICAgICAgdW5zZXRVbmRlcmxpbmU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBVbmRlcmxpbmUgPSBNYXJrLmNyZWF0ZTxVbmRlcmxpbmVPcHRpb25zPih7XG4gIG5hbWU6ICd1bmRlcmxpbmUnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ3UnLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6ICd0ZXh0LWRlY29yYXRpb24nLFxuICAgICAgICBjb25zdW1pbmc6IGZhbHNlLFxuICAgICAgICBnZXRBdHRyczogc3R5bGUgPT4gKChzdHlsZSBhcyBzdHJpbmcpLmluY2x1ZGVzKCd1bmRlcmxpbmUnKSA/IHt9IDogZmFsc2UpLFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWyd1JywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRVbmRlcmxpbmU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZVVuZGVybGluZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdW5zZXRVbmRlcmxpbmU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC11JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlVW5kZXJsaW5lKCksXG4gICAgICAnTW9kLVUnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVVbmRlcmxpbmUoKSxcbiAgICB9XG4gIH0sXG59KVxuIiwgImltcG9ydCB7IEV4dGVuc2lvbiwgdGV4dElucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBUeXBvZ3JhcGh5T3B0aW9ucyB7XG4gIGVtRGFzaDogZmFsc2UgfCBzdHJpbmcsXG4gIGVsbGlwc2lzOiBmYWxzZSB8IHN0cmluZyxcbiAgb3BlbkRvdWJsZVF1b3RlOiBmYWxzZSB8IHN0cmluZyxcbiAgY2xvc2VEb3VibGVRdW90ZTogZmFsc2UgfCBzdHJpbmcsXG4gIG9wZW5TaW5nbGVRdW90ZTogZmFsc2UgfCBzdHJpbmcsXG4gIGNsb3NlU2luZ2xlUXVvdGU6IGZhbHNlIHwgc3RyaW5nLFxuICBsZWZ0QXJyb3c6IGZhbHNlIHwgc3RyaW5nLFxuICByaWdodEFycm93OiBmYWxzZSB8IHN0cmluZyxcbiAgY29weXJpZ2h0OiBmYWxzZSB8IHN0cmluZyxcbiAgdHJhZGVtYXJrOiBmYWxzZSB8IHN0cmluZyxcbiAgc2VydmljZW1hcms6IGZhbHNlIHwgc3RyaW5nLFxuICByZWdpc3RlcmVkVHJhZGVtYXJrOiBmYWxzZSB8IHN0cmluZyxcbiAgb25lSGFsZjogZmFsc2UgfCBzdHJpbmcsXG4gIHBsdXNNaW51czogZmFsc2UgfCBzdHJpbmcsXG4gIG5vdEVxdWFsOiBmYWxzZSB8IHN0cmluZyxcbiAgbGFxdW86IGZhbHNlIHwgc3RyaW5nLFxuICByYXF1bzogZmFsc2UgfCBzdHJpbmcsXG4gIG11bHRpcGxpY2F0aW9uOiBmYWxzZSB8IHN0cmluZyxcbiAgc3VwZXJzY3JpcHRUd286IGZhbHNlIHwgc3RyaW5nLFxuICBzdXBlcnNjcmlwdFRocmVlOiBmYWxzZSB8IHN0cmluZyxcbiAgb25lUXVhcnRlcjogZmFsc2UgfCBzdHJpbmcsXG4gIHRocmVlUXVhcnRlcnM6IGZhbHNlIHwgc3RyaW5nLFxufVxuXG5leHBvcnQgY29uc3QgZW1EYXNoID0gKG92ZXJyaWRlPzogc3RyaW5nKSA9PiB0ZXh0SW5wdXRSdWxlKHtcbiAgZmluZDogLy0tJC8sXG4gIHJlcGxhY2U6IG92ZXJyaWRlID8/ICfigJQnLFxufSlcblxuZXhwb3J0IGNvbnN0IGVsbGlwc2lzID0gKG92ZXJyaWRlPzogc3RyaW5nKSA9PiB0ZXh0SW5wdXRSdWxlKHtcbiAgZmluZDogL1xcLlxcLlxcLiQvLFxuICByZXBsYWNlOiBvdmVycmlkZSA/PyAn4oCmJyxcbn0pXG5cbmV4cG9ydCBjb25zdCBvcGVuRG91YmxlUXVvdGUgPSAob3ZlcnJpZGU/OiBzdHJpbmcpID0+IHRleHRJbnB1dFJ1bGUoe1xuICBmaW5kOiAvKD86XnxbXFxze1soPCdcIlxcdTIwMThcXHUyMDFDXSkoXCIpJC8sXG4gIHJlcGxhY2U6IG92ZXJyaWRlID8/ICfigJwnLFxufSlcblxuZXhwb3J0IGNvbnN0IGNsb3NlRG91YmxlUXVvdGUgPSAob3ZlcnJpZGU/OiBzdHJpbmcpID0+IHRleHRJbnB1dFJ1bGUoe1xuICBmaW5kOiAvXCIkLyxcbiAgcmVwbGFjZTogb3ZlcnJpZGUgPz8gJ+KAnScsXG59KVxuXG5leHBvcnQgY29uc3Qgb3BlblNpbmdsZVF1b3RlID0gKG92ZXJyaWRlPzogc3RyaW5nKSA9PiB0ZXh0SW5wdXRSdWxlKHtcbiAgZmluZDogLyg/Ol58W1xcc3tbKDwnXCJcXHUyMDE4XFx1MjAxQ10pKCcpJC8sXG4gIHJlcGxhY2U6IG92ZXJyaWRlID8/ICfigJgnLFxufSlcblxuZXhwb3J0IGNvbnN0IGNsb3NlU2luZ2xlUXVvdGUgPSAob3ZlcnJpZGU/OiBzdHJpbmcpID0+IHRleHRJbnB1dFJ1bGUoe1xuICBmaW5kOiAvJyQvLFxuICByZXBsYWNlOiBvdmVycmlkZSA/PyAn4oCZJyxcbn0pXG5cbmV4cG9ydCBjb25zdCBsZWZ0QXJyb3cgPSAob3ZlcnJpZGU/OiBzdHJpbmcpID0+IHRleHRJbnB1dFJ1bGUoe1xuICBmaW5kOiAvPC0kLyxcbiAgcmVwbGFjZTogb3ZlcnJpZGUgPz8gJ+KGkCcsXG59KVxuXG5leHBvcnQgY29uc3QgcmlnaHRBcnJvdyA9IChvdmVycmlkZT86IHN0cmluZykgPT4gdGV4dElucHV0UnVsZSh7XG4gIGZpbmQ6IC8tPiQvLFxuICByZXBsYWNlOiBvdmVycmlkZSA/PyAn4oaSJyxcbn0pXG5cbmV4cG9ydCBjb25zdCBjb3B5cmlnaHQgPSAob3ZlcnJpZGU/OiBzdHJpbmcpID0+IHRleHRJbnB1dFJ1bGUoe1xuICBmaW5kOiAvXFwoY1xcKSQvLFxuICByZXBsYWNlOiBvdmVycmlkZSA/PyAnwqknLFxufSlcblxuZXhwb3J0IGNvbnN0IHRyYWRlbWFyayA9IChvdmVycmlkZT86IHN0cmluZykgPT4gdGV4dElucHV0UnVsZSh7XG4gIGZpbmQ6IC9cXCh0bVxcKSQvLFxuICByZXBsYWNlOiBvdmVycmlkZSA/PyAn4oSiJyxcbn0pXG5cbmV4cG9ydCBjb25zdCBzZXJ2aWNlbWFyayA9IChvdmVycmlkZT86IHN0cmluZykgPT4gdGV4dElucHV0UnVsZSh7XG4gIGZpbmQ6IC9cXChzbVxcKSQvLFxuICByZXBsYWNlOiBvdmVycmlkZSA/PyAn4oSgJyxcbn0pXG5cbmV4cG9ydCBjb25zdCByZWdpc3RlcmVkVHJhZGVtYXJrID0gKG92ZXJyaWRlPzogc3RyaW5nKSA9PiB0ZXh0SW5wdXRSdWxlKHtcbiAgZmluZDogL1xcKHJcXCkkLyxcbiAgcmVwbGFjZTogb3ZlcnJpZGUgPz8gJ8KuJyxcbn0pXG5cbmV4cG9ydCBjb25zdCBvbmVIYWxmID0gKG92ZXJyaWRlPzogc3RyaW5nKSA9PiB0ZXh0SW5wdXRSdWxlKHtcbiAgZmluZDogLyg/Ol58XFxzKSgxXFwvMikkLyxcbiAgcmVwbGFjZTogb3ZlcnJpZGUgPz8gJ8K9Jyxcbn0pXG5cbmV4cG9ydCBjb25zdCBwbHVzTWludXMgPSAob3ZlcnJpZGU/OiBzdHJpbmcpID0+IHRleHRJbnB1dFJ1bGUoe1xuICBmaW5kOiAvXFwrXFwvLSQvLFxuICByZXBsYWNlOiBvdmVycmlkZSA/PyAnwrEnLFxufSlcblxuZXhwb3J0IGNvbnN0IG5vdEVxdWFsID0gKG92ZXJyaWRlPzogc3RyaW5nKSA9PiB0ZXh0SW5wdXRSdWxlKHtcbiAgZmluZDogLyE9JC8sXG4gIHJlcGxhY2U6IG92ZXJyaWRlID8/ICfiiaAnLFxufSlcblxuZXhwb3J0IGNvbnN0IGxhcXVvID0gKG92ZXJyaWRlPzogc3RyaW5nKSA9PiB0ZXh0SW5wdXRSdWxlKHtcbiAgZmluZDogLzw8JC8sXG4gIHJlcGxhY2U6IG92ZXJyaWRlID8/ICfCqycsXG59KVxuXG5leHBvcnQgY29uc3QgcmFxdW8gPSAob3ZlcnJpZGU/OiBzdHJpbmcpID0+IHRleHRJbnB1dFJ1bGUoe1xuICBmaW5kOiAvPj4kLyxcbiAgcmVwbGFjZTogb3ZlcnJpZGUgPz8gJ8K7Jyxcbn0pXG5cbmV4cG9ydCBjb25zdCBtdWx0aXBsaWNhdGlvbiA9IChvdmVycmlkZT86IHN0cmluZykgPT4gdGV4dElucHV0UnVsZSh7XG4gIGZpbmQ6IC9cXGQrXFxzPyhbKnhdKVxccz9cXGQrJC8sXG4gIHJlcGxhY2U6IG92ZXJyaWRlID8/ICfDlycsXG59KVxuXG5leHBvcnQgY29uc3Qgc3VwZXJzY3JpcHRUd28gPSAob3ZlcnJpZGU/OiBzdHJpbmcpID0+IHRleHRJbnB1dFJ1bGUoe1xuICBmaW5kOiAvXFxeMiQvLFxuICByZXBsYWNlOiBvdmVycmlkZSA/PyAnwrInLFxufSlcblxuZXhwb3J0IGNvbnN0IHN1cGVyc2NyaXB0VGhyZWUgPSAob3ZlcnJpZGU/OiBzdHJpbmcpID0+IHRleHRJbnB1dFJ1bGUoe1xuICBmaW5kOiAvXFxeMyQvLFxuICByZXBsYWNlOiBvdmVycmlkZSA/PyAnwrMnLFxufSlcblxuZXhwb3J0IGNvbnN0IG9uZVF1YXJ0ZXIgPSAob3ZlcnJpZGU/OiBzdHJpbmcpID0+IHRleHRJbnB1dFJ1bGUoe1xuICBmaW5kOiAvKD86XnxcXHMpKDFcXC80KSQvLFxuICByZXBsYWNlOiBvdmVycmlkZSA/PyAnwrwnLFxufSlcblxuZXhwb3J0IGNvbnN0IHRocmVlUXVhcnRlcnMgPSAob3ZlcnJpZGU/OiBzdHJpbmcpID0+IHRleHRJbnB1dFJ1bGUoe1xuICBmaW5kOiAvKD86XnxcXHMpKDNcXC80KSQvLFxuICByZXBsYWNlOiBvdmVycmlkZSA/PyAnwr4nLFxufSlcblxuZXhwb3J0IGNvbnN0IFR5cG9ncmFwaHkgPSBFeHRlbnNpb24uY3JlYXRlPFR5cG9ncmFwaHlPcHRpb25zPih7XG4gIG5hbWU6ICd0eXBvZ3JhcGh5JyxcblxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIGNvbnN0IHJ1bGVzID0gW11cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZW1EYXNoICE9PSBmYWxzZSkge1xuICAgICAgcnVsZXMucHVzaChlbURhc2godGhpcy5vcHRpb25zLmVtRGFzaCkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lbGxpcHNpcyAhPT0gZmFsc2UpIHtcbiAgICAgIHJ1bGVzLnB1c2goZWxsaXBzaXModGhpcy5vcHRpb25zLmVsbGlwc2lzKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9wZW5Eb3VibGVRdW90ZSAhPT0gZmFsc2UpIHtcbiAgICAgIHJ1bGVzLnB1c2gob3BlbkRvdWJsZVF1b3RlKHRoaXMub3B0aW9ucy5vcGVuRG91YmxlUXVvdGUpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VEb3VibGVRdW90ZSAhPT0gZmFsc2UpIHtcbiAgICAgIHJ1bGVzLnB1c2goY2xvc2VEb3VibGVRdW90ZSh0aGlzLm9wdGlvbnMuY2xvc2VEb3VibGVRdW90ZSkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vcGVuU2luZ2xlUXVvdGUgIT09IGZhbHNlKSB7XG4gICAgICBydWxlcy5wdXNoKG9wZW5TaW5nbGVRdW90ZSh0aGlzLm9wdGlvbnMub3BlblNpbmdsZVF1b3RlKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlU2luZ2xlUXVvdGUgIT09IGZhbHNlKSB7XG4gICAgICBydWxlcy5wdXNoKGNsb3NlU2luZ2xlUXVvdGUodGhpcy5vcHRpb25zLmNsb3NlU2luZ2xlUXVvdGUpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMubGVmdEFycm93ICE9PSBmYWxzZSkge1xuICAgICAgcnVsZXMucHVzaChsZWZ0QXJyb3codGhpcy5vcHRpb25zLmxlZnRBcnJvdykpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yaWdodEFycm93ICE9PSBmYWxzZSkge1xuICAgICAgcnVsZXMucHVzaChyaWdodEFycm93KHRoaXMub3B0aW9ucy5yaWdodEFycm93KSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNvcHlyaWdodCAhPT0gZmFsc2UpIHtcbiAgICAgIHJ1bGVzLnB1c2goY29weXJpZ2h0KHRoaXMub3B0aW9ucy5jb3B5cmlnaHQpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudHJhZGVtYXJrICE9PSBmYWxzZSkge1xuICAgICAgcnVsZXMucHVzaCh0cmFkZW1hcmsodGhpcy5vcHRpb25zLnRyYWRlbWFyaykpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zZXJ2aWNlbWFyayAhPT0gZmFsc2UpIHtcbiAgICAgIHJ1bGVzLnB1c2goc2VydmljZW1hcmsodGhpcy5vcHRpb25zLnNlcnZpY2VtYXJrKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJlZ2lzdGVyZWRUcmFkZW1hcmsgIT09IGZhbHNlKSB7XG4gICAgICBydWxlcy5wdXNoKHJlZ2lzdGVyZWRUcmFkZW1hcmsodGhpcy5vcHRpb25zLnJlZ2lzdGVyZWRUcmFkZW1hcmspKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMub25lSGFsZiAhPT0gZmFsc2UpIHtcbiAgICAgIHJ1bGVzLnB1c2gob25lSGFsZih0aGlzLm9wdGlvbnMub25lSGFsZikpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wbHVzTWludXMgIT09IGZhbHNlKSB7XG4gICAgICBydWxlcy5wdXNoKHBsdXNNaW51cyh0aGlzLm9wdGlvbnMucGx1c01pbnVzKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm5vdEVxdWFsICE9PSBmYWxzZSkge1xuICAgICAgcnVsZXMucHVzaChub3RFcXVhbCh0aGlzLm9wdGlvbnMubm90RXF1YWwpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMubGFxdW8gIT09IGZhbHNlKSB7XG4gICAgICBydWxlcy5wdXNoKGxhcXVvKHRoaXMub3B0aW9ucy5sYXF1bykpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yYXF1byAhPT0gZmFsc2UpIHtcbiAgICAgIHJ1bGVzLnB1c2gocmFxdW8odGhpcy5vcHRpb25zLnJhcXVvKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm11bHRpcGxpY2F0aW9uICE9PSBmYWxzZSkge1xuICAgICAgcnVsZXMucHVzaChtdWx0aXBsaWNhdGlvbih0aGlzLm9wdGlvbnMubXVsdGlwbGljYXRpb24pKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc3VwZXJzY3JpcHRUd28gIT09IGZhbHNlKSB7XG4gICAgICBydWxlcy5wdXNoKHN1cGVyc2NyaXB0VHdvKHRoaXMub3B0aW9ucy5zdXBlcnNjcmlwdFR3bykpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zdXBlcnNjcmlwdFRocmVlICE9PSBmYWxzZSkge1xuICAgICAgcnVsZXMucHVzaChzdXBlcnNjcmlwdFRocmVlKHRoaXMub3B0aW9ucy5zdXBlcnNjcmlwdFRocmVlKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9uZVF1YXJ0ZXIgIT09IGZhbHNlKSB7XG4gICAgICBydWxlcy5wdXNoKG9uZVF1YXJ0ZXIodGhpcy5vcHRpb25zLm9uZVF1YXJ0ZXIpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudGhyZWVRdWFydGVycyAhPT0gZmFsc2UpIHtcbiAgICAgIHJ1bGVzLnB1c2godGhyZWVRdWFydGVycyh0aGlzLm9wdGlvbnMudGhyZWVRdWFydGVycykpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGVzXG4gIH0sXG59KVxuIiwgImV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckV4dGVuc2lvbihpZCwgY2FsbGJhY2spe1xuICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlkIGNhbid0IGJlIHVuZGVmaW5lZCB3aGVuIHJlZ2lzdGVyaW5nIGFuIGV4dGVuc2lvblwiKTtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FsbGJhY2sgY2FuJ3QgYmUgdW5kZWZpbmVkIHdoZW4gcmVnaXN0ZXJpbmcgYW4gZXh0ZW5zaW9uXCIpO1xuICAgIH1cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiYWxwaW5lOmluaXRcIiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBleHQgPSBjYWxsYmFjayh3aW5kb3cudGFsbHRhcFJlZ2lzdHJ5LmdldENvbmZpZyhpZCkpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleHQpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV4dEVsZW1lbnQgb2YgZXh0KSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnRhbGx0YXBSZWdpc3RyeS5yZWdpc3RlcihleHRFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy50YWxsdGFwUmVnaXN0cnkucmVnaXN0ZXIoZXh0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnViYmxlTWVudVJlZihkaXNwbGF5Q29uZGl0aW9uID0gdW5kZWZpbmVkKXtcbiAgICByZXR1cm4ge1xuICAgICAgICBlZGl0b3JSZWY6IHVuZGVmaW5lZCxcbiAgICAgICAgc2hvdzogIWRpc3BsYXlDb25kaXRpb24sXG4gICAgICAgIGluaXRUYWxsdGFwKCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JSZWYgPSB0aGlzLiRlbC5wYXJlbnRFbGVtZW50LmRhdGFzZXQuZWRpdG9yO1xuICAgICAgICAgICAgdGhpcy5ldmFsdWF0ZUlmU2hvd2luZygpO1xuICAgICAgICB9LFxuICAgICAgICBldmFsdWF0ZUlmU2hvd2luZygpe1xuICAgICAgICAgICAgaWYgKCFkaXNwbGF5Q29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zaG93ID0gdGhpcy5nZXRFZGl0b3IoKS5pc0FjdGl2ZShkaXNwbGF5Q29uZGl0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5ldmFsdWF0ZUlmU2hvd2luZygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RWRpdG9yKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEVkaXRvcigpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cudGFsbHRhcFt0aGlzLmVkaXRvclJlZl07XG4gICAgICAgIH0sXG4gICAgICAgICdidWJibGVNZW51UmVmJzoge1xuICAgICAgICAgICAgWyd4LWluaXQnXSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRUYWxsdGFwKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgWyd4LXNob3cnXSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaG93O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFsneC1vbjp1cGRhdGUud2luZG93J10oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmFsdWF0ZUlmU2hvd2luZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH1cbn0iLCAiaW1wb3J0IFRleHRBbGlnbiBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tdGV4dC1hbGlnblwiO1xuaW1wb3J0IFVuZGVybGluZSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tdW5kZXJsaW5lXCI7XG5pbXBvcnQgVHlwb2dyYXBoeSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tdHlwb2dyYXBoeVwiO1xuaW1wb3J0IHtyZWdpc3RlckV4dGVuc2lvbn0gZnJvbSBcIi4uLy4uLy4uL3N1cHBvcnQvcmVzb3VyY2VzL2pzL3V0aWxzLmpzXCI7XG5cbnJlZ2lzdGVyRXh0ZW5zaW9uKCdzdGFydGVyLWtpdCcsICgpID0+IFtcbiAgICBUZXh0QWxpZ24uY29uZmlndXJlKHt0eXBlczogW1wiaGVhZGluZ1wiLCBcInBhcmFncmFwaFwiXX0pLFxuICAgIFVuZGVybGluZSxcbiAgICBUeXBvZ3JhcGh5XG5dKTsiXSwKICAibWFwcGluZ3MiOiAiOztBQUVBLFdBQVMsY0FBYyxHQUFHLEdBQUcsS0FBSztBQUM5QixhQUFTLElBQUksS0FBSSxLQUFLO0FBQ2xCLFVBQUksS0FBSyxFQUFFLGNBQWMsS0FBSyxFQUFFO0FBQzVCLGVBQU8sRUFBRSxjQUFjLEVBQUUsYUFBYSxPQUFPO0FBQ2pELFVBQUksU0FBUyxFQUFFLE1BQU0sQ0FBQyxHQUFHLFNBQVMsRUFBRSxNQUFNLENBQUM7QUFDM0MsVUFBSSxVQUFVLFFBQVE7QUFDbEIsZUFBTyxPQUFPO0FBQ2Q7QUFBQSxNQUNKO0FBQ0EsVUFBSSxDQUFDLE9BQU8sV0FBVyxNQUFNO0FBQ3pCLGVBQU87QUFDWCxVQUFJLE9BQU8sVUFBVSxPQUFPLFFBQVEsT0FBTyxNQUFNO0FBQzdDLGlCQUFTLElBQUksR0FBRyxPQUFPLEtBQUssQ0FBQyxLQUFLLE9BQU8sS0FBSyxDQUFDLEdBQUc7QUFDOUM7QUFDSixlQUFPO0FBQUEsTUFDWDtBQUNBLFVBQUksT0FBTyxRQUFRLFFBQVEsT0FBTyxRQUFRLE1BQU07QUFDNUMsWUFBSSxRQUFRLGNBQWMsT0FBTyxTQUFTLE9BQU8sU0FBUyxNQUFNLENBQUM7QUFDakUsWUFBSSxTQUFTO0FBQ1QsaUJBQU87QUFBQSxNQUNmO0FBQ0EsYUFBTyxPQUFPO0FBQUEsSUFDbEI7QUFBQSxFQUNKO0FBQ0EsV0FBUyxZQUFZLEdBQUcsR0FBRyxNQUFNLE1BQU07QUFDbkMsYUFBUyxLQUFLLEVBQUUsWUFBWSxLQUFLLEVBQUUsZ0JBQWM7QUFDN0MsVUFBSSxNQUFNLEtBQUssTUFBTTtBQUNqQixlQUFPLE1BQU0sS0FBSyxPQUFPLEVBQUUsR0FBRyxNQUFNLEdBQUcsS0FBSztBQUNoRCxVQUFJLFNBQVMsRUFBRSxNQUFNLEVBQUUsRUFBRSxHQUFHLFNBQVMsRUFBRSxNQUFNLEVBQUUsRUFBRSxHQUFHLE9B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QSxNQUN2QztBQUFBLElBQ0osQ0FBQztBQUFBLEVBQ0w7OztBQ1pBLG9CQUFrQixlQUFlLE1BQU07QUFBQSxJQUNuQyxVQUFVLFVBQVUsRUFBQyxPQUFPLENBQUMsV0FBVyxXQUFXLEVBQUMsQ0FBQztBQUFBLElBQ3JEO0FBQUEsSUFDQTtBQUFBLEVBQ0osQ0FBQzsiLAogICJuYW1lcyI6IFsiZmlyc3QiLCAiY29weSIsICJmb3VuZCIsICJmb3VuZCIsICJpIiwgInR5cGUiLCAibmZhIiwgImVkZ2UiLCAiZXhwciIsICJub2RlIiwgInN0YXRlcyIsICJmb3VuZCIsICJjb3B5IiwgImRlbCIsICJwYXJlbnQiLCAiaW5kZXgiLCAiam9pbmFibGUiLCAiZmlyc3QiLCAibWF0Y2hlcyIsICJtYXRjaCIsICJ0eXBlIiwgImNsb3NlIiwgIlRyYW5zZm9ybUVycm9yIiwgImZvdW5kIiwgImZpcnN0IiwgImNvbW1hbmRzIiwgImZvdW5kIiwgImZpcnN0IiwgImNvbW1hbmQiLCAicmFuZ2UiLCAiY29tbWFuZHMiLCAiY3JlYXRlUGFyYWdyYXBoTmVhciIsICJvcmlnaW5hbENyZWF0ZVBhcmFncmFwaE5lYXIiLCAiZGVsZXRlU2VsZWN0aW9uIiwgIm9yaWdpbmFsRGVsZXRlU2VsZWN0aW9uIiwgImV4aXRDb2RlIiwgIm9yaWdpbmFsRXhpdENvZGUiLCAia2V5cyIsICJzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCIsICJqb2luVXAiLCAib3JpZ2luYWxKb2luVXAiLCAiam9pbkRvd24iLCAib3JpZ2luYWxKb2luRG93biIsICJqb2luQmFja3dhcmQiLCAib3JpZ2luYWxKb2luQmFja3dhcmQiLCAiam9pbkZvcndhcmQiLCAib3JpZ2luYWxKb2luRm9yd2FyZCIsICJsaWZ0IiwgIm9yaWdpbmFsTGlmdCIsICJsaWZ0RW1wdHlCbG9jayIsICJvcmlnaW5hbExpZnRFbXB0eUJsb2NrIiwgImxpZnRMaXN0SXRlbSIsICJvcmlnaW5hbExpZnRMaXN0SXRlbSIsICJuZXdsaW5lSW5Db2RlIiwgIm9yaWdpbmFsTmV3bGluZUluQ29kZSIsICJzZWxlY3RBbGwiLCAic2VsZWN0Tm9kZUJhY2t3YXJkIiwgIm9yaWdpbmFsU2VsZWN0Tm9kZUJhY2t3YXJkIiwgInNlbGVjdE5vZGVGb3J3YXJkIiwgIm9yaWdpbmFsU2VsZWN0Tm9kZUZvcndhcmQiLCAic2VsZWN0UGFyZW50Tm9kZSIsICJvcmlnaW5hbFNlbGVjdFBhcmVudE5vZGUiLCAic2VsZWN0VGV4dGJsb2NrRW5kIiwgIm9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrRW5kIiwgInNlbGVjdFRleHRibG9ja1N0YXJ0IiwgIm9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrU3RhcnQiLCAiZG9jdW1lbnQiLCAiZGVmYXVsdEJsb2NrQXQiLCAicmFuZ2UiLCAiY29tbWFuZHMiLCAic2lua0xpc3RJdGVtIiwgIm9yaWdpbmFsU2lua0xpc3RJdGVtIiwgInNwbGl0QmxvY2siLCAiZGVmYXVsdEJsb2NrQXQiLCAiZmlyc3QiLCAibmV3TmV4dFR5cGVBdHRyaWJ1dGVzIiwgIm5leHRUeXBlIiwgIndyYXBJbiIsICJvcmlnaW5hbFdyYXBJbiIsICJ3cmFwSW5MaXN0IiwgIm9yaWdpbmFsV3JhcEluTGlzdCIsICJNYXJrIiwgImNvbW1hbmRzIiwgIk1hcmsiLCAiY29tbWFuZHMiXQp9Cg==
